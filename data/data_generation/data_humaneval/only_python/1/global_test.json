[{"instruction": "def emit(self, action, payload=None, retry=0):\n        \"\"\"Emit action with payload.\n\n        :param action: an action slug\n        :param payload: data, default {}\n        :param retry: integer, default 0.\n        :return: information in form of dict.\n        \"\"\"\n", "input": "", "output": "        payload = payload or {}\n\n        if retry:\n            _retry = self.transport.retry(retry)\n            emit = _retry(self.transport.emit)\n        else:\n            emit = self.transport.emit\n\n        return emit(action, payload)", "category": "Python"}, {"instruction": "def get_all_external_link(self, **kwargs):  # noqa: E501\n        \"\"\"Get all external links for a customer  # noqa: E501\n\n          # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_all_external_link(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param int offset:\n        :param int limit:\n        :return: ResponseContainerPagedExternalLink\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n", "input": "", "output": "        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async_req'):\n            return self.get_all_external_link_with_http_info(**kwargs)  # noqa: E501\n        else:\n            (data) = self.get_all_external_link_with_http_info(**kwargs)  # noqa: E501\n            return data", "category": "Python"}, {"instruction": "def b64encode(s, altchars=None):\n    \"\"\"Encode bytes using the standard Base64 alphabet.\n\n    Argument ``s`` is a :term:`bytes-like object` to encode.\n\n    Optional ``altchars`` must be a byte string of length 2 which specifies\n    an alternative alphabet for the '+' and '/' characters.  This allows an\n    application to e.g. generate url or filesystem safe Base64 strings.\n\n    The result is returned as a :class:`bytes` object.\n    \"\"\"\n", "input": "", "output": "    if altchars is not None:\n        altchars = _get_bytes(altchars)\n        assert len(altchars) == 2, repr(altchars)\n    if version_info < (3, 0):\n        if isinstance(s, text_type):\n            raise TypeError('a bytes-like object is required, not \\''\n                            + type(s).__name__ + '\\'')\n    return builtin_encode(s, altchars)", "category": "Python"}, {"instruction": "def _extract_vararray_max(tform):\n    \"\"\"\n    Extract number from PX(number)\n    \"\"\"\n", "input": "", "output": "    first = tform.find('(')\n    last = tform.rfind(')')\n\n    if first == -1 or last == -1:\n        # no max length specified\n        return -1\n\n    maxnum = int(tform[first+1:last])\n    return maxnum", "category": "Python"}, {"instruction": "def _parse_text(self, el, refs=None, specials=None,  element_cls=Paragraph):\n        \"\"\"Like _parse_element but ensure a single element.\"\"\"\n", "input": "", "output": "        if specials is None:\n            specials = {}\n        if refs is None:\n            refs = {}\n        elements = self._parse_element_r(el, specials=specials, refs=refs, element_cls=element_cls)\n        # This occurs if the input element is self-closing... (some table td in NLM XML)\n        if not elements:\n            return [element_cls('')]\n        element = elements[0]\n        for next_element in elements[1:]:\n            element += element_cls(' ') + next_element\n        return [element]", "category": "Python"}, {"instruction": "def update_nseg(self):\n        \"\"\"Update the number of segments, displayed in the dialog.\"\"\"\n", "input": "", "output": "        self.nseg = 0\n        if self.one_grp:\n            segments = self.get_segments()\n\n            if segments is not None:\n                self.nseg = len(segments)\n                self.show_nseg.setText('Number of segments: ' + str(self.nseg))\n                times = [t for seg in segments for t in seg['times']]\n                self.parent.overview.mark_poi(times)\n\n            else:\n                self.show_nseg.setText('No valid segments')\n\n        self.toggle_freq()", "category": "Python"}, {"instruction": "def main():\n    \"\"\"\n    What will be executed when running as a stand alone program.\n    \"\"\"\n", "input": "", "output": "    args = parse_args()\n\n    try:\n        hsm = pyhsm.base.YHSM(device=args.device, debug=args.debug)\n\n        if args.debug or args.verbose:\n            print \"Device  : %s\" % (args.device)\n            print \"Version : %s\" % (hsm.info())\n            print \"\"\n\n        password = get_password(hsm, args)\n        otp = get_otp(hsm, args)\n        if not password and not otp:\n            print \"\\nAborted\\n\"\n            return 1\n        else:\n            if args.debug or args.verbose:\n                print \"\"\n            if hsm.unlock(password = password, otp = otp):\n                if args.debug or args.verbose:\n                    print \"OK\\n\"\n    except pyhsm.exception.YHSM_Error, e:\n        sys.stderr.write(\"ERROR: %s\\n\" % (e.reason))\n        if e.reason == \"YubiHSM did not respond to command YSM_SYSTEM_INFO_QUERY\":\n            sys.stderr.write(\"Please check whether your YubiHSM is really at \" + args.device + \", you can specify an alternate device using the option -D\")\n        return 1\n\n    return 0", "category": "Python"}, {"instruction": "def try_until_succeed(_warning_period, func, *argv, **kwarg):\n    \"\"\"Try a function until it successfully returns.\n    \n    Print current exception every ``_warning_period`` times try.\n    \n    **\u4e2d\u6587\u6587\u6863**\n    \n    \u5c1d\u8bd5\u4e00\u4e2a\u51fd\u6570\u76f4\u5230\u5176\u6210\u529f\u4e3a\u6b62\u3002\u4e0d\u9002\u7528\u4e8e\u4f1a\u51fa\u73b0\u6b7b\u5faa\u73af\u7684\u51fd\u6570\u3002\n    \n    \u6bcf\u9694``_warning_period``\u6b21\u5931\u8d25, \u5c31\u4f1a\u6253\u5370\u5f53\u524d\u5f02\u5e38\u548c\u5c1d\u8bd5\u6b21\u6570\u3002\n    \"\"\"\n", "input": "", "output": "    if (not isinstance(_warning_period, int)) or (_warning_period < 1):\n        raise Exception(\"'_warning_period' argument has to be int \"\n                        \"and greater than 0\")\n        \n    counter = 1\n    while 1:\n        try:\n            return func(*argv, **kwarg)\n        except Exception as e:\n            current_exception = e\n            counter += 1\n            if (counter % _warning_period) == 0:\n                print(\"Warning: this is %sth try, current error is \"\n                      \"%s\" % (counter, repr(current_exception)))", "category": "Python"}, {"instruction": "def to_array(self):\n        \"\"\"\n        Serializes this PassportElementErrorReverseSide to a dictionary.\n\n        :return: dictionary representation of this object.\n        :rtype: dict\n        \"\"\"\n", "input": "", "output": "        array = super(PassportElementErrorReverseSide, self).to_array()\n        array['source'] = u(self.source)  # py2: type unicode, py3: type str\n        array['type'] = u(self.type)  # py2: type unicode, py3: type str\n        array['file_hash'] = u(self.file_hash)  # py2: type unicode, py3: type str\n        array['message'] = u(self.message)  # py2: type unicode, py3: type str\n        return array", "category": "Python"}, {"instruction": "def coros(n=None, interval=0, default_callback=None, loop=None):\n    \"\"\"Decorator for wrap coro_function into the function return NewTask.\"\"\"\n", "input": "", "output": "    submitter = Loop(\n        n=n, interval=interval, default_callback=default_callback, loop=loop\n    ).submitter\n\n    return submitter", "category": "Python"}, {"instruction": "def _gen_3spec(op, path, xattr=False):\n    \"\"\"\n    Returns a Spec tuple suitable for passing to the underlying C extension.\n    This variant is called for operations that lack an input value.\n\n    :param str path: The path to fetch\n    :param bool xattr: Whether this is an extended attribute\n    :return: a spec suitable for passing to the underlying C extension\n    \"\"\"\n", "input": "", "output": "    flags = 0\n    if xattr:\n        flags |= _P.SDSPEC_F_XATTR\n    return Spec(op, path, flags)", "category": "Python"}, {"instruction": "def encode_jwt(self, claims_set):\n        \"\"\"Encode a JWT token based on the claims_set and the settings.\n\n        If available, registry.settings.jwtauth.private_key is used as key.\n        In this case the algorithm must be an RS* or EC* algorithm.\n        If registry.settings.jwtauth.private_key is not set,\n        registry.settings.jwtauth.master_secret is used.\n        registry.settings.jwtauth.algorithm is used as algorithm.\n\n        :param claims_set: set of claims, which will be included in\n            the created token.\n        \"\"\"\n", "input": "", "output": "        token = jwt.encode(claims_set, self.private_key, self.algorithm)\n\n        if PY3:\n            token = token.decode(encoding='UTF-8')\n\n        return token", "category": "Python"}, {"instruction": "def calculate_angles(detector, combs):\n    \"\"\"Calculates angles between PMT combinations according to positions in\n    detector_file\n\n    Parameters\n    ----------\n    detector_file: file from which to read the PMT positions (.detx)\n    combs: pmt combinations\n\n    Returns\n    -------\n    angles: numpy array of angles between all PMT combinations\n\n    \"\"\"\n", "input": "", "output": "    angles = []\n    pmt_angles = detector.pmt_angles\n    for first, second in combs:\n        angles.append(\n            kp.math.angle_between(\n                np.array(pmt_angles[first]), np.array(pmt_angles[second])\n            )\n        )\n    return np.array(angles)", "category": "Python"}, {"instruction": "def from_dict(self, d: Dict[str, Any]) -> None:\n        \"\"\"Load values from a dict.\"\"\"\n", "input": "", "output": "        for key, value in d.items():\n            if key.isupper():\n                self._setattr(key, value)\n\n        logger.info(\"Config is loaded from dict: %r\", d)", "category": "Python"}, {"instruction": "def supports_version_type(self, version_type):\n        \"\"\"Tests if the given version type is supported.\n\n        arg:    version_type (osid.type.Type): a version Type\n        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise\n        raise:  IllegalState - syntax is not a ``VERSION``\n        raise:  NullArgument - ``version_type`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n", "input": "", "output": "        # Implemented from template for osid.Metadata.supports_coordinate_type\n        if self._kwargs['syntax'] not in ['``VERSION``']:\n            raise errors.IllegalState()\n        return version_type in self.get_version_types", "category": "Python"}, {"instruction": "def search_genius(self, search_term):\n        \"\"\"Search documents hosted on Genius.\"\"\"\n", "input": "", "output": "        endpoint = \"search/\"\n        params = {'q': search_term}\n        return self._make_request(endpoint, params_=params)", "category": "Python"}, {"instruction": "def checkAndCreate(self, key, payload):\n        \"\"\" Function checkAndCreate\n        Check if an object exists and create it if not\n\n        @param key: The targeted object\n        @param payload: The targeted object description\n        @return RETURN: The id of the object\n        \"\"\"\n", "input": "", "output": "        if key not in self:\n            if 'templates' in payload:\n                templates = payload.pop('templates')\n            self[key] = payload\n            self.reload()\n        return self[key]['id']", "category": "Python"}, {"instruction": "def after_epoch(self, epoch_data: EpochData, **kwargs) -> None:\n        \"\"\"\n        If initialized to check after each epoch, stop the training once the epoch data contains a monitored\n        variable equal to NaN.\n\n        :param epoch_data: epoch data to be checked\n        \"\"\"\n", "input": "", "output": "\n        if self._after_epoch:\n            self._check_nan(epoch_data)", "category": "Python"}, {"instruction": "def mark_sentence_boundaries(sequences, drop=0.0):  # pragma: no cover\n    \"\"\"Pad sentence sequences with EOL markers.\"\"\"\n", "input": "", "output": "    for sequence in sequences:\n        sequence.insert(0, \"-EOL-\")\n        sequence.insert(0, \"-EOL-\")\n        sequence.append(\"-EOL-\")\n        sequence.append(\"-EOL-\")\n    return sequences, None", "category": "Python"}, {"instruction": "def rerun(client, run, job):\n    \"\"\"Re-run existing workflow or tool using CWL runner.\"\"\"\n", "input": "", "output": "    from renku.models.provenance import ProcessRun\n    activity = client.process_commmit()\n\n    if not isinstance(activity, ProcessRun):\n        click.secho('No tool was found.', fg='red', file=sys.stderr)\n        return\n\n    try:\n        args = ['cwl-runner', activity.path]\n        if job:\n            job_file = tempfile.NamedTemporaryFile(\n                suffix='.yml', dir=os.getcwd(), delete=False\n            )\n            args.append(job_file.name)\n\n            with job_file as fp:\n                yaml.dump(yaml.safe_load(job), stream=fp, encoding='utf-8')\n\n        if run:\n            return call(args, cwd=os.getcwd())\n    finally:\n        if job:\n            os.unlink(job_file.name)", "category": "Python"}, {"instruction": "def to_float(stype):\n    \"\"\" Returns the instruction sequence for converting the given\n    type stored in DE,HL to fixed DE,HL.\n    \"\"\"\n", "input": "", "output": "    output = []  # List of instructions\n\n    if stype == 'f':\n        return []  # Nothing to do\n\n    if stype == 'f16':\n        output.append('call __F16TOFREG')\n        REQUIRES.add('f16tofreg.asm')\n        return output\n\n    # If we reach this point, it's an integer type\n    if stype == 'u8':\n        output.append('call __U8TOFREG')\n    elif stype == 'i8':\n        output.append('call __I8TOFREG')\n    else:\n        output = to_long(stype)\n        if stype in ('i16', 'i32'):\n            output.append('call __I32TOFREG')\n        else:\n            output.append('call __U32TOFREG')\n\n    REQUIRES.add('u32tofreg.asm')\n\n    return output", "category": "Python"}, {"instruction": "def export(self, top=True):\n        \"\"\"Exports object to its string representation.\n\n        Args:\n            top (bool):  if True appends `internal_name` before values.\n                All non list objects should be exported with value top=True,\n                all list objects, that are embedded in as fields inlist objects\n                should be exported with `top`=False\n\n        Returns:\n            str: The objects string representation\n\n        \"\"\"\n", "input": "", "output": "        out = []\n        if top:\n            out.append(self._internal_name)\n        out.append(self._to_str(self.city))\n        out.append(self._to_str(self.state_province_region))\n        out.append(self._to_str(self.country))\n        out.append(self._to_str(self.source))\n        out.append(self._to_str(self.wmo))\n        out.append(self._to_str(self.latitude))\n        out.append(self._to_str(self.longitude))\n        out.append(self._to_str(self.timezone))\n        out.append(self._to_str(self.elevation))\n        return \",\".join(out)", "category": "Python"}, {"instruction": "def unixtime_to_datetimestr(unixtime, timefmt='%Y/%m/%d %H:%M:%S', isutc=True):\n    \"\"\"\n    TODO: ranme to datetimestr\n    \"\"\"\n", "input": "", "output": "    try:\n        if unixtime == -1:\n            return 'NA'\n        if unixtime is None:\n            return None\n        if isutc:\n            return datetime.datetime.utcfromtimestamp(unixtime).strftime(timefmt)\n        else:\n            return datetime.datetime.fromtimestamp(unixtime).strftime(timefmt)\n    except ValueError:\n        raise", "category": "Python"}, {"instruction": "def _walk(r):\n    '''\n    Recursively walk dirs. Return flattened list of keys.\n    r: etcd.EtcdResult\n    '''\n", "input": "", "output": "    if not r.dir:\n        return [r.key.split('/', 3)[3]]\n\n    keys = []\n    for c in client.read(r.key).children:\n        keys.extend(_walk(c))\n    return keys", "category": "Python"}, {"instruction": "def get_event_transfers(self, id, **data):\n        \"\"\"\n        GET /events/:id/transfers/\n        Returns a list of :format:`transfers` for the event.\n        \"\"\"\n", "input": "", "output": "        \n        return self.get(\"/events/{0}/transfers/\".format(id), data=data)", "category": "Python"}, {"instruction": "def _detect(self):\n        \"\"\" Detect shadowing\n\n        Recursively visit the calls\n        Returns:\n            list: {'vuln', 'filename,'contract','func', 'shadow'}\n\n        \"\"\"\n", "input": "", "output": "        results = []\n        for c in self.contracts:\n            shadowing = self.detect_shadowing(c)\n            if shadowing:\n                for all_variables in shadowing:\n                    shadow = all_variables[0]\n                    variables = all_variables[1:]\n                    info = '{}.{} ({}) shadows:\\n'.format(shadow.contract.name,\n                                                        shadow.name,\n                                                        shadow.source_mapping_str)\n                    for var in variables:\n                        info += \"\\t- {}.{} ({})\\n\".format(var.contract.name,\n                                                       var.name,\n                                                       var.source_mapping_str)\n\n                    json = self.generate_json_result(info)\n                    self.add_variables_to_json(all_variables, json)\n                    results.append(json)\n\n        return results", "category": "Python"}, {"instruction": "def find_counterpart_in(self, tree_b):\n        \"\"\" Finds a TreeNode counterpart for this node in tree_b\n            :param tree_b: target tree that hosts counterpart to this node\n            :return: TreeNode from tree_b that has the same timeperiod as self.timeperiod,\n                or None if no counterpart ware found\n        \"\"\"\n", "input": "", "output": "\n        tree_b_hierarchy_entry = tree_b.process_hierarchy.get_by_qualifier(self.time_qualifier)\n        if not tree_b_hierarchy_entry:\n            # special case when tree with more levels depends on the tree with smaller amount of levels\n            # for example ThreeLevel Financial tree depends on TwoLevel Google Channel\n            # in this case - we just verify time-periods that matches in both trees;\n            # for levels that have no match, we assume that dependency does not exists\n            # for example Financial Monthly has no counterpart in Google Daily Report -\n            # so we assume that its not blocked\n            node_b = None\n        else:\n            node_b = tree_b.get_node(tree_b_hierarchy_entry.process_entry.process_name, self.timeperiod)\n\n        return node_b", "category": "Python"}, {"instruction": "def get_previous(self):\n        \"\"\"Returns the previous :obj:`Gtk.TreeModelRow` or None\"\"\"\n", "input": "", "output": "\n        prev_iter = self.model.iter_previous(self.iter)\n        if prev_iter:\n            return TreeModelRow(self.model, prev_iter)", "category": "Python"}, {"instruction": "def WriteEvent(self, event):\n    \"\"\"Writes the event to the output.\n\n    Args:\n      event (EventObject): event.\n    \"\"\"\n", "input": "", "output": "    self.WriteEventStart()\n\n    try:\n      self.WriteEventBody(event)\n\n    except errors.NoFormatterFound as exception:\n      error_message = 'unable to retrieve formatter with error: {0!s}'.format(\n          exception)\n      self._ReportEventError(event, error_message)\n\n    except errors.WrongFormatter as exception:\n      error_message = 'wrong formatter with error: {0!s}'.format(exception)\n      self._ReportEventError(event, error_message)\n\n    self.WriteEventEnd()", "category": "Python"}, {"instruction": "def write_dag(self):\n    \"\"\"\n    Write either a dag or a dax.\n    \"\"\"\n", "input": "", "output": "    if not self.__nodes_finalized:\n      for node in self.__nodes:\n        node.finalize()\n    self.write_concrete_dag()\n    self.write_abstract_dag()", "category": "Python"}, {"instruction": "def set_sink_nodes(self, sink_nodes):\n        r\"\"\"\n        Set the sink nodes and compute their t-weights.\n        \n        Parameters\n        ----------\n        sink_nodes : sequence of integers\n            Declare the sink nodes via their ids.\n        \n        Notes\n        -----\n        It does not get checked if one of the supplied sink-nodes already has\n        a weight assigned (e.g. by passing it to set_source_nodes()). This can\n        occur when the foreground- and background-markers cover the same region. In this\n        case the order of setting the terminal nodes can affect the graph and therefore\n        the graph-cut result.\n        \"\"\"\n", "input": "", "output": "        self.__tnodes = list(sink_nodes)\n        \n        # set the source-to-node weights (t-weights)\n        for tnode in self.__tnodes:\n            self.__tweights[tnode] = (0, self.MAX)", "category": "Python"}, {"instruction": "def _get_first_part_id(self, assessment_id):\n        \"\"\"This session implemenation assumes all items are assigned to the first assessment part\"\"\"\n", "input": "", "output": "        if assessment_id not in self._first_part_index:\n            self._first_part_index[assessment_id] = get_first_part_id_for_assessment(\n                assessment_id,\n                runtime=self._runtime,\n                proxy=self._proxy,\n                create=True,\n                bank_id=self._catalog_id)\n        return self._first_part_index[assessment_id]", "category": "Python"}, {"instruction": "def node_scale_root_height(self, treeheight=1):\n        \"\"\"\n        Returns a toytree copy with all nodes scaled so that the root \n        height equals the value entered for treeheight.\n        \"\"\"\n", "input": "", "output": "        # make tree height = 1 * treeheight\n        ctree = self._ttree.copy()\n        _height = ctree.treenode.height\n        for node in ctree.treenode.traverse():\n            node.dist = (node.dist / _height) * treeheight\n        ctree._coords.update()\n        return ctree", "category": "Python"}, {"instruction": "def opens_platforms(self, tag=None, fromdate=None, todate=None):\n        \"\"\"\n        Gets an overview of the platforms used to open your emails.\n        This is only recorded when open tracking is enabled for that email.\n        \"\"\"\n", "input": "", "output": "        return self.call(\"GET\", \"/stats/outbound/opens/platforms\", tag=tag, fromdate=fromdate, todate=todate)", "category": "Python"}, {"instruction": "def _create_justification_button(self):\n        \"\"\"Creates horizontal justification button\"\"\"\n", "input": "", "output": "\n        iconnames = [\"JustifyLeft\", \"JustifyCenter\", \"JustifyRight\"]\n        bmplist = [icons[iconname] for iconname in iconnames]\n        self.justify_tb = _widgets.BitmapToggleButton(self, bmplist)\n        self.justify_tb.SetToolTipString(_(u\"Justification\"))\n        self.Bind(wx.EVT_BUTTON, self.OnJustification, self.justify_tb)\n        self.AddControl(self.justify_tb)", "category": "Python"}, {"instruction": "def guest_unpause(self, userid):\n        \"\"\"Unpause a virtual machine.\n\n        :param str userid: the id of the virtual machine to be unpaused\n        :returns: None\n        \"\"\"\n", "input": "", "output": "        action = \"unpause guest '%s'\" % userid\n        with zvmutils.log_and_reraise_sdkbase_error(action):\n            self._vmops.guest_unpause(userid)", "category": "Python"}, {"instruction": "def _priority_key(pep8_result):\n    \"\"\"Key for sorting PEP8 results.\n\n    Global fixes should be done first. This is important for things like\n    indentation.\n\n    \"\"\"\n", "input": "", "output": "    priority = [\n        # Fix multiline colon-based before semicolon based.\n        'e701',\n        # Break multiline statements early.\n        'e702',\n        # Things that make lines longer.\n        'e225', 'e231',\n        # Remove extraneous whitespace before breaking lines.\n        'e201',\n        # Shorten whitespace in comment before resorting to wrapping.\n        'e262'\n    ]\n    middle_index = 10000\n    lowest_priority = [\n        # We need to shorten lines last since the logical fixer can get in a\n        # loop, which causes us to exit early.\n        'e501'\n    ]\n    key = pep8_result['id'].lower()\n    try:\n        return priority.index(key)\n    except ValueError:\n        try:\n            return middle_index + lowest_priority.index(key) + 1\n        except ValueError:\n            return middle_index", "category": "Python"}, {"instruction": "def application_list(request):\n    \"\"\" a user wants to see all applications possible. \"\"\"\n", "input": "", "output": "\n    if util.is_admin(request):\n        queryset = Application.objects.all()\n    else:\n        queryset = Application.objects.get_for_applicant(request.user)\n\n    q_filter = ApplicationFilter(request.GET, queryset=queryset)\n\n    table = ApplicationTable(q_filter.qs.order_by(\"-expires\"))\n    tables.RequestConfig(request).configure(table)\n\n    spec = []\n    for name, value in six.iteritems(q_filter.form.cleaned_data):\n        if value is not None and value != \"\":\n            name = name.replace('_', ' ').capitalize()\n            spec.append((name, value))\n\n    return render(\n        template_name=\"kgapplications/application_list.html\",\n        context={\n            'table': table,\n            'filter': q_filter,\n            'spec': spec,\n            'title': \"Application list\",\n        },\n        request=request)", "category": "Python"}, {"instruction": "def run_script_with_context(script_path, cwd, context):\n    \"\"\"Execute a script after rendering it with Jinja.\n\n    :param script_path: Absolute path to the script to run.\n    :param cwd: The directory to run the script from.\n    :param context: Cookiecutter project template context.\n    \"\"\"\n", "input": "", "output": "    _, extension = os.path.splitext(script_path)\n\n    contents = io.open(script_path, 'r', encoding='utf-8').read()\n\n    with tempfile.NamedTemporaryFile(\n        delete=False,\n        mode='wb',\n        suffix=extension\n    ) as temp:\n        env = StrictEnvironment(\n            context=context,\n            keep_trailing_newline=True,\n        )\n        template = env.from_string(contents)\n        output = template.render(**context)\n        temp.write(output.encode('utf-8'))\n\n    run_script(temp.name, cwd)", "category": "Python"}, {"instruction": "def thing_type_exists(thingTypeName,\n            region=None, key=None, keyid=None, profile=None):\n    '''\n    Given a thing type name, check to see if the given thing type exists\n\n    Returns True if the given thing type exists and returns False if the\n    given thing type does not exist.\n\n    .. versionadded:: 2016.11.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt myminion boto_iot.thing_type_exists mythingtype\n\n    '''\n", "input": "", "output": "\n    try:\n        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)\n        res = conn.describe_thing_type(thingTypeName=thingTypeName)\n        if res.get('thingTypeName'):\n            return {'exists': True}\n        else:\n            return {'exists': False}\n    except ClientError as e:\n        err = __utils__['boto3.get_error'](e)\n        if e.response.get('Error', {}).get('Code') == 'ResourceNotFoundException':\n            return {'exists': False}\n        return {'error': err}", "category": "Python"}, {"instruction": "def retrieve(cls, *args, **kwargs):\n        \"\"\"Return parent method.\"\"\"\n", "input": "", "output": "        return super(ApplicationFeeRefund, cls).retrieve(*args, **kwargs)", "category": "Python"}, {"instruction": "def resolve_redirection(self, request, context):\n        \"\"\"Check for redirections.\"\"\"\n", "input": "", "output": "        current_page = context['current_page']\n        lang = context['lang']\n        if current_page.redirect_to_url:\n            return HttpResponsePermanentRedirect(current_page.redirect_to_url)\n\n        if current_page.redirect_to:\n            return HttpResponsePermanentRedirect(\n                current_page.redirect_to.get_url_path(lang))", "category": "Python"}, {"instruction": "def query(cls, **kwargs):\n        \"\"\"\n        Query multiple objects.\n\n        :param kwargs: The query parameters. The key is the filter parameter and the value is the value to search for.\n        :return: The list of matching objects\n        :raises: A `ValueError` if at least one of the supplied parameters is not in the list of allowed parameters.\n        \"\"\"\n", "input": "", "output": "        params = dict(cls._default_filters)\n\n        for key, value in kwargs.items():\n            if key in cls._filter_parameters:\n                if isinstance(value, datetime):\n                    params[key] = value.strftime('%Y-%m-%dT%H:%M:%S+00:00')\n                else:\n                    params[key] = value\n            else:\n                raise ValueError('\\'{}\\' is not a filter parameter for class \\'{}\\''.format(key, cls.__name__))\n\n        return cls._get_iter_from_url('{}/'.format(cls._endpoint), params=params)", "category": "Python"}, {"instruction": "def filter_match_kwargs(kwargs, children=False):\n    \"\"\"\n    Filters out kwargs for Match construction\n\n    :param kwargs:\n    :type kwargs: dict\n    :param children:\n    :type children: Flag to filter children matches\n    :return: A filtered dict\n    :rtype: dict\n    \"\"\"\n", "input": "", "output": "    kwargs = kwargs.copy()\n    for key in ('pattern', 'start', 'end', 'parent', 'formatter', 'value'):\n        if key in kwargs:\n            del kwargs[key]\n    if children:\n        for key in ('name',):\n            if key in kwargs:\n                del kwargs[key]\n    return kwargs", "category": "Python"}, {"instruction": "def _compute_separations(inner, outer, angles):\n        \"\"\"Compute x and y positions for separation lines for given angles.\n\n        \"\"\"\n", "input": "", "output": "        return [np.array([[a, inner], [a, outer]]) for a in angles]", "category": "Python"}, {"instruction": "def __get_types(for_type=None, for_types=None):\n        \"\"\"Parse the arguments and return a tuple of types to implement for.\n\n        Raises:\n            ValueError or TypeError as appropriate.\n        \"\"\"\n", "input": "", "output": "        if for_type:\n            if for_types:\n                raise ValueError(\"Cannot pass both for_type and for_types.\")\n            for_types = (for_type,)\n        elif for_types:\n            if not isinstance(for_types, tuple):\n                raise TypeError(\"for_types must be passed as a tuple of \"\n                                \"types (classes).\")\n        else:\n            raise ValueError(\"Must pass either for_type or for_types.\")\n\n        return for_types", "category": "Python"}, {"instruction": "def main(database_dir, target_dir):\n    \"\"\"Generate CSV files from a CronosPro/CronosPlus database.\"\"\"\n", "input": "", "output": "    if not os.path.isdir(database_dir):\n        raise click.ClickException(\"Database directory does not exist!\")\n    try:\n        os.makedirs(target_dir)\n    except:\n        pass\n    try:\n        parse(database_dir, target_dir)\n    except CronosException as ex:\n        raise click.ClickException(ex.message)", "category": "Python"}, {"instruction": "def n_yearly_publications(self, refresh=True):\n        \"\"\"Number of journal publications in a given year.\"\"\"\n", "input": "", "output": "        pub_years = [int(ab.coverDate.split('-')[0])\n                     for ab in self.get_journal_abstracts(refresh=refresh)]\n        return Counter(pub_years)", "category": "Python"}, {"instruction": "def formfield_for_dbfield(self, db_field, **kwargs):\n        \"\"\"\n        Make slug mandatory.\n        \"\"\"\n", "input": "", "output": "        if db_field.name == \"slug\":\n            kwargs[\"required\"] = True\n            kwargs[\"help_text\"] = None\n        return super(LinkAdmin, self).formfield_for_dbfield(db_field, **kwargs)", "category": "Python"}, {"instruction": "def get_xml_string_with_self_contained_assertion_within_encrypted_assertion(\n            self, assertion_tag):\n        \"\"\" Makes a encrypted assertion only containing self contained\n        namespaces.\n\n        :param assertion_tag: Tag for the assertion to be transformed.\n        :return: A new samlp.Resonse in string representation.\n        \"\"\"\n", "input": "", "output": "        prefix_map = self.get_prefix_map(\n            [self.encrypted_assertion._to_element_tree().find(assertion_tag)])\n\n        tree = self._to_element_tree()\n\n        self.set_prefixes(\n            tree.find(\n                self.encrypted_assertion._to_element_tree().tag).find(\n                assertion_tag), prefix_map)\n\n        return ElementTree.tostring(tree, encoding=\"UTF-8\").decode('utf-8')", "category": "Python"}, {"instruction": "def get_build_configuration_id_by_name(name):\n    \"\"\"\n    Returns the id of the build configuration matching name\n    :param name: name of build configuration\n    :return: id of the matching build configuration, or None if no match found\n    \"\"\"\n", "input": "", "output": "    response = utils.checked_api_call(pnc_api.build_configs, 'get_all', q='name==' + name).content\n    if not response:\n        return None\n    return response[0].id", "category": "Python"}, {"instruction": "def get_schedule(self, date=None):\n        \"\"\"\n        Calling the Schedule API.\n\n        Return:\n           json data\n        \"\"\"\n", "input": "", "output": "\n        schedule_url = self.api_path + \"schedule/\"\n        params = {}\n        if date:\n            params['date'] = date\n        response = self.get_response(schedule_url, params)\n        return response", "category": "Python"}, {"instruction": "def OpenClient(client_id=None, token=None):\n  \"\"\"Opens the client, getting potential approval tokens.\n\n  Args:\n    client_id: The client id that should be opened.\n    token: Token to use to open the client\n\n  Returns:\n    tuple containing (client, token) objects or (None, None) on if\n    no appropriate aproval tokens were found.\n  \"\"\"\n", "input": "", "output": "  if not token:\n    try:\n      token = ApprovalFind(client_id, token=token)\n    except access_control.UnauthorizedAccess as e:\n      logging.debug(\"No authorization found for access to client: %s\", e)\n\n  try:\n    # Try and open with the token we managed to retrieve or the default.\n    client = aff4.FACTORY.Open(\n        rdfvalue.RDFURN(client_id), mode=\"r\", token=token)\n    return client, token\n  except access_control.UnauthorizedAccess:\n    logging.warning(\n        \"Unable to find a valid reason for client %s. You may need \"\n        \"to request approval.\", client_id)\n    return None, None", "category": "Python"}, {"instruction": "def get_real_end_line(token):\n    \"\"\"Finds the line on which the token really ends.\n\n    With pyyaml, scalar tokens often end on a next line.\n    \"\"\"\n", "input": "", "output": "    end_line = token.end_mark.line + 1\n\n    if not isinstance(token, yaml.ScalarToken):\n        return end_line\n\n    pos = token.end_mark.pointer - 1\n    while (pos >= token.start_mark.pointer - 1 and\n           token.end_mark.buffer[pos] in string.whitespace):\n        if token.end_mark.buffer[pos] == '\\n':\n            end_line -= 1\n        pos -= 1\n    return end_line", "category": "Python"}, {"instruction": "def tag_info_chart (self):\n\n        \"\"\" Make the taginfo.txt plot \"\"\"\n", "input": "", "output": "\n        ## TODO: human chrs on hg19. How will this work with GRCh genome or other, non human, genomes?\n        # nice if they are ordered by size\n        ucsc = [\"chr\" + str(i) for i in range(1,23)].append([ \"chrX\", \"chrY\", \"chrM\"])\n        ensembl = list(range(1,23)).append([ \"X\", \"Y\", \"MT\"])\n        pconfig = {\n            'id': 'tagInfo',\n            'title': 'Homer: Tag Info Distribution',\n            'ylab': 'Tags',\n            'cpswitch_counts_label': 'Number of Tags'\n        }\n\n        ## check if chromosomes starts with \"chr\" (UCSC) or \"#\" (ensembl)\n        sample1 = next(iter(self.tagdir_data['taginfo_total']))\n        chrFormat = next(iter(self.tagdir_data['taginfo_total'][sample1]))\n\n        if (\"chr\" in chrFormat):\n            chrs = ucsc\n        else:\n            chrs = ensembl\n\n        return bargraph.plot(self.tagdir_data['taginfo_total'], chrs, pconfig)", "category": "Python"}, {"instruction": "def auth_middleware(policy):\n    \"\"\"Returns a aiohttp_auth middleware factory for use by the aiohttp\n    application object.\n\n    Args:\n        policy: A authentication policy with a base class of\n            AbstractAuthentication.\n    \"\"\"\n", "input": "", "output": "    assert isinstance(policy, AbstractAuthentication)\n\n    async def _auth_middleware_factory(app, handler):\n\n        async def _middleware_handler(request):\n            # Save the policy in the request\n            request[POLICY_KEY] = policy\n\n            # Call the next handler in the chain\n            response = await handler(request)\n\n            # Give the policy a chance to handle the response\n            await policy.process_response(request, response)\n\n            return response\n\n        return _middleware_handler\n\n    return _auth_middleware_factory", "category": "Python"}, {"instruction": "def try_remove(self, key, timeout=0):\n        \"\"\"\n        Tries to remove the given key from this map and returns immediately if timeout is not provided. If\n        timeout is provided, operation waits until it is completed or timeout is reached.\n\n        :param key: (object), key of the entry to be deleted.\n        :param timeout: (int), operation timeout in seconds (optional).\n        :return: (bool), ``true`` if the remove is successful, ``false`` otherwise.\n        \"\"\"\n", "input": "", "output": "        check_not_none(key, \"key can't be None\")\n\n        key_data = self._to_data(key)\n        return self._try_remove_internal(key_data, timeout)", "category": "Python"}, {"instruction": "def set_hyperparams(self, new_params):\n        \"\"\"Set the (free) hyperparameters.\n        \n        Parameters\n        ----------\n        new_params : :py:class:`Array` or other Array-like\n            New values of the free parameters.\n        \n        Raises\n        ------\n        ValueError\n            If the length of `new_params` is not consistent with :py:attr:`self.params`.\n        \"\"\"\n", "input": "", "output": "        new_params = scipy.asarray(new_params, dtype=float)\n        \n        if len(new_params) == len(self.free_params):\n            num_free_k1 = sum(~self.k1.fixed_params)\n            self.k1.set_hyperparams(new_params[:num_free_k1])\n            self.k2.set_hyperparams(new_params[num_free_k1:])\n        else:\n            raise ValueError(\"Length of new_params must be %s!\" % (len(self.free_params),))", "category": "Python"}, {"instruction": "def read_credentials(fname):\n    \"\"\"\n    read a simple text file from a private location to get\n    username and password\n    \"\"\"\n", "input": "", "output": "    with open(fname, 'r') as f:\n        username = f.readline().strip('\\n')\n        password = f.readline().strip('\\n')\n    return username, password", "category": "Python"}, {"instruction": "def get_item_ids_for_assessment_part(self, assessment_part_id):\n        \"\"\"convenience method returns item ids associated with an assessment_part_id\"\"\"\n", "input": "", "output": "        item_ids = []\n        for question_map in self._my_map['questions']:\n            if question_map['assessmentPartId'] == str(assessment_part_id):\n                item_ids.append(Id(question_map['itemId']))\n        return item_ids", "category": "Python"}, {"instruction": "def logger(self):\n        \"\"\":class:`logging.Logger` of this plotter\"\"\"\n", "input": "", "output": "        try:\n            return self.data.psy.logger.getChild(self.__class__.__name__)\n        except AttributeError:\n            name = '%s.%s' % (self.__module__, self.__class__.__name__)\n            return logging.getLogger(name)", "category": "Python"}, {"instruction": "def get_dependants(cls, dist):\n        \"\"\"Yield dependant user packages for a given package name.\"\"\"\n", "input": "", "output": "        for package in cls.installed_distributions:\n            for requirement_package in package.requires():\n                requirement_name = requirement_package.project_name\n                # perform case-insensitive matching\n                if requirement_name.lower() == dist.lower():\n                    yield package", "category": "Python"}, {"instruction": "def init_app(self, app):\n        \"\"\"Flask application initialization.\n\n        :param app: The Flask application.\n        \"\"\"\n", "input": "", "output": "        self.init_config(app)\n        app.extensions['invenio-indexer'] = self\n\n        hooks = app.config.get('INDEXER_BEFORE_INDEX_HOOKS', [])\n        for hook in hooks:\n            if isinstance(hook, six.string_types):\n                hook = import_string(hook)\n            before_record_index.connect_via(app)(hook)", "category": "Python"}, {"instruction": "def reward(self, action):\n        \"\"\"\n        Reward function for the task.\n\n        The dense reward has five components.\n\n            Reaching: in [0, 1], to encourage the arm to reach the cube\n            Grasping: in {0, 0.25}, non-zero if arm is grasping the cube\n            Lifting: in {0, 1}, non-zero if arm has lifted the cube\n            Aligning: in [0, 0.5], encourages aligning one cube over the other\n            Stacking: in {0, 2}, non-zero if cube is stacked on other cube\n\n        The sparse reward only consists of the stacking component.\n        However, the sparse reward is either 0 or 1.\n\n        Args:\n            action (np array): unused for this task\n\n        Returns:\n            reward (float): the reward\n        \"\"\"\n", "input": "", "output": "        r_reach, r_lift, r_stack = self.staged_rewards()\n        if self.reward_shaping:\n            reward = max(r_reach, r_lift, r_stack)\n        else:\n            reward = 1.0 if r_stack > 0 else 0.0\n\n        return reward", "category": "Python"}, {"instruction": "def read(self, size):\n        \"\"\"Read bytes from the stream and block until sample rate is achieved.\n\n        Args:\n          size: number of bytes to read from the stream.\n        \"\"\"\n", "input": "", "output": "        now = time.time()\n        missing_dt = self._sleep_until - now\n        if missing_dt > 0:\n            time.sleep(missing_dt)\n        self._sleep_until = time.time() + self._sleep_time(size)\n        data = (self._wavep.readframes(size)\n                if self._wavep\n                else self._fp.read(size))\n        #  When reach end of audio stream, pad remainder with silence (zeros).\n        if not data:\n            return b'\\x00' * size\n        return data", "category": "Python"}, {"instruction": "def sortkey(x):\n    \"\"\"Return '001002003' for (colorname, 1, 2, 3)\"\"\"\n", "input": "", "output": "    k = str(x[1]).zfill(3) + str(x[2]).zfill(3) + str(x[3]).zfill(3)\n    return k", "category": "Python"}, {"instruction": "def get_zone(self, zone_id, records=True):\n        \"\"\"Get a zone and its records.\n\n        :param zone: the zone name\n        :returns: A dictionary containing a large amount of information about\n                  the specified zone.\n\n        \"\"\"\n", "input": "", "output": "        mask = None\n        if records:\n            mask = 'resourceRecords'\n        return self.service.getObject(id=zone_id, mask=mask)", "category": "Python"}, {"instruction": "def check_images(data):\n    \"\"\"\n    Check and reformat input images if needed\n    \"\"\"\n", "input": "", "output": "    if isinstance(data, ndarray):\n        data = fromarray(data)\n    \n    if not isinstance(data, Images):\n        data = fromarray(asarray(data))\n\n    if len(data.shape) not in set([3, 4]):\n        raise Exception('Number of image dimensions %s must be 2 or 3' % (len(data.shape)))\n\n    return data", "category": "Python"}, {"instruction": "def find_actions(namespace, action_prefix):\n    \"\"\"Find all the actions in the namespace.\"\"\"\n", "input": "", "output": "    actions = {}\n    for key, value in iteritems(namespace):\n        if key.startswith(action_prefix):\n            actions[key[len(action_prefix):]] = analyse_action(value)\n    return actions", "category": "Python"}, {"instruction": "def loadTrusts(self, callback, bare_jid, device_ids):\n        \"\"\"\n        Return a dict containing the trust status for each device id. By default, this\n        method calls loadTrust for each device id.\n        \"\"\"\n", "input": "", "output": "\n        if self.is_async:\n            self.__loadTrustsAsync(callback, bare_jid, device_ids, {})\n        else:\n            return self.__loadTrustsSync(bare_jid, device_ids)", "category": "Python"}, {"instruction": "def get_usage(self, start=None, end=None):\n        \"\"\"Access historical account usage data.\"\"\"\n", "input": "", "output": "        method = 'GET'\n        endpoint = '/rest/v1/users/{}/usage'.format(self.client.sauce_username)\n        data = {}\n        if start:\n            data['start'] = start\n        if end:\n            data['end'] = end\n        if data:\n            endpoint = '?'.join([endpoint, urlencode(data)])\n        return self.client.request(method, endpoint)", "category": "Python"}, {"instruction": "def get_ie(instance, key, data):\n    \"\"\"http://git.kernel.org/cgit/linux/kernel/git/jberg/iw.git/tree/scan.c?id=v3.17#n981.\n\n    Positional arguments:\n    instance -- `ie_print` class instance.\n    key -- corresponding `ieprinters` dictionary key for the instance.\n    data -- bytearray data to read.\n\n    Returns:\n    Dictionary of parsed data with string keys.\n    \"\"\"\n", "input": "", "output": "    if not instance.print_:\n        return dict()\n    if len(data) < instance.minlen or len(data) > instance.maxlen:\n        if data:\n            return {'<invalid: {0} byte(s)>'.format(len(data)): ' '.join(format(x, '02x') for x in data)}\n        return {'<invalid: no data>': data}\n    return {instance.name: instance.print_(key, data)}", "category": "Python"}, {"instruction": "def read(self, include_deleted=False):\n        \"\"\"Return only read items in the current queryset\"\"\"\n", "input": "", "output": "        if is_soft_delete() and not include_deleted:\n            return self.filter(unread=False, deleted=False)\n\n        # When SOFT_DELETE=False, developers are supposed NOT to touch 'deleted' field.\n        # In this case, to improve query performance, don't filter by 'deleted' field\n        return self.filter(unread=False)", "category": "Python"}, {"instruction": "def d8hdisttostrm(np, p, src, dist, thresh, workingdir=None,\n                      mpiexedir=None, exedir=None, log_file=None, runtime_file=None, hostfile=None):\n        \"\"\"Run D8 horizontal distance down to stream.\n        \"\"\"\n", "input": "", "output": "        fname = TauDEM.func_name('d8hdisttostrm')\n        return TauDEM.run(FileClass.get_executable_fullpath(fname, exedir),\n                          {'-p': p, '-src': src},\n                          workingdir,\n                          {'-thresh': thresh},\n                          {'-dist': dist},\n                          {'mpipath': mpiexedir, 'hostfile': hostfile, 'n': np},\n                          {'logfile': log_file, 'runtimefile': runtime_file})", "category": "Python"}, {"instruction": "def check_input_data_type(self):\n        \"\"\"Check the input data types of the state\n\n        Checks all input data ports if the handed data is not of the specified type and generate an error logger message\n        with details of the found type conflict.\n        \"\"\"\n", "input": "", "output": "        for data_port in self.input_data_ports.values():\n            if data_port.name in self.input_data and self.input_data[data_port.name] is not None:\n                #check for class\n                if not isinstance(self.input_data[data_port.name], data_port.data_type):\n                    logger.error(\"{0} had an data port error: Input of execute function must be of type '{1}' not '{2}'\"\n                                 \" as current value '{3}'\".format(self, data_port.data_type.__name__,\n                                                               type(self.input_data[data_port.name]).__name__,\n                                                               self.input_data[data_port.name]))", "category": "Python"}, {"instruction": "def pickAttachment(self):\r\n        \"\"\"\r\n        Prompts the user to select an attachment to add to this edit.\r\n        \"\"\"\n", "input": "", "output": "        filename = QFileDialog.getOpenFileName(self.window(),\r\n                                               'Select Attachment',\r\n                                               '',\r\n                                               'All Files (*.*)')\r\n        \r\n        if type(filename) == tuple:\r\n            filename = nativestring(filename[0])\r\n        \r\n        filename = nativestring(filename)\r\n        if filename:\r\n            self.addAttachment(os.path.basename(filename), filename)", "category": "Python"}, {"instruction": "def create(self, name):\n        \"\"\" Creates a configuration file named *name*.\n\n        If there is already a configuration file with that name,\n        the existing file is returned.\n\n        :param name: The name of the configuration file.\n        :type name: ``string``\n\n        :return: The :class:`ConfigurationFile` object.\n        \"\"\"\n", "input": "", "output": "        # This has to be overridden to handle the plumbing of creating\n        # a ConfigurationFile (which is a Collection) instead of some\n        # Entity.\n        if not isinstance(name, basestring):\n            raise ValueError(\"Invalid name: %s\" % repr(name))\n        response = self.post(__conf=name)\n        if response.status == 303:\n            return self[name]\n        elif response.status == 201:\n            return ConfigurationFile(self.service, PATH_CONF % name, item=Stanza, state={'title': name})\n        else:\n            raise ValueError(\"Unexpected status code %s returned from creating a stanza\" % response.status)", "category": "Python"}, {"instruction": "def view_announcement_view(request, id):\n    \"\"\"View an announcement.\n\n    id: announcement id\n\n    \"\"\"\n", "input": "", "output": "    announcement = get_object_or_404(Announcement, id=id)\n\n    return render(request, \"announcements/view.html\", {\"announcement\": announcement})", "category": "Python"}, {"instruction": "def get_gps(self, image):\n        \"\"\"\u83b7\u53d6\u7ecf\u5ea6\uff0c\u7eac\u5ea6\"\"\"\n", "input": "", "output": "        exif_data = self.get_exif_data(image)\n        return self.get_lat_lon(exif_data)", "category": "Python"}, {"instruction": "def fetch_album_name(self):\n        \"\"\"\n        Get the name of the album from lastfm.\n        \"\"\"\n", "input": "", "output": "        response = get_lastfm('track.getInfo', artist=self.artist,\n                              track=self.title)\n        if response:\n            try:\n                self.album = response['track']['album']['title']\n                logger.debug('Found album %s from lastfm', self.album)\n            except Exception:\n                logger.warning('Could not fetch album name for %s', self)\n        else:\n            logger.warning('Could not fetch album name for %s', self)", "category": "Python"}]