[{"instruction": "// servicesWatch is used to watch the list of available services", "input": "go language", "output": "func servicesWatch(params map[string]interface{}) (WatcherFunc, error) {\n\tstale := false\n\tif err := assignValueBool(params, \"stale\", &stale); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfn := func(p *Plan) (BlockingParamVal, interface{}, error) {\n\t\tcatalog := p.client.Catalog()\n\t\topts := makeQueryOptionsWithContext(p, stale)\n\t\tdefer p.cancelFunc()\n\t\tservices, meta, err := catalog.Services(&opts)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\treturn WaitIndexVal(meta.LastIndex), services, err\n\t}\n\treturn fn, nil\n}", "category": "Python"}, {"instruction": "Likewise, we want to know if a profile is specified early, in particular to save the window state data.", "input": "JavaScript", "output": "function profileFromArgs(args) {\n\tif (!args) return null;\n\tconst profileIndex = args.indexOf('--profile');\n\tif (profileIndex <= 0 || profileIndex >= args.length - 1) return null;\n\tconst profileValue = args[profileIndex + 1];\n\treturn profileValue ? profileValue : null;\n}", "category": "Python"}, {"instruction": "Unescapes a double quoted string.\n\n@param string value A double quoted string.\n\n@return string The unescaped string.", "input": "JavaScript", "output": "function(value)\n\t{\n\t\tvar callback = function(m) {\n\t\t\treturn new YamlUnescaper().unescapeCharacter(m);\n\t\t};\n\n\t\t// evaluate the string\n\t\treturn value.replace(new RegExp(YamlUnescaper.REGEX_ESCAPED_CHARACTER, 'g'), callback);\n\t}", "category": "Python"}, {"instruction": "partial : ((* -> c), *) -> * -> c", "input": "JavaScript", "output": "function partial(...args) {\n  const fn = args[0]\n  const xs = args.slice(1)\n\n  if(!isFunction(fn)) {\n    throw new TypeError('partial: Function required for first argument')\n  }\n\n  return curry(\n    Function.bind.apply(fn, [ null ].concat(xs))\n  )\n}", "category": "Python"}, {"instruction": "@private\n\nInjects LiveReload script into HTML\n\n@param {Object} ctx\n@param {number} port - server port number", "input": "JavaScript", "output": "function _injectLiveReload(ctx, port) {\n  const { hostname } = ctx.request;\n  const wsPort = _websocketPort(ctx, port);\n  const script = `<script src=\"/dashboard/javascripts/livereload.js?snipver=1&port=${wsPort}&host=${hostname}\"></script>`;\n\n  ctx.body = ctx.body.replace(/(<\\/body>(?![\\s\\S]*<\\/body>[\\s\\S]*$))/i, `${script}\\n$1`);\n}", "category": "Python"}, {"instruction": "Parse nodes in FBXTree.Objects.Material", "input": "JavaScript", "output": "function ( textureMap ) {\n\n\t\t\tvar materialMap = new Map();\n\n\t\t\tif ( 'Material' in fbxTree.Objects ) {\n\n\t\t\t\tvar materialNodes = fbxTree.Objects.Material;\n\n\t\t\t\tfor ( var nodeID in materialNodes ) {\n\n\t\t\t\t\tvar material = this.parseMaterial( materialNodes[ nodeID ], textureMap );\n\n\t\t\t\t\tif ( material !== null ) materialMap.set( parseInt( nodeID ), material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materialMap;\n\n\t\t}", "category": "Python"}, {"instruction": "Wrapper to allow the use of object methods as static methods of Immutable.", "input": "JavaScript", "output": "function toStatic(fn) {\n    function staticWrapper() {\n      var args = [].slice.call(arguments);\n      var self = args.shift();\n      return fn.apply(self, args);\n    }\n\n    return staticWrapper;\n  }", "category": "Python"}, {"instruction": "Style strike.\n@param {object} sq - squire editor instance", "input": "JavaScript", "output": "function styleStrike(sq) {\n  if (sq.hasFormat('S')) {\n    sq.changeFormat(null, {tag: 'S'});\n  } else if (!sq.hasFormat('a') && !sq.hasFormat('PRE')) {\n    if (sq.hasFormat('code')) {\n      sq.changeFormat(null, {tag: 'code'});\n    }\n    sq.strikethrough();\n  }\n}", "category": "Python"}, {"instruction": "\u5c06\u4e24\u4e2a\u70b9\u5747\u5206\u6210count\u4e2a\u70b9", "input": "JavaScript", "output": "function _splitPoints(points, former, count) {\n  var result = [].concat(points);\n  var index = void 0;\n  var t = 1 / (count + 1);\n  var formerEnd = _getSegmentPoints(former)[0];\n  for (var i = 1; i <= count; i++) {\n    t *= i;\n    index = Math.floor(points.length * t);\n    if (index === 0) {\n      result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);\n    } else {\n      result.splice(index, 0, [formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);\n    }\n  }\n  return result;\n}", "category": "Python"}, {"instruction": "The default function used to format a Date to String, passed to the `format`\nprop.\n@param {Date} d\n@return {String}", "input": "JavaScript", "output": "function defaultFormat(d) {\n  if ((0, _DateUtils.isDate)(d)) {\n    var year = d.getFullYear();\n    var month = '' + (d.getMonth() + 1);\n    var day = '' + d.getDate();\n    return year + '-' + month + '-' + day;\n  }\n  return '';\n}", "category": "Python"}, {"instruction": "\u64ad\u653e\u504f\u79fb\u91cf the offset of current playing audio \n@language=en\n@private Initialize.", "input": "JavaScript", "output": "function(){\n        this._context = context;\n        this._gainNode = context.createGain ? context.createGain() : context.createGainNode();\n        this._gainNode.connect(context.destination);\n\n        this._onAudioEvent = this._onAudioEvent.bind(this);\n        this._onDecodeComplete = this._onDecodeComplete.bind(this);\n        this._onDecodeError = this._onDecodeError.bind(this);\n    }", "category": "Python"}, {"instruction": "Checks whether a node has the '_super' property.\n@param {Node[]} nodes An array of nodes.\n@returns {Boolean}", "input": "JavaScript", "output": "function checkForSuper(nodes) {\n  if (nodes.length === 0) return false;\n\n  return nodes.some((n) => {\n    if (utils.isCallExpression(n.expression)) {\n      const fnCallee = n.expression.callee;\n      return utils.isMemberExpression(fnCallee) &&\n        utils.isThisExpression(fnCallee.object) &&\n        utils.isIdentifier(fnCallee.property) &&\n        fnCallee.property.name === '_super';\n    } else if (utils.isReturnStatement(n)) {\n      if (!n.argument || !utils.isCallExpression(n.argument)) return false;\n\n      const fnCallee = n.argument.callee;\n      return fnCallee.property.name === '_super';\n    }\n\n    return false;\n  });\n}", "category": "Python"}, {"instruction": "/*\nGeoJSON MultiLineString Class\nnew MultiLineString();\nnew MultiLineString([ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ]);\nnew MultiLineString({\ntype: \"MultiLineString\",\ncoordinates: [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ]\n});", "input": "JavaScript", "output": "function MultiLineString(input){\n    if(input && input.type === \"MultiLineString\" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiLineString\";\n    }\n\n    this.type = \"MultiLineString\";\n  }", "category": "Python"}, {"instruction": "Adds null elements of the given ArrayExpression or ArrayPattern node to the ignore list.\n@param {ASTNode} node An ArrayExpression or ArrayPattern node.\n@returns {void}", "input": "JavaScript", "output": "function addNullElementsToIgnoreList(node) {\n            let previousToken = sourceCode.getFirstToken(node);\n\n            node.elements.forEach(element => {\n                let token;\n\n                if (element === null) {\n                    token = sourceCode.getTokenAfter(previousToken);\n\n                    if (astUtils.isCommaToken(token)) {\n                        commaTokensToIgnore.push(token);\n                    }\n                } else {\n                    token = sourceCode.getTokenAfter(element);\n                }\n\n                previousToken = token;\n            });\n        }", "category": "Python"}, {"instruction": "Mimic Array.filter() API, but with an async callback function. Execute each callback on each array item serially. Useful when using WebDriverIO API. Added due because of problem with chrome driver when too many requests are made simultaneously. https://bugs.chromium.org/p/chromedriver/issues/detail?id=2152#c9 @param {object[]} array Input array items to iterate over @param {function} callback Async function to excute on each array item @param {object} option Additional options. 'extractValue' will extract the .value object from a WebdriverIO", "input": "JavaScript", "output": "async function filterAsync(array, callback, option = {}) {\n  const {\n    extractValue = true,\n  } = option;\n  const inputArray = Array.isArray(array) ? array : [array];\n  const values = [];\n  for (let index = 0; index < inputArray.length; index++) {\n    try {\n      const res = unify(await callback(inputArray[index], index, inputArray), { extractValue });\n      const value = Array.isArray(res) ? res[0] : res;\n\n      if (value) {\n        values.push(inputArray[index]);\n      }\n    } catch (err) {\n      throw err;\n    }\n  }\n  return values;\n}", "category": "Python"}, {"instruction": "Convert string to printable,replace all control chars and unicode to hex escape", "input": "JavaScript", "output": "function toPrint(s,isRaw) {\n  var ctrl=/[\\x00-\\x1F\\x7F-\\x9F]/,unicode=/[\\u009F-\\uFFFF]/;\n  s=s.split('').map(function (c) {\n    if (!isRaw && printEscapeMap.hasOwnProperty(c)) return printEscapeMap[c];\n    else if (unicode.test(c)) return '\\\\u'+('00'+ord(c).toString(16).toUpperCase()).slice(-4);\n    else if (ctrl.test(c)) return '\\\\x'+(\"0\"+ord(c).toString(16).toUpperCase()).slice(-2);\n    return c;\n  }).join('');\n  return s;\n}", "category": "Python"}, {"instruction": "/*\tPrivate Methods\n==================================================", "input": "JavaScript", "output": "function () {\n\t\t\n\t\t// Create Layout\n\t\tthis._el.message_container = TL.Dom.create(\"div\", \"tl-message-container\", this._el.container);\n\t\tthis._el.loading_icon = TL.Dom.create(\"div\", this.options.message_icon_class, this._el.message_container);\n\t\tthis._el.message = TL.Dom.create(\"div\", \"tl-message-content\", this._el.message_container);\n\t\t\n\t\tthis._updateMessage();\n\t\t\n\t}", "category": "Python"}, {"instruction": "return the custom message for the given element name and validation method", "input": "JavaScript", "output": "function( name, method ) {\n\t\t\tvar m = this.settings.messages[name];\n\t\t\treturn m && (m.constructor === String ? m : m[method]);\n\t\t}", "category": "Python"}, {"instruction": "\u6dfb\u52a0\u5e74\u6708\u65e5\u7b49\u6587\u672c\n@param { array } arr\n@param {string } text\n@param { object } props", "input": "JavaScript", "output": "function formatText(arr, text, props) {\n  const formatArray = [];\n  const localeCode = props.locale;\n  for (let i = 0; i < arr.length; i += 1) {\n    const el = arr[i];\n    formatArray.push(isArray(el) ?\n      formatText(el, locale[localeCode].surfix[colFlags[i]], props) :\n      {\n        text: addZero(el.text) +\n              (isUndefined(text) ? locale[localeCode].surfix[colFlags[i]] : text),\n        value: el.value,\n      });\n  }\n  return formatArray;\n}", "category": "Python"}, {"instruction": "Skip transition and create new iframe\n\n@param {Object} shell shell instance\n@param {Object} options\n@param {string} options.targetPageId targetPageId\n@param {Object} options.targetPageMeta pageMeta of target page\n@param {string} options.sourcePageId sourcePageId\n@param {Object} options.sourcePageMeta pageMeta of source page\n@param {boolean} options.newPage whether a new iframe should be created (false)\n@param {boolean} options.isForward whether transition direction is forward (true)\n@param {Function} options.onComplete complete callback", "input": "JavaScript", "output": "function skipTransitionAndCreate (shell, options) {\n  let {sourcePageId, targetPageId, onComplete} = options\n\n  hideAllIFrames()\n  fixRootPageScroll(shell, {sourcePageId, targetPageId})\n  onComplete && onComplete()\n\n  let iframe = getIFrame(targetPageId)\n  css(iframe, 'z-index', activeZIndex++)\n\n  shell.afterSwitchPage(options)\n}", "category": "Python"}, {"instruction": "Validates any given collection.\nBasically you can validate Audiences, Categories, Severity etc - everything that meets the criteria\n\nPositive cases :\n- \"Capitalcase\"\n\n@private\n@param {array} aEnum Enum to be validated.\n@param {array} oEnumComparison Enum comparison.\n@returns {boolean} Boolean response if the provided collection is valid.", "input": "JavaScript", "output": "function(aEnum, oEnumComparison) {\n\n\t\tif (aEnum && Array.isArray(aEnum) && aEnum.length) {\n\n\t\t\tfor (var i = 0; i < aEnum.length; i++) {\n\n\t\t\t\tif (oEnumComparison.hasOwnProperty(aEnum[i])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}", "category": "Python"}, {"instruction": "/*\\\nRaphael\n[ method ]\n*\nCreates a canvas object on which to draw.\nYou must do this first, as all future calls to drawing methods\nfrom this instance will be bound to this canvas.\n> Parameters\n*\n- container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface\n- width (number)\n- height (number)\n- callback (function) #optional callback function which is going to be executed in the context of newly created paper\nor\n- x (number)\n- y (number)\n- width (number)\n- height (number)\n- callback (function) #optional callback function which is going to be executed in the context of newly created paper\nor\n- all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.\n- callback (function) #optional callback function which is going to be executed in the context of newly created paper\nor\n- onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve\u2019s \u201cDOMLoad\u201d event. In this case method returns `undefined`.\n= (object) @Paper\n> Usage\n| // Each of the following examples create a canvas\n| // that is 320px wide by 200px high.\n| // Canvas is created at the viewport\u2019s 10,50 coordinate.\n| var paper = Raphael(10, 50, 320, 200);\n| // Canvas is created at the top left corner of the #notepad element\n| // (or its top right corner in dir=\"rtl\" elements)\n| var paper = Raphael(document.getElementById(\"notepad\"), 320, 200);\n| // Same as above\n| var paper = Raphael(\"notepad\", 320, 200);\n| // Image dump\n| var set = Raphael([\"notepad\", 320, 200, {\n|     type: \"rect\",\n|     x: 10,\n|     y: 10,\n|     width: 25,\n|     height: 25,\n|     stroke: \"#f00\"\n| }, {\n|     type: \"text\",\n|     x: 30,\n|     y: 40,\n|     text: \"Dump\"\n| }]);\n\\", "input": "JavaScript", "output": "function R(first) {\n        if (R.is(first, \"function\")) {\n            return loaded ? first() : eve.on(\"raphael.DOMload\", first);\n        } else if (R.is(first, array)) {\n            return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);\n        } else {\n            var args = Array.prototype.slice.call(arguments, 0);\n            if (R.is(args[args.length - 1], \"function\")) {\n                var f = args.pop();\n                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on(\"raphael.DOMload\", function () {\n                    f.call(R._engine.create[apply](R, args));\n                });\n            } else {\n                return R._engine.create[apply](R, arguments);\n            }\n        }\n    }", "category": "Python"}, {"instruction": "traverse icons in a row of icon atlas extend each icon with left-top coordinates", "input": "JavaScript", "output": "function buildRowMapping(mapping, columns, yOffset) {\n  for (let i = 0; i < columns.length; i++) {\n    const {icon, xOffset} = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = Object.assign({}, icon, {\n      x: xOffset,\n      y: yOffset\n    });\n  }\n}", "category": "Python"}, {"instruction": "Copyright (c) 2006-2017, JGraph Ltd\nCopyright (c) 2006-2017, Gaudenz Alder\n \nClass: mxPrintPreview\n\nImplements printing of a diagram across multiple pages. The following opens\na print preview for an existing graph:\n\n(code)\nvar preview = new mxPrintPreview(graph);\npreview.open();\n(end)\n\nUse <mxUtils.getScaleForPageCount> as follows in order to print the graph\nacross a given number of pages:\n\n(code)\nvar pageCount = mxUtils.prompt('Enter page count', '1');\n\nif (pageCount != null)\n{\nvar scale = mxUtils.getScaleForPageCount(pageCount, graph);\nvar preview = new mxPrintPreview(graph, scale);\npreview.open();\n}\n(end)\n\nAdditional pages:\n\nTo add additional pages before and after the output, <getCoverPages> and\n<getAppendices> can be used, respectively.\n\n(code)\nvar preview = new mxPrintPreview(graph, 1);\n\npreview.getCoverPages = function(w, h)\n{\nreturn [this.renderPage(w, h, 0, 0, mxUtils.bind(this, function(div)\n{\ndiv.innerHTML = '<div style=\"position:relative;margin:4px;\">Cover Page</p>'\n}))];\n};\n\npreview.getAppendices = function(w, h)\n{\nreturn [this.renderPage(w, h, 0, 0, mxUtils.bind(this, function(div)\n{\ndiv.innerHTML = '<div style=\"position:relative;margin:4px;\">Appendix</p>'\n}))];\n};\n\npreview.open();\n(end)\n\nCSS:\n\nThe CSS from the original page is not carried over to the print preview.\nTo add CSS to the page, use the css argument in the <open> function or\noverride <writeHead> to add the respective link tags as follows:\n\n(code)\nvar writeHead = preview.writeHead;\npreview.writeHead = function(doc, css)\n{\nwriteHead.apply(this, arguments);\ndoc.writeln('<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">');\n};\n(end)\n\nPadding:\n\nTo add a padding to the page in the preview (but not the print output), use\nthe following code:\n\n(code)\npreview.writeHead = function(doc)\n{\nwriteHead.apply(this, arguments);\n\ndoc.writeln('<style type=\"text/css\">');\ndoc.writeln('@media screen {');\ndoc.writeln('  body > div { padding-top:30px;padding-left:40px;box-sizing:content-box; }');\ndoc.writeln('}');\ndoc.writeln('</style>');\n};\n(end)\n\nHeaders:\n\nApart from setting the title argument in the mxPrintPreview constructor you\ncan override <renderPage> as follows to add a header to any page:\n\n(code)\nvar oldRenderPage = mxPrintPreview.prototype.renderPage;\nmxPrintPreview.prototype.renderPage = function(w, h, x, y, content, pageNumber)\n{\nvar div = oldRenderPage.apply(this, arguments);\n\nvar header = document.createElement('div');\nheader.style.position = 'absolute';\nheader.style.top = '0px';\nheader.style.width = '100%';\nheader.style.textAlign = 'right';\nmxUtils.write(header, 'Your header here');\ndiv.firstChild.appendChild(header);\n\nreturn div;\n};\n(end)\n\nThe pageNumber argument contains the number of the current page, starting at\n1. To display a header on the first page only, check pageNumber and add a\nvertical offset in the constructor call for the height of the header.\n\nPage Format:\n\nFor landscape printing, use <mxConstants.PAGE_FORMAT_A4_LANDSCAPE> as\nthe pageFormat in <mxUtils.getScaleForPageCount> and <mxPrintPreview>.\nKeep in mind that one can not set the defaults for the print dialog\nof the operating system from JavaScript so the user must manually choose\na page format that matches this setting.\n\nYou can try passing the following CSS directive to <open> to set the\npage format in the print dialog to landscape. However, this CSS\ndirective seems to be ignored in most major browsers, including IE.\n\n(code)\n@page {\nsize: landscape;\n}\n(end)\n\nNote that the print preview behaves differently in IE when used from the\nfilesystem or via HTTP so printing should always be tested via HTTP.\n\nIf you are using a DOCTYPE in the source page you can override <getDoctype>\nand provide the same DOCTYPE for the print preview if required. Here is\nan example for IE8 standards mode.\n\n(code)\nvar preview = new mxPrintPreview(graph);\npreview.getDoctype = function()\n{\nreturn '<!--[if IE]><meta http-equiv=\"X-UA-Compatible\" content=\"IE=5,IE=8\" ><![endif]-->';\n};\npreview.open();\n(end)\n\nConstructor: mxPrintPreview\n\nConstructs a new print preview for the given parameters.\n\nParameters:\n\ngraph - <mxGraph> to be previewed.\nscale - Optional scale of the output. Default is 1 / <mxGraph.pageScale>.\nborder - Border in pixels along each side of every page. Note that the\nactual print function in the browser will add another border for\nprinting.\npageFormat - <mxRectangle> that specifies the page format (in pixels).\nThis should match the page format of the printer. Default uses the\n<mxGraph.pageFormat> of the given graph.\nx0 - Optional left offset of the output. Default is 0.\ny0 - Optional top offset of the output. Default is 0.\nborderColor - Optional color of the page border. Default is no border.\nNote that a border is sometimes useful to highlight the printed page\nborder in the print preview of the browser.\ntitle - Optional string that is used for the window title. Default\nis 'Printer-friendly version'.\npageSelector - Optional boolean that specifies if the page selector\nshould appear in the window with the print preview. Default is true.", "input": "JavaScript", "output": "function mxPrintPreview(graph, scale, pageFormat, border, x0, y0, borderColor, title, pageSelector)\n{\n\tthis.graph = graph;\n\tthis.scale = (scale != null) ? scale : 1 / graph.pageScale;\n\tthis.border = (border != null) ? border : 0;\n\tthis.pageFormat = mxRectangle.fromRectangle((pageFormat != null) ? pageFormat : graph.pageFormat);\n\tthis.title = (title != null) ? title : 'Printer-friendly version';\n\tthis.x0 = (x0 != null) ? x0 : 0;\n\tthis.y0 = (y0 != null) ? y0 : 0;\n\tthis.borderColor = borderColor;\n\tthis.pageSelector = (pageSelector != null) ? pageSelector : true;\n}", "category": "Python"}, {"instruction": "Update mark when resizing", "input": "JavaScript", "output": "function updateMarkWhenResizing() {\n    const helper = getHelper();\n\n    ml.getAll().forEach(marker => {\n      helper.updateMarkerWithExtraInfo(marker);\n    });\n\n    editor.eventManager.emit('markerUpdated', ml.getAll());\n  }", "category": "Python"}, {"instruction": "Gets an actual movement value corrected by offset.\n\n@return {Number}", "input": "JavaScript", "output": "function get() {\n      var offset = this.offset;\n      var translate = this.translate;\n\n      if (Components.Direction.is('rtl')) {\n        return translate + offset;\n      }\n\n      return translate - offset;\n    }", "category": "Python"}, {"instruction": "primary ('.' id)+ '='?\n| primary", "input": "JavaScript", "output": "function() {\n    var node = this.primary();\n    if (node) {\n      while (this.accept('.')) {\n        var id = new nodes.Ident(this.expect('ident').val.string);\n        node = new nodes.Member(node, id);\n      }\n      this.skipSpaces();\n      if (this.accept('=')) {\n        node.val = this.list();\n        // @block support\n        if (node.val.isEmpty) this.assignAtblock(node.val);\n      }\n    }\n    return node;\n  }", "category": "Python"}, {"instruction": "ANIMATION:", "input": "JavaScript", "output": "function(props, duration, easing, complete) {\n                    return this.each(function() { animate(this, props, duration, easing, complete); });\n                }", "category": "Python"}, {"instruction": "Sets the value for multiple styles on a node.  If a value is specified as\n'' (empty string), the corresponding style property will be unset.\n\n@param {DOMElement} node\n@param {object} styles", "input": "JavaScript", "output": "function setValueForStyles(node, styles, getStack) {\n  const style = node.style;\n  for (let styleName in styles) {\n    if (!styles.hasOwnProperty(styleName)) {\n      continue;\n    }\n    const isCustomProperty = styleName.indexOf('--') === 0;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!isCustomProperty) {\n        warnValidStyle(styleName, styles[styleName], getStack);\n      }\n    }\n    const styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n    if (styleName === 'float') {\n      styleName = 'cssFloat';\n    }\n    if (isCustomProperty) {\n      const name = isCustomProperty ? styleName : hyphenateStyleName(styleName);\n      style.setProperty(name, styleValue);\n    } else {\n      style[styleName] = styleValue;\n    }\n  }\n}", "category": "Python"}, {"instruction": "Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.", "input": "JavaScript", "output": "function hideTooltipOnMouseMove(e) {\r\n\t\t\tvar pageX = defined(e.pageX) ? e.pageX : e.page.x, // In mootools the event is wrapped and the page x/y position is named e.page.x\r\n\t\t\t\tpageY = defined(e.pageX) ? e.pageY : e.page.y; // Ref: http://mootools.net/docs/core/Types/DOMEvent\r\n\r\n\t\t\tif (chartPosition &&\r\n\t\t\t\t\t!isInsidePlot(pageX - chartPosition.left - plotLeft,\r\n\t\t\t\t\t\tpageY - chartPosition.top - plotTop)) {\r\n\t\t\t\tresetTracker();\r\n\t\t\t}\r\n\t\t}", "category": "Python"}, {"instruction": "has length 2", "input": "JavaScript", "output": "function(module, shim) {\n\t\t\tif ( Array.isArray(shim) ) {\n\t\t\t\tshim = { deps : shim };\n\t\t\t}\n\t\t\tmShims[module + '.js'] = shim;\n\t\t}", "category": "Python"}, {"instruction": "Helper method for unwrapping jQuery/DOM/string elements\n@param callback", "input": "JavaScript", "output": "function(a) {\n            if ( !a ) {\n                return null;\n            } else if ( a instanceof jQuery ) {\n                return a[0];\n            } else if ( a instanceof Object ) {\n                return a;\n            }\n            return $('#'+a)[0];\n        }", "category": "Python"}, {"instruction": "It will remove resize/scroll events and won't recalculate popper position\nwhen they are triggered. It also won't trigger onUpdate callback anymore,\nunless you call `update` method manually.\n@method\n@memberof Popper", "input": "JavaScript", "output": "function disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    if (window.cancelAnimationFrame) {\n      cancelAnimationFrame(this.scheduleUpdate);\n    }\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}", "category": "Python"}, {"instruction": "Initialize the point\n@param {Object} series The series object containing this point\n@param {Object} options The data in either number, array or object format", "input": "JavaScript", "output": "function (series, options) {\r\n\t\tvar point = this,\r\n\t\t\tcounters = series.chart.counters,\r\n\t\t\tdefaultColors;\r\n\t\tpoint.series = series;\r\n\t\tpoint.applyOptions(options);\r\n\t\tpoint.pointAttr = {};\r\n\r\n\t\tif (series.options.colorByPoint) {\r\n\t\t\tdefaultColors = series.chart.options.colors;\r\n\t\t\tif (!point.options) {\r\n\t\t\t\tpoint.options = {};\r\n\t\t\t}\r\n\t\t\tpoint.color = point.options.color = point.color || defaultColors[counters.color++];\r\n\r\n\t\t\t// loop back to zero\r\n\t\t\tcounters.wrapColor(defaultColors.length);\r\n\t\t}\r\n\r\n\t\tseries.chart.pointCount++;\r\n\t\treturn point;\r\n\t}", "category": "Python"}, {"instruction": "Return a page by its path\n@param {String} filePath\n@return {Object|undefined}", "input": "JavaScript", "output": "function getPageByPath(filePath) {\n        var page = output.getPage(filePath);\n        if (!page) return undefined;\n\n        return JSONUtils.encodePage(page, summary);\n    }", "category": "Python"}, {"instruction": "Delete a given Queue", "input": "JavaScript", "output": "async function deleteQueue(\n  project = 'my-project-id', // Your GCP Project id\n  queue = 'my-appengine-queue', // Name of the Queue to delete\n  location = 'us-central1' // The GCP region in which to delete the queue\n) {\n  // Imports the Google Cloud Tasks library.\n  const cloudTasks = require('@google-cloud/tasks');\n\n  // Instantiates a client.\n  const client = new cloudTasks.CloudTasksClient();\n\n  // Get the fully qualified path to the queue\n  const name = client.queuePath(project, location, queue);\n\n  // Send delete queue request.\n  await client.deleteQueue({name});\n  console.log(`Deleted queue '${queue}'.`);\n}", "category": "Python"}, {"instruction": "Returns unique values from an array.\n\nNote: ugly code is ugly, but efficient: http://jsperf.com/array-unique2/8\n\n@param  Array  array\n@return Array", "input": "JavaScript", "output": "function unique(array) {\n    \"use strict\";\n    var o = {},\n        r = [];\n    for (var i = 0, len = array.length; i !== len; i++) {\n        var d = array[i];\n        if (typeof o[d] === \"undefined\") {\n            o[d] = 1;\n            r[r.length] = d;\n        }\n    }\n    return r;\n}", "category": "Python"}, {"instruction": "A small colored rectangle with rounded corners.", "input": "JavaScript", "output": "function Badge({ className, children, color = \"primary\" }: Props): React.Node {\n  const classes = cn(\n    {\n      badge: true,\n      [`badge-${color}`]: color,\n    },\n    className\n  );\n  return <span className={classes}>{children}</span>;\n}", "category": "Python"}, {"instruction": "Properties of a FieldOptions.\n@memberof google.protobuf\n@interface IFieldOptions\n@property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype\n@property {boolean|null} [packed] FieldOptions packed\n@property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype\n@property {boolean|null} [lazy] FieldOptions lazy\n@property {boolean|null} [deprecated] FieldOptions deprecated\n@property {boolean|null} [weak] FieldOptions weak\n@property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption\n \nConstructs a new FieldOptions.\n@memberof google.protobuf\n@classdesc Represents a FieldOptions.\n@implements IFieldOptions\n@constructor\n@param {google.protobuf.IFieldOptions=} [properties] Properties to set", "input": "JavaScript", "output": "function FieldOptions(properties) {\n                this.uninterpretedOption = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }", "category": "Python"}, {"instruction": "Annoying method to copy nodes to an array, thanks to IE", "input": "JavaScript", "output": "function(nodes) {\n      nodes = nodes || [];\n\n      var results = [];\n      for (var i = 0; i < nodes.length; ++i) {\n        results.push(nodes.item(i));\n      }\n      return results;\n    }", "category": "Python"}, {"instruction": "find the leftmost node of a polygon ring", "input": "JavaScript", "output": "function getLeftmost(start) {\n        var p = start, leftmost = start;\n        do {\n            if (p.x < leftmost.x)\n                leftmost = p;\n            p = p.next;\n        } while (p !== start);\n        return leftmost;\n    }", "category": "Python"}, {"instruction": "Update the site\n\n@param {string} siteId\n@param {Object} manifest", "input": "JavaScript", "output": "async function _updateSite(siteId, tree, manifest, content) {\n  const endpoint = url.resolve(apiURL, `/sites/${siteId}`);\n  const body = { tree, content, manifest };\n  const response = await got.post(endpoint, { body, json: true, headers: _bearer() });\n  return response.body.site;\n}", "category": "Python"}, {"instruction": "Converts the current instance to a Javascript date\n@return {Date}", "input": "JavaScript", "output": "function toJSDate() {\n      if (this.zone == ICAL.Timezone.localTimezone) {\n        if (this.isDate) {\n          return new Date(this.year, this.month - 1, this.day);\n        } else {\n          return new Date(this.year, this.month - 1, this.day,\n                          this.hour, this.minute, this.second, 0);\n        }\n      } else {\n        return new Date(this.toUnixTime() * 1000);\n      }\n    }", "category": "Python"}, {"instruction": "The name has been updated if the user presses enter.", "input": "JavaScript", "output": "function registerInputEnterKeyHandler(inputEl, fileId) {\n        inheritedInternalApi.getDisposeSupport().attach(inputEl, \"keyup\", function(event) {\n\n            var code = event.keyCode || event.which;\n\n            if (code === 13) {\n                handleNameUpdate(inputEl, fileId);\n            }\n        });\n    }", "category": "Python"}, {"instruction": "turns off the scroll shadow on view containers so they don't interfere with dragging\n@private\n@param {Boolean} disable - true to disable, false to enable", "input": "JavaScript", "output": "function _suppressScrollShadowsOnAllViews(disable) {\n        _.forEach(_views, function (view) {\n            if (disable) {\n                ViewUtils.removeScrollerShadow(view.$openFilesContainer[0], null);\n            } else if (view.$openFilesContainer[0].scrollHeight > view.$openFilesContainer[0].clientHeight) {\n                ViewUtils.addScrollerShadow(view.$openFilesContainer[0], null, true);\n            }\n        });\n    }", "category": "Python"}, {"instruction": "Returns a list of elements that have had polymer-elements created but\nare not yet ready to register. The list is an array of element definitions.", "input": "JavaScript", "output": "function() {\n      var e$ = [];\n      for (var i=0, l=elements.length, e; (i<l) && \n          (e=elements[i]); i++) {\n        if (e.__queue && !e.__queue.flushable) {\n          e$.push(e);\n        }\n      }\n      return e$;\n    }", "category": "Python"}, {"instruction": "/* jshint ignore:start \nInitialize the BulkExports version of Preview\n\n@constructor Twilio.Preview.BulkExports\n\n@property {Twilio.Preview.BulkExports.ExportList} exports - exports resource\n@property {Twilio.Preview.BulkExports.ExportConfigurationList} exportConfiguration -\nexportConfiguration resource\n\n@param {Twilio.Preview} domain - The twilio domain\n /* jshint ignore:end", "input": "JavaScript", "output": "function BulkExports(domain) {\n  Version.prototype.constructor.call(this, domain, 'BulkExports');\n\n  // Resources\n  this._exports = undefined;\n  this._exportConfiguration = undefined;\n}", "category": "Python"}, {"instruction": "async strategy ensures processing order by chaining the callbacks", "input": "JavaScript", "output": "function asyncStrategy(node, oAggregation, mAggregations) {\n\t\t\tvar childNode,\n\t\t\t\tpChain = Promise.resolve(),\n\t\t\t\taChildPromises = [];\n\n\t\t\tfor (childNode = node.firstChild; childNode; childNode = childNode.nextSibling) {\n\t\t\t\tpChain = pChain.then(fnCallback.bind(null, node, oAggregation, mAggregations, childNode));\n\t\t\t\taChildPromises.push(pChain);\n\t\t\t}\n\t\t\treturn Promise.all(aChildPromises);\n\t\t}", "category": "Python"}, {"instruction": "Sets version in 'package.json' in http://semver.org friendly mode\n\n@param {String} type   Could be 'major', 'minor' or 'patch'\n@param {String} suffix Suffic string, example: 'alpha', 'pre-alpha', 'beta'", "input": "JavaScript", "output": "function setVersion(type, suffix) {\n        var file = 'package.json',\n            VERSION_REGEX = /([\\'|\\\"]version[\\'|\\\"][ ]*:[ ]*[\\'|\\\"])([\\d|.]*)(-\\w+)*([\\'|\\\"])/,\n            contents = grunt.file.read(file),\n            version;\n        contents = contents.replace(VERSION_REGEX, function(match, left, center) {\n            version = center;\n            if (type) {\n                version = require('semver').inc(version, type);\n            }\n            //semver.inc strips our suffix if it existed\n            if (suffix) {\n                version += '-' + suffix;\n            }\n            return left + version + '\"';\n        });\n        grunt.log.ok('Version set to ' + version.cyan);\n        grunt.file.write(file, contents);\n        return version;\n    }", "category": "Python"}, {"instruction": "Function: getStylename\n\nReturns the stylename in a style of the form [(stylename|key=value);] or\nan empty string if the given style does not contain a stylename.\n\nParameters:\n\nstyle - String of the form [(stylename|key=value);].", "input": "JavaScript", "output": "function(style)\n\t{\n\t\tif (style != null)\n\t\t{\n\t\t\tvar pairs = style.split(';');\n\t\t\tvar stylename = pairs[0];\n\t\t\t\n\t\t\tif (stylename.indexOf('=') < 0)\n\t\t\t{\n\t\t\t\treturn stylename;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\treturn '';\n\t}", "category": "Python"}, {"instruction": "Given a string and an index, look backwards to find the string of whitespace following the next previous line break.", "input": "JavaScript", "output": "function getIndentation(str, index) {\n  let indentStart = index;\n  let indentEnd = index;\n  while (indentStart) {\n    const c = str.charCodeAt(indentStart - 1);\n    // line break\n    if (c === 10 || c === 13 || c === 0x2028 || c === 0x2029) {\n      break;\n    }\n    indentStart--;\n    // not white space\n    if (c !== 9 && c !== 11 && c !== 12 && c !== 32 && c !== 160) {\n      indentEnd = indentStart;\n    }\n  }\n  return str.substring(indentStart, indentEnd);\n}", "category": "Python"}, {"instruction": "/* BIFF2_??? where ??? is the name from [XLS]", "input": "JavaScript", "output": "function parse_BIFF2STR(blob, length, opts) {\n\tvar cell = parse_XLSCell(blob, 6);\n\t++blob.l;\n\tvar str = parse_XLUnicodeString2(blob, length-7, opts);\n\tcell.t = 'str';\n\tcell.val = str;\n\treturn cell;\n}", "category": "Python"}, {"instruction": "The keys in this object are timezones that we know may be ambiguous after\na preliminary scan through the olson_tz object.\n\nThe array of timezones to compare must be in the order that daylight savings\nstarts for the regions.", "input": "JavaScript", "output": "function () {\r\n              var ambiguity_list = AMBIGUITIES[timezone_name],\r\n                  length = ambiguity_list.length,\r\n                  i = 0,\r\n                  tz = ambiguity_list[0];\r\n\r\n              for (; i < length; i += 1) {\r\n                  tz = ambiguity_list[i];\r\n\r\n                  if (jstz.date_is_dst(jstz.dst_start_for(tz))) {\r\n                      timezone_name = tz;\r\n                      return;\r\n                  }\r\n              }\r\n          }", "category": "Python"}, {"instruction": "/*!\nThe following functions are taken from jQuery UI 1.8.17 but modified\n\nCopyright 2011, AUTHORS.txt (http://jqueryui.com/about)\nDual licensed under the MIT or GPL Version 2 licenses.\nhttp://jquery.org/license\n\nhttp://docs.jquery.com/UI", "input": "JavaScript", "output": "function visible( element ) {\n\t\t// check if one of the parents (until it's position parent) is invisible\n\t\t// prevent that elements in static area are always checked as invisible\n\n\t\t// list all items until the offsetParent item (with jQuery >1.6 you can use parentsUntil)\n\t\tvar oOffsetParent = jQuery(element).offsetParent();\n\t\tvar bOffsetParentFound = false;\n\t\tvar $refs = jQuery(element).parents().filter(function() {\n\t\t\tif (this === oOffsetParent) {\n\t\t\t\tbOffsetParentFound = true;\n\t\t\t}\n\t\t\treturn bOffsetParentFound;\n\t\t});\n\n\t\t// check for at least one item to be visible\n\t\treturn !jQuery(element).add($refs).filter(function() {\n\t\t\treturn jQuery.css( this, \"visibility\" ) === \"hidden\" || jQuery.expr.filters.hidden( this );\n\t\t}).length;\n\t}", "category": "Python"}, {"instruction": "Checks if a value is a valid locator.\n@param {!(By|Function|ByHash)} locator The value to check.\n@return {!(By|Function)} The valid locator.\n@throws {TypeError} If the given value does not define a valid locator\nstrategy.", "input": "JavaScript", "output": "function check(locator) {\n  if (locator instanceof By || typeof locator === 'function') {\n    return locator;\n  }\n\n  if (locator\n      && typeof locator === 'object'\n      && typeof locator.using === 'string'\n      && typeof locator.value === 'string') {\n    return new By(locator.using, locator.value);\n  }\n\n  for (let key in locator) {\n    if (locator.hasOwnProperty(key) && By.hasOwnProperty(key)) {\n      return By[key](locator[key]);\n    }\n  }\n  throw new TypeError('Invalid locator');\n}", "category": "Python"}, {"instruction": "Prints CasperJS help.", "input": "JavaScript", "output": "function printHelp() {\n        /* global slimer */\n        var engine = phantom.casperEngine === 'slimerjs' ? slimer : phantom;\n        var version = [engine.version.major, engine.version.minor, engine.version.patch].join('.');\n        return __terminate([\n            'CasperJS version ' + phantom.casperVersion.toString() +\n            ' at ' + phantom.casperPath + ', using ' + phantom.casperEngine + ' version ' + version,\n            fs.read(fs.pathJoin(phantom.casperPath, 'bin', 'usage.txt'))\n        ].join('\\n'));\n    }", "category": "Python"}, {"instruction": "object draw<br>\nnot to be called by the end user<br>\ncalled by the game manager on each game loop\n@name draw\n@memberOf me.Entity\n@function\n@protected\n@param {me.CanvasRenderer|me.WebGLRenderer} renderer a renderer object\n@param {me.Rect} region to draw", "input": "JavaScript", "output": "function (renderer, rect) {\n            var renderable = this.renderable;\n            if (renderable instanceof me.Renderable) {\n                // predraw (apply transforms)\n                renderable.preDraw(renderer);\n\n                // draw the object\n                renderable.draw(renderer, rect);\n\n                // postdraw (clean-up);\n                renderable.postDraw(renderer);\n            }\n        }", "category": "Python"}, {"instruction": "Exports JDL a application to a JDL file in the current directory.\n@param application, the JDL application to export.\n@return the exported application in its final form.", "input": "JavaScript", "output": "function exportApplication(application) {\n  checkForErrors(application);\n  const formattedApplication = setUpApplicationStructure(application);\n  writeConfigFile(formattedApplication);\n  return formattedApplication;\n}", "category": "Python"}, {"instruction": "Binds a framebuffer\n\nThis function pretty much soley exists because I spent hours\ntrying to figure out why something I wrote wasn't working only\nto realize I forget to set the viewport dimensions.\nMy hope is this function will fix that.\n\nIt is effectively the same as\n\ngl.bindFramebuffer(gl.FRAMEBUFFER, someFramebufferInfo.framebuffer);\ngl.viewport(0, 0, someFramebufferInfo.width, someFramebufferInfo.height);\n\n@param {WebGLRenderingContext} gl the WebGLRenderingContext\n@param {module:twgl.FramebufferInfo} [framebufferInfo] a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.\nIf not passed will bind the canvas.\n@param {number} [target] The target. If not passed `gl.FRAMEBUFFER` will be used.\n@memberOf module:twgl/framebuffers", "input": "JavaScript", "output": "function bindFramebufferInfo(gl, framebufferInfo, target) {\n  target = target || gl.FRAMEBUFFER;\n  if (framebufferInfo) {\n    gl.bindFramebuffer(target, framebufferInfo.framebuffer);\n    gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);\n  } else {\n    gl.bindFramebuffer(target, null);\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n  }\n}", "category": "Python"}, {"instruction": "tutorials can have only one parent so there is no risk for loops", "input": "JavaScript", "output": "function saveChildren(node) {\n        node.children.forEach(function(child) {\n            var originalFileName = child.name;\n            var isHtmlTutorial = child.type === tutorial.TYPES.HTML;\n            var title = 'Tutorial: ' + child.title;\n            var fileName = helper.tutorialToUrl(child.name);\n\n            generateTutorial(title, child, fileName, originalFileName, isHtmlTutorial);\n            saveChildren(child);\n        });\n    }", "category": "Python"}, {"instruction": "remember the state of the bound property and copy it to both accus", "input": "JavaScript", "output": "function() {\n\n\t\tvar binding = this.binding;\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * 3;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\tthis.cumulativeWeight = 0;\n\n\t}", "category": "Python"}, {"instruction": "adds a class on NewComponent events", "input": "JavaScript", "output": "function() {\n        var comp,\n            c = this.__c,\n            str = \"\";\n        for (comp in c) {\n            str += \" \" + comp;\n        }\n        str = str.substr(1);\n        this._element.className = str;\n    }", "category": "Python"}, {"instruction": "mouse event management (mousewheel)\nXXX: mousewheel is deprecated\n@ignore", "input": "JavaScript", "output": "function onMouseWheel(e) {\n       /* jshint expr:true */\n       if (e.target === me.video.renderer.getScreenCanvas()) {\n         // create a (fake) normalized event object\n         e.type = \"wheel\"; // dispatch mouse event to registered object\n\n         return dispatchEvent(normalizeEvent(e));\n       }\n\n       return true;\n     }", "category": "Python"}, {"instruction": "Convert CH y/x to WGS lat", "input": "JavaScript", "output": "function CHtoWGSlat(y, x) {\n\n  // Converts militar to civil and  to unit = 1000km\n  // Axiliary values (% Bern)\n  const y_aux = (y - 600000) / 1000000;\n  const x_aux = (x - 200000) / 1000000;\n\n  // Process lat\n  let lat = 16.9023892 +\n      3.238272 * x_aux -\n      0.270978 * Math.pow(y_aux, 2) -\n      0.002528 * Math.pow(x_aux, 2) -\n      0.0447 * Math.pow(y_aux, 2) * x_aux -\n      0.0140 * Math.pow(x_aux, 3);\n\n  // Unit 10000\" to 1 \" and converts seconds to degrees (dec)\n  lat = lat * 100 / 36;\n\n  return lat;\n\n}", "category": "Python"}, {"instruction": "Compile and link the given template and store values for element, scope, and controller.\n@param {string} template\n@returns {angular.JQLite} The root compiled element.", "input": "JavaScript", "output": "function createDatepickerInstance(template) {\n    var outputElement = $compile(template)(pageScope);\n    pageScope.$apply();\n\n    ngElement = outputElement[0].tagName == 'MD-DATEPICKER' ?\n        outputElement : outputElement.find('md-datepicker');\n    element = ngElement[0];\n    scope = ngElement.isolateScope();\n    controller = ngElement.controller('mdDatepicker');\n\n    return outputElement;\n  }", "category": "Python"}, {"instruction": "Takes a model, and searches for a value by the property\n@param  {Object} model     The dictionary to search against\n@param  {String} property  A path within a dictionary (i.e. 'window.location.href')\n@param  {Object} data      Additional information from the get request that is\npassed to functions in the child model\n@return {Promise}", "input": "JavaScript", "output": "function resolveValue(model, property) {\n  var unwrappedContext = typeof model[property] === 'function' ? model[property]() : model[property];\n  return Postmate.Promise.resolve(unwrappedContext);\n}", "category": "Python"}, {"instruction": "Flatten an array\n@param {Array} array\n@param {Array} target\n@returns Array flattened array", "input": "JavaScript", "output": "function flatten(array, target) {\n\tconst result = target || [];\n\n\tfor (let i = 0; i < array.length; ++i) {\n\t\tif (Array.isArray(array[i])) {\n\t\t\tflatten(array[i], result);\n\t\t}\n\t\telse {\n\t\t\tresult.push(array[i]);\n\t\t}\n\t}\n\n\treturn result;\n}", "category": "Python"}, {"instruction": "Creates an SVG Cursor for the target element\n\n@param {MouseCursor} svgCursor - The cursor.", "input": "JavaScript", "output": "function setToolCursor(element, svgCursor) {\n  if (!globalConfiguration.state.showSVGCursors) {\n    return;\n  }\n  // TODO: (state vs options) Exit if cursor wasn't updated\n  // TODO: Exit if invalid options to create cursor\n\n  // Note: Max size of an SVG cursor is 128x128, default is 32x32.\n  const cursorBlob = svgCursor.getIconWithPointerSVG();\n  const mousePoint = svgCursor.mousePoint;\n\n  const svgCursorUrl = window.URL.createObjectURL(cursorBlob);\n  element.style.cursor = `url('${svgCursorUrl}') ${mousePoint}, auto`;\n\n  state.svgCursorUrl = svgCursorUrl;\n}", "category": "Python"}, {"instruction": "/* eslint-disable valid-typeof", "input": "JavaScript", "output": "function isBrowseStorage (storage) {\n  try {\n    var testKey = '__xe_t'\n    storage.setItem(testKey, 1)\n    storage.removeItem(testKey)\n    return true\n  } catch (e) {\n    return false\n  }\n}", "category": "Python"}, {"instruction": "for output file output", "input": "JavaScript", "output": "function formatOutput(output) {\n    var indent = '  ';\n    var pad = '  ';\n    var results = [];\n    results.push('AppDir:' + output.appDir);\n    output.suites.forEach(function(suite) {\n      results.push(pad + 'Suite: ' + suite.description + ' -- ' + suite.status);\n      pad+=indent;\n      suite.specs.forEach(function(spec) {\n        results.push(pad + spec.status + ' - ' + spec.description);\n        if (spec.failedExpectations) {\n          pad+=indent;\n          spec.failedExpectations.forEach(function (fe) {\n            results.push(pad + 'message: ' + fe.message);\n          });\n          pad=pad.substr(2);\n        }\n      });\n      pad = pad.substr(2);\n      results.push('');\n    });\n    results.push('');\n    return results.join('\\n');\n  }", "category": "Python"}, {"instruction": "Transform url-key names into something more presentable\n@param key\n@returns {string}", "input": "JavaScript", "output": "function getKeyName(key) {\n    if (key.indexOf(\"ui\") > -1) {\n        if (key === \"ui\") {\n            return \"UI\";\n        }\n        if (key === \"ui-external\") {\n            return \"UI External\";\n        }\n    }\n    return key.substr(0, 1).toUpperCase() + key.substring(1);\n}", "category": "Python"}, {"instruction": "The same as <code>find()</code> method, but restricts matched result\nto <code>tag</code> type\n@param {String} text\n@param {Number} pos\n@returns {Object}", "input": "JavaScript", "output": "function(text, pos) {\n\t\t\tvar result = this.find(text, pos);\n\t\t\tif (result && result.type == 'tag') {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}", "category": "Python"}, {"instruction": "/* jshint ignore:start \nInitialize the V1 version of FlexApi\n\n@constructor Twilio.FlexApi.V1\n\n@property {Twilio.FlexApi.V1.FlexFlowList} flexFlow - flexFlow resource\n@property {Twilio.FlexApi.V1.ConfigurationList} configuration -\nconfiguration resource\n\n@param {Twilio.FlexApi} domain - The twilio domain\n /* jshint ignore:end", "input": "JavaScript", "output": "function V1(domain) {\n  Version.prototype.constructor.call(this, domain, 'v1');\n\n  // Resources\n  this._flexFlow = undefined;\n  this._configuration = undefined;\n}", "category": "Python"}, {"instruction": "internal helper to get nodes and edges as separate collections with single iteration over elements", "input": "JavaScript", "output": "function byGroup() {\n    var nodes = this.spawn();\n    var edges = this.spawn();\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n\n      if (ele.isNode()) {\n        nodes.merge(ele);\n      } else {\n        edges.merge(ele);\n      }\n    }\n\n    return {\n      nodes: nodes,\n      edges: edges\n    };\n  }", "category": "Python"}, {"instruction": "Canacel a preapproval payment using the preapprovalModule\n@param id\n@param callback\n@returns {*}", "input": "JavaScript", "output": "function cancelPreapprovalPayment(id) {\n    var callback = preConditions.getCallback(arguments[arguments.length - 1]);\n\n    showWarning();\n\n    return preapprovalModule.update({\n      id: id,\n      status: 'cancelled'\n    }, callback);\n  }", "category": "Python"}, {"instruction": "Creates a catalog item from the supplied resource and adds it to the supplied parent if necessary..\n@private\n@param resource The Ckan resource\n@param rootCkanGroup The root group of all items in this Ckan hierarchy\n@param itemData The data of the item to build the catalog item from\n@param extras\n@param parent The parent group to add the item to once it's constructed - set this to rootCkanGroup for flat hierarchies.\n@returns {CatalogItem} The catalog item added, or undefined if no catalog item was added.", "input": "JavaScript", "output": "function addItem(resource, rootCkanGroup, itemData, extras, parent) {\n  var item =\n    rootCkanGroup.terria.catalog.shareKeyIndex[\n      parent.uniqueId + \"/\" + resource.id\n    ];\n  var alreadyExists = defined(item);\n\n  if (!alreadyExists) {\n    item = createItemFromResource(\n      resource,\n      rootCkanGroup,\n      itemData,\n      extras,\n      parent\n    );\n\n    if (item) {\n      parent.add(item);\n    }\n  }\n\n  return item;\n}", "category": "Python"}, {"instruction": "\u83b7\u53d6\u6587\u7ae0\u7684\u7b80\u4ecb\uff0c\u5373\u524d5\u884c\u5185\u5bb9\n@param  {String} post \u6587\u7ae0\u5185\u5bb9\n@param  {Number} line \u884c\u6570\uff0c\u9ed8\u8ba4\u4e3a10\u884c\n@return {String}      \u6587\u7ae0\u7b80\u4ecb", "input": "JavaScript", "output": "function getPostIntro(body) {\n  let isBlankReg = /^\\s+$/,\n    start = 0;\n  return body.split('\\n').filter((item) => {\n    if (start < 5 && !isBlankReg.test(item)) {\n      start++;\n      return true;\n    }\n  }).join('\\n')\n}", "category": "Python"}, {"instruction": "Add additional information to the armor version of an OpenPGP binary\npacket block.\n@author  Alex\n@version 2011-12-16\n@param {String} customComment (optional) additional comment to add to the armored string\n@returns {String} The header information", "input": "JavaScript", "output": "function addheader(customComment) {\n  let result = \"\";\n  if (config.show_version) {\n    result += \"Version: \" + config.versionstring + '\\r\\n';\n  }\n  if (config.show_comment) {\n    result += \"Comment: \" + config.commentstring + '\\r\\n';\n  }\n  if (customComment) {\n    result += \"Comment: \" + customComment + '\\r\\n';\n  }\n  result += '\\r\\n';\n  return result;\n}", "category": "Python"}, {"instruction": "overrides the lunr tokenizer in order to define custom token separators", "input": "JavaScript", "output": "function overrideLunrTokenizer() {\n\n\t\tvar origTokenizer = lunr.tokenizer;\n\t\tvar rSeparators = /[-./#_,;\\(\\)=><|]/g;\n\n\t\tlunr.tokenizer = function(str) {\n\t\t\treturn origTokenizer.call(lunr, str).reduce( function (result, token) {\n\t\t\t\tif ( rSeparators.test(token) ) {\n\t\t\t\t\ttoken = token.replace(rSeparators, \" \");\n\t\t\t\t\tresult.push.apply(result, token.toLowerCase().split(/ +/));\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(token.toLowerCase());\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}, []);\n\t\t};\n\t\tObject.keys(origTokenizer).forEach(function (key) {\n\t\t\tlunr.tokenizer[key] = origTokenizer[key];\n\t\t});\n\t}", "category": "Python"}, {"instruction": "Strips the .ts or .tsx file extension from a path and returns the base filename.", "input": "JavaScript", "output": "function getBasename(relativePath) {\n    const mayBeSuffix = [\".ts\", \".tsx\", \".d.ts\"];\n    let mayBePath = relativePath;\n    mayBeSuffix.map(suffix => {\n        const tmpPath = path_1.default.basename(relativePath, suffix);\n        if (tmpPath.length < mayBePath.length) {\n            mayBePath = tmpPath;\n        }\n    });\n    // Return whichever path is shorter. If they're the same length then nothing was stripped.\n    return mayBePath;\n}", "category": "Python"}, {"instruction": "textutil -convert txt -stdout foo.doc", "input": "JavaScript", "output": "function extractText( filePath, options, cb ) {\n  var result = ''\n    , error = null\n    , textutil = spawn( 'textutil', ['-convert', 'txt', '-stdout', filePath] )\n    ;\n\n  textutil.stdout.on( 'data', function( buffer ) {\n    result += buffer.toString();\n  });\n\n  textutil.stderr.on( 'error', function( buffer ) {\n    if ( !error ) {\n      error = '';\n    }\n    error += buffer.toString();\n  });\n\n  textutil.on( 'close', function( /* code */ ) {\n    if ( error ) {\n      error = new Error( 'textutil read of file named [[ ' +\n        path.basename( filePath ) + ' ]] failed: ' + error );\n      cb( error, null );\n      return;\n    }\n    cb( null, result.trim() );\n  });\n}", "category": "Python"}, {"instruction": "Creates and initializes specified collection of extensions.\nEach extension receives access to instance of glide and rest of components.\n\n@param {Object} glide\n@param {Object} extensions\n\n@returns {Object}", "input": "JavaScript", "output": "function mount(glide, extensions, events) {\n  var components = {};\n\n  for (var name in extensions) {\n    if (isFunction(extensions[name])) {\n      components[name] = extensions[name](glide, components, events);\n    } else {\n      warn('Extension must be a function');\n    }\n  }\n\n  for (var _name in components) {\n    if (isFunction(components[_name].mount)) {\n      components[_name].mount();\n    }\n  }\n\n  return components;\n}", "category": "Python"}, {"instruction": "/* At this point, any content is assumed to be an URL", "input": "JavaScript", "output": "function(url)  {\n\t\t\t\t\tvar self = this,\n\t\t\t\t\t\tdeferred = $.Deferred();\n\t\t\t\t\t/* we are using load so one can specify a target with: url.html #targetelement */\n\t\t\t\t\tvar $container = $('<div></div>').load(url, function(response, status){\n\t\t\t\t\t\tif ( status !== \"error\" ) {\n\t\t\t\t\t\t\tdeferred.resolve($container.contents());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdeferred.reject();\n\t\t\t\t\t});\n\t\t\t\t\treturn deferred.promise();\n\t\t\t\t}", "category": "Python"}, {"instruction": "Event handler for 'native.keyboardshow' event, sets keyboard.height to the\nreported height and keyboard.isOpening to true. Then calls\nkeyboardWaitForResize with keyboardShow or keyboardUpdateViewportHeight as\nthe callback depending on whether the event was triggered by a focusin or\nan orientationchange.", "input": "JavaScript", "output": "function keyboardNativeShow(e) {\n  clearTimeout(keyboardFocusOutTimer);\n  //console.log(\"keyboardNativeShow fired at: \" + Date.now());\n  //console.log(\"keyboardNativeshow window.innerHeight: \" + window.innerHeight);\n\n  if (!ionic.keyboard.isOpen || ionic.keyboard.isClosing) {\n    ionic.keyboard.isOpening = true;\n    ionic.keyboard.isClosing = false;\n  }\n\n  ionic.keyboard.height = e.keyboardHeight;\n  //console.log('nativeshow keyboard height:' + e.keyboardHeight);\n\n  if (wasOrientationChange) {\n    keyboardWaitForResize(keyboardUpdateViewportHeight, true);\n  } else {\n    keyboardWaitForResize(keyboardShow, true);\n  }\n}", "category": "Python"}, {"instruction": "Prefixes the given path with the API's basePath, if that option is enabled and the API has a basePath.\n\n@param   {string}    path\n@returns {string}", "input": "JavaScript", "output": "function getConfiguredPath (path) {\n    if (options.useBasePath && context.api && context.api.basePath) {\n      return context.api.basePath + path;\n    }\n    else {\n      return path;\n    }\n  }", "category": "Python"}, {"instruction": "Calls a method recoursively downwards on the tree\n\n@param   {String} functionName      the name of the function to be called\n@param   {[Array]}functionArguments optional arguments that are passed to every function\n@param   {[bool]} bottomUp          Call methods from bottom to top, defaults to false\n@param   {[bool]} skipSelf          Don't invoke the method on the class that calls it, defaults to false\n\n@returns {void}", "input": "JavaScript", "output": "function( functionName, functionArguments, bottomUp, skipSelf ) {\n\t\tvar i;\n\n\t\tif( bottomUp !== true && skipSelf !== true ) {\n\t\t\tthis[ functionName ].apply( this, functionArguments || [] );\n\t\t}\n\t\tfor( i = 0; i < this.contentItems.length; i++ ) {\n\t\t\tthis.contentItems[ i ].callDownwards( functionName, functionArguments, bottomUp );\n\t\t}\n\t\tif( bottomUp === true && skipSelf !== true ) {\n\t\t\tthis[ functionName ].apply( this, functionArguments || [] );\n\t\t}\n\t}", "category": "Python"}, {"instruction": "PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END", "input": "JavaScript", "output": "function (obj) {\n    return function (subscriber) {\n        var obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__[\"observable\"]]();\n        if (typeof obs.subscribe !== 'function') {\n            throw new TypeError('Provided object does not correctly implement Symbol.observable');\n        }\n        else {\n            return obs.subscribe(subscriber);\n        }\n    };\n}", "category": "Python"}, {"instruction": "targeting snapsIE >= 0.2", "input": "JavaScript", "output": "function getFailureMessage(exceptionMessage) {\n            var msg = 'Snapsie failed: ';\n            if (exceptionMessage) {\n                if (exceptionMessage ==\n                    \"Automation server can't create object\") {\n                    msg += 'Is it installed? Does it have permission to run '\n                        + 'as an add-on? See http://snapsie.sourceforge.net/';\n                }\n                else {\n                    msg += exceptionMessage;\n                }\n            }\n            else {\n                msg += 'Undocumented error';\n            }\n            return msg;\n        }", "category": "Python"}, {"instruction": "Returns the history into formatted output depending on the passed format.\n\n@public\n@method\n@param {string} sFormat The format into which the history object will be converted. Possible values are listed in sap.ui.support.HistoryFormats.\n@name sap.ui.support.History.getFormattedHistory\n@returns {*} All analysis history objects in the correct format.", "input": "JavaScript", "output": "function (sFormat) {\n\t\t\tvar oFormattedHistory,\n\t\t\t\taHistory = this.getHistory();\n\n\t\t\tswitch (sFormat) {\n\t\t\t\tcase library.HistoryFormats.Abap:\n\t\t\t\t\toFormattedHistory = AbapHistoryFormatter.format(aHistory);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault :\n\t\t\t\t\toFormattedHistory = StringHistoryFormatter.format(aHistory);\n\t\t\t}\n\n\t\t\treturn oFormattedHistory;\n\t\t}", "category": "Python"}, {"instruction": "Locate last brace in `str` within the key.\n\n@param {String} str\n@return {Number}\n@api private", "input": "JavaScript", "output": "function lastBraceInKey(str) {\n  var len = str.length\n    , brace\n    , c;\n  for (var i = 0; i < len; ++i) {\n    c = str[i];\n    if (']' == c) brace = false;\n    if ('[' == c) brace = true;\n    if ('=' == c && !brace) return i;\n  }\n}", "category": "Python"}, {"instruction": "ORIGINAL SOURCE: https://github.com/getsentry/raven-js/\nGiven a child DOM element, returns a query-selector statement describing that\nand its ancestors\ne.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\n@param elem\n@returns {string}", "input": "JavaScript", "output": "function htmlTreeAsString (elem) {\n  var MAX_TRAVERSE_HEIGHT = 5\n  var MAX_OUTPUT_LEN = 80\n  var out = []\n  var height = 0\n  var len = 0\n  var separator = ' > '\n  var sepLength = separator.length\n  var nextStr\n\n  while (elem && height++ < MAX_TRAVERSE_HEIGHT) {\n    nextStr = htmlElementAsString(elem)\n    // bail out if\n    // - nextStr is the 'html' element\n    // - the length of the string that would be created exceeds MAX_OUTPUT_LEN\n    //   (ignore this limit if we are on the first iteration)\n    if (\n      nextStr === 'html' ||\n      (height > 1 &&\n       len + (out.length * sepLength) + nextStr.length >= MAX_OUTPUT_LEN)\n    ) {\n      break\n    }\n\n    out.push(nextStr)\n\n    len += nextStr.length\n    elem = elem.parentNode\n  }\n\n  return out.reverse().join(separator)\n}", "category": "Python"}, {"instruction": "Use mouse events for entropy, if we do not have enough entropy by the time we need it, entropy will be generated by Math.random.", "input": "JavaScript", "output": "function(ev) {\n    this.count = this.count || 0;\n    if (this.count >= 256 || rng_pptr >= rng_psize) {\n      if (window.removeEventListener)\n        window.removeEventListener(\"mousemove\", onMouseMoveListener, false);\n      else if (window.detachEvent)\n        window.detachEvent(\"onmousemove\", onMouseMoveListener);\n      return;\n    }\n    try {\n      var mouseCoordinates = ev.x + ev.y;\n      rng_pool[rng_pptr++] = mouseCoordinates & 255;\n      this.count += 1;\n    } catch (e) {\n      // Sometimes Firefox will deny permission to access event properties for some reason. Ignore.\n    }\n  }", "category": "Python"}, {"instruction": "\u6dfb\u52a0\u78b0\u649e\u76d1\u542c\n@param {Number} typeA \u78b0\u649e\u7c7b\u578bA\n@param {Number} typeB \u78b0\u649e\u7c7b\u578bB\n@param {Object} listenerConfig \u56de\u8c03\u51fd\u6570\u914d\u7f6e\n@param {Physics~collisionCallback} listenerConfig.begin \u5f00\u59cb\u63a5\u89e6\u56de\u8c03\n@param {Physics~collisionCallback} listenerConfig.preSolve \u5904\u7406\u524d\u78b0\u649e\u56de\u8c03\n@param {Physics~collisionCallback} listenerConfig.postSolve \u5904\u7406\u540e\u78b0\u649e\u56de\u8c03\n@param {Physics~collisionCallback} listenerConfig.separate \u5206\u79bb\u56de\u8c03", "input": "JavaScript", "output": "function(typeA, typeB, listenerConfig){\n            var begin = listenerConfig.begin||function(arbiter){\n                return true;\n            };\n\n            var preSolve = listenerConfig.preSolve||function(arbiter){\n                return true;\n            };\n\n            var postSolve = listenerConfig.postSolve||function(arbiter){\n\n            };\n\n            var separate = listenerConfig.separate||function(arbiter){\n\n            };\n\n            this.space.addCollisionHandler(typeA, typeB, begin, preSolve, postSolve, separate);\n        }", "category": "Python"}, {"instruction": "Dom ready.\n\n@param {Function} fn\n\n@link https://github.com/jed/alReady.js", "input": "JavaScript", "output": "function alReady ( fn ) {\n        var add = 'addEventListener';\n        var pre = document[ add ] ? '' : 'on';\n\n        ~document.readyState.indexOf( 'm' ) ? fn() :\n            'load DOMContentLoaded readystatechange'.replace( /\\w+/g, function( type, i ) {\n                ( i ? document : window )\n                    [ pre ? 'attachEvent' : add ]\n                (\n                    pre + type,\n                    function(){ if ( fn ) if ( i < 6 || ~document.readyState.indexOf( 'm' ) ) fn(), fn = 0 },\n                    !1\n                )\n            })\n    }", "category": "Python"}, {"instruction": "Load the resource at the given path.\n@name orion.explorer.FileExplorer#loadResourceList\n@function\n@param {String|Object} path The path of the resource to load, or an object with a ChildrenLocation or ContentLocation field giving the path.\n@param {Boolean} [force] If true, force reload even if the path is unchanged. Useful\nwhen the client knows the resource underlying the current path has changed.\n@param {Function} postLoad a function to call after loading the resource. <b>Deprecated</b>: use the returned promise instead.\n@returns {orion.Promise}", "input": "JavaScript", "output": "function(path, force, postLoad) {\n\t\t\tif (path && typeof path === \"object\") {\n\t\t\t\tpath = path.ChildrenLocation || path.ContentLocation;\n\t\t\t}\n\t\t\tpath = mFileUtils.makeRelative(path);\n\t\t\tvar self = this;\n\t\t\tif (force || path !== this.treeRoot.Path || path !== this._lastPath) {\n\t\t\t\tthis._lastPath = path;\n\t\t\t\treturn this.load(this.fileClient.read(path, true), i18nUtil.formatMessage(messages[\"Loading ${0}\"], path), postLoad).then(function() {\n\t\t\t\t\tself.treeRoot.Path = path;\n\t\t\t\t\treturn self.treeRoot;\n\t\t\t\t}, function(err) {\n\t\t\t\t\tself.treeRoot.Path = null;\n\t\t\t\t\treturn new Deferred().reject(err);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn new Deferred().resolve(self.treeRoot);\n\t\t}", "category": "Python"}, {"instruction": "Provides a cross-browser way to set a CSS value on a CSS declaration.\n@param {!CSSStyleDeclaration} cssStyle A CSS style object.\n@param {string} propName A property name.\n@param {string} sanitizedValue Sanitized value of the property to be set\non the CSS style object.\n@supported IE8 and newer.", "input": "JavaScript", "output": "function setCssProperty(cssStyle, propName, sanitizedValue) {\n  genericMethodCall(\n      Methods.SET_PROPERTY, cssStyle,\n      cssStyle.setProperty ? 'setProperty' : 'setAttribute',\n      [propName, sanitizedValue]);\n}", "category": "Python"}, {"instruction": "Remove padding from a string.", "input": "JavaScript", "output": "function unpad(str) {\n  const lines = str.split(\"\\n\");\n  const m = lines[1] && lines[1].match(/^\\s+/);\n  if (!m) {\n    return str;\n  }\n  const spaces = m[0].length;\n  return lines\n    .map(line => line.slice(spaces))\n    .join(\"\\n\")\n    .trim();\n}", "category": "Python"}, {"instruction": "Build the legacy pyramid URLs (one tile per level)\n@function\n@param {object} options - infoJson\n@throws {Error}", "input": "JavaScript", "output": "function constructLevels(options) {\n        var levels = [];\n        for(var i = 0; i < options.sizes.length; i++) {\n            levels.push({\n                url: options['@id'] + '/full/' + options.sizes[i].width + ',/0/default.' + options.tileFormat,\n                width: options.sizes[i].width,\n                height: options.sizes[i].height\n            });\n        }\n        return levels.sort(function(a, b) {\n            return a.width - b.width;\n        });\n    }", "category": "Python"}, {"instruction": "Opens the panel. If a config value is passed, creates a new panelRef\nusing $mdPanel.open(config); Otherwise, called open on the panelRef,\nassuming one has already been created.\n@param {!Object=} opt_config", "input": "JavaScript", "output": "function openPanel(preset, opt_config) {\n    // TODO(ErinCoughlan): Investigate why panelRef.open() doesn't return\n    // panelRef.\n    var openPromise;\n\n    if (panelRef) {\n      openPromise = panelRef.open();\n    } else {\n      openPromise = $mdPanel.open(preset, opt_config);\n    }\n\n    openPromise.then(function(createdPanelRef) {\n      panelRef = createdPanelRef;\n      return panelRef;\n    });\n\n    flushPanel();\n  }", "category": "Python"}, {"instruction": "Clones a given metadata instance\n@param source the instance to clone\n@returns {*} cloned metadata", "input": "JavaScript", "output": "function cloneMetadata(source) {\n\t\t\tvar backupMetadata = initMetadata(source.__ui5version);\n\t\t\tfor (var index in source.__byIndex__) {\n\t\t\t\tbackupMetadata.__byIndex__[index] = source.__byIndex__[index];\n\t\t\t}\n\t\t\tfor (var key in source.__byKey__) {\n\t\t\t\tbackupMetadata.__byKey__[key] = source.__byKey__[key];\n\t\t\t}\n\t\t\treturn backupMetadata;\n\t\t}", "category": "Python"}, {"instruction": "Retrieve the computed style from a specified element.\n\n@param el\n@param styleProperty\n@return The computed style value.\n@type String", "input": "JavaScript", "output": "function(el, styleProperty){\n            if(el.currentStyle){\n                return el.currentStyle[styleProperty];\n            }else if(window.getComputedStyle){\n                var cssProperty = styleProperty.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n                var computedStyle = window.getComputedStyle(el, \"\");\n                return computedStyle.getPropertyValue(cssProperty);\n            }else{\n                return \"\";\n            }\n        }", "category": "Python"}, {"instruction": "Fires the XHR request -- may be invoked immediately or on a gradually expanding retry window for reconnects", "input": "JavaScript", "output": "function () {\r\n                req.date = new Date();\r\n                if (self._conn.options.customHeaders){\r\n                    var headers = self._conn.options.customHeaders;\r\n                    for (var header in headers) {\r\n                        if (headers.hasOwnProperty(header)) {\r\n                            req.xhr.setRequestHeader(header, headers[header]);\r\n                        }\r\n                    }\r\n                }\r\n                req.xhr.send(req.data);\r\n            }", "category": "Python"}, {"instruction": "Override the broken getFunctionName() method from JsUnit\nThis file must be loaded _after_ the jsunitCore.js", "input": "JavaScript", "output": "function getFunctionName(aFunction) {\n    var regexpResult = aFunction.toString().match(/function (\\w*)/);\n    if (regexpResult && regexpResult[1]) {\n        return regexpResult[1];\n    }\n    return 'anonymous';\n}", "category": "Python"}, {"instruction": "SAP MODIFICATION Because touchcancel is used together with touchend, jQuery.fn.bind is used to replace jQuery.fn.one due to the fact that jQuery.fn.one doesn't work for multiple events.", "input": "JavaScript", "output": "function stopHandler( event ) {\n\t\t\t\t\t$this.unbind( touchMoveEvent, moveHandler )\n\t\t\t\t\t\t.unbind( touchStopEvent, stopHandler );\n\n\t\t\t\t\tif ( start && stop ) {\n\t\t\t\t\t\t$.event.special.swipe.handleSwipe( start, stop );\n\t\t\t\t\t}\n\t\t\t\t\tstart = stop = undefined;\n\t\t\t\t}", "category": "Python"}, {"instruction": "Called when the result stream reads a new chunk.\n\n@param {Chunk} chunk", "input": "JavaScript", "output": "function onResultStreamData(chunk)\n  {\n    // unsubscribe from the result stream's 'data' and 'close' events\n    resultStream.removeListener('data', onResultStreamData);\n    resultStream.removeListener('close', onResultStreamClose);\n\n    // get all the rows in the chunk that overlap with the requested window,\n    // and use the resulting array as the new row buffer\n    var chunkStart = chunk.getStartIndex();\n    var chunkEnd = chunk.getEndIndex();\n    rowBuffer = chunk.getRows().slice(\n        Math.max(chunkStart, start) - chunkStart,\n        Math.min(chunkEnd, end) + 1 - chunkStart);\n\n    // reset the row index\n    rowIndex = 0;\n\n    // process the row buffer\n    processRowBuffer();\n  }", "category": "Python"}, {"instruction": "\"Natural\" union type.\n\nThis representation doesn't require a wrapping object and is therefore\nsimpler and generally closer to what users expect. However it cannot be used\nto represent all Avro unions since some lead to ambiguities (e.g. if two\nnumber types are in the union).\n\nCurrently, this union supports at most one type in each of the categories\nbelow:\n\n+ `null`\n+ `boolean`\n+ `int`, `long`, `float`, `double`\n+ `string`, `enum`\n+ `bytes`, `fixed`\n+ `array`\n+ `map`, `record`", "input": "JavaScript", "output": "function UnwrappedUnionType(schema, opts) {\n  UnionType.call(this, schema, opts);\n\n  this._dynamicBranches = null;\n  this._bucketIndices = {};\n  this.types.forEach(function (type, index) {\n    if (Type.isType(type, 'abstract', 'logical')) {\n      if (!this._dynamicBranches) {\n        this._dynamicBranches = [];\n      }\n      this._dynamicBranches.push({index: index, type: type});\n    } else {\n      var bucket = getTypeBucket(type);\n      if (this._bucketIndices[bucket] !== undefined) {\n        throw new Error(f('ambiguous unwrapped union: %j', this));\n      }\n      this._bucketIndices[bucket] = index;\n    }\n  }, this);\n\n  Object.freeze(this);\n}", "category": "Python"}, {"instruction": "We are using a 2x2 rotation matrix.", "input": "JavaScript", "output": "function applyRotationMatrix(touch, axis) {\n  const rotationMatrix = axisProperties.rotationMatrix[axis];\n\n  return {\n    pageX: rotationMatrix.x[0] * touch.pageX + rotationMatrix.x[1] * touch.pageY,\n    pageY: rotationMatrix.y[0] * touch.pageX + rotationMatrix.y[1] * touch.pageY,\n  };\n}", "category": "Python"}, {"instruction": "hook for the deprecated property viewId on the route, will not prefix the id with the component\n\n@name sap.ui.core.routing.TargetCache#_getViewWithGlobalId\n@returns {*}\n@private\n \n@param {string} sName logs an error if it is empty or undefined\n@param {string} sType whether it's a 'View' or 'Component'\n@private", "input": "JavaScript", "output": "function (sName, sType) {\n\n\t\t\t\tif (!sName) {\n\t\t\t\t\tvar sMessage = \"A name for the \" + sType.toLowerCase() + \" has to be defined\";\n\t\t\t\t\tLog.error(sMessage, this);\n\t\t\t\t\tthrow Error(sMessage);\n\t\t\t\t}\n\n\t\t\t}", "category": "Python"}, {"instruction": "Builds a function call graph for the current contracts.\nExample Contract call graph:\n\n{\n\"KingOfTheEtherThrone\": {\n\"contracts\": {...},                                        // Contract node as defined in abstractAstView.js\n\"functions\": {\n\"KingOfTheEtherThrone.claimThrone(string memory)\": {    // function in KingOfEtherThrone\n\"node\": {...},                                        // function node as defined in abstractAstView.js\n\"calls\": {                                            // list of full qualified function names which are called form this function\n}\n}\n}\n},\n\"foo\": {\n\"contract\": {...},           // Contract node as definded in abstractAstView.js\n\"functions\": {}             // map from full qualified function name to func node\n}\n}\n\n@contracts {list contracts} Expects as input the contract structure defined in abstractAstView.js\n@return {map (string -> Contract Call Graph)} returns map from contract name to contract call graph", "input": "JavaScript", "output": "function buildGlobalFuncCallGraph (contracts) {\n  var callGraph = {}\n  contracts.forEach((contract) => {\n    var filterNodes = (node) => { return common.isLocalCallGraphRelevantNode(node) || common.isExternalDirectCall(node) }\n    var getNodeIdent = (node) => { return common.getFullQualifiedFunctionCallIdent(contract.node, node) }\n    var getFunDefIdent = (funcDef) => { return common.getFullQuallyfiedFuncDefinitionIdent(contract.node, funcDef.node, funcDef.parameters) }\n\n    callGraph[common.getContractName(contract.node)] = { contract: contract, functions: buildLocalFuncCallGraphInternal(contract.functions, filterNodes, getNodeIdent, getFunDefIdent) }\n  })\n\n  return callGraph\n}", "category": "Python"}, {"instruction": "Limit the resultset to `n` records\n@class Model\n@method limit\n@param {integer} limit - The limit as a number.\n@param {integer} offset - Optional offset.\n\n@see Model.exec\n\n@return {Model}", "input": "JavaScript", "output": "function(limit, offset) {\n    const self = this.chain()._unresolve() // if the collection is already resolved, return a unresolved and empty copy!\n\n    offset = offset || self.getInternal('offset') || 0\n\n    if (typeof limit === 'string') limit = parseInt(limit)\n    if (typeof offset === 'string') offset = parseInt(offset)\n\n    if (!isNaN(limit)) {\n      self.setInternal('limit', limit)\n      self.setInternal('no_relation_cache', true)\n    }\n    if (!isNaN(offset)) {\n      self.setInternal('offset', offset)\n      self.setInternal('no_relation_cache', true)\n    }\n\n    if (!limit) {\n      self.clearInternal('offset', offset)\n      self.clearInternal('limit', limit)\n    }\n\n    return self\n  }", "category": "Python"}, {"instruction": "Function to format an individual tick mark\n@private", "input": "JavaScript", "output": "function(time, index, ticks, format) {\n\t\tvar me = this;\n\t\tvar adapter = me._adapter;\n\t\tvar options = me.options;\n\t\tvar formats = options.time.displayFormats;\n\t\tvar minorFormat = formats[me._unit];\n\t\tvar majorUnit = me._majorUnit;\n\t\tvar majorFormat = formats[majorUnit];\n\t\tvar majorTime = +adapter.startOf(time, majorUnit);\n\t\tvar majorTickOpts = options.ticks.major;\n\t\tvar major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;\n\t\tvar label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);\n\t\tvar tickOpts = major ? majorTickOpts : options.ticks.minor;\n\t\tvar formatter = valueOrDefault$c(tickOpts.callback, tickOpts.userCallback);\n\n\t\treturn formatter ? formatter(label, index, ticks) : label;\n\t}", "category": "Python"}, {"instruction": "Case-insensitive scan of current elements only (do not descend).", "input": "JavaScript", "output": "function scanLevel(element) {\n        if (element) {\n          for (var i = 0, len = element.length; i < len; i++) {\n            if (element[i].nodeName.toLowerCase() === nodeName) {\n              return element[i];\n            }\n          }\n        }\n        return null;\n      }", "category": "Python"}, {"instruction": "gets an iframes document in a cross browser compatible manner", "input": "JavaScript", "output": "function getiframeDocument($iframe) {\n            var iframeDoc = $iframe[0].contentWindow || $iframe[0].contentDocument;\n            if (iframeDoc.document) {\n                iframeDoc = iframeDoc.document;\n            }\n            return iframeDoc;\n        }", "category": "Python"}, {"instruction": "Left/right translate effect", "input": "JavaScript", "output": "function scrollInterpolator3 (index, carouselProps) {\n    const range = [2, 1, 0, -1];\n    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);\n    const outputRange = range;\n\n    return { inputRange, outputRange };\n}", "category": "Python"}, {"instruction": "Hooks and props are merged as arrays.", "input": "JavaScript", "output": "function mergeHook (\n  parentVal,\n  childVal\n) {\n  const res = childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal;\n  return res\n    ? dedupeHooks(res)\n    : res\n}", "category": "Python"}, {"instruction": "Converts a SAT.Polygon into a SVG path string.", "input": "JavaScript", "output": "function poly2path(polygon) {\n  var pos = polygon.pos;\n  var points = polygon.calcPoints;\n  var result = 'M' + pos.x + ' ' + pos.y;\n  result += 'M' + (pos.x + points[0].x) + ' ' + (pos.y + points[0].y);\n  for (var i = 1; i < points.length; i++) {\n    var point = points[i];\n    result += 'L' + (pos.x + point.x) + ' ' + (pos.y + point.y);\n  }\n  result += 'Z';\n  return result;\n}", "category": "Python"}, {"instruction": "Registration", "input": "JavaScript", "output": "function supportsObject(grip, noGrip = false) {\n  const type = getGripType(grip, noGrip);\n  if (noGrip === true || !isGrip(grip)) {\n    return type == \"function\";\n  }\n\n  return type == \"Function\";\n}", "category": "Python"}, {"instruction": "Given a simple array of css color strings, eg. [\"red\", \"orange\", \"black\"],\nreturn an evenly spaced array suitable to instantiate a color map.\n@private\n@param  {String[]} simpleArray A simple array of css color strings, eg. [\"red\", \"orange\", \"black\"].\n@return {Object[]} An array of {color, offset} objects.", "input": "JavaScript", "output": "function simpleArrayToArray(simpleArray) {\n  return simpleArray\n    .map(function(el, index) {\n      return {\n        color: el,\n        offset: simpleArray.length === 1 ? 0 : index / (simpleArray.length - 1)\n      };\n    })\n    .filter(function(o) {\n      return o.color !== \"\";\n    });\n}", "category": "Python"}, {"instruction": "Highlight the searching keywords", "input": "JavaScript", "output": "function highlightKeywords() {\n      var q = url('?q');\n      if (q !== null) {\n        var keywords = q.split(\"%20\");\n        keywords.forEach(function (keyword) {\n          if (keyword !== \"\") {\n            $('.data-searchable *').mark(keyword);\n            $('article *').mark(keyword);\n          }\n        });\n      }\n    }", "category": "Python"}, {"instruction": "Invoked when a splitter's dragListener fires dragStart. Calculates the splitters\nmovement area once (so that it doesn't need calculating on every mousemove event)\n\n@param   {lm.controls.Splitter} splitter\n\n@returns {void}", "input": "JavaScript", "output": "function( splitter ) {\n\t\tvar items = this._getItemsForSplitter( splitter ),\n\t\t\tminSize = this.layoutManager.config.dimensions[ this._isColumn ? 'minItemHeight' : 'minItemWidth' ];\n\t\n\t\tthis._splitterPosition = 0;\n\t\tthis._splitterMinPosition = -1 * ( items.before.element[ this._dimension ]() - minSize );\n\t\tthis._splitterMaxPosition = items.after.element[ this._dimension ]() - minSize;\n\t}", "category": "Python"}, {"instruction": "Transparently handle JSONP. Although this does require wrapping the Request#send() method which is a bit nasty. Other alternative is to always pass the response on and include this middleware after the routes.", "input": "JavaScript", "output": "function () {\n    return function (req, res, next) {\n      var _send = res.send;\n      res.send = function (body) {\n        var callback = req.params.callback,\n            isJSONP  = res.get('Content-Type') === 'application/json' && callback;\n\n        if (body && req.method !== 'HEAD' && isJSONP) {\n          res.contentType('js');\n          body = callback + '(' + body.toString().trim() + ');';\n        }\n        _send.call(this, body);\n      };\n      next();\n    };\n  }", "category": "Python"}, {"instruction": "Checks if `value` is a number.\n\nNote: `NaN` is considered a number. See http://es5.github.io/#x8.5.\n\n@static\n@memberOf _\n@category Objects\n@param {*} value The value to check.\n@returns {boolean} Returns `true` if the `value` is a number, else `false`.\n@example\n\n_.isNumber(8.4 * 5);\n// => true", "input": "JavaScript", "output": "function isNumber(value) {\n    return typeof value == 'number' ||\n      value && typeof value == 'object' && toString.call(value) == numberClass || false;\n  }", "category": "Python"}, {"instruction": "------------------------------------------------------------------------------ Helpers ------------------------------------------------------------------------------ \nGets all of the Use Strict Directives in the Directive Prologue of a group of\nstatements.\n@param {ASTNode[]} statements Statements in the program or function body.\n@returns {ASTNode[]} All of the Use Strict Directives.", "input": "JavaScript", "output": "function getUseStrictDirectives(statements) {\n    const directives = [];\n\n    for (let i = 0; i < statements.length; i++) {\n        const statement = statements[i];\n\n        if (\n            statement.type === \"ExpressionStatement\" &&\n            statement.expression.type === \"Literal\" &&\n            statement.expression.value === \"use strict\"\n        ) {\n            directives[i] = statement;\n        } else {\n            break;\n        }\n    }\n\n    return directives;\n}", "category": "Python"}, {"instruction": "Loads configuration data from a JSON file into this config object.\n@note Loading configuration will reset all existing configuration\non the object.\n@!macro nobrowser\n@param path [String] the path relative to your process's current\nworking directory to load configuration from.\n@return [AWS.Config] the same configuration object", "input": "JavaScript", "output": "function loadFromPath(path) {\n    this.clear();\n\n    var options = JSON.parse(AWS.util.readFileSync(path));\n    var fileSystemCreds = new AWS.FileSystemCredentials(path);\n    var chain = new AWS.CredentialProviderChain();\n    chain.providers.unshift(fileSystemCreds);\n    chain.resolve(function (err, creds) {\n      if (err) throw err;\n      else options.credentials = creds;\n    });\n\n    this.constructor(options);\n\n    return this;\n  }", "category": "Python"}, {"instruction": "Apply the operators that apply to the 'browser:reload' event\n@param {Rx.Observable} subject\n@param options\n@returns {Rx.Observable}", "input": "JavaScript", "output": "function applyReloadOperators(subject, options) {\n    var operators = [\n        {\n            option: \"reloadDebounce\",\n            fnName: \"debounce\"\n        },\n        {\n            option: \"reloadThrottle\",\n            fnName: \"throttle\"\n        },\n        {\n            option: \"reloadDelay\",\n            fnName: \"delay\"\n        }\n    ];\n\n    return applyOperators(\n        operators,\n        subject,\n        options,\n        options.getIn([\"debug\", \"scheduler\"])\n    );\n}", "category": "Python"}, {"instruction": "Join lists with \"i\" and \"i+1\"", "input": "JavaScript", "output": "function addToList(i, L, R) {\n    R[L[i + 1]] = R[i];\n    L[R[i]] = L[i + 1];\n    R[i] = i + 1;\n    L[i + 1] = i;\n}", "category": "Python"}, {"instruction": "Documents are considered to be out-of-sync if they are dirty and\ndo not have \"update while editing\" support\n@param {Document} doc\n@return {boolean}", "input": "JavaScript", "output": "function _docIsOutOfSync(doc) {\n        var liveDoc = _server && _server.get(doc.file.fullPath),\n            isLiveEditingEnabled = liveDoc && liveDoc.isLiveEditingEnabled();\n\n        return doc.isDirty && !isLiveEditingEnabled;\n    }", "category": "Python"}, {"instruction": "/* global dom", "input": "JavaScript", "output": "function noParentScrolled(element, offset) {\n\telement = dom.getComposedParent(element);\n\twhile (element && element.nodeName.toLowerCase() !== 'html') {\n\t\tif (element.scrollTop) {\n\t\t\toffset += element.scrollTop;\n\t\t\tif (offset >= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telement = dom.getComposedParent(element);\n\t}\n\treturn true;\n}", "category": "Python"}, {"instruction": "Called by native code when returning error result from an action.", "input": "JavaScript", "output": "function (callbackId, args) {\n        // TODO: Deprecate callbackSuccess and callbackError in favour of callbackFromNative.\n        // Derive success from status.\n        cordova.callbackFromNative(callbackId, false, args.status, [args.message], args.keepCallback);\n    }", "category": "Python"}, {"instruction": "@private\nProcess and load the current theme into the editor\n\n@return {$.Promise} promise object resolved with the theme object and all\ncorresponding new css/less and scrollbar information", "input": "JavaScript", "output": "function loadCurrentTheme() {\n        var theme = getCurrentTheme();\n\n        var pending = theme && FileUtils.readAsText(theme.file)\n            .then(function (lessContent) {\n                return lessifyTheme(lessContent.replace(commentRegex, \"\"), theme);\n            })\n            .then(function (content) {\n                var result = extractScrollbars(content);\n                theme.scrollbar = result.scrollbar;\n                return result.content;\n            })\n            .then(function (cssContent) {\n                $(\"body\").toggleClass(\"dark\", theme.dark);\n                styleNode.text(cssContent);\n                return theme;\n            });\n\n        return $.when(pending);\n    }", "category": "Python"}, {"instruction": "Return a string that shows the literal parent hierarchy of the selector\nin info.\n\n@param {!SelectorInfo} info\n@param {boolean=} useGroup true to append selectorGroup instead of selector\n@return {string} the literal parent hierarchy of the selector", "input": "JavaScript", "output": "function getCompleteSelectors(info, useGroup) {\n        if (info.parentSelectors) {\n            // Show parents with / separators.\n            var completeSelectors = info.parentSelectors + \" / \";\n            if (useGroup && info.selectorGroup) {\n                completeSelectors += info.selectorGroup;\n            } else {\n                completeSelectors += info.selector;\n            }\n            return completeSelectors;\n        } else if (useGroup && info.selectorGroup) {\n            return info.selectorGroup;\n        }\n\n        return info.selector;\n    }", "category": "Python"}, {"instruction": "/*", "input": "JavaScript", "output": "function preTransformVFor (el, options) {\n  var exp = getAndRemoveAttr(el, 'v-for');\n  if (!exp) {\n    return\n  }\n\n  var res = parseFor(exp);\n  if (!res) {\n    if (process.env.NODE_ENV !== 'production' && options.warn) {\n      options.warn((\"Invalid v-for expression: \" + exp));\n    }\n    return\n  }\n\n  var desc = {\n    '@expression': res.for,\n    '@alias': res.alias\n  };\n  if (res.iterator2) {\n    desc['@key'] = res.iterator1;\n    desc['@index'] = res.iterator2;\n  } else {\n    desc['@index'] = res.iterator1;\n  }\n\n  delete el.attrsMap['v-for'];\n  addRawAttr(el, '[[repeat]]', desc);\n}", "category": "Python"}, {"instruction": "create an touch point\n@constructor\n@param target\n@param identifier\n@param pos\n@param deltaX\n@param deltaY\n@returns {Object} touchPoint", "input": "JavaScript", "output": "function Touch(target, identifier, pos, deltaX, deltaY) {\n        deltaX = deltaX || 0;\n        deltaY = deltaY || 0;\n\n        this.identifier = identifier;\n        this.target = target;\n        this.clientX = pos.clientX + deltaX;\n        this.clientY = pos.clientY + deltaY;\n        this.screenX = pos.screenX + deltaX;\n        this.screenY = pos.screenY + deltaY;\n        this.pageX = pos.pageX + deltaX;\n        this.pageY = pos.pageY + deltaY;\n    }", "category": "Python"}, {"instruction": "process items to extract files to be uploaded\n@param  {File[]} items items to process\n@param  {Event} event event that led to upload", "input": "JavaScript", "output": "function loadFiles(items, event) {\n      if(!items.length){\n        return; // nothing to do\n      }\n      $.fire('beforeAdd');\n      var files = [];\n      processCallbacks(\n          Array.prototype.map.call(items, function(item){\n            // bind all properties except for callback\n            var entry = item;\n            if('function' === typeof item.webkitGetAsEntry){\n              entry = item.webkitGetAsEntry();\n            }\n            return processItem.bind(null, entry, \"\", files);\n          }),\n          function(){\n            if(files.length){\n              // at least one file found\n              appendFilesFromFileList(files, event);\n            }\n          }\n      );\n    }", "category": "Python"}, {"instruction": "Displays the UI for a signed out user.", "input": "JavaScript", "output": "function() {\n  document.getElementById('user-signed-in').style.display = 'none';\n  document.getElementById('user-signed-out').style.display = 'block';\n  ui.start('#firebaseui-container', getUiConfig());\n}", "category": "Python"}, {"instruction": "TODO(dbeam): DO NOT USE. THIS IS DEPRECATED. Use an action-link instead.\nCall this to stop clicks on <a href=\"#\"> links from scrolling to the top of\nthe page (and possibly showing a # in the link).", "input": "JavaScript", "output": "function preventDefaultOnPoundLinkClicks() {\n  document.addEventListener('click', function(e) {\n    var anchor = findAncestor(/** @type {Node} */(e.target), function(el) {\n      return el.tagName == 'A';\n    });\n    // Use getAttribute() to prevent URL normalization.\n    if (anchor && anchor.getAttribute('href') == '#')\n      e.preventDefault();\n  });\n}", "category": "Python"}, {"instruction": "OAuth2 Username-Password Flow (Resource Owner Password Credentials)\n\n@param {String} username - Salesforce username\n@param {String} password - Salesforce password\n@param {Callback.<TokenResponse>} [callback] - Callback function\n@returns {Promise.<TokenResponse>}", "input": "JavaScript", "output": "function(username, password, callback) {\n    return this._postParams({\n      grant_type : \"password\",\n      username : username,\n      password : password,\n      client_id : this.clientId,\n      client_secret : this.clientSecret,\n      redirect_uri : this.redirectUri\n    }, callback);\n  }", "category": "Python"}, {"instruction": "Turns off the event handlers for a given event, optionally for a specific preference\nor a specific handler function.\n\n@param {string} event Name of the event for which to turn off listening\n@param {string|Function} preferenceID Name of a specific preference or the handler function\n@param {?Function} handler Specific handler which should stop being notified", "input": "JavaScript", "output": "function (event, preferenceID, handler) {\n            if (typeof preferenceID === \"function\") {\n                handler = preferenceID;\n                preferenceID = null;\n            }\n\n            if (preferenceID) {\n                var pref = this.getPreference(preferenceID);\n                pref.off(event, handler);\n            } else {\n                this._off_internal(event, handler);\n            }\n        }", "category": "Python"}, {"instruction": "Validate a book configuration for plugins and\nreturns an update configuration with default values.\n\n@param {Book}\n@param {OrderedMap<String:Plugin>}\n@return {Promise<Book>}", "input": "JavaScript", "output": "function validateConfig(book, plugins) {\n    return Promise.reduce(plugins, function(newBook, plugin) {\n        return validatePluginConfig(newBook, plugin);\n    }, book);\n}", "category": "Python"}, {"instruction": "Convert the JSON object to a padded buffer.\n\nPad the JSON with extra whitespace to fit the next 4-byte boundary. This ensures proper alignment\nfor the section that follows.\n\n@param {Object} [json] The JSON object.\n@returns {Buffer} The padded JSON buffer.\n\n@private", "input": "JavaScript", "output": "function getJsonBufferPadded(json) {\n    let string = JSON.stringify(json);\n\n    const boundary = 4;\n    const byteLength = Buffer.byteLength(string);\n    const remainder = byteLength % boundary;\n    const padding = (remainder === 0) ? 0 : boundary - remainder;\n    let whitespace = '';\n    for (let i = 0; i < padding; ++i) {\n        whitespace += ' ';\n    }\n    string += whitespace;\n\n    return Buffer.from(string);\n}", "category": "Python"}, {"instruction": "@description Formats API response into handlebars/theme format.\n\n@return {Object} containing page variables", "input": "JavaScript", "output": "function formatPageResponse(result) {\n    var response = {};\n\n    if (result.posts) {\n        response.posts = result.posts;\n    }\n\n    if (result.meta && result.meta.pagination) {\n        response.pagination = result.meta.pagination;\n    }\n\n    _.each(result.data, function (data, name) {\n        if (data.meta) {\n            // Move pagination to be a top level key\n            response[name] = data;\n            response[name].pagination = data.meta.pagination;\n            delete response[name].meta;\n        } else {\n            // This is a single object, don't wrap it in an array\n            response[name] = data[0];\n        }\n    });\n\n    return response;\n}", "category": "Python"}, {"instruction": "{{{1 numeric encode", "input": "JavaScript", "output": "function encode_numeric(str) {\n    var len = str.length;\n    var bits = [];\n\n    for (var i = 0; i < len; i += 3) {\n        var s = str.substr(i, 3);\n        var b = Math.ceil(s.length * 10 / 3);\n        pushBits(bits, b, parseInt(s, 10));\n    }\n\n    var res = {};\n\n    var d = [0, 0, 0, 1];\n    pushBits(d, 14, len);\n    res.data27 = d.concat(bits);\n\n    if (len < 4096) {\n        var d = [0, 0, 0, 1];\n        pushBits(d, 12, len);\n        res.data10 = d.concat(bits);\n    }\n\n    if (len < 1024) {\n        var d = [0, 0, 0, 1];\n        pushBits(d, 10, len);\n        res.data1 = d.concat(bits);\n    }\n\n    return res;\n}", "category": "Python"}, {"instruction": "Validate regular expression literals\n@param {ASTNode} node node to validate\n@returns {void}\n@private", "input": "JavaScript", "output": "function checkLiteral(node) {\n            const token = sourceCode.getFirstToken(node),\n                nodeType = token.type,\n                nodeValue = token.value;\n\n            if (nodeType === \"RegularExpression\") {\n                checkRegex(node, nodeValue, token.range[0]);\n            }\n        }", "category": "Python"}, {"instruction": "Issues a request to cancel a statement.\n\n@param {Object} statementContext\n@param {Object} statement\n@param {Function} callback", "input": "JavaScript", "output": "function sendCancelStatement(statementContext, statement, callback)\n{\n  var url;\n  var json;\n\n  // use different rest endpoints based on whether the statement id is available\n  if (statementContext.statementId)\n  {\n    url = '/queries/' + statementContext.statementId + '/abort-request';\n  }\n  else\n  {\n    url  = '/queries/v1/abort-request';\n    json =\n    {\n      requestId: statementContext.requestId\n    };\n  }\n\n  // issue a request to cancel the statement\n  statementContext.services.sf.request(\n  {\n    method   : 'POST',\n    url      : url,\n    json     : json,\n    callback : function(err)\n    {\n      // if a callback was specified, invoke it\n      if (Util.isFunction(callback))\n      {\n        callback(Errors.externalize(err), statement);\n      }\n    }\n  });\n}", "category": "Python"}, {"instruction": "Search for abbreviation in editor from current caret position\n@param {IEmmetEditor} editor Editor instance\n@return {String}", "input": "JavaScript", "output": "function findAbbreviation(editor) {\n\t\tvar r = range(editor.getSelectionRange());\n\t\tvar content = String(editor.getContent());\n\t\tif (r.length()) {\n\t\t\t// abbreviation is selected by user\n\t\t\treturn r.substring(content);\n\t\t}\n\t\t\n\t\t// search for new abbreviation from current caret position\n\t\tvar curLine = editor.getCurrentLineRange();\n\t\treturn actionUtils.extractAbbreviation(content.substring(curLine.start, r.start));\n\t}", "category": "Python"}, {"instruction": "Sum the width of all tabs.\n\n@param elements\n@returns {number}", "input": "JavaScript", "output": "function getTotalTabsWidth(elements) {\n    var sum = 0, i, tab;\n\n    for (i = 0; i < elements.tabs.length; i++) {\n      tab = elements.tabs[i];\n      sum += tab.offsetWidth;\n    }\n\n    return sum;\n  }", "category": "Python"}, {"instruction": "PTR records with a TTL of 0 is considered a \"goodbye\" announcement. I.e. a DNS response broadcasted when a service shuts down in order to let the network know that the service is no longer going to be available.  For more info see: https://tools.ietf.org/html/rfc6762#section-8.4  This function returns an array of all resource records considered a goodbye record", "input": "JavaScript", "output": "function goodbyes (name, packet) {\n  return packet.answers.concat(packet.additionals)\n    .filter(function (rr) {\n      return rr.type === 'PTR' && rr.ttl === 0 && dnsEqual(rr.name, name)\n    })\n    .map(function (rr) {\n      return rr.data\n    })\n}", "category": "Python"}, {"instruction": "Execute the down function of currently executed seeds.", "input": "JavaScript", "output": "function (specification, scope, callback) {\n    var executeUndoSeed = load('undo-seed');\n    if (arguments.length > 0) {\n      if (typeof specification === 'number') {\n        this.internals.argv.count = specification;\n\n        if (scope) {\n          this.internals.migrationMode = scope;\n          this.internals.matching = scope;\n        }\n      } else if (typeof specification === 'string') {\n        this.internals.migrationMode = scope;\n        this.internals.matching = scope;\n      }\n    }\n\n    return Promise.fromCallback(\n      function (callback) {\n        executeUndoSeed(this.internals, this.config, callback);\n      }.bind(this)\n    ).asCallback(callback);\n  }", "category": "Python"}, {"instruction": "Get a call object built with the provided options.\n@param {grpc.Channel} channel\n@param {string} path\n@param {grpc.Client~CallOptions=} options Options object.", "input": "JavaScript", "output": "function getCall(channel, path, options) {\n  var deadline;\n  var host;\n  var parent;\n  var propagate_flags;\n  var credentials;\n  if (options) {\n    deadline = options.deadline;\n    host = options.host;\n    parent = options.parent ? options.parent.call : undefined;\n    propagate_flags = options.propagate_flags;\n    credentials = options.credentials;\n  }\n  if (deadline === undefined) {\n    deadline = Infinity;\n  }\n  var call = channel.createCall(path, deadline, host,\n                                parent, propagate_flags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}", "category": "Python"}, {"instruction": "@class StaticAsset\n@implements Asset\n@classdesc\n\nAn immutable {@link Asset} compatible with {@link WebGlStage} and\n{@link CssStage}.\n\n@param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} element The\nunderlying pixel source.\n@throws If the pixel source is unsupported.", "input": "JavaScript", "output": "function StaticAsset(element) {\n  var supported = false;\n  for (var type in propertyMap) {\n    if (global[type] && element instanceof global[type]) {\n      supported = true;\n      this._widthProp = propertyMap[type][0];\n      this._heightProp = propertyMap[type][1];\n      break;\n    }\n  }\n  if (!supported) {\n    throw new Error('Unsupported pixel source');\n  }\n\n  this._element = element;\n}", "category": "Python"}, {"instruction": "Sends a command to node to cause a restart.", "input": "JavaScript", "output": "function restartNode() {\n        try {\n            _nodeConnection.domains.base.restartNode();\n        } catch (e) {\n            window.alert(\"Failed trying to restart Node: \" + e.message);\n        }\n    }", "category": "Python"}, {"instruction": "Creates a mongoDB object representation of this object.\n\n<pre><code>\n{\n'_id' : , // {number} id for this file\n'filename' : , // {string} name for this file\n'contentType' : , // {string} mime type for this file\n'length' : , // {number} size of this file?\n'chunksize' : , // {number} chunk size used by this file\n'uploadDate' : , // {Date}\n'aliases' : , // {array of string}\n'metadata' : , // {string}\n}\n</code></pre>\n\n@ignore", "input": "JavaScript", "output": "function(self, callback) {\n  // Calcuate the length\n  var mongoObject = {\n    _id: self.fileId,\n    filename: self.filename,\n    contentType: self.contentType,\n    length: self.position ? self.position : 0,\n    chunkSize: self.chunkSize,\n    uploadDate: self.uploadDate,\n    aliases: self.aliases,\n    metadata: self.metadata\n  };\n\n  var md5Command = { filemd5: self.fileId, root: self.root };\n  self.db.command(md5Command, function(err, results) {\n    if (err) return callback(err);\n\n    mongoObject.md5 = results.md5;\n    callback(null, mongoObject);\n  });\n}", "category": "Python"}, {"instruction": "get a list of pointers\n@returns {Array}     touchlist", "input": "JavaScript", "output": "function() {\n      var self = this;\n      var touchlist = [];\n\n      // we can use forEach since pointerEvents only is in IE10\n      Object.keys(self.pointers).sort().forEach(function(id) {\n        touchlist.push(self.pointers[id]);\n      });\n      return touchlist;\n    }", "category": "Python"}, {"instruction": "Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.", "input": "JavaScript", "output": "function GetSlope(aT, aA1, aA2) {\n\t\t\treturn 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n\t\t}", "category": "Python"}, {"instruction": "Undo elements to its previous state\n@type {Function}", "input": "JavaScript", "output": "function () {\n      if (!els.length) return\n      els.map(function (el) {\n        el.parentElement.removeChild(el)\n      })\n      els = []\n    }", "category": "Python"}, {"instruction": "Creates a type derived from {@link CatalogMember} based on a given URL.\n\n@param {String} url The derived type name.\n@param {Terria} terria The Terria instance.\n@param {Boolean} allowLoad Whether it's ok to attempt to load the URL and detect failures. We generally do this for WMS type services, but not for local files.\n@returns {CatalogMember} The constructed data item or promise, or undefined if the URL is not supported.", "input": "JavaScript", "output": "function(url, terria, allowLoad, index) {\n  index = index || 0;\n  if (index >= mapping.length) {\n    return undefined;\n  }\n  if (\n    (mapping[index].matcher && !mapping[index].matcher(url)) ||\n    (mapping[index].requiresLoad && !allowLoad)\n  ) {\n    return createCatalogItemFromUrl(url, terria, allowLoad, index + 1);\n  } else {\n    var item = new mapping[index].constructor(terria);\n    if (!allowLoad) {\n      return item;\n    }\n    item.url = url;\n    item.name = url;\n    return item\n      .load()\n      .yield(item)\n      .otherwise(function(e) {\n        console.log(e);\n        return createCatalogItemFromUrl(url, terria, allowLoad, index + 1);\n      });\n  }\n}", "category": "Python"}, {"instruction": "terminate process, err (if defined) is from seneca.close", "input": "JavaScript", "output": "function(close_err) {\n            if (!undead) {\n              process.nextTick(function() {\n                if (close_err) {\n                  instance.log.fatal({\n                    kind: 'close',\n                    err: Util.inspect(close_err)\n                  })\n                }\n\n                if (test) {\n                  if (close_err) {\n                    Print.err(close_err)\n                  }\n\n                  Print.err(stderrmsg)\n                  Print.err(\n                    '\\nSENECA TERMINATED at ' +\n                      new Date().toISOString() +\n                      '. See above for error report.\\n'\n                  )\n                }\n\n                so.system.exit(1)\n              })\n            }\n          }", "category": "Python"}, {"instruction": "Checks for an active Internet connection by doing a DNS lookup of Microsoft.com.\n\n@return {Promise.<boolean>} - True if lookup succeeded (or if we skip the test)", "input": "JavaScript", "output": "function checkInternetConnection () {\n  return new Promise((resolve) => {\n    require('dns').lookup('microsoft.com', (err) => {\n      if (err && err.code === 'ENOTFOUND') {\n        resolve(false)\n      } else {\n        resolve(true)\n      }\n    })\n  })\n}", "category": "Python"}, {"instruction": "Creates a local instance of an alert group.\n\n@param {Object} props The properties for the alert group.\n@return {splunkjs.Service.FiredAlertGroup} A new `splunkjs.Service.FiredAlertGroup` instance.\n\n@method splunkjs.Service.FiredAlertGroupCollection", "input": "JavaScript", "output": "function(props) {\n            var entityNamespace = utils.namespaceFromProperties(props);\n            return new root.FiredAlertGroup(this.service, props.name, entityNamespace);\n        }", "category": "Python"}, {"instruction": "Creates an array with the control properties that are inherited.\n@param {Object} control - UI5 control.\n@returns {Array}\n@private", "input": "JavaScript", "output": "function (control) {\n\t\t\t\tvar result = [];\n\t\t\t\tvar inheritedMetadata = control.getMetadata().getParent();\n\n\t\t\t\twhile (inheritedMetadata instanceof ElementMetadata) {\n\t\t\t\t\tresult.push(this._copyInheritedProperties(control, inheritedMetadata));\n\t\t\t\t\tinheritedMetadata = inheritedMetadata.getParent();\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}", "category": "Python"}, {"instruction": "Helper that creates a NDEF record containing an absolute URI.\n\nAn Absolute URI record means the URI describes the payload of the record.\n\nFor example a SOAP message could use \"http://schemas.xmlsoap.org/soap/envelope/\"\nas the type and XML content for the payload.\n\nAbsolute URI can also be used to write LaunchApp records for Windows.\n\nSee 2.4.2 Payload Type of the NDEF Specification\nhttp://www.nfc-forum.org/specs/spec_list#ndefts\n\nNote that by default, Android will open the URI defined in the type\nfield of an Absolute URI record (TNF=3) and ignore the payload.\nBlackBerry and Windows do not open the browser for TNF=3.\n\nTo write a URI as the payload use ndef.uriRecord(uri)\n\n@uri String\n@payload byte[] or String\n@id byte[] (optional)", "input": "JavaScript", "output": "function (uri, payload, id) {\n        if (!id) { id = []; }\n        if (!payload) { payload = []; }\n        return ndef.record(ndef.TNF_ABSOLUTE_URI, uri, id, payload);\n    }", "category": "Python"}, {"instruction": "listing descendant nodes\n\n@param {Node} node\n@param {Function} [pred] - predicate function", "input": "JavaScript", "output": "function listDescendant(node, pred) {\n  const descendants = [];\n  pred = pred || func.ok;\n\n  // start DFS(depth first search) with node\n  (function fnWalk(current) {\n    if (node !== current && pred(current)) {\n      descendants.push(current);\n    }\n    for (let idx = 0, len = current.childNodes.length; idx < len; idx++) {\n      fnWalk(current.childNodes[idx]);\n    }\n  })(node);\n\n  return descendants;\n}", "category": "Python"}, {"instruction": "client.enableSessionPersistence\n\n@description Enable session persistence of the requested type\n\n@param {Object}          loadBalancer      the loadBalancer or loadBalancerId\n@param {String}          type              HTTP_COOKIE or SOURCE_IP\n@param {function}        callback", "input": "JavaScript", "output": "function (loadBalancer, type, callback) {\n    var self = this,\n        loadBalancerId =\n          loadBalancer instanceof lb.LoadBalancer ? loadBalancer.id : loadBalancer;\n\n    if (!type || (type !== 'HTTP_COOKIE' && type !== 'SOURCE_IP')) {\n      throw new Error('Please provide a valid session persistence type');\n    }\n\n    self._request({\n      path: urlJoin(_urlPrefix, loadBalancerId, 'sessionpersistence'),\n      method: 'PUT',\n      body: {\n        sessionPersistence: {\n          persistenceType: type\n        }\n      }\n    }, function (err) {\n      return callback(err);\n    });\n  }", "category": "Python"}, {"instruction": "Resize method bound to the polar\n@param {module:echarts/coord/polar/PolarModel} polarModel\n@param {module:echarts/ExtensionAPI} api", "input": "JavaScript", "output": "function resizePolar(polar, polarModel, api) {\n    var center = polarModel.get('center');\n    var width = api.getWidth();\n    var height = api.getHeight();\n\n    polar.cx = parsePercent(center[0], width);\n    polar.cy = parsePercent(center[1], height);\n\n    var radiusAxis = polar.getRadiusAxis();\n    var size = Math.min(width, height) / 2;\n    var radius = parsePercent(polarModel.get('radius'), size);\n    radiusAxis.inverse\n        ? radiusAxis.setExtent(radius, 0)\n        : radiusAxis.setExtent(0, radius);\n}", "category": "Python"}, {"instruction": "+'s are replaced with spaces when used in query params, this returns them to +'s, then removes remaining whitespace. https://github.com/badges/shields/pull/1546", "input": "JavaScript", "output": "function decodeDataUrlFromQueryParam(value) {\n  if (typeof value !== 'string') {\n    return undefined\n  }\n  const maybeDataUrl = prependPrefix(value, 'data:')\n    .replace(/ /g, '+')\n    .replace(/\\s/g, '')\n  return isDataUrl(maybeDataUrl) ? maybeDataUrl : undefined\n}", "category": "Python"}, {"instruction": "* -1 if rtl scroll max is negative", "input": "JavaScript", "output": "function(base) {\n                        return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));\n                    }", "category": "Python"}, {"instruction": "This next function modelled on Cesium.geoJsonDataSource's defaultDescribe.", "input": "JavaScript", "output": "function describeWithoutUnderscores(properties, nameProperty) {\n  var html = \"\";\n  for (var key in properties) {\n    if (properties.hasOwnProperty(key)) {\n      if (key === nameProperty || simpleStyleIdentifiers.indexOf(key) !== -1) {\n        continue;\n      }\n      var value = properties[key];\n      if (typeof value === \"object\") {\n        value = describeWithoutUnderscores(value);\n      } else {\n        value = formatPropertyValue(value);\n      }\n      key = key.replace(/_/g, \" \");\n      if (defined(value)) {\n        html += \"<tr><th>\" + key + \"</th><td>\" + value + \"</td></tr>\";\n      }\n    }\n  }\n  if (html.length > 0) {\n    html =\n      '<table class=\"cesium-infoBox-defaultTable\"><tbody>' +\n      html +\n      \"</tbody></table>\";\n  }\n  return html;\n}", "category": "Python"}, {"instruction": "Reads files from .desktop and computes a version hash.\n\n@param {string} dir - path\n@returns {Promise<Object>}", "input": "JavaScript", "output": "function readFilesAndComputeDesktopHash(dir) {\n    const desktopHash = crypto.createHash('sha1');\n\n    return new Promise((resolve, reject) => {\n        getFileList(dir)\n            .catch(reject)\n            .then(readAndHashFiles)\n            .catch(reject)\n            .then((result) => {\n                const hash = result.files.reduce(\n                    (tmpHash, file) => {\n                        tmpHash += result.fileHashes[file];\n                        return tmpHash;\n                    }, ''\n                );\n                desktopHash.update(hash);\n                result.hash = desktopHash.digest('hex');\n                resolve(result);\n            });\n    });\n}", "category": "Python"}, {"instruction": "Locates the instance of lm.controls.Splitter in the array of\nregistered splitters and returns a map containing the contentItem\nbefore and after the splitters, both of which are affected if the\nsplitter is moved\n\n@param   {lm.controls.Splitter} splitter\n\n@returns {Object} A map of contentItems that the splitter affects", "input": "JavaScript", "output": "function( splitter ) {\n\t\tvar index = lm.utils.indexOf( splitter, this._splitter );\n\t\t\n\t\treturn {\n\t\t\tbefore: this.contentItems[ index ],\n\t\t\tafter: this.contentItems[ index + 1 ]\n\t\t};\n\t}", "category": "Python"}, {"instruction": "Find the deepest React component completely containing the root of the\npassed-in instance (for use when entire React trees are nested within each\nother). If React trees are not nested, returns null.", "input": "JavaScript", "output": "function findRootContainerNode(inst) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  if (typeof inst.tag === 'number') {\n    while (inst['return']) {\n      inst = inst['return'];\n    }\n    if (inst.tag !== HostRoot) {\n      // This can happen if we're in a detached tree.\n      return null;\n    }\n    return inst.stateNode.containerInfo;\n  } else {\n    while (inst._hostParent) {\n      inst = inst._hostParent;\n    }\n    var rootNode = ReactDOMComponentTree_1.getNodeFromInstance(inst);\n    return rootNode.parentNode;\n  }\n}", "category": "Python"}, {"instruction": "Replace any characters that can't be sent on with an underscore", "input": "JavaScript", "output": "function sanitizeTags(value, telegraf) {\n  const blacklist = telegraf ? /:|\\|/g : /:|\\||@|,/g;\n  // Replace reserved chars with underscores.\n  return String(value).replace(blacklist, '_');\n}", "category": "Python"}, {"instruction": "Converts an array of globs to full paths\n@function\n@param {array} globs - Array of globs and/or normal paths\n@return {array} Array of fully-qualified paths\n@requires glob", "input": "JavaScript", "output": "function convertGlobPaths(globs) {\n  return globs\n    .map(globString => glob.sync(globString))\n    .reduce((previous, current) => previous.concat(current), []);\n}", "category": "Python"}, {"instruction": "Log when a file changes\n@param {BrowserSync} bs\n@param data", "input": "JavaScript", "output": "function(bs, data) {\n        if (canLogFileChange(bs, data)) {\n            if (data.path[0] === \"*\") {\n                return logger.info(\n                    \"{cyan:Reloading files that match: {magenta:%s\",\n                    data.path\n                );\n            }\n\n            logger.info(\n                \"{cyan:File event [\" + data.event + \"] : {magenta:%s\",\n                data.path\n            );\n        }\n    }", "category": "Python"}, {"instruction": "\u5728 trailing edge \u4e14\u65f6\u95f4\u7b26\u5408\u6761\u4ef6\u65f6\uff0c\u8c03\u7528 trailingEdge\u51fd\u6570\uff0c\u5426\u5219\u91cd\u542f\u5b9a\u65f6\u5668", "input": "JavaScript", "output": "function timerExpired() {\n    let time = new Date()\n      .getTime();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // \u91cd\u542f\u5b9a\u65f6\u5668\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }", "category": "Python"}, {"instruction": "Keeps the selection state in sync", "input": "JavaScript", "output": "function(sender, evt)\n\t{\n\t\tvar changes = evt.getProperty('edit').changes;\n\t\tgraph.setSelectionCells(graph.getSelectionCellsForChanges(changes));\n\t}", "category": "Python"}, {"instruction": "('data.a.b', 5) => opts.data.a.b = 5", "input": "JavaScript", "output": "function (path, value) {\n    if (typeof path == 'string') {\n      path = path.split('.');\n    } else if (!Array.isArray(path)) {\n      return;\n    }\n\n    var propName = path.shift();\n    var prop = Model.allProperties[propName] || opts.extra[propName];\n    var currKey, currObj;\n\n    if (!prop) {\n      return;\n    }\n    if (path.length == 0) {\n      instance[propName] = value;\n      return;\n    }\n    currObj = instance[propName];\n\n    while(currObj && path.length > 0 ) {\n      currKey = path.shift();\n\n      if (path.length > 0) {\n        currObj = currObj[currKey];\n      } else if (currObj[currKey] !== value) {\n        currObj[currKey] = value;\n        opts.changes.push(propName);\n      }\n    }\n  }", "category": "Python"}, {"instruction": "This is an internal class and is intentionally not documented.", "input": "JavaScript", "output": "function (sector, tileMatrix, row, column, imagePath) {\n            this.sector = sector;\n            this.tileMatrix = tileMatrix;\n            this.row = row;\n            this.column = column;\n            this.imagePath = imagePath;\n\n            this.texelSize = (sector.deltaLatitude() * Angle.DEGREES_TO_RADIANS) / tileMatrix.tileHeight;\n\n            this.tileKey = tileMatrix.levelNumber.toString() + \".\" + row.toString() + \".\" + column.toString();\n\n            this.gpuCacheKey = imagePath;\n        }", "category": "Python"}, {"instruction": "Action creator for document change event. Used to create action objects\nto be passed to dispatch.\n@param  {Object} change - Document change object from Firebase callback\n@param  {Object} [originalMeta={}] - Original meta data of action\n@return {Object}                   [description]", "input": "JavaScript", "output": "function docChangeEvent(change, originalMeta = {}) {\n  const meta = { ...cloneDeep(originalMeta), path: change.doc.ref.path };\n  if (originalMeta.subcollections && !originalMeta.storeAs) {\n    meta.subcollections[0] = { ...meta.subcollections[0], doc: change.doc.id };\n  } else {\n    meta.doc = change.doc.id;\n  }\n  return {\n    type: changeTypeToEventType[change.type] || actionTypes.DOCUMENT_MODIFIED,\n    meta,\n    payload: {\n      data: change.doc.data(),\n      ordered: { oldIndex: change.oldIndex, newIndex: change.newIndex },\n    },\n  };\n}", "category": "Python"}, {"instruction": "Computes the maximum sum of values for any date\n\n@return {Number} Max value", "input": "JavaScript", "output": "function getMaxValueByDate() {\n            let keys = uniq(data.map(o => o.name));\n            let maxValueByDate = d3Array.max(dataByDateFormatted, function(d){\n                let vals = keys.map((key) => d[key]);\n\n                return d3Array.sum(vals);\n            });\n\n            return maxValueByDate;\n        }", "category": "Python"}, {"instruction": "/*\nrecursive function to get a dependencie Set which is ordered so that no depencies exist to a later on entry\n@return Set with all the dependencies.", "input": "JavaScript", "output": "function getAllDependencies(allVariables, currentKey, dependencies = new Set()) {\n\n    if (!allVariables[currentKey].dependencies.length) {\n\n        dependencies.add(`${currentKey}: ${allVariables[currentKey].value}`);\n        return Array.from(dependencies);\n    } else {\n\n        allVariables[currentKey].dependencies.forEach(dependecy => {\n            getAllDependencies(allVariables, dependecy, dependencies).forEach(newDependency => dependencies.add(newDependency));\n        });\n\n        dependencies.add(`${currentKey}: ${allVariables[currentKey].value}`);\n        return Array.from(dependencies);\n    }\n}", "category": "Python"}, {"instruction": "Inlines CSS into HTML, adds media query CSS into the <style> tag of the email, and compresses the HTML", "input": "JavaScript", "output": "function inliner(css) {\n  var css = fs.readFileSync(css).toString();\n  var mqCss = siphon(css);\n\n  var pipe = lazypipe()\n    .pipe($.inlineCss, {\n      applyStyleTags: false,\n      removeStyleTags: true,\n      preserveMediaQueries: true,\n      removeLinkTags: false\n    })\n    .pipe($.replace, '<!-- <style> -->', `<style>${mqCss}</style>`)\n    .pipe($.replace, '<link rel=\"stylesheet\" type=\"text/css\" href=\"css/app.css\">', '')\n    .pipe($.htmlmin, {\n      collapseWhitespace: true,\n      minifyCSS: true\n    });\n\n  return pipe();\n}", "category": "Python"}, {"instruction": "Emulates python's range() built-in. Returns an array of integers, counting\nup (or down) from start to end. Note that the range returned is up to, but\nNOT INCLUDING, end.\n.\n@param start  integer from which to start counting. If the end parameter is\nnot provided, this value is considered the end and start will\nbe zero.\n@param end    integer to which to count. If omitted, the function will count\nup from zero to the value of the start parameter. Note that\nthe array returned will count up to but will not include this\nvalue.\n@return       an array of consecutive integers.", "input": "JavaScript", "output": "function range(start, end)\n{\n    if (arguments.length == 1) {\n        var end = start;\n        start = 0;\n    }\n\n    var r = [];\n    if (start < end) {\n        while (start != end)\n            r.push(start++);\n    }\n    else {\n        while (start != end)\n            r.push(start--);\n    }\n    return r;\n}", "category": "Python"}, {"instruction": "Obtains the children of a remote resource\n@param location The location of the item to obtain children for\n@return A deferred that will provide the array of child objects when complete", "input": "JavaScript", "output": "function(location) {\n\t\t\tif (!location) {\n\t\t\t\tlocation = this._rootLocation;\n\t\t\t}\n\t\t\treturn _call(\"PROPFIND\", location, {depth:1}).then(function(response) {\n\t\t\t\tif (response.status !== 207) {\n\t\t\t\t\tthrow \"Error \" + response.status;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar multistatus = parseDAV_multistatus(response.responseText);\n\t\t\t\tvar childrenResponses = multistatus.response.slice(1);\n\t\t\t\t\n\t\t\t\tvar children = [];\n\t\t\t\twhile (childrenResponses.length !== 0) {\n\t\t\t\t\tchildren.push(createFile(childrenResponses.shift()));\n\t\t\t\t}\n\t\t\t\treturn children;\n\t\t\t});\n\t\t}", "category": "Python"}, {"instruction": "Get linefeed\n\n@param {Object} options\n@api private", "input": "JavaScript", "output": "function getLinefeed(options) {\n  var feeds = {\n    cr: '\\r',\n    crlf: '\\r\\n',\n    lf: '\\n',\n    lfcr: '\\n\\r'\n  };\n\n  return feeds[options.linefeed] || '\\n';\n}", "category": "Python"}, {"instruction": "extended", "input": "JavaScript", "output": "function( dir, result ){\n\n            result = result || new Physics.vector();\n\n            return result.clone( dir ).normalize().mult( this.radius );\n        }", "category": "Python"}, {"instruction": "if (transform == null) { throw new Error(`No transform found for ${ccName}`); }", "input": "JavaScript", "output": "function statsMethod (query = {}) {\n    const reqParams = Object.assign({}, defaults, query);\n\n    debug(\"stats request\", endpoint.url, reqParams);\n    return transport(endpoint.url, reqParams).then(function (response) {\n      if (response == null) return;\n\n      // response is something like \"GameID is required\"\n      if (typeof response === \"string\") throw new Error(response);\n\n      return transform ? transform(response) : response;\n    });\n  }", "category": "Python"}, {"instruction": "Helper function to get the text of a given document and send it to tern.\nIf DocumentManager successfully gets the file's text then we'll send it to the tern node domain.\nThe Promise for getDocumentText() is returned so that custom fail functions can be used.\n\n@param {string} filePath - the path of the file to get the text of\n@return {jQuery.Promise} - the Promise returned from DocumentMangaer.getDocumentText()", "input": "JavaScript", "output": "function getDocText(filePath) {\n                if (!FileSystem.isAbsolutePath(filePath) || // don't handle URLs\n                        filePath.slice(0, 2) === \"//\") { // don't handle protocol-relative URLs like //example.com/main.js (see #10566)\n                    return (new $.Deferred()).reject().promise();\n                }\n\n                var file = FileSystem.getFileForPath(filePath),\n                    promise = DocumentManager.getDocumentText(file);\n\n                promise.done(function (docText) {\n                    resolvedFiles[name] = filePath;\n                    numResolvedFiles++;\n                    replyWith(name, filterText(docText));\n                });\n                return promise;\n            }", "category": "Python"}, {"instruction": "We want the smallest scaled file to be uploaded first", "input": "JavaScript", "output": "function(sizes) {\n        \"use strict\";\n\n        sizes = qq.extend([], sizes);\n\n        return sizes.sort(function(a, b) {\n            if (a.maxSize > b.maxSize) {\n                return 1;\n            }\n            if (a.maxSize < b.maxSize) {\n                return -1;\n            }\n            return 0;\n        });\n    }", "category": "Python"}, {"instruction": "\u5206\u6790\u6ce8\u91ca\u4e2d\u4f9d\u8d56\u7528\u6cd5\u3002\n@param {String} comment \u6ce8\u91ca\u5185\u5bb9\n@param {Callback} [callback] \u53ef\u4ee5\u901a\u8fc7\u6b64\u53c2\u6570\u6765\u66ff\u6362\u539f\u6709\u66ff\u6362\u56de\u8c03\u51fd\u6570\u3002\n@memberOf fis.compile", "input": "JavaScript", "output": "function analyseComment(comment, callback) {\n  var reg = /(@(require|async|require\\.async)\\s+)('[^']+'|\"[^\"]+\"|[^\\s;!@#%^&*()]+)/g;\n  callback = callback || function(m, prefix, type, value) {\n    type = type === 'require' ? type : 'async';\n\n    return prefix + map[type].wrap(value);\n  };\n\n  return comment.replace(reg, callback).replace(/(?:@|#)\\s+sourceMappingURL=([^\\s]+)/g, function(_, value) {\n    return '# sourceMappingURL=' + map.sourceMap.wrap(value);\n  });\n}", "category": "Python"}, {"instruction": "Calls the provided function only after all of the channels specified\nhave been fired. All channels must be sticky channels.", "input": "JavaScript", "output": "function (h, c) {\n        var len = c.length;\n        var i = len;\n        var f = function () {\n            if (!(--i)) h();\n        };\n        for (var j = 0; j < len; j++) {\n            if (c[j].state === 0) {\n                throw Error('Can only use join with sticky channels.');\n            }\n            c[j].subscribe(f);\n        }\n        if (!len) h();\n    }", "category": "Python"}, {"instruction": "Function: getName\n\nReturns the name for the given value.", "input": "JavaScript", "output": "function(value)\n\t{\n\t\tfor (var key in mxStyleRegistry.values)\n\t\t{\n\t\t\tif (mxStyleRegistry.values[key] == value)\n\t\t\t{\n\t\t\t\treturn key;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}", "category": "Python"}, {"instruction": "Track textures used by material components, so that they can be safely\ndisposed when no longer in use. Textures must be registered here, and not\nthrough registerMaterial(), because textures may not be attached at the\ntime the material is registered.\n\n@param {Event} e", "input": "JavaScript", "output": "function (e) {\n    if (!this.textureCounts[e.detail.texture.uuid]) {\n      this.textureCounts[e.detail.texture.uuid] = 0;\n    }\n    this.textureCounts[e.detail.texture.uuid]++;\n  }", "category": "Python"}, {"instruction": "We create a Comment node for CSS comments `/* */`, but keep the LeSS comments `//` silent, by just skipping over them.", "input": "JavaScript", "output": "function () {\n                var comment;\n\n                if (input.charAt(i) !== '/') { return; }\n\n                if (input.charAt(i + 1) === '/') {\n                    return new(tree.Comment)($re(/^\\/\\/.*/), true, i, env.currentFileInfo);\n                }\n                comment = $re(/^\\/\\*(?:[^*]|\\*+[^\\/*])*\\*+\\/\\n?/);\n                if (comment) {\n                    return new(tree.Comment)(comment, false, i, env.currentFileInfo);\n                }\n            }", "category": "Python"}, {"instruction": "True if is interaction with external contract (change in context, no delegate calls) (send, call of other contracts)\n@node {ASTNode} some AstNode\n@return {bool}", "input": "JavaScript", "output": "function isInteraction (node) {\n  return isLLCall(node) || isLLSend(node) || isExternalDirectCall(node) || isTransfer(node) || isLLCall050(node) || isLLSend050(node)\n}", "category": "Python"}, {"instruction": "Adds an InfoWindow to the map\n@param infoWindowOptions:google.maps.InfoWindowOptions (optional)\n@param callback:function(InfoWindow:google.maps.InfoWindowOptions) (optional)\n@return $(google.maps.InfoWindowOptions)\n@see http://code.google.com/intl/sv-SE/apis/maps/documentation/javascript/reference.html#InfoWindowOptions", "input": "JavaScript", "output": "function(a, b) {\n            var c = new google.maps.InfoWindow(a);\n            this._call(b, c);\n            return $(c);\n        }", "category": "Python"}, {"instruction": "Poll for stats every `ms`.\n\n@param {Number} ms", "input": "JavaScript", "output": "function pollStats(ms) {\n    request('./stats', function (data) {\n        o('li.inactive .count').text(data.inactiveCount);\n        o('li.active .count').text(data.activeCount);\n        o('li.complete .count').text(data.completeCount);\n        o('li.failed .count').text(data.failedCount);\n        o('li.delayed .count').text(data.delayedCount);\n        setTimeout(function () {\n            pollStats(ms);\n        }, ms);\n    });\n}", "category": "Python"}, {"instruction": "Convert object to meta by value.", "input": "JavaScript", "output": "function (obj) {\n  return Object.getOwnPropertyNames(obj).map(function (name) {\n    return {\n      name: name,\n      value: obj[name]\n    }\n  })\n}", "category": "Python"}, {"instruction": "/* eslint-enable \nLoader used to create Skeleton objects", "input": "JavaScript", "output": "function Skeleton({ width, height, dark, ...other }) {\n  return (\n    <StyledSkeleton dark={dark} customWidth={width} customHeight={height} {...other}>\n      &nbsp;\n    </StyledSkeleton>\n  );\n}", "category": "Python"}, {"instruction": "Creates an error object to be thrown when an exception was caught, but the `Error` is falsy or undefined.\n\n@public\n@param {string} message - Error message to be displayed.\n@returns {Error} instance detailing the error condition", "input": "JavaScript", "output": "function createInvalidExceptionError(message, value) {\n  var err = new Error(message);\n  err.code = 'ERR_MOCHA_INVALID_EXCEPTION';\n  err.valueType = typeof value;\n  err.value = value;\n  return err;\n}", "category": "Python"}, {"instruction": "Mimic Array.forEach() API, but with an async callback function. Execute each callback on each array item serially. Useful when using WebDriverIO API.  Added due because of problem with chrome driver when too many requests are made simultaneously. https://bugs.chromium.org/p/chromedriver/issues/detail?id=2152#c9  @param {object[]} array Input array items to iterate over @param {function} callback Async function to excute on each array item @param {object} option Additional options. 'extractValue' will extract the .value object from a WebdriverIO", "input": "JavaScript", "output": "async function forEachAsync(array, callback, option = {}) {\n  const {\n    extractValue = true,\n    unify: unifyResults = true,\n    expandArrayResults = true,\n  } = option;\n  const inputArray = Array.isArray(array) ? array : [array];\n  const values = [];\n  for (let index = 0; index < inputArray.length; index++) {\n    let res;\n    try {\n      res = await callback(inputArray[index], index, inputArray);\n      if (Array.isArray(res) && expandArrayResults) {\n        res.forEach(val => values.push(val));\n      } else if (res) {\n        values.push(res);\n      }\n    } catch (err) {\n      throw err;\n    }\n  }\n  if (unifyResults) {\n    return unify(values, { extractValue: true });\n  }\n  return values;\n}", "category": "Python"}, {"instruction": "url:        null, type:       'GET',", "input": "JavaScript", "output": "function( mockHandler, requestSettings ) {\n\t\t\tif ( mockHandler.logging === false ||\n\t\t\t\t ( typeof mockHandler.logging === 'undefined' && $.mockjaxSettings.logging === false ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( window.console && console.log ) {\n\t\t\t\tvar message = 'MOCK ' + requestSettings.type.toUpperCase() + ': ' + requestSettings.url;\n\t\t\t\tvar request = $.extend({}, requestSettings);\n\n\t\t\t\tif (typeof console.log === 'function') {\n\t\t\t\t\tconsole.log(message, request);\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconsole.log( message + ' ' + JSON.stringify(request) );\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.log(message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}", "category": "Python"}, {"instruction": "Checks whether this user is the current user and has been authenticated.\n@deprecated \u5982\u679c\u8981\u5224\u65ad\u5f53\u524d\u7528\u6237\u7684\u767b\u5f55\u72b6\u6001\u662f\u5426\u6709\u6548\uff0c\u8bf7\u4f7f\u7528 currentUser.isAuthenticated().then()\uff0c\n\u5982\u679c\u8981\u5224\u65ad\u8be5\u7528\u6237\u662f\u5426\u662f\u5f53\u524d\u767b\u5f55\u7528\u6237\uff0c\u8bf7\u4f7f\u7528 user.id === currentUser.id\n@return (Boolean) whether this user is the current user and is logged in.", "input": "JavaScript", "output": "function() {\n        console.warn(\n          'DEPRECATED: \u5982\u679c\u8981\u5224\u65ad\u5f53\u524d\u7528\u6237\u7684\u767b\u5f55\u72b6\u6001\u662f\u5426\u6709\u6548\uff0c\u8bf7\u4f7f\u7528 currentUser.isAuthenticated().then()\uff0c\u5982\u679c\u8981\u5224\u65ad\u8be5\u7528\u6237\u662f\u5426\u662f\u5f53\u524d\u767b\u5f55\u7528\u6237\uff0c\u8bf7\u4f7f\u7528 user.id === currentUser.id\u3002'\n        );\n        return (\n          !!this._sessionToken &&\n          (!AV._config.disableCurrentUser &&\n            AV.User.current() &&\n            AV.User.current().id === this.id)\n        );\n      }", "category": "Python"}, {"instruction": "<include src=\"assert.js\"> \nAlias for document.getElementById. Found elements must be HTMLElements.\n@param {string} id The ID of the element to find.\n@return {HTMLElement} The found element or null if not found.", "input": "JavaScript", "output": "function $(id) {\n  var el = document.getElementById(id);\n  return el ? assertInstanceof(el, HTMLElement) : null;\n}", "category": "Python"}, {"instruction": "File loading ------------------------------------------------", "input": "JavaScript", "output": "function(plugins) {\n    _.each(\n      plugins,\n      _.bind(function(plugin) {\n        if (!this.plugins[plugin]) {\n          this.plugins[plugin] = this.requirePlugin(plugin);\n        }\n      }, this)\n    );\n  }", "category": "Python"}, {"instruction": "Begins polling to determine when the specified stylesheet has finished loading\nin Gecko. Polling stops when all pending stylesheets have loaded or after 10\nseconds (to prevent stalls).\n\nThanks to Zach Leatherman for calling my attention to the @import-based\ncross-domain technique used here, and to Oleg Slobodskoi for an earlier\nsame-domain implementation. See Zach's blog for more details:\nhttp://www.zachleat.com/web/2010/07/29/load-css-dynamically/\n\n@method pollGecko\n@param {HTMLElement} node Style node to poll.\n@private", "input": "JavaScript", "output": "function pollGecko(node) {\n    var hasRules;\n\n    try {\n      // We don't really need to store this value or ever refer to it again, but\n      // if we don't store it, Closure Compiler assumes the code is useless and\n      // removes it.\n      hasRules = !!node.sheet.cssRules;\n    } catch (ex) {\n      // An exception means the stylesheet is still loading.\n      pollCount += 1;\n\n      if (pollCount < 200) {\n        setTimeout(function () { pollGecko(node); }, 50);\n      } else {\n        // We've been polling for 10 seconds and nothing's happened. Stop\n        // polling and finish the pending requests to avoid blocking further\n        // requests.\n        hasRules && finish('css');\n      }\n\n      return;\n    }\n\n    // If we get here, the stylesheet has loaded.\n    finish('css');\n  }", "category": "Python"}, {"instruction": "Tells if an object is a primitive type or a \"real\" object\nArrays are considered primitive", "input": "JavaScript", "output": "function isPrimitiveType (obj) {\n  return ( typeof obj === 'boolean' ||\n       typeof obj === 'number' ||\n       typeof obj === 'string' ||\n       obj === null ||\n       util.isDate(obj) ||\n       util.isArray(obj));\n}", "category": "Python"}, {"instruction": "/* GLTFREGISTRY", "input": "JavaScript", "output": "function GLTFRegistry() {\n\n    var objects = {};\n\n    return    {\n\n        get: function ( key ) {\n\n            return objects[ key ];\n\n        },\n\n        add: function ( key, object ) {\n\n            objects[ key ] = object;\n\n        },\n\n        remove: function ( key ) {\n\n            delete objects[ key ];\n\n        },\n\n        removeAll: function () {\n\n            objects = {};\n\n        }\n\n    };\n\n}", "category": "Python"}, {"instruction": "DomRenderer#attach( data ) -> this\n- data (HTMLElement|Object): DOM node or event data (`data.body`)\n\nEvent callback to attach a node to the viewport", "input": "JavaScript", "output": "function( data ){\n\n            // interpred data as either dom node or event data\n            var el = (data.nodeType && data) || (data.body && data.body.view)\n                ;\n\n            if ( el ){\n                // attach to viewport\n                this.el.appendChild( el );\n            }\n\n            return this;\n        }", "category": "Python"}, {"instruction": "$NON-NLS-0$", "input": "JavaScript", "output": "function(){\n\t\t\tvar compareParams = PageUtil.matchResourceParameters();\n\t\t\tvar compareTreeExplorer = new mCompareTreeExplorer.CompareTreeExplorer(serviceRegistry, \"compare-tree-results\", commandRegistry, fileClient); //$NON-NLS-0$\n\t\t\tcompareTreeExplorer.startup(compareParams);\n\t\t\tmGlobalCommands.setPageTarget({\n\t\t\t\ttask: messages.compareTreeTitle\n\t\t\t});\n\t\t}", "category": "Python"}, {"instruction": "Changes the user's password.", "input": "JavaScript", "output": "function onChangePassword() {\n  var password = $('#changed-password').val();\n  activeUser().updatePassword(password).then(function() {\n    refreshUserData();\n    alertSuccess('Password changed!');\n  }, onAuthError);\n}", "category": "Python"}, {"instruction": "Show value inside the debug console", "input": "JavaScript", "output": "function WidgetSliderGUI() {\n        this.addOutput(\"\", \"number\");\n        this.properties = {\n            value: 0.5,\n            min: 0,\n            max: 1,\n            text: \"V\"\n        };\n        var that = this;\n        this.size = [140, 40];\n        this.slider = this.addWidget(\n            \"slider\",\n            \"V\",\n            this.properties.value,\n            function(v) {\n                that.properties.value = v;\n            },\n            this.properties\n        );\n        this.widgets_up = true;\n    }", "category": "Python"}, {"instruction": "Parse CSS", "input": "JavaScript", "output": "function parseCSS(content) {\r\n    var _return = {},\r\n      parts = content.split(\"\\n\"),\r\n      keys = [\r\n        \"name\",\r\n        \"description\",\r\n        \"type\"\r\n      ];\r\n\r\n    for (var pi in parts) {\r\n      var p = parts[pi];\r\n\r\n      for (var ki in keys) {\r\n        var key = keys[ki];\r\n\r\n        if (p.indexOf(\"@\"+key) > -1) {\r\n          var pset = p.split(\"@\"+key),\r\n          part = pset[ pset.length - 1 ].trim();\r\n\r\n          _return[key] = part;\r\n        }\r\n      }\r\n    }\r\n    return _return;\r\n  }", "category": "Python"}, {"instruction": "Wrapper for defined play method.\nPlay component by adding tick behavior and calling user's play method.\n\n@param playMethod {function}", "input": "JavaScript", "output": "function wrapPlay (playMethod) {\n  return function play () {\n    var sceneEl = this.el.sceneEl;\n    var shouldPlay = this.el.isPlaying && !this.isPlaying;\n    if (!this.initialized || !shouldPlay) { return; }\n    playMethod.call(this);\n    this.isPlaying = true;\n    this.eventsAttach();\n    // Add tick behavior.\n    if (!hasBehavior(this)) { return; }\n    sceneEl.addBehavior(this);\n  };\n}", "category": "Python"}, {"instruction": "Set the resource path to be considered for the OData request URI of this\nquery request object. This method provides an alternative way to assign a\npath comprising a parameterization. If a path is provided, it overwrites\nany parameterization object that might have been specified separately.\n\n@param {string} sResourcePath\nResource path pointing to the entity set of the query result.\nMust include a valid parameterization if query contains\nparameters.\n@public\n@function\n@name sap.ui.model.analytics.odata4analytics.QueryResultRequest#setResourcePath", "input": "JavaScript", "output": "function(sResourcePath) {\n\t\t\tthis._sResourcePath = sResourcePath;\n\t\t\tif (this._sResourcePath.indexOf(\"/\") != 0) {\n\t\t\t\tthrow \"Missing leading / (slash) for resource path\";\n\t\t\t}\n\t\t\tif (this._oQueryResult.getParameterization()) {\n\t\t\t\tvar iLastPathSep = sResourcePath.lastIndexOf(\"/\");\n\t\t\t\tif (iLastPathSep == -1) {\n\t\t\t\t\tthrow \"Missing navigation from parameter entity set to query result in resource path\";\n\t\t\t\t}\n\t\t\t\tvar sNavPropName = sResourcePath.substring(iLastPathSep + 1);\n\t\t\t\tif (sNavPropName != this._oQueryResult.getParameterization().getNavigationPropertyToQueryResult()) {\n\t\t\t\t\tthrow \"Invalid navigation property from parameter entity set to query result in resource path\";\n\t\t\t\t}\n\t\t\t}\n\t\t}", "category": "Python"}, {"instruction": "/* return a promise and a function. When the function is called,\nthe promise will be resolved.", "input": "JavaScript", "output": "function awaitFunctionCall() {\n                let func;\n                const promise = new Promise((resolve, reject) => {\n                    func = function(...args) {\n                        resolve(args);\n                        return new Promise((resolve, reject) => {\n                            // give us some time to process the result before\n                            // continuing\n                            global.setTimeout(resolve, 1);\n                        });\n                    };\n                });\n                return {func, promise};\n            }", "category": "Python"}, {"instruction": "Drag Handlers", "input": "JavaScript", "output": "function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var label = { position: this.getLabelPosition(x, y, data.positionArgs) };\n        this.model.label(data.labelIdx, label);\n    }", "category": "Python"}, {"instruction": "Initialize the grid navigation holder to null.\n@param {Object} modelItem The model item object that represent a row.", "input": "JavaScript", "output": "function(modelItem) {\n\t\t\tif(!modelItem){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar modelId = this._model.getId(modelItem);\n\t\t\tif(this._dict[modelId]){\n\t\t\t\tthis._dict[modelId].gridChildren = null;\n\t\t\t}\n\t\t}", "category": "Python"}, {"instruction": "/* eslint-disable", "input": "JavaScript", "output": "function requestUrl(url, callback) {\n  var req = new XMLHttpRequest();\n  req.addEventListener(\"load\", function () {\n    callback(req.responseText);\n  });\n  req.open(\"GET\", url);\n  req.send();\n}", "category": "Python"}, {"instruction": "/* template", "input": "JavaScript", "output": "function() {\n      var _vm = this;\n      var _h = _vm.$createElement;\n      var _c = _vm._self._c || _h;\n      return _c(\n        _vm.tag,\n        {\n          tag: \"component\",\n          class: [!_vm.fluid ? \"container\" : \"container-fluid\"]\n        },\n        [_vm._t(\"default\")],\n        2\n      )\n    }", "category": "Python"}, {"instruction": "Build CSS", "input": "JavaScript", "output": "function() {\n    return gulp\n      .src(item.dest + item.name + '.css')\n      .pipe(rename(item.name + '.min.css'))\n      .pipe(cleanCSS())\n      .pipe(gulp.dest(item.dest));\n  }", "category": "Python"}, {"instruction": "/* [MS-XLSB] 2.5.166", "input": "JavaScript", "output": "function parse_XLNullableWideString(data) {\n\tvar cchCharacters = data.read_shift(4);\n\treturn cchCharacters === 0 || cchCharacters === 0xFFFFFFFF ? \"\" : data.read_shift(cchCharacters, 'dbcs');\n}", "category": "Python"}, {"instruction": "Exports a [SurfacePolyline]{@link SurfacePolyline} in WKT format of type LineString.\n@param {SurfacePolyline} renderable The SurfacePolyline object.\n@throws {ArgumentError} If the specified argument is null or undefined.\n@returns {String} WKT format.", "input": "JavaScript", "output": "function (renderable) {\n                if (!(renderable instanceof WorldWind.SurfacePolyline)) {\n                    throw new ArgumentError(\n                        Logger.logMessage(Logger.LEVEL_SEVERE, \"WktExporter\", \"exportSurfacePolyline\",\n                            \"invalidTypeOfRenderable\"));\n                }\n\n                var sb = WktType.SupportedGeometries.LINE_STRING + '(';\n                for (var i = 0; i < renderable.boundaries.length; i++) {\n                    sb = sb + renderable.boundaries[i].longitude + ' ' +\n                        renderable.boundaries[i].latitude;\n                    sb = sb + ', ';\n                }\n                sb = sb.substring(0, sb.length - 2);\n                sb = sb + ')';\n                return sb;\n            }", "category": "Python"}, {"instruction": "/* jshint ignore:start \nInitialize the V1 version of Pricing\n\n@constructor Twilio.Pricing.V1\n\n@property {Twilio.Pricing.V1.MessagingList} messaging - messaging resource\n@property {Twilio.Pricing.V1.PhoneNumberList} phoneNumbers -\nphoneNumbers resource\n@property {Twilio.Pricing.V1.VoiceList} voice - voice resource\n\n@param {Twilio.Pricing} domain - The twilio domain\n /* jshint ignore:end", "input": "JavaScript", "output": "function V1(domain) {\n  Version.prototype.constructor.call(this, domain, 'v1');\n\n  // Resources\n  this._messaging = undefined;\n  this._phoneNumbers = undefined;\n  this._voice = undefined;\n}", "category": "Python"}, {"instruction": "measure the given text size in pixels\n@name measureText\n@memberOf me.BitmapText.prototype\n@function\n@param {String} [text]\n@param {me.Rect} [ret] a object in which to store the text metrics\n@returns {TextMetrics} a TextMetrics object with two properties: `width` and `height`, defining the output dimensions", "input": "JavaScript", "output": "function (text, ret) {\n            text = text || this._text;\n\n            var strings = (\"\" + text).split(\"\\n\");\n            var stringHeight = measureTextHeight(this);\n            var textMetrics  = ret || this.getBounds();\n\n            textMetrics.height = textMetrics.width = 0;\n\n            for (var i = 0; i < strings.length; i++) {\n                textMetrics.width = Math.max(measureTextWidth(this, strings[i]), textMetrics.width);\n                textMetrics.height += stringHeight;\n            }\n            return textMetrics;\n        }", "category": "Python"}, {"instruction": "---------------------------------------------------------------------------", "input": "JavaScript", "output": "function replaceInFile (filename, regex, replacement) {\n    let contents = fs.readFileSync (filename, 'utf8')\n    const parts = contents.split (regex)\n    const newContents = parts[0] + replacement + parts[1]\n    fs.truncateSync (filename)\n    fs.writeFileSync (filename, newContents)\n}", "category": "Python"}, {"instruction": "# prop :: String -> a -> b . . Takes a property name and an object with known properties and returns . the value of the specified property. If for some reason the object . lacks the specified property, a type error is thrown. . . For accessing properties of uncertain objects, use [`get`](#get) instead. . For accessing string map values by key, use [`value`](#value) instead. . . ```javascript . > S.prop ('a') ({a: 1, b: 2}) . 1 . ```", "input": "JavaScript", "output": "function prop(key) {\n    return function(x) {\n      var obj = toObject (x);\n      if (key in obj) return obj[key];\n      throw new TypeError ('\u2018prop\u2019 expected object to have a property named ' +\n                           '\u2018' + key + '\u2019; ' + show (x) + ' does not');\n    };\n  }", "category": "Python"}, {"instruction": "Add a column split on a string or number valued field, producing a column for\neach distinct value of the field.\n\n@param {String} fieldName The name of field to split on.\n@return {splunkjs.Service.PivotSpecification} The updated pivot specification.\n\n@method splunkjs.Service.PivotSpecification", "input": "JavaScript", "output": "function(fieldName) {\n            if (!this.dataModelObject.hasField(fieldName)) {\n                throw new Error(\"Did not find field \" + fieldName);\n            }\n            var f = this.dataModelObject.fieldByName(fieldName);\n            if (!utils.contains([\"number\", \"string\"], f.type)) {\n                throw new Error(\"Field was of type \" + f.type + \", expected number or string.\");\n            }\n\n            var col = {\n                fieldName: fieldName,\n                owner: f.owner,\n                type: f.type\n            };\n\n            if (\"number\" === f.type) {\n                col.display = \"all\";\n            }\n\n            this.columns.push(col);\n\n            return this;\n        }", "category": "Python"}, {"instruction": "Test screen rotation", "input": "JavaScript", "output": "function rotateScreen(r) {\n    lcd.setRotation(r);\n    lcd.fillRect(0, 0, 5, 5, ili9341.ILI9341_WHITE);\n    if (r < 4) {\n        r++;\n        setTimeout(function() { rotateScreen(r); }, 1000);\n    }\n}", "category": "Python"}, {"instruction": "/* =========================================================== /* lifecycle methods /* =========================================================== \nCalled when the controller is instantiated.\n@public", "input": "JavaScript", "output": "function () {\n\t\t\tBaseController.prototype.onInit.call(this);\n\n\t\t\t// manually call the handler once at startup as device API won't do this for us\n\t\t\tthis._onOrientationChange({\n\t\t\t\tlandscape: Device.orientation.landscape\n\t\t\t});\n\n\t\t\tthis.getRouter().getRoute(\"tools\").attachPatternMatched(this._onMatched, this);\n\t\t}", "category": "Python"}, {"instruction": "This function is called in a $$postDigest to trigger all the onChanges hooks in a single digest", "input": "JavaScript", "output": "function flushOnChangesQueue() {\n      try {\n        if (!(--onChangesTtl)) {\n          // We have hit the TTL limit so reset everything\n          onChangesQueue = undefined;\n          throw $compileMinErr('infchng', '{0} $onChanges() iterations reached. Aborting!\\n', TTL);\n        }\n        // We must run this hook in an apply since the $$postDigest runs outside apply\n        $rootScope.$apply(function() {\n          for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) {\n            onChangesQueue[i]();\n          }\n          // Reset the queue to trigger a new schedule next time there is a change\n          onChangesQueue = undefined;\n        });\n      } finally {\n        onChangesTtl++;\n      }\n    }", "category": "Python"}, {"instruction": "Undeclared grammar", "input": "JavaScript", "output": "function undeclaredGrammar(grammarName, namespace, interval) {\n  var message = namespace ?\n      'Grammar ' + grammarName + ' is not declared in namespace ' + Namespace.toString(namespace) :\n      'Undeclared grammar ' + grammarName;\n  return createError(message, interval);\n}", "category": "Python"}, {"instruction": "/* extract the faces from an image for given face rectangles", "input": "JavaScript", "output": "function getFacesFromLocations(img, rects, faceSize = 150) {\n      const shapes = rects.map(rect => faceLandmarkPredictor.predict(img, rect))\n      return fr.extractImageChips(img, fr.getFaceChipDetails(shapes, faceSize))\n    }", "category": "Python"}, {"instruction": "23.1.3.3 Map.prototype.delete(key) 23.2.3.4 Set.prototype.delete(value)", "input": "JavaScript", "output": "function (key) {\n        var that = this;\n        var state = getInternalState(that);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.next;\n          var prev = entry.previous;\n          delete state.index[entry.index];\n          entry.removed = true;\n          if (prev) prev.next = next;\n          if (next) next.previous = prev;\n          if (state.first == entry) state.first = next;\n          if (state.last == entry) state.last = prev;\n          if (DESCRIPTORS) state.size--;\n          else that.size--;\n        } return !!entry;\n      }", "category": "Python"}, {"instruction": "---- Names and Paths ----------------------------------------------------------------------- \nName conversion function that converts a name in unified resource name syntax to a name in UI5 module name syntax.\nIf the name cannot be converted (e.g. doesn't end with '.js'), then <code>undefined</code> is returned.\n\n@param {string} sName Name in unified resource name syntax\n@returns {string|undefined} Name in UI5 (legacy) module name syntax (dot separated)\nor <code>undefined</code> when the name can't be converted\n@private", "input": "JavaScript", "output": "function urnToUI5(sName) {\n\t\t// UI5 module name syntax is only defined for JS resources\n\t\tif ( !/\\.js$/.test(sName) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tsName = sName.slice(0, -3);\n\t\tif ( /^jquery\\.sap\\./.test(sName) ) {\n\t\t\treturn sName; // do nothing\n\t\t}\n\t\treturn sName.replace(/\\//g, \".\");\n\t}", "category": "Python"}, {"instruction": "/*eslint-enable no-loop-func", "input": "JavaScript", "output": "function getContextInfos(oContext, sModelName) {\n\t\t\t\tvar mContextInfos = {\n\t\t\t\t\tmodelName: (sModelName === 'undefined') ? 'none (default)' : sModelName,\n\t\t\t\t\tpath: oContext.getPath()\n\t\t\t\t};\n\n\t\t\t\tif (oContext.getModel().isA(\"sap.ui.model.odata.v4.ODataModel\")) { // ODataModel v4 throws an exception on getObject()\n\t\t\t\t\tmContextInfos.unverifiedPath = true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!oContext.getObject() == null) {\n\t\t\t\t\t\tmContextInfos.invalidPath = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn mContextInfos;\n\t\t\t}", "category": "Python"}, {"instruction": "Write the API meta data used for the AutoComplete widget\n@method writeAPIMeta\n@param {Callback} cb The callback to execute when complete\n@async", "input": "JavaScript", "output": "function (cb) {\n            Y.log('Writing API Meta Data', 'info', 'builder');\n            var self = this;\n            this.renderAPIMeta(function (js) {\n                fs.writeFile(path.join(self.options.outdir, 'api.js'), js, Y.charset, cb);\n            });\n        }", "category": "Python"}, {"instruction": "Returns a view limiter that prevents zooming in beyond the given\nresolution.\n@param {number} size The image width in pixels.\n@return {FlatViewLimiter}", "input": "JavaScript", "output": "function(size) {\n    return function limitResolution(params) {\n      if (params.width <= 0 || params.height <= 0) {\n        return params;\n      }\n      var width = params.width;\n      var minZoom = pixelRatio() * width / size;\n      params.zoom = clamp(params.zoom, minZoom, Infinity);\n      return params;\n    };\n  }", "category": "Python"}, {"instruction": "Remove animator\n@param {clay.animate.Animator} animator", "input": "JavaScript", "output": "function (animator) {\n        var clips = animator.getClips();\n        for (var i = 0; i < clips.length; i++) {\n            this.removeClip(clips[i]);\n        }\n        animator.animation = null;\n    }", "category": "Python"}, {"instruction": "Matches settings for currectly matching media breakpoint.\n\n@param {Object} points\n@returns {Object}", "input": "JavaScript", "output": "function match(points) {\n      if (typeof window.matchMedia !== 'undefined') {\n        for (var point in points) {\n          if (points.hasOwnProperty(point)) {\n            if (window.matchMedia('(max-width: ' + point + 'px)').matches) {\n              return points[point];\n            }\n          }\n        }\n      }\n\n      return defaults;\n    }", "category": "Python"}, {"instruction": "Returns true if the source code is intended to run in strict mode. Does not detect\n\"use strict\" if it occurs in a nested function.\n\n@param {String} src\n@return {Boolean}", "input": "JavaScript", "output": "function detectStrictMode(src) {\r\n    var singleLine;\r\n    var multiLine;\r\n\r\n    while ((singleLine = singleLineComment.test(src)) || (multiLine = multiLineComment.test(src))) {\r\n        if (singleLine) {\r\n            src = src.replace(singleLineComment, \"\");\r\n        }\r\n        if (multiLine) {\r\n            src = src.replace(multiLineComment, \"\");\r\n        }\r\n    }\r\n\r\n    return strictMode.test(src);\r\n}", "category": "Python"}, {"instruction": "column merge \uac00 \uc124\uc815\ub418\uc5b4 \uc788\uc744 \ub54c \ud5e4\ub354\uc758 \uacc4\uce35\uad6c\uc870 \ub9ac\uc2a4\ud2b8\ub97c \uac00\uc838\uc628\ub2e4.\n@returns {Array}  \uacc4\uce35\uad6c\uc870 \ub9ac\uc2a4\ud2b8\n@private", "input": "JavaScript", "output": "function() {\n        var columns = this._getColumnData().columns;\n        var hierarchyList;\n\n        hierarchyList = _.map(columns, function(column) {\n            return this._getColumnHierarchy(column).reverse();\n        }, this);\n\n        return hierarchyList;\n    }", "category": "Python"}, {"instruction": "Determines whether a provided address matches the provided parent domain in order\nto avoid certain attack vectors.\n\n@param {String} srvAddress The address to check against a domain\n@param {String} parentDomain The domain to check the provided address against\n@return {Boolean} Whether the provided address matches the parent domain", "input": "JavaScript", "output": "function matchesParentDomain(srvAddress, parentDomain) {\n  const regex = /^.*?\\./;\n  const srv = `.${srvAddress.replace(regex, '')}`;\n  const parent = `.${parentDomain.replace(regex, '')}`;\n  return srv.endsWith(parent);\n}", "category": "Python"}, {"instruction": "/*\nCreates new sap.ui.layout.ResponsiveFlowLayoutData with the given parameters\n@param {int} iWeight the weight for the layout data\n@param {boolean} bLinebreak Whether the layout data has a linebreak\n@param {boolean} bLinebreakable Whether the layout data is linebreakable\n@returns {sap.ui.layout.ResponsiveFlowLayoutData} The newly created ResponsiveFlowLayoutData\n@private", "input": "JavaScript", "output": "function _createRFLayoutData(iWeight, bLinebreak, bLinebreakable, iMinWidth) {\n\n\t\tvar oLayout = new ResponsiveFlowLayoutData({weight:iWeight,linebreak:bLinebreak === true,linebreakable: bLinebreakable === true});\n\t\tif (iMinWidth) {\n\t\t\toLayout.setMinWidth(iMinWidth);\n\t\t}\n\t\tthis._aLayouts.push(oLayout.getId());\n\t\treturn oLayout;\n\n\t}", "category": "Python"}, {"instruction": "/*\n<functionName>: function() {}", "input": "JavaScript", "output": "function (node) {\n                if (node.body && node.body.type === \"FunctionDeclaration\") {\n                    if (node.label) {\n                        _addResult(node.label);\n                    }\n                }\n            }", "category": "Python"}, {"instruction": "Set a property on an object. Adds the new property and\ntriggers change notification if the property doesn't\nalready exist.", "input": "JavaScript", "output": "function set (target, key, val) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}", "category": "Python"}, {"instruction": "Handle when the DOM is ready", "input": "JavaScript", "output": "function() {\n\t\t// Make sure that the DOM is not already loaded\n\t\tif ( !jQuery.isReady ) {\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\n\t\t\t// If there are functions bound, to execute\n\t\t\tif ( jQuery.readyList ) {\n\t\t\t\t// Execute all of them\n\t\t\t\tjQuery.each( jQuery.readyList, function(){\n\t\t\t\t\tthis.call( document, jQuery );\n\t\t\t\t});\n\n\t\t\t\t// Reset the list of functions\n\t\t\t\tjQuery.readyList = null;\n\t\t\t}\n\n\t\t\t// Trigger any bound ready events\n\t\t\tjQuery(document).triggerHandler(\"ready\");\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Delimiter functions", "input": "JavaScript", "output": "function checkDelimiter(\n    delim: AnyParseNode,\n    context: FunctionContext,\n): SymbolParseNode {\n    const symDelim = checkSymbolNodeType(delim);\n    if (symDelim && utils.contains(delimiters, symDelim.text)) {\n        return symDelim;\n    } else {\n        throw new ParseError(\n            \"Invalid delimiter: '\" +\n            (symDelim ? symDelim.text : JSON.stringify(delim)) +\n            \"' after '\" + context.funcName + \"'\", delim);\n    }\n}", "category": "Python"}, {"instruction": "PrivateFunction: _newXHR\n_Private_ helper function to create XMLHttpRequests.\n\nThis function creates XMLHttpRequests across all implementations.\n\nReturns:\nA new XMLHttpRequest.", "input": "JavaScript", "output": "function ()\r\n    {\r\n        var xhr = null;\r\n        if (window.XMLHttpRequest) {\r\n            xhr = new XMLHttpRequest();\r\n            if (xhr.overrideMimeType) {\r\n                xhr.overrideMimeType(\"text/xml; charset=utf-8\");\r\n            }\r\n        } else if (window.ActiveXObject) {\r\n            xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\r\n        }\r\n\r\n        // use Function.bind() to prepend ourselves as an argument\r\n        xhr.onreadystatechange = this.func.bind(null, this);\r\n\r\n        return xhr;\r\n    }", "category": "Python"}, {"instruction": "get returns the value of the given key. If that value is undefined, it returns optionalDefaultValue instead.", "input": "JavaScript", "output": "function(key, optionalDefaultValue) {\n\t\tvar data = this.storage.read(this._namespacePrefix + key)\n\t\treturn this._deserialize(data, optionalDefaultValue)\n\t}", "category": "Python"}, {"instruction": "COUNTUP AND CODE VISUALIZER", "input": "JavaScript", "output": "function createCountUp() {\n    establishOptionsFromInputs();\n    demo = new CountUp('myTargetElement', endVal, options);\n    if (!demo.error) {\n      errorSection.style.display = 'none';\n      if (input('useOnComplete').checked) {\n        demo.start(methodToCallOnComplete);\n      }\n      else {\n        demo.start();\n      }\n      updateCodeVisualizer();\n    }\n    else {\n      errorSection.style.display = 'block';\n      document.getElementById('error').innerHTML = demo.error;\n      console.error(demo.error);\n    }\n  }", "category": "Python"}, {"instruction": "Remote Event: Go to the given source node", "input": "JavaScript", "output": "function _onRemoteEdit(event, res) {\n        // res = {nodeId, name, value}\n\n        // detach from DOM change events\n        if (res.value === \"0\") {\n            Inspector.DOM.off(\".EditAgent\");\n            return;\n        }\n\n        // find and store the edited node\n        var node = DOMAgent.nodeWithId(res.nodeId);\n        node = node.children[0];\n        if (!node.location) {\n            return;\n        }\n        _editedNode = node;\n\n        // attach to character data modified events\n        Inspector.DOM.on(\"characterDataModified.EditAgent\", _onCharacterDataModified);\n    }", "category": "Python"}, {"instruction": "Test bind path to make sure it's working\n@param {string} bindPath\n@return {boolean}", "input": "JavaScript", "output": "function tryBindPath(serverless, bindPath, testFile) {\n  const options = [\n    'run',\n    '--rm',\n    '-v',\n    `${bindPath}:/test`,\n    'alpine',\n    'ls',\n    `/test/${testFile}`\n  ];\n  try {\n    const ps = dockerCommand(options);\n    if (process.env.SLS_DEBUG) {\n      serverless.cli.log(`Trying bindPath ${bindPath} (${options})`);\n      serverless.cli.log(ps.stdout.trim());\n    }\n    return ps.stdout.trim() === `/test/${testFile}`;\n  } catch (err) {\n    return false;\n  }\n}", "category": "Python"}, {"instruction": "Default onTouchEnd handler.\n@param {jQuery.Event} oEvent  Event object", "input": "JavaScript", "output": "function (oEvent) {\n\t\t\tvar iPageY = oEvent.changedTouches && oEvent.changedTouches.length ? oEvent.changedTouches[0].pageY : oEvent.pageY;\n\n\t\t\tif (this._bIsDrag === false) {\n\t\t\t\tthis.fireTap(oEvent);\n\t\t\t\tthis._dragSession = null;\n\t\t\t}\n\n\t\t\tthis._bIsDrag = true;\n\n\t\t\tif (!this.getIsExpanded()) {\n\t\t\t\tthis._dragSession = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._endDrag(iPageY, oEvent.timeStamp);\n\n\t\t\tthis._mousedown = false;\n\t\t}", "category": "Python"}, {"instruction": "/* TODO", "input": "JavaScript", "output": "function write_sty_xlml(wb, opts)/*:string*/ {\n\t/* Styles */\n\tvar styles/*:Array<string>*/ = ['<Style ss:ID=\"Default\" ss:Name=\"Normal\"><NumberFormat/></Style>'];\n\topts.cellXfs.forEach(function(xf, id) {\n\t\tvar payload/*:Array<string>*/ = [];\n\t\tpayload.push(writextag('NumberFormat', null, {\"ss:Format\": escapexml(SSF._table[xf.numFmtId])}));\n\t\tstyles.push(writextag('Style', payload.join(\"\"), {\"ss:ID\": \"s\" + (21+id)}));\n\t});\n\treturn writextag(\"Styles\", styles.join(\"\"));\n}", "category": "Python"}, {"instruction": "runner", "input": "JavaScript", "output": "function traverseDirectory(pathname, callback) {\n\tpathname = pathname.replace(/\\\\/g, \"/\")\n\treturn new Promise(function(resolve, reject) {\n\t\tfs.lstat(pathname, function(err, stat) {\n\t\t\tif (err) reject(err)\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\tfs.readdir(pathname, function(err, pathnames) {\n\t\t\t\t\tif (err) reject(err)\n\t\t\t\t\tvar promises = []\n\t\t\t\t\tfor (var i = 0; i < pathnames.length; i++) {\n\t\t\t\t\t\tpathnames[i] = path.join(pathname, pathnames[i])\n\t\t\t\t\t\tpromises.push(traverseDirectory(pathnames[i], callback))\n\t\t\t\t\t}\n\t\t\t\t\tcallback(pathname, stat, pathnames)\n\t\t\t\t\tresolve(Promise.all(promises))\n\t\t\t\t})\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcallback(pathname, stat)\n\t\t\t\tresolve(pathname)\n\t\t\t}\n\t\t})\n\t})\n}", "category": "Python"}, {"instruction": "field can be: 1. function 2. regular property - ex: 'prop' 3. nested property path - ex: 'nested.prop'", "input": "JavaScript", "output": "function collect(obj, field) {\n      // utility function to get nested property\n      function dig(obj, selector) {\n        var result = obj;\n        var splitter = selector.split('.');\n\n        for (var i = 0; i < splitter.length; i++) {\n          if (typeof result === 'undefined' || result === null) {\n            return undefined;\n          }\n\n          result = result[splitter[i]];\n        }\n\n        return result;\n      }\n\n      if (typeof field === 'function') return field(obj);\n      if (typeof field === 'string') return dig(obj, field);\n      return undefined;\n    }", "category": "Python"}, {"instruction": "And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js", "input": "JavaScript", "output": "function ExtensionAPI(chartInstance) {\n    zrUtil.each(echartsAPIList, function (name) {\n        this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n    }, this);\n}", "category": "Python"}, {"instruction": "Texture Blur *****************************************", "input": "JavaScript", "output": "function LGraphTextureBlur() {\n            this.addInput(\"Texture\", \"Texture\");\n            this.addInput(\"Iterations\", \"number\");\n            this.addInput(\"Intensity\", \"number\");\n            this.addOutput(\"Blurred\", \"Texture\");\n            this.properties = {\n                intensity: 1,\n                iterations: 1,\n                preserve_aspect: false,\n                scale: [1, 1],\n                precision: LGraphTexture.DEFAULT\n            };\n        }", "category": "Python"}, {"instruction": "/*", "input": "JavaScript", "output": "function handleError (err, vm, info) {\n  if (vm) {\n    let cur = vm;\n    while ((cur = cur.$parent)) {\n      const hooks = cur.$options.errorCaptured;\n      if (hooks) {\n        for (let i = 0; i < hooks.length; i++) {\n          try {\n            const capture = hooks[i].call(cur, err, vm, info) === false;\n            if (capture) return\n          } catch (e) {\n            globalHandleError(e, cur, 'errorCaptured hook');\n          }\n        }\n      }\n    }\n  }\n  globalHandleError(err, vm, info);\n}", "category": "Python"}, {"instruction": "Retrieve a property from an object\n@param {Object} object\n@param {Index} index\n@return {*} Returns the value of the property\n@private", "input": "JavaScript", "output": "function _getObjectProperty (object, index) {\n  if (index.size().length !== 1) {\n    throw new DimensionError(index.size(), 1)\n  }\n\n  const key = index.dimension(0)\n  if (typeof key !== 'string') {\n    throw new TypeError('String expected as index to retrieve an object property')\n  }\n\n  return getSafeProperty(object, key)\n}", "category": "Python"}, {"instruction": "constructor", "input": "JavaScript", "output": "function init(cols, rows, tilewidth, tileheight) {\n         this._super(me.TMXRenderer, \"init\", [cols, rows, tilewidth, tileheight]);\n\n         this.hTilewidth = tilewidth / 2;\n         this.hTileheight = tileheight / 2;\n         this.originX = this.rows * this.hTilewidth;\n       }", "category": "Python"}, {"instruction": "setup events to detect gestures on the document", "input": "JavaScript", "output": "function setup() {\n  if(Hammer.READY) {\n    return;\n  }\n\n  // find what eventtypes we add listeners to\n  Event.determineEventTypes();\n\n  // Register all gestures inside Hammer.gestures\n  Utils.each(Hammer.gestures, function(gesture){\n    Detection.register(gesture);\n  });\n\n  // Add touch events on the document\n  Event.onTouch(Hammer.DOCUMENT, EVENT_MOVE, Detection.detect);\n  Event.onTouch(Hammer.DOCUMENT, EVENT_END, Detection.detect);\n\n  // Hammer is ready...!\n  Hammer.READY = true;\n}", "category": "Python"}, {"instruction": "the exporter is buggy eg VCGLab | MeshLab and does not specify input_set", "input": "JavaScript", "output": "function getLastNumber(str){\n\t\t\t\t\tvar retval=\"\";\n\t\t\t\t\tfor (var i=str.length-1;i>=0;--i)\n\t\t\t\t\t\tif (str[i]>=\"0\"&&str[i]<=\"9\")\n\t\t\t\t\t\t\tretval=str[i]+retval;\n\t\t\t\t\tif (retval.length==0) return \"0\";\n\t\t\t\t\treturn retval;\n\t\t\t\t}", "category": "Python"}, {"instruction": "Creates a new search client.\n@param {Object} options The options object\n@param {orion.serviceregistry.ServiceRegistry} options.serviceRegistry The service registry\n@name orion.searchClient.Searcher\n@class Provides API for searching the workspace.", "input": "JavaScript", "output": "function Searcher(options) {\n\t\tthis._registry= options.serviceRegistry;\n\t\tthis._commandService = options.commandService;\n\t\tthis._fileClient = options.fileService;\n\t\t//TODO clean up the search client API. Make any helper private\n\t\tthis._registry.registerService(\"orion.core.search.client\", this); //$NON-NLS-1$\n\t}", "category": "Python"}, {"instruction": "Removes value from an array.\nPresence of value (and its position in an array) is determined via `Array.prototype.indexOf`\n@static\n@memberOf fabric.util\n@method removeFromArray\n@param {Array} array\n@param {Any} value\n@return {Array} original array", "input": "JavaScript", "output": "function removeFromArray(array, value) {\n    var idx = array.indexOf(value);\n    if (idx !== -1) {\n      array.splice(idx, 1);\n    }\n    return array;\n  }", "category": "Python"}, {"instruction": "/*\nLints the directory passed in as a command line argument", "input": "JavaScript", "output": "function lintDirectory () {\n  var shouldFix = args.hasOwnProperty('fix');\n\n  cli = new eslint.CLIEngine({ configFile: configFilePath, fix: shouldFix });\n\n  report = cli.executeOnFiles(dir);\n\n  if (shouldFix) {\n    eslint.CLIEngine.outputFixes(report);\n  }\n\n  console.log(cli.getFormatter()(report.results)); // eslint-disable-line\n\n  // End with exit code 1 if there are errors\n  // Use process.exit instead of throwing to mimic the behaviour of eslints bin\n  // We don't want a stacktrace, it would just be confusing\n  if (report.errorCount) {\n      process.exit(1); // eslint-disable-line\n  }\n}", "category": "Python"}, {"instruction": "extended", "input": "JavaScript", "output": "function( options ){\n\n            parent.init.call( this );\n            this.options.defaults({\n                channel: 'collisions:candidates' //default channel\n            });\n            this.options( options );\n\n            this.encounters = [];\n            this.candidates = [];\n\n            this.clear();\n        }", "category": "Python"}, {"instruction": "show notification popup", "input": "JavaScript", "output": "function showNotification(msg, type, reloadPage){\n    // defaults to false\n    reloadPage = reloadPage || false;\n\n    $('#notify_message').removeClass();\n    $('#notify_message').addClass('alert-' + type);\n    $('#notify_message').html(msg);\n    $('#notify_message').slideDown(600).delay(2500).slideUp(600, function(){\n        if(reloadPage === true){\n            location.reload();\n        }\n    });\n}", "category": "Python"}, {"instruction": "Checks whether or not there is a transition.\n\n@param styles The cached styles to use for the calculation. If null, getComputedStyle()\nwill be used.\n\n@returns {boolean} True if there is no transition/duration; false otherwise.", "input": "JavaScript", "output": "function noTransitionFound(styles) {\n          styles = styles || window.getComputedStyle(element[0]);\n\n          return styles.transitionDuration == '0s' || (!styles.transition && !styles.transitionProperty);\n        }", "category": "Python"}, {"instruction": "Create a directory\n@param {String} dirPath The path to create\n@param {UserOptions=} options Options for the request\n@memberof ClientInterface\n@returns {Promise} A promise that resolves when the remote path has been created\n@example\nawait client.createDirectory(\"/my/directory\");", "input": "JavaScript", "output": "function createDirectory(dirPath, options) {\n            const createOptions = merge(baseOptions, options || {});\n            return createDir.createDirectory(dirPath, createOptions);\n        }", "category": "Python"}, {"instruction": "Create a function so we can use it inside of webpack's watch function.", "input": "JavaScript", "output": "function eslintFn() {\n  return gulp\n    .src([config.files.docs.srcJS])\n    .pipe(eslint())\n    .pipe(eslint.formatEach(\"stylish\", process.stderr));\n}", "category": "Python"}, {"instruction": "Counts repeated characters in a string. When 50% or more characters are the same,\nwe return false and therefore invalidate the string.\n@param {String} stringToTest The password string to check.\n@return {Boolean}", "input": "JavaScript", "output": "function characterOccurance(stringToTest) {\n    var chars = {},\n        allowedOccurancy,\n        valid = true;\n\n    stringToTest = _.toString(stringToTest);\n    allowedOccurancy = stringToTest.length / 2;\n\n    // Loop through string and accumulate character counts\n    _.each(stringToTest, function (char) {\n        if (!chars[char]) {\n            chars[char] = 1;\n        } else {\n            chars[char] += 1;\n        }\n    });\n\n    // check if any of the accumulated chars exceed the allowed occurancy\n    // of 50% of the words' length.\n    _.forIn(chars, function (charCount) {\n        if (charCount >= allowedOccurancy) {\n            valid = false;\n        }\n    });\n\n    return valid;\n}", "category": "Python"}, {"instruction": "Add cf routes command *", "input": "JavaScript", "output": "function describeRoute(route) {\n\t\tvar host = route.Host;\n\t\tvar domain = route.DomainName;\n\t\tvar apps = route.Apps;\n\t\tvar appsNum = route.Apps.length;\n\n\t\tvar strResult = \"\\n\" + host + \"\\t\" + domain;\n\n\t\tif(appsNum != 0){\n\t\t\tstrResult += \"\\t\" + route.Apps[0].Name;\n\t\t\tif(appsNum > 1){\n\t\t\t\tfor(var i = 1; i < appsNum; i++){\n\t\t\t\t\tstrResult += \", \" + route.Apps[i].Name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn strResult;\n\t}", "category": "Python"}, {"instruction": "Create a new item in the current project.\n\n@param baseDir {string|Directory} Full path of the directory where the item should go.\nDefaults to the project root if the entry is not valid or not within the project.\n@param initialName {string} Initial name for the item\n@param skipRename {boolean} If true, don't allow the user to rename the item\n@param isFolder {boolean} If true, create a folder instead of a file\n@return {$.Promise} A promise object that will be resolved with the File\nof the created object, or rejected if the user cancelled or entered an illegal\nfilename.", "input": "JavaScript", "output": "function createNewItem(baseDir, initialName, skipRename, isFolder) {\n        baseDir = model.getDirectoryInProject(baseDir);\n\n        if (skipRename) {\n            if(isFolder) {\n                return model.createAtPath(baseDir + initialName + \"/\");\n            }\n            return model.createAtPath(baseDir + initialName);\n        }\n        return actionCreator.startCreating(baseDir, initialName, isFolder);\n    }", "category": "Python"}, {"instruction": "Creates a splice record and sends an array splice notification for\nthe described mutation\n\nNote: this implementation only accepts normalized paths\n\n@param {!PropertyEffectsType} inst Instance to send notifications to\n@param {Array} array The array the mutations occurred on\n@param {string} path The path to the array that was mutated\n@param {number} index Index at which the array mutation occurred\n@param {number} addedCount Number of added items\n@param {Array} removed Array of removed items\n@return {void}\n@private", "input": "JavaScript", "output": "function notifySplice(inst, array, path, index, addedCount, removed) {\n  notifySplices(inst, array, path, [{\n    index: index,\n    addedCount: addedCount,\n    removed: removed,\n    object: array,\n    type: 'splice'\n  }]);\n}", "category": "Python"}, {"instruction": "Copies properties of `source` to `object`.\n\n@private\n@param {Object} source The object to copy properties from.\n@param {Array} props The property identifiers to copy.\n@param {Object} [object={}] The object to copy properties to.\n@param {Function} [customizer] The function to customize copied values.\n@returns {Object} Returns `object`.", "input": "JavaScript", "output": "function copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      _baseAssignValue(object, key, newValue);\n    } else {\n      _assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}", "category": "Python"}, {"instruction": "def conv(col, fromBase, toBase):\n    \"\"\"\n    Convert a number in a string column from one base to another.\n\n    >>> df = spark.createDataFrame([(\"010101\",)], ['n'])\n    >>> df.select(conv(df.n, 2, 16).alias('hex')).collect()\n    [Row(hex=u'15')]\n    \"\"\"\n", "input": "", "output": "    sc = SparkContext._active_spark_context\n    return Column(sc._jvm.functions.conv(_to_java_column(col), fromBase, toBase))", "category": "Python"}, {"instruction": "def indent(self):\n        \"\"\"\n        Indents text at cursor position.\n        \"\"\"\n", "input": "", "output": "        cursor = self.editor.textCursor()\n        assert isinstance(cursor, QtGui.QTextCursor)\n        if cursor.hasSelection():\n            self.indent_selection(cursor)\n        else:\n            # simply insert indentation at the cursor position\n            tab_len = self.editor.tab_length\n            if cursor.positionInBlock() < self.min_column and not cursor.atBlockEnd():\n                cursor.movePosition(cursor.Right, cursor.MoveAnchor, self.min_column)\n            cursor.beginEditBlock()\n            if self.editor.use_spaces_instead_of_tabs:\n                nb_space_to_add = tab_len - (cursor.positionInBlock() - self.min_column) % tab_len\n                cursor.insertText(nb_space_to_add * \" \")\n            else:\n                cursor.insertText('\\t')\n            cursor.endEditBlock()\n            self.editor.setTextCursor(cursor)", "category": "Python"}, {"instruction": "def handle_attribute_value(self, value):\n        \"\"\"Check attribute. Especially designed for avoiding URLs in the form:\n        javascript:myXSSFunction();\"\"\"\n", "input": "", "output": "        if self.re_js.match(value) or self.re_vb.match(value):\n            return ''\n        return value", "category": "Python"}, {"instruction": "def sha_hash(self) -> str:\n        \"\"\"\n        Return uppercase hex sha256 hash from signed raw document\n\n        :return:\n        \"\"\"\n", "input": "", "output": "        return hashlib.sha256(self.signed_raw().encode(\"ascii\")).hexdigest().upper()", "category": "Python"}, {"instruction": "def current_state(self, *,\n                      chat: typing.Union[str, int, None] = None,\n                      user: typing.Union[str, int, None] = None) -> FSMContext:\n        \"\"\"\n        Get current state for user in chat as context\n\n        .. code-block:: python3\n\n            with dp.current_state(chat=message.chat.id, user=message.user.id) as state:\n                pass\n\n            state = dp.current_state()\n            state.set_state('my_state')\n\n        :param chat:\n        :param user:\n        :return:\n        \"\"\"\n", "input": "", "output": "        if chat is None:\n            chat_obj = types.Chat.get_current()\n            chat = chat_obj.id if chat_obj else None\n        if user is None:\n            user_obj = types.User.get_current()\n            user = user_obj.id if user_obj else None\n\n        return FSMContext(storage=self.storage, chat=chat, user=user)", "category": "Python"}, {"instruction": "def point_eval(M, C, x):\n    \"\"\"\n    Evaluates M(x) and C(x).\n\n    Minimizes computation; evaluating M(x) and C(x) separately would\n    evaluate the off-diagonal covariance term twice, but callling\n    point_eval(M,C,x) would only evaluate it once.\n\n    Also chunks the evaluations if the off-diagonal term.\n    \"\"\"\n", "input": "", "output": "\n    x_ = regularize_array(x)\n\n    M_out = empty(x_.shape[0])\n    V_out = empty(x_.shape[0])\n\n    if isinstance(C, pymc.gp.BasisCovariance):\n        y_size = len(C.basis)\n    elif C.obs_mesh is not None:\n        y_size = C.obs_mesh.shape[0]\n    else:\n        y_size = 1\n\n    n_chunks = ceil(y_size * x_.shape[0] / float(chunksize))\n    bounds = array(linspace(0, x_.shape[0], n_chunks + 1), dtype='int')\n    cmin = bounds[:-1]\n    cmax = bounds[1:]\n    for (cmin, cmax) in zip(bounds[:-1], bounds[1:]):\n        x__ = x_[cmin:cmax]\n        V_out[cmin:cmax], Uo_Cxo = C(x__, regularize=False, return_Uo_Cxo=True)\n        M_out[cmin:cmax] = M(x__, regularize=False, Uo_Cxo=Uo_Cxo)\n\n    if len(x.shape) > 1:\n        targ_shape = x.shape[:-1]\n    else:\n        targ_shape = x.shape\n    return M_out.reshape(targ_shape), V_out.reshape(targ_shape)", "category": "Python"}, {"instruction": "def from_bytes(self, string):\n        \"\"\"Deserialize the binder's annotations from a byte string.\"\"\"\n", "input": "", "output": "        msg = srsly.msgpack_loads(gzip.decompress(string))\n        self.attrs = msg[\"attrs\"]\n        self.strings = set(msg[\"strings\"])\n        lengths = numpy.fromstring(msg[\"lengths\"], dtype=\"int32\")\n        flat_spaces = numpy.fromstring(msg[\"spaces\"], dtype=bool)\n        flat_tokens = numpy.fromstring(msg[\"tokens\"], dtype=\"uint64\")\n        shape = (flat_tokens.size // len(self.attrs), len(self.attrs))\n        flat_tokens = flat_tokens.reshape(shape)\n        flat_spaces = flat_spaces.reshape((flat_spaces.size, 1))\n        self.tokens = NumpyOps().unflatten(flat_tokens, lengths)\n        self.spaces = NumpyOps().unflatten(flat_spaces, lengths)\n        for tokens in self.tokens:\n            assert len(tokens.shape) == 2, tokens.shape\n        return self", "category": "Python"}, {"instruction": "def _find_aux_coord_vars(self, ds, refresh=False):\n        '''\n        Returns a list of auxiliary coordinate variables\n\n        An auxiliary coordinate variable is any netCDF variable that contains\n        coordinate data, but is not a coordinate variable (in the sense of the term\n        defined by CF).\n\n        :param netCDF4.Dataset ds: An open netCDF dataset\n        :param bool refresh: if refresh is set to True, the cache is\n                             invalidated.\n        :rtype: list\n        :return: List of variable names (str) that are defined to be auxiliary\n                 coordinate variables.\n        '''\n", "input": "", "output": "        if self._aux_coords.get(ds, None) and refresh is False:\n            return self._aux_coords[ds]\n\n        self._aux_coords[ds] = cfutil.get_auxiliary_coordinate_variables(ds)\n        return self._aux_coords[ds]", "category": "Python"}, {"instruction": "def pattern(head, *args, mode=1, wc_name=None, conditions=None, **kwargs) \\\n        -> Pattern:\n    \"\"\"'Flat' constructor for the Pattern class\n\n    Positional and keyword arguments are mapped into `args` and `kwargs`,\n    respectively. Useful for defining rules that match an instantiated\n    Expression with specific arguments\n    \"\"\"\n", "input": "", "output": "    if len(args) == 0:\n        args = None\n    if len(kwargs) == 0:\n        kwargs = None\n    return Pattern(head, args, kwargs, mode=mode, wc_name=wc_name,\n                   conditions=conditions)", "category": "Python"}, {"instruction": "@\n#Crafty.map.remove\n@comp Crafty.map\n@kind Method\n\n@sign public void Crafty.map.remove(Entry entry)\n@param entry - An entry to remove from the hashmap\n\nRemove an entry from the broad phase map.\n\n@example\n~~~\nCrafty.map.remove(e);\n~~~", "input": "JavaScript", "output": "function(entry) {\n        var keys = entry.keys;\n        var obj = entry.obj;\n        var i = 0,\n            j,\n            hash;\n\n        //search in all x buckets\n        for (i = keys.x1; i <= keys.x2; i++) {\n            //insert into all y buckets\n            for (j = keys.y1; j <= keys.y2; j++) {\n                hash = (i << 16) ^ j;\n\n                if (this.map[hash]) {\n                    var cell = this.map[hash],\n                        m,\n                        n = cell.length;\n                    //loop over objs in cell and delete\n                    for (m = 0; m < n; m++)\n                        if (cell[m] && cell[m][0] === obj[0]) cell.splice(m, 1);\n                }\n            }\n        }\n\n        //mark map boundaries as dirty\n        this.boundsDirty = true;\n    }", "category": "Python"}, {"instruction": "def load(self, client, webpy_app, course_factory, task_factory, database, user_manager, submission_manager, config):\n        \"\"\" Loads the plugin manager. Must be done after the initialisation of the client \"\"\"\n", "input": "", "output": "        self._app = webpy_app\n        self._task_factory = task_factory\n        self._database = database\n        self._user_manager = user_manager\n        self._submission_manager = submission_manager\n        self._loaded = True\n        for entry in config:\n            module = importlib.import_module(entry[\"plugin_module\"])\n            module.init(self, course_factory, client, entry)", "category": "Python"}, {"instruction": "/*\nAuthor: Zion Orent <zorent@ics.com>\nCopyright (c) 2015 Intel Corporation.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", "input": "JavaScript", "output": "function exit()\n{\n\tconsole.log(\"Exiting\");\n\n\tif (myLEDController_obj)\n\t{\n\t\t// clear the bits we set earlier\n\t\tmyLEDController_obj.ledFullOff(3, false);\n\t\tmyLEDController_obj.ledFullOn(4, false);\n\t}\n\tmyLEDController_obj = null;\n\tif (LEDController_lib)\n\t{\n\t\tLEDController_lib.cleanUp();\n\t\tLEDController_lib = null;\n\t}\n\tprocess.exit(0);\n}", "category": "Python"}, {"instruction": "success handler", "input": "JavaScript", "output": "function() {\n          socket[options.decodedPropertyName] = decoded;\n          socket.emit('authenticated');\n          if (server.$emit) {\n            server.$emit('authenticated', socket);\n          } else {\n            //try getting the current namespace otherwise fallback to all sockets.\n            var namespace = (server.nsps && socket.nsp &&\n                             server.nsps[socket.nsp.name]) ||\n                            server.sockets;\n\n            // explicit namespace\n            namespace.emit('authenticated', socket);\n          }\n        }", "category": "Python"}, {"instruction": "Initialize a new Record.\nYou could either use\n```js\nvar records = new Model();\n```\n@or\n```js\nvar records = Model.new();\n```\n\n@class Model\n@method new\n@param {object} attributes - Optional: The records attributes\n\n@return {Record}", "input": "JavaScript", "output": "function(data, castType) {\n    data = data || {}\n\n    // if it's already a record\n    if (data.definition && data._exists) {\n      if (this.add) this.add(data)\n      return data\n    }\n\n    if (this.chained) {\n      var record = this.model.new()\n      if (this.definition.temporary) {\n        record.definition = this.definition\n      }\n\n      record.__chainedModel = this\n      record.set(data, castType)\n\n      this.add(record)\n\n      return record\n    }\n\n    return new this(data, castType)\n  }", "category": "Python"}, {"instruction": "Sends the \"Complete\" request and fulfills the returned promise when the success of this request is known.\n\n@param id ID associated with the file.\n@param uploadId AWS uploadId for this file\n@param etagEntries Array of objects containing `etag` values and their associated `part` numbers.\n@returns {qq.Promise}", "input": "JavaScript", "output": "function(id, uploadId, etagEntries) {\n            var promise = new qq.Promise(),\n                body = getCompleteRequestBody(etagEntries);\n\n            getHeaders(id, uploadId, body).then(function(headers, endOfUrl) {\n                options.log(\"Submitting S3 complete multipart upload request for \" + id);\n\n                pendingCompleteRequests[id] = promise;\n                delete headers[\"Content-Type\"];\n\n                requester.initTransport(id)\n                    .withPath(endOfUrl)\n                    .withHeaders(headers)\n                    .withPayload(body)\n                    .send();\n            }, promise.failure);\n\n            return promise;\n        }", "category": "Python"}, {"instruction": "Parses a YAML string and returns the value.\n\n@param {string} text - The YAML string to be parsed\n@param {function} [reviver] - Not currently supported. Provided for consistency with {@link JSON.parse}\n@returns {*}", "input": "JavaScript", "output": "function yamlParse (text, reviver) {\n    try {\n      return yaml.safeLoad(text);\n    }\n    catch (e) {\n      if (e instanceof Error) {\n        throw e;\n      }\n      else {\n        // https://github.com/nodeca/js-yaml/issues/153\n        throw ono(e, e.message);\n      }\n    }\n  }", "category": "Python"}, {"instruction": "@\n#.bind\n@comp Crafty Core\n@kind Method\n\n@sign public this .bind(String eventName, Function callback)\n@param eventName - Name of the event to bind to\n@param callback - Method to execute when the event is triggered\n\nAttach the current entity (or entities) to listen for an event.\n\nCallback will be invoked when an event with the event name passed\nis triggered. Depending on the event, some data may be passed\nvia an argument to the callback function.\n\nThe first argument is the event name (can be anything) whilst the\nsecond argument is the callback. If the event has data, the\ncallback should have an argument.\n\nEvents are arbitrary and provide communication between components.\nYou can trigger or bind an event even if it doesn't exist yet.\n\nUnlike DOM events, Crafty events are executed synchronously.\n\n@example\n~~~\nthis.attr(\"triggers\", 0); //set a trigger count\nthis.bind(\"myevent\", function() {\nthis.triggers++; //whenever myevent is triggered, increment\n});\nthis.bind(\"UpdateFrame\", function() {\nthis.trigger(\"myevent\"); //trigger myevent on every frame\n});\n~~~\n\n@see .trigger, .unbind", "input": "JavaScript", "output": "function(event, callback) {\n        //  To learn how the event system functions, see the comments for Crafty._callbackMethods\n        //optimization for 1 entity\n        if (this.length === 1) {\n            this._bindCallback(event, callback);\n        } else {\n            for (var i = 0; i < this.length; i++) {\n                var e = entities[this[i]];\n                if (e) {\n                    e._bindCallback(event, callback);\n                }\n            }\n        }\n        return this;\n    }", "category": "Python"}, {"instruction": "save entitlements", "input": "JavaScript", "output": "function setEntitlements(file, entitlements) {\n    const plistContent = plist.build(entitlements);\n\n    mkpath.sync(path.dirname(file));\n\n    fs.writeFileSync(file, plistContent, \"utf8\");\n  }", "category": "Python"}, {"instruction": "client.getNodeServiceEvents\n\n@description retrieve a list of events associated with the activity\nbetween the node and the load balancer\n\n@param {Object}          loadBalancer      the loadBalancer or loadBalancerId\n@param {function}        callback", "input": "JavaScript", "output": "function (loadBalancer, callback) {\n    var self = this,\n        loadBalancerId =\n          loadBalancer instanceof lb.LoadBalancer ? loadBalancer.id : loadBalancer;\n\n    self._request({\n      path: urlJoin(_urlPrefix, loadBalancerId, 'nodes', 'events')\n    }, function (err, body) {\n      return err\n        ? callback(err)\n        : callback(err, body.nodeServiceEvents);\n    });\n  }", "category": "Python"}, {"instruction": "gets an legacy lambda name", "input": "JavaScript", "output": "function getLegacyName(tuple) {\n    if (Array.isArray(tuple)) {\n      var verb = tuple[0]\n      var path = getLegacyLambdaName(tuple[1])\n      return [`${app}-production-${verb}${path}`, `${app}-staging-${verb}${path}`]\n    }\n    else {\n      var path = getLegacyLambdaName(tuple)\n      return [`${app}-production-get${path}`, `${app}-staging-get${path}`]\n    }\n  }", "category": "Python"}, {"instruction": "Create output directory", "input": "JavaScript", "output": "function createDirectory(filenames, next) {\n        fs.exists(config.folder, function(exists) {\n          if (!exists) {\n            fs.mkdir(config.folder, function(err) {\n              if (err) {\n                next(err);\n              } else {\n                next(null, filenames);\n              }\n            });\n          } else {\n            next(null, filenames);\n          }\n        });\n      }", "category": "Python"}, {"instruction": "}}}", "input": "JavaScript", "output": "function createDragbars(li) //{{{\n      {\n        var i;\n        for (i = 0; i < li.length; i++) {\n          dragbar[li[i]] = insertDragbar(li[i]);\n        }\n      }", "category": "Python"}, {"instruction": "removes array item by given index", "input": "JavaScript", "output": "function shift(arr, index) {\n    for (let i = index; i < arr.length; i++) {\n        arr[i] = arr[i + 1];\n    }\n    delete arr[arr.length - 1];\n    arr.length -= 1;\n}", "category": "Python"}, {"instruction": "Remove an article from a level.\n\n@param {Summary} summary\n@param {String|SummaryArticle} level: level to remove\n@return {Summary}", "input": "JavaScript", "output": "function removeArticle(summary, level) {\n    // Coerce to level\n    level = is.string(level)? level : level.getLevel();\n\n    var parent = summary.getParent(level);\n\n    var articles = parent.getArticles();\n    // Find the index to remove\n    var index = articles.findIndex(function(art) {\n        return art.getLevel() === level;\n    });\n    if (index === -1) {\n        return summary;\n    }\n\n    // Remove from children\n    articles = articles.remove(index);\n    parent = parent.set('articles', articles);\n\n    // Reindex the level from here\n    parent = indexArticleLevels(parent);\n\n    return mergeAtLevel(summary, parent.getLevel(), parent);\n}", "category": "Python"}, {"instruction": "Parse Style variables to object", "input": "JavaScript", "output": "function findVariables(string) {\n  // Do not parse empty files. Otherwise gonzales.parse will fail\n  if (!string) {\n    return [];\n  }\n\n  var out = [],\n      ast = gonzales.parse(string, {\n        syntax: 'less'\n      });\n\n  ast.traverseByType('value', function(subAst) {\n    subAst.traverseByType('variable', function(node) {\n      out.push(node.content.toString());\n    });\n  });\n\n  return out;\n}", "category": "Python"}, {"instruction": "Prefill customer fields based on URL query string", "input": "JavaScript", "output": "function (suppliedConfig, urlParams) {\n    $.each(suppliedConfig.customer_fields, function (key) {\n      if (!urlParams['customer.' + key]) return\n      suppliedConfig.customer_fields[key].prefilled = urlParams['customer.' + key];\n    });\n    return suppliedConfig\n  }", "category": "Python"}, {"instruction": "Remember\n\n@param {Object} options\n@return {Remember}\n@api public", "input": "JavaScript", "output": "function Remember(options) {\n  if(!(this instanceof Remember)) return new Remember(options);\n  options = options || {};\n  this.excepts = [];\n  this.ids = {};\n  var self = this;\n\n  // localstorage namespace\n  this.namespace = options.namespace || 'remember:';\n\n  // pull from storage\n  this.pull();\n\n  this.oninput = bind(this, this.input);\n  this.onselect = bind(this, this.select);\n\n  // bindings\n  delegate.bind(document, inputs, 'input', this.oninput);\n  delegate.bind(document, buttons, 'click', this.onselect);\n}", "category": "Python"}, {"instruction": "*\nGets the selection state for a package/module.\nPackage names must end with a slash, modules must not.\nIf an ancestor package of the package/module does not exists, undefined is returned.\n@param {object} oObject The resulting hierarchy object\n@param {string} sName The name to be set in the hierarchy\n@returns {boolean} the selected state of a name", "input": "JavaScript", "output": "function (oObject, sName) {\n\t\t\tsName = sName === '/' ? '' : sName;\n\t\t\tvar aNames = sName.split('/'),\n\t\t\t\tl = aNames.length, i;\n\n\t\t\tif (l > 0) {\n\t\t\t\tfor (i = 0; oObject && i < l - 1; i++) {\n\t\t\t\t\tif (!oObject[aNames[i]]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\toObject = oObject[aNames[i]];\n\t\t\t\t}\n\t\t\t\treturn oObject[aNames[l - 1]];\n\t\t\t}\n\t\t}", "category": "Python"}, {"instruction": "Shows an error dialog indicating that the given file could not be opened due to the given error\n@param {!FileSystemError} name\n@return {!Dialog}", "input": "JavaScript", "output": "function showFileOpenError(name, path) {\n        return Dialogs.showModalDialog(\n            DefaultDialogs.DIALOG_ID_ERROR,\n            Strings.ERROR_OPENING_FILE_TITLE,\n            StringUtils.format(\n                Strings.ERROR_OPENING_FILE,\n                StringUtils.breakableUrl(path),\n                FileUtils.getFileErrorString(name)\n            )\n        );\n    }", "category": "Python"}, {"instruction": "list-specific helper function to set nested children's `level` prop automatically", "input": "JavaScript", "output": "function addNestedLevelProps(childNode, level) {\n  let currentLevel = level;\n\n  if (childNode.tagName) {\n    childNode.level = currentLevel;\n  }\n\n  return currentLevel;\n}", "category": "Python"}, {"instruction": "enqueue an element to the next spot in the queue.", "input": "JavaScript", "output": "function(element, check, go) {\n      var shouldAdd = element.__queue && !element.__queue.check;\n      if (shouldAdd) {\n        queueForElement(element).push(element);\n        element.__queue.check = check;\n        element.__queue.go = go;\n      }\n      return (this.indexOf(element) !== 0);\n    }", "category": "Python"}, {"instruction": "strips trailing slashes and compares urls", "input": "JavaScript", "output": "function _isCurrentUrl(href, currentUrl) {\n        if (!currentUrl) {\n            return false;\n        }\n\n        var strippedHref = href.replace(/\\/+$/, ''),\n            strippedCurrentUrl = currentUrl.replace(/\\/+$/, '');\n        return strippedHref === strippedCurrentUrl;\n    }", "category": "Python"}, {"instruction": "Returns the normalized resource name from the given full resource path.\n\n@param   {string}    path - The full resource path (e.g. \"/restaurants/washington/seattle/joes-diner\")\n@returns {string}         - The normalized resource name (e.g. \"/joes-diner\")", "input": "JavaScript", "output": "function getNameFromPath (path) {\n  path = _(path).toString();\n  let lastSlash = path.substring(0, path.length - 1).lastIndexOf(\"/\");\n  if (lastSlash === -1) {\n    return normalizeName(path);\n  }\n  else {\n    return normalizeName(path.substring(lastSlash));\n  }\n}", "category": "Python"}, {"instruction": "Construct glide.\n\n@param  {String} selector\n@param  {Object} options", "input": "JavaScript", "output": "function Glide(selector) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, Glide);\n\n    this._c = {};\n    this._t = [];\n    this._e = new EventsBus();\n\n    this.disabled = false;\n    this.selector = selector;\n    this.settings = mergeOptions(defaults, options);\n    this.index = this.settings.startAt;\n  }", "category": "Python"}, {"instruction": "Constructs a GeoJSON FeatureCollection object. Applications typically do not call this constructor.\nIt is called by {@link GeoJSON} as GeoJSON is read.\n@alias GeoJSONFeatureCollection\n@constructor\n@classdesc Contains the data associated with a GeoJSON Feature Collection Object.\nAn object of type \"FeatureCollection\" must have a member with the name \"features\".\nThe value corresponding to \"features\" is an array. Each element in the array is a feature object as\ndefined in {@link GeoJSONFeature}.\nTo include information on the coordinate range for feature collections, a GeoJSON object may have a member\nnamed \"bbox\".\n@param {Object} features An object containing the data associated with the GeoJSON FeatureCollection\nfeatures.\n@param {Object} bbox An object containing the value of GeoJSON FeatureCollection bbox member.\n@throws {ArgumentError} If the specified mandatory features parameter is null or undefined.", "input": "JavaScript", "output": "function (features,  bbox) {\n\n            if (!features) {\n                throw new ArgumentError(\n                    Logger.logMessage(Logger.LEVEL_SEVERE, \"GeoJSONFeatureCollection\", \"constructor\",\n                        \"missingFeatures\"));\n            }\n\n            if (Object.prototype.toString.call(features) !== '[object Array]') {\n                throw new ArgumentError(\n                    Logger.logMessage(Logger.LEVEL_SEVERE, \"GeoJSONFeatureCollection\", \"constructor\",\n                        \"invalidFeatures\"));\n            }\n\n            // Documented in defineProperties below.\n            this._features = features;\n\n            // Documented in defineProperties below.\n            this._bbox = bbox;\n        }", "category": "Python"}, {"instruction": "**********", "input": "JavaScript", "output": "function module(name, section) {\n      var module = cache[name];\n      if (!module) {\n        module = cache[name] = {\n          name: name,\n          url: (NG_DOCS.html5Mode ? '' : '#/') + section + '/' + name,\n          globals: [],\n          controllers: [],\n          directives: [],\n          services: [],\n          others: [],\n          service: function(name) {\n            var service =  cache[this.name + ':' + name];\n            if (!service) {\n              service = {name: name};\n              cache[this.name + ':' + name] = service;\n              this.services.push(service);\n            }\n            return service;\n          },\n          types: [],\n          filters: []\n        };\n        modules.push(module);\n      }\n      return module;\n    }", "category": "Python"}, {"instruction": "Checks whether the property of 2 given member expression nodes are the same\nproperty or not.\n\n@param {ASTNode} left - A member expression node to check.\n@param {ASTNode} right - Another member expression node to check.\n@returns {boolean} `true` if the member expressions have the same property.", "input": "JavaScript", "output": "function isSameProperty(left, right) {\n    if (left.property.type === \"Identifier\" &&\n        left.property.type === right.property.type &&\n        left.property.name === right.property.name &&\n        left.computed === right.computed\n    ) {\n        return true;\n    }\n\n    const lname = astUtils.getStaticPropertyName(left);\n    const rname = astUtils.getStaticPropertyName(right);\n\n    return lname !== null && lname === rname;\n}", "category": "Python"}, {"instruction": "/*\noverwrite Labels isDisplayOnly function to use the editable property of the Form\nto determine the mode.\n\nIf DisplayOnly is set explicitly on the Label, this is used.", "input": "JavaScript", "output": "function _labelIsDisplayOnly(){\n\n\t\tif (this.getDisplayOnly) {\n\t\t\tif (!this.isPropertyInitial(\"displayOnly\")) {\n\t\t\t\treturn this.getDisplayOnly();\n\t\t\t}\n\n\t\t\tvar oFormElement = this.getParent();\n\t\t\tvar oFormContainer = oFormElement.getParent();\n\n\t\t\tif (oFormContainer) {\n\t\t\t\tvar oForm = oFormContainer.getParent();\n\n\t\t\t\tif (oForm) {\n\t\t\t\t\treturn !oForm.getEditable();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\n\t}", "category": "Python"}, {"instruction": "Executes the provided `callback` once for each enumerable own property in the\nobject and constructs a new object from the results. The `callback` is\ninvoked with three arguments:\n\n- the property value\n- the property name\n- the object being traversed\n\nProperties that are added after the call to `mapObject` will not be visited\nby `callback`. If the values of existing properties are changed, the value\npassed to `callback` will be the value at the time `mapObject` visits them.\nProperties that are deleted before being visited are not visited.\n\n@grep function objectMap()\n@grep function objMap()\n\n@param {?object} object\n@param {function} callback\n@param {*} context\n@return {?object}", "input": "JavaScript", "output": "function mapObject(object, callback, context) {\n  if (!object) {\n    return null;\n  }\n  var result = {};\n  for (var name in object) {\n    if (hasOwnProperty.call(object, name)) {\n      result[name] = callback.call(context, object[name], name, object);\n    }\n  }\n  return result;\n}", "category": "Python"}, {"instruction": "\u6dfb\u52a0change\u4e8b\u4ef6\n@method change\n@param {Function} fn \u56de\u8c03\u51fd\u6570\n@param {Boolean} after \u65f6\u5019\u7ed1\u5b9aafter\u4e8b\u4ef6\n@chainable", "input": "JavaScript", "output": "function (fn, after) {\n    if (typeof fn === FUNCTION) {\n      this._subs[after ? AFTER : ON].push(fn)\n    }\n\n    return this\n  }", "category": "Python"}, {"instruction": "Determine if a type is abstract (not concrete).\n\nNote: This is used in place of the `graphql` version of the function in order\nto not break `instanceof` checks with Jest. This version also unwraps\nnon-null/list wrapper types.", "input": "JavaScript", "output": "function isAbstractType(type: GraphQLType): boolean {\n  const rawType = getRawType(type);\n  return (\n    rawType instanceof GraphQLInterfaceType ||\n    rawType instanceof GraphQLUnionType\n  );\n}", "category": "Python"}, {"instruction": "Reorder tracks in a playlist.\n@param {string} playlistId The playlist's ID\n@param {int} rangeStart The position of the first track to be reordered.\n@param {int} insertBefore The position where the tracks should be inserted.\n@param {Object} options Optional parameters, i.e. range_length and snapshot_id.\n@param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n@returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\nit contains an error object. Not returned if a callback is given.", "input": "JavaScript", "output": "function(\n    playlistId,\n    rangeStart,\n    insertBefore,\n    options,\n    callback\n  ) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(\n        {\n          range_start: rangeStart,\n          insert_before: insertBefore\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.put, callback);\n  }", "category": "Python"}, {"instruction": "Get the constructor for a type\n\nIf the type is not registered, use generic {module:core/abstracts.MediaObject}\n\n@function module:kurentoClient~MediaObjectCreator~getConstructor\n\n@param {external:string} type\n@param {external:Boolean} strict\n\n@return {module:core/abstracts.MediaObject}", "input": "JavaScript", "output": "function getConstructor(type, strict) {\n  var result = register.classes[type.qualifiedType] || register.abstracts[type\n      .qualifiedType] ||\n    register.classes[type.type] || register.abstracts[type.type] ||\n    register.classes[type] || register.abstracts[type];\n  if (result) return result;\n\n  if (type.hierarchy != undefined) {\n    for (var i = 0; i <= type.hierarchy.length - 1; i++) {\n      var result = register.classes[type.hierarchy[i]] || register.abstracts[\n        type.hierarchy[i]];\n      if (result) return result;\n    };\n  }\n  if (strict) {\n    var error = new SyntaxError(\"Unknown type '\" + type + \"'\")\n    error.type = type\n\n    throw error\n  }\n\n  console.warn(\"Unknown type '\", type, \"', using MediaObject instead\");\n  return register.abstracts.MediaObject;\n}", "category": "Python"}, {"instruction": "def execute_ping(host_list, remote_user, remote_pass,\n                 sudo=False, sudo_user=None, sudo_pass=None):\n    '''\n    Execute ls on some hosts\n    '''\n", "input": "", "output": "    runner = spam.ansirunner.AnsibleRunner()\n    result, failed_hosts = runner.ansible_perform_operation(\n        host_list=host_list,\n        remote_user=remote_user,\n        remote_pass=remote_pass,\n        sudo=sudo,\n        sudo_pass=sudo_pass,\n        sudo_user=sudo_user,\n        module=\"ping\")\n\n    print result, failed_hosts\n    dark_hosts = runner.ansible_get_dark_hosts(result)\n    print \"dark hosts: \", dark_hosts", "category": "Python"}, {"instruction": "def is_node(objecttype):\n    \"\"\"\n    Check if the given objecttype has Node as an interface\n    \"\"\"\n", "input": "", "output": "    if not isclass(objecttype):\n        return False\n\n    if not issubclass(objecttype, ObjectType):\n        return False\n\n    for i in objecttype._meta.interfaces:\n        if issubclass(i, Node):\n            return True\n\n    return False", "category": "Python"}, {"instruction": "def _try_instantiate(self, ipopo, factory, component):\n        # type: (Any, str, str) -> None\n        \"\"\"\n        Tries to instantiate a component from the queue. Hides all exceptions.\n\n        :param ipopo: The iPOPO service\n        :param factory: Component factory\n        :param component: Component name\n        \"\"\"\n", "input": "", "output": "        try:\n            # Get component properties\n            with self.__lock:\n                properties = self.__queue[factory][component]\n        except KeyError:\n            # Component not in queue\n            return\n        else:\n            try:\n                # Try instantiation\n                ipopo.instantiate(factory, component, properties)\n            except TypeError:\n                # Unknown factory: try later\n                pass\n            except ValueError as ex:\n                # Already known component\n                _logger.error(\"Component already running: %s\", ex)\n            except Exception as ex:\n                # Other error\n                _logger.exception(\"Error instantiating component: %s\", ex)", "category": "Python"}, {"instruction": "def register_algorithm(self, alg_id, alg_obj):\n        \"\"\"\n        Registers a new Algorithm for use when creating and verifying tokens.\n        \"\"\"\n", "input": "", "output": "        if alg_id in self._algorithms:\n            raise ValueError('Algorithm already has a handler.')\n\n        if not isinstance(alg_obj, Algorithm):\n            raise TypeError('Object is not of type `Algorithm`')\n\n        self._algorithms[alg_id] = alg_obj\n        self._valid_algs.add(alg_id)", "category": "Python"}, {"instruction": "def parse_scalar_type_extension(lexer: Lexer) -> ScalarTypeExtensionNode:\n    \"\"\"ScalarTypeExtension\"\"\"\n", "input": "", "output": "    start = lexer.token\n    expect_keyword(lexer, \"extend\")\n    expect_keyword(lexer, \"scalar\")\n    name = parse_name(lexer)\n    directives = parse_directives(lexer, True)\n    if not directives:\n        raise unexpected(lexer)\n    return ScalarTypeExtensionNode(\n        name=name, directives=directives, loc=loc(lexer, start)\n    )", "category": "Python"}, {"instruction": "def has_next_assessment_section(self, assessment_section_id):\n        \"\"\"Tests if there is a next assessment section in the assessment following the given assessment section ``Id``.\n\n        arg:    assessment_section_id (osid.id.Id): ``Id`` of the\n                ``AssessmentSection``\n        return: (boolean) - ``true`` if there is a next section,\n                ``false`` otherwise\n        raise:  IllegalState - ``has_assessment_begun()`` is ``false``\n        raise:  NotFound - ``assessment_taken_id`` is not found\n        raise:  NullArgument - ``assessment_taken_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n", "input": "", "output": "        try:\n            self.get_next_assessment_section(assessment_section_id)\n        except errors.IllegalState:\n            return False\n        else:\n            return True", "category": "Python"}, {"instruction": "def is_logged(self, user):\n        \"\"\"Check if a logged user is trying to access the register page.\n           If so, redirect him/her to his/her profile\"\"\"\n", "input": "", "output": "\n        response = None\n        if user.is_authenticated():\n            if not user.needs_update:\n                response = redirect('user_profile', username=user.username)\n\n        return response", "category": "Python"}, {"instruction": "def digest(dirname, glob=None):\n    \"\"\"Returns the md5 digest of all interesting files (or glob) in `dirname`.\n    \"\"\"\n", "input": "", "output": "    md5 = hashlib.md5()\n    if glob is None:\n        fnames = [fname for _, fname in list_files(Path(dirname))]\n        for fname in sorted(fnames):\n            fname = os.path.join(dirname, fname)\n            md5.update(open(fname, 'rb').read())\n    else:\n        fnames = Path(dirname).glob(glob)\n        for fname in sorted(fnames):\n            md5.update(fname.open('rb').read())\n    return md5.hexdigest()", "category": "Python"}, {"instruction": "def get_genus_type_metadata(self):\n        \"\"\"Overrides get_genus_type_metadata of extended object\"\"\"\n", "input": "", "output": "        metadata = dict(self.my_osid_object_form._genus_type_metadata)\n        metadata.update({'read_only': True})\n        return Metadata(**metadata)", "category": "Python"}, {"instruction": "def qos_map_cos_mutation_cos1(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n", "input": "", "output": "        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        map = ET.SubElement(qos, \"map\")\n        cos_mutation = ET.SubElement(map, \"cos-mutation\")\n        name_key = ET.SubElement(cos_mutation, \"name\")\n        name_key.text = kwargs.pop('name')\n        cos1 = ET.SubElement(cos_mutation, \"cos1\")\n        cos1.text = kwargs.pop('cos1')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "category": "Python"}, {"instruction": "def ifaces(cls, name):\n        \"\"\" Get vlan attached ifaces. \"\"\"\n", "input": "", "output": "        ifaces = Iface.list({'vlan_id': cls.usable_id(name)})\n        ret = []\n        for iface in ifaces:\n            ret.append(Iface.info(iface['id']))\n        return ret", "category": "Python"}, {"instruction": "def difference(self, *args):\n        \"\"\"\n        Take the difference between one array and a number of other arrays.\n        Only the elements present in just the first array will remain.\n        \"\"\"\n", "input": "", "output": "        setobj = set(self.obj)\n        for i, v in enumerate(args):\n            setobj = setobj - set(args[i])\n        return self._wrap(self._clean._toOriginal(setobj))", "category": "Python"}, {"instruction": "def parse(cls, conn):\n        \"\"\"Read a request from the HTTP connection ``conn``.\n\n        May raise ``BadHttpRequestError``.\n        \"\"\"\n", "input": "", "output": "\n        req = cls(conn)\n        req_line = yield from conn.reader.readline()\n        logger('HttpRequest').debug('req_line = %r', req_line)\n        req._parse_req_line(req_line)\n\n        header_line = yield from conn.reader.readline()\n        while len(header_line) > 0 and header_line != b'\\r\\n':\n            try:\n                req._parse_header(header_line)\n            except BadHttpHeaderError as e:\n                # Tolerating 'minor' mistakes\n                logger('HttpRequest').debug(traceback.format_exc())\n            header_line = yield from conn.reader.readline()\n        return req", "category": "Python"}, {"instruction": "def load(self):\n        \"\"\" Return the model from the store \"\"\"\n", "input": "", "output": "\n        filters = [Filter(self.field, 'eq', self.rid)]\n        store = goldman.sess.store\n\n        self._is_loaded = True\n        self.models = store.search(self.rtype, filters=filters)\n\n        return self.models", "category": "Python"}, {"instruction": "def ints2str(self, int_values):\n    \"\"\"Conversion list[int] => decoded string.\"\"\"\n", "input": "", "output": "    if not self._encoder:\n      raise ValueError(\n          \"Text.ints2str is not available because encoder hasn't been defined.\")\n    return self._encoder.decode(int_values)", "category": "Python"}, {"instruction": "def stringize(\n        self,\n        rnf_profile=RnfProfile(),\n    ):\n        \"\"\"Create RNF representation of this read.\n\n\t\tArgs:\n\t\t\tread_tuple_id_width (int): Maximal expected string length of read tuple ID.\n\t\t\tgenome_id_width (int): Maximal expected string length of genome ID.\n\t\t\tchr_id_width (int): Maximal expected string length of chromosome ID.\n\t\t\tcoor_width (int): Maximal expected string length of a coordinate.\n\t\t\"\"\"\n", "input": "", "output": "\n        sorted_segments = sorted(self.segments,\n         key=lambda x: (\n          x.genome_id * (10 ** 23) +\n          x.chr_id * (10 ** 21) +\n          (x.left + (int(x.left == 0) * x.right - 1)) * (10 ** 11) +\n          x.right * (10 ** 1) +\n          int(x.direction == \"F\")\n         )\n        )\n\n        segments_strings = [x.stringize(rnf_profile) for x in sorted_segments]\n\n        read_tuple_name = \"__\".join(\n            [\n                self.prefix,\n                format(self.read_tuple_id, 'x').zfill(rnf_profile.read_tuple_id_width),\n                \",\".join(segments_strings),\n                self.suffix,\n            ]\n        )\n\n        return read_tuple_name", "category": "Python"}, {"instruction": "def get_pr_review_status(pr: PullRequestDetails) -> Any:\n    \"\"\"\n    References:\n        https://developer.github.com/v3/pulls/reviews/#list-reviews-on-a-pull-request\n    \"\"\"\n", "input": "", "output": "    url = (\"https://api.github.com/repos/{}/{}/pulls/{}/reviews\"\n           \"?access_token={}\".format(pr.repo.organization,\n                                     pr.repo.name,\n                                     pr.pull_id,\n                                     pr.repo.access_token))\n    response = requests.get(url)\n\n    if response.status_code != 200:\n        raise RuntimeError(\n            'Get review failed. Code: {}. Content: {}.'.format(\n                response.status_code, response.content))\n\n    return json.JSONDecoder().decode(response.content.decode())", "category": "Python"}, {"instruction": "def wait_for_compute_global_operation(project_name, operation):\n    \"\"\"Poll for global compute operation until finished.\"\"\"\n", "input": "", "output": "    logger.info(\"wait_for_compute_global_operation: \"\n                \"Waiting for operation {} to finish...\".format(\n                    operation[\"name\"]))\n\n    for _ in range(MAX_POLLS):\n        result = compute.globalOperations().get(\n            project=project_name,\n            operation=operation[\"name\"],\n        ).execute()\n        if \"error\" in result:\n            raise Exception(result[\"error\"])\n\n        if result[\"status\"] == \"DONE\":\n            logger.info(\"wait_for_compute_global_operation: \"\n                        \"Operation done.\")\n            break\n\n        time.sleep(POLL_INTERVAL)\n\n    return result", "category": "Python"}, {"instruction": "def __interact_writen(self, fd, data):\n        '''This is used by the interact() method.\n        '''\n", "input": "", "output": "\n        while data != b'' and self.isalive():\n            n = os.write(fd, data)\n            data = data[n:]", "category": "Python"}, {"instruction": "def _publish_stats(self, counter_prefix, stats):\n        \"\"\"Given a stats dictionary from _get_stats_from_socket,\n        publish the individual values.\n        \"\"\"\n", "input": "", "output": "        for stat_name, stat_value in flatten_dictionary(\n            stats,\n            prefix=counter_prefix,\n        ):\n            self.publish_gauge(stat_name, stat_value)", "category": "Python"}, {"instruction": "def _fault_to_exception(f):\n    \"\"\" Converts XML-RPC Fault objects to Pynipap-exceptions.\n\n        TODO: Is this one neccesary? Can be done inline...\n    \"\"\"\n", "input": "", "output": "\n    e = _fault_to_exception_map.get(f.faultCode)\n    if e is None:\n        e = NipapError\n    return e(f.faultString)", "category": "Python"}, {"instruction": "def _get_metric(self, metric, tablename, index_name=None):\n        \"\"\" Fetch a read/write capacity metric \"\"\"\n", "input": "", "output": "        end = time.time()\n        begin = end - 3 * 60  # 3 minute window\n        dimensions = [{\"Name\": \"TableName\", \"Value\": tablename}]\n        if index_name is not None:\n            dimensions.append({\"Name\": \"GlobalSecondaryIndexName\", \"Value\": index_name})\n        period = 60\n        data = self.cloudwatch_connection.get_metric_statistics(\n            Period=period,\n            StartTime=begin,\n            EndTime=end,\n            MetricName=metric,\n            Namespace=\"AWS/DynamoDB\",\n            Statistics=[\"Sum\"],\n            Dimensions=dimensions,\n        )\n        points = data[\"Datapoints\"]\n        if not points:\n            return 0\n        else:\n            points.sort(key=lambda r: r[\"Timestamp\"])\n            return float(points[-1][\"Sum\"]) / period", "category": "Python"}, {"instruction": "def sso(user, desired_username, name, email, profile_fields=None):\n    \"\"\"\n    Create a user, if the provided `user` is None, from the parameters.\n    Then log the user in, and return it.\n    \"\"\"\n", "input": "", "output": "    if not user:\n        if not settings.REGISTRATION_OPEN:\n            raise SSOError('Account registration is closed')\n        user = _create_desired_user(desired_username)\n        _configure_user(user, name, email, profile_fields)\n\n    if not user.is_active:\n        raise SSOError('Account disabled')\n\n    # login() expects the logging in backend to be set on the user.\n    # We are bypassing login, so fake it.\n    user.backend = settings.AUTHENTICATION_BACKENDS[0]\n    return user", "category": "Python"}, {"instruction": "def p_array_literal_2(self, p):\n        \"\"\"array_literal : LBRACKET element_list RBRACKET\n                         | LBRACKET element_list COMMA elision_opt RBRACKET\n        \"\"\"\n", "input": "", "output": "        items = p[2]\n        if len(p) == 6:\n            items.extend(p[4])\n        p[0] = ast.Array(items=items)", "category": "Python"}, {"instruction": "def loc_adjacent_to_opponent_king(self, location, position):\n        \"\"\"\n        Finds if 2 kings are touching given the position of one of the kings.\n\n        :type: location: Location\n        :type: position: Board\n        :rtype: bool\n        \"\"\"\n", "input": "", "output": "        for fn in self.cardinal_directions:\n            try:\n                if isinstance(position.piece_at_square(fn(location)), King) and \\\n                        position.piece_at_square(fn(location)).color != self.color:\n                    return True\n\n            except IndexError:\n                pass\n\n        return False", "category": "Python"}, {"instruction": "def on_unexpected_error(e):  # pragma: no cover\n    \"\"\"Catch-all error handler\n\n    Unexpected errors will be handled by this function.\n    \"\"\"\n", "input": "", "output": "    sys.stderr.write('Unexpected error: {} ({})\\n'.format(\n        str(e), e.__class__.__name__))\n    sys.stderr.write('See file slam_error.log for additional details.\\n')\n    sys.exit(1)", "category": "Python"}, {"instruction": "def check_images(data):\n    \"\"\"\n    Check and reformat input images if needed\n    \"\"\"\n", "input": "", "output": "    if isinstance(data, ndarray):\n        data = fromarray(data)\n    \n    if not isinstance(data, Images):\n        data = fromarray(asarray(data))\n\n    if len(data.shape) not in set([3, 4]):\n        raise Exception('Number of image dimensions %s must be 2 or 3' % (len(data.shape)))\n\n    return data", "category": "Python"}, {"instruction": "def pbkdf2(seed: str or bytes, dk_len: int) -> bytes:\n    \"\"\"\n    Derive one key from a seed.\n\n    :param seed: the secret pass phrase to generate the keys from.\n    :param dk_len: the length in bytes of every derived key.\n    :return:\n    \"\"\"\n", "input": "", "output": "    key = b''\n    index = 1\n    bytes_seed = str_to_bytes(seed)\n    while len(key) < dk_len:\n        key += Digest.sha256(b''.join([bytes_seed, index.to_bytes(4, 'big', signed=True)]))\n        index += 1\n    return key[:dk_len]", "category": "Python"}, {"instruction": "def en_last(self):\n        \"\"\" Report the energies from the last SCF present in the output.\n\n        Returns a |dict| providing the various energy values from the\n        last SCF cycle performed in the output. Keys are those of\n        :attr:`~opan.output.OrcaOutput.p_en`.\n        Any energy value not relevant to the parsed\n        output is assigned as |None|.\n\n        Returns\n        -------\n        last_ens\n            |dict| of |npfloat_|--\n            Energies from the last SCF present in the output.\n\n        \"\"\"\n", "input": "", "output": "\n        # Initialize the return dict\n        last_ens = dict()\n\n        # Iterate and store\n        for (k,l) in self.en.items():\n            last_ens.update({ k : l[-1] if l != [] else None })\n        ##next (k,l)\n\n        # Should be ready to return?\n        return last_ens", "category": "Python"}, {"instruction": "def from_stored(self, key):\n        \"\"\"\n        Set the current collection as based on a stored one. The key argument\n        is the key off the stored collection.\n        \"\"\"\n", "input": "", "output": "        # only one stored key allowed\n        if self.stored_key:\n            raise ValueError('This collection is already based on a stored one')\n\n        # prepare the collection\n        self.stored_key = key\n        self.intersect(_StoredCollection(self.cls.get_connection(), key))\n        self.sort(by='nosort')  # keep stored order\n\n        # count the number of results to manage empty result (to not behave like\n        # expired key)\n        self._stored_len = self.cls.get_connection().llen(key)\n\n        return self", "category": "Python"}, {"instruction": "def read_long_description(readme_file):\n    \"\"\" Read package long description from README file \"\"\"\n", "input": "", "output": "    try:\n        import pypandoc\n    except (ImportError, OSError) as exception:\n        print('No pypandoc or pandoc: %s' % (exception,))\n        if sys.version_info.major == 3:\n            handle = open(readme_file, encoding='utf-8')\n        else:\n            handle = open(readme_file)\n        long_description = handle.read()\n        handle.close()\n        return long_description\n    else:\n        return pypandoc.convert(readme_file, 'rst')", "category": "Python"}, {"instruction": "def _save_stdin(self, stdin):\n\t\t\"\"\"\n\t\tCreates a temporary dir (self.temp_dir) and saves the given input\n\t\tstream to a file within that dir. Returns the path to the file. The dir\n\t\tis removed in the __del__ method.\n\t\t\"\"\"\n", "input": "", "output": "\t\tself.temp_dir = TemporaryDirectory()\n\t\tfile_path = os.path.join(self.temp_dir.name, 'dataset')\n\n\t\ttry:\n\t\t\twith open(file_path, 'w') as f:\n\t\t\t\tfor line in stdin:\n\t\t\t\t\tf.write(line)\n\t\texcept TypeError:\n\t\t\tself.temp_dir.cleanup()\n\t\t\traise ValueError('Could not read stdin')\n\n\t\treturn file_path", "category": "Python"}, {"instruction": "def get_all_licenses(self):\n        \"\"\"Retrieve license type, key, installation date, etc.\"\"\"\n", "input": "", "output": "        data = self._execute_command('GET_ALL_LICENSES', 'RIB_INFO', 'read')\n        d = {}\n        for key, val in data['GET_ALL_LICENSES']['LICENSE'].items():\n            if isinstance(val, dict):\n                d[key] = data['GET_ALL_LICENSES']['LICENSE'][key]['VALUE']\n        return d", "category": "Python"}, {"instruction": "def get_storage_usage(access_token, subscription_id, location):\n    '''Returns storage usage and quota information for the specified subscription.\n\n    Args:\n        access_token (str): A valid Azure authentication token.\n        subscription_id (str): Azure subscription id.\n\n    Returns:\n        HTTP response. JSON body of storage account usage.\n    '''\n", "input": "", "output": "    endpoint = ''.join([get_rm_endpoint(),\n                        '/subscriptions/', subscription_id,\n                        '/providers/Microsoft.Storage/locations/', location,\n                        '/usages',\n                        '?api-version=', STORAGE_API])\n    return do_get(endpoint, access_token)", "category": "Python"}, {"instruction": "def set_custom_image(user_context, app_id, image_path):\n  \"\"\"Sets the custom image for `app_id` to be the image located at\n  `image_path`. If there already exists a custom image for `app_id` it will\n  be deleted. Returns True is setting the image was successful.\"\"\"\n", "input": "", "output": "  if image_path is None:\n    return False\n\n  if not os.path.exists(image_path):\n    return False\n\n  (root, ext) = os.path.splitext(image_path)\n  if not is_valid_extension(ext):\n    # TODO: Maybe log that this happened?\n    return False\n  # If we don't remove the old image then theres no guarantee that Steam will\n  # show our new image when it launches.\n  if has_custom_image(user_context, app_id):\n    img = get_custom_image(user_context, app_id)\n    assert(img is not None)\n    os.remove(img)\n  \n  # Set the new image\n  parent_dir = paths.custom_images_directory(user_context)\n  new_path = os.path.join(parent_dir, app_id + ext)\n  shutil.copyfile(image_path, new_path)\n  return True", "category": "Python"}, {"instruction": "def update(self, *args, **kwargs):\n        '''Preserves order if given an assoc list.\n        '''\n", "input": "", "output": "        arg = dict_arg(*args, **kwargs)\n        if isinstance(arg, list):\n          for key, val in arg:\n              self[key] = val\n        else:\n            super(AssocDict, self).update(arg)", "category": "Python"}, {"instruction": "def get_notifier(provider_name: str, strict: bool = False) -> Provider:\n    \"\"\"\n    Convenience method to return an instantiated :class:`~notifiers.core.Provider` object according to it ``name``\n\n    :param provider_name: The ``name`` of the requested :class:`~notifiers.core.Provider`\n    :param strict: Raises a :class:`ValueError` if the given provider string was not found\n    :return: :class:`Provider` or None\n    :raises ValueError: In case ``strict`` is True and provider not found\n    \"\"\"\n", "input": "", "output": "    if provider_name in _all_providers:\n        log.debug(\"found a match for '%s', returning\", provider_name)\n        return _all_providers[provider_name]()\n    elif strict:\n        raise NoSuchNotifierError(name=provider_name)", "category": "Python"}, {"instruction": "def info_progress(prefix: str, value: float, max_value: float) -> None:\n    \"\"\" Display info progress in percent.\n\n    :param value: the current value\n    :param max_value: the max value\n    :param prefix: the prefix message to print\n\n\n    \"\"\"\n", "input": "", "output": "    if sys.stdout.isatty():\n        percent = float(value) / max_value * 100\n        sys.stdout.write(prefix + \": %.0f%%\\r\" % percent)\n        sys.stdout.flush()", "category": "Python"}, {"instruction": "def analysis(self):\n        \"\"\"The list of analysis of ``words`` layer elements.\"\"\"\n", "input": "", "output": "        if not self.is_tagged(ANALYSIS):\n            self.tag_analysis()\n        return [word[ANALYSIS] for word in self.words]", "category": "Python"}, {"instruction": "def xstep(self):\n        r\"\"\"Minimise Augmented Lagrangian with respect to\n        :math:`\\mathbf{x}`.\n        \"\"\"\n", "input": "", "output": "\n        b = self.AHSf + self.rho*np.sum(\n            np.conj(self.Gf)*sl.rfftn(self.Y-self.U, axes=self.axes),\n            axis=self.Y.ndim-1)\n        self.Xf = b / (self.AHAf + self.rho*self.GHGf)\n        self.X = sl.irfftn(self.Xf, self.axsz, axes=self.axes)\n\n        if self.opt['LinSolveCheck']:\n            ax = (self.AHAf + self.rho*self.GHGf)*self.Xf\n            self.xrrs = sl.rrs(ax, b)\n        else:\n            self.xrrs = None", "category": "Python"}, {"instruction": "def _send(self, value, mode):\n        \"\"\"Send the specified value to the display with automatic 4bit / 8bit\n        selection. The rs_mode is either ``RS_DATA`` or ``RS_INSTRUCTION``.\"\"\"\n", "input": "", "output": "\n        # Assemble the parameters sent to the pigpio script\n        params = [mode]\n        params.extend([(value >> i) & 0x01 for i in range(8)])\n        # Switch off pigpio's exceptions, so that we get the return codes\n        pigpio.exceptions = False\n        while True:\n            ret = self.pi.run_script(self._writescript, params)\n            if ret >= 0:\n                break\n            elif ret != pigpio.PI_SCRIPT_NOT_READY:\n                raise pigpio.error(pigpio.error_text(ret))\n            # If pigpio script is not ready, sleep and try again\n            c.usleep(1)\n        # Switch on pigpio's exceptions\n        pigpio.exceptions = True", "category": "Python"}, {"instruction": "def write_sheet(writer, name, df, index=False):\n    \"\"\"Write a pandas DataFrame to an ExcelWriter,\n    auto-formatting column width depending on maxwidth of data and colum header\n\n    Parameters\n    ----------\n    writer: pandas.ExcelWriter\n        an instance of a pandas ExcelWriter\n    name: string\n        name of the sheet to be written\n    df: pandas.DataFrame\n        a pandas DataFrame to be written to the sheet\n    index: boolean, default False\n        flag whether index should be written to the sheet\n    \"\"\"\n", "input": "", "output": "    if index:\n        df = df.reset_index()\n    df.to_excel(writer, name, index=False)\n    worksheet = writer.sheets[name]\n    for i, col in enumerate(df.columns):\n        if df.dtypes[col].name.startswith(('float', 'int')):\n            width = len(str(col)) + 2\n        else:\n            width = max([df[col].map(lambda x: len(str(x or 'None'))).max(),\n                         len(col)]) + 2\n        xls_col = '{c}:{c}'.format(c=NUMERIC_TO_STR[i])\n        worksheet.set_column(xls_col, width)", "category": "Python"}, {"instruction": "def delete_webhook(self, id, **kwargs):  # noqa: E501\n        \"\"\"Delete a specific webhook  # noqa: E501\n\n          # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.delete_webhook(id, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id: (required)\n        :return: ResponseContainerNotificant\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n", "input": "", "output": "        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async_req'):\n            return self.delete_webhook_with_http_info(id, **kwargs)  # noqa: E501\n        else:\n            (data) = self.delete_webhook_with_http_info(id, **kwargs)  # noqa: E501\n            return data", "category": "Python"}, {"instruction": "def _cb_inform_interface_change(self, msg):\n        \"\"\"Update the sensors and requests available.\"\"\"\n", "input": "", "output": "        self._logger.debug('cb_inform_interface_change(%s)', msg)\n        self._interface_changed.set()", "category": "Python"}, {"instruction": "def delete_build_configuration(id=None, name=None):\n    \"\"\"\n    Delete an existing BuildConfiguration\n    :param id:\n    :param name:\n    :return:\n    \"\"\"\n", "input": "", "output": "    data = delete_build_configuration_raw(id, name)\n    if data:\n        return utils.format_json(data)", "category": "Python"}, {"instruction": "def getBool(t):\n    \"\"\"If t is of type bool, return it, otherwise raise InvalidTypeError.\n    \"\"\"\n", "input": "", "output": "    b = c_int()\n    if PL_get_long(t, byref(b)):\n        return bool(b.value)\n    else:\n        raise InvalidTypeError(\"bool\")", "category": "Python"}, {"instruction": "def create_and_register_access_db(filename: str,\n                                  dsn: str,\n                                  description: str) -> bool:\n    \"\"\"\n    (Windows only.)\n    Creates a Microsoft Access database and registers it with ODBC.\n\n    Args:\n        filename: filename of the database to create\n        dsn: ODBC data source name to create\n        description: description of the database\n\n    Returns:\n        bool: was the DSN created?\n    \"\"\"\n", "input": "", "output": "    fullfilename = os.path.abspath(filename)\n    create_string = fullfilename + \" General\"\n    # ... filename, space, sort order (\"General\" for English)\n    return (create_user_dsn(access_driver, CREATE_DB=create_string) and\n            register_access_db(filename, dsn, description))", "category": "Python"}, {"instruction": "def halt(self):\n        \"\"\"Halts the CPU Core.\n\n        Args:\n          self (JLink): the ``JLink`` instance\n\n        Returns:\n          ``True`` if halted, ``False`` otherwise.\n        \"\"\"\n", "input": "", "output": "        res = int(self._dll.JLINKARM_Halt())\n        if res == 0:\n            time.sleep(1)\n            return True\n        return False", "category": "Python"}, {"instruction": "def minibatch(items, size=8):\n    \"\"\"Iterate over batches of items. `size` may be an iterator,\n    so that batch-size can vary on each step.\n    \"\"\"\n", "input": "", "output": "    if isinstance(size, int):\n        size_ = itertools.repeat(size)\n    else:\n        size_ = size\n    items = iter(items)\n    while True:\n        batch_size = next(size_)\n        batch = list(itertools.islice(items, int(batch_size)))\n        if len(batch) == 0:\n            break\n        yield list(batch)", "category": "Python"}, {"instruction": "def _cz_gate(self, lines):\n        \"\"\"\n        Return the TikZ code for an n-controlled Z-gate.\n\n        :param lines: List of all qubits involved.\n        :type: list[int]\n        \"\"\"\n", "input": "", "output": "        line = lines[0]\n        delta_pos = self._gate_offset(Z)\n        gate_width = self._gate_width(Z)\n        gate_str = self._phase(line, self.pos[line])\n\n        for ctrl in lines[1:]:\n            gate_str += self._phase(ctrl, self.pos[line])\n            gate_str += self._line(ctrl, line)\n\n        new_pos = self.pos[line] + delta_pos + gate_width\n        for i in lines:\n            self.op_count[i] += 1\n        for i in range(min(lines), max(lines) + 1):\n            self.pos[i] = new_pos\n        return gate_str", "category": "Python"}, {"instruction": "def send(\n        self, record, message, resource=None, labels=None, trace=None, span_id=None\n    ):\n        \"\"\"Overrides transport.send().\n\n        :type record: :class:`logging.LogRecord`\n        :param record: Python log record that the handler was called with.\n\n        :type message: str\n        :param message: The message from the ``LogRecord`` after being\n                        formatted by the associated log formatters.\n\n        :type resource: :class:`~google.cloud.logging.resource.Resource`\n        :param resource: (Optional) Monitored resource of the entry.\n\n        :type labels: dict\n        :param labels: (Optional) Mapping of labels for the entry.\n        \"\"\"\n", "input": "", "output": "        info = {\"message\": message, \"python_logger\": record.name}\n        self.logger.log_struct(\n            info,\n            severity=record.levelname,\n            resource=resource,\n            labels=labels,\n            trace=trace,\n            span_id=span_id,\n        )", "category": "Python"}, {"instruction": "def calculate_size(name, sequence):\n    \"\"\" Calculates the request payload size\"\"\"\n", "input": "", "output": "    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += LONG_SIZE_IN_BYTES\n    return data_size", "category": "Python"}, {"instruction": "def xclaim(self, stream, group_name, consumer_name, min_idle_time,\n               id, *ids):\n        \"\"\"Claim a message for a given consumer\"\"\"\n", "input": "", "output": "        fut = self.execute(\n            b'XCLAIM', stream, group_name, consumer_name, min_idle_time,\n            id, *ids\n        )\n        return wait_convert(fut, parse_messages)", "category": "Python"}, {"instruction": "def get_changeform_initial_data(self, request):\n        \"\"\"\n        Provide initial datas when creating an entry.\n        \"\"\"\n", "input": "", "output": "        get_data = super(EntryAdmin, self).get_changeform_initial_data(request)\n        return get_data or {\n            'sites': [Site.objects.get_current().pk],\n            'authors': [request.user.pk]\n        }", "category": "Python"}, {"instruction": "def _eight_byte_real_to_float(value):\n    \"\"\"\n    Convert a number from GDSII 8 byte real format to float.\n\n    Parameters\n    ----------\n    value : string\n        The GDSII binary string representation of the number.\n\n    Returns\n    -------\n    out : float\n        The number represented by ``value``.\n    \"\"\"\n", "input": "", "output": "    short1, short2, long3 = struct.unpack('>HHL', value)\n    exponent = (short1 & 0x7f00) // 256 - 64\n    mantissa = (((short1 & 0x00ff) * 65536 + short2) * 4294967296 +\n                long3) / 72057594037927936.0\n    if short1 & 0x8000:\n        return -mantissa * 16.**exponent\n    return mantissa * 16.**exponent", "category": "Python"}, {"instruction": "def _entry_must_exist(df, k1, k2):\n    \"\"\"Evaluate key-subkey existence.\n\n    Checks that the key-subkey combo exists in the\n    configuration options.\n    \"\"\"\n", "input": "", "output": "    count = df[(df['k1'] == k1) &\n               (df['k2'] == k2)].shape[0]\n    if count == 0:\n        raise NotRegisteredError(\n            \"Option {0}.{1} not registered\".format(k1, k2))", "category": "Python"}, {"instruction": "def _is_json(string):\n        \"\"\"Test if input string is in JSON format.\n\n        :param string: Input string.\n        :type string: :py:class:`str` or :py:class:`bytes`\n        :return: Input string if in JSON format or False otherwise.\n        :rtype: :py:class:`str` or :py:obj:`False`\n        \"\"\"\n", "input": "", "output": "        try:\n            if isinstance(string, bytes):\n                string = string.decode(\"utf-8\")\n                json.loads(string)\n            elif isinstance(string, str):\n                json.loads(string)\n            else:\n                raise TypeError(\"Expecting <class 'str'> or <class 'bytes'>, but {} was passed\".format(type(string)))\n            return string\n\n        except ValueError:\n            return False", "category": "Python"}, {"instruction": "def require_prebuilt_dist(func):\n    \"\"\"Decorator for ToolchainCL methods. If present, the method will\n    automatically make sure a dist has been built before continuing\n    or, if no dists are present or can be obtained, will raise an\n    error.\n    \"\"\"\n", "input": "", "output": "\n    @wraps(func)\n    def wrapper_func(self, args):\n        ctx = self.ctx\n        ctx.set_archs(self._archs)\n        ctx.prepare_build_environment(user_sdk_dir=self.sdk_dir,\n                                      user_ndk_dir=self.ndk_dir,\n                                      user_android_api=self.android_api,\n                                      user_ndk_api=self.ndk_api)\n        dist = self._dist\n        if dist.needs_build:\n            if dist.folder_exists():  # possible if the dist is being replaced\n                dist.delete()\n            info_notify('No dist exists that meets your requirements, '\n                        'so one will be built.')\n            build_dist_from_args(ctx, dist, args)\n        func(self, args)\n    return wrapper_func", "category": "Python"}, {"instruction": "def set_install_dir(self, install_dir=None, version=None, verbose=False):\n        \"\"\"\n        Sets the path to the cassandra source directory for use by this node.\n        \"\"\"\n", "input": "", "output": "        if version is None:\n            self.__install_dir = install_dir\n            if install_dir is not None:\n                common.validate_install_dir(install_dir)\n        else:\n            self.__install_dir = self.node_setup(version, verbose=verbose)\n\n        self._cassandra_version = common.get_version_from_build(self.__install_dir, cassandra=True)\n\n        if self.get_base_cassandra_version() >= 4.0:\n            self.network_interfaces['thrift'] = None\n\n        self.import_config_files()\n        self.import_bin_files()\n        self.__conf_updated = False\n        return self", "category": "Python"}, {"instruction": "def get_print_rect(self, grid_rect):\n        \"\"\"Returns wx.Rect that is correctly positioned on the print canvas\"\"\"\n", "input": "", "output": "\n        grid = self.grid\n\n        rect_x = grid_rect.x - \\\n            grid.GetScrollPos(wx.HORIZONTAL) * grid.GetScrollLineX()\n        rect_y = grid_rect.y - \\\n            grid.GetScrollPos(wx.VERTICAL) * grid.GetScrollLineY()\n\n        return wx.Rect(rect_x, rect_y, grid_rect.width, grid_rect.height)", "category": "Python"}, {"instruction": "def get_intersectionsbysubsets(df,cols_fracby2vals,cols_subset,col_ids):\n    \"\"\"\n    cols_fracby:\n    cols_subset:\n    \"\"\"\n", "input": "", "output": "    for col_fracby in cols_fracby2vals:\n        val=cols_fracby2vals[col_fracby]\n        ids=df.loc[(df[col_fracby]==val),col_ids].dropna().unique()\n        for col_subset in cols_subset:\n            for subset in dropna(df[col_subset].unique()):\n                ids_subset=df.loc[(df[col_subset]==subset),col_ids].dropna().unique()\n                df.loc[(df[col_subset]==subset),f'P {col_fracby} {col_subset}']=len(set(ids_subset).intersection(ids))/len(ids_subset)\n    return df", "category": "Python"}, {"instruction": "def get_mac_address_table_input_request_type_get_interface_based_request_forwarding_interface_interface_name(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n", "input": "", "output": "        config = ET.Element(\"config\")\n        get_mac_address_table = ET.Element(\"get_mac_address_table\")\n        config = get_mac_address_table\n        input = ET.SubElement(get_mac_address_table, \"input\")\n        request_type = ET.SubElement(input, \"request-type\")\n        get_interface_based_request = ET.SubElement(request_type, \"get-interface-based-request\")\n        forwarding_interface = ET.SubElement(get_interface_based_request, \"forwarding-interface\")\n        interface_name = ET.SubElement(forwarding_interface, \"interface-name\")\n        interface_name.text = kwargs.pop('interface_name')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "category": "Python"}, {"instruction": "def expand_paths(path):\n    \"\"\"When given a path with brackets, expands it to return all permutations\n       of the path with expanded brackets, similar to ant.\n\n       >>> expand_paths('../{a,b}/{c,d}')\n       ['../a/c', '../a/d', '../b/c', '../b/d']\n       >>> expand_paths('../{a,b}/{a,b}.py')\n       ['../a/a.py', '../a/b.py', '../b/a.py', '../b/b.py']\n       >>> expand_paths('../{a,b,c}/{a,b,c}')\n       ['../a/a', '../a/b', '../a/c', '../b/a', '../b/b', '../b/c', '../c/a', '../c/b', '../c/c']\n       >>> expand_paths('test')\n       ['test']\n       >>> expand_paths('')\n    \"\"\"\n", "input": "", "output": "    pr = itertools.product\n    parts = MAGIC_BRACKETS.findall(path)\n\n    if not path:\n        return\n\n    if not parts:\n        return [path]\n\n    permutations = [[(p[0], i, 1) for i in p[1].split(',')] for p in parts]\n    return [_replace_all(path, i) for i in pr(*permutations)]", "category": "Python"}, {"instruction": "A node in the dynamic tree. The client does not interact with this directly.\n\n@prop {AABB} aabb Enlarged AABB\n@prop {integer} height 0: leaf, -1: free node", "input": "JavaScript", "output": "function TreeNode(id) {\n  this.id = id;\n  this.aabb = new AABB();\n  this.userData = null;\n  this.parent = null;\n  this.child1 = null;\n  this.child2 = null;\n  this.height = -1;\n\n  this.toString = function() {\n    return this.id + \": \" + this.userData;\n  }\n}", "category": "Python"}, {"instruction": "Reset the tracking by hiding the tooltip, the hover series state and the hover point", "input": "JavaScript", "output": "function resetTracker() {\r\n\t\t\tvar hoverSeries = chart.hoverSeries,\r\n\t\t\t\thoverPoint = chart.hoverPoint;\r\n\r\n\t\t\tif (hoverPoint) {\r\n\t\t\t\thoverPoint.onMouseOut();\r\n\t\t\t}\r\n\r\n\t\t\tif (hoverSeries) {\r\n\t\t\t\thoverSeries.onMouseOut();\r\n\t\t\t}\r\n\r\n\t\t\tif (tooltip) {\r\n\t\t\t\ttooltip.hide();\r\n\t\t\t}\r\n\r\n\t\t\thoverX = null;\r\n\t\t}", "category": "Python"}, {"instruction": "'{' '}'\n| '{' pair (ws pair)* '}'", "input": "JavaScript", "output": "function(){\n    var obj = new nodes.Object\n      , id, val, comma, hash;\n    this.expect('{');\n    this.skipWhitespace();\n\n    while (!this.accept('}')) {\n      if (this.accept('comment')\n        || this.accept('newline')) continue;\n\n      if (!comma) this.accept(',');\n      id = this.accept('ident') || this.accept('string');\n\n      if (!id) {\n        this.error('expected \"ident\" or \"string\", got {peek}');\n      }\n\n      hash = id.val.hash;\n\n      this.skipSpacesAndComments();\n      this.expect(':');\n\n      val = this.expression();\n\n      obj.setValue(hash, val);\n      obj.setKey(hash, id.val);\n\n      comma = this.accept(',');\n      this.skipWhitespace();\n    }\n\n    return obj;\n  }", "category": "Python"}, {"instruction": "Handler for `swipestart` event. Calculates entry points of the user's tap.\n\n@param {Object} event\n@return {Void}", "input": "JavaScript", "output": "function start(event) {\n      if (!disabled && !Glide.disabled) {\n        this.disable();\n\n        var swipe = this.touches(event);\n\n        swipeSin = null;\n        swipeStartX = toInt(swipe.pageX);\n        swipeStartY = toInt(swipe.pageY);\n\n        this.bindSwipeMove();\n        this.bindSwipeEnd();\n\n        Events.emit('swipe.start');\n      }\n    }", "category": "Python"}, {"instruction": "@ngdoc method\n@name bundler.default:default#htmlTags\n@methodOf bundler.default:default\n@function\n@description\nFunction called by view.js to build the view HTML\n\n\n@param {String} type Either start/js/css\n@param {Boolean} pack Pack with resolveAssetLink ?\n@returns {[String]} List of script tag strings", "input": "JavaScript", "output": "function htmlTags(type,pack) {\n    var dests;\n\n    // jshint validthis:true\n    if (type === 'start') {\n      return ['<script>' + this.module('start').map(function(value) { return value.content; }).join('\\n') + '</script>'];\n    }\n\n    if (pack) {\n      dests = { urls: {} };\n      // jshint validthis:true\n      dests.urls[type] = resolveAssetLink(this.client, type);\n      return [ htmlTag[type](dests) ];\n    } else {\n      // jshint validthis:true\n      var entries = this.entries(type);\n      dests = this.dests;\n      return entries.map(function(entry) {\n        return htmlTag[type](dests,entry);\n      });\n    }\n  }", "category": "Python"}, {"instruction": "rgb \u989c\u8272\u8f6c\u6362\u6210\u6570\u7ec4", "input": "JavaScript", "output": "function rgb2arr(str) {\n  var arr = [];\n  arr.push(parseInt(str.substr(1, 2), 16));\n  arr.push(parseInt(str.substr(3, 2), 16));\n  arr.push(parseInt(str.substr(5, 2), 16));\n  return arr;\n}", "category": "Python"}, {"instruction": "setup events to detect gestures on the document\nthis function is called when creating an new instance\n@private", "input": "JavaScript", "output": "function setup(opts) {\n  if (GestureDetector.READY) {\n    return;\n  }\n\n  // find what eventtypes we add listeners to\n  Event.determineEventTypes();\n\n  // Register all gestures inside GestureDetector.gestures\n  Utils.each(GestureDetector.gestures, function(gesture) {\n    Detection.register(gesture);\n  });\n\n  // Add touch events on the document\n  Event.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect, opts);\n  Event.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect, opts);\n\n  // GestureDetector is ready...!\n  GestureDetector.READY = true;\n}", "category": "Python"}, {"instruction": "A Value is a comma-delimited list of Expressions In a Rule, a Value represents everything after the `:`, and before the `;`.", "input": "JavaScript", "output": "function() {\n                var e, expressions = [];\n\n                e = $(this.expression);\n                while (e) {\n                    expressions.push(e);\n                    if (! $(',')) { break; }\n                    e = $(this.expression);\n                }\n\n                if (expressions.length > 1) {\n                    return new tree.Value(expressions.map(function(e) {\n                        return e.value[0];\n                    }));\n                } else if (expressions.length === 1) {\n                    return new tree.Value(expressions);\n                }\n            }", "category": "Python"}, {"instruction": "Creates a new extension installer dialog.\n@constructor\n@param {{install: function(url), cancel: function()}} installer The installer backend to use.", "input": "JavaScript", "output": "function InstallExtensionDialog(installer, _isUpdate) {\n        this._installer = installer;\n        this._state = STATE_CLOSED;\n        this._installResult = null;\n        this._isUpdate = _isUpdate;\n\n        // Timeout before we allow user to leave STATE_INSTALL_CANCELING without waiting for a resolution\n        // (per-instance so we can poke it for unit testing)\n        this._cancelTimeout = 10 * 1000;\n    }", "category": "Python"}, {"instruction": "Read all \"data-*\" attributes from a node", "input": "JavaScript", "output": "function attributeData(node) {\n    var store = {}\n    $.each(node.attributes || emptyArray, function(i, attr){\n      if (attr.name.indexOf('data-') == 0)\n        store[camelize(attr.name.replace('data-', ''))] =\n          $.zepto.deserializeValue(attr.value)\n    })\n    return store\n  }", "category": "Python"}, {"instruction": "Logs a message at a given level.\n\n@param {String} levelTag the tag associated with the level at which to log\nthe message.\n@param {String} message the message to log.\n@param {Number} bufferMaxLength the maximum size to which the message\nbuffer can grow.", "input": "JavaScript", "output": "function(levelTag, message, bufferMaxLength)\n  {\n    // add the log level tag (e.g. info, warn, etc.) to the front of the message\n    message = Util.format('%s: %s', levelTag, message);\n\n    // if the buffer is full, evict old messages\n    while (buffer.length >= bufferMaxLength)\n    {\n      buffer.shift();\n    }\n\n    // add the new message to the buffer\n    buffer.push(message);\n  }", "category": "Python"}, {"instruction": "----------------------------------------------------------------------------", "input": "JavaScript", "output": "function isSubquery(str, parenthesisLevel) {\n\treturn  parenthesisLevel - (str.replace(/\\(/g,'').length - str.replace(/\\)/g,'').length )\n}", "category": "Python"}, {"instruction": "Add new layers to both existing maps\n@param {Object} splitMaps\n@param {Object|Array<Object>} layers\n@returns {Array<Object>} new splitMaps", "input": "JavaScript", "output": "function addNewLayersToSplitMap(splitMaps, layers) {\n  const newLayers = Array.isArray(layers) ? layers : [layers];\n\n  if (!splitMaps || !splitMaps.length || !newLayers.length) {\n    return splitMaps;\n  }\n\n  // add new layer to both maps,\n  //  don't override, if layer.id is already in splitMaps.settings.layers\n  return splitMaps.map(settings => ({\n    ...settings,\n    layers: {\n      ...settings.layers,\n      ...newLayers.reduce(\n        (accu, newLayer) =>\n          newLayer.config.isVisible\n            ? {\n                ...accu,\n                [newLayer.id]: settings.layers[newLayer.id]\n                  ? settings.layers[newLayer.id]\n                  : generateLayerMetaForSplitViews(newLayer)\n              }\n            : accu,\n        {}\n      )\n    }\n  }));\n}", "category": "Python"}, {"instruction": "Define delegates for the given class for each property/method on the indicated prototype.", "input": "JavaScript", "output": "function defineDelegates(cls, prototype) {\n  const names = Object.getOwnPropertyNames(prototype);\n  names.forEach(name => {\n    const descriptor = Object.getOwnPropertyDescriptor(prototype, name);\n    if (!descriptor) {\n      return;\n    }\n    const delegate = createDelegate(name, descriptor);\n    if (delegate) {\n      Object.defineProperty(cls.prototype, name, delegate);\n    }\n  });\n}", "category": "Python"}, {"instruction": "Utility function that creates new folders\nbased off dir argument", "input": "JavaScript", "output": "function createDirectory(dir) {\n    if (!fs.existsSync(dir)) {\n        dryRun ? console.log(`...CREATE the '${dir}' folder.`) : fs.mkdirSync(dir);\n    }\n}", "category": "Python"}, {"instruction": "B.2.3.2.1 CreateHTML(string, tag, attribute, value)", "input": "JavaScript", "output": "function (string, tag, attribute, value) {\n  var S = String(defined(string));\n  var p1 = '<' + tag;\n  if (attribute !== '') p1 += ' ' + attribute + '=\"' + String(value).replace(quot, '&quot;') + '\"';\n  return p1 + '>' + S + '</' + tag + '>';\n}", "category": "Python"}, {"instruction": "Change current page", "input": "JavaScript", "output": "function changePage(pageNumber) {\n      var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (pageNumber > 0 && this.total > this.currentPerPage * (pageNumber - 1)) {\n        this.prevPage = this.currentPage;\n        this.currentPage = pageNumber;\n        if (emit) this.pageChanged();\n      }\n    }", "category": "Python"}, {"instruction": "Fetches the published versions of npm from the npm registry\n@return {Promise.<versions[]>} - Array of the available versions", "input": "JavaScript", "output": "function getAvailableNPMVersions () {\n  return new Promise((resolve, reject) => {\n    exec('npm view npm versions --json', (err, stdout) => {\n      if (err) {\n        let error = 'We could not show latest available versions. Try running this script again '\n        error += 'with the version you want to install (npm-windows-upgrade --npm-version 3.0.0)'\n        return reject(error)\n      }\n\n      resolve(JSON.parse(stdout))\n    })\n  })\n}", "category": "Python"}, {"instruction": "Repeats a string n times with given separator\n@param str string to repeat\n@param n number of times\n@param sep separator\n@returns {*}", "input": "JavaScript", "output": "function strRepeat(str, n, sep) {\n  if(!n) {\n    return str;\n  }\n  return str + sep + strRepeat(str, --n, sep);\n}", "category": "Python"}, {"instruction": "Private Static Methods", "input": "JavaScript", "output": "function(value)\n\t\t\t{\n\t\t\t\tswitch (typeof value)\n\t\t\t\t{\n\t\t\t\t\tcase \"number\":\n\t\t\t\t\tcase \"boolean\":\n\t\t\t\t\t\treturn value + \"\";\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\treturn \"\\\"\" + value + \"\\\"\";\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (value === undefined)\n\t\t\t\t\t\t\treturn \"undefined\";\n\t\t\t\t\t\tif (value === null)\n\t\t\t\t\t\t\treturn \"null\";\n\t\t\t\t\t\tvar hash = value[_HASH_KEY];\n\t\t\t\t\t\tif (!hash)\n\t\t\t\t\t\t\thash = value[_HASH_KEY] = \"#\" + (++_hashCount);\n\t\t\t\t\t\treturn hash;\n\t\t\t\t}\n\t\t\t}", "category": "Python"}, {"instruction": "if the user specifies include_docs=true, then we don't want to block the main cursor while we're fetching the doc", "input": "JavaScript", "output": "function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result);\n      if (opts.conflicts) {\n        var conflicts = pouchdbMerge.collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }", "category": "Python"}, {"instruction": "Get session from the store.\n@private", "input": "JavaScript", "output": "function getSession(sessions, sessionId) {\n  var sess = sessions[sessionId]\n\n  if (!sess) {\n    debug('no session in MemoryStore for %s',sessionId);\n    return;\n  }\n\n  // parse\n  sess = JSON.parse(sess)\n\n  var expires = typeof sess.cookie.expires === 'string' ?\n    new Date(sess.cookie.expires) :\n    sess.cookie.expires\n\n  // destroy expired session\n  if (expires && expires <= Date.now()) {\n    debug('Session %s is Expired in MemoryStore',sessionId);\n    delete sessions[sessionId];\n    return;\n  }\n\n  return sess\n}", "category": "Python"}, {"instruction": "jshint ;_; /* AFFIX CLASS DEFINITION\n======================", "input": "JavaScript", "output": "function (element, options) {\n    this.options = $.extend({}, $.fn.affix.defaults, options)\n    this.$window = $(window).on('scroll.affix.data-api', $.proxy(this.checkPosition, this))\n    this.$element = $(element)\n    this.checkPosition()\n  }", "category": "Python"}, {"instruction": "\u7f16\u8bd1\u666e\u901a\u8282\u70b9\n\n@param {ANode} aNode \u8282\u70b9\u5bf9\u8c61\n@param {CompileSourceBuffer} sourceBuffer \u7f16\u8bd1\u6e90\u7801\u7684\u4e2d\u95f4buffer\n@param {Component} owner \u6240\u5c5e\u7ec4\u4ef6\u5b9e\u4f8b\u73af\u5883\n@param {Object} extra \u7f16\u8bd1\u6240\u9700\u7684\u4e00\u4e9b\u989d\u5916\u4fe1\u606f", "input": "JavaScript", "output": "function (aNode, sourceBuffer, owner) {\n        elementSourceCompiler.tagStart(sourceBuffer, aNode);\n        elementSourceCompiler.inner(sourceBuffer, aNode, owner);\n        elementSourceCompiler.tagEnd(sourceBuffer, aNode);\n    }", "category": "Python"}, {"instruction": "Loads the given name (or [name, options] pair) from the given table object\nholding the available presets or plugins.\n\nReturns undefined if the preset or plugin is not available; passes through\nname unmodified if it (or the first element of the pair) is not a string.", "input": "JavaScript", "output": "function loadBuiltin(builtinTable, name) {\n  if (isArray(name) && typeof name[0] === \"string\") {\n    if (builtinTable.hasOwnProperty(name[0])) {\n      return [builtinTable[name[0]]].concat(name.slice(1));\n    }\n    return;\n  } else if (typeof name === \"string\") {\n    return builtinTable[name];\n  }\n  // Could be an actual preset/plugin module\n  return name;\n}", "category": "Python"}, {"instruction": "Main function to run the sandbox", "input": "JavaScript", "output": "function main() {\n    loadDependencies();\n    setInitialData();\n    domHelpers.initDomElements();\n\n    setDataInInputField();\n    setConfigInInputField();\n    setChartSelectorType();\n    setNewChart();\n    setHandlers();\n}", "category": "Python"}, {"instruction": "The following function does what document.importNode(node, true) would do for us here; however that method is broken in Safari/1.3, so we have to emulate it.", "input": "JavaScript", "output": "function xmlImportNode(doc, node) {\n  if (node.nodeType == DOM_TEXT_NODE) {\n    return domCreateTextNode(doc, node.nodeValue);\n\n  } else if (node.nodeType == DOM_CDATA_SECTION_NODE) {\n    return domCreateCDATASection(doc, node.nodeValue);\n\n  } else if (node.nodeType == DOM_ELEMENT_NODE) {\n    var newNode = domCreateElement(doc, node.nodeName);\n    for (var i = 0; i < node.attributes.length; ++i) {\n      var an = node.attributes[i];\n      var name = an.nodeName;\n      var value = an.nodeValue;\n      domSetAttribute(newNode, name, value);\n    }\n\n    for (var c = node.firstChild; c; c = c.nextSibling) {\n      var cn = arguments.callee(doc, c);\n      domAppendChild(newNode, cn);\n    }\n\n    return newNode;\n\n  } else {\n    return domCreateComment(doc, node.nodeName);\n  }\n}", "category": "Python"}, {"instruction": "List of client ids the user has visited", "input": "JavaScript", "output": "function (done) {\n      var index = 'users:' + user._id + ':clients'\n      Client.__client.zrevrange(index, 0, -1, function (err, ids) {\n        if (err) { return done(err) }\n        done(null, ids)\n      })\n    }", "category": "Python"}, {"instruction": "/* -----[ Tokenizer ]-----", "input": "JavaScript", "output": "function is_alphanumeric_char(ch) {\n        ch = ch.charCodeAt(0);\n        return (ch >= 48 && ch <= 57) ||\n                (ch >= 65 && ch <= 90) ||\n                (ch >= 97 && ch <= 122);\n}", "category": "Python"}, {"instruction": "Sets up the binding index before executing any `pureFunctionX` instructions.\n\nThe index must be restored after the pure function is executed\n\n{@link reserveSlots}", "input": "JavaScript", "output": "function moveBindingIndexToReservedSlot(offset) {\n    var currentSlot = viewData[BINDING_INDEX];\n    viewData[BINDING_INDEX] = tView.bindingStartIndex - offset;\n    return currentSlot;\n}", "category": "Python"}, {"instruction": "@classdesc\nWraps a jCal component, adding convenience methods to add, remove and\nupdate subcomponents and properties.\n\n@class\n@alias ICAL.Component\n@param {Array|String} jCal         Raw jCal component data OR name of new\ncomponent\n@param {ICAL.Component} parent     Parent component to associate", "input": "JavaScript", "output": "function Component(jCal, parent) {\n    if (typeof(jCal) === 'string') {\n      // jCal spec (name, properties, components)\n      jCal = [jCal, [], []];\n    }\n\n    // mostly for legacy reasons.\n    this.jCal = jCal;\n\n    this.parent = parent || null;\n  }", "category": "Python"}, {"instruction": "Map a function over a list", "input": "JavaScript", "output": "function map(fn, list) {\n\n   return list\n            ? cons(fn(head(list)), map(fn,tail(list)))\n            : emptyList\n            ;\n}", "category": "Python"}, {"instruction": "\u89e3\u6790\u65e5\u671f\n@param { object | string | date | string | number } date\n@returns times", "input": "JavaScript", "output": "function parseDate(value) {\n  let date = value;\n  if (!value) {\n    return new Date().getTime();\n  }\n  if (isObject(date)) {\n    date = date.value || date;\n  }\n  // array\n  if (isArray(date)) {\n    date = new Date(...date).getTime();\n  } else {\n    // string number  null \u3001''\u3001undefined\n    date = new Date(date).getTime();\n  }\n  if (date) {\n    return date;\n  }\n  console.warn('Invalid Date ', value);\n  return new Date().getTime();\n}", "category": "Python"}, {"instruction": "Output all assets using a generator\n\n@param {Generator} generator\n@param {Output} output\n@return {Promise<Output>}", "input": "JavaScript", "output": "function generateAssets(generator, output) {\n    var assets = output.getAssets();\n    var logger = output.getLogger();\n\n    // Is generator ignoring assets?\n    if (!generator.onAsset) {\n        return Promise(output);\n    }\n\n    return Promise.reduce(assets, function(out, assetFile) {\n        logger.debug.ln('copy asset \"' + assetFile + '\"');\n\n        return generator.onAsset(out, assetFile);\n    }, output);\n}", "category": "Python"}, {"instruction": "Serializes a capabilities object. This is defined as a standalone function\nso it may be type checked (where Capabilities[Symbols.serialize] has type\nchecking disabled since it is defined with [] access on a struct).\n\n@param {!Capabilities} caps The capabilities to serialize.\n@return {!Object<string, ?>} The JSON representation of this instance.\nNote, the returned object may contain nested promised values.", "input": "JavaScript", "output": "function serialize(caps) {\n  let ret = {};\n  for (let key of caps.keys()) {\n    let cap = caps.get(key);\n    if (cap !== undefined && cap !== null) {\n      ret[key] = cap;\n    }\n  }\n  return ret;\n}", "category": "Python"}, {"instruction": "Returns the default number of simultaneous requests.\n@export @public @method\n@name getDefaultSimultaneousRequests\n\n@returns {number} The default number of simultaneous requests.", "input": "JavaScript", "output": "function getDefaultSimultaneousRequests() {\n  const infoString = getBrowserInfo();\n  const info = infoString.split(' ');\n  const browserName = info[0];\n  const browserVersion = info[1];\n  const browserData = maxSimultaneousRequests[browserName];\n\n  if (!browserData) {\n    return maxSimultaneousRequests.default;\n  }\n\n  if (!browserData[browserVersion]) {\n    return browserData.default;\n  }\n\n  return browserData[browserVersion];\n}", "category": "Python"}, {"instruction": "Hooks into React's state management and applies the componentstate\nto GoldenLayout\n\n@private\n@returns {void}", "input": "JavaScript", "output": "function( nextProps, nextState ) {\n\t\tthis._container.setState( nextState );\n\t\tthis._originalComponentWillUpdate.call( this._reactComponent, nextProps, nextState );\n\t}", "category": "Python"}, {"instruction": "////////////////", "input": "JavaScript", "output": "function initialise() {\n\n\t    DOMReady(function () {\n\n\t    \tfor (var i = 0; i < 10; i++) {\n\t\t\t\tcreateCommandHtml(true);\n\t    \t}\n\n\t\t\t// var rellax = new Rellax('.rellax');\n\n\t    });\n\n\t    document.addEventListener('webkitAnimationEnd', onAnimationEnded);\n\n\t}", "category": "Python"}, {"instruction": "Return unique array.\n\n@param {Array} arr\n@return {Array}\n@api private", "input": "JavaScript", "output": "function unique(arr) {\n  var ret = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (~ret.indexOf(arr[i])) continue;\n    ret.push(arr[i]);\n  }\n\n  return ret;\n}", "category": "Python"}, {"instruction": "Special case getDefaultProps which should move into statics but requires\nautomatic merging.", "input": "JavaScript", "output": "function(Constructor, getDefaultProps) {\n      if (Constructor.getDefaultProps) {\n        Constructor.getDefaultProps = createMergedResultFunction(\n          Constructor.getDefaultProps,\n          getDefaultProps\n        );\n      } else {\n        Constructor.getDefaultProps = getDefaultProps;\n      }\n    }", "category": "Python"}, {"instruction": "SECTION: handle `change` event", "input": "JavaScript", "output": "function shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}", "category": "Python"}, {"instruction": "Returns all Documents that are 'open' in the UI somewhere (for now, this means open in an\ninline editor and/or a full-size editor). Only these Documents can be modified, and only\nthese Documents are synced with external changes on disk.\n@return {Array.<Document>}", "input": "JavaScript", "output": "function getAllOpenDocuments() {\n        var result = [];\n        var id;\n        for (id in _openDocuments) {\n            if (_openDocuments.hasOwnProperty(id)) {\n                result.push(_openDocuments[id]);\n            }\n        }\n        return result;\n    }", "category": "Python"}, {"instruction": "the function is used when no update function is given", "input": "JavaScript", "output": "function defaultUpdateFunction(instance, data) {\n    if (instance.isMatreshkaArray) {\n        instance.recreate(data);\n    } else if (instance.isMatreshkaObject) {\n        instance.setData(data, { replaceData: true });\n    } else {\n        // for other objects just extend them with given data\n        nofn.assign(instance, data);\n    }\n}", "category": "Python"}, {"instruction": "Use timeInterval to set the period between notches, in seconds,\nadding notches as the number of pixels per second increases.\n\nNote that if you override the default function, you'll almost\ncertainly want to override formatTimeCallback, primaryLabelInterval\nand/or secondaryLabelInterval so they all work together.\n\n@param: pxPerSec", "input": "JavaScript", "output": "function timeInterval(pxPerSec) {\n    var retval = 1;\n    if (pxPerSec >= 25 * 100) {\n        retval = 0.01;\n    } else if (pxPerSec >= 25 * 40) {\n        retval = 0.025;\n    } else if (pxPerSec >= 25 * 10) {\n        retval = 0.1;\n    } else if (pxPerSec >= 25 * 4) {\n        retval = 0.25;\n    } else if (pxPerSec >= 25) {\n        retval = 1;\n    } else if (pxPerSec * 5 >= 25) {\n        retval = 5;\n    } else if (pxPerSec * 15 >= 25) {\n        retval = 15;\n    } else {\n        retval = Math.ceil(0.5 / pxPerSec) * 60;\n    }\n    return retval;\n}", "category": "Python"}, {"instruction": "actually log the message", "input": "JavaScript", "output": "function logMessage(message)\n    {\n        // post the message\n        var msg = WebInspector.ConsoleMessage.create(\n            WebInspector.ConsoleMessage.MessageSource.Other,\n            messageLevel || WebInspector.ConsoleMessage.MessageLevel.Debug,\n            message);\n\n        self.console.addMessage(msg);\n        if (showConsole)\n            WebInspector.showConsole();\n    }", "category": "Python"}, {"instruction": "The loaded method is invoked after the initial batch of data arrives from the server.\nWhen this resolves, all data which existed prior to calling $asArray() is now cached\nlocally in the array.\n\nAs a shortcut is also possible to pass resolve/reject methods directly into this\nmethod just as they would be passed to .then()\n\n@param {Function} [resolve]\n@param {Function} [reject]\n@returns a promise", "input": "JavaScript", "output": "function(resolve, reject) {\n          var promise = this._sync.ready();\n          if( arguments.length ) {\n            // allow this method to be called just like .then\n            // by passing any arguments on to .then\n            promise = promise.then.call(promise, resolve, reject);\n          }\n          return promise;\n        }", "category": "Python"}, {"instruction": "The margins push the \"home\" region in from the sides by the specified amounts.\n@function\n@param {Object} margins - Properties (Numbers, in screen coordinates): left, top, right, bottom.", "input": "JavaScript", "output": "function(margins) {\n        $.console.assert($.type(margins) === 'object', '[Viewport.setMargins] margins must be an object');\n\n        this._margins = $.extend({\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        }, margins);\n\n        this._updateContainerInnerSize();\n        if (this.viewer) {\n            this.viewer.forceRedraw();\n        }\n    }", "category": "Python"}, {"instruction": "Build demo", "input": "JavaScript", "output": "function buildDemo(file) {\r\n    var doc = JSON.parse(fs.read(file));\r\n\r\n    if (doc.name) {\r\n      var destination = file.replace('docs/json', \"demo/_src/pages/components\").replace(\".json\", \".md\"),\r\n        template = {\r\n          template: \"component.html\",\r\n          title: doc.name,\r\n          demo: doc.demo,\r\n          asset_root: \"../\",\r\n          year: new Date().getFullYear()\r\n        },\r\n        header = \"\";\r\n\r\n      header += '\\n\\n #' + doc.name + ' Demo';\r\n      header += '\\n<p class=\"back_link\"><a href=\"https://formstone.it/components/' + doc.name.toLowerCase().replace(/ /g, \"\") + '\">View Documentation</a></p>';\r\n\r\n      fs.write(destination, JSON.stringify(template) + header);\r\n    }\r\n  }", "category": "Python"}, {"instruction": "returns false, true, or the squash value to indicate the \"default parameter url squash policy\".", "input": "JavaScript", "output": "function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }", "category": "Python"}, {"instruction": "PURE_IMPORTS_START _map PURE_IMPORTS_END", "input": "JavaScript", "output": "function pluck() {\n    var properties = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        properties[_i] = arguments[_i];\n    }\n    var length = properties.length;\n    if (length === 0) {\n        throw new Error('list of properties cannot be empty.');\n    }\n    return function (source) { return Object(_map__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(plucker(properties, length))(source); };\n}", "category": "Python"}, {"instruction": "settings: { zoomOnMouseWheel moveOnMouseMove moveOnMouseWheel } The value can be: true / false / 'shift' / 'ctrl' / 'alt'.", "input": "JavaScript", "output": "function isAvailableBehavior(behaviorToCheck, e, settings) {\n    var setting = settings[behaviorToCheck];\n    return !behaviorToCheck || (\n        setting && (!zrUtil.isString(setting) || e.event[setting + 'Key'])\n    );\n}", "category": "Python"}, {"instruction": "Find vertex by name", "input": "JavaScript", "output": "function findVertex(name) {\r\n\t\tvar objects = alasql.databases[alasql.useid].objects;\r\n\t\tfor (var k in objects) {\r\n\t\t\tif (objects[k].name === name) {\r\n\t\t\t\treturn objects[k];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn undefined;\r\n\t}", "category": "Python"}, {"instruction": "Disables text selection and dragging, with optional whitelist callbacks.\n@param {function(Event):boolean=} opt_allowSelectStart Unless this function\nis defined and returns true, the onselectionstart event will be\nsurpressed.\n@param {function(Event):boolean=} opt_allowDragStart Unless this function\nis defined and returns true, the ondragstart event will be surpressed.", "input": "JavaScript", "output": "function disableTextSelectAndDrag(opt_allowSelectStart, opt_allowDragStart) {\n  // Disable text selection.\n  document.onselectstart = function(e) {\n    if (!(opt_allowSelectStart && opt_allowSelectStart.call(this, e)))\n      e.preventDefault();\n  };\n\n  // Disable dragging.\n  document.ondragstart = function(e) {\n    if (!(opt_allowDragStart && opt_allowDragStart.call(this, e)))\n      e.preventDefault();\n  };\n}", "category": "Python"}, {"instruction": "TODO: not used here anymore and needs to be moved", "input": "JavaScript", "output": "function setProviderFromEndpoint (endpoint, context, cb) {\n    var oldProvider = web3.currentProvider\n\n    if (endpoint === 'ipc') {\n      web3.setProvider(new web3.providers.IpcProvider())\n    } else {\n      web3.setProvider(new web3.providers.HttpProvider(endpoint))\n    }\n    if (web3.isConnected()) {\n      executionContext = context\n      self._updateBlockGasLimit()\n      self.event.trigger('contextChanged', ['web3'])\n      self.event.trigger('web3EndpointChanged')\n      cb()\n    } else {\n      web3.setProvider(oldProvider)\n      var alertMsg = 'Not possible to connect to the Web3 provider. '\n      alertMsg += 'Make sure the provider is running and a connection is open (via IPC or RPC).'\n      cb(alertMsg)\n    }\n  }", "category": "Python"}, {"instruction": "Return the cadence of notches that get labels in the primary color.\nEG, return 2 if every 2nd notch should be labeled,\nreturn 10 if every 10th notch should be labeled, etc.\n\nNote that if you override the default function, you'll almost\ncertainly want to override formatTimeCallback, primaryLabelInterval\nand/or secondaryLabelInterval so they all work together.\n\n@param pxPerSec", "input": "JavaScript", "output": "function primaryLabelInterval(pxPerSec) {\n    var retval = 1;\n    if (pxPerSec >= 25 * 100) {\n        retval = 10;\n    } else if (pxPerSec >= 25 * 40) {\n        retval = 4;\n    } else if (pxPerSec >= 25 * 10) {\n        retval = 10;\n    } else if (pxPerSec >= 25 * 4) {\n        retval = 4;\n    } else if (pxPerSec >= 25) {\n        retval = 1;\n    } else if (pxPerSec * 5 >= 25) {\n        retval = 5;\n    } else if (pxPerSec * 15 >= 25) {\n        retval = 15;\n    } else {\n        retval = Math.ceil(0.5 / pxPerSec) * 60;\n    }\n    return retval;\n}", "category": "Python"}, {"instruction": "for comparing mods before unassignment", "input": "JavaScript", "output": "function compareArray(a1, a2) {\n    if (a1.length != a2.length) return false;\n    for (var i = 0; i < a1.length; i++) {\n        if (a1[i] !== a2[i]) return false;\n    }\n    return true;\n  }", "category": "Python"}, {"instruction": "\u5faa\u73af\u904d\u5386\u6570\u7ec4\u96c6\u5408\n\n@inner\n@param {Array} source \u6570\u7ec4\u6e90\n@param {function(Array,Number):boolean} iterator \u904d\u5386\u51fd\u6570", "input": "JavaScript", "output": "function each(source, iterator) {\n        if (source instanceof Array) {\n            for (var i = 0, len = source.length; i < len; i++) {\n                if (iterator(source[i], i) === false) {\n                    break;\n                }\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Create conversion event params to be sent to the logging endpoint\n@param  {Object} options                           Object containing values needed to build conversion event\n@param  {Object} options.attributes                Object representing user attributes and values which need to be recorded\n@param  {string} options.clientEngine              The client we are using: node or javascript\n@param  {string} options.clientVersion             The version of the client\n@param  {Object} options.configObj                 Object representing project configuration, including datafile information and mappings for quick lookup\n@param  {string} options.eventKey                  Event key representing the event which needs to be recorded\n@param  {Object} options.eventTags                 Object with event-specific tags\n@param  {Object} options.logger                    Logger object\n@param  {string} options.userId                    ID for user\n@return {Object}                                   Params to be used in conversion event logging endpoint call", "input": "JavaScript", "output": "function(options) {\n    var conversionEvent = {\n      httpVerb: HTTP_VERB,\n    };\n\n    var commonParams = getCommonEventParams(options);\n    conversionEvent.url = ENDPOINT;\n\n    var snapshot = getVisitorSnapshot(options.configObj,\n                                            options.eventKey,\n                                            options.eventTags,\n                                            options.logger);\n\n    commonParams.visitors[0].snapshots = [snapshot];\n    conversionEvent.params = commonParams;\n\n    return conversionEvent;\n  }", "category": "Python"}, {"instruction": "Functions from lodash 4.0.0-pre \nThe base implementation of `_.pick` without support for individual\nproperty names.\n\n@private\n@param {Object} object The source object.\n@param {string[]} props The property names to pick.\n@returns {Object} Returns the new object.", "input": "JavaScript", "output": "function basePick(object, props) {\n  object = Object(object);\n\n  const { length } = props;\n  const result = {};\n  let index = -1;\n\n  while (++index < length) {\n    const key = props[index];\n    if (key in object) {\n      result[key] = object[key];\n    }\n  }\n\n  return result;\n}", "category": "Python"}, {"instruction": "Constructs a rotation gesture recognizer.\n@alias RotationRecognizer\n@constructor\n@augments GestureRecognizer\n@classdesc A concrete gesture recognizer subclass that looks for two finger rotation gestures.\n@param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.\n@param {Function} callback An optional function to call when this gesture is recognized. If non-null, the\nfunction is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,\ne.g., <code>gestureCallback(recognizer)</code>.\n@throws {ArgumentError} If the specified target is null or undefined.", "input": "JavaScript", "output": "function (target, callback) {\n            GestureRecognizer.call(this, target, callback);\n\n            // Intentionally not documented.\n            this._rotation = 0;\n\n            // Intentionally not documented.\n            this._offsetRotation = 0;\n\n            // Intentionally not documented.\n            this.referenceAngle = 0;\n\n            // Intentionally not documented.\n            this.interpretThreshold = 20;\n\n            // Intentionally not documented.\n            this.weight = 0.4;\n\n            // Intentionally not documented.\n            this.rotationTouches = [];\n        }", "category": "Python"}, {"instruction": "/* Ensure a date is within any min/max bounds.", "input": "JavaScript", "output": "function(inst, date) {\n\t\tvar minDate = this._getMinMaxDate(inst, \"min\"),\n\t\t\tmaxDate = this._getMinMaxDate(inst, \"max\"),\n\t\t\tnewDate = (minDate && date < minDate ? minDate : date);\n\t\treturn (maxDate && newDate > maxDate ? maxDate : newDate);\n\t}", "category": "Python"}, {"instruction": "Checks if there are internal rules files that has to be loaded\n@returns {Promise} The returned promise resolves with an argument showing\nwhether internal rules can be loaded or not", "input": "JavaScript", "output": "function () {\n\t\t\t\tvar that = this;\n\n\t\t\t\tvar oInternalRulesPromise = new Promise(function (resolve) {\n\n\t\t\t\t\tif (that.bCanLoadInternalRules !== null) {\n\t\t\t\t\t\tresolve(that.bCanLoadInternalRules);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\n\t\t\t\t\tjQuery.ajax({\n\t\t\t\t\t\ttype: \"HEAD\",\n\t\t\t\t\t\turl: sInternalPingFilePath,\n\t\t\t\t\t\tsuccess: function () {\n\t\t\t\t\t\t\tthat.bCanLoadInternalRules = true;\n\t\t\t\t\t\t\tresolve(that.bCanLoadInternalRules);\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: function() {\n\t\t\t\t\t\t\tthat.bCanLoadInternalRules = false;\n\t\t\t\t\t\t\tresolve(that.bCanLoadInternalRules);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\treturn oInternalRulesPromise;\n\t\t\t}", "category": "Python"}, {"instruction": "Subclass of `glob.GlobSync`\n@param {string}     pattern      Pattern to be matched.\n@param {Object}     options      `options` for `glob`\n@param {function()} shouldIgnore Method to check whether a directory should be ignored.\n@constructor", "input": "JavaScript", "output": "function GlobSync(pattern, options, shouldIgnore) {\n\n    /**\n     * We don't put this thing to argument `options` to avoid\n     * further problems, such as `options` validation.\n     *\n     * Use `Symbol` as much as possible to avoid confliction.\n     */\n    this[IGNORE] = shouldIgnore;\n\n    Sync.call(this, pattern, options);\n}", "category": "Python"}, {"instruction": "return the distance between this vector and the passed one\n@name distance\n@memberOf me.Vector3d\n@function\n@param {me.Vector2d|me.Vector3d} v\n@return {Number}", "input": "JavaScript", "output": "function (v) {\n            var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - (v.z || 0);\n            return Math.sqrt(dx * dx + dy * dy + dz * dz);\n        }", "category": "Python"}, {"instruction": "Returns whether or not comments are inside a node type or not.\n@param {ASTNode} parent The Comment parent node.\n@param {string} nodeType The parent type to check against.\n@returns {boolean} True if the comment is inside nodeType.", "input": "JavaScript", "output": "function isParentNodeType(parent, nodeType) {\n            return parent.type === nodeType ||\n                (parent.body && parent.body.type === nodeType) ||\n                (parent.consequent && parent.consequent.type === nodeType);\n        }", "category": "Python"}, {"instruction": "Convert a raw string to an array of big-endian words\nCharacters >255 have their high-byte silently ignored.", "input": "JavaScript", "output": "function rstr2binb(input) {\n    var i, l = input.length * 8,\n      output = Array(input.length >> 2),\n      lo = output.length;\n    for (i = 0; i < lo; i += 1) {\n      output[i] = 0;\n    }\n    for (i = 0; i < l; i += 8) {\n      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);\n    }\n    return output;\n  }", "category": "Python"}, {"instruction": "Traverse an object or array, and return a clone with all ISO strings parsed\ninto Date objects.\n\n@param {Object} obj\n@return {Object}", "input": "JavaScript", "output": "function traverse (input, strict) {\n  if (strict === undefined) strict = true;\n\n  if (is.object(input)) return object(input, strict);\n  if (is.array(input)) return array(input, strict);\n  return input;\n}", "category": "Python"}, {"instruction": "not save if out of bounds", "input": "JavaScript", "output": "function (start, end) {\n    var total = 0;\n\n    start = start || 0;\n    end = end || this.binCount;\n\n    for (var i = start; i < end; i++) {\n      total += this.frequencyByteData[i];\n    }\n\n    return total / (end - start);\n  }", "category": "Python"}, {"instruction": "Gathers angular-wrapped versions of each element\n@param elements\n@returns {{}}", "input": "JavaScript", "output": "function getAngularElements (elements) {\n    var obj = {};\n    for (var key in elements) {\n      if (elements.hasOwnProperty(key)) obj[ key ] = angular.element(elements[ key ]);\n    }\n    return obj;\n  }", "category": "Python"}, {"instruction": "Seeds either the static or version controlled seeders, controlled by\nthe passed mode.", "input": "JavaScript", "output": "function (mode, scope, callback) {\n    var executeSeed = load('seed');\n    if (scope) {\n      this.internals.migrationMode = scope;\n      this.internals.matching = scope;\n    }\n\n    this.internals.mode = mode || 'vc';\n    return Promise.fromCallback(\n      function (callback) {\n        executeSeed(this.internals, this.config, callback);\n      }.bind(this)\n    ).asCallback(callback);\n  }", "category": "Python"}, {"instruction": "readable event readable - some data is now available event data - switch to flowing mode - feeds chunks to handler event end - no more data event close - optional, indicates upstream close event error - duh", "input": "JavaScript", "output": "function(size) {\n    var buffers;\n    // read min(buffer, size || infinity)\n    if (size) {\n      buffers = [];\n      while (size && this.buffers.length && !this.buffers[0].eod) {\n        var first = this.buffers[0];\n        var buffer = first.read(size);\n        size -= buffer.length;\n        buffers.push(buffer);\n        if (first.eod && first.full) {\n          this.buffers.shift();\n        }\n      }\n      return Buffer.concat(buffers);\n    }\n\n    buffers = this.buffers.map(buf => buf.toBuffer())\n      .filter(Boolean);\n    this.buffers = [];\n    return Buffer.concat(buffers);\n  }", "category": "Python"}, {"instruction": "/*\tEvents\n==================================================", "input": "JavaScript", "output": "function(e) {\n\t\tthis.youtube_loaded = true;\n\t\tthis._el.content_item = document.getElementById(this._el.content_item.id);\n\t\tthis.onMediaLoaded();\n\n\t}", "category": "Python"}, {"instruction": "Like _getNextNode, but for DOM implementations with no\nfirstElementChild/nextElementSibling functionality...", "input": "JavaScript", "output": "function(node, ignoreSelfAndKids) {\n    function nextSiblingEl(n) {\n      do {\n        n = n.nextSibling;\n      } while (n && n.nodeType !== n.ELEMENT_NODE);\n      return n;\n    }\n    // First check for kids if those aren't being ignored\n    if (!ignoreSelfAndKids && node.children[0]) {\n      return node.children[0];\n    }\n    // Then for siblings...\n    var next = nextSiblingEl(node);\n    if (next) {\n      return next;\n    }\n    // And finally, move up the parent chain *and* find a sibling\n    // (because this is depth-first traversal, we will have already\n    // seen the parent nodes themselves).\n    do {\n      node = node.parentNode;\n      if (node)\n        next = nextSiblingEl(node);\n    } while (node && !next);\n    return node && next;\n  }", "category": "Python"}, {"instruction": "Fetch the model from the server. If the server's representation of the\nmodel differs from its current attributes, they will be overriden,\ntriggering a <code>\"change\"</code> event.\n@param {Object} fetchOptions Optional options to set 'keys',\n'include' and 'includeACL' option.\n@param {AuthOptions} options\n@return {Promise} A promise that is fulfilled when the fetch\ncompletes.", "input": "JavaScript", "output": "function(fetchOptions = {}, options) {\n        var self = this;\n        var request = _request(\n          'classes',\n          this.className,\n          this.id,\n          'GET',\n          transformFetchOptions(fetchOptions),\n          options\n        );\n        return request.then(function(response) {\n          const fetchedAttrs = self.parse(response);\n          if (!fetchOptions.keys) self._cleanupUnsetKeys(fetchedAttrs);\n          self._finishFetch(fetchedAttrs, true);\n          return self;\n        });\n      }", "category": "Python"}, {"instruction": "A BufferGeometry where a 'prefab' geometry is repeated a number of times.\n\n@param {Geometry|BufferGeometry} prefab The Geometry instance to repeat.\n@param {Number} count The number of times to repeat the geometry.\n@constructor", "input": "JavaScript", "output": "function PrefabBufferGeometry(prefab, count) {\n  three.BufferGeometry.call(this);\n\n  /**\n   * A reference to the prefab geometry used to create this instance.\n   * @type {Geometry|BufferGeometry}\n   */\n  this.prefabGeometry = prefab;\n  this.isPrefabBufferGeometry = prefab.isBufferGeometry;\n\n  /**\n   * Number of prefabs.\n   * @type {Number}\n   */\n  this.prefabCount = count;\n\n  /**\n   * Number of vertices of the prefab.\n   * @type {Number}\n   */\n  if (this.isPrefabBufferGeometry) {\n    this.prefabVertexCount = prefab.attributes.position.count;\n  } else {\n    this.prefabVertexCount = prefab.vertices.length;\n  }\n\n  this.bufferIndices();\n  this.bufferPositions();\n}", "category": "Python"}, {"instruction": "------------------------------ GOOGLE MAP /*\ncustom map with google api\ncheck out the link below for more information about api usage\nhttps://developers.google.com/maps/documentation/javascript/examples/marker-simple", "input": "JavaScript", "output": "function initializeMap() {\r\n\t\t\tif($('.map').length) {\r\n\t\t\t\tvar mapCanvas = $('#map-canvas');\r\n\t\t\t\tvar myLatlng = new google.maps.LatLng(mapCanvas.data(\"latitude\"),mapCanvas.data(\"longitude\"));\r\n\t\t\t\tvar mapOptions = {\r\n\t\t\t\t\tzoom: mapCanvas.data(\"zoom\"),\r\n\t\t\t\t\tcenter: myLatlng\r\n\t\t\t\t}\r\n\t\t\t\tvar map = new google.maps.Map(document.getElementById('map-canvas'), mapOptions);\r\n\t\t\t\t\r\n\t\t\t\tvar marker = new google.maps.Marker({\r\n\t\t\t\t  position: myLatlng,\r\n\t\t\t\t  map: map\r\n\t\t  \t});\r\n\t\t\t}\r\n\t\t  \r\n\t\t}", "category": "Python"}, {"instruction": "ensure that control and library are loaded", "input": "JavaScript", "output": "function getObjectFallback(oClassObject) {\n\t\t\t\t// some modules might not return a class definition, so we fallback to the global\n\t\t\t\t// this is against the AMD definition, but is required for backward compatibility\n\t\t\t\tif (!oClassObject) {\n\t\t\t\t\tLog.error(\"Control '\" + sClassName + \"' did not return a class definition from sap.ui.define.\", \"\", \"XMLTemplateProcessor\");\n\t\t\t\t\toClassObject = ObjectPath.get(sClassName);\n\t\t\t\t}\n\t\t\t\tif (!oClassObject) {\n\t\t\t\t\tLog.error(\"Can't find object class '\" + sClassName + \"' for XML-view\", \"\", \"XMLTemplateProcessor\");\n\t\t\t\t}\n\t\t\t\treturn oClassObject;\n\t\t\t}", "category": "Python"}, {"instruction": "Checks a given node against matching selectors and returns\nselector index (or 0 if none matched).\n\nThis function takes into account the ngProjectAs attribute: if present its value will be compared\nto the raw (un-parsed) CSS selector instead of using standard selector matching logic.", "input": "JavaScript", "output": "function matchingSelectorIndex(tNode, selectors, textSelectors) {\n    var ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n    for (var i = 0; i < selectors.length; i++) {\n        // if a node has the ngProjectAs attribute match it against unparsed selector\n        // match a node against a parsed selector only if ngProjectAs attribute is not present\n        if (ngProjectAsAttrVal === textSelectors[i] ||\n            ngProjectAsAttrVal === null && isNodeMatchingSelectorList(tNode, selectors[i])) {\n            return i + 1; // first matching selector \"captures\" a given node\n        }\n    }\n    return 0;\n}", "category": "Python"}, {"instruction": "The base implementation of `assignValue` and `assignMergeValue` without\nvalue checks.\n\n@private\n@param {Object} object The object to modify.\n@param {string} key The key of the property to assign.\n@param {*} value The value to assign.", "input": "JavaScript", "output": "function baseAssignValue(object, key, value) {\n  if (key == '__proto__') {\n    Object.defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    })\n  } else {\n    object[key] = value\n  }\n}", "category": "Python"}, {"instruction": "This method is like `_.set` except that accepts `updater` to produce the\nvalue to set. Use `_.updateWith` to customize `path` creation. The `updater`\nis invoked with one argument: (value).\n\n**Note:** This method mutates `object`.\n\n@static\n@memberOf _\n@since 4.6.0\n@category Object\n@param {Object} object The object to modify.\n@param {Array|string} path The path of the property to set.\n@param {Function} updater The function to produce the updated value.\n@returns {Object} Returns `object`.\n@example\n\nvar object = { 'a': [{ 'b': { 'c': 3 } }] };\n\n_.update(object, 'a[0].b.c', function(n) { return n * n; });\nconsole.log(object.a[0].b.c);\n// => 9\n\n_.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\nconsole.log(object.x[0].y.z);\n// => 0", "input": "JavaScript", "output": "function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }", "category": "Python"}, {"instruction": "Create a new UndoManager with an optional maximum history size.", "input": "JavaScript", "output": "function UndoManager (maxItems) {\n    this.maxItems  = maxItems || 50;\n    this.state = NORMAL_STATE;\n    this.dontCompose = false;\n    this.undoStack = [];\n    this.redoStack = [];\n  }", "category": "Python"}, {"instruction": "When using multiple axes, adjust the number of ticks to match the highest\nnumber of ticks in that group", "input": "JavaScript", "output": "function adjustTickAmount() {\r\n\r\n\t\t\tif (maxTicks && !isDatetimeAxis && !categories && !isLinked) { // only apply to linear scale\r\n\t\t\t\tvar oldTickAmount = tickAmount,\r\n\t\t\t\t\tcalculatedTickAmount = tickPositions.length;\r\n\r\n\t\t\t\t// set the axis-level tickAmount to use below\r\n\t\t\t\ttickAmount = maxTicks[xOrY];\r\n\r\n\t\t\t\tif (calculatedTickAmount < tickAmount) {\r\n\t\t\t\t\twhile (tickPositions.length < tickAmount) {\r\n\t\t\t\t\t\ttickPositions.push(correctFloat(\r\n\t\t\t\t\t\t\ttickPositions[tickPositions.length - 1] + tickInterval\r\n\t\t\t\t\t\t));\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttransA *= (calculatedTickAmount - 1) / (tickAmount - 1);\r\n\t\t\t\t\tmax = tickPositions[tickPositions.length - 1];\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif (defined(oldTickAmount) && tickAmount !== oldTickAmount) {\r\n\t\t\t\t\taxis.isDirty = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}", "category": "Python"}, {"instruction": "Convert real value to percent\n\n@param value {Number} X in real\n@param no_min {boolean=} don't use min value\n@returns {Number} X in percent", "input": "JavaScript", "output": "function (value, no_min) {\n            var diapason = this.options.max - this.options.min,\n                one_percent = diapason / 100,\n                val, percent;\n\n            if (!diapason) {\n                this.no_diapason = true;\n                return 0;\n            }\n\n            if (no_min) {\n                val = value;\n            } else {\n                val = value - this.options.min;\n            }\n\n            percent = val / one_percent;\n\n            return this.toFixed(percent);\n        }", "category": "Python"}, {"instruction": "/*\nThis function calculates the absolute 'left' value for a html node", "input": "JavaScript", "output": "function calculateOffsetLeft(obj)\n{\n\tvar curleft = 0;\n\tif (obj.offsetParent) {\n\t\tcurleft = obj.offsetLeft\n\t\twhile (obj = obj.offsetParent) \n\t\t\tcurleft += obj.offsetLeft;\n\t} else if (obj.x)\n\t\tcurleft += obj.x;\n\treturn curleft;\n}", "category": "Python"}, {"instruction": "Transforms the searchable templates by removing the `searchable` prefix.\n\nThis makes them usable in the `SearchBox` component.\n\n@param {object} templates The widget templates\n@returns {object} the formatted templates", "input": "JavaScript", "output": "function transformTemplates(templates) {\n  const allTemplates = {\n    ...templates,\n    submit: templates.searchableSubmit,\n    reset: templates.searchableReset,\n    loadingIndicator: templates.searchableLoadingIndicator,\n  };\n\n  const {\n    searchableReset,\n    searchableSubmit,\n    searchableLoadingIndicator,\n    ...transformedTemplates\n  } = allTemplates;\n\n  return transformedTemplates;\n}", "category": "Python"}, {"instruction": "Mini-implementation of stream.PassThrough We are far from having need for the full implementation, and we can make assumptions like \"many writes, then only one final read\" and we can ignore encoding specifics", "input": "JavaScript", "output": "function PassThrough() {\n  return {\n    buf: '',\n\n    write: function(b) {\n      this.buf += b;\n    },\n\n    end: function(b) {\n      this.buf += b;\n    },\n\n    read: function() {\n      return this.buf;\n    }\n  };\n}", "category": "Python"}, {"instruction": "Print the names and majors of students in a sample spreadsheet:\nhttps://docs.google.com/spreadsheets/d/1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms/edit", "input": "JavaScript", "output": "function listMajors(auth) {\n  const sheets = google.sheets('v4');\n  sheets.spreadsheets.values.get(\n    {\n      auth: auth,\n      spreadsheetId: '1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms',\n      range: 'Class Data!A2:E',\n    },\n    (err, res) => {\n      if (err) {\n        console.error('The API returned an error.');\n        throw err;\n      }\n      const rows = res.data.values;\n      if (rows.length === 0) {\n        console.log('No data found.');\n      } else {\n        console.log('Name, Major:');\n        for (const row of rows) {\n          // Print columns A and E, which correspond to indices 0 and 4.\n          console.log(`${row[0]}, ${row[4]}`);\n        }\n      }\n    }\n  );\n}", "category": "Python"}, {"instruction": "The relative require() itself.", "input": "JavaScript", "output": "function localRequire(path) {\n    var resolved = localRequire.resolve(path);\n    return require(resolved, parent, path);\n  }", "category": "Python"}, {"instruction": "-----------------------------------------------------------------------------", "input": "JavaScript", "output": "function getIdlType(type) {\n    var result\n\n\n    if (-1 == NativeTypes.indexOf(type.name)) {\n        result = \"<a href='javascript:showInterface(\\\"\" + type.name + \"\\\"); void(0);'>\" + type.name + \"</a>\"\n    }\n    else {\n        result = type.name\n    }\n\n    for (var i=0; i<type.rank; i++) {\n        result += \"[]\"\n    }\n\n    return \"<span class='type'>\" + result + \"</span>\"\n}", "category": "Python"}, {"instruction": "convert a Backbone model to JSON", "input": "JavaScript", "output": "function serialize(model) {\n    var data = model.toJSON();\n    Object.keys(data).forEach(function serializeRecur(key) {\n        var value = data[key];\n        // if any value can be serialized toJSON() then do it\n        if (value && value.toJSON) {\n            data[key] = data[key].toJSON();\n        }\n    });\n    return data;\n}", "category": "Python"}, {"instruction": "We set our dependencies as externals on our app bundler when developing (isDevelopment ? dependencies : []).forEach(function (dep) { appBundler.external(dep); }); The rebundle process", "input": "JavaScript", "output": "function () {\n\t\tvar start = Date.now();\n\t\tgutil.log('Building APP bundle');\n\t\tappBundler.bundle()\n\t\t\t.on('error', gutil.log)\n\t\t\t.pipe(source('main.js'))\n\t\t\t.pipe(gulpif(!isDevelopment, streamify(uglify())))\n\t\t\t.pipe(gulp.dest(configs.folders[options.environment]))\n\t\t\t.pipe(notify(function () {\n\t\t\t\tgutil.log('APP bundle built in ' + (Date.now() - start) + 'ms');\n\t\t\t}))\n\t\t\t.pipe(connect.reload());\n\t}", "category": "Python"}, {"instruction": "Creates an object with the agregations bindings of a UI5 control.\n@param {Object} control\n@returns {Object}\n@private", "input": "JavaScript", "output": "function (control) {\n\t\t\t\tvar aggregations = control.getMetadata().getAllAggregations();\n\t\t\t\tvar aggregationsBindingData = Object.create(null);\n\n\t\t\t\tfor (var key in aggregations) {\n\t\t\t\t\tif (aggregations.hasOwnProperty(key) && control.getBinding(key)) {\n\t\t\t\t\t\taggregationsBindingData[key] = Object.create(null);\n\t\t\t\t\t\taggregationsBindingData[key].model = this._getModelFromContext(control, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn aggregationsBindingData;\n\t\t\t}", "category": "Python"}, {"instruction": "`URLSearchParams.prototype.forEach` method", "input": "JavaScript", "output": "function forEach(callback /* , thisArg */) {\n    var entries = getInternalParamsState(this).entries;\n    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);\n    var i = 0;\n    var entry;\n    while (i < entries.length) {\n      entry = entries[i++];\n      boundFunction(entry.value, entry.key, this);\n    }\n  }", "category": "Python"}, {"instruction": "Extend properties to target if not exist.\n@param  {Object} target\n@param  {Object} source\n@return {Object}\n@memberOf clay.core.util", "input": "JavaScript", "output": "function (target, source) {\n        if (source) {\n            for (var propName in source) {\n                if (target[propName] === undefined) {\n                    target[propName] = source[propName];\n                }\n            }\n        }\n        return target;\n    }", "category": "Python"}, {"instruction": "Main generate function", "input": "JavaScript", "output": "function ngSwaggerGen(options) {\n  if (typeof options.swagger != 'string') {\n    console.error(\"Swagger file not specified in the 'swagger' option\");\n    process.exit(1);\n  }\n\n  var globalTunnel = require('global-tunnel-ng');\n  globalTunnel.initialize();\n  \n  $RefParser.bundle(options.swagger, { dereference: { circular: false } }).then(\n    data => {\n      doGenerate(data, options);\n    },\n    err => {\n      console.error(\n        `Error reading swagger location ${options.swagger}: ${err}`\n      );\n    }\n  ).catch(function (error) {\n    console.error(`Error: ${error}`);\n  });\n}", "category": "Python"}, {"instruction": "Pick the object\n@param  {number} x Mouse position x\n@param  {number} y Mouse position y\n@return {clay.Node}", "input": "JavaScript", "output": "function(x, y) {\n        var renderer = this.renderer;\n\n        var ratio = this.downSampleRatio;\n        x = Math.ceil(ratio * x);\n        y = Math.ceil(ratio * (this.height - y));\n\n        this._frameBuffer.bind(renderer);\n        var pixel = new Uint8Array(4);\n        var _gl = renderer.gl;\n        // TODO out of bounds ?\n        // preserveDrawingBuffer ?\n        _gl.readPixels(x, y, 1, 1, _gl.RGBA, _gl.UNSIGNED_BYTE, pixel);\n        this._frameBuffer.unbind(renderer);\n        // Skip interpolated pixel because of anti alias\n        if (pixel[3] === 255) {\n            var id = unpackID(pixel[0], pixel[1], pixel[2]);\n            if (id) {\n                var el = this._lookupTable[id - this.lookupOffset];\n                return el;\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Parses a JSON string into a Javascript object.\n@function\n@param {String} string\n@returns {Object}", "input": "JavaScript", "output": "function(string) {\n            if (window.JSON && window.JSON.parse) {\n                $.parseJSON = window.JSON.parse;\n            } else {\n                // Should only be used by IE8 in non standards mode\n                $.parseJSON = function(string) {\n                    /*jshint evil:true*/\n                    //eslint-disable-next-line no-eval\n                    return eval('(' + string + ')');\n                };\n            }\n            return $.parseJSON(string);\n        }", "category": "Python"}, {"instruction": "Get Custom Fingerprint.  Take a string of datapoints and eturn a 32-bit integer representing the browsers fingerprint.", "input": "JavaScript", "output": "function() {\n      var bar = '|';\n      var key = \"\";\n      for (var i = 0; i < arguments.length; i++) {\n        key += arguments[i] + bar;\n      }\n      return murmurhash3_32_gc(key, 256);\n    }", "category": "Python"}, {"instruction": "Returns the number of fixed columns depending on the parameter <code>bConsiderVisibility</code>.\n\n@param {sap.ui.table.Table} oTable Instance of the table.\n@param {boolean} bConsiderVisibility If <code>false</code> the result of the <code>getComputedFixedColumnCount</code> function of the\ntable is returned. If <code>true</code> the visibility is included into the determination of the\ncount.\n@returns {int} Returns the number of fixed columns depending on the parameter <code>bConsiderVisibility</code>.", "input": "JavaScript", "output": "function(oTable, bConsiderVisibility) {\n\t\t\tvar iFixed = oTable.getComputedFixedColumnCount();\n\n\t\t\tif (!bConsiderVisibility) {\n\t\t\t\treturn iFixed;\n\t\t\t}\n\n\t\t\tif (iFixed <= 0 || oTable._bIgnoreFixedColumnCount) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar aColumns = oTable.getColumns();\n\t\t\tvar iVisibleFixedColumnCount = 0;\n\t\t\tiFixed = Math.min(iFixed, aColumns.length);\n\n\t\t\tfor (var i = 0; i < iFixed; i++) {\n\t\t\t\tif (aColumns[i].shouldRender()) {\n\t\t\t\t\tiVisibleFixedColumnCount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn iVisibleFixedColumnCount;\n\t\t}", "category": "Python"}, {"instruction": "createDispatchers\n\nCreate action dispatcher wrappers with bound playerID and credentials", "input": "JavaScript", "output": "function createDispatchers(\n  storeActionType,\n  innerActionNames,\n  store,\n  playerID,\n  credentials,\n  multiplayer\n) {\n  return innerActionNames.reduce((dispatchers, name) => {\n    dispatchers[name] = function(...args) {\n      let assumedPlayerID = playerID;\n\n      // In singleplayer mode, if the client does not have a playerID\n      // associated with it, we attach the currentPlayer as playerID.\n      if (!multiplayer && (playerID === null || playerID === undefined)) {\n        const state = store.getState();\n        assumedPlayerID = state.ctx.currentPlayer;\n      }\n\n      store.dispatch(\n        ActionCreators[storeActionType](\n          name,\n          args,\n          assumedPlayerID,\n          credentials\n        )\n      );\n    };\n    return dispatchers;\n  }, {});\n}", "category": "Python"}, {"instruction": "columns is a required parameter.", "input": "JavaScript", "output": "function getIdColumns(idColumnNames, columns) {\n  if (!defined(idColumnNames)) {\n    return [];\n  }\n  return idColumnNames.map(name => getColumnWithNameIdOrIndex(name, columns));\n}", "category": "Python"}, {"instruction": "Get the actual indent of node\n@param {ASTNode|Token} node Node to examine\n@param {boolean} [byLastLine=false] get indent of node's last line\n@returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\ncontains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\n`badChar` is the amount of the other indentation character.", "input": "JavaScript", "output": "function getNodeIndent(node, byLastLine) {\n            const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n            const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n            const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n            const spaces = indentChars.filter(char => char === \" \").length;\n            const tabs = indentChars.filter(char => char === \"\\t\").length;\n\n            return {\n                space: spaces,\n                tab: tabs,\n                goodChar: indentType === \"space\" ? spaces : tabs,\n                badChar: indentType === \"space\" ? tabs : spaces\n            };\n        }", "category": "Python"}, {"instruction": "PATHS", "input": "JavaScript", "output": "function (ps) {\n        var p = paths.ps = paths.ps || {};\n        if (p[ps]) {\n            p[ps].sleep = 100;\n        } else {\n            p[ps] = {\n                sleep: 100\n            };\n        }\n        setTimeout(function () {\n            for (var key in p) if (p[has](key) && key != ps) {\n                p[key].sleep--;\n                !p[key].sleep && delete p[key];\n            }\n        });\n        return p[ps];\n    }", "category": "Python"}, {"instruction": "$NON-NLS-0$", "input": "JavaScript", "output": "function(item, index, ar){\t\t\t\r\n\t\t\tvar option = document.createElement(\"option\"); //$NON-NLS-0$\r\n\t\t\toption.value = item.value;\r\n\t\t\toption.appendChild(document.createTextNode(typeof item.label === \"string\" ? item.label : item.value)); //$NON-NLS-0$\r\n\t\t\tif( item.selected  ){\r\n\t\t\t\toption.selected = 'selected'; //$NON-NLS-0$\r\n\t\t\t}\r\n\t\t\tthis.select.appendChild(option);\r\n\t\t}", "category": "Python"}, {"instruction": "Transform start/end and route into series of lines\n@param {g.point} sourcePoint start point\n@param {g.point} targetPoint end point\n@param {g.point[]} route optional list of route\n@return {g.line[]} [description]", "input": "JavaScript", "output": "function createLines(sourcePoint, targetPoint, route) {\n        // make a flattened array of all points\n        var points = [].concat(sourcePoint, route, targetPoint);\n        return points.reduce(function(resultLines, point, idx) {\n            // if there is a next point, make a line with it\n            var nextPoint = points[idx + 1];\n            if (nextPoint != null) {\n                resultLines[idx] = g.line(point, nextPoint);\n            }\n            return resultLines;\n        }, []);\n    }", "category": "Python"}, {"instruction": "Modified Richards and Whitby-Stevens precedence climbing method.", "input": "JavaScript", "output": "function makeTree(left, ops, rights, minPrecedence = 0) {\n  while (ops.length > 0 && precedence[ops[0]] >= minPrecedence) {\n    let op = ops.shift();\n    let right = rights.shift();\n    while (ops.length > 0 && (precedence[ops[0]] > precedence[op] ||\n        associativity[ops[0]] === 'R' && precedence[ops[0]] === precedence[op])) {\n      right = makeTree(right, ops, rights, precedence[ops[0]]);\n    }\n    left = new BinaryExpression(left, op, right);\n  }\n  return left;\n}", "category": "Python"}, {"instruction": "Pick the next auth stage\n\n@private\n@return {string?} login type\n@throws {NoAuthFlowFoundError} If no suitable authentication flow can be found", "input": "JavaScript", "output": "function() {\n        const flow = this._chooseFlow();\n        console.log(\"Active flow => %s\", JSON.stringify(flow));\n        const nextStage = this._firstUncompletedStage(flow);\n        console.log(\"Next stage: %s\", nextStage);\n        return nextStage;\n    }", "category": "Python"}, {"instruction": "/* Given a comma-separated string of layer names, returns the layer objects corresponding to them.", "input": "JavaScript", "output": "function findLayers(layers, names) {\n  if (!defined(names)) {\n    // If a list of layers is not specified, we're using all layers.\n    return layers;\n  }\n  return names.split(\",\").map(function(id) {\n    return findLayer(layers, id);\n  });\n}", "category": "Python"}, {"instruction": "creates token objects and pushes them to a list", "input": "JavaScript", "output": "function tokener(value, type) {\n\t\tsession.tokens.push({\n\t\t\tvalue: value,\n\t\t\ttype:  type || value,\n\t\t\tstart: null,\n\t\t\tend:   null\n\t\t});\n\t}", "category": "Python"}, {"instruction": "Set the position of the visual highlighter.\n@param {string} elementId - The id of the DOM element that need to be highlighted\n@returns {exports}", "input": "JavaScript", "output": "function (elementId) {\n\t\t\t\tvar highlighter;\n\t\t\t\tvar targetDomElement;\n\t\t\t\tvar targetRect;\n\n\t\t\t\tif (_highLighter === null && !document.getElementById(\"ui5-highlighter\")) {\n\t\t\t\t\t_createHighLighter();\n\t\t\t\t} else {\n\t\t\t\t\t_showHighLighter();\n\t\t\t\t}\n\n\t\t\t\thighlighter = _highLighter.firstElementChild;\n\t\t\t\ttargetDomElement = document.getElementById(elementId);\n\n\t\t\t\tif (targetDomElement) {\n\t\t\t\t\ttargetRect = targetDomElement.getBoundingClientRect();\n\n\t\t\t\t\thighlighter.style.top = targetRect.top + \"px\";\n\t\t\t\t\thighlighter.style.left = targetRect.left + \"px\";\n\t\t\t\t\thighlighter.style.height = targetRect.height + \"px\";\n\t\t\t\t\thighlighter.style.width = targetRect.width + \"px\";\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t}", "category": "Python"}, {"instruction": "return a getUserMedia Constraints", "input": "JavaScript", "output": "function getConstraintObj(deviceId, facingMode, width, height){\n      var obj = { audio: false, video: {} };\n      obj.video.deviceId = {exact: deviceId};\n      if(facingMode) {\n        obj.video.facingMode = {exact: facingMode};\n      }\n      if(width) {\n        obj.video.width = {exact: width};\n      }\n      if(height) {\n        obj.video.height = {exact: height};\n      }\n      return obj;\n    }", "category": "Python"}, {"instruction": "Updating the marks for editor content", "input": "JavaScript", "output": "function clearMarks(editor, arr, classes) {\n    for (var i = 0; i < arr.length; ++i) {\n      var mark = arr[i];\n      if (mark instanceof CodeMirror.TextMarker) {\n        mark.clear();\n      } else {\n        editor.removeLineClass(mark, \"background\", classes.chunk);\n        editor.removeLineClass(mark, \"background\", classes.start);\n        editor.removeLineClass(mark, \"background\", classes.end);\n      }\n    }\n    arr.length = 0;\n  }", "category": "Python"}, {"instruction": "Subtracts matrix b from matrix a\n\n@param {mat3} out the receiving matrix\n@param {mat3} a the first operand\n@param {mat3} b the second operand\n@returns {mat3} out", "input": "JavaScript", "output": "function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}", "category": "Python"}, {"instruction": "/* search in a sorted array.\n\nreturns the index of the last element for which func returns\ngreater than zero, or array.length if no such element exists.", "input": "JavaScript", "output": "function binarySearch(array, func) {\n    // min is inclusive, max exclusive.\n    let min = 0,\n        max = array.length;\n\n    while (min < max) {\n        const mid = (min + max) >> 1;\n        const res = func(array[mid]);\n        if (res > 0) {\n            // the element at 'mid' is too big; set it as the new max.\n            max = mid;\n        } else {\n            // the element at 'mid' is too small. 'min' is inclusive, so +1.\n            min = mid + 1;\n        }\n    }\n    // presumably, min==max now.\n    return min;\n}", "category": "Python"}, {"instruction": "Creates a JavaScript UTC Date corresponding to the given JavaScript Date.\n@param {Date} oDate JavaScript date object. Time related information is cut.\n@returns {Date} JavaScript date created from the date object, but this time considered as UTC date information.", "input": "JavaScript", "output": "function createUTCDate(oDate) {\n\t\t\tvar oUTCDate = new Date(Date.UTC(0, 0, 1));\n\n\t\t\toUTCDate.setUTCFullYear(oDate.getFullYear(), oDate.getMonth(), oDate.getDate());\n\n\t\t\treturn oUTCDate;\n\t\t}", "category": "Python"}, {"instruction": "Process File\nTakes a reference to a single file, sends it to the relevant handler to be loaded and returns an object in the\nimportData format: {data: {}, images: []}\nThe data key contains JSON representing any data that should be imported\nThe image key contains references to images that will be stored (and where they will be stored)\n@param {File} file\n@returns {Promise(ImportData)}", "input": "JavaScript", "output": "function (file, ext) {\n        var fileHandler = _.find(this.handlers, function (handler) {\n            return _.includes(handler.extensions, ext);\n        });\n\n        return fileHandler.loadFile([_.pick(file, 'name', 'path')]).then(function (loadedData) {\n            // normalize the returned data\n            var importData = {};\n            importData[fileHandler.type] = loadedData;\n            return importData;\n        });\n    }", "category": "Python"}, {"instruction": "Register an alias name associated with a font-icon library style ;", "input": "JavaScript", "output": "function fontSet(alias, className) {\n    config.fontSets.push({\n      alias: alias,\n      fontSet: className || alias\n    });\n    return this;\n  }", "category": "Python"}, {"instruction": "handle debouncing a function for better performance on scroll", "input": "JavaScript", "output": "function debounce(fn, delay) {\n        return function () {\n          var self = this, args = arguments;\n          clearTimeout(timer);\n          console.log('debounce()');\n          timer = setTimeout(function () {\n            fn.apply(self, args);\n          }, delay);\n        };\n      }", "category": "Python"}, {"instruction": "checks the given module's functions code for invalidContent returns an array which contains the functions with invalid content", "input": "JavaScript", "output": "function(oController, viewId, aInvalidContent, fnProcessInvalidFunction) {\n\t\t\t\tvar _aInvalidControllerFunctions = [];\n\t\t\t\tObject.keys(oController).forEach(function(sProtoKey) {\n\t\t\t\t\tvar sFnContent = oController[sProtoKey].toString().replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n\n\t\t\t\t\taInvalidContent.forEach(function(sInvalidContent) {\n\t\t\t\t\t\tif (sFnContent.indexOf(sInvalidContent) > 0) {\n\t\t\t\t\t\t\tfnProcessInvalidFunction(oController.getMetadata().getName(), sProtoKey, sInvalidContent, viewId);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\n\t\t\t\t});\n\t\t\t\treturn _aInvalidControllerFunctions;\n\t\t\t}", "category": "Python"}, {"instruction": "Private: Format a date according to the `weekday`, `day`, `month`, and `year` attribute values.  This doesn't use Intl.DateTimeFormat to avoid creating text in the user's language when the majority of the surrounding text is in English. There's currently no way to separate the language from the format in Intl.  el - The local-time element to format.  Returns a date String or null if no date formats are provided.", "input": "JavaScript", "output": "function formatDate(el: Element, date: Date) {\n  // map attribute values to strftime\n  const props = {\n    weekday: {\n      short: '%a',\n      long: '%A'\n    },\n    day: {\n      numeric: '%e',\n      '2-digit': '%d'\n    },\n    month: {\n      short: '%b',\n      long: '%B'\n    },\n    year: {\n      numeric: '%Y',\n      '2-digit': '%y'\n    }\n  }\n\n  // build a strftime format string\n  let format = isDayFirst() ? 'weekday day month year' : 'weekday month day, year'\n  for (const prop in props) {\n    const value = props[prop][el.getAttribute(prop)]\n    format = format.replace(prop, value || '')\n  }\n\n  // clean up year separator comma\n  format = format.replace(/(\\s,)|(,\\s$)/, '')\n\n  // squeeze spaces from final string\n  return strftime(date, format)\n    .replace(/\\s+/, ' ')\n    .trim()\n}", "category": "Python"}, {"instruction": "Stringify the given `arr`.\n\n@param {Array} arr\n@param {String} prefix\n@return {String}\n@api private", "input": "JavaScript", "output": "function stringifyArray(arr, prefix) {\n  var ret = [];\n  if (!prefix) throw new TypeError('stringify expects an object');\n  for (var i = 0; i < arr.length; i++) {\n    ret.push(stringify(arr[i], prefix + '[]'));\n  }\n  return ret.join('&');\n}", "category": "Python"}, {"instruction": "Create an interpolation binding with 4 expressions.", "input": "JavaScript", "output": "function interpolation4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n    var different = bindingUpdated4(v0, v1, v2, v3);\n    return different ?\n        prefix + stringify$1(v0) + i0 + stringify$1(v1) + i1 + stringify$1(v2) + i2 + stringify$1(v3) +\n            suffix :\n        NO_CHANGE;\n}", "category": "Python"}, {"instruction": "}}}", "input": "JavaScript", "output": "function parseKey(e) //{{{\n      {\n        if (e.ctrlKey || e.metaKey) {\n          return true;\n        }\n        shift_down = e.shiftKey ? true : false;\n        var nudge = shift_down ? 10 : 1;\n\n        switch (e.keyCode) {\n        case 37:\n          doNudge(e, -nudge, 0);\n          break;\n        case 39:\n          doNudge(e, nudge, 0);\n          break;\n        case 38:\n          doNudge(e, 0, -nudge);\n          break;\n        case 40:\n          doNudge(e, 0, nudge);\n          break;\n        case 27:\n          if (options.allowSelect) Selection.release();\n          break;\n        case 9:\n          return true;\n        }\n\n        return false;\n      }", "category": "Python"}, {"instruction": "Running", "input": "JavaScript", "output": "function run() {\n\treturn Promise.resolve()\n\t\t.then(loadEnvFile)\n\t\t.then(loadConfigFile)\n\t\t.then(mergeOptions)\n\t\t.then(startBroker)\n\t\t.catch(err => {\n\t\t\tlogger.error(err);\n\t\t\tprocess.exit(1);\n\t\t});\n}", "category": "Python"}, {"instruction": "Returns number representation of object's complexity\n@method complexity\n@return {Number} complexity", "input": "JavaScript", "output": "function() {\n      return this.paths.reduce(function(total, path) {\n        return total + ((path && path.complexity) ? path.complexity() : 0);\n      }, 0);\n    }", "category": "Python"}, {"instruction": "Removes project from shared projects.\nAlso removes all references from the other table.", "input": "JavaScript", "output": "function removeProject(project) {\n\t\treturn sharedProject.findOne({'location': project}).exec()\n\t\t.then(function(doc) {\n\t\t\tif (doc.users.length > 0) {\n\t\t\t\treturn userProjectsCollection.removeProjectReferences(doc.users, project).exec();\n\t\t\t}\n\t\t})\n\t\t.then(function() {\n\t\t\treturn sharedProject.remove({location: project}).exec();\n\t\t});\n\t}", "category": "Python"}, {"instruction": "`URLSearchParams.prototype.has` method https://url.spec.whatwg.org/#dom-urlsearchparams-has", "input": "JavaScript", "output": "function has(name) {\n    validateArgumentsLength(arguments.length, 1);\n    var entries = getInternalParamsState(this).entries;\n    var key = name + '';\n    var i = 0;\n    while (i < entries.length) if (entries[i++].key === key) return true;\n    return false;\n  }", "category": "Python"}, {"instruction": "todos unmarked count", "input": "JavaScript", "output": "function setBadge(todos) {\n  if (chrome.browserAction) {\n    const count = todos.filter(todo => !todo.marked).length;\n    chrome.browserAction.setBadgeText({ text: count > 0 ? count.toString() : '' });\n  }\n}", "category": "Python"}, {"instruction": "Initialize the generator\n\n@param {Output}\n@return {Output}", "input": "JavaScript", "output": "function onInit(output) {\n    return Promise(output)\n    .then(prepareI18n)\n    .then(prepareResources)\n    .then(copyPluginAssets);\n}", "category": "Python"}, {"instruction": "extended", "input": "JavaScript", "output": "function( meta ){\n\n            this.els.fps.innerHTML = meta.fps.toFixed(2);\n            this.els.ipf.innerHTML = meta.ipf;\n        }", "category": "Python"}, {"instruction": "Get the parent ES6 component node from the current scope\n\n@returns {ASTNode} component node, null if we are not in a component", "input": "JavaScript", "output": "function () {\n      let scope = context.getScope();\n      while (scope && scope.type !== 'class') {\n        scope = scope.upper;\n      }\n      const node = scope && scope.block;\n      if (!node || !utils.isES6Component(node)) {\n        return null;\n      }\n      return node;\n    }", "category": "Python"}, {"instruction": "Indicates if the current application is a variant of an existing one\n\n@param {sap.ui.core.Control} oControl - SAPUI5 control\n@returns {boolean} true if it's an application variant\n@public\n@function\n@name sap.ui.fl.Utils.isApplicationVariant", "input": "JavaScript", "output": "function (oControl) {\n\t\t\tvar sFlexReference = Utils.getComponentClassName(oControl);\n\t\t\tvar oAppComponent = Utils.getAppComponentForControl(oControl);\n\t\t\tvar sComponentName = Utils.getComponentName(oAppComponent);\n\t\t\treturn sFlexReference !== sComponentName;\n\t\t}", "category": "Python"}, {"instruction": "Returns value of the header with the specified <code>sHeaderName</code> from\nthe specified <code>sHeaders</code> section of MIME part.\n\n@param {string} sHeaders\nSection of MIME part representing HTTP headers\n@param {string} sHeaderName\nName of HTTP header in lower case\n@returns {string} The HTTP header value", "input": "JavaScript", "output": "function getHeaderValue(sHeaders, sHeaderName) {\n\t\tvar i,\n\t\t\taHeaderParts,\n\t\t\taHeaders = sHeaders.split(\"\\r\\n\");\n\n\t\tfor (i = 0; i < aHeaders.length; i += 1) {\n\t\t\taHeaderParts = aHeaders[i].split(\":\");\n\n\t\t\tif (aHeaderParts[0].toLowerCase().trim() === sHeaderName) {\n\t\t\t\treturn aHeaderParts[1].trim();\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "returns the key used for calculating signature", "input": "JavaScript", "output": "function getSigningKey(date, region, secretKey) {\n  if (!isObject(date)) {\n    throw new TypeError('date should be of type \"object\"')\n  }\n  if (!isString(region)) {\n    throw new TypeError('region should be of type \"string\"')\n  }\n  if (!isString(secretKey)) {\n    throw new TypeError('secretKey should be of type \"string\"')\n  }\n  var dateLine = makeDateShort(date),\n    hmac1 = Crypto.createHmac('sha256', 'AWS4' + secretKey).update(dateLine).digest(),\n    hmac2 = Crypto.createHmac('sha256', hmac1).update(region).digest(),\n    hmac3 = Crypto.createHmac('sha256', hmac2).update('s3').digest()\n  return Crypto.createHmac('sha256', hmac3).update('aws4_request').digest()\n}", "category": "Python"}, {"instruction": "Extracts metadata from metadata map by scope key\n@param {object} mMetadata metadata map received from loader\n@param {string} sScopeKey scope name to be extracted\n@private", "input": "JavaScript", "output": "function getScopeBasedDesignTime(mMetadata, sScopeKey) {\n\t\tvar mResult = mMetadata;\n\n\t\tif (\"default\" in mMetadata) {\n\t\t\tmResult = merge(\n\t\t\t\t{},\n\t\t\t\tmMetadata.default,\n\t\t\t\tsScopeKey !== \"default\" && mMetadata[sScopeKey] || null\n\t\t\t);\n\t\t}\n\n\t\treturn mResult;\n\t}", "category": "Python"}, {"instruction": "Traverses all the children of the specified node\n\n@param {Node} node", "input": "JavaScript", "output": "function (node) {\n    this.level++;\n    for (var i = 0, count = node.childNodes.length; i < count; i++) {\n      this._visit(node.childNodes[i]);\n    }\n    this.level--;\n  }", "category": "Python"}, {"instruction": "Create a new has one instance.", "input": "JavaScript", "output": "function HasOne(model, related, foreignKey, localKey) {\n        var _this = _super.call(this, model) /* istanbul ignore next */ || this;\n        _this.related = _this.model.relation(related);\n        _this.foreignKey = foreignKey;\n        _this.localKey = localKey;\n        return _this;\n    }", "category": "Python"}, {"instruction": "Built {type.Componen} from gcc user data\n@param userData {type.Component} GCC data from client\n@returns {type.Component} GCC encoded client user data", "input": "JavaScript", "output": "function writeConferenceCreateRequest (userData) {\n    var userDataStream = new type.Stream(userData.size());\n    userData.write(userDataStream);\n    \n    return new type.Component([\n\t    per.writeChoice(0), per.writeObjectIdentifier(t124_02_98_oid),\n\t    per.writeLength(userData.size() + 14), per.writeChoice(0),\n\t    per.writeSelection(0x08), per.writeNumericString(\"1\", 1), per.writePadding(1),\n\t    per.writeNumberOfSet(1), per.writeChoice(0xc0),\n\t    per.writeOctetStream(new Buffer(h221_cs_key), 4), per.writeOctetStream(userDataStream.getValue())\n    ]);\n}", "category": "Python"}, {"instruction": "Sticky Sidebar Plugin Defintion.\n@param {Object|String} - config", "input": "JavaScript", "output": "function _jQueryPlugin(config){\n      return this.each(function(){\n        var $this = plugin(this),\n          data = plugin(this).data(DATA_NAMESPACE);\n\n          if( ! data ){\n            data = new StickySidebar(this, typeof config == 'object' && config);\n            $this.data(DATA_NAMESPACE, data);\n          }\n\n          if( 'string' === typeof config){\n            if (data[config] === undefined && ['destroy', 'updateSticky'].indexOf(config) === -1)\n              throw new Error('No method named \"'+ config +'\"');\n\n            data[config]();\n          }\n      });\n    }", "category": "Python"}, {"instruction": "Fix Mode7 comments when they are bad", "input": "JavaScript", "output": "function (text) {\n        if (text.charAt(0) === '[') {\n            switch (text.charAt(text.length - 1)) {\n                case ']':\n                    return text;\n                case '\"':\n                    return text + ']';\n                case ',':\n                    return text.substring(0, text.length - 1) + '\"]';\n                default:\n                    return _formatmode7(text.substring(0, text.length - 1));\n            }\n        } else {\n            return text;\n        }\n    }", "category": "Python"}, {"instruction": "Determines the nearest ancestor of a node that is scrollable.\n\nNOTE: This can be expensive if used repeatedly or on a node nested deeply.\n\n@param {?DOMNode} node Node from which to start searching.\n@return {?DOMWindow|DOMElement} Scroll parent of the supplied node.", "input": "JavaScript", "output": "function(node) {\n    if (!node) {\n      return null;\n    }\n    var ownerDocument = node.ownerDocument;\n    while (node && node !== ownerDocument.body) {\n      if (_isNodeScrollable(node, 'overflow') ||\n          _isNodeScrollable(node, 'overflowY') ||\n          _isNodeScrollable(node, 'overflowX')) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n    return ownerDocument.defaultView || ownerDocument.parentWindow;\n  }", "category": "Python"}, {"instruction": "Doc version select", "input": "JavaScript", "output": "function initVersionSelect () {\n    // version select\n    var versionSelect = document.querySelector('.version-select')\n    versionSelect && versionSelect.addEventListener('change', function (e) {\n      var version = e.target.value\n      var section = window.location.pathname.match(/\\/v\\d\\/(\\w+?)\\//)[1]\n      if (version === 'SELF') return\n      window.location.assign(\n        'http://' +\n        version +\n        (version && '.') +\n        'vuejs.org/' + section + '/'\n      )\n    })\n  }", "category": "Python"}, {"instruction": "Returns search options for sifter (the system\nfor scoring and sorting results).\n\n@see https://github.com/brianreavis/sifter.js\n@return {object}", "input": "JavaScript", "output": "function() {\n\t\t\tvar settings = this.settings;\n\t\t\tvar sort = settings.sortField;\n\t\t\tif (typeof sort === 'string') {\n\t\t\t\tsort = [{field: sort}];\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tfields      : settings.searchField,\n\t\t\t\tconjunction : settings.searchConjunction,\n\t\t\t\tsort        : sort\n\t\t\t};\n\t\t}", "category": "Python"}, {"instruction": "The non-streamed request handler is only for the cases where neither the request or response can have streams. In this case, a req.stream indicates that the request is fragmented across multiple frames.", "input": "JavaScript", "output": "function RequestCallbackHandler(callback, thisp) {\n    var self = this;\n    self.callback = callback;\n    self.thisp = thisp || self;\n}", "category": "Python"}, {"instruction": "\"A collapsed block prop is either a collapsed line break that is not an extraneous line break, or an Element that is an inline node and whose children are all either invisible or collapsed block props and that has at least one child that is a collapsed block prop.\"", "input": "JavaScript", "output": "function isCollapsedBlockProp(node) {\n\tif (isCollapsedLineBreak(node)\n\t&& !isExtraneousLineBreak(node)) {\n\t\treturn true;\n\t}\n\n\tif (!isInlineNode(node)\n\t|| node.nodeType != Node.ELEMENT_NODE) {\n\t\treturn false;\n\t}\n\n\tvar hasCollapsedBlockPropChild = false;\n\tfor (var i = 0; i < node.childNodes.length; i++) {\n\t\tif (!isInvisible(node.childNodes[i])\n\t\t&& !isCollapsedBlockProp(node.childNodes[i])) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isCollapsedBlockProp(node.childNodes[i])) {\n\t\t\thasCollapsedBlockPropChild = true;\n\t\t}\n\t}\n\n\treturn hasCollapsedBlockPropChild;\n}", "category": "Python"}, {"instruction": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n**************************************************************************** /* global Reflect, Promise", "input": "JavaScript", "output": "function(d, b) {\n    extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return extendStatics(d, b);\n}", "category": "Python"}, {"instruction": "finds the given at declaration value\n@param  {Array[Object]} decls the decls from an element\n@param  {String}        the prop\n@return {Any}           the found value", "input": "JavaScript", "output": "function findAtDecl (decls, prop) {\n  const foundDecls = decls.filter((decl) => {\n    return (isPlainObject(decl) &&\n          Object.keys(decl).length > 0 &&\n          Object.keys(decl)[0] === `@${prop}`) || decl === `@${prop}`\n  })\n\n  if (foundDecls.length === 0) { return }\n\n  const decl = foundDecls[0]\n\n  return isPlainObject(decl) ? Object.values(decl)[0] : true\n}", "category": "Python"}, {"instruction": "*\n@method insert(str, [index] = length)\n@returns String\n@short Adds `str` at [index]. Allows negative values.\n\n@example\n\n'dopamine'.insert('e', 3)       -> dopeamine\n'spelling eror'.insert('r', -3) -> spelling error\n\n@param {string} str\n@param {number} [index]\n\n*", "input": "JavaScript", "output": "function(str, substr, index) {\n    index = isUndefined(index) ? str.length : index;\n    return str.slice(0, index) + substr + str.slice(index);\n  }", "category": "Python"}, {"instruction": "Replace table.\n@param {jQuery} $table - table jQuery element\n@param {Array.<Array.<object>>} tableData - table data\n@returns {jQuery}\n@ignore", "input": "JavaScript", "output": "function replaceTable($table, tableData) {\n  const cellIndexData = tableDataHandler.createCellIndexData(tableData);\n  const renderData = tableDataHandler.createRenderData(tableData, cellIndexData);\n  const $newTable = $(createTableHtml(renderData));\n\n  $table.replaceWith($newTable);\n\n  return $newTable;\n}", "category": "Python"}, {"instruction": "Find dimension by property name\n\n@param {string}\nsName Property name\n@returns {sap.ui.model.analytics.odata4analytics.Dimension} The dimension object to\nwhich the given property name is related, because the property\nholds the dimension key, its text, or is an attribute of this\ndimension. If no such dimension exists, null is returned.\n@public\n@function\n@name sap.ui.model.analytics.odata4analytics.QueryResult#findDimensionByPropertyName", "input": "JavaScript", "output": "function(sName) {\n\t\t\tif (this._oDimensionSet[sName]) { // the easy case\n\t\t\t\treturn this._oDimensionSet[sName];\n\t\t\t}\n\n\t\t\tfor ( var sDimensionName in this._oDimensionSet) {\n\t\t\t\tvar oDimension = this._oDimensionSet[sDimensionName];\n\t\t\t\tvar oTextProperty = oDimension.getTextProperty();\n\t\t\t\tif (oTextProperty && oTextProperty.name == sName) {\n\t\t\t\t\treturn oDimension;\n\t\t\t\t}\n\t\t\t\tif (oDimension.findAttributeByName(sName)) {\n\t\t\t\t\treturn oDimension;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}", "category": "Python"}, {"instruction": "Decortaor for `sync` component helper.\n@param   {string}          path - Path in store\n@returns {VueDecorator}         - Vue decortaor to be used in cue class component.", "input": "JavaScript", "output": "function Sync(path) {\n  if (typeof path !== 'string' || arguments.length > 1) { throw new Error('Property decorators can be used for single property access') }\n  return createDecorator((options, key) => {\n    if (!options.computed) options.computed = {}\n    options.computed[key] = sync(path)\n  })\n}", "category": "Python"}, {"instruction": "Orders the data by date for consumption on the chart tooltip\n@param  {areaChartData} data    Chart data\n@return {Object[]}               Chart data ordered by date\n@private", "input": "JavaScript", "output": "function getDataByDate(data) {\n            return d3Collection.nest()\n                .key(getDate)\n                .entries(\n                    data.sort((a, b) => a.date - b.date)\n                )\n                .map(d => {\n                    return assign({}, d, {\n                        date: new Date(d.key)\n                    });\n                });\n\n            // let b =  d3Collection.nest()\n            //                     .key(getDate).sortKeys(d3Array.ascending)\n            //                     .entries(data);\n        }", "category": "Python"}, {"instruction": "Service resolution helper.\n\nIt is used both by client and server channels, to respectively decode errors\nand responses, or requests.", "input": "JavaScript", "output": "function Adapter(clientSvc, serverSvc, hash, isRemote) {\n  this._clientSvc = clientSvc;\n  this._serverSvc = serverSvc;\n  this._hash = hash; // Convenience to access it when creating handshakes.\n  this._isRemote = !!isRemote;\n  this._readers = createReaders(clientSvc, serverSvc);\n}", "category": "Python"}, {"instruction": "Find the symbol name of an AssignmentNode. Recurses into the chain of\nobjects to the root object.\n@param {AssignmentNode} node\n@return {string | null} Returns the name when found, else returns null.", "input": "JavaScript", "output": "function findSymbolName (node) {\n  const math = getMath()\n  let n = node\n\n  while (n) {\n    if (math.isSymbolNode(n)) {\n      return n.name\n    }\n    n = n.object\n  }\n\n  return null\n}", "category": "Python"}, {"instruction": "routeChat handler. Receives a stream of message/location pairs, and responds\nwith a stream of all previous messages at each of those locations.\n@param {Duplex} call The stream for incoming and outgoing messages", "input": "JavaScript", "output": "function routeChat(call) {\n  call.on('data', function(note) {\n    var key = pointKey(note.getLocation());\n    /* For each note sent, respond with all previous notes that correspond to\n     * the same point */\n    if (route_notes.hasOwnProperty(key)) {\n      _.each(route_notes[key], function(note) {\n        call.write(note);\n      });\n    } else {\n      route_notes[key] = [];\n    }\n    // Then add the new note to the list\n    route_notes[key].push(note);\n  });\n  call.on('end', function() {\n    call.end();\n  });\n}", "category": "Python"}, {"instruction": "Message-Id header", "input": "JavaScript", "output": "function do_msgid_header (cb) {\n        const msgid = trans.header.get('message-id');\n        const mmatch = /@([^>]+)>/.exec(msgid);\n        if (mmatch) {\n            return plugin.do_lookups(connection, cb, mmatch[1], 'msgid');\n        }\n        cb();\n    }", "category": "Python"}, {"instruction": "Recolor an image using 2d canvas", "input": "JavaScript", "output": "function recolorBillboard(img, color) {\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = img.width;\n  canvas.height = img.height;\n\n  // Copy the image contents to the canvas\n  var context = canvas.getContext(\"2d\");\n  context.drawImage(img, 0, 0);\n  var image = context.getImageData(0, 0, canvas.width, canvas.height);\n  var normClr = [color.red, color.green, color.blue, color.alpha];\n\n  var length = image.data.length; //pixel count * 4\n  for (var i = 0; i < length; i += 4) {\n    for (var j = 0; j < 4; j++) {\n      image.data[j + i] *= normClr[j];\n    }\n  }\n\n  context.putImageData(image, 0, 0);\n  return canvas.toDataURL();\n  //    return context.getImageData(0, 0, canvas.width, canvas.height);\n}", "category": "Python"}, {"instruction": "Initialize indent for node\n\n@returns {Node}", "input": "JavaScript", "output": "function() {\r\n            var $this = $(this);\r\n            $this.find('.treegrid-indent').remove();\r\n            var tpl = $this.treegrid('getSetting', 'indentTemplate');\r\n            var expander = $this.find('.treegrid-expander');\r\n            var depth = $this.treegrid('getDepth');\r\n            for (var i = 0; i < depth; i++) {\r\n                $(tpl).insertBefore(expander);\r\n            }\r\n            return $this;\r\n        }", "category": "Python"}, {"instruction": "**************************************************\nThis class is a scanner for the visitor pattern. *\n************************************************** \nConstructor, parameters are:\nvisitor: the visitor implementation, it must be a class with a visit(element) method.\nscanElementsOnly: a flag telling whether to scan html elements only or all html nodes.", "input": "JavaScript", "output": "function DocumentScanner(visitor, scanElementsOnly) {\n\tthis.visitor = visitor;\n\tthis.scanElementsOnly = scanElementsOnly;\n\n\t/**\n\t * Scans the element\n\t */\n\tthis.scan = function(element) {\n\t\tif (this.visitor.visit(element)) {\n\t\t\t// visit child elements\n\t\t\tvar children = element.childNodes;\n\t\t\tfor(var i = 0; i < children.length; i++) {\n\t\t\t\tif(!this.scanElementsOnly || children[i].nodeType == 1)\n\t\t\t\t\tthis.scan(children[i]);\n\t\t\t}\n\t\t}\t\t\n\t}\t\n}", "category": "Python"}, {"instruction": "show goto", "input": "JavaScript", "output": "function showGoto(targets) {\n        if (!_currentMenu) {\n            return;\n        }\n        _currentMenu.createBody();\n        var i;\n        for (i in targets) {\n            _currentMenu.addItem(targets[i]);\n        }\n        _currentMenu.show();\n    }", "category": "Python"}, {"instruction": "This class represents a single search node in the exploration tree for\nA* algorithm.\n\n@param {Object} node  original node in the graph", "input": "JavaScript", "output": "function NodeSearchState(node) {\n  this.node = node;\n\n  // How we came to this node?\n  this.parent = null;\n\n  this.closed = false;\n  this.open = 0;\n\n  this.distanceToSource = Number.POSITIVE_INFINITY;\n  // the f(n) = g(n) + h(n) value\n  this.fScore = Number.POSITIVE_INFINITY;\n\n  // used to reconstruct heap when fScore is updated.\n  this.heapIndex = -1;\n}", "category": "Python"}, {"instruction": "/ ZUI change begin", "input": "JavaScript", "output": "function(bar, placement) {\n            var options = this.options;\n            placement = placement || options.scaleValuePlacement;\n            placement = placement ? placement.toLowerCase() : 'auto';\n            if(placement === 'auto') {\n                placement = bar.y < 15 ? 'insdie' : 'outside';\n            }\n\n            var y = placement === 'insdie' ? (bar.y + 10) : (bar.y - 10);\n            var ctx = this.chart.ctx;\n            ctx.font = helpers.fontString(options.scaleFontSize, options.scaleFontStyle, options.scaleFontFamily);\n            ctx.textBaseline = \"middle\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = options.scaleFontColor;\n            ctx.fillText(bar.value, bar.x, y);\n        }", "category": "Python"}, {"instruction": "Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points. @deprecated @param rhs Right hand side vector. @return Solution vector.", "input": "JavaScript", "output": "function(rhs) {\n\n            console.warn('deprecated');\n\n            var n = rhs.length;\n            // `x` is a solution vector.\n            var x = [];\n            var tmp = [];\n            var b = 2.0;\n\n            x[0] = rhs[0] / b;\n\n            // Decomposition and forward substitution.\n            for (var i = 1; i < n; i++) {\n                tmp[i] = 1 / b;\n                b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n                x[i] = (rhs[i] - x[i - 1]) / b;\n            }\n\n            for (i = 1; i < n; i++) {\n                // Backsubstitution.\n                x[n - i - 1] -= tmp[n - i] * x[n - i];\n            }\n\n            return x;\n        }", "category": "Python"}, {"instruction": "template that produces error message", "input": "JavaScript", "output": "function(errors) {\n      var\n        html = '<ul class=\"list\">'\n      ;\n      $.each(errors, function(index, value) {\n        html += '<li>' + value + '</li>';\n      });\n      html += '</ul>';\n      return $(html);\n    }", "category": "Python"}, {"instruction": "Move by key\n\n@param right {boolean} direction to move", "input": "JavaScript", "output": "function (right) {\n            var p = this.coords.p_pointer;\n            var p_step = (this.options.max - this.options.min) / 100;\n            p_step = this.options.step / p_step;\n\n            if (right) {\n                p += p_step;\n            } else {\n                p -= p_step;\n            }\n\n            this.coords.x_pointer = this.toFixed(this.coords.w_rs / 100 * p);\n            this.is_key = true;\n            this.calc();\n        }", "category": "Python"}, {"instruction": "Pauses the Current User's Playback\n@param {Object} [options] Options, for now device_id,\n@param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n@example playbackPause().then(...)\n@returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\notherwise an error. Not returned if a callback is given.", "input": "JavaScript", "output": "function(options, callback) {\n    return (\n      WebApiRequest.builder(this.getAccessToken())\n        .withPath('/v1/me/player/pause')\n        /*jshint camelcase: false */\n        .withQueryParameters(\n          options && options.device_id ? { device_id: options.device_id } : null\n        )\n        .withHeaders({ 'Content-Type': 'application/json' })\n        .build()\n        .execute(HttpManager.put, callback)\n    );\n  }", "category": "Python"}, {"instruction": "Iterates over the available log entries.\n\nBoth parameter functions gets a log entry object passed in with the following properties:\n<ul>\n<li>{jQuery.sap.log.Level} oLogEntry.level One of the log levels FATAL, ERROR, WARNING, INFO, DEBUG, TRACE</li>\n<li>{string} oLogEntry.message     The logged message</li>\n<li>{string} oLogEntry.details     The optional details for the message</li>\n<li>{string} oLogEntry.component   The optional log component under which the message was logged</li>\n<li>{float}  oLogEntry.timestamp   The timestamp when the log entry was written</li>\n<li>{object} oLogEntry.supportInfo The optional support info object</li>\n</ul>\n\n@param {function} fnFilter Filter function to filter out irrelevant log entries.\nIf the function returns <code>true</code> the log entry is kept, otherwise it's filtered out.\n@param {string} fnCheck Check function to check the remaining log entries.\nIf the function returns <code>true</code> the checking procedure is stopped,\notherwise the next entry is passed for checking.", "input": "JavaScript", "output": "function(fnFilter, fnCheck) {\n\t\t\tvar aLog = Log.getLogEntries(); //oScope.getLoggedObjects(); /*getLoggedObjects returns only log entries with supportinfo*/\n\t\t\tvar oLogEntry;\n\t\t\tfor (var i = 0; i < aLog.length; i++) {\n\t\t\t\toLogEntry = aLog[i];\n\t\t\t\tif (fnFilter(oLogEntry)) {\n\t\t\t\t\tif (fnCheck(oLogEntry)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}", "category": "Python"}, {"instruction": "return true if the given doc matches the supplied selector", "input": "JavaScript", "output": "function matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw 'Selector error: expected a JSON object';\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}", "category": "Python"}, {"instruction": "A mixin for all OData V4 bindings.\n\n@alias sap.ui.model.odata.v4.ODataBinding\n@mixin", "input": "JavaScript", "output": "function ODataBinding() {\n\t\t// maps a canonical path of a quasi-absolute or relative binding to a cache object that may\n\t\t// be reused\n\t\tthis.mCacheByResourcePath = undefined;\n\t\tthis.oCachePromise = SyncPromise.resolve();\n\t\tthis.mCacheQueryOptions = undefined;\n\t\t// used to create cache only for the latest call to #fetchCache\n\t\tthis.oFetchCacheCallToken = undefined;\n\t\t// change reason to be used when the binding is resumed\n\t\tthis.sResumeChangeReason = ChangeReason.Change;\n\t}", "category": "Python"}, {"instruction": "`triggerEvent` builds a custom DOM event with given `eventName` and `detail` data and triggers it on element given as `el`.", "input": "JavaScript", "output": "function( el, eventName, detail ) {\n            var event = document.createEvent( \"CustomEvent\" );\n            event.initCustomEvent( eventName, true, true, detail );\n            el.dispatchEvent( event );\n        }", "category": "Python"}, {"instruction": "\"An editing host is a node that is either an Element whose isContentEditable property returns true but whose parent node is not an element or whose isContentEditable property returns false, or a Document whose designMode is enabled.\"", "input": "JavaScript", "output": "function isEditingHost(node) {\n        return node &&\n            ((node.nodeType == 9 && node.designMode == \"on\") ||\n            (isEditableElement(node) && !isEditableElement(node.parentNode)));\n    }", "category": "Python"}, {"instruction": "The base implementation of `_.toString` which doesn't convert nullish\nvalues to empty strings.\n\n@private\n@param {*} value The value to process.\n@returns {string} Returns the string.", "input": "JavaScript", "output": "function baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value === 'string') {\n    return value\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : ''\n  }\n  var result = value + ''\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result\n}", "category": "Python"}, {"instruction": "`getStep` is a helper function that returns a step element defined by parameter. If a number is given, step with index given by the number is returned, if a string is given step element with such id is returned, if DOM element is given it is returned if it is a correct step element.", "input": "JavaScript", "output": "function( step ) {\n            if ( typeof step === \"number\" ) {\n                step = step < 0 ? steps[ steps.length + step ] : steps[ step ];\n            } else if ( typeof step === \"string\" ) {\n                step = lib.util.byId( step );\n            }\n            return ( step && step.id && stepsData[ \"impress-\" + step.id ] ) ? step : null;\n        }", "category": "Python"}, {"instruction": "add icons to registry and insert the font style", "input": "JavaScript", "output": "function loadFont(oFontMetadata) {\n\t\t\t\tfor (var sKey in oFontMetadata) {\n\t\t\t\t\toFontMetadata[sKey] = parseInt(oFontMetadata[sKey], 16);\n\t\t\t\t}\n\t\t\t\tmRegistry[collectionName] = oFontMetadata;\n\t\t\t\tIconPool.insertFontFaceStyle(oConfig.fontFamily, oConfig.fontURI, collectionName);\n\t\t\t\tmFontRegistry[collectionName].metadataLoaded = true;\n\t\t\t}", "category": "Python"}, {"instruction": "\u6309\u7c7b\u522b\u548c\u53c2\u6570\u6570\u7ec4\u83b7\u53d6 mock \u6570\u636e\n@param {Number} format - \u6570\u636e\u6a21\u578b\u7684\u7c7b\u578b\n@param {Array} params - \u53c2\u6570\u6570\u7ec4\n@param {Array} ds - \u6570\u636e\u6a21\u578b\u7684\u6570\u636e\u6e90, \u5305\u62ec\u6240\u6709\u6570\u636e\u6a21\u578b", "input": "JavaScript", "output": "function (format, params, ds) {\n      this.ds = ds;\n      this.errorData = [];\n      this._sortParams(params);\n      var result = this._getMockByParams(format, params);\n      return {\n        json: result,\n        error: this.errorData\n      };\n    }", "category": "Python"}, {"instruction": "Using top-down recursion, linearly scan the JSON tree to determine which values should be deduplicated.", "input": "JavaScript", "output": "function collectDuplicates(value) {\n    if (value == null || typeof value !== 'object') {\n      return;\n    }\n    const metadata = metadataForVal.get(value);\n    // Only consider duplicates with hashes longer than 2 (excludes [] and {}).\n    if (metadata && metadata.value !== value && metadata.hash.length > 2) {\n      metadata.isDuplicate = true;\n      return;\n    }\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        collectDuplicates(value[i]);\n      }\n    } else {\n      for (const k in value) {\n        if (value.hasOwnProperty(k) && value[k] !== undefined) {\n          collectDuplicates(value[k]);\n        }\n      }\n    }\n  }", "category": "Python"}, {"instruction": "Convert a list back to a js native array", "input": "JavaScript", "output": "function listAsArray(list){\n\n   return foldR( function(arraySoFar, listItem){\n      \n      arraySoFar.unshift(listItem);\n      return arraySoFar;\n           \n   }, [], list );\n   \n}", "category": "Python"}, {"instruction": "/*\nFeature class for features that fire (or don't) on combinations of context\nand class\nCopyright (C) 2017 Hugo W.L. ter Doest\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.", "input": "JavaScript", "output": "function Feature(f, name, parameters) {\n  this.evaluate = f;\n  this.name = name;\n  this.parameters = parameters;\n\n  var tmp = \"\";\n  parameters.forEach(function(par) {\n    tmp += par + \"|\";\n  });\n  this.parametersKey = tmp.substr(0, tmp.length - 1);\n}", "category": "Python"}, {"instruction": "Update the zoom and center (X and Y) springs.\n@function\n@returns {Boolean} True if any change has been made, false otherwise.", "input": "JavaScript", "output": "function() {\n        var _this = this;\n        this._adjustCenterSpringsForZoomPoint(function() {\n            _this.zoomSpring.update();\n        });\n\n        this.centerSpringX.update();\n        this.centerSpringY.update();\n\n        var changed = this.centerSpringX.current.value !== this._oldCenterX ||\n            this.centerSpringY.current.value !== this._oldCenterY ||\n            this.zoomSpring.current.value !== this._oldZoom;\n\n        this._oldCenterX = this.centerSpringX.current.value;\n        this._oldCenterY = this.centerSpringY.current.value;\n        this._oldZoom    = this.zoomSpring.current.value;\n\n        return changed;\n    }", "category": "Python"}, {"instruction": "Creates a new general purpose modal dialog using the default template and the template variables given\nas parameters as described.\n\n@param {string} dlgClass A class name identifier for the dialog. Typically one of DefaultDialogs.*\n@param {string=} title The title of the dialog. Can contain HTML markup. Defaults to \"\".\n@param {string=} message The message to display in the dialog. Can contain HTML markup. Defaults to \"\".\n@param {Array.<{className: string, id: string, text: string}>=} buttons An array of buttons where each button\nhas a class, id and text property. The id is used in \"data-button-id\". Defaults to a single Ok button.\nTypically className is one of DIALOG_BTN_CLASS_*, id is one of DIALOG_BTN_*\n@param {boolean=} autoDismiss Whether to automatically dismiss the dialog when one of the buttons\nis clicked. Default true. If false, you'll need to manually handle button clicks and the Esc\nkey, and dismiss the dialog yourself when ready by calling `close()` on the returned dialog.\n@return {Dialog}", "input": "JavaScript", "output": "function showModalDialog(dlgClass, title, message, buttons, autoDismiss) {\n        var templateVars = {\n            dlgClass: dlgClass,\n            title:    title   || \"\",\n            message:  message || \"\",\n            buttons:  buttons || [{ className: DIALOG_BTN_CLASS_PRIMARY, id: DIALOG_BTN_OK, text: Strings.OK }]\n        };\n        var template = Mustache.render(DialogTemplate, templateVars);\n\n        return showModalDialogUsingTemplate(template, autoDismiss);\n    }", "category": "Python"}, {"instruction": "The file item has been added to the DOM.", "input": "JavaScript", "output": "function(id) {\n            // If the edit filename feature is enabled, mark the filename element as \"editable\" and the associated edit icon\n            if (this._isEditFilenameEnabled()) {\n                this._templating.markFilenameEditable(id);\n                this._templating.showEditIcon(id);\n\n                // If the focusin event is not supported, we must add a focus handler to the newly create edit filename text input\n                if (!this._focusinEventSupported) {\n                    this._filenameInputFocusHandler.addHandler(this._templating.getEditInput(id));\n                }\n            }\n        }", "category": "Python"}, {"instruction": "Resets an existing tern server.", "input": "JavaScript", "output": "function resetTernServer() {\n    // If a server is already created just reset the analysis data \n    if (ternServer) {\n        ternServer.reset();\n        Infer.resetGuessing();\n        // tell the main thread we're ready to start processing again\n        self.postMessage({type: MessageIds.TERN_WORKER_READY});\n    }\n}", "category": "Python"}, {"instruction": "Get the canvas size\n@param {Boolean} sketch If set to true return the size of the sketch canvas\n@returns {OpenSeadragon.Point} The size of the canvas", "input": "JavaScript", "output": "function(sketch) {\n        var canvas = this._getContext(sketch).canvas;\n        return new $.Point(canvas.width, canvas.height);\n    }", "category": "Python"}, {"instruction": "Get the number of elements in an array block.\n\n@param tap {Tap} A tap positioned at the beginning of an array block.", "input": "JavaScript", "output": "function readArraySize(tap) {\n  var n = tap.readLong();\n  if (n < 0) {\n    n = -n;\n    tap.skipLong(); // Skip size.\n  }\n  return n;\n}", "category": "Python"}, {"instruction": "https://gist.github.com/1044128/", "input": "JavaScript", "output": "function(element) {\n  if ('outerHTML' in element) return element.outerHTML;\n  var ns = \"http://www.w3.org/1999/xhtml\";\n  var container = document.createElementNS(ns, '_');\n  var elemProto = (window.HTMLElement || window.Element).prototype;\n  var xmlSerializer = new XMLSerializer();\n  var html;\n  if (document.xmlVersion) {\n    return xmlSerializer.serializeToString(element);\n  } else {\n    container.appendChild(element.cloneNode(false));\n    html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');\n    container.innerHTML = '';\n    return html;\n  }\n}", "category": "Python"}, {"instruction": "Finds out the data entry that is closer to the given position on pixels\n@param  {Number} mouseX X position of the mouse\n@return {Object}        Data entry that is closer to that x axis position", "input": "JavaScript", "output": "function getNearestDataPoint(mouseX) {\n            let dateFromInvertedX = xScale.invert(mouseX);\n            let bisectDate = d3Array.bisector(getDate).left;\n            let dataEntryIndex = bisectDate(dataByDate, dateFromInvertedX, 1);\n            let dataEntryForXPosition = dataByDate[dataEntryIndex];\n            let previousDataEntryForXPosition = dataByDate[dataEntryIndex - 1];\n            let nearestDataPoint;\n\n            if (previousDataEntryForXPosition && dataEntryForXPosition) {\n                nearestDataPoint = findOutNearestDate(dateFromInvertedX, dataEntryForXPosition, previousDataEntryForXPosition);\n            } else {\n                nearestDataPoint = dataEntryForXPosition;\n            }\n\n            return nearestDataPoint;\n        }", "category": "Python"}, {"instruction": "Build an includePaths string\nfrom the options.includePaths array and the SASS_PATH environment variable\n\n@param {Object} options\n@api private", "input": "JavaScript", "output": "function buildIncludePaths(options) {\n  options.includePaths = options.includePaths || [];\n\n  if (process.env.hasOwnProperty('SASS_PATH')) {\n    options.includePaths = options.includePaths.concat(\n      process.env.SASS_PATH.split(path.delimiter)\n    );\n  }\n\n  // Preserve the behaviour people have come to expect.\n  // This behaviour was removed from Sass in 3.4 and\n  // LibSass in 3.5.\n  options.includePaths.unshift(process.cwd());\n\n  return options.includePaths.join(path.delimiter);\n}", "category": "Python"}, {"instruction": "Convert the CSS style value to a JSX style value\n\n@param {string} value CSS style value\n@return {string} JSX style value", "input": "JavaScript", "output": "function (value) {\n    if (isNumeric(value)) {\n      return value\n    } else if (value.startsWith(\"'\") || value.startsWith(\"\\\"\")) {\n      return value\n    } else {\n      return '\\'' + value.replace(/'/g, '\"') + '\\'';\n    }\n  }", "category": "Python"}, {"instruction": "Function: setCellStyles\n\nAssigns the value for the given key in the styles of the given cells, or\nremoves the key from the styles if the value is null.\n\nParameters:\n\nmodel - <mxGraphModel> to execute the transaction in.\ncells - Array of <mxCells> to be updated.\nkey - Key of the style to be changed.\nvalue - New value for the given key.", "input": "JavaScript", "output": "function(model, cells, key, value)\n\t{\n\t\tif (cells != null && cells.length > 0)\n\t\t{\n\t\t\tmodel.beginUpdate();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (cells[i] != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar style = mxUtils.setStyle(model.getStyle(cells[i]), key, value);\n\t\t\t\t\t\tmodel.setStyle(cells[i], style);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tmodel.endUpdate();\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Returns an object of show and hide triggers.\n\nIf a trigger is supplied,\nit is used to show the tooltip; otherwise, it will use the `trigger`\noption passed to the `$tooltipProvider.options` method; else it will\ndefault to the trigger supplied to this directive factory.\n\nThe hide trigger is based on the show trigger. If the `trigger` option\nwas passed to the `$tooltipProvider.options` method, it will use the\nmapped trigger from `triggerMap` or the passed trigger if the map is\nundefined; otherwise, it uses the `triggerMap` value of the show\ntrigger; else it will just use the show trigger.", "input": "JavaScript", "output": "function getTriggers ( trigger ) {\n        var show = trigger || options.trigger || defaultTriggerShow;\n        var hide = triggerMap[show] || show;\n        return {\n          show: show,\n          hide: hide\n        };\n      }", "category": "Python"}, {"instruction": "Z Sorting function\n@ignore", "input": "JavaScript", "output": "function _sortZ(a, b) {\n         return b.pos && a.pos ? b.pos.z - a.pos.z : a.pos ? -Infinity : Infinity;\n       }", "category": "Python"}, {"instruction": "Get the real native browser event from a jQuery event object", "input": "JavaScript", "output": "function(oEvent) {\n\t\t\twhile (oEvent && oEvent.originalEvent && oEvent !== oEvent.originalEvent) {\n\t\t\t\toEvent = oEvent.originalEvent;\n\t\t\t}\n\t\t\treturn oEvent;\n\t\t}", "category": "Python"}, {"instruction": "Get the credentials from the ~/.aws/credentials file using the AWS_PROFILE env var to get the profile.\n\n@param profile The AWS profile to get the credentials from. Default to 'default'\n@returns {Promise} Will resolve with no parameters if it succeeds, rejects with the error if it fails (no credentials found for given profile.", "input": "JavaScript", "output": "function saveCredentialsInAWS(profile = 'default') {\n    credentials = new AWS.SharedIniFileCredentials({ profile });\n    return new Promise((resolve, reject) =>\n        credentials.refresh(err => {\n            if (err) {\n                reject(err);\n            }\n            AWS.config.credentials = credentials;\n            resolve();\n        })\n    );\n}", "category": "Python"}, {"instruction": "Tag this match with type and return it for chaining\n\n@param {!RegExp.match} match  RegExp Match object with steps function parameters\nin array position 1 (and optionally 2).\n@param {number} type Either BEZIER or STEP\n@return {RegExp.match} Same object that was passed in.", "input": "JavaScript", "output": "function _tagMatch(match, type) {\n        switch (type) {\n        case BEZIER:\n            match.isBezier = true;\n            break;\n        case STEP:\n            match.isStep = true;\n            break;\n        }\n\n        return match;\n    }", "category": "Python"}, {"instruction": "---\ncategory: utilities/DOM\n---\n\nWrapper function for window.matchMedia\n\nsee https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia\n\n@param {string} query - media query string\n@param {ReactComponent|DomNode} el - component or DOM node\n@returns {Object} a media query list object", "input": "JavaScript", "output": "function matchMedia (query, el) {\n  const node = findDOMNode(el) || document\n  return canUseDOM && ownerWindow(node).matchMedia(query)\n}", "category": "Python"}, {"instruction": "helper function to add some resiliency to volatile GH api endpoints", "input": "JavaScript", "output": "async function runRetryable (fn, maxRetries) {\n  let lastError\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn()\n    } catch (error) {\n      await new Promise((resolve, reject) => setTimeout(resolve, CHECK_INTERVAL))\n      lastError = error\n    }\n  }\n  // Silently eat 404s.\n  if (lastError.status !== 404) throw lastError\n}", "category": "Python"}, {"instruction": "Get a pre-signed URL for a given operation name.\n\n@note You must ensure that you have static or previously resolved\ncredentials if you call this method synchronously (with no callback),\notherwise it may not properly sign the request. If you cannot guarantee\nthis (you are using an asynchronous credential provider, i.e., EC2\nIAM roles), you should always call this method with an asynchronous\ncallback.\n@note Not all operation parameters are supported when using pre-signed\nURLs. Certain parameters, such as `SSECustomerKey`, `ACL`, `Expires`,\n`ContentLength`, or `Tagging` must be provided as headers when sending a\nrequest. If you are using pre-signed URLs to upload from a browser and\nneed to use these fields, see {createPresignedPost}.\n@note The default signer allows altering the request by adding corresponding\nheaders to set some parameters (e.g. Range) and these added parameters\nwon't be signed. You must use signatureVersion v4 to to include these\nparameters in the signed portion of the URL and enforce exact matching\nbetween headers and signed params in the URL.\n@note This operation cannot be used with a promise. See note above regarding\nasynchronous credentials and use with a callback.\n@param operation [String] the name of the operation to call\n@param params [map] parameters to pass to the operation. See the given\noperation for the expected operation parameters. In addition, you can\nalso pass the \"Expires\" parameter to inform S3 how long the URL should\nwork for.\n@option params Expires [Integer] (900) the number of seconds to expire\nthe pre-signed URL operation in. Defaults to 15 minutes.\n@param callback [Function] if a callback is provided, this function will\npass the URL as the second parameter (after the error parameter) to\nthe callback function.\n@return [String] if called synchronously (with no callback), returns the\nsigned URL.\n@return [null] nothing is returned if a callback is provided.\n@example Pre-signing a getObject operation (synchronously)\nvar params = {Bucket: 'bucket', Key: 'key'};\nvar url = s3.getSignedUrl('getObject', params);\nconsole.log('The URL is', url);\n@example Pre-signing a putObject (asynchronously)\nvar params = {Bucket: 'bucket', Key: 'key'};\ns3.getSignedUrl('putObject', params, function (err, url) {\nconsole.log('The URL is', url);\n});\n@example Pre-signing a putObject operation with a specific payload\nvar params = {Bucket: 'bucket', Key: 'key', Body: 'body'};\nvar url = s3.getSignedUrl('putObject', params);\nconsole.log('The URL is', url);\n@example Passing in a 1-minute expiry time for a pre-signed URL\nvar params = {Bucket: 'bucket', Key: 'key', Expires: 60};\nvar url = s3.getSignedUrl('getObject', params);\nconsole.log('The URL is', url); // expires in 60 seconds", "input": "JavaScript", "output": "function getSignedUrl(operation, params, callback) {\n    params = AWS.util.copy(params || {});\n    var expires = params.Expires || 900;\n    delete params.Expires; // we can't validate this\n    var request = this.makeRequest(operation, params);\n\n    if (callback) {\n      AWS.util.defer(function() {\n        request.presign(expires, callback);\n      });\n    } else {\n      return request.presign(expires, callback);\n    }\n  }", "category": "Python"}, {"instruction": "We need to update this component if the sort order changes or our entry object\nchanges. Thanks to immutability, if any of the directory contents change, our\nentry object will change.", "input": "JavaScript", "output": "function (nextProps, nextState) {\n            return nextProps.forceRender ||\n                this.props.entry !== nextProps.entry ||\n                this.props.sortDirectoriesFirst !== nextProps.sortDirectoriesFirst ||\n                this.props.extensions !== nextProps.extensions ||\n                (nextState !== undefined && this.state.draggedOver !== nextState.draggedOver);\n        }", "category": "Python"}, {"instruction": "Simple bootstrapper for attaching logger and watch plugins by default. Other plugins can be attached through `monitor.use(plugin, options)`.", "input": "JavaScript", "output": "function bootstrap(monitor) {\n    plugins.logger.attach.call(monitor, options);\n    if (options.watch) {\n      plugins.watch.attach.call(monitor, options);\n    }\n  }", "category": "Python"}, {"instruction": "MUST be called after `prepareSource` called\nHere we need to make auto series, especially for auto legend. But we\ndo not modify series.name in option to avoid side effects.", "input": "JavaScript", "output": "function autoSeriesName(seriesModel) {\n    // User specified name has higher priority, otherwise it may cause\n    // series can not be queried unexpectedly.\n    var name = seriesModel.name;\n    if (!modelUtil.isNameSpecified(seriesModel)) {\n        seriesModel.name = getSeriesAutoName(seriesModel) || name;\n    }\n}", "category": "Python"}, {"instruction": "Flip the clock face", "input": "JavaScript", "output": "function(time, doNotAddPlayClass) {\n\t\t\tif(!time) {\n\t\t\t\ttime = this.factory.time.getDayCounter(this.showSeconds);\n\t\t\t}\n\n\t\t\tthis.autoIncrement();\n\n\t\t\tthis.base(time, doNotAddPlayClass);\n\t\t}", "category": "Python"}, {"instruction": "Get the next sibling within a container. This will walk up the\nDOM if a node's siblings have been exhausted.\n\n@param {DOMElement|DOMTextNode} node\n@return {?DOMElement|DOMTextNode}", "input": "JavaScript", "output": "function getSiblingNode(node) {\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n}", "category": "Python"}, {"instruction": "parse json file and allow single line comments", "input": "JavaScript", "output": "async function readJSONFile(filename){\n    // load file\n    let raw = await _fs.readFile(filename, 'utf8');\n\n    // strip single line js comments\n    raw = raw.replace(/^\\s*\\/\\/.*$/gm, '');\n\n    // parse text\n    return JSON.parse(raw);\n}", "category": "Python"}, {"instruction": "Count spaces before/after arrow(`=>`) token.\n@param {Object} tokens Tokens before/after arrow.\n@returns {Object} count of space before/after arrow.", "input": "JavaScript", "output": "function countSpaces(tokens) {\n            const before = tokens.arrow.range[0] - tokens.before.range[1];\n            const after = tokens.after.range[0] - tokens.arrow.range[1];\n\n            return { before, after };\n        }", "category": "Python"}, {"instruction": "hide dom", "input": "JavaScript", "output": "function hideDom(path){\n        var arrElements = document.querySelectorAll(path);\n        var element;\n        for(var i=0,len=arrElements.length;i<len;i++){\n            element = arrElements[i];\n            element._lastDispaly = element.style.display;\n            element.style.display = 'none';\n        }\n    }", "category": "Python"}, {"instruction": "##### BEGIN: MODIFIED BY SAP polyfill for document.createAttributeNS which was removed from Chrome 34 but will be added back in, see: http://datajs.codeplex.com/workitem/1272 https://code.google.com/p/chromium/issues/detail?id=347506 https://codereview.chromium.org/243333003", "input": "JavaScript", "output": "function(namespaceURI, qualifiedName) {\n        var dummy = document.createElement('dummy');\n        dummy.setAttributeNS(namespaceURI, qualifiedName, '');\n        var attr = dummy.attributes[0];\n        dummy.removeAttributeNode(attr);\n        return attr;\n    }", "category": "Python"}, {"instruction": "Get the timings.\n\n@return {Object}", "input": "JavaScript", "output": "function getTiming () {\n  let nativeTiming\n  let performance = window.performance\n  if (performance && performance.timing) {\n    nativeTiming = performance.timing.toJSON\n      ? performance.timing.toJSON()\n      : util.fn.extend({}, performance.timing)\n  } else {\n    nativeTiming = {}\n  }\n  return util.fn.extend(nativeTiming, recorder)\n}", "category": "Python"}, {"instruction": "flatten nested array (the nesting can be to any depth).\n@param array {Array}\n@param i {int}\n@returns {Array}\n@private", "input": "JavaScript", "output": "function flatten(array, i) {\n  i = i || 0;\n\n  if(i >= array.length)\n    return array;\n\n  if(isArray(array[i])) {\n    return flatten(array.slice(0,i)\n      .concat(array[i], array.slice(i+1)), i);\n  }\n  return flatten(array, i+1);\n}", "category": "Python"}, {"instruction": "Create a serializer\n\nMethod simply wraps a serializer provided by a user\nso it adds context to the error\n\n@returns {function} Serialization function", "input": "JavaScript", "output": "function createSerializer(serializer) {\n  var applyFn = function serializationWrapper(v, cb) {\n    try {\n      return cb ? serializer(v, cb) : serializer(v);\n    } catch (e) {\n      var modifiedError = new Error('Could not serialize value: ' + e.message);\n      modifiedError.value = v;\n      modifiedError.serializer = serializer;\n      throw modifiedError;\n    }\n  };\n\n  // We can check how many parameters the function has and activate the asynchronous\n  // operation if the number of parameters the function accepts is > 1\n  return {\n    apply: applyFn,\n    async: serializer.length > 1\n  };\n}", "category": "Python"}, {"instruction": "---\ncategory: utilities/a11y\n---\nReturns `true` if any of the children are not wrapped with [ScreenReaderContent](#ScreenReaderContent).\n@param {ReactChildren} children - A react component's children prop\n@return {boolean} whether any of the children are visible", "input": "JavaScript", "output": "function hasVisibleChildren (children) {\n  let visible = false\n\n  React.Children.forEach(children, (child) => {\n    if (child && !matchComponentTypes(child, [ScreenReaderContent])) {\n      visible = true\n    }\n  })\n\n  return visible\n}", "category": "Python"}, {"instruction": "\u83b7\u53d6\u6216\u8005\u8bbe\u7f6eUploader\u914d\u7f6e\u9879\u3002\n@method option\n@grammar option( key ) => *\n@grammar option( key, val ) => self\n@example\n\n// \u521d\u59cb\u72b6\u6001\u56fe\u7247\u4e0a\u4f20\u524d\u4e0d\u4f1a\u538b\u7f29\nvar uploader = new WebUploader.Uploader({\ncompress: null;\n});\n\n// \u4fee\u6539\u540e\u56fe\u7247\u4e0a\u4f20\u524d\uff0c\u5c1d\u8bd5\u5c06\u56fe\u7247\u538b\u7f29\u52301600 * 1600\nuploader.option( 'compress', {\nwidth: 1600,\nheight: 1600\n});", "input": "JavaScript", "output": "function( key, val ) {\n                var opts = this.options;\n    \n                // setter\n                if ( arguments.length > 1 ) {\n    \n                    if ( $.isPlainObject( val ) &&\n                            $.isPlainObject( opts[ key ] ) ) {\n                        $.extend( opts[ key ], val );\n                    } else {\n                        opts[ key ] = val;\n                    }\n    \n                } else {    // getter\n                    return key ? opts[ key ] : opts;\n                }\n            }", "category": "Python"}, {"instruction": "Check to see if a node contains only identifers\n@param {ASTNode} node The node to check\n@returns {boolean} Whether or not the node contains only identifers", "input": "JavaScript", "output": "function containsOnlyIdentifiers(node) {\n            if (node.type === \"Identifier\") {\n                return true;\n            }\n\n            if (node.type === \"MemberExpression\") {\n                if (node.object.type === \"Identifier\") {\n                    return true;\n                }\n                if (node.object.type === \"MemberExpression\") {\n                    return containsOnlyIdentifiers(node.object);\n                }\n            }\n\n            return false;\n        }", "category": "Python"}, {"instruction": "Prefix css classes in a block\n\n@param {String} prefix\n@param {Block} block\n@return {Block}\n@api private", "input": "JavaScript", "output": "function prefixClasses(prefix, block){\n  utils.assertString(prefix, 'prefix');\n  utils.assertType(block, 'block', 'block');\n\n  var _prefix = this.prefix;\n\n  this.options.prefix = this.prefix = prefix.string;\n  block = this.visit(block);\n  this.options.prefix = this.prefix = _prefix;\n  return block;\n}", "category": "Python"}, {"instruction": "Prepare i18n, load translations from plugins and book\n\n@param {Output}\n@return {Promise<Output>}", "input": "JavaScript", "output": "function prepareI18n(output) {\n    var state = output.getState();\n    var i18n = state.getI18n();\n    var searchPaths = listSearchPaths(output);\n\n    searchPaths\n        .reverse()\n        .forEach(function(searchPath) {\n            var i18nRoot = path.resolve(searchPath, '_i18n');\n\n            if (!fs.existsSync(i18nRoot)) return;\n            i18n.load(i18nRoot);\n        });\n\n    return Promise(output);\n}", "category": "Python"}, {"instruction": "Returns the minimum value for a component with an implicit value to equal a\nreference value. A `null` optimal value means that there is no need for an\nupdate since the implicit value and the reference are equal.\n\n@param {Component} component Component of the computed value.\n@param {any}       implicit  The implicit value of the component.\n@param {any}       reference The reference value for the component.\n@return                      the minimum value making the component to equal\nthe reference value.", "input": "JavaScript", "output": "function getOptimalUpdate(component, implicit, reference) {\n  if (equal(implicit, reference)) {\n    return null;\n  }\n  if (isSingleProperty(component.schema)) {\n    return reference;\n  }\n  var optimal = {};\n  Object.keys(reference).forEach(function(key) {\n    var needsUpdate = !equal(reference[key], implicit[key]);\n    if (needsUpdate) {\n      optimal[key] = reference[key];\n    }\n  });\n  return optimal;\n}", "category": "Python"}, {"instruction": "\ub79c\ub354\ub9c1\n@returns {View.Layout.Header} this", "input": "JavaScript", "output": "function() {\n        var resizeHandleHeights;\n\n        this._destroyChildren();\n\n        this.$el.css({\n            height: this.dimensionModel.get('headerHeight') - TABLE_BORDER_WIDTH\n        }).html(this.template({\n            colGroup: this._getColGroupMarkup(),\n            tBody: this._getTableBodyMarkup()\n        }));\n\n        if (this.coordColumnModel.get('resizable')) {\n            resizeHandleHeights = this._getResizeHandleHeights();\n            this._addChildren(this.viewFactory.createHeaderResizeHandle(this.whichSide, resizeHandleHeights));\n            this.$el.append(this._renderChildren());\n        }\n\n        return this;\n    }", "category": "Python"}, {"instruction": "Returns bucketed experiment ID to compare against experiment user is being called into\n@param {Object} group        Group that experiment is in\n@param {string} bucketingId  Bucketing ID\n@param {string} userId       ID of user to be bucketed into experiment\n@param {Object} logger       Logger implementation\n@return {string} ID of experiment if user is bucketed into experiment within the group, null otherwise", "input": "JavaScript", "output": "function(group, bucketingId, userId, logger) {\n    var bucketingKey = sprintf('%s%s', bucketingId, group.id);\n    var bucketValue = module.exports._generateBucketValue(bucketingKey);\n    logger.log(LOG_LEVEL.DEBUG, sprintf(LOG_MESSAGES.USER_ASSIGNED_TO_EXPERIMENT_BUCKET, MODULE_NAME, bucketValue, userId));\n    var trafficAllocationConfig = group.trafficAllocation;\n    var bucketedExperimentId = module.exports._findBucket(bucketValue, trafficAllocationConfig);\n    return bucketedExperimentId;\n  }", "category": "Python"}, {"instruction": "Given an array of values, a type, and a default value,\nensure the given array's contents ALL adhere to the provided type,\nreturning the default value if type check fails.\n\nIf the given value to check isn't an Array, delegates to SPE.utils.ensureTypedArg.\n\n@param  {Array|boolean|string|number|object} arg          The array of values to check type of.\n@param  {String} type         The type that should be adhered to.\n@param  {(boolean|string|number|object)} defaultValue A default fallback value.\n@return {(boolean|string|number|object)}              The given value if type check passes, or the default value if it fails.", "input": "JavaScript", "output": "function( arg, type, defaultValue ) {\n        'use strict';\n\n        // If the argument being checked is an array, loop through\n        // it and ensure all the values are of the correct type,\n        // falling back to the defaultValue if any aren't.\n        if ( Array.isArray( arg ) ) {\n            for ( var i = arg.length - 1; i >= 0; --i ) {\n                if ( typeof arg[ i ] !== type ) {\n                    return defaultValue;\n                }\n            }\n\n            return arg;\n        }\n\n        // If the arg isn't an array then just fallback to\n        // checking the type.\n        return this.ensureTypedArg( arg, type, defaultValue );\n    }", "category": "Python"}, {"instruction": "Resets the given <code>List</code> selection\nand scrolls to the top.", "input": "JavaScript", "output": "function() {\n\t\t\t\tvar oSelectedItem = this._getList().getSelectedItem();\n\n\t\t\t\tif (oSelectedItem) {\n\t\t\t\t\tthis._toggleListItem(oSelectedItem, false);\n\t\t\t\t\tsetTimeout(this._scrollPageTo.bind(this, 0, 0), 0);\n\t\t\t\t}\n\t\t\t}", "category": "Python"}, {"instruction": "Performs a deep comparison between two values to determine if they are\nequivalent to each other. If a callback is provided it will be executed\nto compare values. If the callback returns `undefined` comparisons will\nbe handled by the method instead. The callback is bound to `thisArg` and\ninvoked with two arguments; (a, b).\n\n@static\n@memberOf _\n@category Objects\n@param {*} a The value to compare.\n@param {*} b The other value to compare.\n@param {Function} [callback] The function to customize comparing values.\n@param {*} [thisArg] The `this` binding of `callback`.\n@returns {boolean} Returns `true` if the values are equivalent, else `false`.\n@example\n\nvar object = { 'name': 'fred' };\nvar copy = { 'name': 'fred' };\n\nobject == copy;\n// => false\n\n_.isEqual(object, copy);\n// => true\n\nvar words = ['hello', 'goodbye'];\nvar otherWords = ['hi', 'goodbye'];\n\n_.isEqual(words, otherWords, function(a, b) {\nvar reGreet = /^(?:hello|hi)$/i,\naGreet = _.isString(a) && reGreet.test(a),\nbGreet = _.isString(b) && reGreet.test(b);\n\nreturn (aGreet || bGreet) ? (aGreet == bGreet) : undefined;\n});\n// => true", "input": "JavaScript", "output": "function isEqual(a, b, callback, thisArg) {\n      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));\n    }", "category": "Python"}, {"instruction": "Perform a request to the homeserver without any credentials.\n@param {Function} callback Optional. The callback to invoke on\nsuccess/failure. See the promise return values for more information.\n@param {string} method The HTTP method e.g. \"GET\".\n@param {string} path The HTTP path <b>after</b> the supplied prefix e.g.\n\"/createRoom\".\n\n@param {Object=} queryParams A dict of query params (these will NOT be\nurlencoded). If unspecified, there will be no query params.\n\n@param {Object} data The HTTP JSON body.\n\n@param {Object=} opts additional options\n\n@param {Number=} opts.localTimeoutMs The maximum amount of time to wait before\ntiming out the request. If not specified, there is no timeout.\n\n@param {sting=} opts.prefix The full prefix to use e.g.\n\"/_matrix/client/v2_alpha\". If not specified, uses this.opts.prefix.\n\n@param {Object=} opts.headers map of additional request headers\n\n@return {module:client.Promise} Resolves to <code>{data: {Object},\nheaders: {Object}, code: {Number}}</code>.\nIf <code>onlyData</code> is set, this will resolve to the <code>data</code>\nobject only.\n@return {module:http-api.MatrixError} Rejects with an error if a problem\noccurred. This includes network problems and Matrix-specific error JSON.", "input": "JavaScript", "output": "function(callback, method, path, queryParams, data, opts) {\n        opts = opts || {};\n        const prefix = opts.prefix !== undefined ? opts.prefix : this.opts.prefix;\n        const fullUri = this.opts.baseUrl + prefix + path;\n\n        return this.requestOtherUrl(\n            callback, method, fullUri, queryParams, data, opts,\n        );\n    }", "category": "Python"}, {"instruction": "Returns the value of an individual property.\n\n@param {string} url\nURL of the string bundle.\n@param {string} prefName\nThe property to get the value of.\n\n@return The value of the requested property\n@type string", "input": "JavaScript", "output": "function getProperty(url, prefName) {\n  var sbs = Cc[\"@mozilla.org/intl/stringbundle;1\"]\n            .getService(Ci.nsIStringBundleService);\n  var bundle = sbs.createBundle(url);\n\n  try {\n    return bundle.GetStringFromName(prefName);\n  } catch (ex) {\n    throw new Error(arguments.callee.name + \": Unknown property - \" + prefName);\n  }\n}", "category": "Python"}, {"instruction": "PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END", "input": "JavaScript", "output": "function iif(condition, trueResult, falseResult) {\n    if (trueResult === void 0) {\n        trueResult = _empty__WEBPACK_IMPORTED_MODULE_1__[\"EMPTY\"];\n    }\n    if (falseResult === void 0) {\n        falseResult = _empty__WEBPACK_IMPORTED_MODULE_1__[\"EMPTY\"];\n    }\n    return Object(_defer__WEBPACK_IMPORTED_MODULE_0__[\"defer\"])(function () { return condition() ? trueResult : falseResult; });\n}", "category": "Python"}, {"instruction": "Reset context state\n@name reset\n@memberOf me.Renderer.prototype\n@function", "input": "JavaScript", "output": "function reset() {\n         this.resetTransform();\n         this.setBlendMode(this.settings.blendMode);\n         this.setColor(\"#000000\");\n         this.currentTint.setColor(255, 255, 255, 1.0);\n         this.cache.clear();\n         this.currentScissor[0] = 0;\n         this.currentScissor[1] = 0;\n         this.currentScissor[2] = this.backBufferCanvas.width;\n         this.currentScissor[3] = this.backBufferCanvas.height;\n         this.updateBounds();\n       }", "category": "Python"}, {"instruction": "override", "input": "JavaScript", "output": "function($super) {\n            $super();\n            // if the user-specified min is greater than the max, switch them\n            if(this.userMin > this.userMax) {\n                var temp = this.userMin;\n                this.userMin = this.userMax;\n                this.userMax = temp;\n            }\n            this.adjustUserMin();\n            this.adjustUserMax();\n        }", "category": "Python"}, {"instruction": "Creates the d3 x and y axis, setting orientations\n@private", "input": "JavaScript", "output": "function buildAxis(){\n            xAxis = d3Axis.axisBottom(xScale);\n\n            yAxis = d3Axis.axisLeft(yScale)\n                .ticks(yTicks)\n                .tickPadding(yTickPadding)\n                .tickFormat(yAxisTickFormat);\n        }", "category": "Python"}, {"instruction": "Get the density of links as a percentage of the content\nThis is the amount of text that is inside a link divided by the total text in the node.\n\n@param Element\n@return number (float)", "input": "JavaScript", "output": "function(element) {\n    var textLength = this._getInnerText(element).length;\n    if (textLength === 0)\n      return 0;\n\n    var linkLength = 0;\n\n    // XXX implement _reduceNodeList?\n    this._forEachNode(element.getElementsByTagName(\"a\"), function(linkNode) {\n      linkLength += this._getInnerText(linkNode).length;\n    });\n\n    return linkLength / textLength;\n  }", "category": "Python"}, {"instruction": "Stops event observing for a particular event handler\n@method stopObserving\n@depracated Since 0.8.34. Use `off` instead.\n@param {String} eventName\n@param {Function} handler", "input": "JavaScript", "output": "function(eventName, handler) {\n    if (!this.__eventListeners) {\n      this.__eventListeners = { };\n    }\n    if (this.__eventListeners[eventName]) {\n      fabric.util.removeFromArray(this.__eventListeners[eventName], handler);\n    }\n  }", "category": "Python"}, {"instruction": "An @import directive  @import \"lib\";  Depending on our environemnt, importing is done differently: In the browser, it's an XHR request, in Node, it would be a file-system operation. The function used for importing is stored in `import`, which we pass to the Import constructor.", "input": "JavaScript", "output": "function () {\n                var path, features, index = i;\n\n                save();\n\n                var dir = $re(/^@import?\\s+/);\n\n                var options = (dir ? this.importOptions() : null) || {};\n\n                if (dir && (path = this.entities.quoted() || this.entities.url())) {\n                    features = this.mediaFeatures();\n                    if ($char(';')) {\n                        features = features && new(tree.Value)(features);\n                        return new(tree.Import)(path, features, options, index, env.currentFileInfo);\n                    }\n                }\n\n                restore();\n            }", "category": "Python"}, {"instruction": "This is the full set of types that any JSEP node can be. Store them here to save space when minified", "input": "JavaScript", "output": "function(message, index) {\n\t\t\tvar error = new Error(message + ' at character ' + index);\n\t\t\terror.index = index;\n\t\t\terror.description = message;\n\t\t\tthrow error;\n\t\t}", "category": "Python"}, {"instruction": "Loads a configuration from a package.json file.\n@param {string} filePath The filename to load.\n@returns {Object} The configuration object from the file.\n@throws {Error} If the file cannot be read.\n@private", "input": "JavaScript", "output": "function loadPackageJSONConfigFile(filePath) {\n    debug(`Loading package.json config file: ${filePath}`);\n    try {\n        return loadJSONConfigFile(filePath).eslintConfig || null;\n    } catch (e) {\n        debug(`Error reading package.json file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}", "category": "Python"}, {"instruction": "Creates a button that when clicked will enter into stereo-rendering mode for AR.\n\nStructure: <div><button></div>\n\n@param {function} enterARHandler\n@returns {Element} Wrapper <div>.", "input": "JavaScript", "output": "function createEnterARButton (clickHandler) {\n  var arButton;\n\n  // Create elements.\n  arButton = document.createElement('button');\n  arButton.className = ENTER_AR_BTN_CLASS;\n  arButton.setAttribute('title', 'Enter AR mode.');\n  arButton.setAttribute('aframe-injected', '');\n\n  arButton.addEventListener('click', function (evt) {\n    document.getElementsByClassName(ENTER_AR_BTN_CLASS)[0].style.display = 'none';\n    document.getElementsByClassName(EXIT_AR_BTN_CLASS)[0].style.display = 'inline-block';\n    clickHandler();\n  });\n  return arButton;\n}", "category": "Python"}, {"instruction": "-- effects ---------------------------------------------- \nRuns all effects of a given type for the given set of property changes\non an instance.\n\n@param {!PropertyEffectsType} inst The instance with effects to run\n@param {Object} effects Object map of property-to-Array of effects\n@param {Object} props Bag of current property changes\n@param {Object=} oldProps Bag of previous values for changed properties\n@param {boolean=} hasPaths True with `props` contains one or more paths\n@param {*=} extraArgs Additional metadata to pass to effect function\n@return {boolean} True if an effect ran for this property\n@private", "input": "JavaScript", "output": "function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n  if (effects) {\n    let ran = false;\n    let id = dedupeId++;\n    for (let prop in props) {\n      if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {\n        ran = true;\n      }\n    }\n    return ran;\n  }\n  return false;\n}", "category": "Python"}, {"instruction": "---------------------------------------------------------------------", "input": "JavaScript", "output": "function buildHttpURL(uri) {\n    var port     = weinre_port\n    var pathname = weinre_pathname\n\n    if (pathname == \"/index.html\") pathname = \"/\"\n\n    if (weinre_protocol == \"file:\") {\n        return uri\n    }\n\n    else if (weinre_protocol == \"http:\") {\n        if (port != \"\") port = \":\" + port\n\n        return weinre_protocol + \"//\" + weinre_host + port + pathname + uri\n    }\n\n    else if (weinre_protocol == \"https:\") {\n        if (port != \"\") port = \":\" + port\n\n        return weinre_protocol + \"//\" + weinre_host + port + pathname + uri\n    }\n}", "category": "Python"}, {"instruction": "Generates the index.html file\n@method writeIndex\n@param {Callback} cb The callback to execute after it's completed", "input": "JavaScript", "output": "function (cb) {\n            var self = this,\n                stack = new Y.Parallel();\n\n            Y.log('Preparing index.html', 'info', 'builder');\n            self.renderIndex(stack.add(function (html, view) {\n                stack.html = html;\n                stack.view = view;\n                if (self.options.dumpview) {\n                    Y.Files.writeFile(path.join(self.options.outdir, 'json', 'index.json'), JSON.stringify(view), stack.add(noop));\n                }\n                Y.Files.writeFile(path.join(self.options.outdir, 'index.html'), html, stack.add(noop));\n            }));\n\n            stack.done(function ( /* html, view */ ) {\n                Y.log('Writing index.html', 'info', 'builder');\n                cb(stack.html, stack.view);\n            });\n        }", "category": "Python"}, {"instruction": "According to: http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/", "input": "JavaScript", "output": "function XdrStreamingTransport(transUrl) {\n  if (!XDRObject.enabled) {\n    throw new Error('Transport created when disabled');\n  }\n  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);\n}", "category": "Python"}, {"instruction": "Test if current element contains block-level children\n@param {AbbreviationNode} node\n@return {Boolean}", "input": "JavaScript", "output": "function(node) {\n\t\t\treturn (this.hasTagsInContent(node) && this.isBlock(node)) \n\t\t\t\t|| node.children.some(function(child) {\n\t\t\t\t\treturn this.isBlock(child);\n\t\t\t\t}, this);\n\t\t}", "category": "Python"}, {"instruction": "Retrieves a value for given key.\n@param key the key to retrieve a value for\n@returns {Promise} a promise that would be resolved in case of successful operation or rejected with\nvalue of the error message if the operation fails. It resolves with a value that is either:\n<ul>\n<li>undefined - the entry does not exist</li>\n<li>any other - the entry exists and value contains the actually one</li>\n</ul>\n@public", "input": "JavaScript", "output": "function (key) {\n\t\t\t\tvar pGet,\n\t\t\t\t\toMsr = startMeasurements(\"get\", key);\n\n\t\t\t\tLog.debug(\"Cache Manager: Getting key [\" + key + \"]\");\n\n\t\t\t\tpGet = this._callInstanceMethod(\"get\", arguments).then(function callInstanceHandler(v) {\n\t\t\t\t\tLog.debug(\"Cache Manager: Getting key [\" + key + \"] done\");\n\t\t\t\t\toMsr.endAsync();\n\t\t\t\t\treturn v;\n\t\t\t\t}, function (e) {\n\t\t\t\t\tLog.debug(\"Cache Manager: Getting key [\" + key + \"] failed. Error: \" + e);\n\t\t\t\t\toMsr.endAsync();\n\t\t\t\t\tthrow e;\n\t\t\t\t});\n\t\t\t\toMsr.endSync();\n\t\t\t\treturn pGet;\n\t\t\t}", "category": "Python"}, {"instruction": "/*\nEnable link preview popup when force touch is appled to link elements\n\n@return   bool", "input": "JavaScript", "output": "function() {\n                var deferred = $q.defer();\n\n                this.isAvailable().then(function() {\n                    window.ThreeDeeTouch.enableLinkPreview();\n                        deferred.resolve(true);\n                },\n                function(err) {\n                    deferred.reject(err);\n                });\n\n                return deferred.promise;\n            }", "category": "Python"}, {"instruction": "https://github.com/digi-trust/dt-cdn/wiki/Integration-Guide", "input": "JavaScript", "output": "function _getDigiTrustObject(key) {\n  function getDigiTrustId() {\n    let digiTrustUser = window.DigiTrust && (config.getConfig('digiTrustId') || window.DigiTrust.getUser({member: key}));\n    return (digiTrustUser && digiTrustUser.success && digiTrustUser.identity) || null;\n  }\n  let digiTrustId = getDigiTrustId();\n  // Verify there is an ID and this user has not opted out\n  if (!digiTrustId || (digiTrustId.privacy && digiTrustId.privacy.optout)) {\n    return null;\n  }\n  return digiTrustId;\n}", "category": "Python"}, {"instruction": "override", "input": "JavaScript", "output": "function($super, key, value, properties) {\n            $super(key, value, properties);\n            switch(key) {\n\n                case 'chart.showLines':\n                    this.showLines = (value === 'false');\n                    this.mapper.mapValue((value === 'false') ? 0 : 1, [\"plotOptions\", \"area\", \"lineWidth\"]);\n                    break;\n                default:\n                    // no-op, ignore unsupported properties\n                    break;\n\n            }\n        }", "category": "Python"}, {"instruction": "Register event handler to suppress event within busy section", "input": "JavaScript", "output": "function registerInteractionHandler(fnHandler) {\n\t\t\tvar aSuppressHandler = [],\n\t\t\t\toParentDOM = this.$parent.get(0),\n\t\t\t\toBlockLayerDOM = this.$blockLayer.get(0);\n\n\t\t\tfor (var i = 0; i < aPreventedEvents.length; i++) {\n\t\t\t\t// Add event listeners with \"useCapture\" settings to suppress events before dispatching/bubbling starts\n\t\t\t\toParentDOM.addEventListener(aPreventedEvents[i], fnHandler, {\n\t\t\t\t\tcapture: true,\n\t\t\t\t\tpassive: false\n\t\t\t\t});\n\t\t\t\taSuppressHandler.push(EventTriggerHook.suppress(aPreventedEvents[i], oParentDOM, oBlockLayerDOM));\n\t\t\t}\n\t\t\t//for jQuery triggered events we also need the keydown handler\n\t\t\tthis.$blockLayer.bind('keydown', fnHandler);\n\n\t\t\treturn aSuppressHandler;\n\t\t}", "category": "Python"}, {"instruction": "Creates an object with the entry names and file names\nto be transformed.\n\n@param {String} dirName - Name of the directory to read.\n\n@returns {Object} with webpack entry points.", "input": "JavaScript", "output": "function getEntries(dirName) {\n  const entries = {};\n  getExamples(dirName, (entryName, filename) => {\n    entries[entryName] = filename;\n  });\n  return entries;\n}", "category": "Python"}, {"instruction": "clone the array to avoid modifying the original", "input": "JavaScript", "output": "function(callbacks, args) {\n            if (!callbacks.length) {\n                return typeof done === 'function' ? done() : true;\n            }\n\n            var callback = callbacks.shift();\n            callback.apply(context, args);\n\n            // Is the callback synchronous ?\n            if (callback.length === nbArguments) {\n                iterator(callbacks, args, done);\n            }\n        }", "category": "Python"}, {"instruction": "------------------------------------------------------------------------------ Rule Definition ------------------------------------------------------------------------------ \nReports an \"Insert ...\" issue where text must be inserted.\n@param {RuleContext} context - The ESLint rule context.\n@param {number} offset - The source offset where to insert text.\n@param {string} text - The text to be inserted.\n@returns {void}", "input": "JavaScript", "output": "function reportInsert(context, offset, text) {\n  const pos = context.getSourceCode().getLocFromIndex(offset);\n  const range = [offset, offset];\n  context.report({\n    message: 'Insert `{{ code }}`',\n    data: { code: showInvisibles(text) },\n    loc: { start: pos, end: pos },\n    fix(fixer) {\n      return fixer.insertTextAfterRange(range, text);\n    }\n  });\n}", "category": "Python"}, {"instruction": "Makes a call to reset user's account password by sms code and new password.\nThe sms code is sent by AV.User.requestPasswordResetBySmsCode.\n@param {String} code The sms code sent by AV.User.Cloud.requestSmsCode\n@param {String} password The new password.\n@return {Promise} A promise that will be resolved with the result\nof the function.", "input": "JavaScript", "output": "function(code, password) {\n        var json = { password: password };\n        var request = AVRequest(\n          'resetPasswordBySmsCode',\n          null,\n          code,\n          'PUT',\n          json\n        );\n        return request;\n      }", "category": "Python"}, {"instruction": "Guard the specified event. If the event is not interesting, guard returns `true`. Otherwise, it returns `false`.", "input": "JavaScript", "output": "function(evt, view) {\n\n        if (evt.type === 'mousedown' && evt.button === 2) {\n            // handled as `contextmenu` type\n            return true;\n        }\n\n        if (this.options.guard && this.options.guard(evt, view)) {\n            return true;\n        }\n\n        if (evt.data && evt.data.guarded !== undefined) {\n            return evt.data.guarded;\n        }\n\n        if (view && view.model && (view.model instanceof joint.dia.Cell)) {\n            return false;\n        }\n\n        if (this.svg === evt.target || this.el === evt.target || $.contains(this.svg, evt.target)) {\n            return false;\n        }\n\n        return true;    // Event guarded. Paper should not react on it in any way.\n    }", "category": "Python"}, {"instruction": "Allow this block to be managed with the keyboard", "input": "JavaScript", "output": "function() {\n    this.inner.setAttribute('tabindex', 0);\n    this.inner.addEventListener('keyup', (e) => {\n      if (e.target !== this.inner) { return; }\n\n      switch(e.keyCode) {\n        case 13:\n          this.mediator.trigger(\"block:create\", 'Text', null, this.el, { autoFocus: true });\n          break;\n        case 8:\n          this.onDeleteClick.call(this, new CustomEvent('click'));\n          return;\n      }\n    });\n  }", "category": "Python"}, {"instruction": "Conditionally set basic authentication on a server request object.\n\n@method _auth\n@private\n@param {Object} request A superagent request object\n@param {Object} options A WPRequest _options object\n@param {Boolean} forceAuthentication whether to force authentication on the request\n@param {Object} A superagent request object, conditionally configured to use basic auth", "input": "JavaScript", "output": "function _auth( request, options, forceAuthentication ) {\n\t// If we're not supposed to authenticate, don't even start\n\tif ( ! forceAuthentication && ! options.auth && ! options.nonce ) {\n\t\treturn request;\n\t}\n\n\t// Enable nonce in options for Cookie authentication http://wp-api.org/guides/authentication.html\n\tif ( options.nonce ) {\n\t\trequest.set( 'X-WP-Nonce', options.nonce );\n\t\treturn request;\n\t}\n\n\t// Retrieve the username & password from the request options if they weren't provided\n\tconst username = options.username;\n\tconst password = options.password;\n\n\t// If no username or no password, can't authenticate\n\tif ( ! username || ! password ) {\n\t\treturn request;\n\t}\n\n\t// Can authenticate: set basic auth parameters on the request\n\treturn request.auth( username, password );\n}", "category": "Python"}, {"instruction": "Creates a slice of `array` excluding elements dropped from the end.\nElements are dropped until `predicate` returns falsey. The predicate is\ninvoked with three arguments: (value, index, array).\n\n@static\n@memberOf _\n@since 3.0.0\n@category Array\n@param {Array} array The array to query.\n@param {Function} [predicate=_.identity] The function invoked per iteration.\n@returns {Array} Returns the slice of `array`.\n@example\n\nvar users = [\n{ 'user': 'barney',  'active': true },\n{ 'user': 'fred',    'active': false },\n{ 'user': 'pebbles', 'active': false }\n];\n\n_.dropRightWhile(users, function(o) { return !o.active; });\n// => objects for ['barney']\n\n// The `_.matches` iteratee shorthand.\n_.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n// => objects for ['barney', 'fred']\n\n// The `_.matchesProperty` iteratee shorthand.\n_.dropRightWhile(users, ['active', false]);\n// => objects for ['barney']\n\n// The `_.property` iteratee shorthand.\n_.dropRightWhile(users, 'active');\n// => objects for ['barney', 'fred', 'pebbles']", "input": "JavaScript", "output": "function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }", "category": "Python"}, {"instruction": "This module provides the {@link jQuery#selectText} API.\n\n@namespace\n@name module:sap/ui/dom/jquery/selectText\n@public\n@since 1.58\n \nSets the text selection in the first element of the collection.\n\n<b>Note</b>: This feature is only supported for input element\u2019s type of text, search, url, tel and password.\n\n@param {int} iStart Start position of the selection (inclusive)\n@param {int} iEnd End position of the selection (exclusive)\n@return {jQuery} The jQuery collection\n@public\n@name jQuery#selectText\n@author SAP SE\n@since 0.9.0\n@function\n@requires module:sap/ui/dom/jquery/selectText", "input": "JavaScript", "output": "function selectText(iStart, iEnd) {\n\t\tvar oDomRef = this.get(0);\n\n\t\ttry {\n\t\t\t// In Chrome 58 and above selection start is set to selection end when the first parameter of a setSelectionRange call is negative.\n\t\t\tif (typeof (oDomRef.selectionStart) === \"number\") {\n\t\t\t\toDomRef.setSelectionRange(iStart > 0 ? iStart : 0, iEnd);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// note: some browsers fail to read the \"selectionStart\" and \"selectionEnd\" properties from HTMLInputElement, e.g.: The input element's type \"number\" does not support selection.\n\t\t}\n\n\t\treturn this;\n\t}", "category": "Python"}, {"instruction": "Just a convenience wrapper to enable sourcemaps in an easier-to-read fashion\nthan `setDevTool()`.\n@TODO: Only sets the javascript sourcemaps now. Would be nice to make loaders\nenable their specific sourcemaps when `sourceMaps()` is used.\n\n@param {string} [devtool]\n@return {Function}", "input": "JavaScript", "output": "function sourceMaps(devtool = 'cheap-module-eval-source-map') {\n  return (context, util) => {\n    context.sourceMaps = true\n\n    return util.merge({ devtool })\n  }\n}", "category": "Python"}, {"instruction": "PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END", "input": "JavaScript", "output": "function distinctUntilKeyChanged(key, compare) {\n    return Object(_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_0__[\"distinctUntilChanged\"])(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });\n}", "category": "Python"}, {"instruction": "Exports the passed entities to JSON.\n@param passedConfiguration the object having the keys:\n- entities: the entity objects to export (key: entity name, value: the entity),\n- forceNoFiltering: whether to filter out unchanged entities,\n- application:\n- forSeveralApplications: whether more than one application have to be generated,\n- name: application base name,\n- type: application type\n@returns The exported entities.", "input": "JavaScript", "output": "function exportEntities(passedConfiguration) {\n  init(passedConfiguration);\n  createJHipsterJSONFolder(\n    passedConfiguration.application.forSeveralApplications ? configuration.application.name : ''\n  );\n  if (!configuration.forceNoFiltering) {\n    filterOutUnchangedEntities();\n  }\n  if (shouldFilterOutEntitiesBasedOnMicroservice()) {\n    filterOutEntitiesByMicroservice();\n  }\n  writeEntities(passedConfiguration.application.forSeveralApplications ? configuration.application.name : '');\n  return Object.values(configuration.entities);\n}", "category": "Python"}, {"instruction": "A simple router function that does nothing but respond \"OK\". Can be used for load balancer health checks, for example.", "input": "JavaScript", "output": "function ping(req, res) {\n  if (url.parse(req.url).pathname == '/ping') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('OK');\n    return true;\n  }\n  return false;\n}", "category": "Python"}, {"instruction": "/*\nconst sqRootBiggest = compose(Math.max, Math.sqrt, Math.trunc);\nsqRootBiggest(10, 5); // 3\nsqRootBiggest(7, 0, 16); // 4", "input": "JavaScript", "output": "function compose(fn1, fn2 /*, fn3, etc */) {\n  if (!arguments.length) {\n    throw new Error(\n      'expected at least one (and probably more) function arguments'\n    );\n  }\n  var fns = arguments;\n\n  return function() {\n    var result = fns[0].apply(this, arguments);\n    var len = fns.length;\n    for (var i = 1; i < len; i++) {\n      result = fns[i].call(this, result);\n    }\n    return result;\n  };\n}", "category": "Python"}, {"instruction": "called when the layer is removed from the game world or a container", "input": "JavaScript", "output": "function onDeactivateEvent() {\n         // cancel all event subscriptions\n         me.event.unsubscribe(this.vpChangeHdlr);\n         me.event.unsubscribe(this.vpResizeHdlr);\n         me.event.unsubscribe(this.vpLoadedHdlr);\n       }", "category": "Python"}, {"instruction": "Recursively replace @imports with the text at that url", "input": "JavaScript", "output": "function(text, url, callback) {\n    var done = function(map) {\n      callback(this.flatten(text, url, map));\n    }.bind(this);\n    this.loader.process(text, url, done);\n  }", "category": "Python"}, {"instruction": "/* TODO: convert to BIFF8 font struct", "input": "JavaScript", "output": "function parse_BIFF2FONTXTRA(blob, length) {\n\tblob.l += 6; // unknown\n\tblob.l += 2; // font weight \"bls\"\n\tblob.l += 1; // charset\n\tblob.l += 3; // unknown\n\tblob.l += 1; // font family\n\tblob.l += length - 13;\n}", "category": "Python"}, {"instruction": "Copyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n \n\nClass: mxMorphing\n\nImplements animation for morphing cells. Here is an example of\nusing this class for animating the result of a layout algorithm:\n\n(code)\ngraph.getModel().beginUpdate();\ntry\n{\nvar circleLayout = new mxCircleLayout(graph);\ncircleLayout.execute(graph.getDefaultParent());\n}\nfinally\n{\nvar morph = new mxMorphing(graph);\nmorph.addListener(mxEvent.DONE, function()\n{\ngraph.getModel().endUpdate();\n});\n\nmorph.startAnimation();\n}\n(end)\n\nConstructor: mxMorphing\n\nConstructs an animation.\n\nParameters:\n\ngraph - Reference to the enclosing <mxGraph>.\nsteps - Optional number of steps in the morphing animation. Default is 6.\nease - Optional easing constant for the animation. Default is 1.5.\ndelay - Optional delay between the animation steps. Passed to <mxAnimation>.", "input": "JavaScript", "output": "function mxMorphing(graph, steps, ease, delay)\n{\n\tmxAnimation.call(this, delay);\n\tthis.graph = graph;\n\tthis.steps = (steps != null) ? steps : 6;\n\tthis.ease = (ease != null) ? ease : 1.5;\n}", "category": "Python"}, {"instruction": "returns the number of digits of precision after the decimal point optionally accepts a maximum number, after which point it will stop looking and return the max", "input": "JavaScript", "output": "function(num, max) {\n            max = max || Infinity;\n            var precision = 0;\n\n            while(precision < max && num.toFixed(precision) !== num.toString()) {\n                precision += 1;\n            }\n\n            return precision;\n        }", "category": "Python"}, {"instruction": "Removes errors that occur inside a string node\n@param {ASTNode} node to check for matching errors.\n@returns {void}\n@private", "input": "JavaScript", "output": "function removeWhitespaceError(node) {\n            const locStart = node.loc.start;\n            const locEnd = node.loc.end;\n\n            errors = errors.filter(({ loc: errorLoc }) => {\n                if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {\n                    if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }", "category": "Python"}, {"instruction": "`String.prototype.search` method https://tc39.github.io/ecma262/#sec-string.prototype.search", "input": "JavaScript", "output": "function search(regexp) {\n        var O = requireObjectCoercible(this);\n        var searcher = regexp == undefined ? undefined : regexp[SEARCH];\n        return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));\n      }", "category": "Python"}, {"instruction": "Copyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n \nClass: mxTooltipHandler\n\nGraph event handler that displays tooltips. <mxGraph.getTooltip> is used to\nget the tooltip for a cell or handle. This handler is built-into\n<mxGraph.tooltipHandler> and enabled using <mxGraph.setTooltips>.\n\nExample:\n\n(code>\nnew mxTooltipHandler(graph);\n(end)\n\nConstructor: mxTooltipHandler\n\nConstructs an event handler that displays tooltips with the specified\ndelay (in milliseconds). If no delay is specified then a default delay\nof 500 ms (0.5 sec) is used.\n\nParameters:\n\ngraph - Reference to the enclosing <mxGraph>.\ndelay - Optional delay in milliseconds.", "input": "JavaScript", "output": "function mxTooltipHandler(graph, delay)\n{\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.delay = delay || 500;\n\t\tthis.graph.addMouseListener(this);\n\t}\n}", "category": "Python"}, {"instruction": "Private Attempt to send the event to the socket. If socket no longer exists, remove it from set", "input": "JavaScript", "output": "function sendToMultiple(send, msg, destinations, type) {\n  destinations = destinations instanceof Array && destinations || [destinations];\n  destinations.forEach(function(destination) {\n    var set, socketIds;\n    set = subscriptions[type];\n    if ((socketIds = set.members(destination))) {\n      return socketIds.slice(0).forEach(function(socketId) {\n        if (!send.socketId(socketId, msg, destination)) {\n          return set.removeFromAll(socketId);\n        }\n      });\n    }\n  });\n  return true;\n}", "category": "Python"}, {"instruction": "Deep merge two objects.\n@param target\n@param ...sources", "input": "JavaScript", "output": "function mergeDeep(target, ...sources) {\n  if (!sources.length) return target;\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, { [key]: {} });\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, { [key]: source[key] });\n      }\n    }\n  }\n\n  return mergeDeep(target, ...sources);\n}", "category": "Python"}, {"instruction": "client.getNetworks\n\n@description Display the currently available networks\n\n@param {Function}    callback    f(err, networks) where networks is an array of networks\n@returns {*}", "input": "JavaScript", "output": "function (callback) {\n      return this._request({\n        path: this._extension\n      }, function (err, body, res) {\n        return err\n          ? callback(err)\n          : callback(null, body.networks, res);\n      });\n    }", "category": "Python"}, {"instruction": "Recursively cleans the payload of all contained requests via {@link #.cleanPayload}.\nModifies the array in-place.\n\n@param {object[]} aRequests\nThe requests\n@returns {object[]}\nThe cleaned requests\n\n@private", "input": "JavaScript", "output": "function (aRequests) {\n\t\t\taRequests.forEach(function (oRequest) {\n\t\t\t\tif (Array.isArray(oRequest)) {\n\t\t\t\t\t_Requestor.cleanBatch(oRequest);\n\t\t\t\t} else {\n\t\t\t\t\toRequest.body = _Requestor.cleanPayload(oRequest.body);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn aRequests;\n\t\t}", "category": "Python"}, {"instruction": "Password signup handler", "input": "JavaScript", "output": "function createUser (req, res, next) {\n    User.insert(req.body, { private: true }, function (err, user) {\n      if (err) {\n        res.render('signup', {\n          params: qs.stringify(req.body),\n          request: req.body,\n          providers: settings.providers,\n          error: err.message\n        })\n      } else {\n        authenticator.dispatch('password', req, res, next, function (err, user, info) {\n          if (err) { return next(err) }\n          if (!user) {\n          } else {\n            authenticator.login(req, user)\n            req.sendVerificationEmail =\n              req.provider.emailVerification.enable\n            req.flash('isNewUser', true)\n            next()\n          }\n        })\n      }\n    })\n  }", "category": "Python"}, {"instruction": "Animated works by building a directed acyclic graph of dependencies\ntransparently when you render your Animated components.\n\nnew Animated.Value(0)\n.interpolate()        .interpolate()    new Animated.Value(1)\nopacity               translateY      scale\nstyle                         transform\nView#234                         style\nView#123\n\nA) Top Down phase\nWhen an Animated.Value is updated, we recursively go down through this\ngraph in order to find leaf nodes: the views that we flag as needing\nan update.\n\nB) Bottom Up phase\nWhen a view is flagged as needing an update, we recursively go back up\nin order to build the new value that it needs. The reason why we need\nthis two-phases process is to deal with composite props such as\ntransform which can receive values from multiple parents.", "input": "JavaScript", "output": "function findAnimatedStyles(node, styles) {\n  if (typeof node.update === 'function') styles.add(node)\n  else node.getChildren().forEach(child => findAnimatedStyles(child, styles))\n}", "category": "Python"}, {"instruction": "Drawing in Canvas", "input": "JavaScript", "output": "function _onMakeImage() {\n\t\t\tthis._elImage.src = this._elCanvas.toDataURL(\"image/png\");\n\t\t\tthis._elImage.style.display = \"block\";\n\t\t\tthis._elCanvas.style.display = \"none\";\t\t\t\n\t\t}", "category": "Python"}, {"instruction": "\u68c0\u6d4b\u662f\u5426\u5b58\u5728\u73af\n@param {Number} id - \u8981\u68c0\u6d4b\u7684id\n@param {Array} traversePath - \u904d\u5386\u65f6\u5b58\u7684\u8def\u5f84\n@return {String|undefined}  - \u5b58\u5728\u73af\u65f6\u8fd4\u56de\u73af\u7684\u540d\u79f0, \u5426\u5219\u8fd4\u56de undefined", "input": "JavaScript", "output": "function (id, traversePath) {\n      var datatype = this.ds.find(function (dt) {\n        return dt.id == id;\n      });\n      if (datatype.format != 0 && datatype.format != 2 || datatype.id === 10000) {\n        // \u975e\u54c8\u5e0c\u3001\u975e\u6570\u7ec4\u3001\u53ef\u53d8\u7c7b\u578b\u65f6\u4e0d\u4f1a\u6709\u5faa\u73af\u4f9d\u8d56\u4ea7\u751f\n        return;\n      }\n      var foundLoop = traversePath.find(function (item) {\n        // todo: \u8fd9\u91cc\u4e0d\u4f7f\u7528\u4e25\u683c\u76f8\u7b49\u5224\u65ad, \u56e0\u4e3a\u540e\u7aef\u8fd4\u56de\u7684\u6570\u636e\u7c7b\u578b\u6709\u65f6\u662f\u5b57\u7b26\u6709\u65f6\u662f\u6570\u5b57\n        return item.id == id;\n      });\n      if (foundLoop) {\n        // \u5982\u679c\u5b58\u5728\u73af, \u5c31\u8fd4\u56de\u6570\u636e\u7c7b\u578b\u7684\u540d\u79f0\n        // console.log(traversePath)\n        // console.log(foundLoop.name)\n        return '<' + foundLoop.name + '>';\n      } else {\n        traversePath.push({\n          id: id,\n          name: datatype.name\n        });\n      }\n    }", "category": "Python"}, {"instruction": "Returns a function that takes an object as an input and maps the object's keys using `mapper`. If the input is not an object, the input is returned unchanged.", "input": "JavaScript", "output": "function keyMapper(mapper) {\n  return obj => {\n    if (!isObject(obj) || Array.isArray(obj)) {\n      return obj;\n    }\n\n    const keys = Object.keys(obj);\n    const out = {};\n\n    for (let i = 0, l = keys.length; i < l; ++i) {\n      const key = keys[i];\n      out[mapper(key)] = obj[key];\n    }\n\n    return out;\n  };\n}", "category": "Python"}, {"instruction": "Returns pointer coordinates relative to canvas.\n@method getPointer\n@return {Object} object with \"x\" and \"y\" number values", "input": "JavaScript", "output": "function (e) {\n      var pointer = getPointer(e);\n      return {\n        x: pointer.x - this._offset.left,\n        y: pointer.y - this._offset.top\n      };\n    }", "category": "Python"}, {"instruction": "Create a notification\n@constructor", "input": "JavaScript", "output": "function Notification (payload) {\n  this.encoding = \"utf8\";\n  this.payload = {};\n  this.compiled = false;\n\n  this.aps = {};\n  this.expiry = 0;\n  this.priority = 10;\n\n  if (payload) {\n    for(let key in payload) {\n      if (payload.hasOwnProperty(key)) {\n        this[key] = payload[key];\n      }\n    }\n  }\n}", "category": "Python"}, {"instruction": "From http://blog.stevenlevithan.com/archives/faster-trim-javascript\nprofiler shows this is much faster than the previous implementation in both IE and Firefox.\n\n@param {String} str The string to trim.\n@param {String} (Optional) delim The characters to remove from the start/end of the string.\n\n@type String\n@return A trimmed string.", "input": "JavaScript", "output": "function(str, delim) {\n            if (delim) return str.replace(new RegExp(\"^[\\\\s\" + delim + \"]+\"),'').replace(new RegExp(\"[\\\\s\" + delim + \"]+$\"), '');\n            else return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n        }", "category": "Python"}, {"instruction": "Finds intersection of two ranges\n@param {Range} range\n@returns {Range} <code>null</code> if ranges does not overlap", "input": "JavaScript", "output": "function(range) {\n\t\t\tif (this.overlap(range)) {\n\t\t\t\tvar start = Math.max(range.start, this.start);\n\t\t\t\tvar end = Math.min(range.end, this.end);\n\t\t\t\treturn new Range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t}", "category": "Python"}, {"instruction": "Add animation to the view", "input": "JavaScript", "output": "function createGridClipShape(rect, seriesModel, cb) {\n    var rectEl = new graphic.Rect({\n        shape: {\n            x: rect.x - 10,\n            y: rect.y - 10,\n            width: 0,\n            height: rect.height + 20\n        }\n    });\n    graphic.initProps(rectEl, {\n        shape: {\n            width: rect.width + 20,\n            height: rect.height + 20\n        }\n    }, seriesModel, cb);\n\n    return rectEl;\n}", "category": "Python"}, {"instruction": "Reports `import`, `export`, `as`, and `from` keywords of a given node if\nusage of spacing around those keywords is invalid.\n\nThis rule handles the `*` token in module declarations.\n\nimport*as A from \"./a\"; /*error Expected space(s) after \"import\".\nerror Expected space(s) before \"as\".\n\n@param {ASTNode} node - A node to report.\n@returns {void}", "input": "JavaScript", "output": "function checkSpacingForModuleDeclaration(node) {\n            const firstToken = sourceCode.getFirstToken(node);\n\n            checkSpacingBefore(firstToken, PREV_TOKEN_M);\n            checkSpacingAfter(firstToken, NEXT_TOKEN_M);\n\n            if (node.type === \"ExportDefaultDeclaration\") {\n                checkSpacingAround(sourceCode.getTokenAfter(firstToken));\n            }\n\n            if (node.source) {\n                const fromToken = sourceCode.getTokenBefore(node.source);\n\n                checkSpacingBefore(fromToken, PREV_TOKEN_M);\n                checkSpacingAfter(fromToken, NEXT_TOKEN_M);\n            }\n        }", "category": "Python"}, {"instruction": "Named container of edited source\n@type EditContainer\n@param {String} source\n@param {Object} options", "input": "JavaScript", "output": "function EditContainer(source, options) {\n\t\tthis.options = utils.extend({offset: 0}, options);\n\t\t/**\n\t\t * Source code of edited structure. All changes in the structure are \n\t\t * immediately reflected into this property\n\t\t */\n\t\tthis.source = source;\n\t\t\n\t\t/** \n\t\t * List of all editable children\n\t\t * @private \n\t\t */\n\t\tthis._children = [];\n\t\t\n\t\t/**\n\t\t * Hash of all positions of container\n\t\t * @private\n\t\t */\n\t\tthis._positions = {\n\t\t\tname: 0\n\t\t};\n\t\t\n\t\tthis.initialize.apply(this, arguments);\n\t}", "category": "Python"}, {"instruction": "Creates an interpolation binding with 7 expressions.", "input": "JavaScript", "output": "function interpolation7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n    var different = bindingUpdated4(v0, v1, v2, v3);\n    different = bindingUpdated2(v4, v5) || different;\n    different = bindingUpdated(v6) || different;\n    return different ?\n        prefix + stringify$1(v0) + i0 + stringify$1(v1) + i1 + stringify$1(v2) + i2 + stringify$1(v3) + i3 +\n            stringify$1(v4) + i4 + stringify$1(v5) + i5 + stringify$1(v6) + suffix :\n        NO_CHANGE;\n}", "category": "Python"}, {"instruction": "Checks if an expression is a variable that can only be observed within the given function.\n@param {ASTNode} expression The expression to check\n@param {ASTNode} surroundingFunction The function node\n@returns {boolean} `true` if the expression is a variable which is local to the given function, and is never\nreferenced in a closure.", "input": "JavaScript", "output": "function isLocalVariableWithoutEscape(expression, surroundingFunction) {\n            if (expression.type !== \"Identifier\") {\n                return false;\n            }\n\n            const variable = resolveVariable(expression);\n\n            if (!variable) {\n                return false;\n            }\n\n            return variable.references.every(reference => identifierToSurroundingFunctionMap.get(reference.identifier) === surroundingFunction) &&\n                variable.defs.every(def => identifierToSurroundingFunctionMap.get(def.name) === surroundingFunction);\n        }", "category": "Python"}, {"instruction": "We have to remember current server data and client data.\nThe `sync` method has no access to it.\n`updated_at` is already set to \"Date.now\" when the overridden `sync.update` is called.\nSee https://github.com/tgriesser/bookshelf/blob/79c526870e618748caf94e7476a0bc796ee090a6/src/model.js#L955", "input": "JavaScript", "output": "function save(data) {\n            this.clientData = _.cloneDeep(data) || {};\n            this.serverData = _.cloneDeep(this.attributes);\n\n            return ParentModel.prototype.save.apply(this, arguments);\n        }", "category": "Python"}, {"instruction": "generate webpack entry file for markdown docs", "input": "JavaScript", "output": "function buildDocsEntry() {\n  const output = join('docs/src/docs-entry.js');\n  const getName = fullPath => fullPath.replace(/\\/(en|zh)/, '.$1').split('/').pop().replace('.md', '');\n  const docs = glob\n    .sync([\n      join('docs/**/*.md'),\n      join('packages/**/*.md'),\n      '!**/node_modules/**'\n    ])\n    .map(fullPath => {\n      const name = getName(fullPath);\n      return `'${name}': () => import('${path.relative(join('docs/src'), fullPath).replace(/\\\\/g, '/')}')`;\n    });\n\n  const content = `${tips}\nexport default {\n  ${docs.join(',\\n  ')}\n};\n`;\n  fs.writeFileSync(output, content);\n}", "category": "Python"}, {"instruction": "\u58f0\u660e\u5f0f\u4e8b\u4ef6\u7684\u76d1\u542c\u51fd\u6570\n\n@param {Object} eventBind \u7ed1\u5b9a\u4fe1\u606f\u5bf9\u8c61\n@param {boolean} isComponentEvent \u662f\u5426\u7ec4\u4ef6\u81ea\u5b9a\u4e49\u4e8b\u4ef6\n@param {Data} data \u6570\u636e\u73af\u5883\n@param {Event} e \u4e8b\u4ef6\u5bf9\u8c61", "input": "JavaScript", "output": "function getEventListener(eventExpr, owner, data, isComponentEvent) {\n    return function (e) {\n        var method = findMethod(owner, eventExpr.name, data);\n\n        if (typeof method === 'function') {\n            method.apply(owner, evalArgs(\n                eventExpr.args,\n                new Data(\n                    { $event: isComponentEvent ? e : e || window.event },\n                    data\n                ),\n                owner\n            ));\n        }\n    };\n}", "category": "Python"}, {"instruction": "Resolves property names or property paths defined with period-delimited strings or arrays of strings. Property names that are found on the source object are used directly (even if they include a period). Nested property names that include periods, within a path, are only understood in array paths.", "input": "JavaScript", "output": "function getPropertyByPath(source: Object, path: string | Array<string>): any {\n  if (typeof path === 'string' && source.hasOwnProperty(path)) {\n    return source[path];\n  }\n\n  const parsedPath = typeof path === 'string' ? path.split('.') : path;\n  return parsedPath.reduce((previous, key) => {\n    if (previous === undefined) {\n      return previous;\n    }\n    return previous[key];\n  }, source);\n}", "category": "Python"}, {"instruction": "var node = wysihtml5.dom.domNode(element).prev({nodeTypes: [1,3], ignoreBlankTexts: true});", "input": "JavaScript", "output": "function(options) {\n        var prevNode = node.previousSibling,\n            types = (options && options.nodeTypes) ? options.nodeTypes : defaultNodeTypes;\n        \n        if (!prevNode) {\n          return null;\n        }\n\n        if (\n          (!wysihtml5.lang.array(types).contains(prevNode.nodeType)) || // nodeTypes check.\n          (options && options.ignoreBlankTexts && _isBlankText(prevNode)) // Blank text nodes bypassed if set\n        ) {\n          return wysihtml5.dom.domNode(prevNode).prev(options);\n        }\n        \n        return prevNode;\n      }", "category": "Python"}, {"instruction": "Sets handlers on all of our input fields on the sandbox dom", "input": "JavaScript", "output": "function setHandlers() {\n    d3.select(`.${chartSelectorClass}`).on('change', _handleChartSelectorChange);\n    d3.select(`.${dataSelectorClass}`).on('change', _handleDataSelectorChange);\n\n    d3.select(`.${dataSubmitButtonClass}`).on('click', _handleDataUpdate);\n    d3.select(`.${dataResetButtonClass}`).on('click', _handleDataReset);\n    d3.select(`.${dataInputSizeToggleClass}`).on('click', _handleDataSizeToggle);\n\n    d3.select(`.${configSubmitButtonClass}`).on('click', _handleConfigUpdate);\n    d3.select(`.${configResetButtonClass}`).on('click', _handleConfigReset);\n\n    d3.select(`.${configAddTooltipClass}`).on('click', _handleAddTooltip.bind(null, tooltipTypes.basic))\n    d3.select(`.${configAddMiniTooltipClass}`).on('click', _handleAddTooltip.bind(null, tooltipTypes.mini))\n}", "category": "Python"}, {"instruction": "convert relative path to absolute path.", "input": "JavaScript", "output": "function convert( name, _path, contents ) {\n    var rDefine = /(define\\s*\\(\\s*('|\").*?\\2\\s*,\\s*\\[)([\\s\\S]*?)\\]/ig,\n        rDeps = /('|\")(.*?)\\1/g,\n        root = _path.substr( 0, _path.length - name.length - 3 ),\n        dir = path.dirname( _path ),\n        m, m2, deps, dep, _path2;\n\n    contents = contents.replace( rDefine, function( m, m1, m2, m3 ) {\n        return m1 + m3.replace( rDeps, function( m, m1, m2 ) {\n            m2 = path.join( dir, m2 );\n            m2 = path.relative( root, m2 );\n\n            m2 = m2.replace(/\\\\/g, '/');\n            return m1 + m2 + m1;\n        }) + ']';\n    });\n\n    return contents;\n}", "category": "Python"}, {"instruction": "@private\n\nSets the project root to the given directory, resetting the ProjectModel and file tree in the process.\n\n@param {Directory} rootEntry directory object for the project root\n@return {$.Promise} resolved when the project is done setting up", "input": "JavaScript", "output": "function _setProjectRoot(rootEntry) {\n        var d = new $.Deferred();\n        model.setProjectRoot(rootEntry).then(function () {\n            d.resolve();\n            model.reopenNodes(PreferencesManager.getViewState(\"project.treeState\", _getProjectViewStateContext()));\n        });\n        return d.promise();\n    }", "category": "Python"}, {"instruction": "un-marshall a data chunk, for ease of matching body is converted to string", "input": "JavaScript", "output": "function(data, escapeHeaderValues) {\n    const onFrame = jasmine.createSpy('onFrame');\n    const onIncomingPing = jasmine.createSpy('onIncomingPing');\n    const parser = new StompJs.Parser(onFrame, onIncomingPing);\n\n    parser.parseChunk(data);\n\n    const rawFrame = onFrame.calls.first().args[0];\n    return StompJs.FrameImpl.fromRawFrame(rawFrame, escapeHeaderValues);\n  }", "category": "Python"}, {"instruction": "The worker receives a message to load the index and to query the index", "input": "JavaScript", "output": "function handleMessage(message) {\n  var type = message.data.type;\n  var id = message.data.id;\n  var payload = message.data.payload;\n  switch(type) {\n    case 'load-index':\n      makeRequest(SEARCH_TERMS_URL, function(searchInfo) {\n        index = createIndex(loadIndex(searchInfo));\n        self.postMessage({type: type, id: id, payload: true});\n      });\n      break;\n    case 'query-index':\n      self.postMessage({type: type, id: id, payload: {query: payload, results: queryIndex(payload)}});\n      break;\n    default:\n      self.postMessage({type: type, id: id, payload: {error: 'invalid message type'}})\n  }\n}", "category": "Python"}, {"instruction": "Reports a given function node if the node matches the following patterns.\n\n- Not allowed by options.\n- The body is empty.\n- The body doesn't have any comments.\n\n@param {ASTNode} node - A function node to report. This is one of\nan ArrowFunctionExpression, a FunctionDeclaration, or a\nFunctionExpression.\n@returns {void}", "input": "JavaScript", "output": "function reportIfEmpty(node) {\n            const kind = getKind(node);\n            const name = astUtils.getFunctionNameWithKind(node);\n            const innerComments = sourceCode.getTokens(node.body, {\n                includeComments: true,\n                filter: astUtils.isCommentToken\n            });\n\n            if (allowed.indexOf(kind) === -1 &&\n                node.body.type === \"BlockStatement\" &&\n                node.body.body.length === 0 &&\n                innerComments.length === 0\n            ) {\n                context.report({\n                    node,\n                    loc: node.body.loc.start,\n                    messageId: \"unexpected\",\n                    data: { name }\n                });\n            }\n        }", "category": "Python"}, {"instruction": "Trigger update to all registered materials.", "input": "JavaScript", "output": "function (material) {\n    var materials = this.materials;\n    Object.keys(materials).forEach(function (uuid) {\n      materials[uuid].needsUpdate = true;\n    });\n  }", "category": "Python"}, {"instruction": "converts a dash or hypen separated string to camelCase", "input": "JavaScript", "output": "function unDashHyphen (str) {\n  return str\n    .trim()\n    .toLowerCase()\n    .replace(/[-_\\s]+(.)?/g, function (match, c) {\n      return c ? c.toUpperCase() : \"\";\n    });\n}", "category": "Python"}, {"instruction": "Checks if the image of a given enabled element fitted the window\nbefore the resize\n\n@param {EnabledElement} enabledElement The Cornerstone Enabled Element\n@param {number} oldCanvasWidth The width of the canvas before the resize\n@param {number} oldCanvasHeight The height of the canvas before the resize\n@return {Boolean} true if it fitted the windows, false otherwise", "input": "JavaScript", "output": "function wasFitToWindow (enabledElement, oldCanvasWidth, oldCanvasHeight) {\r\n  const scale = enabledElement.viewport.scale;\r\n  const imageSize = getImageSize(enabledElement.image, enabledElement.viewport.rotation);\r\n  const imageWidth = Math.round(imageSize.width * scale);\r\n  const imageHeight = Math.round(imageSize.height * scale);\r\n  const x = enabledElement.viewport.translation.x;\r\n  const y = enabledElement.viewport.translation.y;\r\n\r\n  return (imageWidth === oldCanvasWidth && imageHeight <= oldCanvasHeight) ||\r\n    (imageWidth <= oldCanvasWidth && imageHeight === oldCanvasHeight) &&\r\n    (x === 0 && y === 0);\r\n}", "category": "Python"}, {"instruction": "Executes the CLI based on an array of arguments that is passed in.\n@param {string|Array|Object} args The arguments to process.\n@returns {int} The exit code for the operation.", "input": "JavaScript", "output": "function execute(args) {\n    try {\n        const currentOptions = options.parse(args)\n        return executeOptions(currentOptions)\n    } catch (error) {\n        console.error(error.message)\n        return 1\n    }\n}", "category": "Python"}, {"instruction": "Returns an unqualified search string by removing any leading 'search '\ncommand.  This method does a simple search at the beginning of the\nsearch.", "input": "JavaScript", "output": "function(q) {\n            var workingQ = '' + q;\n            workingQ = workingQ.replace(this.reLTrimCommand, '');\n            if (workingQ.substring(0, 7) == 'search ') {\n                return workingQ.substring(7).replace(this.reLTrimCommand, '');\n            }\n            return q;\n        }", "category": "Python"}, {"instruction": "composeS : Semigroupoid s => (s y z, s x y, ..., s a b) -> s a z", "input": "JavaScript", "output": "function composeS(...args) {\n  if(!arguments.length) {\n    throw new TypeError(err)\n  }\n\n  const ms =\n    args.slice().reverse()\n\n  const head =\n    ms[0]\n\n  if(!isSemigroupoid(head)) {\n    throw new TypeError(err)\n  }\n\n  if(ms.length === 1) {\n    return head\n  }\n\n  return ms.slice().reduce((comp, m) => {\n    if(!isSameType(comp, m)) {\n      throw new TypeError(err)\n    }\n\n    return comp.compose(m)\n  })\n}", "category": "Python"}, {"instruction": "Move the file or directory at the given path to a system dependent trash\nlocation, calling back asynchronously with a possibly null FileSystemError\nstring. Directories will be moved even when non-empty.\n\n@param {string} path\n@param {function(string)=} callback", "input": "JavaScript", "output": "function moveToTrash(path, callback) {\n        appshell.fs.moveToTrash(path, function (err) {\n            callback(_mapError(err));\n        });\n    }", "category": "Python"}, {"instruction": "A stream that the server can read from. Used for calls that are streaming\nfrom the client side.\n@constructor grpc~ServerReadableStream\n@extends external:Readable\n@borrows grpc~ServerUnaryCall#sendMetadata as\ngrpc~ServerReadableStream#sendMetadata\n@borrows grpc~ServerUnaryCall#getPeer as grpc~ServerReadableStream#getPeer\n@param {grpc.internal~Call} call The call object to read data with\n@param {grpc.Metadata} metadata The request metadata from the client\n@param {grpc~deserialize} deserialize Deserialization function for reads", "input": "JavaScript", "output": "function ServerReadableStream(call, metadata, deserialize) {\n  Readable.call(this, {objectMode: true});\n  this.call = call;\n  setUpReadable(this, deserialize);\n  /**\n   * Indicates if the call has been cancelled\n   * @member {boolean} grpc~ServerReadableStream#cancelled\n   */\n  this.cancelled = false;\n  /**\n   * The request metadata from the client\n   * @member {grpc.Metadata} grpc~ServerReadableStream#metadata\n   */\n  this.metadata = metadata;\n}", "category": "Python"}, {"instruction": "Adaptive text sizing function\n\n@private\n@param width Parent width\n@param height Parent height\n@param fontSize Requested text size\n@param scale Proportional scale of text", "input": "JavaScript", "output": "function textSize(width, height, fontSize, scale) {\n\t    var stageWidth = parseInt(width, 10);\n\t    var stageHeight = parseInt(height, 10);\n\n\t    var bigSide = Math.max(stageWidth, stageHeight);\n\t    var smallSide = Math.min(stageWidth, stageHeight);\n\n\t    var newHeight = 0.8 * Math.min(smallSide, bigSide * scale);\n\t    return Math.round(Math.max(fontSize, newHeight));\n\t}", "category": "Python"}, {"instruction": "\u83b7\u53d6\u4e00\u4e2a\u8282\u70b9\u7684\u6240\u6709\u7236\u8f88\u8282\u70b9\n@param {*} item\n@param {*} uncheckableItemValues", "input": "JavaScript", "output": "function getParents(item: Object) {\n    let parents = [];\n\n    if (!item.parent) {\n      return parents;\n    }\n\n    parents.push(item.parent);\n    parents = parents.concat(getParents(item.parent));\n\n    return parents;\n  }", "category": "Python"}, {"instruction": "Unhightlight the highlighted line", "input": "JavaScript", "output": "function() {\n\t\t\tvar annotationModel = this.getAnnotationModel();\n\t\t\tvar textModel = this.getModel();\n\t\t\tif (textModel.getBaseModel) {\n\t\t\t\ttextModel = textModel.getBaseModel();\n\t\t\t}\n\t\t\tvar type = AT.ANNOTATION_HIGHLIGHTED_LINE;\n\t\t\tvar annotations = annotationModel.getAnnotations(0, textModel.getCharCount());\n\t\t\tvar remove = null;\n\t\t\twhile (annotations.hasNext()) {\n\t\t\t\tvar annotation = annotations.next();\n\t\t\t\tif (annotation.type === type) {\n\t\t\t\t\tremove = annotation;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (remove) {\n\t\t\t\tannotationModel.removeAnnotation(remove);\n\t\t\t}\n\t\t}", "category": "Python"}, {"instruction": "Manage the codecasting stream. Wait for code events (for each panel) then\nupdate the appropriate panel", "input": "JavaScript", "output": "function codecastStream() {\n    if (!(jsbin && jsbin.panels && jsbin.panels.panels)) return;\n    var editors = jsbin.panels.panels;\n\n    function setCode(event) {\n      var panelId = event.type;\n      if (!editors[panelId]) return;\n      var cursor = editors[panelId].editor.getCursor();\n      editors[panelId].setCode(event.data);\n      editors[panelId].editor.setCursor(cursor);\n    }\n\n    // Update the url when the revision is bumped\n    es.addEventListener('bump-revision', function (event) {\n      window.location.pathname = cleanPath(event.data) + '/edit';\n    });\n    // on data, update the panels, which will cause an automatic render\n    es.addEventListener('css', setCode);\n    es.addEventListener('javascript', setCode);\n    es.addEventListener('html', setCode);\n  }", "category": "Python"}, {"instruction": "register a list of ng filters to ngVue", "input": "JavaScript", "output": "function registerFilters (filters) {\n  if (isArray(filters)) {\n    lazyStringFilters = lazyStringFilters.concat(filters)\n  } else if (isObject(filters)) {\n    Object.keys(filters).forEach(name => {\n      addFilter(name, filters[name])\n    })\n  }\n}", "category": "Python"}, {"instruction": "Parses rabin chunker string\n\n@param  {String}   chunker Chunker algorithm supported formats:\n\"rabin\"\n\"rabin-{avg}\"\n\"rabin-{min}-{avg}-{max}\"\n\n@return {Object}   rabin chunker options", "input": "JavaScript", "output": "function parseRabinString (chunker) {\n  const options = {}\n  const parts = chunker.split('-')\n  switch (parts.length) {\n    case 1:\n      options.avgChunkSize = 262144\n      break\n    case 2:\n      options.avgChunkSize = parseChunkSize(parts[1], 'avg')\n      break\n    case 4:\n      options.minChunkSize = parseChunkSize(parts[1], 'min')\n      options.avgChunkSize = parseChunkSize(parts[2], 'avg')\n      options.maxChunkSize = parseChunkSize(parts[3], 'max')\n      break\n    default:\n      throw new Error('Incorrect chunker format (expected \"rabin\" \"rabin-[avg]\" or \"rabin-[min]-[avg]-[max]\"')\n  }\n\n  return options\n}", "category": "Python"}, {"instruction": "invokeToneAssistant calls the invokeToneAsync function to get the tone information for the user's\ninput text (input.text in the payload json object), adds/updates the user's tone in the payload's context,\nand sends the payload to the assistant service to get a response which is printed to screen.\n@param payload a json object containing the basic information needed to converse with the Assistant Service's\nmessage endpoint.\n\nNote: as indicated below, the console.log statements can be replaced with application-specific code to process\nthe err or data object returned by the Assistant Service.", "input": "JavaScript", "output": "function invokeToneAssistant(payload, maintainToneHistoryInContext) {\n  tone_detection\n    .invokeToneAsync(payload, toneAnalyzer)\n    .then(tone => {\n      tone_detection.updateUserTone(\n        payload,\n        tone,\n        maintainToneHistoryInContext\n      );\n      assistant.message(payload, function(err, data) {\n        if (err) {\n          // APPLICATION-SPECIFIC CODE TO PROCESS THE ERROR\n          // FROM ASSISTANT SERVICE\n          console.error(JSON.stringify(err, null, 2));\n        } else {\n          // APPLICATION-SPECIFIC CODE TO PROCESS THE DATA\n          // FROM ASSISTANT SERVICE\n          console.log(JSON.stringify(data, null, 2));\n        }\n      });\n    })\n    .catch(function(err) {\n      console.log(JSON.stringify(err, null, 2));\n    });\n}", "category": "Python"}, {"instruction": "Creates an untitled document. The associated File has a fullPath that\nlooks like /some-random-string/Untitled-counter.fileExt.\n\n@param {number} counter - used in the name of the new Document's File\n@param {string} fileExt - file extension of the new Document's File, including \".\"\n@return {Document} - a new untitled Document", "input": "JavaScript", "output": "function createUntitledDocument(counter, fileExt) {\n        var filename = Strings.UNTITLED + \"-\" + counter + fileExt,\n            fullPath = _untitledDocumentPath + \"/\" + filename,\n            now = new Date(),\n            file = new InMemoryFile(fullPath, FileSystem);\n\n        FileSystem.addEntryForPathIfRequired(file, fullPath);\n\n        return new DocumentModule.Document(file, now, \"\");\n    }", "category": "Python"}, {"instruction": "Returns a JSON (array) representation", "input": "JavaScript", "output": "function toJSON() {\n  const s = [];\n  let entry = this.head;\n  while (entry) {\n    s.push({ key: entry.key.toJSON(), value: entry.value.toJSON() });\n    entry = entry.newer;\n  }\n  return s;\n}", "category": "Python"}, {"instruction": "/*------------------------------------*\\\nStyles & DOM\n\\*------------------------------------", "input": "JavaScript", "output": "function createDragger(el){\n            var state = getState(el);\n\n            var dragger = document.createElement('div');\n            var draggerStyler = document.createElement('div');\n\n            dragger.className = state.config.draggerClass;\n\n            dragger.style.position = 'absolute';\n\n            if (!state.draggerEnabled) {\n                dragger.style.display = 'none';\n            }\n\n            draggerStyler.className = state.config.draggerStylerClass;\n\n            dragger.appendChild(draggerStyler);\n            state.el1.appendChild(dragger);\n\n            return dragger;\n        }", "category": "Python"}, {"instruction": "'\\\\' . ' '*", "input": "JavaScript", "output": "function() {\n    var captures;\n    if (captures = /^\\\\(.)[ \\t]*/.exec(this.str)) {\n      var c = captures[1];\n      this.skip(captures);\n      return new Token('ident', new nodes.Literal(c));\n    }\n  }", "category": "Python"}, {"instruction": "function generateTemplateSource(html, editor, name) { var code = null; try { code = window.reactTemplates.convertTemplateToReact(html.trim().replace(/\\r/g, ''), {modules: 'none', name: name}); clearMessage(editor); } catch (e) { if (e.name === 'RTCodeError') { //index: -1 line: -1 message: \"Document should have a root element\" name: \"RTCodeError\" editor.annotate({line: e.line, message: e.message, index: e.index}); } else { editor.annotate({line: 1, message: e.message}); } //showMessage(editor, msg); console.log(e); } return code; }", "input": "JavaScript", "output": "function showMessage(editor, msg) {\n        if (editor && editor.showMessage) {\n            editor.annotate({line: 1, message: msg})\n        }\n    }", "category": "Python"}, {"instruction": "validate(values, props) -> errors", "input": "JavaScript", "output": "function validate({ username, password }, { i18n }) {\n  const errors = {}\n\n  if (!username) {\n    errors.username = i18n.t`Username is required`\n  } else if (validUsernames.indexOf(username)) {\n    errors.username = i18n.t`Sorry ${username}, you can't get in.`\n  }\n\n  return errors\n}", "category": "Python"}, {"instruction": "High-resolution timer", "input": "JavaScript", "output": "function hrtimer() {\n    const start = process.hrtime();\n\n    return () => {\n      const durationComponents = process.hrtime(start);\n      const seconds = durationComponents[0];\n      const nanoseconds = durationComponents[1];\n      const duration = (seconds * 1000) + (nanoseconds / 1E6);\n      return duration;\n    };\n  }", "category": "Python"}, {"instruction": "Retrieves help content vie the luis.json from\nthe arguments input by the user.\n\n@param args The arguments input by the user\n@returns {Promise<*>}1]", "input": "JavaScript", "output": "async function getHelpContents(args, output) {\n    if ('!' in args) {\n        return getAllCommands(process.stdout);\n    }\n\n    if (args._.length == 0) {\n        return getGeneralHelpContents(output);\n    }\n    else if (args._.length == 1) {\n        return getVerbHelp(args._[0], output);\n    } else if (args._.length >= 2) {\n        const operation = getOperation(args._[0], args._[1]);\n        if (operation) {\n            output.write(`${operation.description}\\n\\n`);\n            output.write(`Usage:\\n${chalk.cyan.bold(operation.command)}\\n\\n`);\n            return getHelpContentsForOperation(operation, output);\n        } else {\n            return getVerbHelp(args._[0], output);\n        }\n    }\n\n    return getGeneralHelpContents(output);\n}", "category": "Python"}, {"instruction": "Returns true when a named property exists.\n\n@param {String} name     The property name\n@return {Boolean}        True, when property is found", "input": "JavaScript", "output": "function(name) {\n      var props = this.jCal[PROPERTY_INDEX];\n      var len = props.length;\n\n      var i = 0;\n      for (; i < len; i++) {\n        // 0 is property name\n        if (props[i][NAME_INDEX] === name) {\n          return true;\n        }\n      }\n\n      return false;\n    }", "category": "Python"}, {"instruction": "Ensure that an array exists at [key] on `object`, and add `value` to it.\n\n@param {Object} object the object to mutate\n@param {string} key the object's key\n@param {*} value the value to add\n@returns {void}\n@private", "input": "JavaScript", "output": "function ensureArrayAndPush(object, key, value) {\n            if (!Array.isArray(object[key])) {\n                object[key] = [];\n            }\n            object[key].push(value);\n        }", "category": "Python"}, {"instruction": "Convert the keys in an `obj` using a `convert` function.\n\n@param {Object} obj\n@param {Function} convert", "input": "JavaScript", "output": "function aliasByFunction (obj, convert) {\n  // have to create another object so that ie8 won't infinite loop on keys\n  var output = {};\n  for (var key in obj) output[convert(key)] = obj[key];\n  return output;\n}", "category": "Python"}, {"instruction": "cloudant", "input": "JavaScript", "output": "function viewSearch (ddoc, viewName, qs, callback) {\n      return view(ddoc, viewName, { type: 'search' }, qs, callback)\n    }", "category": "Python"}, {"instruction": "/* eslint-disable prefer-object-spread/prefer-object-spread", "input": "JavaScript", "output": "function ReactResolver$$1(component) {\n  return isReactComponent(component) ? component : function (props) {\n    return React.createElement(VueContainer, _extends({}, props, { component: component }));\n  };\n}", "category": "Python"}, {"instruction": "Function: attach\nAttach to an already created and authenticated BOSH session.\n\nThis function is provided to allow Strophe to attach to BOSH\nsessions which have been created externally, perhaps by a Web\napplication.  This is often used to support auto-login type features\nwithout putting user credentials into the page.\n\nParameters:\n(String) jid - The full JID that is bound by the session.\n(String) sid - The SID of the BOSH session.\n(String) rid - The current RID of the BOSH session.  This RID\nwill be used by the next request.\n(Function) callback The connect callback function.\n(Integer) wait - The optional HTTPBIND wait value.  This is the\ntime the server will wait before returning an empty result for\na request.  The default setting of 60 seconds is recommended.\nOther settings will require tweaks to the Strophe.TIMEOUT value.\n(Integer) hold - The optional HTTPBIND hold value.  This is the\nnumber of connections the server will hold at one time.  This\nshould almost always be set to 1 (the default).\n(Integer) wind - The optional HTTBIND window value.  This is the\nallowed range of request ids that are valid.  The default is 5.", "input": "JavaScript", "output": "function (jid, sid, rid, callback, wait, hold, wind)\r\n    {\r\n        this._proto._attach(jid, sid, rid, callback, wait, hold, wind);\r\n    }", "category": "Python"}, {"instruction": "To authenticate using PLAIN and a simple username and password\ncombination, the application provides a callback function for\nauthenticating a connecting user given their specified username and\npassword. (The test used here - namely that the password is always\nthe username in reverse - is of course NOT recommended in practice!\n:-)", "input": "JavaScript", "output": "function authenticate(username, password) {\n    console.log('Authenticating as ' + username);\n    return username.split('').reverse().join('') === password;\n}", "category": "Python"}, {"instruction": "-------------------------------------------------------------------------- Helpers -------------------------------------------------------------------------- \nGet exact callee name from expression\n@param {ASTNode} node CallExpression or NewExpression node\n@returns {string} name", "input": "JavaScript", "output": "function extractNameFromExpression(node) {\n\n            let name = \"\";\n\n            if (node.callee.type === \"MemberExpression\") {\n                const property = node.callee.property;\n\n                if (property.type === \"Literal\" && (typeof property.value === \"string\")) {\n                    name = property.value;\n                } else if (property.type === \"Identifier\" && !node.callee.computed) {\n                    name = property.name;\n                }\n            } else {\n                name = node.callee.name;\n            }\n            return name;\n        }", "category": "Python"}, {"instruction": "Function: getColor\n\nReturns the color value for the given key in the given associative\narray or the given default value if the value is null. If the value\nis <mxConstants.NONE> then null is returned.\n\nParameters:\n\narray - Associative array that contains the value for the key.\nkey - Key whose value should be returned.\ndefaultValue - Value to be returned if the value for the given\nkey is null. Default is null.", "input": "JavaScript", "output": "function(array, key, defaultValue)\n\t{\n\t\tvar value = (array != null) ? array[key] : null;\n\n\t\tif (value == null)\n\t\t{\n\t\t\tvalue = defaultValue;\n\t\t}\n\t\telse if (value == mxConstants.NONE)\n\t\t{\n\t\t\tvalue = null;\n\t\t}\n\t\t\n\t\treturn value;\n\t}", "category": "Python"}, {"instruction": "Get a text description of the resolution based on the zoom level\nmax width of the dataset, the bins per dimension and the maximum\nzoom.\n\n@param {int} zoomLevel The current zoomLevel (e.g. 0)\n@param {int} max_width The max width\n(e.g. 2 ** maxZoom * highestResolution * binsPerDimension)\n@param {int} bins_per_dimension The number of bins per tile dimension\n(e.g. 256)\n@param {int} maxZoom The maximum zoom level for this tileset\n\n@returns {string} A formatted string representation of the zoom level\n(e.g. \"30K\")", "input": "JavaScript", "output": "function getWidthBasedResolutionText(\n  zoomLevel, maxWidth, binsPerDimension, maxZoom\n) {\n  const resolution = maxWidth / ((2 ** zoomLevel) * binsPerDimension);\n\n  // we can't display a NaN resolution\n  if (!Number.isNaN(resolution)) {\n    // what is the maximum possible resolution?\n    // this will determine how we format the lower resolutions\n    const maxResolutionSize = maxWidth / ((2 ** maxZoom) * binsPerDimension);\n\n    const pp = precisionPrefix(maxResolutionSize, resolution);\n    const f = formatPrefix(`.${pp}`, resolution);\n    const formattedResolution = f(resolution);\n\n    return formattedResolution;\n  }\n  console.warn(\n    'NaN resolution, screen is probably too small. Dimensions:',\n    this.dimensions,\n  );\n\n  return '';\n}", "category": "Python"}, {"instruction": "Checks that the line segments of this polygon do not intersect each other.\n@method isSimple\n@param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n@return {Boolean}\n@todo Should it check all segments with all others?", "input": "JavaScript", "output": "function polygonIsSimple(polygon){\n    var path = polygon, i;\n    // Check\n    for(i=0; i<path.length-1; i++){\n        for(var j=0; j<i-1; j++){\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\n                return false;\n            }\n        }\n    }\n\n    // Check the segment between the last and the first point to all others\n    for(i=1; i<path.length-2; i++){\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\n            return false;\n        }\n    }\n\n    return true;\n}", "category": "Python"}, {"instruction": "Cleans up element by removing all its invisible children (which we don't want to render as Markdown)", "input": "JavaScript", "output": "function cleanUpElement(element) {\n\t\tconst childNodes = element.childNodes;\n\n\t\tfor (let i = 0; i < childNodes.length; i++) {\n\t\t\tconst node = childNodes[i];\n\n\t\t\tlet isVisible = node.nodeType === 1 ? window.getComputedStyle(node).display !== 'none' : true;\n\t\t\tif (isVisible && ['input', 'textarea', 'script', 'noscript', 'style', 'select', 'option', 'button'].indexOf(node.nodeName.toLowerCase()) >= 0) isVisible = false;\n\n\t\t\tif (!isVisible) {\n\t\t\t\telement.removeChild(node);\n\t\t\t} else {\n\t\t\t\tcleanUpElement(node);\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Helper functions", "input": "JavaScript", "output": "function requireSecondPassword (options) {\n  return function (wallet) {\n    if (wallet.isDoubleEncrypted && !wallet.validateSecondPassword(options.second_password)) {\n      throw 'ERR_SECPASS'\n    }\n    return wallet\n  }\n}", "category": "Python"}, {"instruction": "\u6587\u4ef6\u961f\u5217, \u7528\u6765\u5b58\u50a8\u5404\u4e2a\u72b6\u6001\u4e2d\u7684\u6587\u4ef6\u3002\n@class Queue\n@extends Mediator", "input": "JavaScript", "output": "function Queue() {\n    \n            /**\n             * \u7edf\u8ba1\u6587\u4ef6\u6570\u3002\n             * * `numOfQueue` \u961f\u5217\u4e2d\u7684\u6587\u4ef6\u6570\u3002\n             * * `numOfSuccess` \u4e0a\u4f20\u6210\u529f\u7684\u6587\u4ef6\u6570\n             * * `numOfCancel` \u88ab\u79fb\u9664\u7684\u6587\u4ef6\u6570\n             * * `numOfProgress` \u6b63\u5728\u4e0a\u4f20\u4e2d\u7684\u6587\u4ef6\u6570\n             * * `numOfUploadFailed` \u4e0a\u4f20\u9519\u8bef\u7684\u6587\u4ef6\u6570\u3002\n             * * `numOfInvalid` \u65e0\u6548\u7684\u6587\u4ef6\u6570\u3002\n             * @property {Object} stats\n             */\n            this.stats = {\n                numOfQueue: 0,\n                numOfSuccess: 0,\n                numOfCancel: 0,\n                numOfProgress: 0,\n                numOfUploadFailed: 0,\n                numOfInvalid: 0\n            };\n    \n            // \u4e0a\u4f20\u961f\u5217\uff0c\u4ec5\u5305\u62ec\u7b49\u5f85\u4e0a\u4f20\u7684\u6587\u4ef6\n            this._queue = [];\n    \n            // \u5b58\u50a8\u6240\u6709\u6587\u4ef6\n            this._map = {};\n        }", "category": "Python"}, {"instruction": "Normalize all injections into Object-based format", "input": "JavaScript", "output": "function normalizeInject (options) {\n  var inject = options.inject;\n  if (Array.isArray(inject)) {\n    var normalized = options.inject = {};\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = inject[i];\n    }\n  }\n}", "category": "Python"}, {"instruction": "Add a proximity based constraint for finding objects with key point\nvalues near the point given.\n@param {String} key The key that the AV.GeoPoint is stored in.\n@param {AV.GeoPoint} point The reference AV.GeoPoint that is used.\n@return {AV.Query} Returns the query, so you can chain this call.", "input": "JavaScript", "output": "function(key, point) {\n        if (!(point instanceof AV.GeoPoint)) {\n          // Try to cast it to a GeoPoint, so that near(\"loc\", [20,30]) works.\n          point = new AV.GeoPoint(point);\n        }\n        this._addCondition(key, '$nearSphere', point);\n        return this;\n      }", "category": "Python"}, {"instruction": "Checks the origin and enables/disables CORS headers in the response.\n@param  {Object}   req express request object.\n@param  {Function} cb  callback that configures CORS.\n@return {null}", "input": "JavaScript", "output": "function handleCORS(req, cb) {\n    const origin = req.get('origin');\n    const trustedDomains = req.client && req.client.trustedDomains;\n\n    // Request must have an Origin header\n    if (!origin) {\n        return cb(null, DISABLE_CORS);\n    }\n\n    // Origin matches a client_trusted_domain\n    if (some(trustedDomains, {trusted_domain: origin})) {\n        return cb(null, ENABLE_CORS);\n    }\n\n    // Origin matches whitelist\n    if (getWhitelist().indexOf(url.parse(origin).hostname) > -1) {\n        return cb(null, ENABLE_CORS);\n    }\n\n    return cb(null, DISABLE_CORS);\n}", "category": "Python"}, {"instruction": "---------------------------------------------------------------------", "input": "JavaScript", "output": "function replaceText(id, text) {\n    var element = document.getElementById(id)\n    if (null == element) {\n//      alert(\"error: can't find element with id '\" + id + \"'\")\n        return\n    }\n\n    element.innerHTML = text\n}", "category": "Python"}, {"instruction": "Constructs a DateTimeFormatter_ object which implements the Formatter_\ninterface.\n\nInternal object to construct and store a goog.i18n.DateTimeFormat for the\na datetime pattern and formats dates using the fallback interval pattern\n(e.g. '{0} \u2013 {1}').\n\n@param {string} dateTimePattern Datetime pattern used to format the dates.\n@param {string} fallbackPattern Fallback interval pattern to be used with the\ndatetime pattern.\n@param {!DateTimeSymbolsType} dateTimeSymbols Symbols to use with\nthe datetime format.\n@constructor\n@implements {Formatter_}\n@private", "input": "JavaScript", "output": "function(\n    dateTimePattern, fallbackPattern, dateTimeSymbols) {\n  /**\n   * Date time pattern used to format the dates.\n   * @private {string}\n   */\n  this.dateTimePattern_ = dateTimePattern;\n\n  /**\n   * Date time formatter used to format the dates.\n   * @private {!DateTimeFormat}\n   */\n  this.dateTimeFormatter_ =\n      new DateTimeFormat(dateTimePattern, dateTimeSymbols);\n\n  /**\n   * Fallback interval pattern.\n   * @private {string}\n   */\n  this.fallbackPattern_ = fallbackPattern;\n}", "category": "Python"}, {"instruction": "Register mouse down to detect mouse drag.", "input": "JavaScript", "output": "function (evt) {\n    if (!this.data.enabled) { return; }\n    // Handle only primary button.\n    if (evt.button !== 0) { return; }\n\n    var sceneEl = this.el.sceneEl;\n    var canvasEl = sceneEl && sceneEl.canvas;\n\n    this.mouseDown = true;\n    this.previousMouseEvent = evt;\n    this.showGrabbingCursor();\n\n    if (this.data.pointerLockEnabled && !this.pointerLocked) {\n      if (canvasEl.requestPointerLock) {\n        canvasEl.requestPointerLock();\n      } else if (canvasEl.mozRequestPointerLock) {\n        canvasEl.mozRequestPointerLock();\n      }\n    }\n  }", "category": "Python"}, {"instruction": "Pings the given URL to check that this is a valid path.\nIf the ping is successful - redirects to the given URL.\nIf something goes wrong - falls back to a default public URL.\n@private\n@param {string} sUrl URL that needs to be pinged and redirected to\n@param {string} sTopicId The ID of the topic to open", "input": "JavaScript", "output": "function (sUrl, sTopicId) {\n\t\t\tthis._pingUrl(sUrl).then(function success() {\n\t\t\t\tmLibrary.URLHelper.redirect(sUrl, true);\n\t\t\t}, function error() {\n\t\t\t\tjQuery.sap.log.info(\"Support Assistant tried to load documentation link in \" + sUrl + \"but fail\");\n\t\t\t\tsUrl = \"https://ui5.sap.com/#/topic/\" + sTopicId;\n\t\t\t\tmLibrary.URLHelper.redirect(sUrl, true);\n\t\t\t});\n\t\t}", "category": "Python"}, {"instruction": "Get nde events\nreturn node events and optionally\ncheck if the node has already a specific event\nto avoid duplicated callbacks\n\n@param {node} node\n@param {string} name event name\n@param {object} fn callback\n@returns {object}", "input": "JavaScript", "output": "function getNodeEvents(node, name = null, fn = null) {\n    const cache = (node[uid] = node[uid] || []);\n    const data = { all: cache, evt: null, found: null};\n    if (name && fn && utils.size(cache) > 0) {\n        each(cache, (cl, i) => {\n            if (cl.eventName == name && cl.fn.toString() == fn.toString()) {\n                data.found = true;\n                data.evt = i;\n                return false;\n            }\n        })\n    }\n    return data;\n}", "category": "Python"}, {"instruction": "This method will toggle the referenced CSS class (by the provided index)\nwithin the given context.\n\n@param context The styling context that will be updated with the\nnewly provided class value.\n@param index The index of the CSS class which is being updated.\n@param addOrRemove Whether or not to add or remove the CSS class", "input": "JavaScript", "output": "function updateClassProp(context, index, addOrRemove) {\n    var adjustedIndex = index + context[4 /* ClassOffsetPosition */];\n    updateStyleProp(context, adjustedIndex, addOrRemove);\n}", "category": "Python"}, {"instruction": "BCP: 1670235674 MessageItem acts as a proxy to StandardListItem So, we should ensure if something is changed in MessageItem, it would be propagated to the StandardListItem", "input": "JavaScript", "output": "function (sName, oItem) {\n\t\t\t\t\tif (oItem._oMessagePopoverItem.getId() === this.getId() && oItem.getMetadata().getProperty(sName)) {\n\t\t\t\t\t\toItem.setProperty(sName, oValue);\n\t\t\t\t\t}\n\t\t\t\t}", "category": "Python"}, {"instruction": "@\n#.shift\n@comp Crafty.polygon\n@kind Method\n\n@sign public void .shift(Number x, Number y)\n@param x - Amount to shift the `x` axis\n@param y - Amount to shift the `y` axis\n\nShifts every single point in the polygon by the specified amount.\n\n@example\n~~~\nvar poly = new Crafty.polygon([50, 0, 100, 100, 0, 100]);\npoly.shift(5,5);\n//[[55, 5, 105, 5, 5, 105];\n~~~", "input": "JavaScript", "output": "function(x, y) {\n        var i = 0,\n            p = this.points,\n            l = p.length;\n        for (; i < l; i += 2) {\n            p[i] += x;\n            p[i + 1] += y;\n        }\n    }", "category": "Python"}, {"instruction": "Runs Typedoc command.\n\nAdditional config options come from ./typedoc.js", "input": "JavaScript", "output": "function runTypedoc() {\n  const typeSource = apiType === 'node' ? tempNodeSourcePath : sourceFile;\n  const command = `${repoPath}/node_modules/.bin/typedoc ${typeSource} \\\n  --out ${docPath} \\\n  --readme ${tempHomePath} \\\n  --options ${__dirname}/typedoc.js \\\n  --theme ${__dirname}/theme`;\n\n  console.log('Running command:\\n', command);\n  return exec(command);\n}", "category": "Python"}, {"instruction": "Checks whether a given reference is safe or not.\nThe reference is every reference of the upper scope's variable we are\nlooking now.\n\nIt's safeafe if the reference matches one of the following condition.\n- is readonly.\n- doesn't exist inside a local function and after the border.\n\n@param {eslint-scope.Reference} upperRef - A reference to check.\n@returns {boolean} `true` if the reference is safe.", "input": "JavaScript", "output": "function isSafeReference(upperRef) {\n        const id = upperRef.identifier;\n\n        return (\n            !upperRef.isWrite() ||\n            variable.scope.variableScope === upperRef.from.variableScope &&\n            id.range[0] < border\n        );\n    }", "category": "Python"}, {"instruction": "Pushs a variable scope (Program or Function) information to the stack.\n\nThis is used in order to check whether or not `this` binding is a\nreference to the global object.\n\n@param {ASTNode} node - A node of the scope. This is one of Program,\nFunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.\n@returns {void}", "input": "JavaScript", "output": "function enterVarScope(node) {\n            const strict = context.getScope().isStrict;\n\n            funcInfo = {\n                upper: funcInfo,\n                node,\n                strict,\n                defaultThis: false,\n                initialized: strict\n            };\n        }", "category": "Python"}, {"instruction": "/* Event maniupluation\n================================================== Add an event", "input": "JavaScript", "output": "function(data) {\n\t\tvar unique_id = this.config.addEvent(data);\n\n\t\tvar n = this._getEventIndex(unique_id);\n\t\tvar d = this.config.events[n];\n\n\t\tthis._storyslider.createSlide(d, this.config.title ? n+1 : n);\n\t\tthis._storyslider._updateDrawSlides();\n\n\t\tthis._timenav.createMarker(d, n);\n\t\tthis._timenav._updateDrawTimeline(false);\n\n\t\tthis.fire(\"added\", {unique_id: unique_id});\n\t}", "category": "Python"}, {"instruction": "Function comparing an object's properties to a given descriptive\nobject.\n\n@param  {object} object      - The object to compare.\n@param  {object} description - The description's mapping.\n@return {boolean}            - Whether the object matches the description.", "input": "JavaScript", "output": "function compare(object, description) {\n  let ok = true,\n      k;\n\n  // If we reached here via a recursive call, object may be undefined because\n  // not all items in a collection will have the same deep nesting structure.\n  if (!object)\n    return false;\n\n  for (k in description) {\n    if (type.object(description[k])) {\n      ok = ok && compare(object[k], description[k]);\n    }\n    else if (type.array(description[k])) {\n      ok = ok && !!~description[k].indexOf(object[k]);\n    }\n    else {\n      if (object[k] !== description[k])\n        return false;\n    }\n  }\n\n  return ok;\n}", "category": "Python"}, {"instruction": "Get the bounding box (width, height, x and y) for the element", "input": "JavaScript", "output": "function () {\r\n\t\tvar bBox,\r\n\t\t\twidth,\r\n\t\t\theight,\r\n\t\t\trotation = this.rotation,\r\n\t\t\trad = rotation * deg2rad;\r\n\r\n\t\ttry { // fails in Firefox if the container has display: none\r\n\t\t\t// use extend because IE9 is not allowed to change width and height in case\r\n\t\t\t// of rotation (below)\r\n\t\t\tbBox = extend({}, this.element.getBBox());\r\n\t\t} catch (e) {\r\n\t\t\tbBox = { width: 0, height: 0 };\r\n\t\t}\r\n\t\twidth = bBox.width;\r\n\t\theight = bBox.height;\r\n\r\n\t\t// adjust for rotated text\r\n\t\tif (rotation) {\r\n\t\t\tbBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));\r\n\t\t\tbBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));\r\n\t\t}\r\n\r\n\t\treturn bBox;\r\n\t}", "category": "Python"}, {"instruction": "Returns the encoded vast url if it exists on a bid object, only if prebid-cache\nis disabled, and description_url is not already set on a given input\n@param {AdapterBidResponse} bid object to check for vast url\n@param {Object} components the object to check that description_url is NOT set on\n@param {string} prop the property of components that would contain description_url\n@return {string | undefined} The encoded vast url if it exists, or undefined", "input": "JavaScript", "output": "function getDescriptionUrl(bid, components, prop) {\n  if (config.getConfig('cache.url')) { return; }\n\n  if (!deepAccess(components, `${prop}.description_url`)) {\n    const vastUrl = bid && bid.vastUrl;\n    if (vastUrl) { return encodeURIComponent(vastUrl); }\n  } else {\n    logError(`input cannnot contain description_url`);\n  }\n}", "category": "Python"}, {"instruction": "renders slider using CSS background ;)", "input": "JavaScript", "output": "function draw(attrsModified) {\n    calc();\n    if (isChanged && value != prevValue)\n      slider.dispatchEvent(onChange);\n    isChanged = false;\n    if (!attrsModified && value == prevValue)\n      return;\n    prevValue = value;\n    var position = range ? (value - min) / range * 100 : 0;\n    var bg = '-moz-element(#__sliderthumb__) ' + position + '% no-repeat, ';\n    style(slider, { background: bg + track });\n  }", "category": "Python"}, {"instruction": "Properties of a Timestamp.\n@memberof google.protobuf\n@interface ITimestamp\n@property {number|null} [seconds] Timestamp seconds\n@property {number|null} [nanos] Timestamp nanos\n \nConstructs a new Timestamp.\n@memberof google.protobuf\n@classdesc Represents a Timestamp.\n@implements ITimestamp\n@constructor\n@param {google.protobuf.ITimestamp=} [properties] Properties to set", "input": "JavaScript", "output": "function Timestamp(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }", "category": "Python"}, {"instruction": "PKCS#1 (OAEP) mask generation function", "input": "JavaScript", "output": "function oaep_mgf1_arr(seed, len, hash)\n{\n    var mask = '', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(String.fromCharCode.apply(String, seed.concat([\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff])));\n        i += 1;\n    }\n\n    return mask;\n}", "category": "Python"}, {"instruction": "/* eslint-disable-next-line no-unused-vars", "input": "JavaScript", "output": "function stylesheetOverride(stylesheet, props, themeData) {\n  return {\n    ...stylesheet,\n    pointerBorder: { fill: themeData[\"tooltip.backgroundColor\"] },\n    pointerBody: { fill: themeData[\"tooltip.backgroundColor\"] }\n  };\n}", "category": "Python"}, {"instruction": "/*\nFinds the edge with the smallest slack that is incident on tree and returns\nit.", "input": "JavaScript", "output": "function findMinSlackEdge(t, g) {\n  return _.minBy(g.edges(), function(e) {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return slack(g, e);\n    }\n  });\n}", "category": "Python"}, {"instruction": "It clones original object into the new one. It is necessary to retain the options information valid\nfor all nodes.\n@param original Object to clone\n@returns {Object} Cloned object", "input": "JavaScript", "output": "function (original) {\n                var clone = {};\n                var i, keys = Object.keys(original);\n\n                for (i = 0; i < keys.length; i++) {\n                    // copy each property into the clone\n                    clone[keys[i]] = original[keys[i]];\n                }\n\n                return clone;\n            }", "category": "Python"}, {"instruction": "Matches curly braces content right after given position\n@param  {String} content CSS content. Must not contain comments!\n@param  {Number} pos     Search start position\n@return {Range}", "input": "JavaScript", "output": "function(content, pos, sanitize) {\n\t\t\tif (sanitize) {\n\t\t\t\tcontent = this.sanitize(content);\n\t\t\t}\n\n\t\t\tvar stream = stringStream(content);\n\t\t\tstream.start = stream.pos = pos;\n\t\t\tvar stack = [], ranges = [];\n\t\t\tvar ch;\n\t\t\twhile (ch = stream.next()) {\n\t\t\t\tif (ch == '{') {\n\t\t\t\t\tstack.push(stream.pos - 1);\n\t\t\t\t} else if (ch == '}') {\n\t\t\t\t\tif (!stack.length) {\n\t\t\t\t\t\tthrow 'Invalid source structure (check for curly braces)';\n\t\t\t\t\t}\n\t\t\t\t\tranges.push(range.create2(stack.pop(), stream.pos));\n\t\t\t\t\tif (!stack.length) {\n\t\t\t\t\t\treturn ranges;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstream.skipQuoted();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ranges;\n\t\t}", "category": "Python"}, {"instruction": "Create a button that when clicked will enter into stereo-rendering mode for VR.\n\nStructure: <div><button></div>\n\n@param {function} onClick - click event handler\n@returns {Element} Wrapper <div>.", "input": "JavaScript", "output": "function createEnterVRButton (onClick) {\n  var vrButton;\n  var wrapper;\n\n  // Create elements.\n  wrapper = document.createElement('div');\n  wrapper.classList.add(ENTER_VR_CLASS);\n  wrapper.setAttribute(constants.AFRAME_INJECTED, '');\n  vrButton = document.createElement('button');\n  vrButton.className = ENTER_VR_BTN_CLASS;\n  vrButton.setAttribute('title',\n    'Enter VR mode with a headset or fullscreen mode on a desktop. ' +\n    'Visit https://webvr.rocks or https://webvr.info for more information.');\n  vrButton.setAttribute(constants.AFRAME_INJECTED, '');\n\n  // Insert elements.\n  wrapper.appendChild(vrButton);\n  vrButton.addEventListener('click', function (evt) {\n    onClick();\n    evt.stopPropagation();\n  });\n  return wrapper;\n}", "category": "Python"}, {"instruction": "Sort children nodes\n\n@param {TreeNode[]}               children children of node to be sorted\n@param {string | function | null} sort sort method\nSee SunburstSeries.js for details.", "input": "JavaScript", "output": "function sort(children, sortOrder) {\n    if (typeof sortOrder === 'function') {\n        return children.sort(sortOrder);\n    }\n    else {\n        var isAsc = sortOrder === 'asc';\n        return children.sort(function (a, b) {\n            var diff = (a.getValue() - b.getValue()) * (isAsc ? 1 : -1);\n            return diff === 0\n                ? (a.dataIndex - b.dataIndex) * (isAsc ? -1 : 1)\n                : diff;\n        });\n    }\n}", "category": "Python"}, {"instruction": "/*\nOutputs a log message for the given level. Leads to an <code>undefined</code> result\nin case of a WARNING.\n\n@param {sap.base.Log.Level} iLevel\nA log level, either DEBUG or WARNING\n@param {...string} aTexts\nThe main text of the message is constructed from the rest of the arguments by\njoining them\n@returns {boolean}\n<code>false</code>", "input": "JavaScript", "output": "function log(iLevel) {\n\t\t\t\tvar sLocation;\n\n\t\t\t\tif (Log.isLoggable(iLevel, sODataMetaModel)) {\n\t\t\t\t\tsLocation = Array.isArray(vLocation)\n\t\t\t\t\t\t? vLocation.join(\"/\")\n\t\t\t\t\t\t: vLocation;\n\t\t\t\t\tLog[iLevel === DEBUG ? \"debug\" : \"warning\"](\n\t\t\t\t\t\tArray.prototype.slice.call(arguments, 1).join(\"\")\n\t\t\t\t\t\t\t+ (sLocation ? \" at /\" + sLocation : \"\"),\n\t\t\t\t\t\tsResolvedPath, sODataMetaModel);\n\t\t\t\t}\n\t\t\t\tif (iLevel === WARNING) {\n\t\t\t\t\tvResult = undefined;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}", "category": "Python"}, {"instruction": "first pass to try to find fields that will need to be sorted in-memory", "input": "JavaScript", "output": "function getBasicInMemoryFields(index, selector, userFields) {\n\n  userFields = sortFieldsByIndex(userFields, index);\n\n  // check if any of the user selectors lose precision\n  var needToFilterInMemory = false;\n  for (var i = 0, len = userFields.length; i < len; i++) {\n    var field = userFields[i];\n    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n      return userFields.slice(i);\n    }\n    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n      needToFilterInMemory = true;\n    }\n  }\n  return [];\n}", "category": "Python"}, {"instruction": "returns an object with event handlers used at addDomListener", "input": "JavaScript", "output": "function createBindingHandlers({\n    fullEventName,\n    domEventHandler,\n    selector\n}) {\n    return {\n        bindHandler(evt = {}) {\n            const { node } = evt;\n            if (node) {\n                dom.$(node).on(fullEventName, selector, domEventHandler);\n            }\n        },\n        unbindHandler(evt = {}) {\n            const { node } = evt;\n            if (node) {\n                dom.$(node).off(fullEventName, selector, domEventHandler);\n            }\n        }\n    };\n}", "category": "Python"}, {"instruction": "fitty creation function", "input": "JavaScript", "output": "function fitty(target) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    // if target is a string\n    return typeof target === 'string' ?\n\n    // treat it as a querySelector\n    fittyCreate(toArray(document.querySelectorAll(target)), options) :\n\n    // create single fitty\n    fittyCreate([target], options)[0];\n  }", "category": "Python"}, {"instruction": "The 64-bit implementation of the NIST specified Sigma1 function\n\n@private\n@param {Int_64} x The 64-bit integer argument\n@return {Int_64} The NIST specified output of the function", "input": "JavaScript", "output": "function sigma1_64(x)\n\t{\n\t\tvar rotr14 = rotr_64(x, 14), rotr18 = rotr_64(x, 18),\n\t\t\trotr41 = rotr_64(x, 41);\n\n\t\treturn new Int_64(\n\t\t\t\trotr14.highOrder ^ rotr18.highOrder ^ rotr41.highOrder,\n\t\t\t\trotr14.lowOrder ^ rotr18.lowOrder ^ rotr41.lowOrder);\n\t}", "category": "Python"}, {"instruction": "Tests whether a batch can be started.\n@private\n@param {number[]} batch_ops The operations in the batch we are checking.\n@param {number[]} completed_ops Previously completed operations.\n@return {boolean}", "input": "JavaScript", "output": "function _areBatchRequirementsMet(batch_ops, completed_ops) {\n  var dependencies = common.flatMap(batch_ops, function(op) {\n    return OP_DEPENDENCIES[op] || [];\n  });\n  for (var i = 0; i < dependencies.length; i++) {\n    var required_dep = dependencies[i];\n    if (batch_ops.indexOf(required_dep) === -1 &&\n        completed_ops.indexOf(required_dep) === -1) {\n      return false;\n    }\n  }\n  return true;\n}", "category": "Python"}, {"instruction": "Determine if provided node is the last of their parent block.\n@private\n@param {ASTNode} node - node to test\n@returns {boolean} True if `node` is last of their parent block.", "input": "JavaScript", "output": "function isLastNode(node) {\n            const token = sourceCode.getTokenAfter(node);\n\n            return !token || (token.type === \"Punctuator\" && token.value === \"}\");\n        }", "category": "Python"}, {"instruction": "/*\nclass <className> () {}", "input": "JavaScript", "output": "function (node) {\n                _addResult(node);\n                ASTWalker.simple(node, {\n                    /*\n                        class <className> () {\n                            <methodName> () {\n                            \n                            }\n                        }\n                    */\n                    MethodDefinition: function (methodNode) {\n                        _addResult(methodNode, methodNode.key.start, node.id.name);\n                    }\n                });\n            }", "category": "Python"}, {"instruction": "checks if selector targets a tag\n@param  {String} selector the selector\n@return {Boolean}         if the selector targets a tag", "input": "JavaScript", "output": "function targetsTag (selector) {\n  const selectors = simpleSelectorParser.process(selector).res\n\n  return selectors.filter((selector) => {\n    let selectorNodes = selector.nodes.concat([]).reverse() // clone the array\n\n    for (const node of selectorNodes) {\n      if (node.type === 'cominator') { break }\n\n      if (node.type === 'tag') { return true }\n    }\n\n    return false\n  }).length > 0\n}", "category": "Python"}, {"instruction": "\u83b7\u53d6\u6587\u7ae0\u7684\u914d\u7f6e\u53c2\u6570\uff0c\u5728\u6587\u7ae0\u5934\u90e8\u901a\u8fc7[key]: value \u7684\u5f62\u5f0f\n@param  {String} body \u6587\u7ae0\u5185\u5bb9\n[intro]: \u6587\u7ae0\u7684\u4ecb\u7ecd\u6587\u7ae0\u7684\u4ecb\u7ecd\u6587\u7ae0\u7684\u4ecb\u7ecd\n@return {Object}      \u6587\u7ae0\u7684\u914d\u7f6e\u53c2\u6570", "input": "JavaScript", "output": "function getPostQuery(body) {\n  if (!body) return {};\n\n  let result = {};\n  let commentReg = /^\\[(\\w+)\\]\\:([\\s|\\S]+)/;\n  body.split('\\r\\n').every((item) => {\n    let itemMatch = item.match(commentReg);\n    if (itemMatch && itemMatch.length == 3) {\n      let queryKey = itemMatch[1],\n        queryVal = itemMatch[2];\n      result[queryKey] = queryVal && queryVal.trim();\n      return true;\n    } else {\n      return false;\n    }\n  })\n\n  return result;\n}", "category": "Python"}, {"instruction": "Parse length(L) field of BER TLV\n@param s {type.Stream}\n@returns {integer}", "input": "JavaScript", "output": "function decodeLength(s) {\n\tvar size = new type.UInt8().read(s).value;\n\tif(size & 0x80) {\n\t\tsize &= ~0x80;\n\t\tif(size === 1) {\n\t\t\tsize = new type.UInt8().read(s).value;\n\t\t}\n\t\telse if(size === 2) {\n\t\t\tsize = new type.UInt16Be().read(s).value;\n\t\t}\n\t\telse{\n\t\t\tthrow new error.ProtocolError('NODE_RDP_ASN1_BER_INVALID_LENGTH');\n\t\t}\n\t}\n\treturn size;\n}", "category": "Python"}, {"instruction": "Apply median filter.\nWhen used without parameters the default window is 3x3.\n@param {Number} [size=3] square mask size: size x size\n@returns {Sharp}\n@throws {Error} Invalid parameters", "input": "JavaScript", "output": "function median (size) {\n  if (!is.defined(size)) {\n    // No arguments: default to 3x3\n    this.options.medianSize = 3;\n  } else if (is.integer(size) && is.inRange(size, 1, 1000)) {\n    // Numeric argument: specific sigma\n    this.options.medianSize = size;\n  } else {\n    throw new Error('Invalid median size ' + size);\n  }\n  return this;\n}", "category": "Python"}, {"instruction": "do x=floor(x/n) for bigInt x and integer n, and return the remainder", "input": "JavaScript", "output": "function divInt_(x, n) {\n  var i, r=0, s;\n  for (i=x.length-1; i>=0; i--) {\n    s=r*radix+x[i];\n    x[i]=Math.floor(s/n);\n    r=s%n;\n  }\n  return r;\n}", "category": "Python"}, {"instruction": "\u5220\u9664\u7701\u8282\u70b9\u4e0b\u6240\u6709\u7684\u5b50\u8282\u70b9\n\n@param {any} [data=[]]\n@returns", "input": "JavaScript", "output": "function removeChildren(data = []) {\n  const ds = cloneDeep(data);\n  ds.forEach((item) => {\n    if (item.children) delete item.children;\n  });\n  return ds;\n}", "category": "Python"}, {"instruction": "Handle the response from the tern node domain when\nit responds with the definition\n\n@param response - the response from the node domain", "input": "JavaScript", "output": "function handleJumptoDef(response) {\n\n        var file = response.file,\n            offset = response.offset;\n\n        var $deferredJump = getPendingRequest(file, offset, MessageIds.TERN_JUMPTODEF_MSG);\n\n        if ($deferredJump) {\n            response.fullPath = getResolvedPath(response.resultFile);\n            $deferredJump.resolveWith(null, [response]);\n        }\n    }", "category": "Python"}, {"instruction": "12.2.5.4.2 The \"before html\" insertion mode ------------------------------------------------------------------", "input": "JavaScript", "output": "function startTagBeforeHtml(p, token) {\n    if (token.tagName === $.HTML) {\n        p._insertElement(token, NS.HTML);\n        p.insertionMode = BEFORE_HEAD_MODE;\n    }\n\n    else\n        tokenBeforeHtml(p, token);\n}", "category": "Python"}, {"instruction": "Removes the given value from the history values.\n\n@private", "input": "JavaScript", "output": "function(sValue) {\n\t\t\tvar aHistory = this._initHistory();\n\t\t\tfor (var i = 0; i < aHistory.length; i++) {\n\t\t\t\tif (aHistory[i] == sValue) {\n\t\t\t\t\taHistory.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}", "category": "Python"}, {"instruction": "Focus on the open extension tab", "input": "JavaScript", "output": "function focusTab(tabId) {\n    var updateProperties = { \"active\": true };\n    chrome.tabs.update(tabId, updateProperties, function (tab) { });\n  }", "category": "Python"}, {"instruction": "Populate `_hostNode` on the rendered host/text component with the given\nDOM node. The passed `inst` can be a composite.", "input": "JavaScript", "output": "function precacheNode(inst, node) {\n  var hostInst = getRenderedHostOrTextFromComponent(inst);\n  hostInst._hostNode = node;\n  node[internalInstanceKey] = hostInst;\n}", "category": "Python"}, {"instruction": "Function: create\n\nCreates the cell path for the given cell. The cell path is a\nconcatenation of the indices of all ancestors on the (finite) path to\nthe root, eg. \"0.0.0.1\".\n\nParameters:\n\ncell - Cell whose path should be returned.", "input": "JavaScript", "output": "function(cell)\n\t{\n\t\tvar result = '';\n\t\t\n\t\tif (cell != null)\n\t\t{\n\t\t\tvar parent = cell.getParent();\n\t\t\t\n\t\t\twhile (parent != null)\n\t\t\t{\n\t\t\t\tvar index = parent.getIndex(cell);\n\t\t\t\tresult = index + mxCellPath.PATH_SEPARATOR + result;\n\t\t\t\t\n\t\t\t\tcell = parent;\n\t\t\t\tparent = cell.getParent();\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Removes trailing separator\n\t\tvar n = result.length;\n\t\t\n\t\tif (n > 1)\n\t\t{\n\t\t\tresult = result.substring(0, n - 1);\n\t\t}\n\t\t\n\t\treturn result;\n\t}", "category": "Python"}, {"instruction": "isn't it redundant? app.listen(8888);", "input": "JavaScript", "output": "function writeToDisk(dataURL, fileName) {\n    var fileExtension = fileName.split('.').pop(),\n        fileRootNameWithBase = './uploads/' + fileName,\n        filePath = fileRootNameWithBase,\n        fileID = 2,\n        fileBuffer;\n\n    // @todo return the new filename to client\n    while (fs.existsSync(filePath)) {\n        filePath = fileRootNameWithBase + '(' + fileID + ').' + fileExtension;\n        fileID += 1;\n    }\n\n    dataURL = dataURL.split(',').pop();\n    fileBuffer = new Buffer(dataURL, 'base64');\n    fs.writeFileSync(filePath, fileBuffer);\n\n    console.log('filePath', filePath);\n}", "category": "Python"}, {"instruction": "override", "input": "JavaScript", "output": "function($super, rawData, fieldInfo, properties) {\n            // at the moment disabling \"total count\" mode, need a more sophisticated way to handle it\n            if(false && rawData.series['_tc'] && rawData.series['_tc'].length > 0) {\n                this.useTotalCount = true;\n                this.totalCount = parseInt(rawData.series['_tc'][0].rawY, 10);\n            }\n            else {\n                this.useTotalCount = false;\n            }\n            $super(rawData, fieldInfo, properties);\n        }", "category": "Python"}, {"instruction": "Converts Array or ArrayBuffer to string\n@param {Array|Uint8Array|ArrayBuffer} arr\n@return {string}", "input": "JavaScript", "output": "function bytesToString(arr) {\n    if (arr instanceof ArrayBuffer) {\n        arr = new Uint8Array(arr);\n    }\n    return textDecoder.decode(arr);\n}", "category": "Python"}, {"instruction": "*\n@method every([ms] = 1, [arg1], [arg2], ...)\n@returns Function\n@short Executes the function every `ms` milliseconds.\n@extra Returns a reference to itself. `every` uses `setTimeout`, which\nmeans that you are guaranteed a period of idle time equal to [ms]\nafter execution has finished. Compare this to `setInterval` which\nwill try to run a function every [ms], even when execution itself\ntakes up a portion of that time. In most cases avoiding `setInterval`\nis better as calls won't \"back up\" when the CPU is under strain,\nhowever this also means that calls are less likely to happen at\nexact intervals of [ms], so the use case here should be considered.\nAdditionally, `every` can curry arguments passed in after [ms], and\nalso be canceled with `cancel`.\n\n@example\n\nlogHello.every(1000)        -> logs every second\nlogArgs.every(1000, 'Hola') -> logs 'hola' every second\n\n@param {number} [ms]\n@param {any} [arg1]\n@param {any} [arg2]\n\n*", "input": "JavaScript", "output": "function(fn, ms, args) {\n    function execute () {\n      // Set the delay first here, so that cancel\n      // can be called within the executing function.\n      setDelay(fn, ms, execute);\n      fn.apply(fn, args);\n    }\n    setDelay(fn, ms, execute);\n    return fn;\n  }", "category": "Python"}, {"instruction": "Set the opacity of the drawer.\n@param {Number} opacity\n@return {OpenSeadragon.Drawer} Chainable.", "input": "JavaScript", "output": "function( opacity ) {\n        $.console.error(\"drawer.setOpacity is deprecated. Use tiledImage.setOpacity instead.\");\n        var world = this.viewer.world;\n        for (var i = 0; i < world.getItemCount(); i++) {\n            world.getItemAt( i ).setOpacity( opacity );\n        }\n        return this;\n    }", "category": "Python"}, {"instruction": "draw the image layer\n@ignore", "input": "JavaScript", "output": "function (renderer) {\n            var viewport = me.game.viewport,\n                width = this.imagewidth,\n                height = this.imageheight,\n                bw = viewport.bounds.width,\n                bh = viewport.bounds.height,\n                ax = this.anchorPoint.x,\n                ay = this.anchorPoint.y,\n                x = this.pos.x,\n                y = this.pos.y;\n\n            if (this.ratio.x === this.ratio.y === 0) {\n                x = x + ax * (bw - width);\n                y = y + ay * (bh - height);\n            }\n\n            renderer.translate(x, y);\n            renderer.drawPattern(\n                this._pattern,\n                0,\n                0,\n                viewport.width * 2,\n                viewport.height * 2\n            );\n        }", "category": "Python"}, {"instruction": "A ResourceStream is a Node stream implementation for objects that are\nfetched from the API. Basically, any Collection of resources from the\nAPI can be wrapped in this stream, and the stream will fetch new pages\nof items as needed.\n\n@param {Collection} collection Response from initial collection request.\n@constructor", "input": "JavaScript", "output": "function ResourceStream(collection) {\n  var me = this;\n  BufferedReadable.call(me, {\n    objectMode: true\n  });\n\n  // @type {Collection} The collection whose data was last pushed into the\n  //     stream, such that if we have to go back for more, we should fetch\n  //     its `nextPage`.\n  me._collection = collection;\n\n  // @type {boolean} True iff a request for more items is in flight.\n  me._fetching = false;\n\n  // Ensure the initial collection's data is in the stream.\n  me._pushCollection();\n}", "category": "Python"}, {"instruction": "Get server type form request message.", "input": "JavaScript", "output": "function(route) {\n  if (!route) {\n    return null;\n  }\n  var idx = route.indexOf('.');\n  if (idx < 0) {\n    return null;\n  }\n  return route.substring(0, idx);\n}", "category": "Python"}, {"instruction": "Get style\n\n@param {Object} options\n@api private", "input": "JavaScript", "output": "function getStyle(options) {\n  var styles = {\n    nested: 0,\n    expanded: 1,\n    compact: 2,\n    compressed: 3\n  };\n\n  return styles[options.outputStyle] || 0;\n}", "category": "Python"}, {"instruction": "@class errors.QueryResultError\n@augments external:Error\n@description\n\nThis error is specified as the rejection reason for all result-specific methods when the result doesn't match\nthe expectation, i.e. when a query result doesn't match its Query Result Mask - the value of {@link queryResult}.\n\nThe error applies to the result from the following methods: {@link Database#none none},\n{@link Database#one one}, {@link Database#oneOrNone oneOrNone} and {@link Database#many many}.\n\nSupported errors:\n\n- `No return data was expected.`, method {@link Database#none none}\n- `No data returned from the query.`, methods {@link Database#one one} and {@link Database#many many}\n- `Multiple rows were not expected.`, methods {@link Database#one one} and {@link Database#oneOrNone oneOrNone}\n\nLike any other error, this one is notified with through the global event {@link event:error error}.\n\nThe type is available from the {@link errors} namespace.\n\n@property {string} name\nStandard {@link external:Error Error} property - error type name = `QueryResultError`.\n\n@property {string} message\nStandard {@link external:Error Error} property - the error message.\n\n@property {string} stack\nStandard {@link external:Error Error} property - the stack trace.\n\n@property {object} result\nThe original $[Result] object that was received.\n\n@property {number} received\nTotal number of rows received. It is simply the value of `result.rows.length`.\n\n@property {number} code\nError code - {@link errors.queryResultErrorCode queryResultErrorCode} value.\n\n@property {string} query\nQuery that was executed.\n\nNormally, it is the query already formatted with values, if there were any.\nBut if you are using initialization option `pgFormatting`, then the query string is before formatting.\n\n@property {*} values\nValues passed in as query parameters. Available only when initialization option `pgFormatting` is used.\nOtherwise, the values are within the pre-formatted `query` string.\n\n@example\n\nconst QueryResultError = pgp.errors.QueryResultError;\nconst qrec = pgp.errors.queryResultErrorCode;\n\nconst initOptions = {\n\n// pg-promise initialization options...\n\nerror: (err, e) => {\nif (err instanceof QueryResultError) {\n// A query returned unexpected number of records, and thus rejected;\n\n// we can check the error code, if we want specifics:\nif(err.code === qrec.noData) {\n// expected some data, but received none;\n}\n\n// If you write QueryResultError into the console,\n// you will get a nicely formatted output.\n\nconsole.log(err);\n\n// See also: err, e.query, e.params, etc.\n}\n}\n};\n\n@see\n{@link queryResult}, {@link Database#none none}, {@link Database#one one},\n{@link Database#oneOrNone oneOrNone}, {@link Database#many many}", "input": "JavaScript", "output": "function QueryResultError(code, result, query, values) {\n    const temp = Error.apply(this, arguments);\n    temp.name = this.name = 'QueryResultError';\n    this.stack = temp.stack;\n    this.message = errorMessages[code].message;\n    this.code = code;\n    this.result = result;\n    this.query = query;\n    this.values = values;\n    this.received = result.rows.length;\n}", "category": "Python"}, {"instruction": "/*\nGets the URL for the specified remote of a repo", "input": "JavaScript", "output": "function getRemoteUrl(repo, remote) {\n  return wrapPromise(function (resolve, reject) {\n    repo.config(function (err, config) {\n      if (err) {\n        reject(new Error('Failed to find git repository in ' + config.path))\n        return\n      }\n\n      resolve(config.items['remote.' + remote + '.url'])\n    })\n  })\n}", "category": "Python"}, {"instruction": "add multiple items to the list via BindingContext", "input": "JavaScript", "output": "function(aContexts, oBindingInfo, bSuppressInvalidate) {\n\t\t\tfor (var i = 0; i < aContexts.length; i++) {\n\t\t\t\tthis.addListItem(aContexts[i], oBindingInfo, bSuppressInvalidate);\n\t\t\t}\n\t\t}", "category": "Python"}, {"instruction": "Private function, gets a Unicode code point from a JavaScript UTF-16 string handling surrogate pairs appropriately", "input": "JavaScript", "output": "function codePointAt(str, idx){\n\t\tif(idx === undefined){\n\t\t\tidx = 0;\n\t\t}\n\t\tvar code = str.charCodeAt(idx);\n\n\t\t// if a high surrogate\n\t\tif (0xD800 <= code && code <= 0xDBFF && \n\t\t\tidx < str.length - 1){\n\t\t\tvar hi = code;\n\t\t\tvar low = str.charCodeAt(idx + 1);\n\t\t\tif (0xDC00 <= low && low <= 0xDFFF){\n\t\t\t\treturn ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n\t\t\t}\n\t\t\treturn hi;\n\t\t}\n\t\t\n\t\t// if a low surrogate\n\t\tif (0xDC00 <= code && code <= 0xDFFF &&\n\t\t\tidx >= 1){\n\t\t\tvar hi = str.charCodeAt(idx - 1);\n\t\t\tvar low = code;\n\t\t\tif (0xD800 <= hi && hi <= 0xDBFF){\n\t\t\t\treturn ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n\t\t\t}\n\t\t\treturn low;\n\t\t}\n\t\t\n\t\t//just return the char if an unmatched surrogate half or a \n\t\t//single-char codepoint\n\t\treturn code;\n\t}", "category": "Python"}, {"instruction": "Returns deepest child of current section (or section itself)\nwhich includes given position.\n@param  {Number} pos\n@return {CSSSection}", "input": "JavaScript", "output": "function(pos) {\n\t\t\tif (!this.range.inside(pos)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfor (var i = 0, il = this.children.length, m; i < il; i++) {\n\t\t\t\tm = this.children[i].matchDeep(pos);\n\t\t\t\tif (m) {\n\t\t\t\t\treturn m;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn this.parent ? this : null;\n\t\t}", "category": "Python"}, {"instruction": "Block to repeat until a condition becomes true.\n@this Blockly.Block", "input": "JavaScript", "output": "function() {\n    this.jsonInit({\n      \"message0\": Blockly.Msg.CONTROL_REPEATUNTIL,\n      \"message1\": \"%1\",\n      \"message2\": \"%1\",\n      \"lastDummyAlign2\": \"RIGHT\",\n      \"args0\": [\n        {\n          \"type\": \"input_value\",\n          \"name\": \"CONDITION\",\n          \"check\": \"Boolean\"\n        }\n      ],\n      \"args1\": [\n        {\n          \"type\": \"input_statement\",\n          \"name\": \"SUBSTACK\"\n        }\n      ],\n      \"args2\": [\n        {\n          \"type\": \"field_image\",\n          \"src\": Blockly.mainWorkspace.options.pathToMedia + \"repeat.svg\",\n          \"width\": 24,\n          \"height\": 24,\n          \"alt\": \"*\",\n          \"flip_rtl\": true\n        }\n      ],\n      \"category\": Blockly.Categories.control,\n      \"extensions\": [\"colours_control\", \"shape_statement\"]\n    });\n  }", "category": "Python"}, {"instruction": "Clear all elements.\n\n@private", "input": "JavaScript", "output": "function () {\n        var elMap = this._elMap;\n        elMap.each(function (el) {\n            removeEl(el, elMap);\n        });\n        this._elMap = zrUtil.createHashMap();\n    }", "category": "Python"}, {"instruction": "Stroke a line of the given two points\n@name strokeLine\n@memberOf me.CanvasRenderer.prototype\n@function\n@param {Number} startX the start x coordinate\n@param {Number} startY the start y coordinate\n@param {Number} endX the end x coordinate\n@param {Number} endY the end y coordinate", "input": "JavaScript", "output": "function (startX, startY, endX, endY) {\n            var context = this.backBufferContext2D;\n\n            if (context < 1 / 255) {\n                // Fast path: don't draw fully transparent\n                return;\n            }\n\n            context.beginPath();\n            context.moveTo(startX, startY);\n            context.lineTo(endX, endY);\n            context.stroke();\n        }", "category": "Python"}, {"instruction": "Calls the provided DOM property descriptor and returns its result. If the\ndescriptor is not available, use fallbackPropertyName to get the property\nvalue in a clobber-vulnerable way, and use fallbackTest to check if the\nproperty was clobbered, throwing an exception if so.\n@param {?Function} fn\n@param {*} object\n@param {string} fallbackPropertyName\n@param {function(*):boolean} fallbackTest\n@return {?}", "input": "JavaScript", "output": "function genericPropertyGet(fn, object, fallbackPropertyName, fallbackTest) {\n  if (fn) {\n    return fn.apply(object);\n  }\n  var propertyValue = object[fallbackPropertyName];\n  if (!fallbackTest(propertyValue)) {\n    throw new Error('Clobbering detected');\n  }\n  return propertyValue;\n}", "category": "Python"}, {"instruction": "Point towards drop-down menu.\n@this Blockly.Block", "input": "JavaScript", "output": "function() {\n    this.jsonInit({\n      \"message0\": \"%1\",\n      \"args0\": [\n        {\n          \"type\": \"field_dropdown\",\n          \"name\": \"TOWARDS\",\n          \"options\": [\n            [Blockly.Msg.MOTION_POINTTOWARDS_POINTER, '_mouse_'],\n            [Blockly.Msg.MOTION_POINTTOWARDS_RANDOM, '_random_']\n          ]\n        }\n      ],\n      \"colour\": Blockly.Colours.motion.secondary,\n      \"colourSecondary\": Blockly.Colours.motion.secondary,\n      \"colourTertiary\": Blockly.Colours.motion.tertiary,\n      \"extensions\": [\"output_string\"]\n    });\n  }", "category": "Python"}, {"instruction": "Writes the additonal style HTML into the rendermanger (see renderStep)", "input": "JavaScript", "output": "function(rm, sId, iIdx){\n\t\trm.write(\"<div\");\n\t\trm.writeAttribute(\"id\", sId + \"-add\" + iIdx);\n\t\trm.addClass(\"sapUiRoadMapStepAdd\" + iIdx);\n\t\trm.writeClasses();\n\t\trm.write(\"></div>\");\n\t}", "category": "Python"}, {"instruction": "Recursively dive()s every custom component in a wrapper until\nthe target component is found.\n\n@param {ShallowWrapper} wrapper A ShallowWrapper to search\n@param {ComponentType} target A react custom component that, when found, will end recursion\n@param {Adapter} adapter An Enzyme adapter\n@returns {ShallowWrapper|undefined} A ShallowWrapper for the target, or\nundefined if it can't be found", "input": "JavaScript", "output": "function deepRender(wrapper, target, adapter) {\n  const node = wrapper[NODE];\n  const element = node && adapter.nodeToElement(node);\n  if (wrapper.type() === target) {\n    return wrapper.dive();\n  }\n  if (element && isCustomComponentElement(element, adapter)) {\n    return deepRender(wrapper.dive(), target, adapter);\n  }\n  const children = wrapper.children();\n  for (let i = 0; i < children.length; i += 1) {\n    const found = deepRender(children.at(i), target, adapter);\n    if (typeof found !== 'undefined') {\n      return found;\n    }\n  }\n  return undefined;\n}", "category": "Python"}, {"instruction": "Opens the given collection.\n\n@param   {DataStore}         dataStore  - The DataStore to operate on\n@param   {string|Resource}   collection - The collection path or a Resource object\n@param   {function}          callback   - Called with Error, collection Resource, and Resource array", "input": "JavaScript", "output": "function openCollection (dataStore, collection, callback) {\n  if (_.isString(collection)) {\n    collection = new Resource(collection, \"\", \"\");\n  }\n  else if (!(collection instanceof Resource)) {\n    throw ono(\"Expected a string or Resource object. Got a %s instead.\", typeof (collection));\n  }\n\n  // Normalize the collection name\n  let collectionName = collection.valueOf(dataStore.__router, true);\n\n  // Open the data store\n  dataStore.__openDataStore(collectionName, (err, resources) => {\n    callback(err, collection, resources);\n  });\n}", "category": "Python"}, {"instruction": "~~~~~~~~ // Reducers // ~~~~~~~~ //", "input": "JavaScript", "output": "function getReducerName(type) {\n  const trailer = type.match(/s$/) ? '' : 's';\n  return `${type.slice(0, 1).toLowerCase()}${type.slice(1)}${trailer}`;\n}", "category": "Python"}, {"instruction": "Wait until the Tab View has been closed", "input": "JavaScript", "output": "function tabView_waitForClosed() {\n    // Add event listener to wait until the tabview has been closed\n    var self = { closed: false };\n    function checkClosed() { self.closed = true; }\n    this._controller.window.addEventListener(\"tabviewhidden\", checkClosed, false);\n\n    try {\n      mozmill.utils.waitFor(function() {\n        return self.closed == true;\n      }, TIMEOUT, 100, \"TabView is still open.\");\n    } finally {\n      this._controller.window.removeEventListener(\"tabviewhidden\", checkClosed, false);\n    }\n\n    this._tabViewObject = null;\n    this._groupItemsObject = null;\n    this._tabItemsObject = null;\n  }", "category": "Python"}, {"instruction": "/*\ninsert([1, 2, 5, 6], ['a', 'c', 'e'], 2); // [1, 2, 'a', 'c', 'e', 5, 6]\ninsert([1, 2, 5, 6], 'a', 2); // [1, 2, 'a', 5, 6]\ninsert([1, 2, 5, 6], ['a', 'c', 'e'], 0); // ['a', 'c', 'e', 1, 2, 5, 6]\ninsert([1, 2, 5, 6], ['a', 'c', 'e']); // ['a', 'c', 'e', 1, 2, 5, 6]", "input": "JavaScript", "output": "function insert(arr1, arr2, index) {\n  if (!Array.isArray(arr1)) {\n    throw new Error('expected an array for first argument');\n  }\n  if (arguments.length > 2 && typeof index != 'number') {\n    throw new Error('expected a number for third argument');\n  }\n  if (!Array.isArray(arr2)) {\n    arr2 = [arr2];\n  }\n  if (!index) {\n    return arr2.concat(arr1);\n  }\n  var front = arr1.slice(0, index);\n  var back = arr1.slice(index);\n  return front.concat(arr2, back);\n}", "category": "Python"}, {"instruction": "Strip device-specific IDs from React Native file:// paths", "input": "JavaScript", "output": "function normalizeUrl(url, pathStripRe) {\n  if (url.indexOf('/') !== -1) {\n    return url.replace(/^file\\:\\/\\//, '').replace(pathStripRe, '');\n  } else {\n    return '/' + url;\n  }\n}", "category": "Python"}, {"instruction": "Updates _viewStateCache from the given editor's actual current state\n@param {!Editor} editor - editor restore cached data\n@private", "input": "JavaScript", "output": "function _restoreEditorViewState(editor) {\n        // We want to ignore the current state of the editor, so don't call __getViewState()\n        var viewState = ViewStateManager.getViewState(editor.document.file);\n        if (viewState) {\n            editor.restoreViewState(viewState);\n        }\n    }", "category": "Python"}, {"instruction": "Check the JWT token for collab server", "input": "JavaScript", "output": "function checkCollabServerToken(authorization) {\n\t\tif (authorization.substr(0, 7) !== \"Bearer \") {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tvar decoded = jwt.verify(authorization.substr(7), options.configParams.get(\"orion.jwt.secret\"));\n\t\t\treturn true;\n\t\t} catch (ex) {\n\t\t\treturn false;\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Find index of value in array.\n\n@param arr {Array} Can also be a false-ish value.\n@param v {Object} Value to find.\n\nReturns -1 if not found, -2 if found multiple times.", "input": "JavaScript", "output": "function singleIndexOf(arr, v) {\n  var pos = -1;\n  var i, l;\n  if (!arr) {\n    return -1;\n  }\n  for (i = 0, l = arr.length; i < l; i++) {\n    if (arr[i] === v) {\n      if (pos >= 0) {\n        return -2;\n      }\n      pos = i;\n    }\n  }\n  return pos;\n}", "category": "Python"}, {"instruction": "Given a source file with @NgModule class(es), find the name of the first @NgModule class.\n\n@param source source file containing one or more @NgModule\n@returns the name of the first @NgModule, or `undefined` if none is found", "input": "JavaScript", "output": "function getFirstNgModuleName(source) {\n    // First, find the @NgModule decorators.\n    const ngModulesMetadata = getDecoratorMetadata(source, 'NgModule', '@angular/core');\n    if (ngModulesMetadata.length === 0) {\n        return undefined;\n    }\n    // Then walk parent pointers up the AST, looking for the ClassDeclaration parent of the NgModule\n    // metadata.\n    const moduleClass = findClassDeclarationParent(ngModulesMetadata[0]);\n    if (!moduleClass || !moduleClass.name) {\n        return undefined;\n    }\n    // Get the class name of the module ClassDeclaration.\n    return moduleClass.name.text;\n}", "category": "Python"}, {"instruction": "Gets the platform variant, currently either an empty string or 'musl' for Linux/musl platforms.\n\n@api public", "input": "JavaScript", "output": "function getPlatformVariant() {\n  var contents = '';\n\n  if (process.platform !== 'linux') {\n    return '';\n  }\n\n  try {\n    contents = fs.readFileSync(process.execPath);\n\n    // Buffer.indexOf was added in v1.5.0 so cast to string for old node\n    // Delay contents.toStrings because it's expensive\n    if (!contents.indexOf) {\n      contents = contents.toString();\n    }\n\n    if (contents.indexOf('libc.musl-x86_64.so.1') !== -1) {\n      return 'musl';\n    }\n  } catch (err) { } // eslint-disable-line no-empty\n\n  return '';\n}", "category": "Python"}, {"instruction": "Set camera projection matrix\n@param {clay.Matrix4} projectionMatrix", "input": "JavaScript", "output": "function (projectionMatrix) {\n        Matrix4.copy(this.projectionMatrix, projectionMatrix);\n        Matrix4.invert(this.invProjectionMatrix, projectionMatrix);\n        this.decomposeProjectionMatrix();\n    }", "category": "Python"}, {"instruction": "Helpers", "input": "JavaScript", "output": "function(e, attr){\n\t\t\tif(typeof e === \"string\"){\n\t\t\t\tvar elem = \n\t\t\t\t\tdocument.createElementNS(\"http://www.w3.org/2000/svg\",e);\n\t\t\t}else{\n\t\t\t\tvar elem = e;\n\t\t\t}\n\t\t\tif(attr){\n\t\t\t\tfor(var x in attr){\n\t\t\t\t\telem.setAttribute(x, attr[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn elem;\n\t\t}", "category": "Python"}, {"instruction": "calculate delta(sum of length difference of rows) values of given DSV\n@param {string} code - code to be test\n@param {string|RegExp} delimiter - delimiter to test\n@returns {number} delta value for code\n@ignore", "input": "JavaScript", "output": "function calcDSVDelta(code, delimiter) {\n  let rows, delta;\n\n  try {\n    csv.COLUMN_SEPARATOR = delimiter;\n    rows = csv.parse(code);\n\n    if (rows[0].length < 2) {\n      // parsing completely failed\n      throw new Error('parser fail');\n    }\n\n    // sum of all length difference of all rows\n    delta = rows.map(row => row.length)\n      .reduce((a, b) => ({\n        deltaSum: a.deltaSum + Math.abs(a.length - b),\n        length: b\n      }), {\n        deltaSum: 0,\n        length: rows[0].length\n      }).deltaSum;\n  } catch (e) {\n    delta = Infinity;\n  }\n\n  return delta;\n}", "category": "Python"}, {"instruction": "Returns all cookies formatted as a string to be put into the Cookie Header.", "input": "JavaScript", "output": "function() {\n            var cookieString = \"\";\n\n            utils.forEach(this._cookieStore, function (cookieValue, cookieKey) {\n                cookieString += cookieKey;\n                cookieString += '=';\n                cookieString += cookieValue;\n                cookieString += '; ';\n            });\n\n            return cookieString;\n\n        }", "category": "Python"}, {"instruction": "Shows a {@link sap.m.MessageBox} when a service call has failed.\nOnly the first error message will be display.\n@param {string} sDetails a technical error to be displayed on request\n@private", "input": "JavaScript", "output": "function (sDetails) {\n\t\t\t\tif (this._bMessageOpen) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._bMessageOpen = true;\n\t\t\t\tMessageBox.error(\n\t\t\t\t\tthis._sErrorText,\n\t\t\t\t\t{\n\t\t\t\t\t\tid : \"serviceErrorMessageBox\",\n\t\t\t\t\t\tdetails : sDetails,\n\t\t\t\t\t\tstyleClass : this._oComponent.getContentDensityClass(),\n\t\t\t\t\t\tactions : [MessageBox.Action.CLOSE],\n\t\t\t\t\t\tonClose : function () {\n\t\t\t\t\t\t\tthis._bMessageOpen = false;\n\t\t\t\t\t\t}.bind(this)\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}", "category": "Python"}, {"instruction": "@name Client.getSubZones\n@description gets a list of the subzones for a provided zone\n\n@param {object|Number}     zone          the zone of the record to query for\n@param {Function}          callback      handles the callback of your api call", "input": "JavaScript", "output": "function(zone, callback) {\n    var self = this,\n        zoneId = zone instanceof dns.Zone ? zone.id : zone;\n\n    var requestOptions = {\n      path: urlJoin(_urlPrefix, zoneId, 'subdomains'),\n      method: 'GET'\n    };\n\n    self._request(requestOptions, function(err, body, res) {\n      return err\n        ? callback(err)\n        : callback(null, body.domains.map(function (result) {\n        return new dns.Zone(self, result);\n      }), res);\n    });\n  }", "category": "Python"}, {"instruction": "Convert position on slider to percentage value of offset from beginning...\n@param position\n@returns {number}", "input": "JavaScript", "output": "function positionToPercent(position) {\n      var offset = vertical ? sliderDimensions.top : sliderDimensions.left;\n      var size = vertical ? sliderDimensions.height : sliderDimensions.width;\n      var calc = (position - offset) / size;\n\n      if (!vertical && $mdUtil.bidi() === 'rtl') {\n        calc = 1 - calc;\n      }\n\n      return Math.max(0, Math.min(1, vertical ? 1 - calc : calc));\n    }", "category": "Python"}, {"instruction": "Gets the scroll value of the given element in the given side (top and left)\n@method\n@memberof Popper.Utils\n@argument {Element} element\n@argument {String} side `top` or `left`\n@returns {number} amount of scrolled pixels", "input": "JavaScript", "output": "function getScroll(element, side = 'top') {\n  const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  const nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    const html = element.ownerDocument.documentElement;\n    const scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}", "category": "Python"}, {"instruction": "/*\nOutputs a warning message with the current nesting level; takes care not to\nconstruct the message or serialize XML in vain.\n\n@param {Element} [oElement]\nany XML DOM element which is serialized to the details\n@param {...string} aTexts\nthe main text of the message is constructed from the rest of the arguments by\njoining them separated by single spaces", "input": "JavaScript", "output": "function warn(oElement) {\n\t\t\t\tif (bWarning) {\n\t\t\t\t\tif (!bCallerLoggedForWarnings) {\n\t\t\t\t\t\tbCallerLoggedForWarnings = true;\n\t\t\t\t\t\tLog.warning(\"Warning(s) during processing of \" + sCaller, null,\n\t\t\t\t\t\t\tsXMLPreprocessor);\n\t\t\t\t\t}\n\t\t\t\t\tLog.warning(\n\t\t\t\t\t\tgetNestingLevel() + Array.prototype.slice.call(arguments, 1).join(\" \"),\n\t\t\t\t\t\toElement && serializeSingleElement(oElement), sXMLPreprocessor);\n\t\t\t\t}\n\t\t\t}", "category": "Python"}, {"instruction": "https://github.com/jsdoc3/jsdoc/issues/1272", "input": "JavaScript", "output": "function _detailedStringForDecryptionError(err, details) {\n    let result = err.name + '[msg: ' + err.message;\n\n    if (details) {\n        result += ', ' +\n            Object.keys(details).map(\n                (k) => k + ': ' + details[k],\n            ).join(', ');\n    }\n\n    result += ']';\n\n    return result;\n}", "category": "Python"}, {"instruction": "We don't need to publish all of a doc's data to the app, that will add many kilobytes of loading overhead.", "input": "JavaScript", "output": "function publicDocData(doc, extraData) {\n  const options = _.assign(extraData || {}, { hasDemo: (doc.docType === 'directive') });\n\n  // This RegEx always retrieves the last source descriptor.\n  // For example it retrieves from `/opt/material/src/core/services/ripple/ripple.js` the following\n  // source descriptor: `src/core/`.\n  // This is needed because components are not only located in `src/components`.\n  let descriptor = doc.fileInfo.filePath.toString().match(/src\\/.*?\\//g).pop();\n  if (descriptor) {\n    descriptor = descriptor.substring(descriptor.indexOf('/') + 1, descriptor.lastIndexOf('/'));\n  }\n\n  return buildDocData(doc, options, descriptor || 'components');\n}", "category": "Python"}, {"instruction": "=================== new v2 =================== list", "input": "JavaScript", "output": "function postAddListValue (req, res, next) {\n    let key = req.body.key;\n    let value = req.body.value;\n    let type = req.body.type;\n    let connectionId = req.body.connectionId;\n    getConnection(req, res, function () {\n        addListValue(key, value, type, res, next);\n    }, connectionId);\n}", "category": "Python"}, {"instruction": "Create a middleware for filtering files.\n\n@param {Object} filters\n@return {Function}", "input": "JavaScript", "output": "function filterFiles (filters) {\n  return (files, metalsmith, done) => {\n    filter(files, filters, metalsmith.metadata(), done)\n  }\n}", "category": "Python"}, {"instruction": "Override configuration values\n\n@method setConfig\n\n@param {Object}", "input": "JavaScript", "output": "function setConfig (options) {\n  Object.keys(options).forEach((option) => {\n    if (config[option] !== undefined) {\n      config[option] = options[option]\n    }\n  })\n}", "category": "Python"}, {"instruction": "Coerces the HTTP request body to a Buffer\n\n@param {string|Buffer} body\n@param {*} encoding", "input": "JavaScript", "output": "function getBodyAsBuffer(body, encoding) {\n  return body instanceof Buffer\n    ? body\n    : Buffer.from(`${body || ''}`, normalizeBodyEncoding(encoding));\n}", "category": "Python"}, {"instruction": "Checks package.json of the extracted extension for npm dependencies\nand runs npm install when required.\n@param {Object} validationResult return value of the validation procedure\n@param {Function} callback function to be called after the end of validation procedure", "input": "JavaScript", "output": "function performNpmInstallIfRequired(npmOptions, validationResult, callback) {\n\n    function finish() {\n        callback(null, validationResult);\n    }\n\n    var installDirectory = path.join(validationResult.extractDir, validationResult.commonPrefix);\n    var packageJson;\n\n    try {\n        packageJson = fs.readJsonSync(path.join(installDirectory, \"package.json\"));\n    } catch (e) {\n        packageJson = null;\n    }\n\n    if (!packageJson || !packageJson.dependencies || !Object.keys(packageJson.dependencies).length) {\n        return finish();\n    }\n\n    _performNpmInstall(installDirectory, npmOptions, function (err) {\n        if (err) {\n            validationResult.errors.push([Errors.NPM_INSTALL_FAILED, err.toString()]);\n        }\n        finish();\n    });\n}", "category": "Python"}, {"instruction": "Checks if value is not undefined, in which case the\nsetter function for a given property is called.\nReturns true if value is set, false otherwise.\n\n@private", "input": "JavaScript", "output": "function checkAndSetProperty(oControl, property, value) {\n\t\t\tif (value !== undefined) {\n\t\t\t\tvar fSetter = oControl['set' + capitalize(property)];\n\t\t\t\tif (typeof (fSetter) === \"function\") {\n\t\t\t\t\tfSetter.call(oControl, value);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}", "category": "Python"}, {"instruction": "wrap session methods", "input": "JavaScript", "output": "function wrapmethods(sess) {\n      var _reload = sess.reload\n      var _save = sess.save;\n\n      function reload(callback) {\n        debug('reloading %s', this.id)\n        _reload.call(this, function () {\n          wrapmethods(req.session)\n          callback.apply(this, arguments)\n        })\n      }\n\n      function save() {\n        debug('saving %s', this.id);\n        savedHash = hash(this);\n        _save.apply(this, arguments);\n      }\n\n      Object.defineProperty(sess, 'reload', {\n        configurable: true,\n        enumerable: false,\n        value: reload,\n        writable: true\n      })\n\n      Object.defineProperty(sess, 'save', {\n        configurable: true,\n        enumerable: false,\n        value: save,\n        writable: true\n      });\n    }", "category": "Python"}, {"instruction": "Texture Channels to Texture *****************************************", "input": "JavaScript", "output": "function LGraphChannelsTexture() {\n            this.addInput(\"R\", \"Texture\");\n            this.addInput(\"G\", \"Texture\");\n            this.addInput(\"B\", \"Texture\");\n            this.addInput(\"A\", \"Texture\");\n\n            this.addOutput(\"Texture\", \"Texture\");\n\n            this.properties = {\n                precision: LGraphTexture.DEFAULT,\n                R: 1,\n                G: 1,\n                B: 1,\n                A: 1\n            };\n            this._color = vec4.create();\n            this._uniforms = {\n                u_textureR: 0,\n                u_textureG: 1,\n                u_textureB: 2,\n                u_textureA: 3,\n                u_color: this._color\n            };\n        }", "category": "Python"}, {"instruction": "Return true if the r,g,b,a values of this color are equal with the\ngiven one.\n@name equals\n@memberOf me.Color\n@function\n@param {me.Color} color\n@return {Boolean}", "input": "JavaScript", "output": "function (color) {\n            return (\n                (this.glArray[0] === color.glArray[0]) &&\n                (this.glArray[1] === color.glArray[1]) &&\n                (this.glArray[2] === color.glArray[2]) &&\n                (this.glArray[3] === color.glArray[3])\n            );\n        }", "category": "Python"}, {"instruction": "W3C MessageEvent\n\n@see http://www.w3.org/TR/webmessaging/#event-definitions\n@api private", "input": "JavaScript", "output": "function MessageEvent (type, eventInitDict) {\n  Object.defineProperty(this, 'type', { writable: false, value: type, enumerable: true })\n  for (var f in eventInitDict) {\n    if (eventInitDict.hasOwnProperty(f)) {\n      Object.defineProperty(this, f, { writable: false, value: eventInitDict[f], enumerable: true })\n    }\n  }\n}", "category": "Python"}, {"instruction": "Transfer learning logic.\n Scroll to the bottom of the page", "input": "JavaScript", "output": "function scrollToPageBottom() {\n  const scrollingElement = (document.scrollingElement || document.body);\n  scrollingElement.scrollTop = scrollingElement.scrollHeight;\n}", "category": "Python"}, {"instruction": "/* See if an element is within eruda.", "input": "JavaScript", "output": "function exports(el) {\n  let parentNode = el.parentNode\n\n  if (!parentNode) return false\n\n  while (parentNode) {\n    parentNode = parentNode.parentNode\n    if (parentNode && parentNode.id === 'eruda') return true\n  }\n\n  return false\n}", "category": "Python"}, {"instruction": "Check if the node is a React ES5 component\n\n@param {ASTNode} node The AST node being checked.\n@returns {Boolean} True if the node is a React ES5 component, false if not", "input": "JavaScript", "output": "function (node) {\n      if (!node.parent) {\n        return false;\n      }\n      return /^(React\\.)?createClass$/.test(sourceCode.getText(node.parent.callee));\n    }", "category": "Python"}, {"instruction": "Sets up the map including the speaker audio points.", "input": "JavaScript", "output": "function() {\n    // Loop through the tiles and setup the audio listeners.\n    for (var i=0; i<this.grid.length; i++) {\n      if (this.grid[i] === 2) {\n        var y = Math.floor(i / this.size);\n        var x = i % this.size;\n        game.audio.speaker(x, y);\n      }\n    }\n  }", "category": "Python"}, {"instruction": "istanbul ignore next", "input": "JavaScript", "output": "async function deleteBranch(branchName, abandonAssociatedPr = false) {\n  await config.storage.deleteBranch(branchName);\n  // istanbul ignore if\n  if (abandonAssociatedPr) {\n    const pr = await getBranchPr(branchName);\n    await abandonPr(pr.number);\n  }\n}", "category": "Python"}, {"instruction": "Proxies the first require call in order to draw back all changes to the Module.wrapper.\nThus our changes don't influence other modules\n\n@param {!String} path", "input": "JavaScript", "output": "function requireProxy(path) {\n    reset();\n    currentModule.require = nodeRequire;\n    return nodeRequire.call(currentModule, path);  // node's require only works when \"this\" points to the module\n}", "category": "Python"}, {"instruction": "Creates token that can be fed to <code>EditElement</code>\n@param {Number} start\n@param {String} value\n@param {String} type\n@returns", "input": "JavaScript", "output": "function(start, value, type) {\n\t\t\tvar obj = {\n\t\t\t\tstart: start || 0,\n\t\t\t\tvalue: value || '',\n\t\t\t\ttype: type\n\t\t\t};\n\t\t\t\n\t\t\tobj.end = obj.start + obj.value.length;\n\t\t\treturn obj;\n\t\t}", "category": "Python"}, {"instruction": "Resolves the version using an array of UA patterns.\n\n@private\n@param {Array} patterns An array of UA patterns.\n@returns {null|string} The detected version.", "input": "JavaScript", "output": "function getVersion(patterns) {\n      return reduce(patterns, function(result, pattern) {\n        return result || (RegExp(pattern +\n          '(?:-[\\\\d.]+/|(?: for [\\\\w-]+)?[ /-])([\\\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;\n      });\n    }", "category": "Python"}, {"instruction": "Intentionally not documented.", "input": "JavaScript", "output": "function (className, functionName, message) {\n            var msg = this.messageTable[message] ? this.messageTable[message] : message;\n\n            return className + \".\" + functionName + \": \" + msg;\n        }", "category": "Python"}, {"instruction": "Supports old \"geospatial view state as separate props\" style TODO - this should either be moved into the core or deprecated", "input": "JavaScript", "output": "function getViewState(props) {\n  if (!props.viewState && 'latitude' in props && 'longitude' in props && 'zoom' in props) {\n    const {latitude, longitude, zoom, pitch = 0, bearing = 0} = props;\n    return {latitude, longitude, zoom, pitch, bearing};\n  }\n  return props.viewState;\n}", "category": "Python"}, {"instruction": "To see the overview of app variants, a key user has created from an app", "input": "JavaScript", "output": "function(bAsKeyUser) {\n\t\t\tvar oDescriptor = fnGetDescriptor();\n\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\tvar fnCancel = function() {\n\t\t\t\t\tAppVariantUtils.closeOverviewDialog();\n\t\t\t\t};\n\t\t\t\tsap.ui.require([\"sap/ui/rta/appVariant/AppVariantOverviewDialog\"], function(AppVariantOverviewDialog) {\n\t\t\t\t\tif (!oAppVariantOverviewDialog) {\n\t\t\t\t\t\toAppVariantOverviewDialog = new AppVariantOverviewDialog({\n\t\t\t\t\t\t\tidRunningApp: oDescriptor[\"sap.app\"].id,\n\t\t\t\t\t\t\tisOverviewForKeyUser: bAsKeyUser\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\toAppVariantOverviewDialog.attachCancel(fnCancel);\n\n\t\t\t\t\toAppVariantOverviewDialog.oPopup.attachOpened(function() {\n\t\t\t\t\t\tresolve(oAppVariantOverviewDialog);\n\t\t\t\t\t});\n\n\t\t\t\t\toAppVariantOverviewDialog.open();\n\t\t\t\t});\n\t\t\t});\n\t\t}", "category": "Python"}, {"instruction": "Creates a new virtual time scheduler with the specified initial clock value and absolute time comparer.\n\n@constructor\n@param {Number} initialClock Initial value for the clock.\n@param {Function} comparer Comparer to determine causality of events based on absolute time.", "input": "JavaScript", "output": "function VirtualTimeScheduler(initialClock, comparer) {\n      this.clock = initialClock;\n      this.comparer = comparer;\n      this.isEnabled = false;\n      this.queue = new PriorityQueue(1024);\n      __super__.call(this);\n    }", "category": "Python"}, {"instruction": "Log the progress of a request object.", "input": "JavaScript", "output": "function _logProgress(req) {\n  req.on('response', function(resp) {\n    var len = parseInt(resp.headers['content-length'], 10),\n      bar = new ProgressBar('[:bar]', {\n        complete: '=',\n        incomplete: ' ',\n        total: len,\n        width: 100, // just use 100\n      });\n\n    req.on('data', function(chunk) {\n      bar.tick(chunk.length);\n    });\n  });\n\n  req.on('error', function(err) {\n    console.log(err);\n    _log('error', 'failed to download node sources,');\n    process.exit(1);\n  });\n\n  return req;\n}", "category": "Python"}, {"instruction": "Get a list of valid query sort inputs.\n@param model: A mongoose model object.\n@param logger: A logging object.\n@returns {Array}: A list of fields.", "input": "JavaScript", "output": "function(model, logger) {\n    // This line has to come first\n    validationHelper.validateModel(model, logger)\n    const Log = logger.bind()\n\n    let sortableFields = this.getReadableFields(model, Log)\n\n    for (let i = sortableFields.length - 1; i >= 0; i--) {\n      let descendingField = '-' + sortableFields[i]\n      sortableFields.splice(i, 0, descendingField)\n    }\n\n    return sortableFields\n  }", "category": "Python"}, {"instruction": "Starts the Cache Manager (all next calls to it will work against real cache data)\nUsages are meant for testing purposes. If its already on, nothing will happen\n@returns {*}\n@protected", "input": "JavaScript", "output": "function () {\n\t\t\t\tvar that = this;\n\t\t\t\treturn Promise.resolve().then(function () {\n\t\t\t\t\tvar oCfg = sap.ui.getCore().getConfiguration();\n\t\t\t\t\tif (!oCfg.isUI5CacheOn()) {\n\t\t\t\t\t\tsafeClearInstance(that);\n\t\t\t\t\t\tsap.ui.getCore().getConfiguration().setUI5CacheOn(true);\n\t\t\t\t\t}\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t});\n\t\t\t}", "category": "Python"}, {"instruction": "Need to re-render if the sort order or the contents change.", "input": "JavaScript", "output": "function (nextProps, nextState) {\n            return nextProps.forceRender ||\n                this.props.contents !== nextProps.contents ||\n                this.props.sortDirectoriesFirst !== nextProps.sortDirectoriesFirst ||\n                this.props.extensions !== nextProps.extensions;\n        }", "category": "Python"}, {"instruction": "Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists", "input": "JavaScript", "output": "function ( UVNode ) {\n\n\t\t\tvar mappingType = UVNode.MappingInformationType;\n\t\t\tvar referenceType = UVNode.ReferenceInformationType;\n\t\t\tvar buffer = UVNode.UV.a;\n\t\t\tvar indexBuffer = [];\n\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\tindexBuffer = UVNode.UVIndex.a;\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdataSize: 2,\n\t\t\t\tbuffer: buffer,\n\t\t\t\tindices: indexBuffer,\n\t\t\t\tmappingType: mappingType,\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t}", "category": "Python"}, {"instruction": "emulate functionref.apply for IE mac and IE win < 5.5", "input": "JavaScript", "output": "function xbDebugApplyFunction(funcname, funcref, thisref, argumentsref)\n{\n    var rv;\n\n    if (!funcref)\n    {\n        alert('xbDebugApplyFunction: funcref is null');\n    }\n\n    if (typeof(funcref.apply) != 'undefined')\n        return funcref.apply(thisref, argumentsref);\n\n    var applyexpr = 'thisref.xbDebug_orig_' + funcname + '(';\n    var i;\n\n    for (i = 0; i < argumentsref.length; i++)\n    {\n        applyexpr += 'argumentsref[' + i + '],';\n    }\n\n    if (argumentsref.length > 0)\n    {\n        applyexpr = applyexpr.substring(0, applyexpr.length - 1);\n    }\n\n    applyexpr += ')';\n\n    return eval(applyexpr);\n}", "category": "Python"}, {"instruction": "Closes the context menu of a column.\n\n@param {sap.ui.table.Table} oTable Instance of the table.\n@param {int} iColumnIndex The index of the column to close the context menu on.\n@see openContextMenu\n@see openColumnContextMenu\n@private", "input": "JavaScript", "output": "function(oTable, iColumnIndex) {\n\t\t\tif (!oTable ||\n\t\t\t\tiColumnIndex == null || iColumnIndex < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar oColumns = oTable.getColumns();\n\t\t\tif (iColumnIndex >= oColumns.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar oColumn = oColumns[iColumnIndex];\n\t\t\toColumn._closeMenu();\n\t\t}", "category": "Python"}, {"instruction": "Get dictionary of experiment keys and variations.\n\nhttp://visualwebsiteoptimizer.com/knowledge/integration-of-vwo-with-kissmetrics/\n\n@param {Function} fn\n@return {Object}", "input": "JavaScript", "output": "function experiments(fn) {\n  enqueue(function() {\n    var data = {};\n    var ids = window._vwo_exp_ids;\n    if (!ids) return fn();\n    each(ids, function(id) {\n      var name = variation(id);\n      if (name) data['Experiment: ' + id] = name;\n    });\n    fn(null, data);\n  });\n}", "category": "Python"}, {"instruction": "Sets up the Auto Update environment", "input": "JavaScript", "output": "function setupAutoUpdate() {\n        updateJsonHandler = new StateHandler(updateJsonPath);\n        updateDomain.on('data', receiveMessageFromNode);\n\n        updateDomain.exec('initNode', {\n            messageIds: MessageIds,\n            updateDir: updateDir,\n            requester: domainID\n        });\n    }", "category": "Python"}, {"instruction": "Is the current git workspace dirty?", "input": "JavaScript", "output": "function isDirty () {\n  return pify(git.raw.bind(git))(['status', '-s'])\n    .then((out) => {\n      if (out && out.trim().length > 0) {\n        throw new Error('Dirty git repo, aborting')\n      }\n    })\n}", "category": "Python"}, {"instruction": "traditional ordinal numbers above 31 are not commonly used in colloquial Welsh", "input": "JavaScript", "output": "function (number) {\n            var b = number,\n                output = '',\n                lookup = [\n                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed\n                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed\n                ];\n\n            if (b > 20) {\n                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {\n                    output = 'fed'; // not 30ain, 70ain or 90ain\n                } else {\n                    output = 'ain';\n                }\n            } else if (b > 0) {\n                output = lookup[b];\n            }\n\n            return number + output;\n        }", "category": "Python"}, {"instruction": "/*\nChecks if there is a hunk header coming before a new file starts\n\nHunk header is a group of three lines started by ( `--- ` , `+++ ` , `@@` )", "input": "JavaScript", "output": "function existHunkHeader(line, lineIdx) {\n      var idx = lineIdx;\n\n      while (idx < diffLines.length - 3) {\n        if (utils.startsWith(line, 'diff')) {\n          return false;\n        }\n\n        if (\n          utils.startsWith(diffLines[idx], oldFileNameHeader) &&\n          utils.startsWith(diffLines[idx + 1], newFileNameHeader) &&\n          utils.startsWith(diffLines[idx + 2], hunkHeaderPrefix)\n        ) {\n          return true;\n        }\n\n        idx++;\n      }\n\n      return false;\n    }", "category": "Python"}, {"instruction": "Checks the provided OTP token against system generated token\n\n@module otplib-authenticator/check\n@param {string} token - the OTP token to check\n@param {string} secret - your secret that is used to generate the token\n@param {object} options - options which was used to generate it originally\n@return {boolean}", "input": "JavaScript", "output": "function check(token, secret, options) {\n  const delta = checkDelta(token, secret, options);\n  return Number.isInteger(delta);\n}", "category": "Python"}, {"instruction": "writes the new version to package.json", "input": "JavaScript", "output": "function updateVersion () {\n    start(`Updating ${\"package.json\".cyan} version from ${oldVersion.cyan} to ${newVersion.cyan}...`);\n    pkg.version = newVersion;\n    fs.writeFileSync('./package.json', JSON.stringify(pkg, null, 2));\n    done();\n    abortCmds.push('git checkout package.json');\n    pushCmds.push('git add package.json');\n  }", "category": "Python"}, {"instruction": "Simple trick to fake touch event support\nthis is enough for most libraries like Modernizr and Hammer", "input": "JavaScript", "output": "function fakeTouchSupport() {\n        var objs = [window, document.documentElement];\n        var props = ['ontouchstart', 'ontouchmove', 'ontouchcancel', 'ontouchend'];\n\n        for(var o=0; o<objs.length; o++) {\n            for(var p=0; p<props.length; p++) {\n                if(objs[o] && objs[o][props[p]] == undefined) {\n                    objs[o][props[p]] = null;\n                }\n            }\n        }\n    }", "category": "Python"}, {"instruction": "request aborted", "input": "JavaScript", "output": "function onaborted() {\n    if (done) return;\n    done = true;\n\n    var err = new Error('Request aborted');\n    err.code = 'ECONNABORTED';\n    callback(err);\n  }", "category": "Python"}, {"instruction": "Extracts a lowercased domain from a distinguished name for comparison\npurposes.\n\ne.g. \"CN=User,OU=MyBusiness,DC=example,DC=com\" will return \"example.com.\"", "input": "JavaScript", "output": "function dnToDomain (dn) {\n  if (!dn || typeof dn !== 'string') { return null }\n  var matches = domainDnRegex.exec(dn)\n  if (matches) {\n    return matches[1].replace(dnPartRegex, '$1.').toLowerCase()\n  } else {\n    return null\n  }\n}", "category": "Python"}, {"instruction": "\u8fd4\u56de\u524d\u51e0\u5468\u6216\u540e\u51e0\u5468\u7684\u661f\u671f\u51e0\n\n@param {Date} date \u65e5\u671f\n@param {Number} week \u5468(\u9ed8\u8ba4\u5f53\u524d\u5468)\u3001\u524d\u51e0\u5468\u3001\u540e\u51e0\u5468\n@param {Number} day \u661f\u671f\u5929(\u9ed8\u8ba40)\u3001\u661f\u671f\u4e00(1)\u3001\u661f\u671f\u4e8c(2)\u3001\u661f\u671f\u4e09(3)\u3001\u661f\u671f\u56db(4)\u3001\u661f\u671f\u4e94(5)\u3001\u661f\u671f\u516d(6)\n@return {Date}", "input": "JavaScript", "output": "function getWhatWeek (date, week, day) {\n  var time, whatDayTime, currentDay, customDay\n  date = toStringDate(date)\n  if (baseExports.isDate(date)) {\n    customDay = Number(/^[0-7]$/.test(day) ? day : date.getDay())\n    currentDay = date.getDay()\n    time = getDateTime(date)\n    whatDayTime = time + ((customDay === 0 ? 7 : customDay) - (currentDay === 0 ? 7 : currentDay)) * DAY_TIME\n    if (week && !isNaN(week)) {\n      whatDayTime += week * WEEK_TIME\n    }\n    return new Date(whatDayTime)\n  }\n  return date\n}", "category": "Python"}, {"instruction": "Creates an error object to be thrown when the reporter specified in the options was not found.\n\n@public\n@param {string} message - Error message to be displayed.\n@param {string} reporter - User-specified reporter value.\n@returns {Error} instance detailing the error condition", "input": "JavaScript", "output": "function createInvalidReporterError(message, reporter) {\n  var err = new TypeError(message);\n  err.code = 'ERR_MOCHA_INVALID_REPORTER';\n  err.reporter = reporter;\n  return err;\n}", "category": "Python"}, {"instruction": "Write resources from workspace matching the given pattern to the given fs destination\n\n@private\n@param {Object} parameters Parameters\n@param {module:@ui5/fs.DuplexCollection} parameters.workspace DuplexCollection to read and write files\n@param {string} parameters.pattern Pattern to match resources in workspace against\n@param {string} parameters.targetPath Path to write the resources to\n@returns {Promise<number>} Promise resolving with number of resources written to given directory", "input": "JavaScript", "output": "async function writeResourcesToDir({workspace, pattern, targetPath}) {\n\tconst fsTarget = resourceFactory.createAdapter({\n\t\tfsBasePath: targetPath,\n\t\tvirBasePath: \"/resources/\"\n\t});\n\n\tlet allResources;\n\tif (workspace.byGlobSource) { // API only available on duplex collections\n\t\tallResources = await workspace.byGlobSource(pattern);\n\t} else {\n\t\tallResources = await workspace.byGlob(pattern);\n\t}\n\n\t// write all resources to the tmp folder\n\tawait Promise.all(allResources.map((resource) => fsTarget.write(resource)));\n\treturn allResources.length;\n}", "category": "Python"}, {"instruction": "/////////////////////////////////////// Hidden Functions /////////////////////////////////////////", "input": "JavaScript", "output": "function checkCozyMode(oRef) {\n\t\tif (!oRef) {\n\t\t\treturn false;\n\t\t}\n\t\toRef = oRef.$ ? oRef.$() : jQuery(oRef);\n\t\treturn oRef.closest(\".sapUiSizeCompact,.sapUiSizeCondensed,.sapUiSizeCozy\").hasClass(\"sapUiSizeCozy\");\n\t}", "category": "Python"}, {"instruction": "run the script", "input": "JavaScript", "output": "function() {\n\tvar scriptJs = Ext.getCmp('scriptAreaId').getValue();\n\tvar serverId = Ext.getCmp('serverComId').getValue();\n\n\tif (!serverId) {\n\t\talert('serverId is required!');\n\t\treturn;\n\t}\n\n\twindow.parent.client.request('scripts', {\n\t\tcommand: 'run',\n\t\tserverId: serverId,\n\t\tscript: scriptJs\n\t}, function(err, msg) {\n\t\tif (err) {\n\t\t\talert(err);\n\t\t\treturn;\n\t\t}\n\t\tExt.getCmp('tesultTextId').setValue(msg);\n\t});\n}", "category": "Python"}, {"instruction": "Creates an instance of VASTClient.\n@param  {Number} cappingFreeLunch - The number of first calls to skip.\n@param  {Number} cappingMinimumTimeInterval - The minimum time interval between two consecutive calls.\n@param  {Storage} customStorage - A custom storage to use instead of the default one.\n@constructor", "input": "JavaScript", "output": "function VASTClient(cappingFreeLunch, cappingMinimumTimeInterval, customStorage) {\n    classCallCheck(this, VASTClient);\n\n    this.cappingFreeLunch = cappingFreeLunch || 0;\n    this.cappingMinimumTimeInterval = cappingMinimumTimeInterval || 0;\n    this.defaultOptions = {\n      withCredentials: false,\n      timeout: 0\n    };\n    this.vastParser = new VASTParser();\n    this.storage = customStorage || new Storage();\n\n    // Init values if not already set\n    if (this.lastSuccessfulAd === undefined) {\n      this.lastSuccessfulAd = 0;\n    }\n\n    if (this.totalCalls === undefined) {\n      this.totalCalls = 0;\n    }\n    if (this.totalCallsTimeout === undefined) {\n      this.totalCallsTimeout = 0;\n    }\n  }", "category": "Python"}, {"instruction": "getModuleUrl returns different urls for win platform\nso that's why we need a different check here\n@see #getModuleUrl\n@param {!string} pathOrUrl that should be checked if it's absolute\n@return {!boolean} returns true if pathOrUrl is absolute url on win platform\nor when it's absolute path on other platforms", "input": "JavaScript", "output": "function isAbsolutePathOrUrl(pathOrUrl) {\n        return brackets.platform === \"win\" ? PathUtils.isAbsoluteUrl(pathOrUrl) : FileSystem.isAbsolutePath(pathOrUrl);\n    }", "category": "Python"}, {"instruction": "Create a string representing the current set of meshes for a given set of tiles, based on their created timestamp. Used to determine when tiles should be re-collided.", "input": "JavaScript", "output": "function meshSetString (tiles) {\n    return JSON.stringify(\n        Object.entries(tiles).map(([,t]) => {\n            return Object.entries(t.meshes).map(([,s]) => {\n                return s.map(m => m.created_at);\n            });\n        })\n    );\n}", "category": "Python"}, {"instruction": "Return true if `node` is wrapped any one of `types`.\n@param {TxtNode} node is target node\n@param {string[]} types are wrapped target node\n@returns {boolean}", "input": "JavaScript", "output": "function isNodeWrapped(node, types) {\n    var parents = getParents(node);\n    var parentsTypes = parents.map(function(parent) {\n        return parent.type;\n    });\n    return types.some(function(type) {\n        return parentsTypes.some(function(parentType) {\n            return parentType === type;\n        });\n    });\n}", "category": "Python"}, {"instruction": "filtering to enable a white-list version of Sinon FakeXhr, where whitelisted requests are passed through to real XHR", "input": "JavaScript", "output": "function each(collection, callback) {\n        if (!collection) {\n            return;\n        }\n\n        for (var i = 0, l = collection.length; i < l; i += 1) {\n            callback(collection[i]);\n        }\n    }", "category": "Python"}, {"instruction": "Reports an error with the given message and details and throws it.\n\n@param {sap.ui.model.odata.v4.ODataMetaModel} oMetaModel\nThe OData metadata model\n@param {string} sMessage\nError message\n@param {string} sDetails\nError details\n@throws {Error}", "input": "JavaScript", "output": "function reportAndThrowError(oMetaModel, sMessage, sDetails) {\n\t\tvar oError = new Error(sDetails + \": \" + sMessage);\n\n\t\toMetaModel.oModel.reportError(sMessage, sODataMetaModel, oError);\n\t\tthrow oError;\n\t}", "category": "Python"}, {"instruction": "destructive transform (faster)", "input": "JavaScript", "output": "function (point, scale) {\n\t\tscale = scale || 1;\n\t\tpoint.x = scale * (this._a * point.x + this._b);\n\t\tpoint.y = scale * (this._c * point.y + this._d);\n\t\treturn point;\n\t}", "category": "Python"}, {"instruction": "lets you call a css selector with a guard", "input": "JavaScript", "output": "function (args, env) {\n        var lastSelector = this.selectors[this.selectors.length-1];\n        if (!lastSelector.evaldCondition) {\n            return false;\n        }\n        if (lastSelector.condition &&\n            !lastSelector.condition.eval(\n                new(tree.evalEnv)(env,\n                    env.frames))) {\n            return false;\n        }\n        return true;\n    }", "category": "Python"}, {"instruction": "Used to assert that actual matches expected value, where expected may be a function or a string.", "input": "JavaScript", "output": "function assertMatch(actual, expected, message) {\n  if (isRegExp(expected))\n    assert(expected.test(actual), message || `Expected \"${actual}\" to match \"${expected}\"`);\n  else if (typeof expected === 'function')\n    assert(expected(actual), message);\n  else\n    assert.deepEqual(actual, expected, message);\n}", "category": "Python"}, {"instruction": "Current position of an element relative to the document.", "input": "JavaScript", "output": "function offset ( elem, orientation ) {\n\n        var rect = elem.getBoundingClientRect(),\n            doc = elem.ownerDocument,\n            docElem = doc.documentElement,\n            pageOffset = getPageOffset();\n\n        // getBoundingClientRect contains left scroll in Chrome on Android.\n        // I haven't found a feature detection that proves this. Worst case\n        // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.\n        if ( /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) ) {\n            pageOffset.x = 0;\n        }\n\n        return orientation ? (rect.top + pageOffset.y - docElem.clientTop) : (rect.left + pageOffset.x - docElem.clientLeft);\n    }", "category": "Python"}, {"instruction": "--- Compile Helpers ---", "input": "JavaScript", "output": "function getPackagePath(p) {\n      if (p.path) {\n        return p.path;\n      } else if (p.polyfill) {\n        return path.join('polyfills', p.namespace.toLowerCase(), p.name);\n      } else if (p.type === 'fix') {\n        return path.join(p.module.toLowerCase(), 'fixes', p.name);\n      } else if (p.type === 'locale') {\n        return path.join(p.module.toLowerCase(), p.code);\n      } else if (sourcePackageIsDependency(p)) {\n        return path.join(p.module.toLowerCase(), p.type, p.name);\n      } else {\n        return path.join(p.namespace.toLowerCase(), p.name);\n      }\n    }", "category": "Python"}, {"instruction": "Calculates the height and width of text on the canvas Width is found by using the canvas measureText function Height is only estimated -- it calculates the font size in pixels, and sets the height to 110% of that.", "input": "JavaScript", "output": "function() {\n        var ctx = this._drawContext;\n        ctx.font = this._fontString();\n        this.w = ctx.measureText(this._text).width;\n\n        var size = this._textFont.size || this.defaultSize;\n        this.h = 1.1 * this._getFontHeight(size);\n\n        /* Offset the MBR for text alignment*/\n        if (this._textAlign === \"left\" || this._textAlign === \"start\") {\n            this.offsetBoundary(0, 0, 0, 0);\n        } else if (this._textAlign === \"center\") {\n            this.offsetBoundary(this.w / 2, 0, -this.w / 2, 0);\n        } else if (this._textAlign === \"end\" || this._textAlign === \"right\") {\n            this.offsetBoundary(this.w, 0, -this.w, 0);\n        }\n    }", "category": "Python"}, {"instruction": "eslint-disable-next-line no-unused-vars", "input": "JavaScript", "output": "function toggleSlideShowMode() {\n  const streams = room.remoteStreams;\n  const cb = (evt) => {\n    console.log('SlideShowMode changed', evt);\n  };\n  slideShowMode = !slideShowMode;\n  streams.forEach((stream) => {\n    if (localStream.getID() !== stream.getID()) {\n      console.log('Updating config');\n      stream.updateConfiguration({ slideShowMode }, cb);\n    }\n  });\n}", "category": "Python"}, {"instruction": "This function returns the route object matched by the identifier passed as parameter.\n@private", "input": "JavaScript", "output": "function findRouteByIdentifier(sIdf){\n\t\t\tvar i;\n\t\t\tfor (i = 0 ; i < routes.length ; i++) {\n\t\t\t\tif (routes[i].sIdentifier === sIdf) {\n\t\t\t\t\treturn routes[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}", "category": "Python"}, {"instruction": "If there are promise handlers waiting for execution at the time the timeout fires, start another timeout to postpone timer execution after promise execution.", "input": "JavaScript", "output": "function wrapTimerHandler(vHandler) {\n\t\t\t\tvar fnWrappedHandler = function() {\n\t\t\t\t\tvar aArgs, fnHandler;\n\t\t\t\t\tif (bPromisesQueued) {\n\t\t\t\t\t\taArgs = [fnWrappedHandler, 0].concat(arguments);\n\t\t\t\t\t\t_timeout.apply(window, aArgs);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfnHandler = typeof vHandler !== \"function\" ? new Function(vHandler) : vHandler; // eslint-disable-line no-new-func\n\t\t\t\t\t\tfnHandler.apply(window, arguments);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\treturn fnWrappedHandler;\n\t\t\t}", "category": "Python"}, {"instruction": "Gets whether two dates have the same month and year.\n@param {Date} d1\n@param {Date} d2\n@returns {boolean}", "input": "JavaScript", "output": "function isSameMonthAndYear(d1, d2) {\n      return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth();\n    }", "category": "Python"}, {"instruction": "Get all the nodes from a source.\n@param sourceFile The source file object.\n@returns {Observable<ts.Node>} An observable of all the nodes in the source.", "input": "JavaScript", "output": "function getSourceNodes(sourceFile) {\n    const nodes = [sourceFile];\n    const result = [];\n    while (nodes.length > 0) {\n        const node = nodes.shift();\n        if (node) {\n            result.push(node);\n            if (node.getChildCount(sourceFile) >= 0) {\n                nodes.unshift(...node.getChildren());\n            }\n        }\n    }\n    return result;\n}", "category": "Python"}, {"instruction": "Apply a linear transform to array of arcs.  The provided array of arcs is\nmodified in place.\n\n@param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n@param {Array<number>} scale Scale for each dimension.\n@param {Array<number>} translate Translation for each dimension.", "input": "JavaScript", "output": "function transformArcs(arcs, scale, translate) {\n  for (let i = 0, ii = arcs.length; i < ii; ++i) {\n    transformArc(arcs[i], scale, translate);\n  }\n}", "category": "Python"}, {"instruction": "Prepare the function used to generate the uncompressed content from this ZipFile.\n@param {DataReader} reader the reader to use.\n@param {number} from the offset from where we should read the data.\n@param {number} length the length of the data to read.\n@param {JSZip.compression} compression the compression used on this file.\n@param {number} uncompressedSize the uncompressed size to expect.\n@return {Function} the callback to get the uncompressed content (the type depends of the DataReader class).", "input": "JavaScript", "output": "function(reader, from, length, compression, uncompressedSize) {\n        return function() {\n\n            var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());\n            var uncompressedFileData = compression.uncompress(compressedFileData);\n\n            if (uncompressedFileData.length !== uncompressedSize) {\n                throw new Error(\"Bug : uncompressed data size mismatch\");\n            }\n\n            return uncompressedFileData;\n        };\n    }", "category": "Python"}, {"instruction": "/*\ndeep assign\n@param {Object} oldData oldData\n@param {Object} newData newData", "input": "JavaScript", "output": "function assign (oldData, newData) {\n  Object.keys(newData).forEach(k => {\n    if (isObject(newData[k]) && oldData[k] && isObject(oldData[k])) {\n      assign(oldData[k], newData[k])\n      let obj = JSON.parse(JSON.stringify({\n        [k]: oldData[k]\n      }))\n      Object.assign(oldData, obj)\n    } else {\n      oldData[k] = newData[k]\n    }\n  })\n}", "category": "Python"}, {"instruction": "Check whether it should stop traversing ancestors at the given node.\n@param {ASTNode} node A node to check.\n@returns {boolean} `true` if it should stop traversing.", "input": "JavaScript", "output": "function isBoundary(node) {\n    const t = node.type;\n\n    return (\n        t === \"FunctionDeclaration\" ||\n        t === \"FunctionExpression\" ||\n        t === \"ArrowFunctionExpression\" ||\n\n        /*\n         * Don't report the await expressions on for-await-of loop since it's\n         * asynchronous iteration intentionally.\n         */\n        (t === \"ForOfStatement\" && node.await === true)\n    );\n}", "category": "Python"}, {"instruction": "Creates and returns a QueryList.\n\n@param memoryIndex The index in memory where the QueryList should be saved. If null,\nthis is is a content query and the QueryList will be saved later through directiveCreate.\n@param predicate The type for which the query will search\n@param descend Whether or not to descend into children\n@param read What to save in the query\n@returns QueryList<T>", "input": "JavaScript", "output": "function query(memoryIndex, predicate, descend, read) {\n    ngDevMode && assertPreviousIsParent();\n    var queryList = new QueryList$1();\n    var queries = getCurrentQueries(LQueries_);\n    queries.track(queryList, predicate, descend, read);\n    storeCleanupWithContext(null, queryList, queryList.destroy);\n    if (memoryIndex != null) {\n        store(memoryIndex, queryList);\n    }\n    return queryList;\n}", "category": "Python"}, {"instruction": "('(' supports condition ')')\n| feature", "input": "JavaScript", "output": "function(){\n    this.skipSpacesAndComments();\n    if ('(' == this.peek().type) {\n      var la = this.lookahead(2).type;\n\n      if ('ident' == la || '{' == la) {\n        return this.feature();\n      } else {\n        this.expect('(');\n        var node = new nodes.Expression;\n        node.push(new nodes.Literal('('));\n        node.push(this.supportsCondition());\n        this.expect(')')\n        node.push(new nodes.Literal(')'));\n        this.skipSpacesAndComments();\n        return node;\n      }\n    }\n  }", "category": "Python"}, {"instruction": "Get the detailed information of an inspected instance.\n\n@param {Number} id", "input": "JavaScript", "output": "function getInstanceDetails (id) {\n  const instance = instanceMap.get(id)\n  if (!instance) {\n    const vnode = findInstanceOrVnode(id)\n\n    if (!vnode) return {}\n\n    const data = {\n      id,\n      name: getComponentName(vnode.fnOptions),\n      file: vnode.fnOptions.__file || null,\n      state: processProps({ $options: vnode.fnOptions, ...(vnode.devtoolsMeta && vnode.devtoolsMeta.renderContext.props) }),\n      functional: true\n    }\n\n    return data\n  } else {\n    const data = {\n      id: id,\n      name: getInstanceName(instance),\n      state: getInstanceState(instance)\n    }\n\n    let i\n    if ((i = instance.$vnode) && (i = i.componentOptions) && (i = i.Ctor) && (i = i.options)) {\n      data.file = i.__file || null\n    }\n\n    return data\n  }\n}", "category": "Python"}, {"instruction": "Get ReplicaSet status\n\n@param {Admin} a collection instance.\n@param {Object} [options] Optional settings. See Admin.prototype.replSetGetStatus for a list of options.\n@param {Admin~resultCallback} [callback] The command result callback.", "input": "JavaScript", "output": "function replSetGetStatus(admin, options, callback) {\n  executeDbAdminCommand(admin.s.db, { replSetGetStatus: 1 }, options, callback);\n}", "category": "Python"}, {"instruction": "Cache size has been exceeded, create list of images sorted by timeStamp So we can purge the least recently used image", "input": "JavaScript", "output": "function compare (a, b) {\r\n    if (a.timeStamp > b.timeStamp) {\r\n      return -1;\r\n    }\r\n    if (a.timeStamp < b.timeStamp) {\r\n      return 1;\r\n    }\r\n\r\n    return 0;\r\n  }", "category": "Python"}, {"instruction": "parse JSDoc from leading comments\n@param  {...[type]} comments [description]\n@return {{doc: object}}", "input": "JavaScript", "output": "function captureJsDoc(comments) {\n  let doc\n\n  // capture XSDoc\n  comments.forEach(comment => {\n    // skip non-block comments\n    if (comment.type !== 'Block') return\n    try {\n      doc = doctrine.parse(comment.value, { unwrap: true })\n    } catch (err) {\n      /* don't care, for now? maybe add to `errors?` */\n    }\n  })\n\n  return doc\n}", "category": "Python"}, {"instruction": "Sets which annotations types are shown in the overview ruler.  Annotations are visible by default.\n\n@param {Object} types a hash table mapping annotation type to visibility (i.e. AnnotationType.ANNOTATION_INFO -> true).\n@since 14.0", "input": "JavaScript", "output": "function(types) {\n\t\t\tif (textUtil.compare(this._overviewAnnotationTypesVisible, types)) return;\n\t\t\tthis._overviewAnnotationTypesVisible = types;\n\t\t\tif (!this._overviewRuler || !this._textView || !this._overviewRulerVisible) { return; }\n\t\t\tthis._overviewRuler.setAnnotationTypeVisible(types);\n\t\t\tthis._textView.redrawLines(0, undefined, this._overviewRuler);\n\t\t}", "category": "Python"}, {"instruction": "Buffer data from socket to present\nwell formed packets", "input": "JavaScript", "output": "function BufferLayer(socket) {\n\t//for ssl connection\n\tthis.securePair = null;\n\tthis.socket = socket;\n\n\tvar self = this;\n\t// bind event\n\tthis.socket.on('data', function(data) {\n\t\ttry {\n\t\t\tself.recv(data);\n\t\t}\n\t\tcatch(e) {\n\t\t\tself.socket.destroy();\n\t\t\tself.emit('error', e);\n\t\t}\n\t}).on('close', function() {\n\t\tself.emit('close');\n\t}).on('error', function (err) {\n\t\tself.emit('error', err);\n\t});\n\n\t//buffer data\n\tthis.buffers = [];\n\tthis.bufferLength = 0;\n\t//expected size\n\tthis.expectedSize = 0;\n}", "category": "Python"}, {"instruction": "Collect common metadata for each object in the value tree, ensuring that equivalent values have the *same reference* to the same metadata. Note that the hashes generated are not exactly JSON, but still identify equivalent values. Runs in linear time due to hashing in a bottom-up recursion.", "input": "JavaScript", "output": "function collectMetadata(value) {\n    if (value == null || typeof value !== 'object') {\n      return JSON.stringify(value);\n    }\n    let hash;\n    if (Array.isArray(value)) {\n      hash = '[';\n      for (let i = 0; i < value.length; i++) {\n        hash += collectMetadata(value[i]) + ',';\n      }\n    } else {\n      hash = '{';\n      for (const k in value) {\n        if (value.hasOwnProperty(k) && value[k] !== undefined) {\n          hash += k + ':' + collectMetadata(value[k]) + ',';\n        }\n      }\n    }\n    let metadata = metadataForHash.get(hash);\n    if (!metadata) {\n      metadata = {value, hash, isDuplicate: false};\n      metadataForHash.set(hash, metadata);\n    }\n    metadataForVal.set(value, metadata);\n    return hash;\n  }", "category": "Python"}, {"instruction": "private", "input": "JavaScript", "output": "function() {\n        this._containerInnerSize = new $.Point(\n            Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)),\n            Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom))\n        );\n    }", "category": "Python"}, {"instruction": "focusToFirstCode\nFocus to first code tag content of pre tag\n@param {jQuery} $pre pre tag\n@param {WysiwygEditor} wwe wysiwygEditor", "input": "JavaScript", "output": "function focusToFirstCode($pre, wwe) {\n  const range = wwe.getEditor().getSelection().cloneRange();\n  $pre.removeClass(CODEBLOCK_CLASS_TEMP);\n\n  range.setStartBefore($pre.get(0).firstChild);\n  range.collapse(true);\n\n  wwe.getEditor().setSelection(range);\n}", "category": "Python"}, {"instruction": "Creates a search job with a given search query and optional parameters, including `exec_mode` to specify the type of search:\n\n- Use `exec_mode=normal` to return a search job ID immediately (default).\nPoll for completion to find out when you can retrieve search results.\n\n- Use `exec_mode=blocking` to return the search job ID when the search has finished.\n\nTo run a oneshot search, which does not create a job but rather returns the search results, use `Service.oneshotSearch`.\n\n@example\n\nservice.search(\"search ERROR\", {id: \"myjob_123\"}, function(err, newJob) {\nconsole.log(\"CREATED\": newJob.sid);\n});\n\n@param {String} query The search query.\n@param {Object} params A dictionary of properties for the job. For a list of available parameters, see <a href=\" http://dev.splunk.com/view/SP-CAAAEFA#searchjobparams\" target=\"_blank\">Search job parameters</a> on Splunk Developer Portal.\n@param {Object} namespace Namespace information:\n- `owner` (_string_): The Splunk username, such as \"admin\". A value of \"nobody\" means no specific user. The \"-\" wildcard means all users.\n- `app` (_string_): The app context for this resource (such as \"search\"). The \"-\" wildcard means all apps.\n- `sharing` (_string_): A mode that indicates how the resource is shared. The sharing mode can be \"user\", \"app\", \"global\", or \"system\".\n@param {Function} callback A function to call with the created job: `(err, createdJob)`.\n\n@endpoint search/jobs\n@method splunkjs.Service", "input": "JavaScript", "output": "function(query, params, namespace, callback) {\n            if (!callback && utils.isFunction(namespace)) {\n                callback = namespace;\n                namespace = null;\n            }\n            \n            var jobs = new root.Jobs(this, namespace);\n            return jobs.search(query, params, callback);\n        }", "category": "Python"}, {"instruction": "# zipWith :: (a -> b -> c) -> Array a -> Array b -> Array c . . Returns the result of combining, pairwise, the given arrays using the . given binary function. The length of the resulting array is equal to the . length of the shorter input array. . . See also [`zip`](#zip). . . ```javascript . > S.zipWith (a => b => a + b) (['a', 'b']) (['x', 'y', 'z']) . ['ax', 'by'] . . > S.zipWith (a => b => [a, b]) ([1, 3, 5]) ([2, 4]) . [[1, 2], [3, 4]] . ```", "input": "JavaScript", "output": "function zipWith(f) {\n    return function(xs) {\n      return function(ys) {\n        var result = [];\n        var len = Math.min (xs.length, ys.length);\n        for (var idx = 0; idx < len; idx += 1) {\n          result.push (f (xs[idx]) (ys[idx]));\n        }\n        return result;\n      };\n    };\n  }", "category": "Python"}, {"instruction": "mirror jQuery#val functionality: reads opearte on first match, write operates on all matches", "input": "JavaScript", "output": "function val(newVal) {\n      var query;\n\n      if (!arguments.length) {\n        ttEach(this.first(), function(t) { query = t.getVal(); });\n        return query;\n      }\n\n      else {\n        ttEach(this, function(t) { t.setVal(newVal); });\n        return this;\n      }\n    }", "category": "Python"}, {"instruction": "------------------------------ Attach global event listener ------------------------------", "input": "JavaScript", "output": "function addListener(eventType, fn){\n  if (document.addEventListener) {\n    document.addEventListener(eventType, fn, false);\n  } else {\n    document.attachEvent(\"on\" + eventType, fn);\n  }\n}", "category": "Python"}, {"instruction": "DeleteMany function exposed as a mongoose wrapper.\n@param model: A mongoose model.\n@param payload: Either an array of ids or an array of objects containing an id and a \"hardDelete\" flag.\n@param Log: A logging object.\n@returns {object} A promise returning true if the delete succeeds.\n@private", "input": "JavaScript", "output": "function _deleteMany(model, payload, Log) {\n  let request = { payload: payload }\n  return _deleteManyHandler(model, request, Log)\n}", "category": "Python"}, {"instruction": "Gets the first visible child in the openMenuNode\nNecessary incase menu nodes are being dynamically hidden", "input": "JavaScript", "output": "function firstVisibleChild() {\n        for (var i = 0; i < openMenuNode.children.length; ++i) {\n          if ($window.getComputedStyle(openMenuNode.children[i]).display != 'none') {\n            return openMenuNode.children[i];\n          }\n        }\n      }", "category": "Python"}, {"instruction": "removes a given listener by looking at all registered targets and their listeners. if there are no more listeners to a target, the registered target is removed from the mTargets map.", "input": "JavaScript", "output": "function destroy(oListener) {\n\t\tfor (var n in mTargets) {\n\t\t\tvar oTargetConfig = mTargets[n];\n\t\t\tfor (var i = 0; i < oTargetConfig.listeners.length; i++) {\n\t\t\t\tif (oTargetConfig.listeners[i] === oListener) {\n\t\t\t\t\toTargetConfig.listeners.splice(i, 1);\n\t\t\t\t\toTargetConfig.configurations.splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (oTargetConfig.listeners && oTargetConfig.listeners.length === 0) {\n\t\t\t\tdelete mTargets[n];\n\t\t\t\toTargetConfig.object._observer = undefined;\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "/*!\nRecursively check the equality of two objects.\nOnce basic sameness has been established it will\ndefer to `deepEqual` for each enumerable key\nin the object.\n\n@param {Mixed} a\n@param {Mixed} b\n@return {Boolean} result", "input": "JavaScript", "output": "function objectEqual(a, b, m) {\n  if (!isValue(a) || !isValue(b)) {\n    return false;\n  }\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  var i;\n  if (m) {\n    for (i = 0; i < m.length; i++) {\n      if ((m[i][0] === a && m[i][1] === b)\n      ||  (m[i][0] === b && m[i][1] === a)) {\n        return true;\n      }\n    }\n  } else {\n    m = [];\n  }\n\n  try {\n    var ka = enumerable(a);\n    var kb = enumerable(b);\n  } catch (ex) {\n    return false;\n  }\n\n  ka.sort();\n  kb.sort();\n\n  if (!iterableEqual(ka, kb)) {\n    return false;\n  }\n\n  m.push([ a, b ]);\n\n  var key;\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], m)) {\n      return false;\n    }\n  }\n\n  return true;\n}", "category": "Python"}, {"instruction": "same as Array.prototype.slice, but also works on typed arrays", "input": "JavaScript", "output": "function( array, from, to ) {\n\n\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\n\t\t}\n\n\t\treturn array.slice( from, to );\n\n\t}", "category": "Python"}, {"instruction": "PrivateFunction: _restartRequest\n_Private_ function to restart a request that is presumed dead.\n\nParameters:\n(Integer) i - The index of the request in the queue.", "input": "JavaScript", "output": "function (i)\r\n    {\r\n        var req = this._requests[i];\r\n        if (req.dead === null) {\r\n            req.dead = new Date();\r\n        }\r\n\r\n        this._processRequest(i);\r\n    }", "category": "Python"}, {"instruction": "Constructs notification info URL for XHR\n\n@param {string=} localeParam - optional locale, defaults to 'brackets.getLocale()' when omitted.\n@returns {string} the new notification info url", "input": "JavaScript", "output": "function _getVersionInfoUrl(localeParam) {\n\n        var locale = localeParam || brackets.getLocale();\n\n        if (locale.length > 2) {\n            locale = locale.substring(0, 2);\n        }\n\n        return brackets.config.notification_info_url.replace(\"<locale>\", locale);\n    }", "category": "Python"}, {"instruction": "Remove node from scene", "input": "JavaScript", "output": "function (node) {\n        var idx;\n        if (node instanceof Camera) {\n            idx = this._cameraList.indexOf(node);\n            if (idx >= 0) {\n                this._cameraList.splice(idx, 1);\n            }\n        }\n        else if (node instanceof Light) {\n            idx = this.lights.indexOf(node);\n            if (idx >= 0) {\n                this.lights.splice(idx, 1);\n            }\n        }\n        if (node.name) {\n            delete this._nodeRepository[node.name];\n        }\n    }", "category": "Python"}, {"instruction": "/* @type {Object.<string, ConfigView>} List of open views", "input": "JavaScript", "output": "function ConfigView(doc, $container) {\n        this.$container = $container;\n        this.doc = doc;\n        this.json = JSON.parse(this.doc.getText());\n        this.$view = $(Mustache.render(ConfigViewContent, this.json));\n        this.$view.css({\n            \"background-image\": \"url(file://\" + FileUtils.getNativeModuleDirectoryPath(_module) + \"/htmlContent/logo-sm.png)\",\n            \"background-position\": \"bottom right\",\n            \"background-repeat\": \"no-repeat\"\n        });\n        $container.append(this.$view);\n    }", "category": "Python"}, {"instruction": "Properties of a ListOperationsRequest.\n@memberof google.longrunning\n@interface IListOperationsRequest\n@property {string|null} [name] ListOperationsRequest name\n@property {string|null} [filter] ListOperationsRequest filter\n@property {number|null} [pageSize] ListOperationsRequest pageSize\n@property {string|null} [pageToken] ListOperationsRequest pageToken\n \nConstructs a new ListOperationsRequest.\n@memberof google.longrunning\n@classdesc Represents a ListOperationsRequest.\n@implements IListOperationsRequest\n@constructor\n@param {google.longrunning.IListOperationsRequest=} [properties] Properties to set", "input": "JavaScript", "output": "function ListOperationsRequest(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }", "category": "Python"}, {"instruction": "Creates a local instance of a storage password.\n\n@param {Object} props The properties for the new storage password. For a list of available parameters,\nsee <a href=\"http://docs.splunk.com/Documentation/Splunk/latest/RESTAPI/RESTaccess#POST_storage.2Fpasswords\" target=\"_blank\">\nPOST storage/passwords</a> on Splunk Developer Portal.\n@return {splunkjs.Service.SavedSearch} A new `splunkjs.Service.StoragePassword` instance.\n\n@method splunkjs.Service.StoragePasswords", "input": "JavaScript", "output": "function(props) {\n            var entityNamespace = utils.namespaceFromProperties(props);\n            return new root.StoragePassword(this.service, props.name, entityNamespace);\n        }", "category": "Python"}, {"instruction": "/*!\nCalculates the interpolated tween values of an Object for a given\ntimestamp.\n@param {Number} forPosition The position to compute the state for.\n@param {Object} currentState Current state properties.\n@param {Object} originalState: The original state properties the Object is\ntweening from.\n@param {Object} targetState: The destination state properties the Object\nis tweening to.\n@param {number} duration: The length of the tween in milliseconds.\n@param {number} timestamp: The UNIX epoch time at which the tween began.\n@param {Object} easing: This Object's keys must correspond to the keys in\ntargetState.", "input": "JavaScript", "output": "function tweenProps (forPosition, currentState, originalState, targetState,\n      duration, timestamp, easing) {\n      var normalizedPosition = (forPosition - timestamp) / duration;\n\n      var prop;\n      for (prop in currentState) {\n        if (currentState.hasOwnProperty(prop)) {\n          currentState[prop] = tweenProp(originalState[prop],\n            targetState[prop], formula[easing[prop]], normalizedPosition);\n        }\n      }\n\n      return currentState;\n    }", "category": "Python"}, {"instruction": "Function: addStylename\n\nAdds the specified stylename to the given style if it does not already\ncontain the stylename.", "input": "JavaScript", "output": "function(style, stylename)\n\t{\n\t\tif (mxUtils.indexOfStylename(style, stylename) < 0)\n\t\t{\n\t\t\tif (style == null)\n\t\t\t{\n\t\t\t\tstyle = '';\n\t\t\t}\n\t\t\telse if (style.length > 0 && style.charAt(style.length - 1) != ';')\n\t\t\t{\n\t\t\t\tstyle += ';';\n\t\t\t}\n\t\t\t\n\t\t\tstyle += stylename;\n\t\t}\n\t\t\n\t\treturn style;\n\t}", "category": "Python"}, {"instruction": "Returns the value that is the nearest power of 2 less than or equal to the given value.\n@param {Number} value the reference value. The power of 2 returned is less than or equal to this value.\n@returns {Number} the value that is the nearest power of 2 less than or equal to the reference value", "input": "JavaScript", "output": "function (value) {\n                var power = Math.floor(Math.log(value) / Math.log(2));\n                return Math.pow(2, power);\n            }", "category": "Python"}, {"instruction": "Check if is running inside Now.sh and apply variables and secrets to `process.env`", "input": "JavaScript", "output": "function config() {\n  // only run this if it's not running inside Now.sh\n  if (Boolean(process.env.NOW_REGION || process.env.NOW)) return\n\n  const secrets = loadSecrets()\n  const required = loadRequired()\n\n  // load environment variables from now.json\n  loadNowJSON(secrets, required)\n}", "category": "Python"}, {"instruction": "Generate a URL with the host data given by opts and the given path", "input": "JavaScript", "output": "function genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  var pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}", "category": "Python"}, {"instruction": "Insert a screen reader hint for a comment\n\n@param {String} documentId The ID of the document\n@param {String} annotationId The ID of tha assocated annotation\n@param {Object} comment The comment to insert a hint for", "input": "JavaScript", "output": "function insertComment(documentId, annotationId, comment) {\n  let list = document.querySelector(`pdf-annotate-screenreader-comment-list-${annotationId}`);\n  let promise;\n\n  if (!list) {\n    promise = renderScreenReaderComments(documentId, annotationId, []).then(() => {\n      list = document.querySelector(`pdf-annotate-screenreader-comment-list-${annotationId}`);\n      return true;\n    });\n  } else {\n    promise = Promise.resolve(true);\n  }\n\n  promise.then(() => {\n    insertScreenReaderComment(comment);\n  });\n}", "category": "Python"}, {"instruction": "\u83b7\u53d6\u6e10\u53d8\u51fd\u6570\n@param  {Array} colors \u591a\u4e2a\u989c\u8272\n@return {String} \u989c\u8272\u503c", "input": "JavaScript", "output": "function gradient(colors) {\n    var points = [];\n    if (isString(colors)) {\n      colors = colors.split('-');\n    }\n    each(colors, function (color) {\n      if (color.indexOf('#') === -1) {\n        color = ColorUtil.toRGB(color);\n      }\n      points.push(rgb2arr(color));\n    });\n    return function (percent) {\n      return calColor(points, percent);\n    };\n  }", "category": "Python"}, {"instruction": "checks if companion is authorized to access a user's provider account.\n\n@param {object} req\n@param {object} res", "input": "JavaScript", "output": "function authorized (req, res) {\n  const { params, uppy } = req\n  const providerName = params.providerName\n\n  if (!uppy.providerTokens || !uppy.providerTokens[providerName]) {\n    return res.json({ authenticated: false })\n  }\n\n  const token = uppy.providerTokens[providerName]\n  uppy.provider.list({ token, uppy }, (err, response, body) => {\n    const notAuthenticated = Boolean(err)\n    if (notAuthenticated) {\n      logger.debug(`${providerName} failed authorizarion test err:${err}`, 'provider.auth.check')\n    }\n    return res.json({ authenticated: !notAuthenticated })\n  })\n}", "category": "Python"}, {"instruction": "/*\nExecute the given callback once the DOM is ready (which might already be the case).", "input": "JavaScript", "output": "function whenReady(callback) {\n\n\t\tfunction onLoaded() {\n\t\t\tdocument.removeEventListener( \"DOMContentLoaded\", onLoaded, false );\n\t\t\tcallback();\n\t\t}\n\n\t\tif ( document.readyState === 'complete' ) {\n\t\t\tcallback();\n\t\t} else {\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", onLoaded, false );\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Get the current user's followed artists.\n@param {Object} [options] Options, being after and limit.\n@param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n@returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which contains\nalbum objects. Not returned if a callback is given.", "input": "JavaScript", "output": "function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withQueryParameters(\n        {\n          type: 'artist'\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.get, callback);\n  }", "category": "Python"}, {"instruction": "amount of pixels to drag to determine direction of swipe", "input": "JavaScript", "output": "function(e, isDown) {\n\t    _preventObj.prevent = !_closestElement(e.target, _options.isClickableElement);\n\n\t\t_shout('preventDragEvent', e, isDown, _preventObj);\n\t\treturn _preventObj.prevent;\n\n\t}", "category": "Python"}, {"instruction": "Based off of the plugin by Clint Helfers, with permission. http://blindsignals.com/index.php/2009/07/jquery-delay/", "input": "JavaScript", "output": "function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n\t\ttype = type || \"fx\";\n\n\t\treturn this.queue( type, function() {\n\t\t\tvar elem = this;\n\t\t\tsetTimeout(function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t}, time );\n\t\t});\n\t}", "category": "Python"}, {"instruction": "@private\n\nRecursively walks Mustache tokens, and creates a tree that Vapid understands.\n\n@param {Object} tree - a memo that holds the total tree value\n@param {array} branch - Mustache tokens\n@param {string} branchToken - current branch name and params\n@return {Object} tree of sections, fields, params, etc.\n /* eslint-disable no-param-reassign", "input": "JavaScript", "output": "function _walk(tree, branch, branchToken = 'general') {\n  tree[branchToken] = tree[branchToken] || _initBranch(branchToken);\n\n  branch.forEach((leaf) => {\n    switch (leaf[0]) {\n      case 'name': {\n        _addToTree(tree, branchToken, leaf[1]);\n        break;\n      }\n      case '#': {\n        const [, keyword, remainder] = leaf[1].toLowerCase().match(LEAF_REGEX);\n\n        if (Utils.includes(Goatee.CONDITIONALS, keyword)) {\n          if (this.options.parseConditionals) {\n            _addToTree(tree, branchToken, Utils.trim(remainder));\n          }\n          _walk.call(this, tree, leaf[4], branchToken);\n        } else {\n          _walk.call(this, tree, leaf[4], leaf[1]);\n        }\n\n        break;\n      }\n      default: {\n        // Do nothing\n      }\n    }\n  });\n\n  return tree;\n}", "category": "Python"}, {"instruction": "@private\n\nReturns the full path to the welcome project, which we open on first launch.\n\n@param {string} sampleUrl URL for getting started project\n@param {string} initialPath Path to Brackets directory (see {@link FileUtils::#getNativeBracketsDirectoryPath})\n@return {!string} fullPath reference", "input": "JavaScript", "output": "function _getWelcomeProjectPath(sampleUrl, initialPath) {\n        if (sampleUrl) {\n            // Back up one more folder. The samples folder is assumed to be at the same level as\n            // the src folder, and the sampleUrl is relative to the samples folder.\n            initialPath = initialPath.substr(0, initialPath.lastIndexOf(\"/\")) + \"/samples/\" + sampleUrl;\n        }\n\n        return _ensureTrailingSlash(initialPath); // paths above weren't canonical\n    }", "category": "Python"}, {"instruction": "Get the URI to locate the entity set for the query result.\n\n@param {String}\nsServiceRootURI (optional) Identifies the root of the OData\nservice\n\n@returns {String} The resource path of the URI pointing to the entity\nset. It is a relative URI unless a service root is given, which\nwould then prefixed in order to return a complete URL.\n@public\n@function\n@name sap.ui.model.analytics.odata4analytics.QueryResultRequest#getURIToQueryResultEntitySet", "input": "JavaScript", "output": "function(sServiceRootURI) {\n\t\t\tvar sURI = null;\n\t\t\tif (this._sResourcePath != null) {\n\t\t\t\tsURI = (sServiceRootURI ? sServiceRootURI : \"\") + this._sResourcePath;\n\t\t\t} else if (this._oQueryResult.getParameterization()) {\n\t\t\t\tif (!this._oParameterizationRequest) {\n\t\t\t\t\tthrow \"Missing parameterization request\";\n\t\t\t\t} else {\n\t\t\t\t\tsURI = this._oParameterizationRequest.getURIToParameterizationEntry(sServiceRootURI) + \"/\"\n\t\t\t\t\t\t\t+ this._oQueryResult.getParameterization().getNavigationPropertyToQueryResult();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsURI = (sServiceRootURI ? sServiceRootURI : \"\") + \"/\" + this._oQueryResult.getEntitySet().getQName();\n\t\t\t}\n\t\t\treturn sURI;\n\t\t}", "category": "Python"}, {"instruction": "tracks which channels are active", "input": "JavaScript", "output": "function connect() {\r\n    easyrtc.enableDebug(false);\r\n    easyrtc.enableDataChannels(true);\r\n    easyrtc.enableVideo(false);\r\n    easyrtc.enableAudio(false);\r\n    easyrtc.enableVideoReceive(false);\r\n    easyrtc.enableAudioReceive(false);\r\n    easyrtc.setDataChannelOpenListener(openListener);\r\n    easyrtc.setDataChannelCloseListener(closeListener);\r\n    easyrtc.setPeerListener(addToConversation);\r\n    easyrtc.setRoomOccupantListener(convertListToButtons);\r\n    easyrtc.connect(\"easyrtc.dataMessaging\", loginSuccess, loginFailure);\r\n}", "category": "Python"}, {"instruction": "Each layout consists of vertical panels, that contains its position and horizontal views. Flex-like positions of panels and views defined by 'grow' and 'size' parameters. View or panel with 'size' has exactly <size> height or width respectively. View or panel with 'grow' fills <grow> part of the residuary space (it works like flex-grow). By default, position = { grow: 1 }", "input": "JavaScript", "output": "function (position) {\n  if (!_.has(position, \"grow\") && !_.has(position, \"size\")) {\n    position = { grow: 1 };\n  }\n\n  return position;\n}", "category": "Python"}, {"instruction": "Binds swipe's moving event.\n\n@return {Void}", "input": "JavaScript", "output": "function bindSwipeMove() {\n      var _this2 = this;\n\n      Binder.on(MOVE_EVENTS, Components.Html.wrapper, throttle(function (event) {\n        _this2.move(event);\n      }, Glide.settings.throttle), capture);\n    }", "category": "Python"}, {"instruction": "$NON-NLS-0$", "input": "JavaScript", "output": "function(branchLocation, name) {\n\t\t\t\t\tvar addMsg = i18nUtil.formatMessage(messages[\"Adding branch ${0}...\"], name);\n\t\t\t\t\tprogress.progress(serviceRegistry.getService(\"orion.git.provider\").addBranch(branchLocation, name), addMsg).then(function() { //$NON-NLS-0$\n\t\t\t\t\t\tdispatchModelEventOn({type: \"modelChanged\", action: \"addBranch\", branch: name}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t}, function(error){\n\t\t\t\t\t\tif(error.status===409){\n\t\t\t\t\t\t\tcommandInvocation.parameters = branchNameParameters;\n\t\t\t\t\t\t\tcommandService.collectParameters(commandInvocation);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdisplayErrorOnStatus(error);\n\t\t\t\t\t});\n\t\t\t\t}", "category": "Python"}, {"instruction": "Parse the input, then return the root node.\n\n@return {Node}\n@api private", "input": "JavaScript", "output": "function(){\n    var block = this.parent = this.root;\n    if (Parser.cache.has(this.hash)) {\n      block = Parser.cache.get(this.hash);\n      // normalize cached imports\n      if ('block' == block.nodeName) block.constructor = nodes.Root;\n    } else {\n      while ('eos' != this.peek().type) {\n        this.skipWhitespace();\n        if ('eos' == this.peek().type) break;\n        var stmt = this.statement();\n        this.accept(';');\n        if (!stmt) this.error('unexpected token {peek}, not allowed at the root level');\n        block.push(stmt);\n      }\n      Parser.cache.set(this.hash, block);\n    }\n    return block;\n  }", "category": "Python"}, {"instruction": "Closes the row stream.\n\n@param {Error} [err]", "input": "JavaScript", "output": "function(err)\n  {\n    // if we have a result stream, stop listening to events on it\n    if (resultStream)\n    {\n      resultStream.removeListener('data', onResultStreamData);\n      resultStream.removeListener('close', onResultStreamClose);\n    }\n\n    // we're done, so time to clean up\n    rowBuffer = null;\n    rowIndex = 0;\n    resultStream = null;\n    numResultStreamInterrupts = 0;\n\n    if (err)\n    {\n      emitError(err);\n    }\n    else\n    {\n      self.push(null);\n    }\n  }", "category": "Python"}, {"instruction": "render html from uml\n@param {string} umlCode - plant uml code text\n@returns {string} - rendered html", "input": "JavaScript", "output": "function plantUMLReplacer(umlCode) {\n    let renderedHTML;\n\n    try {\n      if (!plantumlEncoder) {\n        throw new Error('plantuml-encoder dependency required');\n      }\n      renderedHTML = `<img src=\"${rendererURL}${plantumlEncoder.encode(umlCode)}\" />`;\n    } catch (err) {\n      renderedHTML = `Error occurred on encoding uml: ${err.message}`;\n    }\n\n    return renderedHTML;\n  }", "category": "Python"}, {"instruction": "Add command for bot to clear the room history (requires client reload).\ne.g. \"bot clr\" or \"@bot clear room\" or \"bot clr from June 3, 2018 17:30\".\n@param {Robot} robot The Hubot instance", "input": "JavaScript", "output": "function load (robot) {\n  robot.respond(/\\b(clean room|clr)( from (.*))?(\\.|!|)?$/i, async (res) => {\n    try {\n      const from = res.match[3] || 'May 19, 2015 04:36:09' // clear all if not given date\n      const oldest = new Date(from).toISOString()\n      const cleaned = await cleanRoomHistory(robot, res.message.user, oldest).catch()\n      if (typeof cleaned === 'undefined') {\n        res.reply(`Sorry, I'm afraid I can't do that.`)\n      }\n    } catch (err) {\n      res.reply(`That wasn't a valid date`)\n    }\n  })\n}", "category": "Python"}, {"instruction": "image-specific code (override to implement e.g. Canvas or SVG tile layer)", "input": "JavaScript", "output": "function (tilePoint) {\n\t\treturn L.Util.template(this._url, L.extend({\n\t\t\ts: this._getSubdomain(tilePoint),\n\t\t\tz: tilePoint.z,\n\t\t\tx: tilePoint.x,\n\t\t\ty: tilePoint.y\n\t\t}, this.options));\n\t}", "category": "Python"}, {"instruction": "Returns whether the busy indicator is visible. It is considered as visible when the busy indicator element exists in the DOM as\na child of the table element. It is not checked whether the indicator is actually visible on the screen.\n\n@param {sap.ui.table.Table} oTable Instance of the table.\n@returns {boolean} Whether the busy indicator is visible.", "input": "JavaScript", "output": "function(oTable) {\n\t\t\tif (!oTable || !oTable.getDomRef()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn oTable.getDomRef().querySelector(\"#\" + oTable.getId() + \"-sapUiTableGridCnt > .sapUiLocalBusyIndicator\") != null;\n\t\t}", "category": "Python"}, {"instruction": "/*\nConvert an array of little-endian words to a hex string.", "input": "JavaScript", "output": "function (binarray) {\r\n        var hex_tab = \"0123456789abcdef\";\r\n        var str = \"\";\r\n        for(var i = 0; i < binarray.length * 4; i++)\r\n        {\r\n            str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +\r\n                hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);\r\n        }\r\n        return str;\r\n    }", "category": "Python"}, {"instruction": "Encrypt plaintext input.\n@param  {Uint8Array} plaintext   The cleartext input to be encrypted\n@param  {Uint8Array} nonce       The nonce (16 bytes)\n@param  {Uint8Array} adata       Associated data to sign\n@returns {Promise<Uint8Array>}    The ciphertext output", "input": "JavaScript", "output": "async function(plaintext, nonce, adata) {\n      const [\n        omacNonce,\n        omacAdata\n      ] = await Promise.all([\n        omac(zero, nonce),\n        omac(one, adata)\n      ]);\n      const ciphered = await ctr(plaintext, omacNonce);\n      const omacCiphered = await omac(two, ciphered);\n      const tag = omacCiphered; // Assumes that omac(*).length === tagLength.\n      for (let i = 0; i < tagLength; i++) {\n        tag[i] ^= omacAdata[i] ^ omacNonce[i];\n      }\n      return util.concatUint8Array([ciphered, tag]);\n    }", "category": "Python"}, {"instruction": "Convolve the image with the specified kernel.\n\n@example\nsharp(input)\n.convolve({\nwidth: 3,\nheight: 3,\nkernel: [-1, 0, 1, -2, 0, 2, -1, 0, 1]\n})\n.raw()\n.toBuffer(function(err, data, info) {\n// data contains the raw pixel data representing the convolution\n// of the input image with the horizontal Sobel operator\n});\n\n@param {Object} kernel\n@param {Number} kernel.width - width of the kernel in pixels.\n@param {Number} kernel.height - width of the kernel in pixels.\n@param {Array<Number>} kernel.kernel - Array of length `width*height` containing the kernel values.\n@param {Number} [kernel.scale=sum] - the scale of the kernel in pixels.\n@param {Number} [kernel.offset=0] - the offset of the kernel in pixels.\n@returns {Sharp}\n@throws {Error} Invalid parameters", "input": "JavaScript", "output": "function convolve (kernel) {\n  if (!is.object(kernel) || !Array.isArray(kernel.kernel) ||\n      !is.integer(kernel.width) || !is.integer(kernel.height) ||\n      !is.inRange(kernel.width, 3, 1001) || !is.inRange(kernel.height, 3, 1001) ||\n      kernel.height * kernel.width !== kernel.kernel.length\n  ) {\n    // must pass in a kernel\n    throw new Error('Invalid convolution kernel');\n  }\n  // Default scale is sum of kernel values\n  if (!is.integer(kernel.scale)) {\n    kernel.scale = kernel.kernel.reduce(function (a, b) {\n      return a + b;\n    }, 0);\n  }\n  // Clip scale to a minimum value of 1\n  if (kernel.scale < 1) {\n    kernel.scale = 1;\n  }\n  if (!is.integer(kernel.offset)) {\n    kernel.offset = 0;\n  }\n  this.options.convKernel = kernel;\n  return this;\n}", "category": "Python"}, {"instruction": "This function memoize results for _computeMarkerId\nsince many of the times user will be playing around with the same zoom\nfactor, we can take advantage of this and cache the results for a\ngiven combination of highlight state, zoom transform value and maxZoom config.\n@returns{Function} memoize wrapper to the _computeMarkerId operation.\n@memberof Marker/helper", "input": "JavaScript", "output": "function _memoizedComputeMarkerId() {\n    let cache = {};\n\n    return (highlight, transform, { maxZoom }) => {\n        const cacheKey = `${highlight};${transform};${maxZoom}`;\n\n        if (cache[cacheKey]) {\n            return cache[cacheKey];\n        }\n\n        const markerId = _computeMarkerId(highlight, transform, { maxZoom });\n\n        cache[cacheKey] = markerId;\n\n        return markerId;\n    };\n}", "category": "Python"}, {"instruction": "Given an AST and an array of variableDeclaration nodes, return a new AST with\nall the declarations at the top of the AST.", "input": "JavaScript", "output": "function addTopDeclarationNodes(ast: Object, declarationNodes: Object[]) {\n  const statements = [];\n  declarationNodes.forEach(declarationNode => {\n    statements.push(getDeclarations(declarationNode));\n  });\n  statements.push(ast);\n  return t.program(statements);\n}", "category": "Python"}, {"instruction": "//////////////////////////////////////////////////////////// Converts a connection string or object into its safe copy: if password is present, it is masked with symbol '#'.", "input": "JavaScript", "output": "function getSafeConnection(cn) {\n    if (typeof cn === 'object') {\n        const copy = Object.assign({}, cn);\n        if (typeof copy.password === 'string') {\n            copy.password = copy.password.replace(/./g, '#');\n        }\n        if (typeof copy.connectionString === 'string') {\n            copy.connectionString = maskPassword(copy.connectionString);\n        }\n        return copy;\n    }\n    return maskPassword(cn);\n}", "category": "Python"}, {"instruction": "Returns the spherical area for a list of coordinates.\n\n[Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\nRobert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\nPolygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\nLaboratory, Pasadena, CA, June 2007\n\n@param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\nring. If the ring is oriented clockwise, the area will be positive,\notherwise it will be negative.\n@param {number} radius The sphere radius.\n@return {number} Area (in square meters).", "input": "JavaScript", "output": "function getAreaInternal(coordinates, radius) {\n  let area = 0;\n  const len = coordinates.length;\n  let x1 = coordinates[len - 1][0];\n  let y1 = coordinates[len - 1][1];\n  for (let i = 0; i < len; i++) {\n    const x2 = coordinates[i][0];\n    const y2 = coordinates[i][1];\n    area += toRadians(x2 - x1) *\n        (2 + Math.sin(toRadians(y1)) +\n        Math.sin(toRadians(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n  return area * radius * radius / 2.0;\n}", "category": "Python"}, {"instruction": "### Parse Options\nTake the given options and ensure they are valid pagination options, else use the defaults\n@param {options} options\n@returns {options} options sanitised for pagination", "input": "JavaScript", "output": "function parseOptions(options) {\n        options = _.defaults(options || {}, defaults);\n\n        if (options.limit !== 'all') {\n            options.limit = parseInt(options.limit, 10) || defaults.limit;\n        }\n\n        options.page = parseInt(options.page, 10) || defaults.page;\n\n        return options;\n    }", "category": "Python"}, {"instruction": "Log docker to AWS.\n@param region\n@param accountId\n@param username\n@param password\n@returns {Promise}", "input": "JavaScript", "output": "function loginToAws(region, accountId, username, password) {\n    const commandLine = `docker login --username AWS --password ${password} https://${accountId}.dkr.ecr.${region}.amazonaws.com`;\n    return new Promise(\n        (resolve, reject) =>\n            command(commandLine, (err, stdout) => {\n                if (err) {\n                    reject(err);\n                }\n                resolve(stdout);\n            }),\n        { silent: true }\n    );\n}", "category": "Python"}, {"instruction": "Get coordinates of a rectangle's lower right corner from its top points\nand its lower left corner.\n\n@param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n@param  {object} A corner's coordinates (x, y).\n@return {object} Coordinates of the corner (x, y).", "input": "JavaScript", "output": "function(r, llc) {\n      return {\n        x: llc.x - r.x1 + r.x2,\n        y: llc.y - r.y1 + r.y2\n      };\n    }", "category": "Python"}, {"instruction": "Copyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n \nClass: mxEdgeHandler\n\nGraph event handler that reconnects edges and modifies control points and\nthe edge label location. Uses <mxTerminalMarker> for finding and\nhighlighting new source and target vertices. This handler is automatically\ncreated in <mxGraph.createHandler> for each selected edge.\n\nTo enable adding/removing control points, the following code can be used:\n\n(code)\nmxEdgeHandler.prototype.addEnabled = true;\nmxEdgeHandler.prototype.removeEnabled = true;\n(end)\n\nNote: This experimental feature is not recommended for production use.\n\nConstructor: mxEdgeHandler\n\nConstructs an edge handler for the specified <mxCellState>.\n\nParameters:\n\nstate - <mxCellState> of the cell to be handled.", "input": "JavaScript", "output": "function mxEdgeHandler(state)\n{\n\tif (state != null)\n\t{\n\t\tthis.state = state;\n\t\tthis.init();\n\t\t\n\t\t// Handles escape keystrokes\n\t\tthis.escapeHandler = mxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tvar dirty = this.index != null;\n\t\t\tthis.reset();\n\t\t\t\n\t\t\tif (dirty)\n\t\t\t{\n\t\t\t\tthis.graph.cellRenderer.redraw(this.state, false, state.view.isRendering());\n\t\t\t}\n\t\t});\n\t\t\n\t\tthis.state.view.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);\n\t}\n}", "category": "Python"}, {"instruction": "Finds siblings nodes of the passed node.\n\n@param  {Element} node\n@return {Array}", "input": "JavaScript", "output": "function siblings(node) {\n  if (node && node.parentNode) {\n    var n = node.parentNode.firstChild;\n    var matched = [];\n\n    for (; n; n = n.nextSibling) {\n      if (n.nodeType === 1 && n !== node) {\n        matched.push(n);\n      }\n    }\n\n    return matched;\n  }\n\n  return [];\n}", "category": "Python"}, {"instruction": "Find the key in the map object given a header name.\n\nReturns undefined if not found.\n\n@param   String  name  Header name\n@return  String|Undefined", "input": "JavaScript", "output": "function find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}", "category": "Python"}, {"instruction": "get a valid repeat mode from an md-mode attribute string.", "input": "JavaScript", "output": "function getRepeatMode(modeStr) {\n    if (!modeStr) { return REPEAT_VIRTUAL; }\n    modeStr = modeStr.toLowerCase();\n    return  REPEAT_MODES.indexOf(modeStr) > -1 ? modeStr : REPEAT_VIRTUAL;\n  }", "category": "Python"}, {"instruction": "The functions in this file return custom JS property descriptors\nthat are supposed to be assigned to Model fields.\n\nSome include the logic to look up models using foreign keys and\nto add or remove relationships between models.\n\n@module descriptors\n \nDefines a basic non-key attribute.\n@param  {string} fieldName - the name of the field the descriptor will be assigned to.", "input": "JavaScript", "output": "function attrDescriptor(fieldName) {\n    return {\n        get() {\n            return this._fields[fieldName];\n        },\n\n        set(value) {\n            return this.set(fieldName, value);\n        },\n\n        enumerable: true,\n        configurable: true,\n    };\n}", "category": "Python"}, {"instruction": "Walks through the call graph from a defined starting function, true if nodeCheck holds for every relevant node in the callgraph\n@callGraph {callGraph} As returned by buildGlobalFuncCallGraph\n@funcName {string} full qualified name of the starting function\n@context {Object} provides additional context information that can be used by the nodeCheck function\n@nodeCheck {(ASTNode, context) -> bool} applied on every relevant node in the call graph\n@return {bool} returns map from contract name to contract call graph", "input": "JavaScript", "output": "function analyseCallGraph (callGraph, funcName, context, nodeCheck) {\n  return analyseCallGraphInternal(callGraph, funcName, context, (a, b) => a || b, nodeCheck, {})\n}", "category": "Python"}, {"instruction": "Listen for errors and display them in the DOM,\nso that the user does not need to open the console", "input": "JavaScript", "output": "function addOnErrorHook () {\n\n\t\twindow.addEventListener(\"error\", function(error) {\n\t\t\terror.preventDefault();\n\t\t\tvar oErrorOutput = document.createElement(\"span\");\n\t\t\toErrorOutput.innerText = error.message; // use save API\n\t\t\toErrorOutput.style.cssText = \"position:absolute; top:1rem; left:1rem\";\n\t\t\tif (!document.body) {\n\t\t\t\tdocument.write(\"<span></span>\"); // add content via document.write to ensure document.body is created;\n\t\t\t}\n\t\t\tdocument.body.appendChild(oErrorOutput);\n\t\t});\n\t}", "category": "Python"}, {"instruction": "eslint-disable-next-line no-unused-vars", "input": "JavaScript", "output": "function renderComponent() {\n    var svg = d3.select('svg');\n    svg.select('.horizontal')\n      .datum([0.15, 0.85])\n      .call(horizontalSvgLine);\n    svg.select('.vertical')\n      .datum([0.2, 0.4, 0.6, 0.8])\n      .call(verticalSvgLine);\n\n    var canvas = d3.select('canvas').node();\n    var ctx = canvas.getContext('2d');\n    horizontalCanvasLine.context(ctx)([0.15, 0.85]);\n    verticalCanvasLine.context(ctx)([0.2, 0.4, 0.6, 0.8]);\n}", "category": "Python"}, {"instruction": "Adds two 64-bit numbers Like the original implementation, does not rely on 32-bit operations", "input": "JavaScript", "output": "function int64add(dst, x, y) {\n        var w0 = (x.l & 0xffff) + (y.l & 0xffff);\n        var w1 = (x.l >>> 16) + (y.l >>> 16) + (w0 >>> 16);\n        var w2 = (x.h & 0xffff) + (y.h & 0xffff) + (w1 >>> 16);\n        var w3 = (x.h >>> 16) + (y.h >>> 16) + (w2 >>> 16);\n        dst.l = (w0 & 0xffff) | (w1 << 16);\n        dst.h = (w2 & 0xffff) | (w3 << 16);\n      }", "category": "Python"}, {"instruction": "callback to be executed when the call to stat completes or immediately if a stat object was passed as an argument", "input": "JavaScript", "output": "function doReadFile(stat) {\n            if (stat.size > (FileUtils.MAX_FILE_SIZE)) {\n                callback(FileSystemError.EXCEEDS_MAX_FILE_SIZE);\n            } else {\n                appshell.fs.readFile(path, encoding, function (_err, _data, encoding, preserveBOM) {\n                    if (_err) {\n                        callback(_mapError(_err));\n                    } else {\n                        callback(null, _data, encoding, preserveBOM, stat);\n                    }\n                });\n            }\n        }", "category": "Python"}, {"instruction": "Returns the difficulty as a number, or if too large (i.e. PoA network) null", "input": "JavaScript", "output": "function checkDifficulty(value) {\n    var v = bignumber_1.bigNumberify(value);\n    try {\n        return v.toNumber();\n    }\n    catch (error) { }\n    return null;\n}", "category": "Python"}, {"instruction": "Returns a new Summary with a part inserted at given index\n\n@param {Summary} summary\n@param {Part} part\n@param {Number} index\n@return {Summary}", "input": "JavaScript", "output": "function insertPart(summary, part, index) {\n    part = SummaryPart(part);\n\n    var parts = summary.getParts().insert(index, part);\n    return indexLevels(summary.set('parts', parts));\n}", "category": "Python"}, {"instruction": "return x*y for bigInts x and y. This is faster when y<x.", "input": "JavaScript", "output": "function mult(x, y) {\n  var ans=expand(x, x.length+y.length);\n  mult_(ans, y);\n  return trim(ans, 1);\n}", "category": "Python"}, {"instruction": "}}}", "input": "JavaScript", "output": "function newSelection(e) //{{{\n    {\n      if (options.disabled) {\n        return false;\n      }\n      if (!options.allowSelect) {\n        return false;\n      }\n      btndown = true;\n      docOffset = getPos($img);\n      Selection.disableHandles();\n      Tracker.setCursor('crosshair');\n      var pos = mouseAbs(e);\n      Coords.setPressed(pos);\n      Selection.update();\n      Tracker.activateHandlers(selectDrag, doneSelect, e.type.substring(0,5)==='touch');\n      KeyManager.watchKeys();\n\n      e.stopPropagation();\n      e.preventDefault();\n      return false;\n    }", "category": "Python"}, {"instruction": "Returns the stack index for the given dataset based on groups and bar visibility.\n@param {number} [datasetIndex] - The dataset index\n@param {string} [name] - The stack name to find\n@returns {number} The stack index\n@private", "input": "JavaScript", "output": "function(datasetIndex, name) {\n\t\tvar stacks = this._getStacks(datasetIndex);\n\t\tvar index = (name !== undefined)\n\t\t\t? stacks.indexOf(name)\n\t\t\t: -1; // indexOf returns -1 if element is not present\n\n\t\treturn (index === -1)\n\t\t\t? stacks.length - 1\n\t\t\t: index;\n\t}", "category": "Python"}, {"instruction": "Sets bytes for node\n@param {Node} node\n@param {ArrayBuffer|Uint8Array|string|undefined} bytes", "input": "JavaScript", "output": "function setBytes(node, bytes) {\n    if (typeof bytes === 'string') {\n        bytes = ByteUtils.base64ToBytes(bytes);\n    }\n    setText(node, bytes ? ByteUtils.bytesToBase64(ByteUtils.arrayToBuffer(bytes)) : undefined);\n}", "category": "Python"}, {"instruction": "/* Plugin constructor\n==================================================", "input": "JavaScript", "output": "function Plugin(element, options) {\n    this.element = element;\n\n    this.options = $.extend(true, {}, defaults, options);\n    this.options.share = options.share; //simple solution to allow order of buttons\n\n    this._defaults = defaults;\n    this._name = pluginName;\n\n    this.init();\n  }", "category": "Python"}, {"instruction": "Create touchable component based on passed parameter and platform.\nIt also returns default props for specific touchable types.", "input": "JavaScript", "output": "function makeTouchable(TouchableComponent) {\n    var Touchable = TouchableComponent || reactNative.Platform.select({\n      android: reactNative.TouchableNativeFeedback,\n      ios: reactNative.TouchableHighlight,\n      default: reactNative.TouchableHighlight\n    });\n    var defaultTouchableProps = {};\n\n    if (Touchable === reactNative.TouchableHighlight) {\n      defaultTouchableProps = {\n        underlayColor: 'rgba(0, 0, 0, 0.1)'\n      };\n    }\n\n    return {\n      Touchable: Touchable,\n      defaultTouchableProps: defaultTouchableProps\n    };\n  }", "category": "Python"}, {"instruction": "creates a property binding (called via bind) to a published property.", "input": "JavaScript", "output": "function(property, observable, oneTime) {\n      if (oneTime) {\n        this[property] = observable;\n        return;\n      }\n      var computed = this.element.prototype.computed;\n      // Binding an \"out-only\" value to a computed property. Note that\n      // since this observer isn't opened, it doesn't need to be closed on\n      // cleanup.\n      if (computed && computed[property]) {\n        var privateComputedBoundValue = property + 'ComputedBoundObservable_';\n        this[privateComputedBoundValue] = observable;\n        return;\n      }\n      return this.bindToAccessor(property, observable, resolveBindingValue);\n    }", "category": "Python"}, {"instruction": "This module provides the following jQuery selectors:\n<ul>\n<li>:focusable/li>\n<li>:sapFocusable</li>\n<li>:sapTabbable</li>\n</ul>\n@namespace\n@name module:sap/ui/dom/jquery/Selectors\n@public\n@since 1.58\n Using \"Object.getOwnPropertyDescriptor\" to not trigger the \"getter\" - see jquery.sap.stubs", "input": "JavaScript", "output": "function getValue(oTarget, sProperty) {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(oTarget, sProperty);\n\t\treturn descriptor && descriptor.value;\n\t}", "category": "Python"}, {"instruction": "Objects", "input": "JavaScript", "output": "function cloneObject(o) {\n  var clone = {};\n  for (var p in o) { clone[p] = o[p]; }\n  return clone;\n}", "category": "Python"}, {"instruction": "This song and dance is to fix methods to a different length from what they actually accept in order to stay in line with spec. Additionally passing argument length, as some methods throw assertion errors based on this (undefined check is not enough). Fortunately for now spec is such that passing 3 actual arguments covers all requirements. Note that passing the argument length also forces the compiler to not rewrite length of the compiled function.", "input": "JavaScript", "output": "function fixArgumentLength(fn) {\n  var staticFn = function(a) {\n    var args = arguments;\n    return fn(a, args[1], args[2], args.length - 1);\n  };\n  staticFn.instance = function(b) {\n    var args = arguments;\n    return fn(this, b, args[1], args.length);\n  };\n  return staticFn;\n}", "category": "Python"}, {"instruction": "Constructor for `splunkjs.Service.DataModel`.\n\n@constructor\n@param {Object} props A dictionary of properties used to create a\n`DataModel` instance.\n@return {splunkjs.Service.DataModel} A new `DataModel` instance.\n\n@method splunkjs.Service.DataModels", "input": "JavaScript", "output": "function(props) {\n            var entityNamespace = utils.namespaceFromProperties(props);\n            return new root.DataModel(this.service, props.name, entityNamespace, props);\n        }", "category": "Python"}, {"instruction": "curry : ((a, b, c) -> d) -> a -> b -> c -> d", "input": "JavaScript", "output": "function curry(fn) {\n  return function(...xs) {\n    const args =\n      xs.length ? xs : [ undefined ]\n\n    if(args.length < fn.length) {\n      return curry(Function.bind.apply(fn, [ null ].concat(args)))\n    }\n\n    const val = args.length === fn.length\n      ? fn.apply(null, args)\n      : args.reduce(applyCurry, fn)\n\n    if(isFunction(val)) {\n      return curry(val)\n    }\n\n    return val\n  }\n}", "category": "Python"}, {"instruction": "\u83b7\u53d6\u9875\u9762\u4e0a\u4e0b\u6587", "input": "JavaScript", "output": "function getPageCtx(pageCtx) {\n  var ctx = pageCtx;\n\n  if (!ctx) {\n    var pages = getCurrentPages();\n    ctx = pages[pages.length - 1];\n  }\n\n  return ctx;\n}", "category": "Python"}, {"instruction": "Calculates the position of the fisrt/last step (with fix for Safari in RTL mode) to make the position and scroll calculations running (see comment on getRTLFactor for RTL behavior)", "input": "JavaScript", "output": "function(oRoadMap, bLast){\n\t\tvar iScrollWidth = oRoadMap.$(\"steparea\").get(0).scrollWidth;\n\t\tif (sap.ui.getCore().getConfiguration().getRTL() && Device.browser.webkit) {\n\t\t\treturn bLast ? 0 : ( -1) * iScrollWidth;\n\t\t}\n\t\treturn bLast ? iScrollWidth : 0;\n\t}", "category": "Python"}, {"instruction": "called third", "input": "JavaScript", "output": "function interpretResponse(serverResponse) {\n  const bidResponses = [];\n  // currently server returns a single response which is the body property\n  if (serverResponse.body) {\n    serverResponse.body.bidderCode = BIDDER_CODE;\n    bidResponses.push(serverResponse.body);\n  }\n\n  return bidResponses;\n}", "category": "Python"}, {"instruction": "Updates the type metadata from the current jCal type and design set.\n\n@private", "input": "JavaScript", "output": "function() {\n      var designSet = this._designSet;\n\n      if (this.type in designSet.value) {\n        var designType = designSet.value[this.type];\n\n        if ('decorate' in designSet.value[this.type]) {\n          this.isDecorated = true;\n        } else {\n          this.isDecorated = false;\n        }\n\n        if (this.name in designSet.property) {\n          this.isMultiValue = ('multiValue' in designSet.property[this.name]);\n          this.isStructuredValue = ('structuredValue' in designSet.property[this.name]);\n        }\n      }\n    }", "category": "Python"}, {"instruction": "Create a Collection object from a response containing a list of resources.\n\n@param {Object} response Full payload from a response to a\ncollection request.\n@param {Dispatcher} dispatcher\n@param {Object} [dispatchOptions]\n@returns {Object} Collection", "input": "JavaScript", "output": "function Collection(response, dispatcher, dispatchOptions) {\n  if (!Collection.isCollectionResponse(response)) {\n    throw new Error(\n        'Cannot create Collection from response that does not have resources');\n  }\n\n  this.data = response.data;\n  this._response = response;\n  this._dispatcher = dispatcher;\n  this._dispatchOptions = dispatchOptions;\n}", "category": "Python"}, {"instruction": "Add or remove the `.md-checked` class from the RadioButton (and conditionally its parent).\nUpdate the `aria-activedescendant` attribute.", "input": "JavaScript", "output": "function render() {\n      var checked = rgCtrl.getViewValue() == attr.value;\n\n      if (checked === lastChecked) return;\n\n      if (element[0].parentNode.nodeName.toLowerCase() !== 'md-radio-group') {\n        // If the radioButton is inside a div, then add class so highlighting will work\n        element.parent().toggleClass(CHECKED_CSS, checked);\n      }\n\n      if (checked) {\n        rgCtrl.setActiveDescendant(element.attr('id'));\n      }\n\n      lastChecked = checked;\n\n      element\n        .attr('aria-checked', checked)\n        .toggleClass(CHECKED_CSS, checked);\n    }", "category": "Python"}, {"instruction": "Load and setup plugins\n\n@param {Output}\n@return {Promise<Output>}", "input": "JavaScript", "output": "function preparePlugins(output) {\n    var book = output.getBook();\n\n    return Promise()\n\n    // Only load plugins for main book\n    .then(function() {\n        if (book.isLanguageBook()) {\n            return output.getPlugins();\n        } else {\n            return Plugins.loadForBook(book);\n        }\n    })\n\n    // Update book's configuration using the plugins\n    .then(function(plugins) {\n        return Plugins.validateConfig(book, plugins)\n        .then(function(newBook) {\n            return output.merge({\n                book: newBook,\n                plugins: plugins\n            });\n        });\n    });\n}", "category": "Python"}, {"instruction": "Allowing namespace constraints such as ES6:String to only build for that namespace.", "input": "JavaScript", "output": "function getNamespaceConstraints() {\n    var map = {};\n    getModuleNames(m).forEach(function(n) {\n      var split = n.split(':');\n      var moduleName = split[0];\n      var namespaceName = split[1];\n      if (namespaceName) {\n        if (SPLIT_MODULES.indexOf(moduleName) === -1) {\n          warn('Module ' + moduleName + ' is not ready to be split!');\n          warn('Exiting...');\n          process.exit();\n        }\n        var constraints = map[moduleName] || {};\n        constraints[namespaceName] = true;\n        map[moduleName] = constraints;\n      }\n    });\n    return map;\n  }", "category": "Python"}, {"instruction": "Parses comma separated list of numbers and returns them an array. Used internally by the TextParser", "input": "JavaScript", "output": "function parseNumberArray( value ) {\n\n\t\tvar array = value.split( ',' ).map( function ( val ) {\n\n\t\t\treturn parseFloat( val );\n\n\t\t} );\n\n\t\treturn array;\n\n\t}", "category": "Python"}, {"instruction": "@\n#.destroy\n@comp Crafty Core\n@kind Method\n\n@sign public this .destroy(void)\nWill remove all event listeners and delete all properties as well as removing from the stage", "input": "JavaScript", "output": "function() {\n        //remove all event handlers, delete from entities\n        this.each(function() {\n            var comp;\n            this.trigger(\"Remove\");\n            for (var compName in this.__c) {\n                comp = components[compName];\n                if (comp && \"remove\" in comp) comp.remove.call(this, true);\n\n                // update map from component to (entityId -> entity)\n                delete compEntities[compName][this[0]];\n            }\n            this._unbindAll();\n            delete entities[this[0]];\n        });\n    }", "category": "Python"}, {"instruction": "http://docs.jquery.com/Plugins/Validation/valid", "input": "JavaScript", "output": "function() {\n\t\tif ( $(this[0]).is(\"form\")) {\n\t\t\treturn this.validate().form();\n\t\t} else {\n\t\t\tvar valid = true;\n\t\t\tvar validator = $(this[0].form).validate();\n\t\t\tthis.each(function() {\n\t\t\t\tvalid = valid && validator.element(this);\n\t\t\t});\n\t\t\treturn valid;\n\t\t}\n\t}", "category": "Python"}, {"instruction": "matches another field", "input": "JavaScript", "output": "function(value, identifier) {\n      var\n        $form = $(this),\n        matchingValue\n      ;\n      if( $('[data-validate=\"'+ identifier +'\"]').length > 0 ) {\n        matchingValue = $('[data-validate=\"'+ identifier +'\"]').val();\n      }\n      else if($('#' + identifier).length > 0) {\n        matchingValue = $('#' + identifier).val();\n      }\n      else if($('[name=\"' + identifier +'\"]').length > 0) {\n        matchingValue = $('[name=\"' + identifier + '\"]').val();\n      }\n      else if( $('[name=\"' + identifier +'[]\"]').length > 0 ) {\n        matchingValue = $('[name=\"' + identifier +'[]\"]');\n      }\n      return (matchingValue !== undefined)\n        ? ( value.toString() == matchingValue.toString() )\n        : false\n      ;\n    }", "category": "Python"}, {"instruction": "return expression", "input": "JavaScript", "output": "function() {\n    this.expect('return');\n    var expr = this.expression();\n    return expr.isEmpty\n      ? new nodes.Return\n      : new nodes.Return(expr);\n  }", "category": "Python"}, {"instruction": "Remove injected default camera from scene, if present.\n\n@param {Element} sceneEl", "input": "JavaScript", "output": "function removeDefaultCamera (sceneEl) {\n  var defaultCamera;\n  var camera = sceneEl.camera;\n  if (!camera) { return; }\n\n  // Remove default camera if present.\n  defaultCamera = sceneEl.querySelector('[' + DEFAULT_CAMERA_ATTR + ']');\n  if (!defaultCamera) { return; }\n  sceneEl.removeChild(defaultCamera);\n}", "category": "Python"}, {"instruction": "# words :: String -> Array String . . Takes a string and returns the array of words the string contains . (words are delimited by whitespace characters). . . See also [`unwords`](#unwords). . . ```javascript . > S.words (' foo bar baz ') . ['foo', 'bar', 'baz'] . ```", "input": "JavaScript", "output": "function words(s) {\n    var words = s.split (/\\s+/);\n    var len = words.length;\n    return words.slice (words[0] === '' ? 1 : 0,\n                        words[len - 1] === '' ? len - 1 : len);\n  }", "category": "Python"}, {"instruction": "/*------------------------------------------------------------------------ \nPicks the layout engine from an array of guesses.\n\n@private\n@param {Array} guesses An array of guesses.\n@returns {null|string} The detected layout engine.", "input": "JavaScript", "output": "function getLayout(guesses) {\n      return reduce(guesses, function(result, guess) {\n        return result || RegExp('\\\\b' + (\n          guess.pattern || qualify(guess)\n        ) + '\\\\b', 'i').exec(ua) && (guess.label || guess);\n      });\n    }", "category": "Python"}, {"instruction": "Expression for $, returns the evaluator function", "input": "JavaScript", "output": "function capture( previousExpr, detection ) {\n\n      // extract meaning from the detection      \n      var capturing = !!detection[CAPTURING_INDEX];\n\n      if (!capturing)          \n         return previousExpr; // don't wrap at all, return given expr as-is      \n      \n      return lazyIntersection(previousExpr, head);\n            \n   }", "category": "Python"}, {"instruction": "Calls the provided DOM prototype method and returns its result. If the\nmethod is not available, use fallbackMethodName to call the method in a\nclobber-vulnerable way, and use fallbackTest to check if the\nmethod was clobbered, throwing an exception if so.\n@param {?Function} fn\n@param {*} object\n@param {string} fallbackMethodName\n@param {!Array<*>} args\n@return {?}", "input": "JavaScript", "output": "function genericMethodCall(fn, object, fallbackMethodName, args) {\n  if (fn) {\n    return fn.apply(object, args);\n  }\n  // IE8 and IE9 will return 'object' for\n  // CSSStyleDeclaration.(get|set)Attribute, so we can't use typeof.\n  if (userAgentProduct.IE && document.documentMode < 10) {\n    if (!object[fallbackMethodName].call) {\n      throw new Error('IE Clobbering detected');\n    }\n  } else if (typeof object[fallbackMethodName] != 'function') {\n    throw new Error('Clobbering detected');\n  }\n  return object[fallbackMethodName].apply(object, args);\n}", "category": "Python"}, {"instruction": "Retrieve the value of an individual preference.\n\n@param {string} prefName\nThe preference to get the value of.\n@param {boolean/number/string} defaultValue\nThe default value if preference cannot be found.\n@param {boolean/number/string} defaultBranch\nIf true the value will be read from the default branch (optional)\n@param {string} interfaceType\nInterface to use for the complex value (optional)\n(nsILocalFile, nsISupportsString, nsIPrefLocalizedString)\n\n@return The value of the requested preference\n@type boolean/int/string/complex", "input": "JavaScript", "output": "function preferences_getPref(prefName, defaultValue, defaultBranch,\n                                         interfaceType) {\n    try {\n      branch = defaultBranch ? this.defaultPrefBranch : this.prefBranch;\n\n      // If interfaceType has been set, handle it differently\n      if (interfaceType != undefined) {\n        return branch.getComplexValue(prefName, interfaceType);\n      }\n\n      switch (typeof defaultValue) {\n        case ('boolean'):\n          return branch.getBoolPref(prefName);\n        case ('string'):\n          return branch.getCharPref(prefName);\n        case ('number'):\n          return branch.getIntPref(prefName);\n        default:\n          return undefined;\n      }\n    } catch(e) {\n      return defaultValue;\n    }\n  }", "category": "Python"}, {"instruction": "Emit controls section of pieces editor modal: the cancel/save buttons, etc.", "input": "JavaScript", "output": "function() {\n      var req = self.apos.templates.contextReq;\n      return self.partial('controls', { controls: self.getEditControls(req), options: self.options });\n    }", "category": "Python"}, {"instruction": "Generate JSON icons map by parsing the generated CSS\n\n@param  {Object} options\n@return {void}", "input": "JavaScript", "output": "async function generateJson(options, generatorResult) {\n  const jsonPath = (\n    options.jsonPath ||\n    `${ path.join(options.outputDir, '/' + options.fontName) }.json`\n  )\n\n  const css = generatorResult.generateCss()\n  let map = {}\n\n  css.replace(CSS_PARSE_REGEX, (match, name, code) => map[name] = code)\n\n  await fsAsync.writeFile(jsonPath, JSON.stringify(map, null, 4))\n}", "category": "Python"}, {"instruction": "OAuth2Strategy\n\nProvider is an object defining the details of the authentication API.\nClient is an object containing provider registration info and options.\nVerify is the Passport callback to invoke after authenticating", "input": "JavaScript", "output": "function OAuth2Strategy (provider, client, verify) {\n  Strategy.call(this)\n  this.provider = provider\n  this.endpoints = provider.endpoints\n  this.mapping = provider.mapping\n  this.client = client\n  this.name = provider.id\n  this.verify = verify\n}", "category": "Python"}, {"instruction": "Builds the data to be POSTed to elastic search.\n\n@param {string} searchTerm The plain-text query to search for.\n@param {number} maxResults The max number of results to search for.", "input": "JavaScript", "output": "function buildRequestData(searchTerm, maxResults) {\n  var requestData = {\n    numHits: maxResults,\n    fuzzy: {\n      maxEdits: 2,\n      minLength: 5,\n      prefixLength: 2\n    }\n  };\n\n  if (searchTerm instanceof Array) {\n    requestData[\"addresses\"] = searchTerm.map(processAddress);\n  } else {\n    requestData[\"addr\"] = processAddress(searchTerm);\n  }\n  return requestData;\n}", "category": "Python"}, {"instruction": "Define the star object\n\n@param {number} x\n@param {number} y\n@param {number} starSize\n@param {context} ctx\n@param {canvas} fgCanvas\n@param {analyser} analyser\n@param {Uint8Array} streamData", "input": "JavaScript", "output": "function Star( x, y, starSize, ctx, fgCanvas, analyser, streamData ){\n\tthis.x = x;\n\tthis.y = y;\n\tthis.angle = Math.atan( Math.abs(y) / Math.abs(x) );\n\tthis.starSize = starSize;\n\tthis.ctx = ctx;\n\tthis.high = 0;\n\tthis.fgCanvas = fgCanvas;\n\tthis.analyser = analyser;\n\tthis.streamData = streamData;\n}", "category": "Python"}, {"instruction": "Write a Cues element to the blobStream using the global `cues` array of CuePoints (use addCuePoint()).\nThe seek entry for the Cues in the SeekHead is updated.", "input": "JavaScript", "output": "function writeCues() {\n                var\n                    ebml = {\n                        \"id\": 0x1C53BB6B,\n                        \"data\": cues\n                    },\n                    \n                    cuesBuffer = new ArrayBufferDataStream(16 + cues.length * 32); // Pretty crude estimate of the buffer size we'll need\n                \n                writeEBML(cuesBuffer, blobBuffer.pos, ebml);\n                blobBuffer.write(cuesBuffer.getAsDataArray());\n                \n                // Now we know where the Cues element has ended up, we can update the SeekHead\n                seekPoints.Cues.positionEBML.data = fileOffsetToSegmentRelative(ebml.offset);\n            }", "category": "Python"}, {"instruction": "/*!\n@param {Object} easingObject\n@param {Object} tokenData", "input": "JavaScript", "output": "function collapseEasingObject (easingObject, tokenData) {\n      Tweenable.each(tokenData, function (prop) {\n        var currentProp = tokenData[prop];\n        var chunkNames = currentProp.chunkNames;\n        var chunkLength = chunkNames.length;\n        var composedEasingString = '';\n\n        for (var i = 0; i < chunkLength; i++) {\n          composedEasingString += ' ' + easingObject[chunkNames[i]];\n          delete easingObject[chunkNames[i]];\n        }\n\n        easingObject[prop] = composedEasingString.substr(1);\n      });\n    }", "category": "Python"}, {"instruction": "Compare this specificity to another.\n@param {Specificity} other The other specificity to compare to.\n@return {int} -1 if the other specificity is larger, 1 if smaller, 0 if equal.\n@method compare", "input": "JavaScript", "output": "function(other) {\n        var comps = [\"a\", \"b\", \"c\", \"d\"],\n            i, len;\n\n        for (i=0, len=comps.length; i < len; i++) {\n            if (this[comps[i]] < other[comps[i]]) {\n                return -1;\n            } else if (this[comps[i]] > other[comps[i]]) {\n                return 1;\n            }\n        }\n\n        return 0;\n    }", "category": "Python"}, {"instruction": "##### BEGIN: MODIFIED BY SAP functions crc32, utf8encode and utf8decode are replaced with implementations by SAP", "input": "JavaScript", "output": "function(buf, crc) {\n\n      var c = (typeof(crc) == \"undefined\" ? 0 : crc) ^ 0xffffffff;\n      var bArray  = typeof buf !== \"string\";\n      var n;\n\n      if (bArray) {\n        for (n = 0; n < buf.length; n++) {\n          c = SAP_CRC32_TABLE[(c ^ buf[n]) & 0xff] ^ (c >>> 8);\n        }\n      } else {\n        for (n = 0; n < buf.length; n++) {\n          c = SAP_CRC32_TABLE[(c ^ buf.charCodeAt(n)) & 0xff] ^ (c >>> 8);\n        }\n      }\n\n      return c ^ 0xffffffff;\n    }", "category": "Python"}, {"instruction": "Validate a texture, either as a selector or as a URL.\nDetects whether `src` is pointing to an image or video and invokes the appropriate\ncallback.\n\n`src` will be passed into the callback\n\n@params {string|Element} src - URL or media element.\n@params {function} isImageCb - callback if texture is an image.\n@params {function} isVideoCb - callback if texture is a video.", "input": "JavaScript", "output": "function validateSrc (src, isImageCb, isVideoCb) {\n  checkIsImage(src, function isAnImageUrl (isImage) {\n    if (isImage) {\n      isImageCb(src);\n      return;\n    }\n    isVideoCb(src);\n  });\n}", "category": "Python"}, {"instruction": "A parameter that specifies an arbitrary polygon on the globe.\n\n@alias GeoJsonParameter\n@constructor\n@extends FunctionParameter\n\n@param {Object} options Object with the following properties:\n@param {Terria} options.terria The Terria instance.\n@param {String} options.id The unique ID of this parameter.\n@param {String} [options.name] The name of this parameter. If not specified, the ID is used as the name.\n@param {String} [options.description] The description of the parameter.\n@param {Boolean} [options.defaultValue] The default value.", "input": "JavaScript", "output": "function(options) {\n  FunctionParameter.call(this, options);\n  this.regionParameter = options.regionParameter;\n  this.value = \"\";\n  this._subtype = undefined;\n}", "category": "Python"}, {"instruction": "/* Is the given date in the accepted range?", "input": "JavaScript", "output": "function(inst, date) {\n\t\tvar yearSplit, currentYear,\n\t\t\tminDate = this._getMinMaxDate(inst, \"min\"),\n\t\t\tmaxDate = this._getMinMaxDate(inst, \"max\"),\n\t\t\tminYear = null,\n\t\t\tmaxYear = null,\n\t\t\tyears = this._get(inst, \"yearRange\");\n\t\t\tif (years){\n\t\t\t\tyearSplit = years.split(\":\");\n\t\t\t\tcurrentYear = new Date().getFullYear();\n\t\t\t\tminYear = parseInt(yearSplit[0], 10);\n\t\t\t\tmaxYear = parseInt(yearSplit[1], 10);\n\t\t\t\tif ( yearSplit[0].match(/[+\\-].*/) ) {\n\t\t\t\t\tminYear += currentYear;\n\t\t\t\t}\n\t\t\t\tif ( yearSplit[1].match(/[+\\-].*/) ) {\n\t\t\t\t\tmaxYear += currentYear;\n\t\t\t\t}\n\t\t\t}\n\n\t\treturn ((!minDate || date.getTime() >= minDate.getTime()) &&\n\t\t\t(!maxDate || date.getTime() <= maxDate.getTime()) &&\n\t\t\t(!minYear || date.getFullYear() >= minYear) &&\n\t\t\t(!maxYear || date.getFullYear() <= maxYear));\n\t}", "category": "Python"}, {"instruction": "Returns an array of the IDs of providers registered for a specific language\n\n@param {!string} languageId\n@return {Array.<string>} Names of registered providers.", "input": "JavaScript", "output": "function getProviderIDsForLanguage(languageId) {\n        if (!_providers[languageId]) {\n            return [];\n        }\n        return _providers[languageId].map(function (provider) {\n            return provider.name;\n        });\n    }", "category": "Python"}, {"instruction": "Converts all object property names to leading '--' style\n\n@param {object} varObj Object containing CSS custom property name:value pairs\n@returns {object}", "input": "JavaScript", "output": "function fixVarNames(varObj = {}) {\n    const reLeadingHyphens = /^-{2}/;\n\n    return Object.keys(varObj).reduce((obj, value) => {\n        const key = reLeadingHyphens.test(value) ? value : `--${value.replace(/^-+/, '')}`;\n\n        obj[key] = varObj[value];\n\n        return obj;\n    }, {});\n}", "category": "Python"}, {"instruction": "/* Returns a promise that returns true if user confirms, or false if they abort.", "input": "JavaScript", "output": "function getConfirmation(terria, viewState, confirmConversion, message) {\n  if (!confirmConversion) {\n    return when(true);\n  }\n\n  var d = when.defer(); // there's no `when.promise(resolver)` in when 1.7.1\n  viewState.notifications.push({\n    confirmText: \"Upload\",\n    denyText: \"Cancel\",\n    title: \"Use conversion service?\",\n    message: message,\n    confirmAction: function() {\n      d.resolve(true);\n    },\n    denyAction: function() {\n      d.resolve(false);\n    }\n  });\n  return d.promise;\n}", "category": "Python"}, {"instruction": "Specify that only a page of the query result shall be returned. A page is\ndescribed by its boundaries, that are row numbers for the first and last\nrows in the query result to be returned.\n\n@param {Number}\nstart The first row of the query result to be returned.\nNumbering starts at 1. Passing null is equivalent to start\nwith the first row.\n@param {Number}\nend The last row of the query result to be returned. Passing\nnull is equivalent to get all rows up to the end of the query\nresult.\n@public\n@function\n@name sap.ui.model.analytics.odata4analytics.QueryResultRequest#setResultPageBoundaries", "input": "JavaScript", "output": "function(start, end) {\n\t\t\tif (start != null && typeof start !== \"number\") {\n\t\t\t\tthrow \"Start value must be null or numeric\"; // TODO\n\t\t\t}\n\t\t\tif (end !== null && typeof end !== \"number\") {\n\t\t\t\tthrow \"End value must be null or numeric\"; // TODO\n\t\t\t}\n\n\t\t\tif (start == null) {\n\t\t\t\tstart = 1;\n\t\t\t}\n\n\t\t\tif (start < 1 || start > (end == null ? start : end)) {\n\t\t\t\tthrow \"Invalid values for requested page boundaries\"; // TODO\n\t\t\t}\n\n\t\t\tthis._iSkipRequestOption = (start > 1) ? start - 1 : null;\n\t\t\tthis._iTopRequestOption = (end != null) ? (end - start + 1) : null;\n\t\t}", "category": "Python"}, {"instruction": "classic build with sourcemaps", "input": "JavaScript", "output": "function build_dist_sourcemap(){\n  // run webpack\n  return gulp.src('index.js').pipe(webpackStream(createWebpackConfig({\n    mode: 'development',\n    entry: classicEntry,\n    output: {\n        filename:'oidc-client.js',\n        libraryTarget:'var',\n        library:'Oidc'\n    },\n    plugins: [],\n    devtool:'inline-source-map'\n  }), webpack))\n  .pipe(gulp.dest('dist/'));\n}", "category": "Python"}, {"instruction": "\u83b7\u53d6\u5bbd\u5ea6\n@param  {HTMLElement} el  dom\u8282\u70b9\n@param  {Number} defaultValue \u9ed8\u8ba4\u503c\n@return {Number} \u5bbd\u5ea6", "input": "JavaScript", "output": "function getWidth(el, defaultValue) {\n    var width = this.getStyle(el, 'width', defaultValue);\n    if (width === 'auto') {\n      width = el.offsetWidth;\n    }\n    return parseFloat(width);\n  }", "category": "Python"}, {"instruction": "/* [MS-XLS] 2.4.4 TODO", "input": "JavaScript", "output": "function parse_Array(blob, length, opts) {\n\tvar ref = parse_Ref(blob, 6);\n\t/* TODO: fAlwaysCalc */\n\tswitch(opts.biff) {\n\t\tcase 2: blob.l ++; length -= 7; break;\n\t\tcase 3: case 4: blob.l += 2; length -= 8; break;\n\t\tdefault: blob.l += 6; length -= 12;\n\t}\n\treturn [ref, parse_ArrayParsedFormula(blob, length, opts, ref)];\n}", "category": "Python"}, {"instruction": "override", "input": "JavaScript", "output": "function($super, axis, formatter, chart) {\n            $super(axis, formatter, chart);\n            var fontSize = 11,\n                tickLabelPadding = 2;\n\n            if(this.isVertical) {\n                this.checkFirstLabelFit(axis, formatter, chart, fontSize);\n            }\n            else {\n                this.checkLastLabelFit(axis, formatter, chart, fontSize);\n            }\n        }", "category": "Python"}, {"instruction": "Retrieves the smallest horizontal (degrees=0) rectangle which contains\nthis rectangle.\n@returns {OpenSeadragon.Rect}", "input": "JavaScript", "output": "function() {\n        if (this.degrees === 0) {\n            return this.clone();\n        }\n        var topLeft = this.getTopLeft();\n        var topRight = this.getTopRight();\n        var bottomLeft = this.getBottomLeft();\n        var bottomRight = this.getBottomRight();\n        var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);\n        var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);\n        var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);\n        var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);\n        return new $.Rect(\n            minX,\n            minY,\n            maxX - minX,\n            maxY - minY);\n    }", "category": "Python"}, {"instruction": "Function: removeAllStylenames\n\nRemoves all stylenames from the given style and returns the updated\nstyle.", "input": "JavaScript", "output": "function(style)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tif (style != null)\n\t\t{\n\t\t\tvar tokens = style.split(';');\n\t\t\t\n\t\t\tfor (var i = 0; i < tokens.length; i++)\n\t\t\t{\n\t\t\t\t// Keeps the key, value assignments\n\t\t\t\tif (tokens[i].indexOf('=') >= 0)\n\t\t\t\t{\n\t\t\t\t\tresult.push(tokens[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result.join(';');\n\t}", "category": "Python"}, {"instruction": "/* [MS-XLS] 2.5.198.21", "input": "JavaScript", "output": "function parse_NameParsedFormula(blob, length, opts, cce) {\n\tvar target = blob.l + length;\n\tvar rgce = parse_Rgce(blob, cce, opts);\n\tvar rgcb;\n\tif(target !== blob.l) rgcb = parse_RgbExtra(blob, target - blob.l, rgce, opts);\n\treturn [rgce, rgcb];\n}", "category": "Python"}, {"instruction": "return path to found, project first", "input": "JavaScript", "output": "function projectOrHereRequire(id,root) {\n\ttry {\n\t\treturn resolve.sync(id, {\n\t\t\tpackage: path.join(root,'package.json'),\n\t\t\tpaths: [root],\n\t\t\tbasedir:root\n\t\t});\n\t} catch(ex) {\n\t\t// console.error(ex);\n\t}\n\n\tvar here = path.join(__dirname,'..','..');\n\ttry {\n\t\tvar p = resolve.sync(id, {\n\t\t\tpackage: path.join(here,'package.json'),\n\t\t\tpaths: [here],\n\t\t\tbasedir:here\n\t\t});\n\t\treturn p;\n\t} catch(ex) {\n\t\t// console.error(ex);\n\t}\n}", "category": "Python"}, {"instruction": "Returns the events of a search job with given parameters.\n\n@example\n\nvar job = service.jobs().item(\"mysid\");\njob.events({count: 10}, function(err, events, job) {\nconsole.log(\"Fields: \", events.fields);\n});\n\n@param {Object} params The parameters for retrieving events. For a list of available parameters, see the <a href=\"http://docs.splunk.com/Documentation/Splunk/latest/RESTAPI/RESTsearch#GET_search.2Fjobs.2F.7Bsearch_id.7D.2Fevents\" target=\"_blank\">GET search/jobs/{search_id}/events</a> endpoint in the REST API documentation.\n@param {Function} callback A function to call when the events are retrieved: `(err, events, job)`.\n\n@endpoint search/jobs/{search_id}/events\n@method splunkjs.Service.Job", "input": "JavaScript", "output": "function(params, callback) {\n            callback = callback || function() {};\n            params = params || {};\n            params.output_mode = params.output_mode || \"json_rows\"; \n            \n            var that = this;\n            return this.get(\"events\", params, function(err, response) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, response.data, that);\n                }\n            });\n        }", "category": "Python"}, {"instruction": "/* Older versions of node do not have fs.exists so we implement our own", "input": "JavaScript", "output": "function checkFileExists(filename, callback) {\n  if (fs.exists !== undefined) {\n    fs.exists(filename, callback);\n  } else {\n    fs.stat(filename, function (err) {\n      callback(!err);\n    });\n  }\n}", "category": "Python"}, {"instruction": "Monkey-patch CodeMirror to prevent modes from being overwritten by extensions.\nWe may rely on the tokens provided by some of these modes.", "input": "JavaScript", "output": "function _patchCodeMirror() {\n        var _original_CodeMirror_defineMode = CodeMirror.defineMode;\n        function _wrapped_CodeMirror_defineMode(name) {\n            if (CodeMirror.modes[name]) {\n                console.error(\"There already is a CodeMirror mode with the name \\\"\" + name + \"\\\"\");\n                return;\n            }\n            _original_CodeMirror_defineMode.apply(CodeMirror, arguments);\n        }\n        CodeMirror.defineMode = _wrapped_CodeMirror_defineMode;\n    }", "category": "Python"}, {"instruction": "Finds and returns the first 'meta charset' element in the head.\n\n@param {Node} head the section to search for the meta charset node.\n@returns {Node} the '<meta charset>' node or null.", "input": "JavaScript", "output": "function findMetaViewport(head) {\n  for (let node = head.firstChild; node !== null; node = node.nextSibling) {\n    if (node.tagName === 'meta' && node.attribs.name === 'viewport') {\n      return node;\n    }\n  }\n  return null;\n}", "category": "Python"}, {"instruction": "Removes an object from canvas and returns it\n@method remove\n@param object {Object} Object to remove\n@return {Object} removed object", "input": "JavaScript", "output": "function (object) {\n      removeFromArray(this._objects, object);\n      if (this.getActiveObject() === object) {\n\n        // removing active object should fire \"selection:cleared\" events\n        this.fire('before:selection:cleared', { target: object });\n        this.discardActiveObject();\n        this.fire('selection:cleared');\n      }\n      this.renderAll();\n      return object;\n    }", "category": "Python"}, {"instruction": "Compares the given values using <code>===</code> and <code>></code>.\n\n@param {any} vValue1\nthe first value to compare\n@param {any} vValue2\nthe second value to compare\n@return {int}\nthe result of the compare: <code>0</code> if the values are equal, <code>-1</code> if the\nfirst value is smaller, <code>1</code> if the first value is larger, <code>NaN</code> if\nthey cannot be compared", "input": "JavaScript", "output": "function simpleCompare(vValue1, vValue2) {\n\t\tif (vValue1 === vValue2) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (vValue1 === null || vValue2 === null\n\t\t\t\t|| vValue1 === undefined || vValue2 === undefined) {\n\t\t\treturn NaN;\n\t\t}\n\t\treturn vValue1 > vValue2 ? 1 : -1;\n\t}", "category": "Python"}, {"instruction": "Checks if a header already exists. If it does not, sets the value to whatever is passed as\n`defaultValue`\n\n@param {object} headers\n@param {String} headerKey\n@param {String} defaultValue", "input": "JavaScript", "output": "function (headers, headerKey, defaultValue) {\n        var headerName = _.findKey(headers, function (value, key) {\n            return key.toLowerCase() === headerKey.toLowerCase();\n        });\n\n        if (!headerName) {\n            headers[headerKey] = defaultValue;\n        }\n    }", "category": "Python"}, {"instruction": "Gets presigned posts\n\n@param {string} siteId\n@param {Object} checksums\n@return {Object}", "input": "JavaScript", "output": "async function _getPresignedPosts(siteId, checksums) {\n  const endpoint = url.resolve(apiURL, `/sites/${siteId}/presigned_posts`);\n  const body = { checksums };\n  const response = await got.post(endpoint, { body, json: true, headers: _bearer() });\n\n  return response.body.presignedPosts;\n}", "category": "Python"}, {"instruction": "scoped", "input": "JavaScript", "output": "function clear () {\n      if (!window.confirm(i18n('Are you certain you want to clear your draft?'))) {\n        return\n      }\n      textArea.value = ''\n      hasContent.set(!!textArea.value)\n      save()\n    }", "category": "Python"}, {"instruction": "This code walks the history of the master branch and prints results that look very similar to calling `git log` from the command line", "input": "JavaScript", "output": "function compileHistory(resultingArrayOfCommits) {\n  var lastSha;\n  if (historyCommits.length > 0) {\n    lastSha = historyCommits[historyCommits.length - 1].commit.sha();\n    if (\n      resultingArrayOfCommits.length == 1 &&\n      resultingArrayOfCommits[0].commit.sha() == lastSha\n    ) {\n      return;\n    }\n  }\n\n  resultingArrayOfCommits.forEach(function(entry) {\n    historyCommits.push(entry);\n  });\n\n  lastSha = historyCommits[historyCommits.length - 1].commit.sha();\n\n  walker = repo.createRevWalk();\n  walker.push(lastSha);\n  walker.sorting(nodegit.Revwalk.SORT.TIME);\n\n  return walker.fileHistoryWalk(historyFile, 500)\n    .then(compileHistory);\n}", "category": "Python"}, {"instruction": "Creates a default toolbar providing basic buttons and functionality.\n\n@param {sap.ui.table.CreationRow} oCreationRow The creation row to get the settings for the toolbar creation from.\n@returns {sap.m.OverflowToolbar} The default toolbar.", "input": "JavaScript", "output": "function createDefaultToolbar(oCreationRow) {\n\t\treturn new OverflowToolbar({\n\t\t\tcontent: [\n\t\t\t\tnew ToolbarSpacer(),\n\t\t\t\tnew Button({\n\t\t\t\t\ttext: TableUtils.getResourceText(\"TBL_CREATIONROW_APPLY\"),\n\t\t\t\t\ttype: MLibrary.ButtonType.Emphasized,\n\t\t\t\t\tenabled: oCreationRow.getApplyEnabled(),\n\t\t\t\t\tpress: function() {\n\t\t\t\t\t\toCreationRow._fireApply();\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t],\n\t\t\tstyle: MLibrary.ToolbarStyle.Clear,\n\t\t\tariaLabelledBy: [oCreationRow.getId() + \"-label\"]\n\t\t});\n\t}", "category": "Python"}, {"instruction": "initWebGL  Initialize WebGL, returning the GL context or null if WebGL isn't available or could not be initialized.", "input": "JavaScript", "output": "function initWebGL() {\n  gl = null;\n\n  try {\n    gl = canvas.getContext(\"experimental-webgl\");\n  }\n  catch(e) {\n    alert(e);\n  }\n\n  // If we don't have a GL context, give up now\n\n  if (!gl) {\n    alert(\"Unable to initialize WebGL. Your browser may not support it.\");\n  }\n}", "category": "Python"}, {"instruction": "Helper - get arguments of a path drawing command", "input": "JavaScript", "output": "function (str) {\n    var output = [];\n    var idx = 0;\n    var c, num;\n\n    var nextNumber = function () {\n      var chars = [];\n\n      while (/[^-\\d\\.]/.test(str.charAt(idx))) {\n        // skip the non-digit characters\n        idx++;\n      }\n\n      if ('-' === str.charAt(idx)) {\n        chars.push('-');\n        idx++;\n      }\n\n      while ((c = str.charAt(idx)) && /[\\d\\.Ee]/.test(c)) {\n        chars.push(c);\n        idx++;\n      }\n\n      return parseFloat(chars.join(''));\n    };\n\n    while (!isNaN(num = nextNumber())) output.push(num);\n\n    return output;\n  }", "category": "Python"}, {"instruction": "Copy the values from one mat3 to another\n\n@param {mat3} out the receiving matrix\n@param {mat3} a the source matrix\n@returns {mat3} out", "input": "JavaScript", "output": "function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}", "category": "Python"}, {"instruction": "/* [MS-XLS] 2.4.173", "input": "JavaScript", "output": "function parse_MTRSettings(blob) {\n\tvar fMTREnabled = blob.read_shift(4) !== 0x00;\n\tvar fUserSetThreadCount = blob.read_shift(4) !== 0x00;\n\tvar cUserThreadCount = blob.read_shift(4);\n\treturn [fMTREnabled, fUserSetThreadCount, cUserThreadCount];\n}", "category": "Python"}, {"instruction": "Register an overlay\nIf the MetaModel was not loaded yet when evaluating addODataProperty, the\nplugin returns editable = false. Therefore we must make an extra check after\nthe MetaModel is loaded.\n@param  {sap.ui.dt.Overlay} oOverlay overlay object\n@override", "input": "JavaScript", "output": "function(oOverlay) {\n\t\t\tvar oModel = oOverlay.getElement().getModel();\n\t\t\tif (oModel){\n\t\t\t\tvar oMetaModel = oModel.getMetaModel();\n\t\t\t\tif (oMetaModel && oMetaModel.loaded){\n\t\t\t\t\toMetaModel.loaded().then(function(){\n\t\t\t\t\t\tthis.evaluateEditable([oOverlay], {onRegistration: true});\n\t\t\t\t\t}.bind(this));\n\t\t\t\t}\n\t\t\t}\n\t\t\tPlugin.prototype.registerElementOverlay.apply(this, arguments);\n\t\t}", "category": "Python"}, {"instruction": "Creates a request for an operation on a given service with\na set of input parameters.\n\n@param config [TableStore.Config] the config to perform the operation on\n@param operation [String] the operation to perform on the service\n@param params [Object] parameters to send to the operation.\nSee the operation's documentation for the format of the\nparameters.", "input": "JavaScript", "output": "function Request(config, operation, params) {\n    var endpoint = new TableStore.Endpoint(config.endpoint);\n    var region = config.region;\n    this.config = config;\n    if (config.maxRetries !== undefined) {\n      TableStore.DefaultRetryPolicy.maxRetryTimes = config.maxRetries;\n    }\n    //\u5982\u679c\u5728sdk\u5916\u90e8\u5305\u88c5\u4e86\u4e00\u5c42domain\uff0c\u5c31\u628a\u5b83\u4f20\u5230this.domain\n    this.domain = domain && domain.active;\n    this.operation = operation;\n    this.params = params || {};\n    this.httpRequest = new TableStore.HttpRequest(endpoint, region);\n    this.startTime = TableStore.util.date.getDate();\n\n    this.response = new TableStore.Response(this);\n    this.restartCount = 0;\n    this._asm = new AcceptorStateMachine(fsm.states, 'build');\n\n    TableStore.SequentialExecutor.call(this);\n    this.emit = this.emitEvent;\n  }", "category": "Python"}, {"instruction": "Process Slate node leaves in preparation for MDAST transformation.", "input": "JavaScript", "output": "function processLeaves(leaf) {\n  /**\n   * Get an array of the mark types, converted to their MDAST equivalent\n   * types.\n   */\n  const { marks = [], text } = leaf;\n  const markTypes = marks.map(mark => markMap[mark.type]);\n\n  if (typeof leaf.text === 'string') {\n    /**\n     * Code marks must be removed from the marks array, and the presence of a\n     * code mark changes the text node type that should be used.\n     */\n    const { filteredMarkTypes, textNodeType } = processCodeMark(markTypes);\n    return { text, marks: filteredMarkTypes, textNodeType };\n  }\n\n  return { node: leaf.node, marks: markTypes };\n}", "category": "Python"}, {"instruction": "/\\s*,\\s", "input": "JavaScript", "output": "function(name,loc) {\n\t\t// slow\n\t\tif(loc === undefined) loc = 0;\n\t\twhile (name[0] == ' '){\n\t\t\tloc++;\n\t\t\tname = name.substr(1);\n\t\t};\n\t\tname = name.trim();\n\t\treturn new Identifier(new Token('IDENTIFIER',name,loc,name.length));\n\t}", "category": "Python"}, {"instruction": "Clean value to boolean\nIf value is not a boolean or can't be converted, an error is thrown\nThis is probably unnecessary but more a precaution\n@param {any} value", "input": "JavaScript", "output": "function ensureBoolean(value) {\n  if (typeof value === 'boolean') {\n    return value;\n  }\n  if (typeof value === 'string' && value.toLowerCase() === 'true') {\n    return true;\n  } else if (typeof value === 'string' && value.toLowerCase() === 'false') {\n    return false;\n  } else if (value === 1) {\n    return true;\n  } else if (value === 0) {\n    return false;\n  }\n  throw new Error(`Unexpected value for boolean: ${value}`);\n}", "category": "Python"}, {"instruction": "Returns the currency symbols available for this locale.\nCurrency symbols get accumulated by custom currency symbols.\n\n@returns {object} the map of all currency symbols available in this locale, e.g.\n{\n\"AUD\": \"A$\",\n\"BRL\": \"R$\",\n\"EUR\": \"\u20ac\",\n\"GBP\": \"\u00a3\",\n}\n@public\n@since 1.60", "input": "JavaScript", "output": "function() {\n\t\t\t// Lookup into global Config\n\t\t\tvar mCustomCurrencies = this._get(\"currency\"),\n\t\t\t\tmCustomCurrencySymbols = {},\n\t\t\t\tsIsoCode;\n\n\t\t\tfor (var sCurrencyKey in mCustomCurrencies) {\n\t\t\t\tsIsoCode = mCustomCurrencies[sCurrencyKey].isoCode;\n\n\t\t\t\tif (mCustomCurrencies[sCurrencyKey].symbol) {\n\t\t\t\t\tmCustomCurrencySymbols[sCurrencyKey] = mCustomCurrencies[sCurrencyKey].symbol;\n\t\t\t\t} else if (sIsoCode) {\n\t\t\t\t\tmCustomCurrencySymbols[sCurrencyKey] = this._get(\"currencySymbols\")[sIsoCode];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Object.assign({}, this._get(\"currencySymbols\"), mCustomCurrencySymbols);\n\t\t}", "category": "Python"}, {"instruction": "constructor \nA loader for JSON manifests. Items inside the manifest are loaded before the loader completes. To load manifests\nusing JSONP, specify a {{#crossLink \"LoadItem/callback:property\"}}{{/crossLink}} as part of the\n{{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\nThe list of files in the manifest must be defined on the top-level JSON object in a `manifest` property. This\nexample shows a sample manifest definition, as well as how to to include a sub-manifest.\n\n{\n\"path\": \"assets/\",\n\"manifest\": [\n\"image.png\",\n{\"src\": \"image2.png\", \"id\":\"image2\"},\n{\"src\": \"sub-manifest.json\", \"type\":\"manifest\", \"callback\":\"jsonCallback\"}\n]\n}\n\nWhen a ManifestLoader has completed loading, the parent loader (usually a {{#crossLink \"LoadQueue\"}}{{/crossLink}},\nbut could also be another ManifestLoader) will inherit all the loaded items, so you can access them directly.\n\nNote that the {{#crossLink \"JSONLoader\"}}{{/crossLink}} and {{#crossLink \"JSONPLoader\"}}{{/crossLink}} are\nhigher priority loaders, so manifests <strong>must</strong> set the {{#crossLink \"LoadItem\"}}{{/crossLink}}\n{{#crossLink \"LoadItem/type:property\"}}{{/crossLink}} property to {{#crossLink \"Types/MANIFEST:property\"}}{{/crossLink}}.\n\nAdditionally, some browsers require the server to serve a JavaScript mime-type for JSONP, so it may not work in\nsome conditions.\n@class ManifestLoader\n@param {LoadItem|Object} loadItem\n@extends AbstractLoader\n@constructor", "input": "JavaScript", "output": "function ManifestLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.Types.MANIFEST);\n\n\t// Public Properties\n\t\t/**\n\t\t * An array of the plugins registered using {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}},\n\t\t * used to pass plugins to new LoadQueues that may be created.\n\t\t * @property _plugins\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis.plugins = null;\n\n\n\t// Protected Properties\n\t\t/**\n\t\t * An internal {{#crossLink \"LoadQueue\"}}{{/crossLink}} that loads the contents of the manifest.\n\t\t * @property _manifestQueue\n\t\t * @type {LoadQueue}\n\t\t * @private\n\t\t */\n\t\tthis._manifestQueue = null;\n\t}", "category": "Python"}, {"instruction": "Snatch wysiwyg command.\n@param {{command: object}} commandWrapper - wysiwyg command wrapper\n@private", "input": "JavaScript", "output": "function _snatchWysiwygCommand(commandWrapper) {\n  const {command} = commandWrapper;\n\n  if (!command.isWWType()) {\n    return;\n  }\n\n  switch (command.getName()) {\n  case 'AddRow':\n    commandWrapper.command = wwAddRow;\n    break;\n  case 'AddCol':\n    commandWrapper.command = wwAddCol;\n    break;\n  case 'RemoveRow':\n    commandWrapper.command = wwRemoveRow;\n    break;\n  case 'RemoveCol':\n    commandWrapper.command = wwRemoveCol;\n    break;\n  case 'AlignCol':\n    commandWrapper.command = wwAlignCol;\n    break;\n  default:\n  }\n}", "category": "Python"}, {"instruction": "/*\tEvents\n==================================================", "input": "JavaScript", "output": "function(error) {\n\t\tthis._state.loaded = true;\n\t\tthis.fire(\"loaded\", this.data);\n\t\tif (this.message) {\n\t\t\tthis.message.hide();\n\t\t}\n\t\tif (!(error || this.options.background)) {\n\t\t\tthis.showMeta();\n\t\t}\n\t\tthis.updateDisplay();\n\t}", "category": "Python"}, {"instruction": "This class is used to maintain all the accessibility roles, tooltips, etc., needed for the ShellBar control life cycle.\n@alias sap/f/shellBar/Accessibility\n@since 1.64\n@private", "input": "JavaScript", "output": "function (oContext) {\n\t\tif (oContext) {\n\t\t\toControl = oContext;\n\t\t\toControl.addDelegate(this._controlDelegate, false, this);\n\t\t}\n\n\t\tthis.oRb = Core.getLibraryResourceBundle(\"sap.f\");\n\t}", "category": "Python"}, {"instruction": "this could be rewritten with actual FS apis / globs, but this is simpler", "input": "JavaScript", "output": "function getFlatFiles(mfsData, output, getAssetPermissions, curBase = \"\") {\n  for (const path of Object.keys(mfsData)) {\n    const item = mfsData[path];\n    const curPath = `${curBase}/${path}`;\n    // directory\n    if (item[\"\"] === true) getFlatFiles(item, output, getAssetPermissions, curPath);\n    // file\n    else if (!curPath.endsWith(\"/\")) {\n      output[curPath.substr(1)] = {\n        source: mfsData[path],\n        permissions: getAssetPermissions(curPath.substr(1))\n      };\n    }\n  }\n}", "category": "Python"}, {"instruction": "/*\nAdjusts the ranks for all nodes in the graph such that all nodes v have\nrank(v) >= 0 and at least one node w has rank(w) = 0.", "input": "JavaScript", "output": "function normalizeRanks(g) {\n  var min = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    if (_.has(node, \"rank\")) {\n      node.rank -= min;\n    }\n  });\n}", "category": "Python"}, {"instruction": "OAuth2 Web Server Authentication Flow (Authorization Code)\nAccess Token Request\n\n@param {String} code - Authorization code\n@param {Object} [params] - Optional parameters to send in token retrieval\n@param {String} [params.code_verifier] - Code verifier value (RFC 7636 - Proof Key of Code Exchange)\n@param {Callback.<TokenResponse>} [callback] - Callback function\n@returns {Promise.<TokenResponse>}", "input": "JavaScript", "output": "function(code, params, callback) {\n    if (typeof params === 'function') {\n      callback = params;\n      params = {};\n    }\n    params = _.extend({\n      grant_type : \"authorization_code\",\n      code : code,\n      client_id : this.clientId,\n      redirect_uri : this.redirectUri\n    }, params || {});\n    if (this.clientSecret) {\n      params.client_secret = this.clientSecret;\n    }\n    return this._postParams(params, callback);\n  }", "category": "Python"}, {"instruction": "def new_registry(attribute=None):\n    \"\"\"\n    Returns an empty dict and a @register decorator.\n    \"\"\"\n", "input": "", "output": "    registry = {}\n\n    def register(key):\n        def decorator(func):\n            registry[key] = func\n            if attribute:\n                setattr(func, attribute, key)\n            return func\n        return decorator\n\n    return registry, register", "category": "Python"}, {"instruction": "Helper functions needed in wait*() methods. Casts timeout argument to integer and checks if next step\nfunction is really a function and if it has been given (if required - depending on isThenRequired flag).\n\n@param   Number   timeout        The max amount of time to wait, in milliseconds\n@param   Function then           Next step to process (optional or required, depending on isThenRequired flag)\n@param   String   methodName     Name of the method, inside of which the helper has been called\n@param   Number   defaultTimeout The default max amount of time to wait, in milliseconds (optional)\n@param   Boolean  isThenRequired Determines if the next step function should be considered as required\n@returns Number", "input": "JavaScript", "output": "function getTimeoutAndCheckNextStepFunction(timeout, then, methodName, defaultTimeout, isThenRequired) {\n    if (isThenRequired || then) {\n        var isFunction = utils.isFunction(then); // Optimization to perform \"isFunction\" check only once.\n\n        if (isThenRequired && !isFunction) {\n            throw new CasperError(methodName + \"() needs a step function\");\n        } else if (then && !isFunction) {\n            throw new CasperError(methodName + \"() next step definition must be a function\");\n        }\n    }\n\n    timeout = ~~timeout || ~~defaultTimeout;\n    if (timeout < 0) {\n        throw new CasperError(methodName + \"() only accepts an integer >= 0 as a timeout value\");\n    }\n\n    return timeout;\n}", "category": "Python"}, {"instruction": "def flush_stream_threads(process, out_formatter=None,\n                                  err_formatter=terminal.fg.red, size=1):\n    \"\"\"\n    Context manager that creates 2 threads, one for each standard\n    stream (stdout/stderr), updating in realtime the piped data.\n    The formatters are callables that receives manipulates the data,\n    e.g. coloring it before writing to a ``sys`` stream. See\n    ``FlushStreamThread`` for more information.\n    \"\"\"\n", "input": "", "output": "    out = FlushStreamThread(process=process, stream_name=\"stdout\",\n                            formatter=out_formatter, size=size)\n    err = FlushStreamThread(process=process, stream_name=\"stderr\",\n                            formatter=err_formatter, size=size)\n    out.start()\n    err.start()\n    yield out, err\n    out.join()\n    err.join()", "category": "Python"}, {"instruction": "def disable_selinux():\n    \"\"\" disables selinux \"\"\"\n", "input": "", "output": "\n    if contains(filename='/etc/selinux/config',\n                text='SELINUX=enforcing'):\n        sed('/etc/selinux/config',\n            'SELINUX=enforcing', 'SELINUX=disabled', use_sudo=True)\n\n    if contains(filename='/etc/selinux/config',\n                text='SELINUX=permissive'):\n        sed('/etc/selinux/config',\n            'SELINUX=permissive', 'SELINUX=disabled', use_sudo=True)\n\n    if sudo('getenforce').lower() != 'disabled':\n        with settings(warn_only=True, capture=True):\n            sudo('/sbin/reboot')\n        sleep_for_one_minute()", "category": "Python"}, {"instruction": "def cares_about(self, delta):\n        \"\"\"Return True if this observer \"cares about\" (i.e. wants to be\n        called) for a this delta.\n\n        \"\"\"\n", "input": "", "output": "        if (self.entity_id and delta.get_id() and\n                not re.match(self.entity_id, str(delta.get_id()))):\n            return False\n\n        if self.entity_type and self.entity_type != delta.entity:\n            return False\n\n        if self.action and self.action != delta.type:\n            return False\n\n        if self.predicate and not self.predicate(delta):\n            return False\n\n        return True", "category": "Python"}, {"instruction": "def getargspec(fn):  # type: (Callable) -> inspect.ArgSpec\n    \"\"\"Get the names and default values of a function's arguments.\n\n    Args:\n        fn (function): a function\n\n    Returns:\n        `inspect.ArgSpec`:  A collections.namedtuple with the following attributes:\n\n            * Args:\n                args (list): a list of the argument names (it may contain nested lists).\n                varargs (str): name of the * argument or None.\n                keywords (str): names of the ** argument or None.\n                defaults (tuple): an n-tuple of the default values of the last n arguments.\n    \"\"\"\n", "input": "", "output": "    if six.PY2:\n        return inspect.getargspec(fn)\n    elif six.PY3:\n        full_arg_spec = inspect.getfullargspec(fn)\n        return inspect.ArgSpec(full_arg_spec.args, full_arg_spec.varargs, full_arg_spec.varkw, full_arg_spec.defaults)", "category": "Python"}, {"instruction": "def config_dict(config):\n    \"\"\"\n    Given a Sphinx config object, return a dictionary of config\n    values.\n    \"\"\"\n", "input": "", "output": "    return dict(\n        (key, getattr(config, key))\n        for key in config.values\n    )", "category": "Python"}, {"instruction": "def processlist(**connection_args):\n    '''\n    Retrieves the processlist from the MySQL server via\n    \"SHOW FULL PROCESSLIST\".\n\n    Returns: a list of dicts, with each dict representing a process:\n\n    .. code-block:: python\n\n        {'Command': 'Query',\n        'Host': 'localhost',\n        'Id': 39,\n        'Info': 'SHOW FULL PROCESSLIST',\n        'Rows_examined': 0,\n        'Rows_read': 1,\n        'Rows_sent': 0,\n        'State': None,\n        'Time': 0,\n        'User': 'root',\n        'db': 'mysql'}\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' mysql.processlist\n\n    '''\n", "input": "", "output": "    ret = []\n\n    dbc = _connect(**connection_args)\n    if dbc is None:\n        return []\n    cur = dbc.cursor()\n    _execute(cur, 'SHOW FULL PROCESSLIST')\n    hdr = [c[0] for c in cur.description]\n    for _ in range(cur.rowcount):\n        row = cur.fetchone()\n        idx_r = {}\n        for idx_j in range(len(hdr)):\n            idx_r[hdr[idx_j]] = row[idx_j]\n        ret.append(idx_r)\n    cur.close()\n    return ret", "category": "Python"}, {"instruction": "def set_timezone(self, request, org):\n        \"\"\"Set the current timezone from the org configuration.\"\"\"\n", "input": "", "output": "        if org and org.timezone:\n            timezone.activate(org.timezone)", "category": "Python"}, {"instruction": "def visitIgnoreDirective(self, ctx: jsgParser.IgnoreDirectiveContext):\n        \"\"\" directive: '.IGNORE' name* SEMI \"\"\"\n", "input": "", "output": "        for name in as_tokens(ctx.name()):\n            self._context.directives.append('_CONTEXT.IGNORE.append(\"{}\")'.format(name))", "category": "Python"}, {"instruction": "def export_project(self):\n        \"\"\" Processes misc options specific for GCC ARM, and run generator. \"\"\"\n", "input": "", "output": "        output = copy.deepcopy(self.generated_project)\n        self.process_data_for_makefile(self.workspace)\n        self._fix_sublime_paths(self.workspace)\n        self.workspace['linker_options'] =[]\n\n        output['path'], output['files']['makefile'] = self.gen_file_jinja('makefile_gcc.tmpl', self.workspace, 'Makefile', self.workspace['output_dir']['path'])\n\n        self.workspace['buildsys_name'] = 'Make'\n        self.workspace['buildsys_cmd'] = 'make all'\n\n        path, output['files']['sublimetext'] = self.gen_file_jinja(\n            'sublimetext.sublime-project.tmpl', self.workspace, '%s.sublime-project' % self.workspace['name'], self.workspace['output_dir']['path'])\n        generated_projects = output\n        return generated_projects", "category": "Python"}, {"instruction": "def get_all_repos(self):\n        \"\"\"Gets user repos\n        :return: List of all user repositories (public, orgs and private)\n        \"\"\"\n", "input": "", "output": "        url = \"https://api.github.com/user/repos\"\n        params = {\n            \"access_token\": GITHUB_TOKEN\n        }  # add auth params\n        url = add_params_to_url(url, params)\n        return self._get_repos(url)", "category": "Python"}, {"instruction": "def save_graph(cn_topo, filename, showintfs=False, showaddrs=False):\n    '''\n    Save the topology to an image file \n    '''\n", "input": "", "output": "    __do_draw(cn_topo, showintfs=showintfs, showaddrs=showaddrs)\n    pyp.savefig(filename)", "category": "Python"}, {"instruction": "def byteify(input_object):\n    \"\"\"Recursive function to transform an object to byte.\n\n    :param input_object: A python object such as unicode, dictionary or list.\n    :type: unicode, list, dict\n\n    :return: The object with byte only.\n    \"\"\"\n", "input": "", "output": "    if isinstance(input_object, dict):\n        return {byteify(key): byteify(value)\n                for key, value in list(input_object.items())}\n    elif isinstance(input_object, list):\n        return [byteify(element) for element in input_object]\n    elif isinstance(input_object, str):\n        return input_object.encode('utf-8')\n    else:\n        return input_object", "category": "Python"}, {"instruction": "def rosmsg(self):\n        \"\"\":obj:`sensor_msgs.Image` : ROS Image\n        \"\"\"\n", "input": "", "output": "        from cv_bridge import CvBridge, CvBridgeError\n        cv_bridge = CvBridge()\n        try:\n            return cv_bridge.cv2_to_imgmsg(self._data, encoding=self._encoding)\n        except CvBridgeError as cv_bridge_exception:\n            logging.error('%s' % (str(cv_bridge_exception)))", "category": "Python"}, {"instruction": "def get_gateway_socket(gateway):\r\n    \"\"\"Takes a gateway address string and returns a non-blocking UDP\r\n       socket to communicate with its NAT-PMP implementation on\r\n       NATPMP_PORT.\r\n       \r\n       e.g. addr = get_gateway_socket('10.0.1.1')\r\n    \"\"\"\n", "input": "", "output": "    if not gateway:\r\n        raise NATPMPNetworkError(NATPMP_GATEWAY_NO_VALID_GATEWAY,\r\n                                 error_str(NATPMP_GATEWAY_NO_VALID_GATEWAY))\r\n    response_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\r\n    response_socket.setblocking(0)\r\n    response_socket.connect((gateway, NATPMP_PORT))\r\n    return response_socket", "category": "Python"}, {"instruction": "def start_worker(self):\n        \"\"\"Trigger new process as a RQ worker.\"\"\"\n", "input": "", "output": "        if not self.include_rq:\n            return None\n\n        worker = Worker(queues=self.queues,\n                        connection=self.connection)\n        worker_pid_path = current_app.config.get(\n            \"{}_WORKER_PID\".format(self.config_prefix), 'rl_worker.pid'\n        )\n\n        try:\n            worker_pid_file = open(worker_pid_path, 'r')\n            worker_pid = int(worker_pid_file.read())\n            print(\"Worker already started with PID=%d\" % worker_pid)\n            worker_pid_file.close()\n\n            return worker_pid\n\n        except (IOError, TypeError):\n            self.worker_process = Process(target=worker_wrapper, kwargs={\n                'worker_instance': worker,\n                'pid_path': worker_pid_path\n            })\n            self.worker_process.start()\n            worker_pid_file = open(worker_pid_path, 'w')\n            worker_pid_file.write(\"%d\" % self.worker_process.pid)\n            worker_pid_file.close()\n\n            print(\"Start a worker process with PID=%d\" %\n                  self.worker_process.pid)\n\n            return self.worker_process.pid", "category": "Python"}, {"instruction": "def request_frame(self):\n        \"\"\"Construct initiating frame.\"\"\"\n", "input": "", "output": "        self.session_id = get_new_session_id()\n        return FrameActivateSceneRequest(scene_id=self.scene_id, session_id=self.session_id)", "category": "Python"}, {"instruction": "def _compute_distance_scaling(self, rup, dists, C):\n        \"\"\"\n        Compute distance-scaling term, equations (3) and (4), pag 107.\n        \"\"\"\n", "input": "", "output": "        Mref = 4.5\n        Rref = 1.0\n        R = np.sqrt(dists.rjb ** 2 + C['h'] ** 2)\n        return (C['c1'] + C['c2'] * (rup.mag - Mref)) * np.log(R / Rref) + \\\n            C['c3'] * (R - Rref)", "category": "Python"}, {"instruction": "def to_bytes(value):\n    \"\"\" str to bytes (py3k) \"\"\"\n", "input": "", "output": "    vtype = type(value)\n\n    if vtype == bytes or vtype == type(None):\n        return value\n\n    try:\n        return vtype.encode(value)\n    except UnicodeEncodeError:\n        pass\n    return value", "category": "Python"}, {"instruction": "def Split(g, *, maxbuffer=10, tuple_len=None):\n    \"\"\"\n    Split a tuple generator into individual generators.\n\n    Parameters\n    ----------\n    g: tohu generator\n        The generator to be split. The items produced by `g` must be tuples.\n    maxbuffer: integer\n        Maximum number of items produced by `g` that will be buffered.\n    \"\"\"\n", "input": "", "output": "    if tuple_len is None:\n        try:\n            tuple_len = g.tuple_len\n        except AttributeError:\n            raise ValueError(\"Argument 'tuple_len' must be given since generator is not of type TupleGenerator.\")\n\n    g_buffered = BufferedTuple(g, maxbuffer=maxbuffer, tuple_len=tuple_len)\n\n    return tuple(NthElementBuffered(g_buffered, i) for i in range(tuple_len))", "category": "Python"}, {"instruction": "def _remove_unicode_encoding(xml_file):\n    '''\n    attempts to remove the \"encoding='unicode'\" from an xml file\n    as lxml does not support that on a windows node currently\n    see issue #38100\n    '''\n", "input": "", "output": "    with salt.utils.files.fopen(xml_file, 'rb') as f:\n        xml_content = f.read()\n    modified_xml = re.sub(r' encoding=[\\'\"]+unicode[\\'\"]+', '', xml_content.decode('utf-16'), count=1)\n    xmltree = lxml.etree.parse(six.StringIO(modified_xml))\n    return xmltree", "category": "Python"}, {"instruction": "def btc_is_p2sh_script( script_hex ):\n    \"\"\"\n    Is the given scriptpubkey a p2sh script?\n    \"\"\"\n", "input": "", "output": "    if script_hex.startswith(\"a914\") and script_hex.endswith(\"87\") and len(script_hex) == 46:\n        return True\n    else:\n        return False", "category": "Python"}, {"instruction": "def modify(self, **kwargs):\n        \"\"\"We need to implement the custom exclusive parameter check.\"\"\"\n", "input": "", "output": "        self._check_exclusive_parameters(**kwargs)\n        return super(Rule, self)._modify(**kwargs)", "category": "Python"}, {"instruction": "def make_request(parameters):\n    \"\"\"Submit a getfeature request to DataBC WFS and return features\n    \"\"\"\n", "input": "", "output": "    r = requests.get(bcdata.WFS_URL, params=parameters)\n    return r.json()[\"features\"]", "category": "Python"}, {"instruction": "def parse_obj(obj):\n    \"\"\"\n    >>> parse_obj('bucket/key')\n    ('bucket', 'key')\n    >>> parse_obj('my-bucket/path/to/file.txt')\n    ('my-bucket', 'path/to/file.txt')\n    >>> parse_obj('s3://this_bucket/some/path.txt')\n    ('this_bucket', 'some/path.txt')\n    >>> parse_obj('https://s3.amazonaws.com/bucket/file.txt')\n    ('bucket', 'file.txt')\n    >>> parse_obj('http://the-bucket.s3.amazonaws.com/the/file.txt')\n    ('the-bucket', 'the/file.txt')\n    \"\"\"\n", "input": "", "output": "    obj = obj.lstrip('s3://')\n    if obj.startswith('http'):\n        url = urlparse.urlparse(obj)\n        if url.netloc == 's3.amazonaws.com':\n            path = url.path[1:]  # remove leading slash\n            bucket, key = path.split('/', 1)\n        else:\n            # bucket.s3.amazonaws.com form\n            bucket = url.netloc.split('.', 1)[0]\n            key = url.path[1:]\n    else:\n        bucket, key = obj.split('/', 1)\n    return bucket, key", "category": "Python"}, {"instruction": "def branches(self):\n        \"\"\"\n        Returns a data frame of all branches in origin.  The DataFrame will have the columns:\n\n         * repository\n         * local\n         * branch\n\n        :returns: DataFrame\n        \"\"\"\n", "input": "", "output": "\n        df = pd.DataFrame(columns=['repository', 'local', 'branch'])\n\n        if _has_joblib:\n            ds = Parallel(n_jobs=-1, backend='threading', verbose=0)(\n                delayed(_branches_func)\n                (x) for x in self.repos\n            )\n            for d in ds:\n                df = df.append(d)\n        else:\n            for repo in self.repos:\n                try:\n                    df = df.append(_branches_func(repo))\n                except GitCommandError:\n                    print('Warning! Repo: %s couldn\\'t be inspected' % (repo, ))\n\n        df.reset_index()\n\n        return df", "category": "Python"}, {"instruction": "def windowing(self, windowing):\n        \"\"\"Sets the windowing of this ChartSettings.\n\n        For the tabular view, whether to use the full time window for the query or the last X minutes  # noqa: E501\n\n        :param windowing: The windowing of this ChartSettings.  # noqa: E501\n        :type: str\n        \"\"\"\n", "input": "", "output": "        allowed_values = [\"full\", \"last\"]  # noqa: E501\n        if windowing not in allowed_values:\n            raise ValueError(\n                \"Invalid value for `windowing` ({0}), must be one of {1}\"  # noqa: E501\n                .format(windowing, allowed_values)\n            )\n\n        self._windowing = windowing", "category": "Python"}, {"instruction": "def leaves(self, nodes=None, unique=True):\n        \"\"\"Get the leaves of the tree starting at this root.\n\n        Args:\n            nodes (iterable): limit leaves for these node names\n            unique: only include individual leaf nodes once\n\n        Returns:\n            list of leaf nodes\n\n        \"\"\"\n", "input": "", "output": "        if nodes is None:\n            return super(DependencyTree, self).leaves(unique=unique)\n\n        res = list()\n        for child_id in nodes:\n            for sub_child in self._all_nodes[child_id].leaves(unique=unique):\n                if not unique or sub_child not in res:\n                    res.append(sub_child)\n        return res", "category": "Python"}, {"instruction": "def chunks(l, n):\n    \"\"\"Yield successive n-sized chunks from l.\"\"\"\n", "input": "", "output": "    if n:\n        for i in xrange(0, len(l), n):\n            yield l[i:i + n]", "category": "Python"}, {"instruction": "def get_prep_value(self, value):\n        \"\"\"Returns field's value prepared for saving into a database.\"\"\"\n", "input": "", "output": "\n        if isinstance(value, LocalizedValue):\n            prep_value = LocalizedValue()\n            for k, v in value.__dict__.items():\n                if v is None:\n                    prep_value.set(k, '')\n                else:\n                    # Need to convert File objects provided via a form to\n                    # unicode for database insertion\n                    prep_value.set(k, six.text_type(v))\n            return super().get_prep_value(prep_value)\n        return super().get_prep_value(value)", "category": "Python"}, {"instruction": "def upsert(self, table: str, record: dict, create_cols: bool=False,\n               dtypes: list=None, pks=[\"id\"], namefields=[\"id\"]):\n        \"\"\"\n        Upsert a record in a table\n        \"\"\"\n", "input": "", "output": "        try:\n            self.db[table].upsert(record, pks, create_cols, dtypes)\n        except Exception as e:\n            self.err(e, \"Can not upsert data\")\n            return\n        names = \"\"\n        for el in namefields:\n            names += \" \" + record[el]\n        self.ok(\"Upserted record\"+names)", "category": "Python"}, {"instruction": "def add_timescale(self, timescale):\n        \"\"\"\n        Add a time scale to the plot.\n\n        :param timescale: the timescale to be added\n        :type  timescale: :class:`~aeneas.plotter.PlotTimeScale`\n        :raises: TypeError: if ``timescale`` is not an instance of :class:`~aeneas.plotter.PlotTimeScale`\n        \"\"\"\n", "input": "", "output": "        if not isinstance(timescale, PlotTimeScale):\n            self.log_exc(u\"timescale must be an instance of PlotTimeScale\", None, True, TypeError)\n        self.timescale = timescale\n        self.log(u\"Added timescale\")", "category": "Python"}, {"instruction": "def _visit(self, element, operation):\n        \"\"\"\n        Visit and execute a operation in element and descendants.\n\n        :param element: The element.\n        :type element: hatemile.util.html.htmldomelement.HTMLDOMElement\n        :param operation: The operation to be executed.\n        :type operation: function\n        \"\"\"\n", "input": "", "output": "\n        if self._is_valid_inherit_element(element):\n            if element.has_children_elements():\n                children = element.get_children_elements()\n                for child in children:\n                    self._visit(child, operation)\n            elif self._is_valid_element(element):\n                operation(element)", "category": "Python"}, {"instruction": "def Crawl(self, seed, seedClient=None, jobClient=None, rounds=1, index=True):\n        \"\"\"\n        Launch a crawl using the given seed\n        :param seed: Type (Seed or SeedList) - used for crawl\n        :param seedClient: if a SeedList is given, the SeedClient to upload, if None a default will be created\n        :param jobClient: the JobClient to be used, if None a default will be created\n        :param rounds: the number of rounds in the crawl\n        :return: a CrawlClient to monitor and control the crawl\n        \"\"\"\n", "input": "", "output": "        if seedClient is None:\n            seedClient = self.Seeds()\n        if jobClient is None:\n            jobClient = self.Jobs()\n\n        if type(seed) != Seed:\n            seed = seedClient.create(jobClient.crawlId + '_seeds', seed)\n        return CrawlClient(self.server, seed, jobClient, rounds, index)", "category": "Python"}, {"instruction": "def _common_parser():\n    \"\"\"Returns a parser with common command-line options for all the scripts\n    in the fortpy suite.\n    \"\"\"\n", "input": "", "output": "    import argparse\n    parser = argparse.ArgumentParser(add_help=False)\n    parser.add_argument(\"-examples\", action=\"store_true\",\n                        help=\"See detailed help and examples for this script.\")\n    parser.add_argument(\"-verbose\", action=\"store_true\",\n                        help=\"See verbose output as the script runs.\")\n    parser.add_argument('-action', nargs=1, choices=['save','print'], default='print',\n                        help=\"Specify what to do with the output (print or save)\")\n    parser.add_argument(\"-debug\", action=\"store_true\",\n                        help=\"Print verbose calculation information for debugging.\")\n\n    return parser", "category": "Python"}, {"instruction": "def signout(self, redirect_url = \"/\"):\r\n        \"\"\"\r\n            \u6ce8\u9500\u767b\u5f55\u72b6\u6001\r\n\r\n            \u53c2\u6570:\r\n                redirect_url    \u8df3\u8f6c\u94fe\u63a5\uff0c\u4e3a None \u65f6\u4e0d\u8df3\u8f6c (Ajax \u53ef\u80fd\u7528\u5f97\u5230)\u3002\r\n        \"\"\"\n", "input": "", "output": "        self.clear_cookie(self._USER_NAME)\r\n        if redirect_url: self.redirect(redirect_url)", "category": "Python"}, {"instruction": "def download(odir: Path, source_url: str, irng: Sequence[int]):\n    \"\"\"Download star index files.\n    The default range was useful for my cameras.\n    \"\"\"\n", "input": "", "output": "    assert len(irng) == 2, 'specify start, stop indices'\n\n    odir = Path(odir).expanduser()\n    odir.mkdir(parents=True, exist_ok=True)\n\n    ri = int(source_url.split('/')[-2][:2])\n\n    for i in range(*irng):\n        fn = f'index-{ri:2d}{i:02d}.fits'\n        url = f'{source_url}{fn}'\n        ofn = odir / fn\n        if ofn.is_file():  # no clobber\n            print('skipping', ofn)\n            continue\n        print(f'{url} => {ofn}', end='\\r')\n\n        urlretrieve(url, ofn)", "category": "Python"}, {"instruction": "def assertTraceDoesNotContain(response, message):\n    \"\"\"\n    Raise TestStepFail if response.verify_trace finds message from response traces.\n\n    :param response: Response. Must contain method verify_trace\n    :param message: Message to look for\n    :return: Nothing\n    :raises: AttributeError if response does not contain verify_trace method.\n    TestStepFail if verify_trace returns True.\n    \"\"\"\n", "input": "", "output": "    if not hasattr(response, \"verify_trace\"):\n        raise AttributeError(\"Response object does not contain verify_trace method!\")\n    if response.verify_trace(message, False):\n        raise TestStepFail('Assert: Message(s) \"%s\" in response' % message)", "category": "Python"}, {"instruction": "def record(self):\n        # type: () -> bytes\n        '''\n        A method to generate the string representing this UDF ICB Tag.\n\n        Parameters:\n         None.\n        Returns:\n         A string representing this UDF ICB Tag.\n        '''\n", "input": "", "output": "        if not self._initialized:\n            raise pycdlibexception.PyCdlibInternalError('UDF ICB Tag not initialized')\n\n        return struct.pack(self.FMT, self.prior_num_direct_entries,\n                           self.strategy_type, self.strategy_param,\n                           self.max_num_entries, 0, self.file_type,\n                           self.parent_icb_log_block_num,\n                           self.parent_icb_part_ref_num, self.flags)", "category": "Python"}, {"instruction": "def styles(self, dictobj):\n\t\t\"\"\"\n\t\tAdd or update styles\n\t\t\"\"\"\n", "input": "", "output": "\t\tfor k in dictobj:\n\t\t\tself.chart_style[k] = dictobj[k]", "category": "Python"}, {"instruction": "def AddDefaultMergers(self):\n    \"\"\"Adds the default DataSetMergers defined in this module.\"\"\"\n", "input": "", "output": "    self.AddMerger(AgencyMerger(self))\n    self.AddMerger(StopMerger(self))\n    self.AddMerger(RouteMerger(self))\n    self.AddMerger(ServicePeriodMerger(self))\n    self.AddMerger(FareMerger(self))\n    self.AddMerger(ShapeMerger(self))\n    self.AddMerger(TripMerger(self))\n    self.AddMerger(FareRuleMerger(self))", "category": "Python"}, {"instruction": "def ConcatWith(x, tensor, dim):\n    \"\"\"\n    A wrapper around ``tf.concat`` to cooperate with :class:`LinearWrap`.\n\n    Args:\n        x (tf.Tensor): input\n        tensor (list[tf.Tensor]): a tensor or list of tensors to concatenate with x.\n            x will be at the beginning\n        dim (int): the dimension along which to concatenate\n\n    Returns:\n        tf.Tensor: ``tf.concat([x] + tensor, dim)``\n    \"\"\"\n", "input": "", "output": "    if type(tensor) != list:\n        tensor = [tensor]\n    return tf.concat([x] + tensor, dim)", "category": "Python"}, {"instruction": "def consume(self, limit=None):\n        \"\"\"Returns an iterator that waits for one message at a time.\"\"\"\n", "input": "", "output": "        for total_message_count in count():\n            if limit and total_message_count >= limit:\n                raise StopIteration\n\n            if not self.channel.is_open:\n                raise StopIteration\n\n            self.channel.wait()\n            yield True", "category": "Python"}, {"instruction": "def _num_required_args(func):\n    \"\"\" Number of args for func\n\n        >>> def foo(a, b, c=None):\n        ... return a + b + c\n\n        >>> _num_required_args(foo)\n        2\n\n        >>> def bar(*args):\n        ... return sum(args)\n\n        >>> print(_num_required_args(bar))\n        None\n\n        borrowed from: https://github.com/pytoolz/toolz\n    \"\"\"\n", "input": "", "output": "    try:\n        spec = inspect.getargspec(func)\n        if spec.varargs:\n            return None\n        num_defaults = len(spec.defaults) if spec.defaults else 0\n        return len(spec.args) - num_defaults\n    except TypeError:\n        return None", "category": "Python"}, {"instruction": "def image_feature_engineering(features, feature_tensors_dict):\n  \"\"\"Add a hidden layer on image features.\n\n  Args:\n    features: features dict\n    feature_tensors_dict: dict of feature-name: tensor\n  \"\"\"\n", "input": "", "output": "  engineered_features = {}\n  for name, feature_tensor in six.iteritems(feature_tensors_dict):\n    if name in features and features[name]['transform'] == IMAGE_TRANSFORM:\n      with tf.name_scope(name, 'Wx_plus_b'):\n        hidden = tf.contrib.layers.fully_connected(\n            feature_tensor,\n            IMAGE_HIDDEN_TENSOR_SIZE)\n        engineered_features[name] = hidden\n    else:\n      engineered_features[name] = feature_tensor\n  return engineered_features", "category": "Python"}, {"instruction": "def _api_group_for_type(cls):\n    \"\"\"\n    Determine which Kubernetes API group a particular PClass is likely to\n    belong with.\n\n    This is basically nonsense.  The question being asked is wrong.  An\n    abstraction has failed somewhere.  Fixing that will get rid of the need\n    for this.\n    \"\"\"\n", "input": "", "output": "    _groups = {\n        (u\"v1beta1\", u\"Deployment\"): u\"extensions\",\n        (u\"v1beta1\", u\"DeploymentList\"): u\"extensions\",\n        (u\"v1beta1\", u\"ReplicaSet\"): u\"extensions\",\n        (u\"v1beta1\", u\"ReplicaSetList\"): u\"extensions\",\n    }\n    key = (\n        cls.apiVersion,\n        cls.__name__.rsplit(u\".\")[-1],\n    )\n    group = _groups.get(key, None)\n    return group", "category": "Python"}, {"instruction": "def get_capacity(self, legacy=None):\n        \"\"\"Get capacity of all facilities.\n\n        :param legacy: Indicate set of server types to include in response\n\n        Validation of `legacy` is left to the packet api to avoid going out of date if any new value is introduced.\n        The currently known values are:\n          - only (current default, will be switched \"soon\")\n          - include\n          - exclude (soon to be default)\n        \"\"\"\n", "input": "", "output": "        params = None\n        if legacy:\n            params = {'legacy': legacy}\n\n        return self.call_api('/capacity', params=params)['capacity']", "category": "Python"}, {"instruction": "def vm_state(vm_=None, **kwargs):\n    '''\n    Return list of all the vms and their state.\n\n    If you pass a VM name in as an argument then it will return info\n    for just the named VM, otherwise it will return all VMs.\n\n    :param vm_: name of the domain\n    :param connection: libvirt connection URI, overriding defaults\n\n        .. versionadded:: 2019.2.0\n    :param username: username to connect with, overriding defaults\n\n        .. versionadded:: 2019.2.0\n    :param password: password to connect with, overriding defaults\n\n        .. versionadded:: 2019.2.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virt.vm_state <domain>\n    '''\n", "input": "", "output": "    def _info(dom):\n        ", "category": "Python"}, {"instruction": "def re_parser(self, scode, *args):\n        \"\"\"\n        args: [arg1, arg2]\n\n        arg[0] = a valid regex pattern\n\n        arg[1] : if startswith('@') call sub; if startswith('$') call finditer,\n                 $0, $1 means group index.\n\n        return an ensure_list\n        \"\"\"\n", "input": "", "output": "\n        def gen_match(matches, num):\n            for match in matches:\n                yield match.group(num)\n\n        scode = self.ensure_str(scode)\n        assert self._re.match(\n            '^@|^\\$\\d+', args[1]), ValueError('args1 should match ^@|^\\$\\d+')\n        arg1, arg2 = args[1][0], args[1][1:]\n        com = self._re.compile(args[0])\n        if arg1 == '@':\n            result = com.sub(arg2, scode)\n            return self.ensure_list(result)\n        else:\n            result = com.finditer(scode)\n            return gen_match(result, int(arg2))", "category": "Python"}, {"instruction": "def entropy_bits_nrange(\n        minimum: Union[int, float], maximum: Union[int, float]\n) -> float:\n    \"\"\"Calculate the number of entropy bits in a range of numbers.\"\"\"\n", "input": "", "output": "    # Shannon:\n    # d = fabs(maximum - minimum)\n    # ent = -(1/d) * log(1/d, 2) * d\n    # Aprox form: log10(digits) * log2(10)\n    if not isinstance(minimum, (int, float)):\n        raise TypeError('minimum can only be int or float')\n    if not isinstance(maximum, (int, float)):\n        raise TypeError('maximum can only be int or float')\n    if minimum < 0:\n        raise ValueError('minimum should be greater than 0')\n    if maximum < 0:\n        raise ValueError('maximum should be greater than 0')\n\n    dif = fabs(maximum - minimum)\n    if dif == 0:\n        return 0.0\n\n    ent = log10(dif) * 3.321928\n    return ent", "category": "Python"}, {"instruction": "def tag_audio(filename, tracklisting):\n    \"\"\"Return True if audio tagged successfully; handle tagging audio.\"\"\"\n", "input": "", "output": "    # TODO: maybe actually glob for files, then try tagging if present?\n    if not(tag_audio_file(filename + '.m4a', tracklisting) or\n           tag_audio_file(filename + '.mp3', tracklisting)):\n        print(\"Cannot find or access any relevant M4A or MP3 audio file.\")\n        print(\"Trying to save a text file instead.\")\n        write_text(filename, tracklisting)\n        return False\n    return True", "category": "Python"}, {"instruction": "def transform(self, vector):\n        \"\"\"\n        Computes the Hadamard product of the vector.\n        \"\"\"\n", "input": "", "output": "        if isinstance(vector, RDD):\n            vector = vector.map(_convert_to_vector)\n\n        else:\n            vector = _convert_to_vector(vector)\n        return callMLlibFunc(\"elementwiseProductVector\", self.scalingVector, vector)", "category": "Python"}, {"instruction": "def logger_has_handlers(logger):\n    \"\"\"\n    Check if given logger has at least 1 handler associated, return a boolean value.\n\n    Since Python 2 doesn't provide Logger.hasHandlers(), we have to perform the lookup by ourself.\n    \"\"\"\n", "input": "", "output": "    if six.PY3:\n        return logger.hasHandlers()\n    else:\n        c = logger\n        rv = False\n        while c:\n            if c.handlers:\n                rv = True\n                break\n            if not c.propagate:\n                break\n            else:\n                c = c.parent\n        return rv", "category": "Python"}, {"instruction": "def tukey(winlen, alpha):\n    \"\"\"\n    Generate a tukey (tapered cosine) window\n    :param winlen: length of the window, in samples\n    :type winlen: int\n    :param alpha: proportion of the window to be tapered. \n    0 = rectangular window\n    1.0 = hann window\n    :type alpha: float\n    \"\"\"\n", "input": "", "output": "    taper = hann(winlen * alpha)\n    rect = np.ones(winlen - len(taper) + 1)\n    win = fftconvolve(taper, rect)\n    win = win / np.amax(win)\n    return win", "category": "Python"}, {"instruction": "def pkg_blacklist(self):\n        \"\"\"Manage blacklist packages\n        \"\"\"\n", "input": "", "output": "        blacklist = BlackList()\n        options = [\n            \"-b\",\n            \"--blacklist\"\n        ]\n        flag = [\n            \"--add\",\n            \"--remove\"\n        ]\n        command = [\"list\"]\n        if (len(self.args) == 2 and self.args[0] in options and\n                self.args[1] == command[0]):\n            blacklist.listed()\n        elif (len(self.args) > 2 and self.args[0] in options and\n                flag[0] in self.args):\n            self.args.remove(flag[0])\n            blacklist.add(self.args[1:])\n        elif (len(self.args) == 3 and self.args[0] in options and\n                \"ALL\" in self.args and flag[1] in self.args):\n            self.args.remove(flag[1])\n            blacklist.remove(blacklist.get_black())\n        elif (len(self.args) > 2 and self.args[0] in options and\n                flag[1] in self.args):\n            self.args.remove(flag[1])\n            blacklist.remove(self.args[1:])\n        else:\n            usage(\"\")", "category": "Python"}, {"instruction": "def log(self, time, message, level=None, attachment=None):\n        \"\"\"Logs a message with attachment.\n\n        The attachment is a dict of:\n            name: name of attachment\n            data: file content\n            mime: content type for attachment\n        \"\"\"\n", "input": "", "output": "        logger.debug(\"log queued\")\n\n        args = {\n            \"time\": time,\n            \"message\": message,\n            \"level\": level,\n            \"attachment\": attachment,\n        }\n        self.queue.put_nowait((\"log\", args))", "category": "Python"}, {"instruction": "def handle_not_found(exception, **extra):\n    \"\"\"Custom blueprint exception handler.\"\"\"\n", "input": "", "output": "    assert isinstance(exception, NotFound)\n\n    page = Page.query.filter(db.or_(Page.url == request.path,\n                                    Page.url == request.path + \"/\")).first()\n\n    if page:\n        _add_url_rule(page.url)\n        return render_template(\n            [\n                page.template_name,\n                current_app.config['PAGES_DEFAULT_TEMPLATE']\n            ],\n            page=page\n        )\n    elif 'wrapped' in extra:\n        return extra['wrapped'](exception)\n    else:\n        return exception", "category": "Python"}, {"instruction": "def subdirs(self, pattern=None, sort_key=lambda k: k, sort_reverse=False, abspath=False):\n        \"\"\" Return a sorted list containing relative path of all subdirs (recursively).\n\n        :type pattern: str\n        :param pattern: Unix style (glob like/gitignore like) pattern\n\n        :param sort_key: key argument for sorted\n\n        :param sort_reverse: reverse argument for sorted\n\n        :rtype: list\n        :return: List of all relative files paths.\n        \"\"\"\n", "input": "", "output": "        return sorted(self.itersubdirs(pattern, abspath=abspath), key=sort_key, reverse=sort_reverse)", "category": "Python"}, {"instruction": "def relative_ref(*parts):\n    \"\"\"\n    Create a reference builder with specified relative location.\n    using getter.relative_ref(\"some\", \"submodel\") to get a value with key\n    \"toto\" will gives reference.Relative(\"some\", \"submodel\", \"toto\")\n    \"\"\"\n", "input": "", "output": "\n    def relative_ref(_value, context, **_params):\n        return reference.Relative(*(parts + (context[\"key\"], )))\n\n    return relative_ref", "category": "Python"}, {"instruction": "def do_preferrep(self, line):\n        \"\"\"preferrep <member node> [member node ...] Add one or more preferred Member\n        Nodes to replication policy.\"\"\"\n", "input": "", "output": "        mns = self._split_args(line, 1, -1)\n        self._command_processor.get_session().get_replication_policy().add_preferred(\n            mns\n        )\n        self._print_info_if_verbose(\n            \"Set {} as preferred replication target(s)\".format(\", \".join(mns))\n        )", "category": "Python"}, {"instruction": "def visit_Import(self, node):\n        \"\"\" Register imported modules and usage symbols.  \"\"\"\n", "input": "", "output": "        for alias in node.names:\n            alias_name = tuple(alias.name.split('.'))\n            self.imports.add(alias_name[0])\n            if alias.asname:\n                self.symbols[alias.asname] = alias_name\n            else:\n                self.symbols[alias_name[0]] = alias_name[:1]\n            self.update = True\n        return None", "category": "Python"}, {"instruction": "def bind_socket(address, port):\n    \"\"\" Returns a socket bound on (address:port). \"\"\"\n", "input": "", "output": "\n    assert address\n    assert port\n    bindsocket = socket.socket()\n    try:\n        bindsocket.bind((address, port))\n    except socket.error:\n        logger.error(\"Couldn't bind socket on %s:%s\", address, port)\n        return None\n\n    logger.info('Listening on %s:%s', address, port)\n    bindsocket.listen(0)\n    return bindsocket", "category": "Python"}, {"instruction": "def replace_nulls(hdrs):\n        \"\"\"Replace '' in hdrs.\"\"\"\n", "input": "", "output": "        ret = []\n        idx = 0\n        for hdr in hdrs:\n            if hdr == '':\n                ret.append(\"no_hdr{}\".format(idx))\n            else:\n                ret.append(hdr)\n        return ret", "category": "Python"}, {"instruction": "def get_items(self):\n        \"\"\"This is out of spec, but required for adaptive assessment parts?\"\"\"\n", "input": "", "output": "        ils = get_item_lookup_session(runtime=self._runtime, proxy=self._proxy)\n        ils.use_federated_bank_view()\n        items = []\n        if self.has_items():\n            for idstr in self._my_map['itemIds']:\n                items.append(ils.get_item(Id(idstr)))\n        return ItemList(items, runtime=self._runtime, proxy=self._proxy)", "category": "Python"}, {"instruction": "def _is_leonardo_module(whatever):\n    '''check if is leonardo module'''\n", "input": "", "output": "\n    # check if is python module\n    if hasattr(whatever, 'default') \\\n            or hasattr(whatever, 'leonardo_module_conf'):\n        return True\n\n    # check if is python object\n    for key in dir(whatever):\n        if 'LEONARDO' in key:\n            return True", "category": "Python"}, {"instruction": "def clean(self):\n        \"\"\"\n        Automatically construct the suggestion input and weight by taking all\n        possible permutation of Person's name as ``input`` and taking their\n        popularity as ``weight``.\n        \"\"\"\n", "input": "", "output": "        self.suggest = {\n            'input': [' '.join(p) for p in permutations(self.name.split())],\n            'weight': self.popularity\n        }", "category": "Python"}, {"instruction": "def ecdsa_private_key(privkey_str=None, compressed=None):\n    \"\"\"\n    Make a private key, but enforce the following rule:\n    * unless the key's hex encoding specifically ends in '01', treat it as uncompressed.\n    \"\"\"\n", "input": "", "output": "    if compressed is None:\n        compressed = False\n        if privkey_str is not None:\n            if len(privkey_str) == 66 and privkey_str[-2:] == '01':\n                compressed = True\n\n    return _ECPrivateKey(privkey_str, compressed=compressed)", "category": "Python"}, {"instruction": "def _writeConnectivity(self, links, fileObject):\n        \"\"\"\n        Write Connectivity Lines to File Method\n        \"\"\"\n", "input": "", "output": "        for link in links:\n            linkNum = link.linkNumber\n            downLink = link.downstreamLinkID\n            numUpLinks = link.numUpstreamLinks\n            upLinks = ''\n            for upLink in link.upstreamLinks:\n                upLinks = '{}{:>5}'.format(upLinks, str(upLink.upstreamLinkID))\n\n            line = 'CONNECT{:>5}{:>5}{:>5}{}\\n'.format(linkNum, downLink, numUpLinks, upLinks)\n            fileObject.write(line)\n        fileObject.write('\\n')", "category": "Python"}, {"instruction": "def make_transparent(image):\n    \"\"\"Turn all black pixels in an image into transparent ones\"\"\"\n", "input": "", "output": "    data = image.copy().getdata()\n    modified = []\n    for item in data:\n        if _check_pixel(item) is True:\n            modified.append((255, 255, 255, 255))  # White transparent pixel\n            continue\n        modified.append(item)\n    image.putdata(modified)\n    return image", "category": "Python"}, {"instruction": "def cartesian_to_spherical(vectors):\n    \"\"\"\n    Return the spherical coordinates for coordinates in Cartesian space.\n\n    This function does an opposite to :func:`spherical_to_cartesian`.\n\n    :param vectors:\n        Array of 3d vectors in Cartesian space of shape (..., 3)\n    :returns:\n        Tuple of three arrays of the same shape as ``vectors`` representing\n        longitude (decimal degrees), latitude (decimal degrees) and depth (km)\n        in specified order.\n    \"\"\"\n", "input": "", "output": "    rr = numpy.sqrt(numpy.sum(vectors * vectors, axis=-1))\n    xx, yy, zz = vectors.T\n    lats = numpy.degrees(numpy.arcsin((zz / rr).clip(-1., 1.)))\n    lons = numpy.degrees(numpy.arctan2(yy, xx))\n    depths = EARTH_RADIUS - rr\n    return lons.T, lats.T, depths", "category": "Python"}, {"instruction": "def path_helper(self, operations, view, app=None, **kwargs):\n        \"\"\"Path helper that allows passing a Flask view function.\"\"\"\n", "input": "", "output": "        rule = self._rule_for_view(view, app=app)\n        operations.update(yaml_utils.load_operations_from_docstring(view.__doc__))\n        if hasattr(view, 'view_class') and issubclass(view.view_class, MethodView):\n            for method in view.methods:\n                if method in rule.methods:\n                    method_name = method.lower()\n                    method = getattr(view.view_class, method_name)\n                    operations[method_name] = yaml_utils.load_yaml_from_docstring(method.__doc__)\n        return self.flaskpath2openapi(rule.rule)", "category": "Python"}, {"instruction": "def from_parmed(cls, path, *args, **kwargs):\n        \"\"\"\n        Try to load a file automatically with ParmEd. Not guaranteed to work, but\n        might be useful if it succeeds.\n\n        Arguments\n        ---------\n        path : str\n            Path to file that ParmEd can load\n        \"\"\"\n", "input": "", "output": "        st = parmed.load_file(path, structure=True, *args, **kwargs)\n        box = kwargs.pop('box', getattr(st, 'box', None))\n        velocities = kwargs.pop('velocities', getattr(st, 'velocities', None))\n        positions = kwargs.pop('positions', getattr(st, 'positions', None))\n        return cls(master=st, topology=st.topology, positions=positions, box=box,\n                   velocities=velocities, path=path, **kwargs)", "category": "Python"}, {"instruction": "def from_tuples(cls, tups):\n        \"\"\"\n        Create a new IntervalTree from an iterable of 2- or 3-tuples,\n         where the tuple lists begin, end, and optionally data.\n        \"\"\"\n", "input": "", "output": "        ivs = [Interval(*t) for t in tups]\n        return IntervalTree(ivs)", "category": "Python"}, {"instruction": "def _get_line(self) -> str:\n        \"\"\"Returns the current line from the file while incrementing the index.\"\"\"\n", "input": "", "output": "        line = self.in_lines[self.index]\n        self.index += 1\n        return line", "category": "Python"}, {"instruction": "def get_user_info(apikey, username, password):\n    \"\"\"\n    blogger.getUserInfo(api_key, username, password)\n    => user structure\n    \"\"\"\n", "input": "", "output": "    user = authenticate(username, password)\n    site = Site.objects.get_current()\n    return user_structure(user, site)", "category": "Python"}, {"instruction": "def ignore_whitespace_text_nodes(cls, wrapped_node):\n        \"\"\"\n        Find and delete any text nodes containing nothing but whitespace in\n        in the given node and its descendents.\n\n        This is useful for cleaning up excess low-value text nodes in a\n        document DOM after parsing a pretty-printed XML document.\n        \"\"\"\n", "input": "", "output": "        for child in wrapped_node.children:\n            if child.is_text and child.value.strip() == '':\n                child.delete()\n            else:\n                cls.ignore_whitespace_text_nodes(child)", "category": "Python"}, {"instruction": "def _copy(self, other, copy_func):\n        \"\"\"\n        Copies the contents of another ParsableOctetString object to itself\n\n        :param object:\n            Another instance of the same class\n\n        :param copy_func:\n            An reference of copy.copy() or copy.deepcopy() to use when copying\n            lists, dicts and objects\n        \"\"\"\n", "input": "", "output": "\n        super(ParsableOctetString, self)._copy(other, copy_func)\n        self._bytes = other._bytes\n        self._parsed = copy_func(other._parsed)", "category": "Python"}, {"instruction": "def checksum(path, hashfunc='md5'):\n    \"\"\"\n    Return checksum given by path. Wildcards can be used in check sum. Function is strongly\n    dependent on checksumdir package by 'cakepietoast'.\n\n    :param path:\n    :param hashfunc:\n    :return:\n    \"\"\"\n", "input": "", "output": "    import checksumdir\n    hash_func = checksumdir.HASH_FUNCS.get(hashfunc)\n    if not hash_func:\n        raise NotImplementedError('{} not implemented.'.format(hashfunc))\n\n    if os.path.isdir(path):\n        return checksumdir.dirhash(path, hashfunc=hashfunc)\n\n    hashvalues = []\n    path_list = glob.glob(path)\n    logger.debug(\"path_list \" + str(path_list))\n    for path in path_list:\n        if os.path.isfile(path):\n            hashvalues.append(checksumdir._filehash(path, hashfunc=hash_func))\n    logger.debug(str(hashvalues))\n    hash = checksumdir._reduce_hash(hashvalues, hashfunc=hash_func)\n    return hash", "category": "Python"}, {"instruction": "def execute(self, **kwargs):\n    \"\"\" commit the current statements from add()\n    \"\"\"\n", "input": "", "output": "    assert self.resp is None, \"Transaction already committed\"\n    try:\n      self.resp = self.db.tx(list(self.edn_iter), **kwargs)\n    except Exception:\n      self.resp = False\n      raise\n    else:\n      self.resolve()\n      self.adds = None\n      self.tmpents = None\n    return self.resp", "category": "Python"}, {"instruction": "def delete_refs(repo, refs, dry_run=False):\n    \"\"\"Note that only the ref to a tag can be explicitly removed.  The tag\n    object will leave on until it's gargabe collected.\"\"\"\n", "input": "", "output": "\n    assert isinstance(repo, github.Repository.Repository), type(repo)\n\n    debug(\"removing {n} refs from {repo}\".format(\n        n=len(refs),\n        repo=repo.full_name)\n    )\n\n    for r in refs:\n        debug(\"  deleting {ref}\".format(ref=r.ref))\n        if dry_run:\n            debug('    (noop)')\n            continue\n\n        r.delete()", "category": "Python"}, {"instruction": "def parse_kv(args):\n    ''' convert a string of key/value items to a dict '''\n", "input": "", "output": "\n    options = {}\n    if args is not None:\n        # attempting to split a unicode here does bad things\n        vargs = shlex.split(str(args), posix=True)\n        for x in vargs:\n            if x.find(\"=\") != -1:\n                k, v = x.split(\"=\",1)\n                options[k]=v\n    return options", "category": "Python"}, {"instruction": "def get_content_type_charset(self, default='UTF-8'):\n\t\t\"\"\"\n\t\tInspect the Content-Type header to retrieve the charset that the client\n\t\thas specified.\n\n\t\t:param str default: The default charset to return if none exists.\n\t\t:return: The charset of the request.\n\t\t:rtype: str\n\t\t\"\"\"\n", "input": "", "output": "\t\tencoding = default\n\t\theader = self.headers.get('Content-Type', '')\n\t\tidx = header.find('charset=')\n\t\tif idx > 0:\n\t\t\tencoding = (header[idx + 8:].split(' ', 1)[0] or encoding)\n\t\treturn encoding", "category": "Python"}, {"instruction": "def is_whitelisted(self, addrinfo):\n        \"\"\"\n        Returns if a result of ``socket.getaddrinfo`` is in the socket address\n        whitelist.\n        \"\"\"\n", "input": "", "output": "        # For details about the ``getaddrinfo`` struct, see the Python docs:\n        # http://docs.python.org/library/socket.html#socket.getaddrinfo\n        family, socktype, proto, canonname, sockaddr = addrinfo\n        address, port = sockaddr[:2]\n        return address in self.socket_address_whitelist", "category": "Python"}, {"instruction": "def close(self, code=None):\n        '''return a `close` :class:`Frame`.\n        '''\n", "input": "", "output": "        code = code or 1000\n        body = pack('!H', code)\n        body += self._close_codes.get(code, '').encode('utf-8')\n        return self.encode(body, opcode=0x8)", "category": "Python"}, {"instruction": "def get_full_import_name(import_from, name):\n    \"\"\"Get the full path of a name from a ``from x import y`` statement.\n\n    :param import_from: The astroid node to resolve the name of.\n    :type import_from: astroid.nodes.ImportFrom\n    :param name:\n    :type name: str\n\n    :returns: The full import path of the name.\n    :rtype: str\n    \"\"\"\n", "input": "", "output": "    partial_basename = resolve_import_alias(name, import_from.names)\n\n    module_name = import_from.modname\n    if import_from.level:\n        module = import_from.root()\n        assert isinstance(module, astroid.nodes.Module)\n        module_name = module.relative_to_absolute_name(\n            import_from.modname, level=import_from.level\n        )\n\n    return \"{}.{}\".format(module_name, partial_basename)", "category": "Python"}, {"instruction": "def _pairwise_chisq(self):\n        \"\"\"Pairwise comparisons (Chi-Square) along axis, as numpy.ndarray.\n\n        Returns a list of square and symmetric matrices of test statistics for the null\n        hypothesis that each vector along *axis* is equal to each other.\n        \"\"\"\n", "input": "", "output": "        return [\n            self._chi_squared(\n                mr_subvar_proportions,\n                self._margin[idx],\n                self._opposite_axis_margin[idx]\n                / np.sum(self._opposite_axis_margin[idx]),\n            )\n            for (idx, mr_subvar_proportions) in enumerate(self._proportions)\n        ]", "category": "Python"}, {"instruction": "def show_version(a_device):\n    \"\"\"Execute show version command using Netmiko.\"\"\"\n", "input": "", "output": "    remote_conn = ConnectHandler(**a_device)\n    print()\n    print(\"#\" * 80)\n    print(remote_conn.send_command_expect(\"show version\"))\n    print(\"#\" * 80)\n    print()", "category": "Python"}, {"instruction": "def memoize(func):\n    '''\n    Memoize aka cache the return output of a function\n    given a specific set of arguments\n\n    .. versionedited:: 2016.3.4\n\n    Added **kwargs support.\n    '''\n", "input": "", "output": "    cache = {}\n\n    @wraps(func)\n    def _memoize(*args, **kwargs):\n        str_args = []\n        for arg in args:\n            if not isinstance(arg, six.string_types):\n                str_args.append(six.text_type(arg))\n            else:\n                str_args.append(arg)\n\n        args_ = ','.join(list(str_args) + ['{0}={1}'.format(k, kwargs[k]) for k in sorted(kwargs)])\n        if args_ not in cache:\n            cache[args_] = func(*args, **kwargs)\n        return cache[args_]\n\n    return _memoize", "category": "Python"}, {"instruction": "def get_vnetwork_dvpgs_input_vcenter(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n", "input": "", "output": "        config = ET.Element(\"config\")\n        get_vnetwork_dvpgs = ET.Element(\"get_vnetwork_dvpgs\")\n        config = get_vnetwork_dvpgs\n        input = ET.SubElement(get_vnetwork_dvpgs, \"input\")\n        vcenter = ET.SubElement(input, \"vcenter\")\n        vcenter.text = kwargs.pop('vcenter')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "category": "Python"}, {"instruction": "async def _wait(self):\n        '''\n        Wait on the other editatoms who are constructing nodes my new nodes refer to\n        '''\n", "input": "", "output": "        for buid in self.otherbldgbuids:\n            nodeevnt = self.allbldgbuids.get(buid)\n            if nodeevnt is None:\n                continue\n            await nodeevnt[1].wait()", "category": "Python"}, {"instruction": "def acquire_lock(self, name):\n        \"\"\"\n        Wait for a lock with name.\n        This will prevent other processes from acquiring the lock with\n        the name while it is held. Thus they will wait in the position\n        where they are acquiring the lock until the process that has it\n        releases it.\n        \"\"\"\n", "input": "", "output": "        if self._remotelib:\n            try:\n                while not self._remotelib.run_keyword('acquire_lock',\n                                                      [name, self._my_id], {}):\n                    time.sleep(0.1)\n                    logger.debug('waiting for lock to release')\n                return True\n            except RuntimeError:\n                logger.warn('no connection')\n                self.__remotelib = None\n        return _PabotLib.acquire_lock(self, name, self._my_id)", "category": "Python"}, {"instruction": "def proofMethods():\n    \"\"\"\n    Run the full protocol including proof generation and verification.\n    \"\"\"\n", "input": "", "output": "    r, x = blind(m)\n    y,kw,tTilde = eval(w,t,x,msk,s)\n\n    # Proof in Gt/Gt\n    pi = proveGt(x, tTilde, kw, y)\n    verifyGt(x, tTilde, y, pi, errorOnFail=True)\n\n    # Proof in G1/Gt\n    pi = proveG1(x, tTilde, kw, y)\n    verifyG1(x, tTilde, y, pi, errorOnFail=True)\n\n    z = deblind(r, y)", "category": "Python"}, {"instruction": "def format_rst(self):\n        \"\"\"\n        return table in RST format\n        \"\"\"\n", "input": "", "output": "        res = ''\n        num_cols = len(self.header)\n        col_width = 25\n        for _ in range(num_cols):\n            res += ''.join(['=' for _ in range(col_width - 1)]) + ' ' \n        res += '\\n'\n        for c in self.header:\n            res += c.ljust(col_width) \n        res += '\\n'\n        for _ in range(num_cols):\n            res += ''.join(['=' for _ in range(col_width - 1)]) + ' ' \n        res += '\\n'\n        for row in self.arr:\n            for c in row:\n                res += self.force_to_string(c).ljust(col_width)\n            res += '\\n' \n        for _ in range(num_cols):\n            res += ''.join(['=' for _ in range(col_width - 1)]) + ' ' \n        res += '\\n'\n        return res", "category": "Python"}, {"instruction": "def render_GET(self, request):\n    \"\"\"Renders a GET request, by showing this nodes stats and children.\"\"\"\n", "input": "", "output": "    fullPath = request.path.split('/')\n    if not fullPath[-1]:\n      fullPath = fullPath[:-1]\n    parts = fullPath[2:]\n    statDict = util.lookup(scales.getStats(), parts)\n\n    if statDict is None:\n      request.setResponseCode(404)\n      return \"Path not found.\"\n\n    if 'query' in request.args:\n      query = request.args['query'][0]\n    else:\n      query = None\n\n    if 'format' in request.args and request.args['format'][0] == 'json':\n      request.headers['content-type'] = 'text/javascript; charset=UTF-8'\n      formats.jsonFormat(request, statDict, query)\n    elif 'format' in request.args and request.args['format'][0] == 'prettyjson':\n      request.headers['content-type'] = 'text/javascript; charset=UTF-8'\n      formats.jsonFormat(request, statDict, query, pretty=True)\n    else:\n      formats.htmlHeader(request, '/' + '/'.join(parts), self.serverName, query)\n      formats.htmlFormat(request, tuple(parts), statDict, query)\n\n    return ''", "category": "Python"}, {"instruction": "def _docf(self, tag, val):\n        \"\"\"\n        Callback used as the handler argument to process_docs(). This converts\n        Stone doc references to Sphinx-friendly annotations.\n        \"\"\"\n", "input": "", "output": "        if tag == 'type':\n            return ':class:`{}`'.format(val)\n        elif tag == 'route':\n            if self.args.route_method:\n                return ':meth:`%s`' % self.args.route_method.format(\n                    ns=self.cur_namespace.name, route=fmt_func(val))\n            else:\n                return val\n        elif tag == 'link':\n            anchor, link = val.rsplit(' ', 1)\n            return '`{} <{}>`_'.format(anchor, link)\n        elif tag == 'val':\n            if val == 'null':\n                return 'None'\n            elif val == 'true' or val == 'false':\n                return '``{}``'.format(val.capitalize())\n            else:\n                return val\n        elif tag == 'field':\n            return '``{}``'.format(val)\n        else:\n            raise RuntimeError('Unknown doc ref tag %r' % tag)", "category": "Python"}, {"instruction": "def selection(self):\n        \"\"\"Returns items in selection as a QItemSelection object\"\"\"\n", "input": "", "output": "        sel = QtGui.QItemSelection()\n        for index in self.selectedIndexes():\n            sel.select(index, index)\n        return sel", "category": "Python"}, {"instruction": "def _load_data():\n    \"\"\"Load the word and character mapping data into a dictionary.\n\n    In the data files, each line is formatted like this:\n        HANZI   PINYIN_READING/PINYIN_READING\n\n    So, lines need to be split by '\\t' and then the Pinyin readings need to be\n    split by '/'.\n\n    \"\"\"\n", "input": "", "output": "    data = {}\n    for name, file_name in (('words', 'hanzi_pinyin_words.tsv'),\n                            ('characters', 'hanzi_pinyin_characters.tsv')):\n        # Split the lines by tabs: [[hanzi, pinyin]...].\n        lines = [line.split('\\t') for line in\n                 dragonmapper.data.load_data_file(file_name)]\n        # Make a dictionary: {hanzi: [pinyin, pinyin]...}.\n        data[name] = {hanzi: pinyin.split('/') for hanzi, pinyin in lines}\n    return data", "category": "Python"}, {"instruction": "def _output_ret(self, ret, out, retcode=0):\n        '''\n        Print the output from a single return to the terminal\n        '''\n", "input": "", "output": "        import salt.output\n        # Handle special case commands\n        if self.config['fun'] == 'sys.doc' and not isinstance(ret, Exception):\n            self._print_docs(ret)\n        else:\n            # Determine the proper output method and run it\n            salt.output.display_output(ret,\n                                       out=out,\n                                       opts=self.config,\n                                       _retcode=retcode)\n        if not ret:\n            sys.stderr.write('ERROR: No return received\\n')\n            sys.exit(2)", "category": "Python"}, {"instruction": "def update_jsonb(uid, extinfo):\n        '''\n        Update the json.\n        '''\n", "input": "", "output": "        cur_extinfo = MPost.get_by_uid(uid).extinfo\n        for key in extinfo:\n            cur_extinfo[key] = extinfo[key]\n        entry = TabPost.update(\n            extinfo=cur_extinfo,\n        ).where(TabPost.uid == uid)\n        entry.execute()\n        return uid", "category": "Python"}, {"instruction": "def send_request(endpoint, **kwargs):\n    \"\"\"Return the response to a query as JSON from the NewsAPI web service.\n\n    The basic API is limited to 100 results which is chosen unless explicitly\n    given as an argument. Beyond that, paging is supported through the \"page\"\n    argument, if needed.\n\n    Parameters\n    ----------\n    endpoint : str\n        Endpoint to query, e.g. \"everything\" or \"top-headlines\"\n\n    kwargs : dict\n        A list of keyword arguments passed as parameters with the query.\n        The basic ones are \"q\" which is the search query, \"from\" is a start\n        date formatted as for instance 2018-06-10 and \"to\" is an end date\n        with the same format.\n\n    Returns\n    -------\n    res_json : dict\n        The response from the web service as a JSON dict.\n    \"\"\"\n", "input": "", "output": "    if api_key is None:\n        logger.error('NewsAPI cannot be used without an API key')\n        return None\n    url = '%s/%s' % (newsapi_url, endpoint)\n    if 'apiKey' not in kwargs:\n        kwargs['apiKey'] = api_key\n    if 'pageSize' not in kwargs:\n        kwargs['pageSize'] = 100\n    res = requests.get(url, params=kwargs)\n    res.raise_for_status()\n    res_json = res.json() \n    return res_json", "category": "Python"}, {"instruction": "def set_size(self, size):\n        \"\"\"Set figure size\"\"\"\n", "input": "", "output": "        w, h = size\n        self.root.set('width', w)\n        self.root.set('height', h)", "category": "Python"}, {"instruction": "def max_len(iterable, minimum=0):\n    \"\"\"Return the len() of the longest item in ``iterable`` or ``minimum``.\n\n    >>> max_len(['spam', 'ham'])\n    4\n\n    >>> max_len([])\n    0\n\n    >>> max_len(['ham'], 4)\n    4\n    \"\"\"\n", "input": "", "output": "    try:\n        result = max(map(len, iterable))\n    except ValueError:\n        result = minimum\n    return minimum if result < minimum else result", "category": "Python"}, {"instruction": "def make_k8s_lando_router(config, obj, queue_name):\n        \"\"\"\n        Makes MessageRouter which can listen to queue_name sending messages to the k8s version of lando.\n        :param config: WorkerConfig/ServerConfig: settings for connecting to the queue\n        :param obj: object: implements lando specific methods\n        :param queue_name: str: name of the queue we will listen on.\n        :return MessageRouter\n        \"\"\"\n", "input": "", "output": "        return MessageRouter(config, obj, queue_name, K8S_LANDO_INCOMING_MESSAGES,\n                             processor_constructor=WorkQueueProcessor)", "category": "Python"}, {"instruction": "def dump(self, output, close_after_write=True):\n        \"\"\"Write a worksheet to the current workbook.\n\n        Args:\n            output (str):\n                Path to the workbook file to write.\n            close_after_write (bool, optional):\n                Close the workbook after write.\n                Defaults to |True|.\n        \"\"\"\n", "input": "", "output": "\n        self.open(output)\n        try:\n            self.make_worksheet(self.table_name)\n            self.write_table()\n        finally:\n            if close_after_write:\n                self.close()", "category": "Python"}, {"instruction": "def get_dataframe(self, *args, **kwargs):\n        \"\"\"\n        Retrieve data as a Pandas dataframe.\n\n        Args:\n            search: (dict) Search query like {\"categ_A\": \"val_A\", \"categ_B\": \"val_B\"},\n                documented at https://developer.mpds.io/#Categories\n            phases: (list) Phase IDs, according to the MPDS distinct phases concept\n            fields: (dict) Data of interest for C-, S-, and P-entries,\n                e.g. for phase diagrams: {'C': ['naxes', 'arity', 'shapes']},\n                documented at https://developer.mpds.io/#JSON-schemata\n            columns: (list) Column names for Pandas dataframe\n\n        Returns: (object) Pandas dataframe object containing the results\n        \"\"\"\n", "input": "", "output": "        columns = kwargs.get('columns')\n        if columns:\n            del kwargs['columns']\n        else:\n            columns = self.default_titles\n\n        return pd.DataFrame(self.get_data(*args, **kwargs), columns=columns)", "category": "Python"}, {"instruction": "def create_hparams():\n  \"\"\"Create hparams.\"\"\"\n", "input": "", "output": "  if FLAGS.use_tpu and \"tpu\" not in FLAGS.hparams_set:\n    tf.logging.warn(\"Not all hyperparameter sets work on TPU. \"\n                    \"Prefer hparams_sets with a '_tpu' suffix, \"\n                    \"e.g. transformer_tpu, if available for your model.\")\n  hparams_path = os.path.join(FLAGS.output_dir, \"hparams.json\")\n  return trainer_lib.create_hparams(FLAGS.hparams_set, FLAGS.hparams,\n                                    hparams_path=hparams_path)", "category": "Python"}, {"instruction": "def auth_approle(self, role_id, secret_id=None, mount_point='approle', use_token=True):\n        \"\"\"POST /auth/<mount_point>/login\n\n        :param role_id:\n        :type role_id:\n        :param secret_id:\n        :type secret_id:\n        :param mount_point:\n        :type mount_point:\n        :param use_token:\n        :type use_token:\n        :return:\n        :rtype:\n        \"\"\"\n", "input": "", "output": "        params = {\n            'role_id': role_id\n        }\n        if secret_id is not None:\n            params['secret_id'] = secret_id\n\n        return self.login('/v1/auth/{0}/login'.format(mount_point), json=params, use_token=use_token)", "category": "Python"}, {"instruction": "def update_metadata(self, scaling_group, metadata):\n        \"\"\"\n        Adds the given metadata dict to the existing metadata for the scaling\n        group.\n        \"\"\"\n", "input": "", "output": "        if not isinstance(scaling_group, ScalingGroup):\n            scaling_group = self.get(scaling_group)\n        curr_meta = scaling_group.metadata\n        curr_meta.update(metadata)\n        return self.update(scaling_group, metadata=curr_meta)", "category": "Python"}, {"instruction": "def mobility(sdat, tstart=None, tend=None):\n    \"\"\"Plates mobility.\n\n    Compute the ratio vsurf / vrms.\n\n    Args:\n        sdat (:class:`~stagpy.stagyydata.StagyyData`): a StagyyData instance.\n        tstart (float): time at which the computation should start. Use the\n            beginning of the time series data if set to None.\n        tend (float): time at which the computation should end. Use the\n            end of the time series data if set to None.\n    Returns:\n        tuple of :class:`numpy.array`: mobility and time arrays.\n    \"\"\"\n", "input": "", "output": "    tseries = sdat.tseries_between(tstart, tend)\n    steps = sdat.steps[tseries.index[0]:tseries.index[-1]]\n    time = []\n    mob = []\n    for step in steps.filter(rprof=True):\n        time.append(step.timeinfo['t'])\n        mob.append(step.rprof.iloc[-1].loc['vrms'] / step.timeinfo['vrms'])\n    return np.array(mob), np.array(time)", "category": "Python"}, {"instruction": "def get_as_list(self, tag_name):\n        \"\"\"\n        Return the value of a tag, making sure that it's a list.  Absent\n        tags are returned as an empty-list; single tags are returned as a\n        one-element list.\n\n        The returned list is a copy, and modifications do not affect the\n        original object.\n        \"\"\"\n", "input": "", "output": "        val = self.get(tag_name, [])\n        if isinstance(val, list):\n            return val[:]\n        else:\n            return [val]", "category": "Python"}, {"instruction": "def get_ip_info(ip: str, exceptions: bool=False, timeout: int=10) -> tuple:\n    \"\"\"\n    Returns (ip, country_code, host) tuple of the IP address.\n    :param ip: IP address\n    :param exceptions: Raise Exception or not\n    :param timeout: Timeout in seconds. Note that timeout only affects geo IP part, not getting host name.\n    :return: (ip, country_code, host)\n    \"\"\"\n", "input": "", "output": "    import traceback\n    import socket\n    if not ip:  # localhost\n        return None, '', ''\n    host = ''\n    country_code = get_geo_ip(ip, exceptions=exceptions, timeout=timeout).get('country_code', '')\n    try:\n        res = socket.gethostbyaddr(ip)\n        host = res[0][:255] if ip else ''\n    except Exception as e:\n        msg = 'socket.gethostbyaddr({}) failed: {}'.format(ip, traceback.format_exc())\n        logger.error(msg)\n        if exceptions:\n            raise e\n    return ip, country_code, host", "category": "Python"}, {"instruction": "def get_scraperclasses():\n    \"\"\"Find all comic scraper classes in the plugins directory.\n    The result is cached.\n    @return: list of Scraper classes\n    @rtype: list of Scraper\n    \"\"\"\n", "input": "", "output": "    global _scraperclasses\n    if _scraperclasses is None:\n        out.debug(u\"Loading comic modules...\")\n        modules = loader.get_modules('plugins')\n        plugins = loader.get_plugins(modules, Scraper)\n        _scraperclasses = list(plugins)\n        check_scrapers()\n        out.debug(u\"... %d modules loaded.\" % len(_scraperclasses))\n    return _scraperclasses", "category": "Python"}, {"instruction": "def timestamp_file():\n    \"\"\"Opens a file for tracking the time of the last version check\"\"\"\n", "input": "", "output": "    config_dir = os.path.join(\n        os.path.expanduser(\"~\"), BaseGlobalConfig.config_local_dir\n    )\n\n    if not os.path.exists(config_dir):\n        os.mkdir(config_dir)\n\n    timestamp_file = os.path.join(config_dir, \"cumulus_timestamp\")\n\n    try:\n        with open(timestamp_file, \"r+\") as f:\n            yield f\n    except IOError:  # file does not exist\n        with open(timestamp_file, \"w+\") as f:\n            yield f", "category": "Python"}, {"instruction": "def _maxlength(X):\n    \"\"\" Returns the maximum length of signal trajectories X \"\"\"\n", "input": "", "output": "    N = 0\n    for x in X:\n        if len(x) > N:\n            N = len(x)\n    return N", "category": "Python"}, {"instruction": "def _prune_invalid_time_reductions(spec):\n    \"\"\"Prune time reductions of spec with no time dimension.\"\"\"\n", "input": "", "output": "    valid_reductions = []\n    if not spec['var'].def_time and spec['dtype_out_time'] is not None:\n        for reduction in spec['dtype_out_time']:\n            if reduction not in _TIME_DEFINED_REDUCTIONS:\n                valid_reductions.append(reduction)\n            else:\n                msg = (\"Var {0} has no time dimension \"\n                       \"for the given time reduction \"\n                       \"{1} so this calculation will \"\n                       \"be skipped\".format(spec['var'].name, reduction))\n                logging.info(msg)\n    else:\n        valid_reductions = spec['dtype_out_time']\n    return valid_reductions", "category": "Python"}, {"instruction": "async def power(source, exponent):\n    \"\"\"Raise the elements of an asynchronous sequence to the given power.\"\"\"\n", "input": "", "output": "    async with streamcontext(source) as streamer:\n        async for item in streamer:\n            yield item ** exponent", "category": "Python"}, {"instruction": "def _Rzderiv(self,R,z,phi=0.,t=0.):\n        \"\"\"\n        NAME:\n           _Rzderiv\n        PURPOSE:\n           evaluate the mixed radial, vertical derivative for this potential\n        INPUT:\n           R - Galactocentric cylindrical radius\n           z - vertical height\n           phi - azimuth\n           t - time\n        OUTPUT:\n           the mixed radial, vertical derivative\n        \"\"\"\n", "input": "", "output": "        if not self.isNonAxi:\n            phi= 0.\n        x,y,z= self._compute_xyz(R,phi,z,t)\n        phixza= self._2ndderiv_xyz(x,y,z,0,2)\n        phiyza= self._2ndderiv_xyz(x,y,z,1,2)\n        ang = self._omegab*t + self._pa\n        c, s = np.cos(ang), np.sin(ang)\n        phixz = c*phixza + s*phiyza\n        phiyz = -s*phixza + c*phiyza\n        return np.cos(phi)*phixz + np.sin(phi)*phiyz", "category": "Python"}, {"instruction": "def clear_context(self, app=None):\n        \"\"\"Clear the component's context.\n\n        Keyword Args:\n            app (flask.Flask, optional): The app to clear this component's\n                context for. If omitted, the value from ``Component.app`` is\n                used.\n        \"\"\"\n", "input": "", "output": "        if (app is None and self._context is _CONTEXT_MISSING\n                and not in_app_context()):\n            raise RuntimeError(\"Attempted to clear component context without\"\n                               \" a bound app context or eager app set! Please\"\n                               \" pass the related app you want to update the\"\n                               \" context for!\")\n\n        if self._context is not _CONTEXT_MISSING:\n            self._context = DEFAULT_DICT\n        else:\n            key = self._get_context_name(app=app)\n            setattr(_CONTEXT_LOCALS, key, DEFAULT_DICT)", "category": "Python"}, {"instruction": "def package(self):\n        \"\"\"Copy Flatbuffers' artifacts to package folder\n        \"\"\"\n", "input": "", "output": "        cmake = self.configure_cmake()\n        cmake.install()\n        self.copy(pattern=\"LICENSE.txt\", dst=\"licenses\")\n        self.copy(pattern=\"FindFlatBuffers.cmake\", dst=os.path.join(\"lib\", \"cmake\", \"flatbuffers\"), src=\"CMake\")\n        self.copy(pattern=\"flathash*\", dst=\"bin\", src=\"bin\")\n        self.copy(pattern=\"flatc*\", dst=\"bin\", src=\"bin\")\n        if self.settings.os == \"Windows\" and self.options.shared:\n            if self.settings.compiler == \"Visual Studio\":\n                shutil.move(os.path.join(self.package_folder, \"lib\", \"%s.dll\" % self.name),\n                            os.path.join(self.package_folder, \"bin\", \"%s.dll\" % self.name))\n            elif self.settings.compiler == \"gcc\":\n                shutil.move(os.path.join(self.package_folder, \"lib\", \"lib%s.dll\" % self.name),\n                            os.path.join(self.package_folder, \"bin\", \"lib%s.dll\" % self.name))", "category": "Python"}, {"instruction": "def _load_config(self):\n        \"\"\"\n        Loads the YAML configuration file and sets python dictionary and raw contents\n        as instance attrs.\n        \"\"\"\n", "input": "", "output": "        if not os.path.exists(self._path):\n            sys.exit(\"Config path %s does not exist\" % self._path)\n        # create empty config object\n        self._config_dict = {}\n        # read file and marshal yaml\n        with open(self._path, 'r') as f:\n            self._raw = f.read()\n            self._config_dict = yaml.load(self._raw)", "category": "Python"}, {"instruction": "def get_content_from_url(self, base_url):\n        \"\"\"\n        Sections can have SectionPage and ArticlePage child objects.\n        These have different fields, and thus have to be treated\n        differently.\n        \"\"\"\n", "input": "", "output": "        # assemble url\n        base_url = base_url.rstrip(\"/\")\n        url = base_url + API_PAGES_ENDPOINT + \"?type=\" + self._content_type + \\\n            \"&fields=\" + \",\".join(self._fields) + \\\n            \"&order=latest_revision_created_at\"\n\n        # make request\n        try:\n            response = requests.get(url)\n            self._base_url = base_url\n            self._content = response.json()\n            self._content = self._content[\"items\"]\n            return self._content\n        except requests.exceptions.ConnectionError:\n            return \"No content could be found from {}. \" \\\n                \"Are you sure this is the correct URL?\".format(base_url)\n        except requests.exceptions.RequestException:\n            return \"Content could not be imported at this time. \" \\\n                   \"Please try again later.\"", "category": "Python"}, {"instruction": "def _get_s3_key():\n    '''\n    Get AWS keys from pillar or config\n    '''\n", "input": "", "output": "\n    key = __opts__['s3.key'] if 's3.key' in __opts__ else None\n    keyid = __opts__['s3.keyid'] if 's3.keyid' in __opts__ else None\n    service_url = __opts__['s3.service_url'] \\\n        if 's3.service_url' in __opts__ \\\n        else None\n    verify_ssl = __opts__['s3.verify_ssl'] \\\n        if 's3.verify_ssl' in __opts__ \\\n        else None\n    kms_keyid = __opts__['aws.kmw.keyid'] if 'aws.kms.keyid' in __opts__ else None\n    location = __opts__['s3.location'] \\\n        if 's3.location' in __opts__ \\\n        else None\n    path_style = __opts__['s3.path_style'] \\\n        if 's3.path_style' in __opts__ \\\n        else None\n    https_enable = __opts__['s3.https_enable'] \\\n        if 's3.https_enable' in __opts__ \\\n        else None\n\n    return key, keyid, service_url, verify_ssl, kms_keyid, location, path_style, https_enable", "category": "Python"}, {"instruction": "def set_unavailable(self):\n        \"\"\"Sets the agent availability to False.\"\"\"\n", "input": "", "output": "        show = PresenceShow.NONE\n        self.set_presence(PresenceState(available=False, show=show))", "category": "Python"}, {"instruction": "def transcript_sequence(self, transcript_id):\n        \"\"\"Return cDNA nucleotide sequence of transcript, or None if\n        transcript doesn't have cDNA sequence.\n        \"\"\"\n", "input": "", "output": "        if self.transcript_sequences is None:\n            raise ValueError(\n                \"No transcript FASTA supplied to this Genome: %s\" % self)\n        return self.transcript_sequences.get(transcript_id)", "category": "Python"}, {"instruction": "def delete(self, object_id):\n        \"\"\"\n        Delete an object by its id\n\n        :param object_id: the objects id.\n        :return: the deleted object\n        :raises: :class: NoResultFound when the object could not be found\n        \"\"\"\n", "input": "", "output": "        obj = self.session.query(self.cls).filter_by(id=object_id).one()\n        self.session.delete(obj)\n        return obj", "category": "Python"}, {"instruction": "def newFile(self, *path):\n        \"\"\"\n        Open a new file somewhere in this Store's file area.\n\n        @param path: a sequence of path segments.\n\n        @return: an L{AtomicFile}.\n        \"\"\"\n", "input": "", "output": "        assert len(path) > 0, \"newFile requires a nonzero number of segments\"\n        if self.dbdir is None:\n            if self.filesdir is None:\n                raise RuntimeError(\"This in-memory store has no file directory\")\n            else:\n                tmpbase = self.filesdir\n        else:\n            tmpbase = self.dbdir\n        tmpname = tmpbase.child('temp').child(str(tempCounter.next()) + \".tmp\")\n        return AtomicFile(tmpname.path, self.newFilePath(*path))", "category": "Python"}, {"instruction": "def cancelMarketDepth(self, contracts=None):\n        \"\"\"\n        Cancel streaming market data for contract\n        https://www.interactivebrokers.com/en/software/api/apiguide/java/cancelmktdepth.htm\n        \"\"\"\n", "input": "", "output": "        if contracts == None:\n            contracts = list(self.contracts.values())\n        elif not isinstance(contracts, list):\n            contracts = [contracts]\n\n        for contract in contracts:\n            tickerId = self.tickerId(self.contractString(contract))\n            self.ibConn.cancelMktDepth(tickerId=tickerId)", "category": "Python"}, {"instruction": "def _pval_from_bootci(boot, estimate):\n    \"\"\"Compute p-value from bootstrap distribution.\n    Similar to the pval function in the R package mediation.\n    Note that this is less accurate than a permutation test because the\n    bootstrap distribution is not conditioned on a true null hypothesis.\n    \"\"\"\n", "input": "", "output": "    if estimate == 0:\n        out = 1\n    else:\n        out = 2 * min(sum(boot > 0), sum(boot < 0)) / len(boot)\n    return min(out, 1)", "category": "Python"}, {"instruction": "def post_login(self, came_from=lurl('/')):\n        \"\"\"\n        Redirect the user to the initially requested page on successful\n        authentication or redirect her back to the login page if login failed.\n\n        \"\"\"\n", "input": "", "output": "        if not request.identity:\n            login_counter = request.environ.get('repoze.who.logins', 0) + 1\n            redirect('/login',\n                params=dict(came_from=came_from, __logins=login_counter))\n        userid = request.identity['repoze.who.userid']\n        flash(_('Welcome back, %s!') % userid)\n        redirect(came_from)", "category": "Python"}, {"instruction": "def fill_auth_list_from_groups(self, auth_provider, user_groups, auth_list):\n        '''\n        Returns a list of authorisation matchers that a user is eligible for.\n        This list is a combination of the provided personal matchers plus the\n        matchers of any group the user is in.\n        '''\n", "input": "", "output": "        group_names = [item for item in auth_provider if item.endswith('%')]\n        if group_names:\n            for group_name in group_names:\n                if group_name.rstrip(\"%\") in user_groups:\n                    for matcher in auth_provider[group_name]:\n                        auth_list.append(matcher)\n        return auth_list", "category": "Python"}, {"instruction": "def get(self,table, sys_id):\n        \"\"\"\n        get a single record by table name and sys_id\n        returns a dict (the json map) for python 3.4\n        \"\"\"\n", "input": "", "output": "        result = self.table_api_get(table, sys_id)\n        return self.to_record(result, table)", "category": "Python"}, {"instruction": "def sky2vec(cls, sky):\n        \"\"\"\n        Convert sky positions in to 3d-vectors on the unit sphere.\n\n        Parameters\n        ----------\n        sky : numpy.array\n            Sky coordinates as an array of (ra,dec)\n\n        Returns\n        -------\n        vec : numpy.array\n            Unit vectors as an array of (x,y,z)\n\n        See Also\n        --------\n        :func:`AegeanTools.regions.Region.vec2sky`\n        \"\"\"\n", "input": "", "output": "        theta_phi = cls.sky2ang(sky)\n        theta, phi = map(np.array, list(zip(*theta_phi)))\n        vec = hp.ang2vec(theta, phi)\n        return vec", "category": "Python"}, {"instruction": "def _full_diff(merge_result, key, context_lines=3):\n    \"\"\"Generate a full diff based on a Weave merge result\"\"\"\n", "input": "", "output": "    header_printed = False\n    for group in _split_diff(merge_result, context_lines=context_lines):\n        if not header_printed:\n            header_printed = True\n            yield color.Header('diff a/%s b/%s' % (key, key))\n            yield color.DeletedHeader('--- %s' % key)\n            yield color.AddedHeader('+++ %s' % key)\n\n        for l in _diff_group(group):\n            yield l", "category": "Python"}, {"instruction": "def request_type(self):\n        \"\"\"Retrieve the type of the request, by fetching it from\n        `xenon.proto.xenon_pb2`.\"\"\"\n", "input": "", "output": "        if self.static and not self.uses_request:\n            return getattr(xenon_pb2, 'Empty')\n\n        if not self.uses_request:\n            return None\n\n        return getattr(xenon_pb2, self.request_name)", "category": "Python"}, {"instruction": "def get_mapping_variable(variable_name, variables_mapping):\n    \"\"\" get variable from variables_mapping.\n\n    Args:\n        variable_name (str): variable name\n        variables_mapping (dict): variables mapping\n\n    Returns:\n        mapping variable value.\n\n    Raises:\n        exceptions.VariableNotFound: variable is not found.\n\n    \"\"\"\n", "input": "", "output": "    try:\n        return variables_mapping[variable_name]\n    except KeyError:\n        raise exceptions.VariableNotFound(\"{} is not found.\".format(variable_name))", "category": "Python"}, {"instruction": "def rgb(color,default=(0,0,0)):\n    \"\"\" return rgb tuple for named color in rgb.txt or a hex color \"\"\"\n", "input": "", "output": "    c = color.lower()\n    if c[0:1] == '#' and len(c)==7:\n        r,g,b = c[1:3], c[3:5], c[5:]\n        r,g,b = [int(n, 16) for n in (r, g, b)]\n        return (r,g,b)\n\n    if c.find(' ')>-1:    c = c.replace(' ','')\n    if c.find('gray')>-1: c = c.replace('gray','grey')\n    if c in x11_colors.keys():  return x11_colors[c]\n    return default", "category": "Python"}, {"instruction": "def init_widget(self):\n        \"\"\" Initialize the underlying widget.\n\n        \"\"\"\n", "input": "", "output": "        super(AndroidTextureView, self).__init__(self)\n        w = self.widget\n        w.setSurfaceTextureListener(w.getId())\n        w.onSurfaceTextureAvailable.connect(self.on_surface_texture_available)\n        w.onSurfaceTextureDestroyed.connect(self.on_surface_texture_destroyed)\n        w.onSurfaceTextureChanged.connect(self.on_surface_texture_changed)\n        w.onSurfaceTextureUpdated.connect(self.on_surface_texture_updated)", "category": "Python"}, {"instruction": "def show_run(command_history_id):\n    \"\"\"\n    Show detailed command history by its ID.\n    \"\"\"\n", "input": "", "output": "    from pprint import pprint\n    from .config import ConfigStore\n    from .database import DataBase\n    db = DataBase(ConfigStore().db_path)\n    with db.connection():\n        for ch_id in command_history_id:\n            crec = db.get_full_command_record(ch_id)\n            pprint(crec.__dict__)\n            print(\"\")", "category": "Python"}, {"instruction": "def find_project_file(start_dir, basename):\n    '''Walk up the directory tree until we find a file of the given name.'''\n", "input": "", "output": "    prefix = os.path.abspath(start_dir)\n    while True:\n        candidate = os.path.join(prefix, basename)\n        if os.path.isfile(candidate):\n            return candidate\n        if os.path.exists(candidate):\n            raise PrintableError(\n                \"Found {}, but it's not a file.\".format(candidate))\n        if os.path.dirname(prefix) == prefix:\n            # We've walked all the way to the top. Bail.\n            raise PrintableError(\"Can't find \" + basename)\n        # Not found at this level. We must go...shallower.\n        prefix = os.path.dirname(prefix)", "category": "Python"}, {"instruction": "def n_sections(neurites, neurite_type=NeuriteType.all, iterator_type=Tree.ipreorder):\n    '''Number of sections in a collection of neurites'''\n", "input": "", "output": "    return sum(1 for _ in iter_sections(neurites,\n                                        iterator_type=iterator_type,\n                                        neurite_filter=is_type(neurite_type)))", "category": "Python"}, {"instruction": "def _join_signals(self):\n        r\"\"\"Join N 1D signals into one N-dimensional signal.\"\"\"\n", "input": "", "output": "        joined = dict()\n        for name in self.signals:\n            name_base = name.rsplit('_', 1)[0]\n            names = joined.get(name_base, list())\n            names.append(name)\n            joined[name_base] = names\n        for name_base, names in joined.items():\n            if len(names) > 1:\n                names = sorted(names)  # ensure dim ordering (_0, _1, etc.)\n                signal_nd = np.stack([self.signals[n] for n in names], axis=1)\n                self.signals[name_base] = signal_nd\n                for name in names:\n                    del self.signals[name]", "category": "Python"}, {"instruction": "def setPrefilter(self, edfsignal, prefilter):\n        \"\"\"\n        Sets the prefilter of signal edfsignal (\"HP:0.1Hz\", \"LP:75Hz N:50Hz\", etc.)\n\n        :param edfsignal: int\n        :param prefilter: str\n\n        Notes\n        -----\n        This function is optional for every signal and can be called only after opening a file in writemode and before the first sample write action.\n        \"\"\"\n", "input": "", "output": "        if edfsignal < 0 or edfsignal > self.n_channels:\n            raise ChannelDoesNotExist(edfsignal)\n        self.channels[edfsignal]['prefilter'] = prefilter\n        self.update_header()", "category": "Python"}, {"instruction": "def initialize_request(self, request, *args, **kwargs):\n        \"\"\"\n        Returns the initial request object.\n        \"\"\"\n", "input": "", "output": "        parser_context = self.get_parser_context(request)\n\n        return Request(\n            request,\n            parsers=self.get_parsers(),\n            authenticators=self.get_authenticators(),\n            negotiator=self.get_content_negotiator(),\n            parser_context=parser_context\n        )", "category": "Python"}, {"instruction": "def mask(args):\n    \"\"\"\n    %prog mask fastafile\n\n    Mask the contaminants. By default, this will compare against UniVec_Core and\n    Ecoli.fasta. Merge the contaminant results, and use `maskFastaFromBed`. Can\n    perform FASTA tidy if requested.\n    \"\"\"\n", "input": "", "output": "    p = OptionParser(mask.__doc__)\n    p.add_option(\"--db\",\n                 help=\"Contaminant db other than Ecoli K12 [default: %default]\")\n    opts, args = p.parse_args(args)\n\n    if len(args) != 1:\n        sys.exit(not p.print_help())\n\n    fastafile, = args\n    assert op.exists(fastafile)\n\n    outfastafile = fastafile.rsplit(\".\", 1)[0] + \".masked.fasta\"\n    vecbedfile = blast([fastafile])\n    ecoliurl = \\\n    \"ftp://ftp.ncbi.nih.gov/genomes/Bacteria/Escherichia_coli_K_12_substr__DH10B_uid58979/NC_010473.fna\"\n    ecolifile = opts.db or download(ecoliurl, filename=\"Ecoli.fasta\")\n    assert op.exists(ecolifile)\n    ecolibedfile = blast([fastafile, \"--db={0}\".format(ecolifile)])\n\n    cmd = \"cat {0} {1}\".format(vecbedfile, ecolibedfile)\n    cmd += \" | mergeBed -nms -d 100 -i stdin\"\n    cmd += \" | maskFastaFromBed -fi {0} -bed stdin -fo {1}\".\\\n            format(fastafile, outfastafile)\n    sh(cmd)\n\n    return tidy([outfastafile])", "category": "Python"}, {"instruction": "def get_debug_option(packagename):\n    \"\"\" Determines if the build is in debug mode.\n\n    Returns\n    -------\n    debug : bool\n        True if the current build was started with the debug option, False\n        otherwise.\n\n    \"\"\"\n", "input": "", "output": "\n    try:\n        current_debug = get_pkg_version_module(packagename,\n                                               fromlist=['debug'])[0]\n    except (ImportError, AttributeError):\n        current_debug = None\n\n    # Only modify the debug flag if one of the build commands was explicitly\n    # run (i.e. not as a sub-command of something else)\n    dist = get_dummy_distribution()\n    if any(cmd in dist.commands for cmd in ['build', 'build_ext']):\n        debug = bool(get_distutils_build_option('debug'))\n    else:\n        debug = bool(current_debug)\n\n    if current_debug is not None and current_debug != debug:\n        build_ext_cmd = dist.get_command_class('build_ext')\n        build_ext_cmd._force_rebuild = True\n\n    return debug", "category": "Python"}, {"instruction": "def as_blocks(self, copy=True):\n        \"\"\"\n        Convert the frame to a dict of dtype -> Constructor Types that each has\n        a homogeneous dtype.\n\n        .. deprecated:: 0.21.0\n\n        NOTE: the dtypes of the blocks WILL BE PRESERVED HERE (unlike in\n              as_matrix)\n\n        Parameters\n        ----------\n        copy : boolean, default True\n\n        Returns\n        -------\n        values : a dict of dtype -> Constructor Types\n        \"\"\"\n", "input": "", "output": "        warnings.warn(\"as_blocks is deprecated and will \"\n                      \"be removed in a future version\",\n                      FutureWarning, stacklevel=2)\n        return self._to_dict_of_blocks(copy=copy)", "category": "Python"}, {"instruction": "def initialize(self, store):\r\n        \"\"\"Common initialization of handlers happens here. If additional\r\n        initialization is required, this method must either be called with\r\n        ``super`` or the child class must assign the ``store`` attribute and\r\n        register itself with the store.\r\n\r\n        \"\"\"\n", "input": "", "output": "        assert isinstance(store, stores.BaseStore)\r\n        self.messages = Queue()\r\n        self.store = store\r\n        self.store.register(self)", "category": "Python"}, {"instruction": "def set_settings(self, releases=None, default_release=None):\n        \"\"\"set path to storage\"\"\"\n", "input": "", "output": "        super(ReplicaSets, self).set_settings(releases, default_release)\n        Servers().set_settings(releases, default_release)", "category": "Python"}, {"instruction": "def get_element_centroids(self):\n        \"\"\"return the central points of all elements\n\n        Returns\n        -------\n        Nx2 array\n            x/z coordinates for all (N) elements\n        \"\"\"\n", "input": "", "output": "        centroids = np.vstack((\n            np.mean(self.grid['x'], axis=1), np.mean(self.grid['z'], axis=1)\n        )).T\n\n        return centroids", "category": "Python"}, {"instruction": "def run(self, *args):\n        \"\"\"Add an identity to the registry.\"\"\"\n", "input": "", "output": "\n        params = self.parser.parse_args(args)\n\n        code = self.add(params.source, params.email, params.name, params.username,\n                        params.uuid, params.matching, params.interactive)\n\n        return code", "category": "Python"}, {"instruction": "def mysql_aes_encrypt(val, key):\n    \"\"\"Mysql AES encrypt value with secret key.\n\n    :param val: Plain text value.\n    :param key: The AES key.\n    :returns: The encrypted AES value.\n    \"\"\"\n", "input": "", "output": "    assert isinstance(val, binary_type) or isinstance(val, text_type)\n    assert isinstance(key, binary_type) or isinstance(key, text_type)\n    k = _mysql_aes_key(_to_binary(key))\n    v = _mysql_aes_pad(_to_binary(val))\n    e = _mysql_aes_engine(k).encryptor()\n\n    return e.update(v) + e.finalize()", "category": "Python"}, {"instruction": "def update_distant_reference(self, ref):\n        \"\"\"Validate and update the reference in Zotero.\n\n        Existing fields not present will be left unmodified.\n        \"\"\"\n", "input": "", "output": "        self.validate_reference_data(ref[\"data\"])\n        self._zotero_lib.update_item(ref)", "category": "Python"}, {"instruction": "def populate(self, obj=None, section=None, parse_types=True):\n        \"\"\"Set attributes in ``obj`` with ``setattr`` from the all values in\n        ``section``.\n\n        \"\"\"\n", "input": "", "output": "        section = self.default_section if section is None else section\n        obj = Settings() if obj is None else obj\n        is_dict = isinstance(obj, dict)\n        for k, v in self.get_options(section).items():\n            if parse_types:\n                if v == 'None':\n                    v = None\n                elif self.FLOAT_REGEXP.match(v):\n                    v = float(v)\n                elif self.INT_REGEXP.match(v):\n                    v = int(v)\n                elif self.BOOL_REGEXP.match(v):\n                    v = v == 'True'\n                else:\n                    m = self.EVAL_REGEXP.match(v)\n                    if m:\n                        evalstr = m.group(1)\n                        v = eval(evalstr)\n            logger.debug('setting {} => {} on {}'.format(k, v, obj))\n            if is_dict:\n                obj[k] = v\n            else:\n                setattr(obj, k, v)\n        return obj", "category": "Python"}, {"instruction": "def to_pixel(self, wcs, mode='all'):\n        \"\"\"\n        Convert the aperture to a `RectangularAnnulus` object defined in\n        pixel coordinates.\n\n        Parameters\n        ----------\n        wcs : `~astropy.wcs.WCS`\n            The world coordinate system (WCS) transformation to use.\n\n        mode : {'all', 'wcs'}, optional\n            Whether to do the transformation including distortions\n            (``'all'``; default) or only including only the core WCS\n            transformation (``'wcs'``).\n\n        Returns\n        -------\n        aperture : `RectangularAnnulus` object\n            A `RectangularAnnulus` object.\n        \"\"\"\n", "input": "", "output": "\n        pixel_params = self._to_pixel_params(wcs, mode=mode)\n        return RectangularAnnulus(**pixel_params)", "category": "Python"}, {"instruction": "def wavefunction(self) -> pyquil.Wavefunction:\n        \"\"\"\n        Return the wavefunction of a completed program.\n        \"\"\"\n", "input": "", "output": "        assert self.status == 'done'\n        assert self._ket is not None\n        wavefn = state_to_wavefunction(self._ket)\n        return wavefn", "category": "Python"}, {"instruction": "def hasChannelType(self, chan):\n        \"\"\"Returns True if chan is among the supported channel types.\n        \n        @param app: Module name.\n        @return:    Boolean \n        \n        \"\"\"\n", "input": "", "output": "        if self._chantypes is None:\n            self._initChannelTypesList()\n        return chan in self._chantypes", "category": "Python"}, {"instruction": "def\tpurge_url(self, host, path):\n\t\t\"\"\"Purge an individual URL.\"\"\"\n", "input": "", "output": "\t\tcontent = self._fetch(path, method=\"PURGE\", headers={ \"Host\": host }) \n\t\treturn FastlyPurge(self, content)", "category": "Python"}, {"instruction": "def match_string(self, stype):\n        \"\"\"Match string type.\"\"\"\n", "input": "", "output": "\n        return not (stype - self.string_types) or bool(stype & self.wild_string_types)", "category": "Python"}, {"instruction": "def ChargeColorMapping(maptype='jet', reverse=False):\n    \"\"\"Maps amino-acid charge at neutral pH to colors. \n    Currently does not use the keyword arguments for *maptype*\n    or *reverse* but accepts these arguments to be consistent\n    with KyteDoolittleColorMapping and MWColorMapping for now.\"\"\"\n", "input": "", "output": "\n    pos_color = '#FF0000'\n    neg_color = '#0000FF'\n    neut_color = '#000000'\n\n    mapping_d = {'A':neut_color,'R':pos_color,'N':neut_color,\\\n                 'D':neg_color,'C':neut_color,'Q':neut_color,\\\n                 'E':neg_color,'G':neut_color,'H':pos_color,\\\n                 'I':neut_color,'L':neut_color,'K':pos_color,\\\n                 'M':neut_color,'F':neut_color,'P':neut_color,\\\n                 'S':neut_color,'T':neut_color,'W':neut_color,\\\n                 'Y':neut_color,'V':neut_color}\n\n    return (None, mapping_d, None)", "category": "Python"}, {"instruction": "def pprint(obj, *args, **kwargs):\n    \"\"\"Pretty-printing function that can pretty-print OrderedDicts\n    like regular dictionaries. Useful for printing the output of\n    :meth:`marshmallow.Schema.dump`.\n    \"\"\"\n", "input": "", "output": "    if isinstance(obj, collections.OrderedDict):\n        print(json.dumps(obj, *args, **kwargs))\n    else:\n        py_pprint(obj, *args, **kwargs)", "category": "Python"}, {"instruction": "def get_athlete_stats(self, athlete_id=None):\n        \"\"\"\n        Returns Statistics for the athlete.\n        athlete_id must be the id of the authenticated athlete or left blank.\n        If it is left blank two requests will be made - first to get the\n        authenticated athlete's id and second to get the Stats.\n\n        http://strava.github.io/api/v3/athlete/#stats\n\n        :return: A model containing the Stats\n        :rtype: :py:class:`stravalib.model.AthleteStats`\n        \"\"\"\n", "input": "", "output": "        if athlete_id is None:\n            athlete_id = self.get_athlete().id\n\n        raw = self.protocol.get('/athletes/{id}/stats', id=athlete_id)\n        # TODO: Better error handling - this will return a 401 if this athlete\n        #       is not the authenticated athlete.\n\n        return model.AthleteStats.deserialize(raw)", "category": "Python"}, {"instruction": "def disassemble_string(self, lpAddress, code):\n        \"\"\"\n        Disassemble instructions from a block of binary code.\n\n        @type  lpAddress: int\n        @param lpAddress: Memory address where the code was read from.\n\n        @type  code: str\n        @param code: Binary code to disassemble.\n\n        @rtype:  list of tuple( long, int, str, str )\n        @return: List of tuples. Each tuple represents an assembly instruction\n            and contains:\n             - Memory address of instruction.\n             - Size of instruction in bytes.\n             - Disassembly line of instruction.\n             - Hexadecimal dump of instruction.\n        \"\"\"\n", "input": "", "output": "        aProcess = self.get_process()\n        return aProcess.disassemble_string(lpAddress, code)", "category": "Python"}, {"instruction": "def replay_scope(self, sess):\n    \"\"\"Enters a replay scope that unsets it at the end.\"\"\"\n", "input": "", "output": "    current_replay = self.replay(sess)\n    try:\n      self.set_replay(sess, True)\n      yield\n    finally:\n      self.set_replay(sess, current_replay)", "category": "Python"}, {"instruction": "def compute_stats(array, stats, weights):\n    \"\"\"\n    :param array:\n        an array of R elements (which can be arrays)\n    :param stats:\n        a sequence of S statistic functions\n    :param weights:\n        a list of R weights\n    :returns:\n        an array of S elements (which can be arrays)\n    \"\"\"\n", "input": "", "output": "    result = numpy.zeros((len(stats),) + array.shape[1:], array.dtype)\n    for i, func in enumerate(stats):\n        result[i] = apply_stat(func, array, weights)\n    return result", "category": "Python"}, {"instruction": "def linear_insert(self, item, priority):\n    \"\"\"Linear search. Performance is O(n^2).\"\"\"\n", "input": "", "output": "\n    with self.lock:\n        self_data = self.data\n        rotate = self_data.rotate\n        maxlen = self._maxlen\n        length = len(self_data)\n        count = length\n\n        # in practice, this is better than doing a rotate(-1) every\n        # loop and getting self.data[0] each time only because deque\n        # implements a very efficient iterator in C\n        for i in self_data:\n            if priority > i[1]:\n                break\n            count -= 1\n\n        rotate(-count)\n        self_data.appendleft((item, priority))\n        rotate(length-count)\n\n        try:\n            self.items[item] += 1\n        except TypeError:\n            self.items[repr(item)] += 1\n\n        if maxlen is not None and maxlen < len(self_data):\n                self._poplast()", "category": "Python"}, {"instruction": "def run(self):\n        \"\"\"\n        1. count the words for each of the :py:meth:`~.InputText.output` targets created by :py:class:`~.InputText`\n        2. write the count into the :py:meth:`~.WordCount.output` target\n        \"\"\"\n", "input": "", "output": "        count = {}\n\n        # NOTE: self.input() actually returns an element for the InputText.output() target\n        for f in self.input():  # The input() method is a wrapper around requires() that returns Target objects\n            for line in f.open('r'):  # Target objects are a file system/format abstraction and this will return a file stream object\n                for word in line.strip().split():\n                    count[word] = count.get(word, 0) + 1\n\n        # output data\n        f = self.output().open('w')\n        for word, count in six.iteritems(count):\n            f.write(\"%s\\t%d\\n\" % (word, count))\n        f.close()", "category": "Python"}, {"instruction": "def get(feature, obj, **kwargs):\n    '''Obtain a feature from a set of morphology objects\n\n    Parameters:\n        feature(string): feature to extract\n        obj: a neuron, population or neurite tree\n        **kwargs: parameters to forward to underlying worker functions\n\n    Returns:\n        features as a 1D or 2D numpy array.\n\n    '''\n", "input": "", "output": "\n    feature = (NEURITEFEATURES[feature] if feature in NEURITEFEATURES\n               else NEURONFEATURES[feature])\n\n    return _np.array(list(feature(obj, **kwargs)))", "category": "Python"}, {"instruction": "def head(self, n=10):\n        \"\"\"\n        Display the top of the file.\n\n        Args:\n            n (int): Number of lines to display\n        \"\"\"\n", "input": "", "output": "        r = self.__repr__().split('\\n')\n        print('\\n'.join(r[:n]), end=' ')", "category": "Python"}, {"instruction": "def delete_unique_identity(db, uuid):\n    \"\"\"Remove a unique identity from the registry.\n\n    Function that removes from the registry, the unique identity\n    that matches with uuid. Data related to this identity will be\n    also removed.\n\n    It checks first whether the unique identity is already on the registry.\n    When it is found, the unique identity is removed. Otherwise, it will\n    raise a 'NotFoundError' exception.\n\n    :param db: database manager\n    :param uuid: unique identifier assigned to the unique identity set\n        for being removed\n\n    :raises NotFoundError: raised when the unique identity does not exist\n        in the registry.\n    \"\"\"\n", "input": "", "output": "    with db.connect() as session:\n        uidentity = find_unique_identity(session, uuid)\n\n        if not uidentity:\n            raise NotFoundError(entity=uuid)\n\n        delete_unique_identity_db(session, uidentity)", "category": "Python"}, {"instruction": "def _wrap_parse(code, filename):\n        \"\"\"\n        async wrapper is required to avoid await calls raising a SyntaxError\n        \"\"\"\n", "input": "", "output": "        code = 'async def wrapper():\\n' + indent(code, ' ')\n        return ast.parse(code, filename=filename).body[0].body[0].value", "category": "Python"}, {"instruction": "def sonTraceRootPath():\n    \"\"\"\n    function for finding external location\n    \"\"\"\n", "input": "", "output": "    import sonLib.bioio\n    i = os.path.abspath(sonLib.bioio.__file__)\n    return os.path.split(os.path.split(os.path.split(i)[0])[0])[0]", "category": "Python"}, {"instruction": "def expire_queues(self):\n        '''\n        Expires old queue_dict keys that have not been used in a long time.\n        Prevents slow memory build up when crawling lots of different domains\n        '''\n", "input": "", "output": "        curr_time = time.time()\n        for key in list(self.queue_dict):\n            diff = curr_time - self.queue_dict[key][1]\n            if diff > self.queue_timeout:\n                self.logger.debug(\"Expiring domain queue key \" + key)\n                del self.queue_dict[key]\n                if key in self.queue_keys:\n                    self.queue_keys.remove(key)", "category": "Python"}, {"instruction": "def times(A, b, offset=0):\n    \"\"\"\n    Times the view of A with b in place (!).\n    Returns modified A\n    Broadcasting is allowed, thus b can be scalar.\n\n    if offset is not zero, make sure b is of right shape!\n\n    :param ndarray A: 2 dimensional array\n    :param ndarray-like b: either one dimensional or scalar\n    :param int offset: same as in view.\n    :rtype: view of A, which is adjusted inplace\n    \"\"\"\n", "input": "", "output": "    return _diag_ufunc(A, b, offset, np.multiply)", "category": "Python"}, {"instruction": "def show_state_usage(queue=False, **kwargs):\n    '''\n    Retrieve the highstate data from the salt master to analyse used and unused states\n\n    Custom Pillar data can be passed with the ``pillar`` kwarg.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' state.show_state_usage\n    '''\n", "input": "", "output": "    conflict = _check_queue(queue, kwargs)\n    if conflict is not None:\n        return conflict\n    pillar = kwargs.get('pillar')\n    pillar_enc = kwargs.get('pillar_enc')\n    if pillar_enc is None \\\n            and pillar is not None \\\n            and not isinstance(pillar, dict):\n        raise SaltInvocationError(\n            'Pillar data must be formatted as a dictionary, unless pillar_enc '\n            'is specified.'\n        )\n\n    st_ = salt.state.HighState(__opts__, pillar, pillar_enc=pillar_enc)\n    st_.push_active()\n\n    try:\n        ret = st_.compile_state_usage()\n    finally:\n        st_.pop_active()\n    _set_retcode(ret)\n    return ret", "category": "Python"}, {"instruction": "def scan(self, folder, sub=None, next_=None):\n        \"\"\" Request immediate rescan of a folder, or a specific path within a\n        folder.\n\n            Args:\n                folder (str): Folder ID.\n                sub (str): Path relative to the folder root. If sub is omitted\n                    the entire folder is scanned for changes, otherwise only\n                    the given path children are scanned.\n                next_ (int): Delays Syncthing's automated rescan interval for\n                    a given amount of seconds.\n\n            Returns:\n                str\n        \"\"\"\n", "input": "", "output": "        if not sub:\n            sub = ''\n        assert isinstance(sub, string_types)\n        assert isinstance(next_, int) or next_ is None\n        return self.post('scan', params={'folder': folder,\n                                         'sub': sub,\n                                         'next': next_})", "category": "Python"}, {"instruction": "def anonymous_login(self):\n        \"\"\"Login as anonymous user\n\n        :return: logon result, see `CMsgClientLogonResponse.eresult <https://github.com/ValvePython/steam/blob/513c68ca081dc9409df932ad86c66100164380a6/protobufs/steammessages_clientserver.proto#L95-L118>`_\n        :rtype: :class:`.EResult`\n        \"\"\"\n", "input": "", "output": "        self._LOG.debug(\"Attempting Anonymous login\")\n\n        self._pre_login()\n\n        self.username = None\n        self.login_key = None\n\n        message = MsgProto(EMsg.ClientLogon)\n        message.header.steamid = SteamID(type='AnonUser', universe='Public')\n        message.body.protocol_version = 65579\n        self.send(message)\n\n        resp = self.wait_msg(EMsg.ClientLogOnResponse, timeout=30)\n        return EResult(resp.body.eresult) if resp else EResult.Fail", "category": "Python"}, {"instruction": "def create(context, name):\n    \"\"\"create(context, name)\n\n    Create a tag.\n\n    >>> dcictl tag-create [OPTIONS]\n\n    :param string name: Name of the tag [required]\n    \"\"\"\n", "input": "", "output": "\n    result = tag.create(context, name=name)\n    utils.format_output(result, context.format)", "category": "Python"}, {"instruction": "def execute_ssh_command(self, client, command):\n        \"\"\"Execute the provided command and log output.\"\"\"\n", "input": "", "output": "        try:\n            out = ipa_utils.execute_ssh_command(client, command)\n        except Exception as error:\n            raise IpaCloudException(\n                'Command: \"{0}\", failed execution: {1}.'.format(\n                    command, error\n                )\n            )\n        else:\n            self._write_to_log(out)", "category": "Python"}, {"instruction": "def fingerprint(self):\n    \"\"\"A memoized sha1 hexdigest hashing the contents of this PayloadField\n\n    The fingerprint returns either a string or None.  If the return is None, consumers of the\n    fingerprint may choose to elide this PayloadField from their combined hash computation.\n\n    :API: public\n    \"\"\"\n", "input": "", "output": "    if self._fingerprint_memo is None:\n      self._fingerprint_memo = self._compute_fingerprint()\n    return self._fingerprint_memo", "category": "Python"}, {"instruction": "def bic(self) -> str:\n        \"\"\"Generate random ``BIC`` (Bank ID Code).\n\n        :return: BIC.\n\n        :Example:\n            044025575.\n        \"\"\"\n", "input": "", "output": "        country_code = '04'\n        code = '{:02}'.format(self.random.randint(1, 10))\n        bank_number = '{:02}'.format(self.random.randint(0, 99))\n        bank_office = '{:03}'.format(self.random.randint(50, 999))\n        bic = country_code + code + bank_number + bank_office\n        return bic", "category": "Python"}, {"instruction": "def approx_equals(self, other, atol):\n        \"\"\"Return ``True`` in case of approximate equality.\n\n        Returns\n        -------\n        approx_eq : bool\n            ``True`` if ``other`` is a `RectPartition` instance with\n            ``self.set == other.set`` up to ``atol`` and\n            ``self.grid == other.other`` up to ``atol``, ``False`` otherwise.\n        \"\"\"\n", "input": "", "output": "        if other is self:\n            return True\n        elif not isinstance(other, RectPartition):\n            return False\n        else:\n            return (self.set.approx_equals(other.set, atol=atol) and\n                    self.grid.approx_equals(other.grid, atol=atol))", "category": "Python"}, {"instruction": "def mkdir(self, name=None, folder_id='0'):\n\t\t'''Create a folder with a specified \"name\" attribute.\n\t\t\tfolder_id allows to specify a parent folder.'''\n", "input": "", "output": "\t\treturn self( 'folders', method='post', encode='json',\n\t\t\tdata=dict(name=name, parent=dict(id=folder_id)) )", "category": "Python"}, {"instruction": "def is_volatile(self):\n        \"\"\"\n        True if combination of field access properties result in a field that\n        should be interpreted as volatile.\n        (Any hardware-writable field is inherently volatile)\n        \"\"\"\n", "input": "", "output": "\n        hw = self.get_property('hw')\n        return (\n            (hw in (rdltypes.AccessType.rw, rdltypes.AccessType.rw1,\n                    rdltypes.AccessType.w, rdltypes.AccessType.w1))\n            or self.get_property('counter')\n            or (self.get_property('next') is not None)\n            or self.get_property('hwset')\n            or self.get_property('hwclr')\n        )", "category": "Python"}, {"instruction": "def toString(self):\n        \"\"\" Returns time as string. \"\"\"\n", "input": "", "output": "        slist = self.toList()\n        string = angle.slistStr(slist)\n        return string if slist[0] == '-' else string[1:]", "category": "Python"}, {"instruction": "def _construct_key(self, rule_id: str, spacy_rule_id:int) -> int:\n        \"\"\"\n        Use a mapping to store the information about rule_id for each matches, create the mapping key here\n        Args:\n            rule_id: str\n            spacy_rule_id:int\n\n        Returns: int\n        \"\"\"\n", "input": "", "output": "\n        hash_key = (rule_id, spacy_rule_id)\n        hash_v = hash(hash_key) + sys.maxsize + 1\n        self._hash_map[hash_v] = hash_key\n        return hash_v", "category": "Python"}, {"instruction": "def callback_oauth2(self, request):\n        \"\"\"\n            Process for oAuth 2\n            :param request: contains the current session\n            :return:\n        \"\"\"\n", "input": "", "output": "        callback_url = self.callback_url(request)\n\n        oauth = OAuth2Session(client_id=self.consumer_key, redirect_uri=callback_url, scope=self.scope)\n        request_token = oauth.fetch_token(self.REQ_TOKEN,\n                                          code=request.GET.get('code', ''),\n                                          authorization_response=callback_url,\n                                          client_secret=self.consumer_secret,\n                                          scope=self.scope,\n                                          verify=False)\n        return request_token.get('access_token')", "category": "Python"}, {"instruction": "def instance(host=None, port=None):\n        \"\"\"\n        Singleton to return only one instance of Server.\n\n        :returns: instance of Server\n        \"\"\"\n", "input": "", "output": "\n        if not hasattr(WebServer, \"_instance\") or WebServer._instance is None:\n            assert host is not None\n            assert port is not None\n            WebServer._instance = WebServer(host, port)\n        return WebServer._instance", "category": "Python"}, {"instruction": "def chk_goids(goids, msg=None, raise_except=True):\n    \"\"\"check that all GO IDs have the proper format.\"\"\"\n", "input": "", "output": "    for goid in goids:\n        if not goid_is_valid(goid):\n            if raise_except:\n                raise RuntimeError(\"BAD GO({GO}): {MSG}\".format(GO=goid, MSG=msg))\n            else:\n                return goid", "category": "Python"}, {"instruction": "def bbox_vert_aligned_right(box1, box2):\n    \"\"\"\n    Returns true if the right boundary of both boxes is within 2 pts\n    \"\"\"\n", "input": "", "output": "    if not (box1 and box2):\n        return False\n    return abs(box1.right - box2.right) <= 2", "category": "Python"}, {"instruction": "def change_speed(body, speed=1):\n    \"\"\"Change the voice speed of the wave body.\"\"\"\n", "input": "", "output": "    if speed == 1:\n        return body\n\n    length = int(len(body) * speed)\n    rv = bytearray(length)\n\n    step = 0\n    for v in body:\n        i = int(step)\n        while i < int(step + speed) and i < length:\n            rv[i] = v\n            i += 1\n        step += speed\n    return rv", "category": "Python"}, {"instruction": "def buffer_iter(self, block_size=1024):\n        \"\"\"\n        Iterate through chunks of the vertices, and indices buffers seamlessly.\n\n        .. note::\n\n            To see a usage example, look at the :class:`ShapeBuffer` description.\n        \"\"\"\n", "input": "", "output": "        streams = (\n            self.vert_data,\n            self.idx_data,\n        )\n\n        # Chain streams seamlessly\n        for stream in streams:\n            stream.seek(0)\n            while True:\n                chunk = stream.read(block_size)\n                if chunk:\n                    yield chunk\n                else:\n                    break", "category": "Python"}, {"instruction": "def _cryptography_cipher(key, iv):\n    \"\"\"Build a cryptography TripleDES Cipher object.\n\n    :param bytes key: Encryption key\n    :param bytesiv iv: Initialization vector\n    :returns: TripleDES Cipher instance\n    :rtype: cryptography.hazmat.primitives.ciphers.Cipher\n    \"\"\"\n", "input": "", "output": "    return Cipher(\n        algorithm=algorithms.TripleDES(key),\n        mode=modes.CBC(iv),\n        backend=default_backend()\n    )", "category": "Python"}, {"instruction": "def make_workspace(measurement, channel=None, name=None, silence=False):\n    \"\"\"\n    Create a workspace containing the model for a measurement\n\n    If `channel` is None then include all channels in the model\n\n    If `silence` is True, then silence HistFactory's output on\n    stdout and stderr.\n    \"\"\"\n", "input": "", "output": "    context = silence_sout_serr if silence else do_nothing\n    with context():\n        hist2workspace = ROOT.RooStats.HistFactory.HistoToWorkspaceFactoryFast(\n            measurement)\n        if channel is not None:\n            workspace = hist2workspace.MakeSingleChannelModel(\n                measurement, channel)\n        else:\n            workspace = hist2workspace.MakeCombinedModel(measurement)\n    workspace = asrootpy(workspace)\n    keepalive(workspace, measurement)\n    if name is not None:\n        workspace.SetName('workspace_{0}'.format(name))\n    return workspace", "category": "Python"}, {"instruction": "def find_all_commands(management_dir):\n    \"\"\"\n    Find all valid commands in a directory\n    management_dir : directory path\n    return - List of commands\n    \"\"\"\n", "input": "", "output": "    try:\n        #Find all commands in the directory that are not __init__.py and end in .py.  Then, remove the trailing .py\n        return [f[:-3] for f in os.listdir(management_dir) if f.endswith('.py') and not f.startswith(\"__\")]\n    except OSError:\n        #If nothing is found, return empty\n        return []", "category": "Python"}, {"instruction": "def get_versioned_delete_collector_class():\n    \"\"\"\n    Gets the class to use for deletion collection.\n\n    :return: class\n    \"\"\"\n", "input": "", "output": "    key = 'VERSIONED_DELETE_COLLECTOR'\n    try:\n        cls = _cache[key]\n    except KeyError:\n        collector_class_string = getattr(settings, key)\n        cls = import_from_string(collector_class_string, key)\n        _cache[key] = cls\n    return cls", "category": "Python"}, {"instruction": "def get_automation(self, automation_id, refresh=False):\n        \"\"\"Get a single automation.\"\"\"\n", "input": "", "output": "        if self._automations is None:\n            self.get_automations()\n            refresh = False\n\n        automation = self._automations.get(str(automation_id))\n\n        if automation and refresh:\n            automation.refresh()\n\n        return automation", "category": "Python"}, {"instruction": "def _fetch_partition_info(self, topic_id, partition_id):\n        \"\"\"Fetch partition info for given topic-partition.\"\"\"\n", "input": "", "output": "        info_path = \"/brokers/topics/{topic_id}/partitions/{p_id}\"\n        try:\n            _, partition_info = self.get(\n                info_path.format(topic_id=topic_id, p_id=partition_id),\n            )\n            return partition_info\n        except NoNodeError:\n            return {}", "category": "Python"}, {"instruction": "def from_fqdn(cls, fqdn):\n        \"\"\"Retrieve domain id associated to a FQDN.\"\"\"\n", "input": "", "output": "        result = cls.list({'fqdn': fqdn})\n        if len(result) > 0:\n            return result[0]['id']", "category": "Python"}, {"instruction": "def sub(self, key):\n        \"\"\"Returns new Vyper instance representing a sub tree of this instance.\n        \"\"\"\n", "input": "", "output": "        subv = Vyper()\n        data = self.get(key)\n        if isinstance(data, dict):\n            subv._config = data\n            return subv\n        else:\n            return None", "category": "Python"}, {"instruction": "def get_condition(self, condition_id):\n        \"\"\"Retrieve the condition for a condition_id.\n\n        :param condition_id: id of the condition, str\n        :return:\n        \"\"\"\n", "input": "", "output": "        condition = self.contract_concise.getCondition(condition_id)\n        if condition and len(condition) == 7:\n            return ConditionValues(*condition)\n\n        return None", "category": "Python"}, {"instruction": "def go_from(self, vertex):\n        \"\"\"\n        Tell the edge to go out from this vertex.\n\n        Args:\n            vertex (Vertex): vertex to go from.\n        \"\"\"\n", "input": "", "output": "        if self.vertex_out:\n            self.vertex_out.edges_out.remove(self)\n        self.vertex_out = vertex\n        vertex.edges_out.add(self)", "category": "Python"}, {"instruction": "def info(self):\n        \"\"\"return info about configuration\"\"\"\n", "input": "", "output": "        uri = ','.join(x['hostname'] for x in self.routers)\n        mongodb_uri = 'mongodb://' + uri\n        result = {'id': self.id,\n                  'shards': self.members,\n                  'configsvrs': self.configsvrs,\n                  'routers': self.routers,\n                  'mongodb_uri': mongodb_uri,\n                  'orchestration': 'sharded_clusters'}\n        if self.login:\n            result['mongodb_auth_uri'] = self.mongodb_auth_uri(uri)\n        return result", "category": "Python"}, {"instruction": "def search(self, keyword, p_index=''):\n        '''\n        perform searching.\n        '''\n", "input": "", "output": "        if p_index == '' or p_index == '-1':\n            current_page_number = 1\n        else:\n            current_page_number = int(p_index)\n        res_all = self.ysearch.get_all_num(keyword)\n        results = self.ysearch.search_pager(\n            keyword,\n            page_index=current_page_number,\n            doc_per_page=CMS_CFG['list_num']\n        )\n        page_num = int(res_all / CMS_CFG['list_num'])\n        kwd = {'title': '\u67e5\u627e\u7ed3\u679c',\n               'pager': '',\n               'count': res_all,\n               'keyword': keyword,\n               'catid': '',\n               'current_page': current_page_number}\n        self.render('misc/search/search_list.html',\n                    kwd=kwd,\n                    srecs=results,\n                    pager=gen_pager_bootstrap_url(\n                        '/search/{0}'.format(keyword),\n                        page_num,\n                        current_page_number\n                    ),\n                    userinfo=self.userinfo,\n                    cfg=CMS_CFG)", "category": "Python"}, {"instruction": "def object_new(self, template=None, **kwargs):\n        \"\"\"Creates a new object from an IPFS template.\n\n        By default this creates and returns a new empty merkledag node, but you\n        may pass an optional template argument to create a preformatted node.\n\n        .. code-block:: python\n\n            >>> c.object_new()\n            {'Hash': 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'}\n\n        Parameters\n        ----------\n        template : str\n            Blueprints from which to construct the new object. Possible values:\n\n             * ``\"unixfs-dir\"``\n             * ``None``\n\n        Returns\n        -------\n            dict : Object hash\n        \"\"\"\n", "input": "", "output": "        args = (template,) if template is not None else ()\n        return self._client.request('/object/new', args,\n                                    decoder='json', **kwargs)", "category": "Python"}, {"instruction": "def prepare(self, ansi='', ensure_trailing_newline=False):\n        \"\"\" Load the contents of 'ansi' into this object \"\"\"\n", "input": "", "output": "\n        body, styles = self.apply_regex(ansi)\n\n        if ensure_trailing_newline and _needs_extra_newline(body):\n            body += '\\n'\n\n        self._attrs = {\n            'dark_bg': self.dark_bg,\n            'line_wrap': self.line_wrap,\n            'font_size': self.font_size,\n            'body': body,\n            'styles': styles,\n        }\n\n        return self._attrs", "category": "Python"}, {"instruction": "async def enable_events(self) -> asyncio.Task:\n        \"\"\"Connects to the websocket. Returns a listening task.\"\"\"\n", "input": "", "output": "        return await self._connection.ws_connect(\n            on_message=self._ws_on_message, on_error=self._ws_on_error\n        )", "category": "Python"}, {"instruction": "def set_threadlocal(self, **values):\n        \"\"\"Set current thread's logging context to specified `values`\"\"\"\n", "input": "", "output": "        with self._lock:\n            self._ensure_threadlocal()\n            self._tpayload.context = values", "category": "Python"}, {"instruction": "def _lats(self):\n        \"\"\"Return the latitudes (in degrees) of the gridded data.\"\"\"\n", "input": "", "output": "        lats = _np.linspace(90.0, -90.0 + 180.0 / self.nlat, num=self.nlat)\n        return lats", "category": "Python"}, {"instruction": "def to_dict(obj):\n    \"\"\"\n    Create a filtered dict from the given object.\n\n    Note: This function is currently specific to the FailureLine model.\n    \"\"\"\n", "input": "", "output": "    if not isinstance(obj.test, str):\n        # TODO: can we handle this in the DB?\n        # Reftests used to use tuple indicies, which we can't support.\n        # This is fixed upstream, but we also need to handle it here to allow\n        # for older branches.\n        return\n\n    keys = [\n        'id',\n        'job_guid',\n        'test',\n        'subtest',\n        'status',\n        'expected',\n        'message',\n        'best_classification',\n        'best_is_verified',\n    ]\n\n    all_fields = obj.to_dict()\n    return {k: v for k, v in all_fields.items() if k in keys}", "category": "Python"}, {"instruction": "def _send(self, message):\n        \"\"\"\n        A helper method that does the actual sending\n\n        :param SmsMessage message: SmsMessage class instance.\n        :returns: True if message is sent else False\n        :rtype: bool\n        \"\"\"\n", "input": "", "output": "\n        params = {\n            'from': message.from_phone, \n            'to': \",\".join(message.to),\n            'text': message.body,\n            'api_key': self.get_api_key(),\n            'api_secret': self.get_api_secret(),\n        }\n\n\n        print(params)\n\n        logger.debug(\"POST to %r with body: %r\", NEXMO_API_URL, params)\n\n        return self.parse(NEXMO_API_URL, requests.post(NEXMO_API_URL, data=params))", "category": "Python"}, {"instruction": "def iso8601_date(d):\n    \"\"\"\n    Return a string representation of a date that the Twilio API understands\n    Format is YYYY-MM-DD. Returns None if d is not a string, datetime, or date\n    \"\"\"\n", "input": "", "output": "    if d == values.unset:\n        return d\n    elif isinstance(d, datetime.datetime):\n        return str(d.date())\n    elif isinstance(d, datetime.date):\n        return str(d)\n    elif isinstance(d, str):\n        return d", "category": "Python"}, {"instruction": "def make_oracle(q0, q1, secret_function):\n    \"\"\" Gates implementing the secret function f(x).\"\"\"\n", "input": "", "output": "\n    # coverage: ignore\n    if secret_function[0]:\n        yield [CNOT(q0, q1), X(q1)]\n\n    if secret_function[1]:\n        yield CNOT(q0, q1)", "category": "Python"}, {"instruction": "def session_to_hour(timestamp):\n    \"\"\":param timestamp: as string in YYYYMMDDHHmmSS format\n    :return string in YYYYMMDDHH format\"\"\"\n", "input": "", "output": "    t = datetime.strptime(timestamp, SYNERGY_SESSION_PATTERN)\n    return t.strftime(SYNERGY_HOURLY_PATTERN)", "category": "Python"}, {"instruction": "def loadtxt(fn, **kwargs):\n    \"\"\"Study the text data file fn. Call numpys loadtxt with keyword\n    arguments based on the study.\n\n    Return data returned from numpy `loadtxt <http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html#numpy-loadtxt>`.\n\n    kwargs: keyword arguments accepted by numpys loadtxt. Any keyword\n    arguments provided will take precedence over the ones resulting\n    from the study.\n\n    Set the module attribute PP to the instance of PatternPull used.\n\n    \"\"\"\n", "input": "", "output": "    global PP\n    PP = PatternPull(fn)\n    txtargs = PP.loadtxtargs()\n    txtargs.update(kwargs)      # Let kwargs dominate.\n    return np.loadtxt(fn, **txtargs)", "category": "Python"}, {"instruction": "def get_user_bookmarks(self, id, **data):\n        \"\"\"\n        GET /users/:id/bookmarks/\n        Gets all the user's saved events.\n        In order to update the saved events list, the user must unsave or save each event.\n        A user is authorized to only see his/her saved events.\n        \"\"\"\n", "input": "", "output": "        \n        return self.get(\"/users/{0}/bookmarks/\".format(id), data=data)", "category": "Python"}, {"instruction": "def fast_hash(self):\n        \"\"\"\n        Get a CRC32 or xxhash.xxh64 reflecting the DataStore.\n\n        Returns\n        ------------\n        hashed: int, checksum of data\n        \"\"\"\n", "input": "", "output": "        fast = sum(i.fast_hash() for i in self.data.values())\n        return fast", "category": "Python"}, {"instruction": "def store_integers(items, allow_zero=True):\n    \"\"\"Store integers from the given list in a storage.\n\n    This is an example function to show autodoc style.\n\n    Return :class:`Storage` instance with integers from the given list.\n\n    Examples::\n\n        >>> storage = store_integers([1, 'foo', 2, 'bar', 0])\n        >>> storage.items\n        [1, 2, 0]\n        >>> storage = store_integers([1, 'foo', 2, 'bar', 0], allow_zero=False)\n        >>> storage.items\n        [1, 2]\n\n    :param items:\n        List of objects of any type, only :class:`int` instances will be\n        stored.\n    :param allow_zero:\n        Boolean -- if ``False``, ``0`` integers will be skipped.\n        Defaults to ``True``.\n\n    \"\"\"\n", "input": "", "output": "    ints = [x for x in items if isinstance(x, int) and (allow_zero or x != 0)]\n    storage = Storage(ints)\n    return storage", "category": "Python"}, {"instruction": "def process_tree_files(tree):\n    \"\"\" process_tree_files: Download files from nodes\n        Args:\n            tree (ChannelManager): manager to handle communication to Kolibri Studio\n        Returns: None\n    \"\"\"\n", "input": "", "output": "    # Fill in values necessary for next steps\n    config.LOGGER.info(\"Processing content...\")\n    files_to_diff = tree.process_tree(tree.channel)\n    config.SUSHI_BAR_CLIENT.report_statistics(files_to_diff, topic_count=tree.channel.get_topic_count())\n    tree.check_for_files_failed()\n    return files_to_diff, config.FAILED_FILES", "category": "Python"}, {"instruction": "def newNsPropEatName(self, ns, name, value):\n        \"\"\"Create a new property tagged with a namespace and carried\n           by a node. \"\"\"\n", "input": "", "output": "        if ns is None: ns__o = None\n        else: ns__o = ns._o\n        ret = libxml2mod.xmlNewNsPropEatName(self._o, ns__o, name, value)\n        if ret is None:raise treeError('xmlNewNsPropEatName() failed')\n        __tmp = xmlAttr(_obj=ret)\n        return __tmp", "category": "Python"}, {"instruction": "def copy_table(from_table, name):\n    \"\"\"\n    Copy a table.\n\n    Based on `Table.tometadata`, but simplified to remove constraints and indexes.\n\n    \"\"\"\n", "input": "", "output": "    metadata = from_table.metadata\n\n    if name in metadata.tables:\n        return metadata.tables[name]\n\n    schema = metadata.schema\n\n    columns = [\n        copy_column(column, schema)\n        for column in from_table.columns\n        if should_copy(column)\n    ]\n\n    return Table(\n        name,\n        metadata,\n        schema=schema,\n        comment=from_table.comment,\n        *columns,\n        **from_table.kwargs,\n    )", "category": "Python"}, {"instruction": "def _title_uptodate(self,fullfile,pid,_title):\n        \"\"\"Check fb photo title against provided title,\n        returns true if they match\"\"\"\n", "input": "", "output": "        i=self.fb.get_object(pid)\n        if i.has_key('name'):\n            if _title == i['name']:\n                return True\n\n        return False", "category": "Python"}, {"instruction": "def get_all(cls, names):\n        \"\"\"\n        Return all queues for the given names (for all available priorities)\n        \"\"\"\n", "input": "", "output": "        names = cls._get_iterable_for_names(names)\n\n        queues = []\n        for queue_name in names:\n            queues.extend(cls.collection(name=queue_name).instances())\n\n        return queues", "category": "Python"}, {"instruction": "def try_imports(imports, fail_msg=None):\n    \"\"\"\n    Try import statements until one succeeds.\n\n    Parameters\n    ----------\n    imports : list\n        The list of import statements.\n    fail_msg : str\n        If not None and no statement succeeds, a `ValueError` is raised with\n        the given message, appended to all failed messages.\n\n    Returns\n    -------\n    locals : dict\n        The dictionary of imported modules.\n    \"\"\"\n", "input": "", "output": "    msgs = []\n    for imp in imports:\n        try:\n            exec imp\n            break\n\n        except Exception, inst:\n            msgs.append(str(inst))\n\n    else:\n        if fail_msg is not None:\n            msgs.append(fail_msg)\n            raise ValueError('\\n'.join(msgs))\n\n    return locals()", "category": "Python"}, {"instruction": "def _set_next_host_location(self, context):\n        '''\n        A function which sets the next host location on the request, if applicable. \n\n        :param ~azure.storage.models.RetryContext context: \n            The retry context containing the previous host location and the request \n            to evaluate and possibly modify.\n        '''\n", "input": "", "output": "        if len(context.request.host_locations) > 1:\n            # If there's more than one possible location, retry to the alternative\n            if context.location_mode == LocationMode.PRIMARY:\n                context.location_mode = LocationMode.SECONDARY\n            else:\n                context.location_mode = LocationMode.PRIMARY\n\n            context.request.host = context.request.host_locations.get(context.location_mode)", "category": "Python"}, {"instruction": "def switch_to_output(self, value=False, **kwargs):\n        \"\"\"Switch the pin state to a digital output with the provided starting\n        value (True/False for high or low, default is False/low).\n        \"\"\"\n", "input": "", "output": "        self.direction = digitalio.Direction.OUTPUT\n        self.value = value", "category": "Python"}, {"instruction": "def parse_cgmlst_alleles(cgmlst_fasta):\n    \"\"\"Parse cgMLST alleles from fasta file\n    cgMLST FASTA file must have a header format of \">{marker name}|{allele name}\"\n\n    Args:\n        cgmlst_fasta (str): cgMLST fasta file path\n\n    Returns:\n        dict of list: Marker name to list of allele sequences\n    \"\"\"\n", "input": "", "output": "    out = defaultdict(list)\n    for header, seq in parse_fasta(cgmlst_fasta):\n        if not '|' in header:\n            raise Exception('Unexpected format for cgMLST fasta file header. No \"|\" (pipe) delimiter present! Header=\"{}\"'.format(header))\n        marker_name, allele_name = header.split('|')\n        out[marker_name].append(seq)\n    return out", "category": "Python"}, {"instruction": "def job_info(self, **kwargs):\n        \"\"\"\n        Get the information about the jobs returned by a particular search.\n        See the [GetJobs][] documentation for more info.\n\n        [GetJobs]: http://casjobs.sdss.org/casjobs/services/jobs.asmx?op=GetJobs\n\n        \"\"\"\n", "input": "", "output": "        search = \";\".join([\"%s : %s\"%(k, str(kwargs[k])) for k in kwargs])\n        params = {\"owner_wsid\": self.userid, \"owner_pw\": self.password,\n                \"conditions\": search, \"includeSystem\": False}\n        r = self._send_request(\"GetJobs\", params=params)\n        results = []\n        for n in minidom.parseString(r.text).getElementsByTagName(\"CJJob\"):\n            results.append({})\n            for e in n.childNodes:\n                if e.nodeType != e.TEXT_NODE:\n                    results[-1][e.tagName] = e.firstChild.data\n        return results", "category": "Python"}, {"instruction": "def to_match(self):\n        \"\"\"Return a unicode object with the MATCH representation of this GlobalContextField.\"\"\"\n", "input": "", "output": "        self.validate()\n\n        mark_name, field_name = self.location.get_location_name()\n        validate_safe_string(mark_name)\n        validate_safe_string(field_name)\n\n        return u'%s.%s' % (mark_name, field_name)", "category": "Python"}, {"instruction": "def findnode(obj, path=''):\n    \"\"\"Returns a Node pointing to obj.\n    \n    If obj is a ctypes-derived class, an UnboundNode is returned.  If obj is\n    an instance of such a class, then a BoundNode will be returned.\n    \n    If the optional path is provided, it is a string to look up searching\n    down the original source node, such as '.overhead.window[2].page'\n    \"\"\"\n", "input": "", "output": "    if isclass(obj):\n        node = _createunbound(obj)\n    else:\n        node = _createbound(obj)\n    \n    # And walk it down.\n    pathparts = re.split(r'\\]?(?:[[.]|$)', path)\n    for part in pathparts:\n        if not part:    continue\n        try:\n            idx = int(part)\n            node = node[idx]\n        except ValueError:\n            node = node[part]\n    return node", "category": "Python"}, {"instruction": "def all_inspections(obj):\n    \"\"\"\n    Generator to iterate all current Jishaku inspections.\n    \"\"\"\n", "input": "", "output": "\n    for name, callback in INSPECTIONS:\n        result = callback(obj)\n        if result:\n            yield name, result", "category": "Python"}, {"instruction": "def cache(self):\n      \"\"\"Caches the result of loader(filename) to cachename.\"\"\"\n", "input": "", "output": "      msg = 'Saving updates from more recent \"%s\" to \"%s\"'\n      log.info(msg, self.filename, self.cachename)\n      with open(self.cachename, 'wb') as output:\n          cPickle.dump(self._dict, output, -1)", "category": "Python"}, {"instruction": "def _make_proxy(self, varname, parent=None, constructor=MlabObjectProxy):\n        \"\"\"Creates a proxy for a variable.\n\n        XXX create and cache nested proxies also here.\n        \"\"\"\n", "input": "", "output": "        # FIXME why not just use gensym here?\n        proxy_val_name = \"PROXY_VAL%d__\" % self._proxy_count\n        self._proxy_count += 1\n        mlabraw.eval(self._session, \"%s = %s;\" % (proxy_val_name, varname))\n        res = constructor(self, proxy_val_name, parent)\n        self._proxies[proxy_val_name] = res\n        return res", "category": "Python"}, {"instruction": "def _disbatch_runner_async(self, chunk):\n        '''\n        Disbatch runner client_async commands\n        '''\n", "input": "", "output": "        pub_data = self.saltclients['runner'](chunk)\n        raise tornado.gen.Return(pub_data)", "category": "Python"}, {"instruction": "def replace(self, child, *nodes):\n        r\"\"\"Replace provided node with node(s).\n\n        :param TexNode child: Child node to replace\n        :param TexNode nodes: List of nodes to subtitute in\n\n        >>> from TexSoup import TexSoup\n        >>> soup = TexSoup(r'''\n        ... \\begin{itemize}\n        ...     \\item Hello\n        ...     \\item Bye\n        ... \\end{itemize}''')\n        >>> items = list(soup.find_all('item'))\n        >>> bye = items[1]\n        >>> soup.itemize.replace(soup.item, bye)\n        >>> soup.itemize\n        \\begin{itemize}\n            \\item Bye\n        \\item Bye\n        \\end{itemize}\n        \"\"\"\n", "input": "", "output": "        self.expr.insert(\n            self.expr.remove(child.expr),\n            *nodes)", "category": "Python"}, {"instruction": "def lazy_property(fn):\n    \"\"\"\n    Decorator that makes a property lazy-evaluated whilst preserving\n    docstrings.\n\n    Args:\n        fn (function): the property in question\n\n    Returns:\n        evaluated version of the property.\n    \"\"\"\n", "input": "", "output": "    attr_name = '_lazy_' + fn.__name__\n\n    @property\n    @wraps(fn)\n    def _lazy_property(self):\n        if not hasattr(self, attr_name):\n            setattr(self, attr_name, fn(self))\n        return getattr(self, attr_name)\n    return _lazy_property", "category": "Python"}, {"instruction": "def from_yaml(data):\n    \"\"\"\n    Interpolate the provided data and return a dict.\n\n    Currently, this is used to reinterpolate the `molecule.yml` inside an\n    Ansible playbook.  If there were any interpolation errors, they would\n    have been found and raised earlier.\n\n    :return: dict\n    \"\"\"\n", "input": "", "output": "    molecule_env_file = os.environ['MOLECULE_ENV_FILE']\n\n    env = os.environ.copy()\n    env = config.set_env_from_file(env, molecule_env_file)\n\n    i = interpolation.Interpolator(interpolation.TemplateWithDefaults, env)\n    interpolated_data = i.interpolate(data)\n\n    return util.safe_load(interpolated_data)", "category": "Python"}, {"instruction": "def get_bucket_type_props(self, bucket_type):\n        \"\"\"\n        Fetch bucket-type properties\n        \"\"\"\n", "input": "", "output": "        self._check_bucket_types(bucket_type)\n        msg_code = riak.pb.messages.MSG_CODE_GET_BUCKET_TYPE_REQ\n        codec = self._get_codec(msg_code)\n        msg = codec.encode_get_bucket_type_props(bucket_type)\n        resp_code, resp = self._request(msg, codec)\n        return codec.decode_bucket_props(resp.props)", "category": "Python"}, {"instruction": "def u_edit(*args):\n    \"\"\"\n    Edits given paths into Umbra.\n\n    :param \\*args: Arguments.\n    :type \\*args: \\*\n    :return: Definition success.\n    :rtype: bool\n    \"\"\"\n", "input": "", "output": "\n    paths = []\n    for path in args:\n        if not os.path.exists(path):\n            continue\n\n        paths.append(os.path.abspath(path))\n\n    if not paths:\n        return\n\n    connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    connection.connect((socket.gethostbyname(socket.gethostname()), 16384))\n    connection.send(\"{0}<!RE>\".format(\"\\n\".join(COMMAND_TEMPLATE).format(paths)))\n    connection.close()\n    return True", "category": "Python"}, {"instruction": "def matrix(self, x=(0, 0), y=(0, 0) , z=(0, 0)):\r\n        \"\"\"\r\n        Copy the ``pyny.Polyhedron`` along a 3D matrix given by the \r\n        three tuples x, y, z:        \r\n\r\n        :param x: Number of copies and distance between them in this\r\n            direction.\r\n        :type x: tuple (len=2)\r\n        :returns: list of ``pyny.Polyhedron``\r\n        \"\"\"\n", "input": "", "output": "        polygon = np.array([[0,0], [0,1], [1,1]])\r\n        space = Space(Place(polygon, polyhedra=self))\r\n        space = space.matrix(x, y, z, inplace=False)\r\n        return [place.polyhedra[0] for place in space]", "category": "Python"}, {"instruction": "def keys_by_alg_and_usage(self, issuer, alg, usage):\n        \"\"\"\n        Find all keys that can be used for a specific crypto algorithm and\n        usage by key owner.\n\n        :param issuer: Key owner\n        :param alg: a crypto algorithm\n        :param usage: What the key should be used for\n        :return: A possibly empty list of keys\n        \"\"\"\n", "input": "", "output": "        if usage in [\"sig\", \"ver\"]:\n            ktype = jws_alg2keytype(alg)\n        else:\n            ktype = jwe_alg2keytype(alg)\n\n        return self.get(usage, ktype, issuer)", "category": "Python"}, {"instruction": "def list_licenses(service_instance=None):\n    '''\n    Lists all licenses on a vCenter.\n\n    service_instance\n        Service instance (vim.ServiceInstance) of the vCenter/ESXi host.\n        Default is None.\n\n    .. code-block:: bash\n\n        salt '*' vsphere.list_licenses\n    '''\n", "input": "", "output": "    log.trace('Retrieving all licenses')\n    licenses = salt.utils.vmware.get_licenses(service_instance)\n    ret_dict = [{'key': l.licenseKey,\n                 'name': l.name,\n                 'description': l.labels[0].value if l.labels else None,\n                 # VMware handles unlimited capacity as 0\n                 'capacity': l.total if l.total > 0 else sys.maxsize,\n                 'used': l.used if l.used else 0}\n                 for l in licenses]\n    return ret_dict", "category": "Python"}, {"instruction": "def _add_temporary_results(self, results, label):\n        \"\"\"Adds `results` to a temporary table with `label`.\n\n        :param results: results file\n        :type results: `File`\n        :param label: label to be associated with results\n        :type label: `str`\n\n        \"\"\"\n", "input": "", "output": "        NGRAM, SIZE, NAME, SIGLUM, COUNT, LABEL = constants.QUERY_FIELDNAMES\n        reader = csv.DictReader(results)\n        data = [(row[NGRAM], row[SIZE], row[NAME], row[SIGLUM], row[COUNT],\n                 label) for row in reader]\n        self._conn.executemany(constants.INSERT_TEMPORARY_RESULTS_SQL, data)", "category": "Python"}, {"instruction": "def finalize(self, **kwargs):\n        \"\"\"\n        Finalize executes any subclass-specific axes finalization steps.\n        The user calls poof and poof calls finalize.\n\n        Parameters\n        ----------\n        kwargs: generic keyword arguments.\n\n        \"\"\"\n", "input": "", "output": "        # Set the title and add the legend\n        self.set_title('ROC Curves for {}'.format(self.name))\n        self.ax.legend(loc='lower right', frameon=True)\n\n        # Set the limits for the ROC/AUC (always between 0 and 1)\n        self.ax.set_xlim([0.0, 1.0])\n        self.ax.set_ylim([0.0, 1.0])\n\n        # Set x and y axis labels\n        self.ax.set_ylabel('True Postive Rate')\n        self.ax.set_xlabel('False Positive Rate')", "category": "Python"}, {"instruction": "def data_filler_simple_registration(self, number_of_rows, conn):\n        '''creates and fills the table with simple regis. information\n        '''\n", "input": "", "output": "        cursor = conn.cursor()\n\n        cursor.execute(", "category": "Python"}, {"instruction": "def findall(dir=os.curdir):\n    \"\"\"\n    Find all files under 'dir' and return the list of full filenames.\n    Unless dir is '.', return full filenames with dir prepended.\n    \"\"\"\n", "input": "", "output": "    files = _find_all_simple(dir)\n    if dir == os.curdir:\n        make_rel = functools.partial(os.path.relpath, start=dir)\n        files = map(make_rel, files)\n    return list(files)", "category": "Python"}, {"instruction": "def _iter_names(self):\n        \"\"\"\n        Generate a key/value pair for each name in this table. The key is a\n        (platform_id, name_id) 2-tuple and the value is the unicode text\n        corresponding to that key.\n        \"\"\"\n", "input": "", "output": "        table_format, count, strings_offset = self._table_header\n        table_bytes = self._table_bytes\n\n        for idx in range(count):\n            platform_id, name_id, name = self._read_name(\n                table_bytes, idx, strings_offset\n            )\n            if name is None:\n                continue\n            yield ((platform_id, name_id), name)", "category": "Python"}, {"instruction": "def node_changed(self, node):\n        \"\"\"\n        Calls :meth:`QAbstractItemModel.dataChanged` with given Node index.\n\n        :param node: Node.\n        :type node: AbstractCompositeNode or GraphModelNode\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n", "input": "", "output": "\n        index = self.get_node_index(node)\n        if index is not None:\n            self.dataChanged.emit(index, index)\n            return True\n        else:\n            return False", "category": "Python"}, {"instruction": "def __add_options(parser):\n    \"\"\"\n    Add the `Configure` options to a option-parser instance or a\n    option group.\n    \"\"\"\n", "input": "", "output": "    parser.add_option('--upx-dir', default=None,\n                      help='Directory containing UPX.')\n    parser.add_option('-C', '--configfile',\n                      default=DEFAULT_CONFIGFILE,\n                      dest='configfilename',\n                      help='Name of generated configfile (default: %default)')", "category": "Python"}, {"instruction": "def _construct_regex(cls, fmt):\n        \"\"\"Given a format string, construct the regex with class attributes.\"\"\"\n", "input": "", "output": "        return re.compile(fmt.format(**vars(cls)), flags=re.U)", "category": "Python"}, {"instruction": "def _count_dollars_before_index(self, s, i):\n        \"\"\"Returns the number of '$' characters right in front of s[i].\"\"\"\n", "input": "", "output": "        dollar_count = 0\n        dollar_index = i - 1\n        while dollar_index > 0 and s[dollar_index] == '$':\n            dollar_count += 1\n            dollar_index -= 1\n        return dollar_count", "category": "Python"}, {"instruction": "def post_optimization_step(self, batch_info, device, model, rollout):\n        \"\"\" Steps to take after optimization has been done\"\"\"\n", "input": "", "output": "        if batch_info.aggregate_batch_number % self.target_update_frequency == 0:\n            self.target_model.load_state_dict(model.state_dict())\n            self.target_model.eval()", "category": "Python"}, {"instruction": "def addAdminResource(self, pluginSubPath: bytes, resource: BasicResource) -> None:\n        \"\"\" Add Site Resource\n\n        Add a cusotom implementation of a served http resource.\n\n        :param pluginSubPath: The resource path where you want to serve this resource.\n        :param resource: The resource to serve.\n        :return: None\n\n        \"\"\"\n", "input": "", "output": "        pluginSubPath = pluginSubPath.strip(b'/')\n        self.__rootAdminResource.putChild(pluginSubPath, resource)", "category": "Python"}, {"instruction": "def ValidateLanguageCode(lang, column_name=None, problems=None):\n  \"\"\"\n  Validates a non-required language code value using the pybcp47 module:\n    - if invalid adds InvalidValue error (if problems accumulator is provided)\n    - distinguishes between 'not well-formed' and 'not valid' and adds error\n      reasons accordingly\n    - an empty language code is regarded as valid! Otherwise we might end up\n      with many duplicate errors because of the required field checks.\n    - returns true if the language is valid, false if not well-formed or\n      invalid.\n  \"\"\"\n", "input": "", "output": "  if util.IsEmpty(lang):\n    return True\n  bcp47_obj = parser.ParseLanguage(str(lang.lower()))\n  if not bcp47_obj.wellformed:\n    if problems:\n      problems.InvalidValue(column_name, lang,\n                            'language code \"%s\" is not well-formed' %\n                            lang, type=problems_class.TYPE_ERROR)\n    return False\n  if not bcp47_obj.valid:\n    if problems:\n      problems.InvalidValue(column_name, lang,\n                            'language code \"%s\" is not valid, parses as: %s' %\n                            (lang, bcp47_obj), type=problems_class.TYPE_WARNING)\n    return False\n  return True", "category": "Python"}, {"instruction": "def _handle_tag_text(self, text):\n        \"\"\"Handle regular *text* inside of an HTML open tag.\"\"\"\n", "input": "", "output": "        next = self._read(1)\n        if not self._can_recurse() or text not in self.MARKERS:\n            self._emit_text(text)\n        elif text == next == \"{\":\n            self._parse_template_or_argument()\n        elif text == next == \"[\":\n            self._parse_wikilink()\n        elif text == \"<\":\n            self._parse_tag()\n        else:\n            self._emit_text(text)", "category": "Python"}, {"instruction": "def process_settings(pelicanobj):\n    \"\"\"Sets user specified settings (see README for more details)\"\"\"\n", "input": "", "output": "\n    # Default settings\n    inline_settings = {}\n    inline_settings['config'] = {'[]':('', 'pelican-inline')}\n\n    # Get the user specified settings\n    try:\n        settings = pelicanobj.settings['MD_INLINE']\n    except:\n        settings = None\n\n    # If settings have been specified, add them to the config\n    if isinstance(settings, dict):\n        inline_settings['config'].update(settings)\n\n    return inline_settings", "category": "Python"}, {"instruction": "def load(self, page = None, verbose=False):\n        \"\"\"\n        call to execute the collection loading\n        :param page: integer of the page to load\n        :param verbose: boolean to print to console\n        :returns response\n        :raises the SalesKingException\n        \"\"\"\n", "input": "", "output": "        url = self._build_query_url(page, verbose)\n        response = self._load(url, verbose)\n        response = self._post_load(response, verbose)\n        return response", "category": "Python"}, {"instruction": "def get_ip(request):\n    \"\"\"Return the IP address inside the HTTP_X_FORWARDED_FOR var inside\n    the `request` object.\n\n    The return of this function can be overrided by the\n    `LOCAL_GEOLOCATION_IP` variable in the `conf` module.\n\n    This function will skip local IPs (starting with 10. and equals to\n    127.0.0.1).\n    \"\"\"\n", "input": "", "output": "    if getsetting('LOCAL_GEOLOCATION_IP'):\n        return getsetting('LOCAL_GEOLOCATION_IP')\n\n    forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')\n\n    if not forwarded_for:\n        return UNKNOWN_IP\n\n    for ip in forwarded_for.split(','):\n        ip = ip.strip()\n        if not ip.startswith('10.') and not ip == '127.0.0.1':\n            return ip\n\n    return UNKNOWN_IP", "category": "Python"}, {"instruction": "def supervisor(self):\n        \"\"\"Return an authenticated connection for use, open new if required.\n\n        Returns:\n            SupervisorWebService: New or existing session with the Five9\n            Statistics API.\n        \"\"\"\n", "input": "", "output": "        supervisor = self._cached_client('supervisor')\n        if not self._api_supervisor_session:\n            self._api_supervisor_session = self.__create_supervisor_session(\n                supervisor,\n            )\n        return supervisor", "category": "Python"}, {"instruction": "def set_iam_policy(self, policy):\n        \"\"\"Sets the access control policy on an instance resource. Replaces any\n        existing policy.\n\n        For more information about policy, please see documentation of\n        class `google.cloud.bigtable.policy.Policy`\n\n        For example:\n\n        .. literalinclude:: snippets.py\n            :start-after: [START bigtable_set_iam_policy]\n            :end-before: [END bigtable_set_iam_policy]\n\n        :type policy: :class:`google.cloud.bigtable.policy.Policy`\n        :param policy: A new IAM policy to replace the current IAM policy\n                       of this instance\n\n        :rtype: :class:`google.cloud.bigtable.policy.Policy`\n        :returns: The current IAM policy of this instance.\n        \"\"\"\n", "input": "", "output": "        instance_admin_client = self._client.instance_admin_client\n        resp = instance_admin_client.set_iam_policy(\n            resource=self.name, policy=policy.to_pb()\n        )\n        return Policy.from_pb(resp)", "category": "Python"}, {"instruction": "def size(self, table=None):\n        \"\"\"\n        Return the size, in bytes, of the profile or *table*.\n\n        If *table* is `None`, this function returns the size of the\n        whole profile (i.e. the sum of the table sizes). Otherwise, it\n        returns the size of *table*.\n\n        Note: if the file is gzipped, it returns the compressed size.\n        \"\"\"\n", "input": "", "output": "        size = 0\n        if table is None:\n            for table in self.relations:\n                size += self.size(table)\n        else:\n            try:\n                fn = _table_filename(os.path.join(self.root, table))\n                size += os.stat(fn).st_size\n            except ItsdbError:\n                pass\n        return size", "category": "Python"}, {"instruction": "def make_static_url(\n        cls, settings: Dict[str, Any], path: str, include_version: bool = True\n    ) -> str:\n        \"\"\"Constructs a versioned url for the given path.\n\n        This method may be overridden in subclasses (but note that it\n        is a class method rather than an instance method).  Subclasses\n        are only required to implement the signature\n        ``make_static_url(cls, settings, path)``; other keyword\n        arguments may be passed through `~RequestHandler.static_url`\n        but are not standard.\n\n        ``settings`` is the `Application.settings` dictionary.  ``path``\n        is the static path being requested.  The url returned should be\n        relative to the current host.\n\n        ``include_version`` determines whether the generated URL should\n        include the query string containing the version hash of the\n        file corresponding to the given ``path``.\n\n        \"\"\"\n", "input": "", "output": "        url = settings.get(\"static_url_prefix\", \"/static/\") + path\n        if not include_version:\n            return url\n\n        version_hash = cls.get_version(settings, path)\n        if not version_hash:\n            return url\n\n        return \"%s?v=%s\" % (url, version_hash)", "category": "Python"}, {"instruction": "def is_path_like(obj, attr=('name', 'is_file', 'is_dir', 'iterdir')):\n    \"\"\"test if object is pathlib.Path like\"\"\"\n", "input": "", "output": "    for a in attr:\n        if not hasattr(obj, a):\n            return False\n    return True", "category": "Python"}, {"instruction": "def __get_factory_with_context(self, factory_name):\n        # type: (str) -> Tuple[type, FactoryContext]\n        \"\"\"\n        Retrieves the factory registered with the given and its factory context\n\n        :param factory_name: The name of the factory\n        :return: A (factory, context) tuple\n        :raise TypeError: Unknown factory, or factory not manipulated\n        \"\"\"\n", "input": "", "output": "        factory = self.__factories.get(factory_name)\n        if factory is None:\n            raise TypeError(\"Unknown factory '{0}'\".format(factory_name))\n\n        # Get the factory context\n        factory_context = getattr(\n            factory, constants.IPOPO_FACTORY_CONTEXT, None\n        )\n        if factory_context is None:\n            raise TypeError(\n                \"Factory context missing in '{0}'\".format(factory_name)\n            )\n\n        return factory, factory_context", "category": "Python"}, {"instruction": "def get(self, *args, **kwargs):\n        '''\n        /label/s/view\n        '''\n", "input": "", "output": "        url_arr = self.parse_url(args[0])\n\n        if len(url_arr) == 2:\n            if url_arr[0] == 'remove':\n                self.remove_redis_keyword(url_arr[1])\n            else:\n                self.list(url_arr[0], url_arr[1])\n        elif len(url_arr) == 3:\n            self.list(url_arr[0], url_arr[1], url_arr[2])\n        else:\n            return False", "category": "Python"}, {"instruction": "def rotation_from_axes(x_axis, y_axis, z_axis):\n        \"\"\"Convert specification of axis in target frame to\n        a rotation matrix from source to target frame.\n\n        Parameters\n        ----------\n        x_axis : :obj:`numpy.ndarray` of float\n            A normalized 3-vector for the target frame's x-axis.\n\n        y_axis : :obj:`numpy.ndarray` of float\n            A normalized 3-vector for the target frame's y-axis.\n\n        z_axis : :obj:`numpy.ndarray` of float\n            A normalized 3-vector for the target frame's z-axis.\n\n        Returns\n        -------\n        :obj:`numpy.ndarray` of float\n            A 3x3 rotation matrix that transforms from a source frame to the\n            given target frame.\n        \"\"\"\n", "input": "", "output": "        return np.hstack((x_axis[:,np.newaxis], y_axis[:,np.newaxis], z_axis[:,np.newaxis]))", "category": "Python"}, {"instruction": "def weld_str_get(array, i):\n    \"\"\"Retrieve character at index i.\n\n    Parameters\n    ----------\n    array : numpy.ndarray or WeldObject\n        Input data.\n    i : int\n        Index of character to retrieve. If greater than length of string, returns None.\n\n    Returns\n    -------\n    WeldObject\n        Representation of this computation.\n\n    \"\"\"\n", "input": "", "output": "    obj_id, weld_obj = create_weld_object(array)\n    index_literal = to_weld_literal(i, WeldLong())\n    missing_literal = default_missing_data_literal(WeldVec(WeldChar()))\n    missing_literal_id = get_weld_obj_id(weld_obj, missing_literal)\n\n    weld_template = ", "category": "Python"}, {"instruction": "def hash160(msg_bytes):\n    '''\n    byte-like -> bytes\n    '''\n", "input": "", "output": "    h = hashlib.new('ripemd160')\n    if 'decred' in riemann.get_current_network_name():\n        h.update(blake256(msg_bytes))\n        return h.digest()\n    h.update(sha256(msg_bytes))\n    return h.digest()", "category": "Python"}, {"instruction": "def get_approvals(self, issue_id_or_key, start=0, limit=50):\n        \"\"\"\n        Get all approvals on a request, for a given request ID/Key\n\n        :param issue_id_or_key: str\n        :param start: OPTIONAL: int\n        :param limit: OPTIONAL: int\n        :return:\n        \"\"\"\n", "input": "", "output": "        url = 'rest/servicedeskapi/request/{}/approval'.format(issue_id_or_key)\n        params = {}\n        if start is not None:\n            params['start'] = int(start)\n        if limit is not None:\n            params['limit'] = int(limit)\n\n        return self.get(url, headers=self.experimental_headers, params=params).get('values')", "category": "Python"}, {"instruction": "def migrate_050_to_051(session):\n    \"\"\"Set time_out field of all flagged\n    timesheet entries to Null.\n    \"\"\"\n", "input": "", "output": "    entries_to_update = session.query(Entry).filter(\n            Entry.forgot_sign_out.is_(True)).filter(\n            Entry.time_out.isnot(None))\n\n    for entry in entries_to_update:\n        entry.time_out = None\n        logging.info('Entry updated {}'.format(entry.uuid))\n        logging.debug(entry.uuid)\n        session.add(entry)", "category": "Python"}, {"instruction": "def composition(mol):\n    \"\"\"Molecular composition in dict format\n    (ex. Glucose {'C': 6, 'H': 12, 'O': 6}).\n    \"\"\"\n", "input": "", "output": "    mol.require(\"Valence\")\n    c = Counter()\n    for _, a in mol.atoms_iter():\n        c += a.composition()\n    return c", "category": "Python"}, {"instruction": "def find_compatible_interpreters(pex_python_path=None, compatibility_constraints=None):\n  \"\"\"Find all compatible interpreters on the system within the supplied constraints and use\n     PEX_PYTHON_PATH if it is set. If not, fall back to interpreters on $PATH.\n  \"\"\"\n", "input": "", "output": "  if pex_python_path:\n    interpreters = []\n    for binary in pex_python_path.split(os.pathsep):\n      try:\n        interpreters.append(PythonInterpreter.from_binary(binary))\n      except Executor.ExecutionError:\n        print(\"Python interpreter %s in PEX_PYTHON_PATH failed to load properly.\" % binary,\n          file=sys.stderr)\n    if not interpreters:\n      die('PEX_PYTHON_PATH was defined, but no valid interpreters could be identified. Exiting.')\n  else:\n    # We may have been invoked with a specific interpreter not on the $PATH, make sure our\n    # sys.executable is included as a candidate in this case.\n    interpreters = OrderedSet([PythonInterpreter.get()])\n\n    # Add all qualifying interpreters found in $PATH.\n    interpreters.update(PythonInterpreter.all())\n\n  return list(\n    matched_interpreters(interpreters, compatibility_constraints)\n    if compatibility_constraints\n    else interpreters\n  )", "category": "Python"}, {"instruction": "def reorient(self, up, look):\n        '''\n        Reorient the mesh by specifying two vectors.\n\n        up: The foot-to-head direction.\n        look: The direction the body is facing.\n\n        In the result, the up will end up along +y, and look along +z\n        (i.e. facing towards a default OpenGL camera).\n\n        '''\n", "input": "", "output": "        from blmath.geometry.transform import rotation_from_up_and_look\n        from blmath.numerics import as_numeric_array\n\n        up = as_numeric_array(up, (3,))\n        look = as_numeric_array(look, (3,))\n\n        if self.v is not None:\n            self.v = np.dot(rotation_from_up_and_look(up, look), self.v.T).T", "category": "Python"}, {"instruction": "def _bell(self):\n        u'''ring the bell if requested.'''\n", "input": "", "output": "        if self.bell_style == u'none':\n            pass\n        elif self.bell_style == u'visible':\n            raise NotImplementedError(u\"Bellstyle visible is not implemented yet.\")\n        elif self.bell_style == u'audible':\n            self.console.bell()\n        else:\n            raise ReadlineError(u\"Bellstyle %s unknown.\"%self.bell_style)", "category": "Python"}, {"instruction": "def prepare_sparse_params(self, param_rowids):\n        '''Prepares the module for processing a data batch by pulling row_sparse\n        parameters from kvstore to all devices based on rowids.\n\n        Parameters\n        ----------\n        param_rowids : dict of str to NDArray of list of NDArrays\n        '''\n", "input": "", "output": "        if not self._kvstore:\n            return\n        assert(isinstance(param_rowids, dict))\n        for param_name, rowids in param_rowids.items():\n            if isinstance(rowids, (tuple, list)):\n                rowids_1d = []\n                for r in rowids:\n                    rowids_1d.append(r.reshape((-1,)).astype(np.int64))\n                rowid = mx.nd.concat(*rowids_1d, dim=0)\n            else:\n                rowid = rowids\n            param_idx = self._exec_group.param_names.index(param_name)\n            param_val = self._exec_group.param_arrays[param_idx]\n            self._kvstore.row_sparse_pull(param_name, param_val, row_ids=rowid,\n                                          priority=-param_idx)", "category": "Python"}, {"instruction": "def say(self, event):\n        \"\"\"Chat event handler for incoming events\n        :param event: say-event with incoming chat message\n        \"\"\"\n", "input": "", "output": "\n        try:\n            userid = event.user.uuid\n            recipient = self._get_recipient(event)\n            content = self._get_content(event)\n\n            if self.config.name in content:\n                self.log('I think, someone mentioned me:', content)\n\n        except Exception as e:\n            self.log(\"Error: '%s' %s\" % (e, type(e)), exc=True, lvl=error)", "category": "Python"}, {"instruction": "def d2Ibr_dV2(Ybr, V, lam):\n    \"\"\" Computes 2nd derivatives of complex branch current w.r.t. voltage.\n    \"\"\"\n", "input": "", "output": "    nb = len(V)\n    diaginvVm = spdiag(div(matrix(1.0, (nb, 1)), abs(V)))\n\n    Haa = spdiag(mul(-(Ybr.T * lam), V))\n    Hva = -1j * Haa * diaginvVm\n    Hav = Hva\n    Hvv = spmatrix([], [], [], (nb, nb))\n\n    return Haa, Hav, Hva, Hvv", "category": "Python"}, {"instruction": "def abivalidate_inputs(self):\n        \"\"\"\n        Run ABINIT in dry mode to validate all the inputs of the flow.\n\n        Return:\n            (isok, tuples)\n\n            isok is True if all inputs are ok.\n            tuples is List of `namedtuple` objects, one for each task in the flow.\n            Each namedtuple has the following attributes:\n\n                retcode: Return code. 0 if OK.\n                log_file:  log file of the Abinit run, use log_file.read() to access its content.\n                stderr_file: stderr file of the Abinit run. use stderr_file.read() to access its content.\n\n        Raises:\n            `RuntimeError` if executable is not in $PATH.\n        \"\"\"\n", "input": "", "output": "        if not self.allocated:\n            self.allocate()\n\n        isok, tuples = True, []\n        for task in self.iflat_tasks():\n            t = task.input.abivalidate()\n            if t.retcode != 0: isok = False\n            tuples.append(t)\n\n        return isok, tuples", "category": "Python"}, {"instruction": "def get_gpg_home( appname, config_dir=None ):\n    \"\"\"\n    Get the GPG keyring directory for a particular application.\n    Return the path.\n    \"\"\"\n", "input": "", "output": "    assert is_valid_appname(appname)\n    config_dir = get_config_dir( config_dir )\n    path = os.path.join( config_dir, \"gpgkeys\", appname )\n    return path", "category": "Python"}, {"instruction": "def register_schema(self, directory, path):\n        \"\"\"Register a json-schema.\n\n        :param directory: root directory path.\n        :param path: schema path, relative to the root directory.\n        \"\"\"\n", "input": "", "output": "        self.schemas[path] = os.path.abspath(directory)", "category": "Python"}, {"instruction": "def locale_export():\n    \"\"\"Exports for dealing with Click-based programs and ASCII/Unicode errors.\n\n    RuntimeError: Click will abort further execution because Python 3 was\n    configured to use ASCII as encoding for the environment.\n    Consult https://click.palletsprojects.com/en/7.x/python3/ for mitigation steps.\n\n    Looks up available locales on the system to find an appropriate one to pick,\n    defaulting to C.UTF-8 which is globally available on newer systems.\n    \"\"\"\n", "input": "", "output": "    locale_to_use = \"C.UTF-8\"\n    try:\n        locales = subprocess.check_output([\"locale\", \"-a\"]).decode(errors=\"ignore\").split(\"\\n\")\n    except subprocess.CalledProcessError:\n        locales = []\n    for locale in locales:\n        if locale.lower().endswith((\"utf-8\", \"utf8\")):\n            locale_to_use = locale\n            break\n    return \"export LC_ALL=%s && export LANG=%s && \" % (locale_to_use, locale_to_use)", "category": "Python"}, {"instruction": "def to_unicode(text):\n    \"\"\"\n    Return *text* as a unicode string. All text in Python 3 is unicode, so\n    this just returns *text* unchanged.\n    \"\"\"\n", "input": "", "output": "    if not isinstance(text, str):\n        tmpl = 'expected unicode string, got %s value %s'\n        raise TypeError(tmpl % (type(text), text))\n    return text", "category": "Python"}, {"instruction": "def hisat2_general_stats_table(self):\n        \"\"\" Take the parsed stats from the HISAT2 report and add it to the\n        basic stats table at the top of the report \"\"\"\n", "input": "", "output": "\n        headers = OrderedDict()\n        headers['overall_alignment_rate'] = {\n            'title': '% Aligned',\n            'description': 'overall alignment rate',\n            'max': 100,\n            'min': 0,\n            'suffix': '%',\n            'scale': 'YlGn'\n        }\n        self.general_stats_addcols(self.hisat2_data, headers)", "category": "Python"}, {"instruction": "def close(self, cancelled=False):\n        \"\"\"\n        Close this temporary pop-up.\n\n        :param cancelled: Whether the pop-up was cancelled (e.g. by pressing Esc).\n        \"\"\"\n", "input": "", "output": "        self._on_close(cancelled)\n        self._scene.remove_effect(self)", "category": "Python"}, {"instruction": "def derivativeX(self,*args):\n        '''\n        Returns the derivative of the function with respect to the X dimension.\n        This is the first input whenever n_dims < 4 and the second input otherwise.\n        '''\n", "input": "", "output": "        if self.n_dims >= 4:\n            j = 1\n        else:\n            j = 0\n        if self.i_dim == j:\n            return np.ones_like(*args[0])\n        else:\n            return np.zeros_like(*args[0])", "category": "Python"}, {"instruction": "def print_stream(file, name):\n    \"\"\"Print stream from file to logger.\"\"\"\n", "input": "", "output": "    logger = logging.getLogger('xenon.{}'.format(name))\n    for line in file:\n        logger.info('[{}] {}'.format(name, line.strip()))", "category": "Python"}, {"instruction": "def create(path, docker_compose):\n    '''\n    Create and validate a docker-compose file into a directory\n\n    path\n        Path where the docker-compose file will be stored on the server\n\n    docker_compose\n        docker_compose file\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt myminion dockercompose.create /path/where/docker-compose/stored content\n    '''\n", "input": "", "output": "    if docker_compose:\n        ret = __write_docker_compose(path,\n                                     docker_compose,\n                                     already_existed=False)\n        if isinstance(ret, dict):\n            return ret\n    else:\n        return __standardize_result(False,\n                                    'Creating a docker-compose project failed, you must send a valid docker-compose file',\n                                    None, None)\n    return __standardize_result(True,\n                                'Successfully created the docker-compose file',\n                                {'compose.base_dir': path},\n                                None)", "category": "Python"}, {"instruction": "def init():\n    \"\"\" Initialize the lib\n\n    Function-design use is to be able to test language settings changes\n    \"\"\"\n", "input": "", "output": "\n    if settings.USE_L10N:\n        locale = settings.LANGUAGE_CODE.replace('-', '_')\n        try:\n            humanize.i18n.activate(locale)\n        except FileNotFoundError:\n            pass  # Just let it to the default locale\n\n    HUMANIZE_FUNC_LIST = [\n        'naturalday',\n        'naturaltime',\n        'ordinal',\n        'intword',\n        'naturaldelta',\n        'intcomma',\n        'apnumber',\n        'fractional',\n        'naturalsize',\n        'naturaldate'\n    ]\n\n    # registers all humanize functions as template tags\n    for funcname in HUMANIZE_FUNC_LIST:\n        func = getattr(humanize, funcname)\n        register.filter(funcname, func, is_safe=True)", "category": "Python"}, {"instruction": "def get_empty_dirs(self, path):\n        \"\"\"Return a list of empty directories in path.\"\"\"\n", "input": "", "output": "        empty_dirs = []\n        for i in os.listdir(path):\n            child_path = os.path.join(path, i)\n            if i == '.git' or os.path.isfile(child_path) or os.path.islink(child_path):  # noqa\n                continue\n            if self.path_only_contains_dirs(child_path):\n                empty_dirs.append(i)\n        return empty_dirs", "category": "Python"}, {"instruction": "def _insertDateIndex(date, l):\r\n    '''\r\n    returns the index to insert the given date in a list\r\n    where each items first value is a date\r\n    '''\n", "input": "", "output": "    return next((i for i, n in enumerate(l) if n[0] < date), len(l))", "category": "Python"}, {"instruction": "def retention_load(self, forced=False):\n        \"\"\"Call hook point 'load_retention'.\n        Retention modules will read retention (from file, db etc)\n\n        :param forced: is load forced?\n        :type forced: bool\n        :return: None\n        \"\"\"\n", "input": "", "output": "        # If we set the retention update to 0, we do not want to manage retention\n        # If we are not forced (like at stopping)\n        if self.pushed_conf.retention_update_interval == 0 and not forced:\n            logger.debug(\"Should have loaded retention but it is not enabled\")\n            return\n\n        _t0 = time.time()\n        self.hook_point('load_retention')\n        statsmgr.timer('hook.retention-load', time.time() - _t0)\n\n        self.add(make_monitoring_log('INFO', 'RETENTION LOAD: %s' % self.my_daemon.name))\n        logger.info('Retention data loaded: %.2f seconds', time.time() - _t0)", "category": "Python"}, {"instruction": "def get_nameserver_detail_output_show_nameserver_nameserver_porttype(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n", "input": "", "output": "        config = ET.Element(\"config\")\n        get_nameserver_detail = ET.Element(\"get_nameserver_detail\")\n        config = get_nameserver_detail\n        output = ET.SubElement(get_nameserver_detail, \"output\")\n        show_nameserver = ET.SubElement(output, \"show-nameserver\")\n        nameserver_portid_key = ET.SubElement(show_nameserver, \"nameserver-portid\")\n        nameserver_portid_key.text = kwargs.pop('nameserver_portid')\n        nameserver_porttype = ET.SubElement(show_nameserver, \"nameserver-porttype\")\n        nameserver_porttype.text = kwargs.pop('nameserver_porttype')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "category": "Python"}, {"instruction": "def is_twss(self, phrase):\n        \"\"\"\n        The magic function- this accepts a phrase and tells you if it\n        classifies as an entendre\n        \"\"\"\n", "input": "", "output": "        featureset = self.extract_features(phrase)\n        return self.classifier.classify(featureset)", "category": "Python"}, {"instruction": "def dict_filter(d, exclude=[]):\n    \"\"\"\n    Exclude specified keys from a nested dict\n    \"\"\"\n", "input": "", "output": "\n    if isinstance(d, list):\n        ret = []\n        for e in d:\n            ret.append(dict_filter(e, exclude))\n        return ret\n    elif isinstance(d, dict):\n        ret = {}\n        for k, v in d.items():\n            if isinstance(k, builtin_str):\n                k = str(k)\n\n            assert isinstance(k, str)\n            if k in exclude:\n                continue\n            ret[k] = dict_filter(v, exclude)\n        return ret\n\n    return d", "category": "Python"}, {"instruction": "def refresh_datasources(self, refreshAll=True):\n        \"\"\"endpoint that refreshes druid datasources metadata\"\"\"\n", "input": "", "output": "        session = db.session()\n        DruidCluster = ConnectorRegistry.sources['druid'].cluster_class\n        for cluster in session.query(DruidCluster).all():\n            cluster_name = cluster.cluster_name\n            valid_cluster = True\n            try:\n                cluster.refresh_datasources(refreshAll=refreshAll)\n            except Exception as e:\n                valid_cluster = False\n                flash(\n                    \"Error while processing cluster '{}'\\n{}\".format(\n                        cluster_name, utils.error_msg_from_exception(e)),\n                    'danger')\n                logging.exception(e)\n                pass\n            if valid_cluster:\n                cluster.metadata_last_refreshed = datetime.now()\n                flash(\n                    _('Refreshed metadata from cluster [{}]').format(\n                        cluster.cluster_name),\n                    'info')\n        session.commit()\n        return redirect('/druiddatasourcemodelview/list/')", "category": "Python"}, {"instruction": "def filter_nodes(graph: BELGraph, node_predicates: NodePredicates) -> Iterable[BaseEntity]:\n    \"\"\"Apply a set of predicates to the nodes iterator of a BEL graph.\"\"\"\n", "input": "", "output": "    concatenated_predicate = concatenate_node_predicates(node_predicates=node_predicates)\n    for node in graph:\n        if concatenated_predicate(graph, node):\n            yield node", "category": "Python"}, {"instruction": "def shellfilter(value):\n    \"\"\"Replace HTML chars for shell usage.\"\"\"\n", "input": "", "output": "    replacements = {'\\\\': '\\\\\\\\',\n                    '`': '\\\\`',\n                    \"'\": \"\\\\'\",\n                    '\"': '\\\\\"'}\n    for search, repl in replacements.items():\n        value = value.replace(search, repl)\n    return safestring.mark_safe(value)", "category": "Python"}, {"instruction": "def cancel_order(self, order_id, stock):\n        \"\"\"Cancel An Order\n\n        https://starfighter.readme.io/docs/cancel-an-order\n        \"\"\"\n", "input": "", "output": "        url_fragment = 'venues/{venue}/stocks/{stock}/orders/{order_id}'.format(\n            venue=self.venue,\n            stock=stock,\n            order_id=order_id,\n        )\n        url = urljoin(self.base_url, url_fragment)\n        return self.session.delete(url).json()", "category": "Python"}, {"instruction": "def likelihood_table_to_probs(self, lktable):\n        \"\"\"\n        Calculates this formula (1), given the log of the numerator as input\n                     \n                     p_k * f(x_i, a_k)\n        t_k(x_i) = -----------------------\n                    ---K\n                    \\   p_k * f(x_i, a_k)\n                    /__k=1\n        \n        x_i is data point i\n        P_k is cluster k of K\n        t_k is the posterior probability of x_i belonging to P_k\n        p_k is the prior probability of belong to P_k (the proportional size of P_k)\n        f(x, a) is the likelihood of x with parameters a\n        \"\"\"\n", "input": "", "output": "        m = lktable.max(1)  # row max of lktable\n        shifted = lktable-m[:,np.newaxis]  # shift lktable of log-likelihoods to a non-underflowing range\n        expsum = np.exp(shifted).sum(1)  # convert logs to (scaled) normal space, and sum the rows\n        logexpsum = np.log(expsum)+m  # convert back to log space, and undo the scaling\n        return np.exp(lktable - logexpsum[:, np.newaxis])", "category": "Python"}, {"instruction": "def use_value(self, value):\n        \"\"\"Converts value to field type or use original\"\"\"\n", "input": "", "output": "        if self.check_value(value):\n            return value\n        return self.convert_value(value)", "category": "Python"}, {"instruction": "def send(self, s):\n        '''Send data to the subprocess' stdin.\n\n        Returns the number of bytes written.\n        '''\n", "input": "", "output": "        s = self._coerce_send_string(s)\n        self._log(s, 'send')\n\n        b = self._encoder.encode(s, final=False)\n        if PY3:\n            return self.proc.stdin.write(b)\n        else:\n            # On Python 2, .write() returns None, so we return the length of\n            # bytes written ourselves. This assumes they all got written.\n            self.proc.stdin.write(b)\n            return len(b)", "category": "Python"}, {"instruction": "def _log_to_stderr(self, record):\n    \"\"\"Emits the record to stderr.\n\n    This temporarily sets the handler stream to stderr, calls\n    StreamHandler.emit, then reverts the stream back.\n\n    Args:\n      record: logging.LogRecord, the record to log.\n    \"\"\"\n", "input": "", "output": "    # emit() is protected by a lock in logging.Handler, so we don't need to\n    # protect here again.\n    old_stream = self.stream\n    self.stream = sys.stderr\n    try:\n      super(PythonHandler, self).emit(record)\n    finally:\n      self.stream = old_stream", "category": "Python"}, {"instruction": "def backward_delete_char(self, e): # (Rubout)\r\n        u\"\"\"Delete the character behind the cursor. A numeric argument means\r\n        to kill the characters instead of deleting them.\"\"\"\n", "input": "", "output": "        self.l_buffer.backward_delete_char(self.argument_reset)\r\n        self.finalize()", "category": "Python"}, {"instruction": "def find_undeclared_variables(ast):\n    \"\"\"Returns a set of all variables in the AST that will be looked up from\n    the context at runtime.  Because at compile time it's not known which\n    variables will be used depending on the path the execution takes at\n    runtime, all variables are returned.\n\n    >>> from jinja2 import Environment, meta\n    >>> env = Environment()\n    >>> ast = env.parse('{% set foo = 42 %}{{ bar + foo }}')\n    >>> meta.find_undeclared_variables(ast) == set(['bar'])\n    True\n\n    .. admonition:: Implementation\n\n       Internally the code generator is used for finding undeclared variables.\n       This is good to know because the code generator might raise a\n       :exc:`TemplateAssertionError` during compilation and as a matter of\n       fact this function can currently raise that exception as well.\n    \"\"\"\n", "input": "", "output": "    codegen = TrackingCodeGenerator(ast.environment)\n    codegen.visit(ast)\n    return codegen.undeclared_identifiers", "category": "Python"}, {"instruction": "def parse(self, requires_cfg=True):\n        \"\"\"Parse the configuration sources into `Bison`.\n\n        Args:\n            requires_cfg (bool): Specify whether or not parsing should fail\n                if a config file is not found. (default: True)\n        \"\"\"\n", "input": "", "output": "        self._parse_default()\n        self._parse_config(requires_cfg)\n        self._parse_env()", "category": "Python"}, {"instruction": "def clear_jobs():\n    '''Clear old jobs\n\n    :param days: Jobs for how many days should be kept (default: 10)\n    :type days: integer\n\n    :statuscode 200: no error\n    :statuscode 403: not authorized to delete jobs\n    :statuscode 409: an error occurred\n    '''\n", "input": "", "output": "    if not is_authorized():\n        return json.dumps({'error': 'not authorized'}), 403, headers\n\n    days = flask.request.args.get('days', None)\n    return _clear_jobs(days)", "category": "Python"}, {"instruction": "def guest_deploy(self, userid, image_name, transportfiles=None,\n                     remotehost=None, vdev=None, hostname=None):\n        \"\"\" Deploy the image to vm.\n\n        :param userid: (str) the user id of the vm\n        :param image_name: (str) the name of image that used to deploy the vm\n        :param transportfiles: (str) the files that used to customize the vm\n        :param remotehost: the server where the transportfiles located, the\n               format is username@IP, eg nova@192.168.99.1\n        :param vdev: (str) the device that image will be deploy to\n        :param hostname: (str) the hostname of the vm. This parameter will be\n               ignored if transportfiles present.\n        \"\"\"\n", "input": "", "output": "        action = (\"deploy image '%(img)s' to guest '%(vm)s'\" %\n                  {'img': image_name, 'vm': userid})\n        with zvmutils.log_and_reraise_sdkbase_error(action):\n            self._vmops.guest_deploy(userid, image_name, transportfiles,\n                                     remotehost, vdev, hostname)", "category": "Python"}, {"instruction": "def _minimize_constraints_fun_summation(x):\n    '''\n    Minimize constraints fun summation\n    '''\n", "input": "", "output": "    summation = sum([x[i] for i in CONSTRAINT_PARAMS_IDX])\n    return CONSTRAINT_UPPERBOUND >= summation >= CONSTRAINT_LOWERBOUND", "category": "Python"}, {"instruction": "def ws010(self, value=None):\n        \"\"\"  Corresponds to IDD Field `ws010`\n        Wind speed corresponding to 1.0% annual cumulative frequency of occurrence\n\n        Args:\n            value (float): value for IDD Field `ws010`\n                Unit: m/s\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n", "input": "", "output": "        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `ws010`'.format(value))\n\n        self._ws010 = value", "category": "Python"}, {"instruction": "def get_log_events(awsclient, log_group_name, log_stream_name, start_ts=None):\n    \"\"\"Get log events for the specified log group and stream.\n    this is used in tenkai output instance diagnostics\n\n    :param log_group_name: log group name\n    :param log_stream_name: log stream name\n    :param start_ts: timestamp\n    :return:\n    \"\"\"\n", "input": "", "output": "    client_logs = awsclient.get_client('logs')\n\n    request = {\n        'logGroupName': log_group_name,\n        'logStreamName': log_stream_name\n    }\n    if start_ts:\n        request['startTime'] = start_ts\n\n    # TODO exhaust the events!\n    # TODO use all_pages !\n    response = client_logs.get_log_events(**request)\n\n    if 'events' in response and response['events']:\n        return [{'timestamp': e['timestamp'], 'message': e['message']}\n                for e in response['events']]", "category": "Python"}, {"instruction": "def _read_imu(self):\n        \"\"\"\n        Internal. Tries to read the IMU sensor three times before giving up\n        \"\"\"\n", "input": "", "output": "\n        self._init_imu()  # Ensure imu is initialised\n\n        attempts = 0\n        success = False\n\n        while not success and attempts < 3:\n            success = self._imu.IMURead()\n            attempts += 1\n            time.sleep(self._imu_poll_interval)\n\n        return success", "category": "Python"}, {"instruction": "def val(self, strictkey):\n        \"\"\"\n        Return a chunk referencing a value in a mapping with the key 'key'.\n        \"\"\"\n", "input": "", "output": "        ruamelkey = self.ruamelindex(strictkey)\n        return self._select(self._pointer.val(ruamelkey, strictkey))", "category": "Python"}, {"instruction": "def get_name_str(self, element):\n        '''get_name_str\n\n        High-level api: Produce a string that represents the name of a node.\n\n        Parameters\n        ----------\n\n        element : `Element`\n            A node in model tree.\n\n        Returns\n        -------\n\n        str\n            A string that represents the name of a node.\n        '''\n", "input": "", "output": "\n        if element.get('diff') == 'added':\n            return self.model2.get_name_str(element)\n        else:\n            return self.model1.get_name_str(element)", "category": "Python"}, {"instruction": "def next(self):\n        \"\"\"\n        Returns the next sequence of results, given stride and n.\n        \n        \"\"\"\n", "input": "", "output": "        try:\n            results = self._stride_buffer.pop()\n        except (IndexError, AttributeError):\n            self._rebuffer()\n            results = self._stride_buffer.pop()\n        if not results:\n            raise StopIteration\n        return results", "category": "Python"}, {"instruction": "def soup(self):\n        \"\"\"Download the page and create the soup\"\"\"\n", "input": "", "output": "        try:\n            return self._soup\n        except AttributeError:\n            url = client.get_url(\"/presentations/%s\" % self.index)\n            content = self.client.fetch_no_cache(url).decode('utf-8')\n            self._soup = bs4.BeautifulSoup(content, \"html.parser\")\n\n            return self._soup", "category": "Python"}, {"instruction": "def to_xdr_object(self):\n        \"\"\"Creates an XDR Memo object for a transaction with MEMO_RETURN.\"\"\"\n", "input": "", "output": "        return Xdr.types.Memo(\n            type=Xdr.const.MEMO_RETURN, retHash=self.memo_return)", "category": "Python"}, {"instruction": "def _get_current_albedo(self):\n        '''Simple step-function albedo based on ice line at temperature Tf.'''\n", "input": "", "output": "        ice = self.subprocess['iceline'].ice\n        # noice = self.subprocess['iceline'].diagnostics['noice']\n        cold_albedo = self.subprocess['cold_albedo'].albedo\n        warm_albedo = self.subprocess['warm_albedo'].albedo\n        albedo = Field(np.where(ice, cold_albedo, warm_albedo), domain=self.domains['Ts'])\n        return albedo", "category": "Python"}, {"instruction": "def start(self, version=None, **kwargs):#game_version=None, data_version=None, **kwargs):\n    \"\"\"Launch the game process.\"\"\"\n", "input": "", "output": "    if not version:\n        version = self.mostRecentVersion\n    pysc2Version = lib.Version( # convert to pysc2 Version\n        version.version,\n        version.baseVersion,\n        version.dataHash,\n        version.fixedHash)\n    return sc_process.StarcraftProcess(\n                self,\n                exec_path=self.exec_path(version.baseVersion),\n                version=pysc2Version,\n                **kwargs)", "category": "Python"}, {"instruction": "def _searchservices(device, name=None, uuid=None, uuidbad=None):\n    \"\"\"\n    Searches the given IOBluetoothDevice using the specified parameters.\n    Returns an empty list if the device has no services.\n\n    uuid should be IOBluetoothSDPUUID object.\n    \"\"\"\n", "input": "", "output": "    if not isinstance(device, _IOBluetooth.IOBluetoothDevice):\n        raise ValueError(\"device must be IOBluetoothDevice, was %s\" % \\\n            type(device))\n\n    services = []\n    allservices = device.getServices()\n    if uuid:\n        gooduuids = (uuid, )\n    else:\n        gooduuids = ()\n    if uuidbad:\n        baduuids = (uuidbad, )\n    else:\n        baduuids = ()\n\n    if allservices is not None:\n        for s in allservices:\n            if gooduuids and not s.hasServiceFromArray_(gooduuids):\n                continue\n            if baduuids and s.hasServiceFromArray_(baduuids):\n                continue\n            if name is None or s.getServiceName() == name:\n                services.append(s)\n    return services", "category": "Python"}, {"instruction": "def get_raw(self, name=None):\n        '''Shortcut for getting a :class:`~statsd.raw.Raw` instance\n\n        :keyword name: See :func:`~statsd.client.Client.get_client`\n        :type name: str\n        '''\n", "input": "", "output": "        return self.get_client(name=name, class_=statsd.Raw)", "category": "Python"}, {"instruction": "def _make_ntgrid(grid):\n    \"\"\"make a named tuple grid\n\n    [[\"\",  \"a b\", \"b c\", \"c d\"],\n     [\"x y\", 1,     2,     3 ],\n     [\"y z\", 4,     5,     6 ],\n     [\"z z\", 7,     8,     9 ],]\n    will return\n    ntcol(x_y=ntrow(a_b=1, b_c=2, c_d=3),\n          y_z=ntrow(a_b=4, b_c=5, c_d=6),\n          z_z=ntrow(a_b=7, b_c=8, c_d=9))\"\"\"\n", "input": "", "output": "    hnames = [_nospace(n) for n in grid[0][1:]]\n    vnames = [_nospace(row[0]) for row in grid[1:]]\n    vnames_s = \" \".join(vnames)\n    hnames_s = \" \".join(hnames)\n    ntcol = collections.namedtuple('ntcol', vnames_s)\n    ntrow = collections.namedtuple('ntrow', hnames_s)\n    rdict = [dict(list(zip(hnames, row[1:]))) for row in grid[1:]]\n    ntrows = [ntrow(**rdict[i]) for i, name in enumerate(vnames)]\n    ntcols = ntcol(**dict(list(zip(vnames, ntrows))))\n    return ntcols", "category": "Python"}, {"instruction": "def int_out_of_bounds(self, index, axis=0):\n        \"\"\" examples if index is out of local processing bounds\n\n        function is used to perform examples for index of type integer\n        :param index: global index to examples as type int\n        :param axis: current axis to examples\n        :return: return input or raise error\n        \"\"\"\n", "input": "", "output": "        #if index >= self._global_shape[axis]:\n        if index > self._global_shape[axis]:\n            raise IndexError('index is larger than the upper bound')\n\n        # wrap around index if negative like in python\n        if index < 0:\n            index += self._global_shape[axis]\n            #warnings.warn('warp around may occur')\n\n        # check for invalid wrap around\n        if index < 0:\n            raise IndexError('index is smaller than the lower bound')\n\n        return index", "category": "Python"}, {"instruction": "def set_value(self, label, value, takeable=False):\n        \"\"\"\n        Quickly set single value at passed label. If label is not contained, a\n        new object is created with the label placed at the end of the result\n        index\n\n        .. deprecated:: 0.21.0\n\n        Please use .at[] or .iat[] accessors.\n\n        Parameters\n        ----------\n        label : object\n            Partial indexing with MultiIndex not allowed\n        value : object\n            Scalar value\n        takeable : interpret the index as indexers, default False\n\n        Notes\n        -----\n        This method *always* returns a new object. It is not particularly\n        efficient but is provided for API compatibility with Series\n\n        Returns\n        -------\n        series : SparseSeries\n        \"\"\"\n", "input": "", "output": "        warnings.warn(\"set_value is deprecated and will be removed \"\n                      \"in a future release. Please use \"\n                      \".at[] or .iat[] accessors instead\", FutureWarning,\n                      stacklevel=2)\n        return self._set_value(label, value, takeable=takeable)", "category": "Python"}, {"instruction": "def device(self, idx):\n        \"\"\"Get a specific GPU device\n\n        Args:\n            idx: index of device\n\n        Returns:\n            NvidiaDevice: single GPU device\n        \"\"\"\n", "input": "", "output": "\n        class GpuDevice(Structure):\n            pass\n\n        c_nvmlDevice_t = POINTER(GpuDevice)\n\n        c_index = c_uint(idx)\n        device = c_nvmlDevice_t()\n        _check_return(_NVML.get_function(\n            \"nvmlDeviceGetHandleByIndex_v2\")(c_index, byref(device)))\n        return NvidiaDevice(device)", "category": "Python"}, {"instruction": "def _check_pillar_exact_minions(self, expr, delimiter, greedy):\n        '''\n        Return the minions found by looking via pillar\n        '''\n", "input": "", "output": "        return self._check_cache_minions(expr,\n                                         delimiter,\n                                         greedy,\n                                         'pillar',\n                                         exact_match=True)", "category": "Python"}, {"instruction": "def remove_tag(self, tag):\n        \"\"\"Remove a user's tag from this object.\"\"\"\n", "input": "", "output": "\n        if isinstance(tag, Tag):\n            tag = tag.get_name()\n\n        params = self._get_params()\n        params[\"tag\"] = tag\n\n        self._request(self.ws_prefix + \".removeTag\", False, params)", "category": "Python"}, {"instruction": "def _audio_item(self, stream_url=None, offset=0, push_buffer=True, opaque_token=None):\n        \"\"\"Builds an AudioPlayer Directive's audioItem and updates current_stream\"\"\"\n", "input": "", "output": "        audio_item = {'stream': {}}\n        stream = audio_item['stream']\n\n        # existing stream\n        if not stream_url:\n            # stream.update(current_stream.__dict__)\n            stream['url'] = current_stream.url\n            stream['token'] = current_stream.token\n            stream['offsetInMilliseconds'] = current_stream.offsetInMilliseconds\n\n        # new stream\n        else:\n            stream['url'] = stream_url\n            stream['token'] = opaque_token or str(uuid.uuid4())\n            stream['offsetInMilliseconds'] = offset\n\n        if push_buffer:  # prevents enqueued streams from becoming current_stream\n            push_stream(stream_cache, context['System']['user']['userId'], stream)\n        return audio_item", "category": "Python"}, {"instruction": "def commit(self):\n        \"\"\":return: Commit object the tag ref points to\n        \n        :raise ValueError: if the tag points to a tree or blob\"\"\"\n", "input": "", "output": "        obj = self.object\n        while obj.type != 'commit':\n            if obj.type == \"tag\":\n                # it is a tag object which carries the commit as an object - we can point to anything\n                obj = obj.object\n            else:\n                raise ValueError((\"Cannot resolve commit as tag %s points to a %s object - \" +\n                                  \"use the `.object` property instead to access it\") % (self, obj.type))\n        return obj", "category": "Python"}, {"instruction": "def column_reflection_fallback(self):\n        \"\"\"If we can't reflect the table, use a query to at least get column names.\"\"\"\n", "input": "", "output": "        sql = sa.select([sa.text(\"*\")]).select_from(self._table)\n        col_names = self.engine.execute(sql).keys()\n        col_dict = [{'name': col_name} for col_name in col_names]\n        return col_dict", "category": "Python"}, {"instruction": "def dkim_sign(message, dkim_domain=None, dkim_key=None, dkim_selector=None, dkim_headers=None):\n    \"\"\"Return signed email message if dkim package and settings are available.\"\"\"\n", "input": "", "output": "    try:\n        import dkim\n    except ImportError:\n        pass\n    else:\n        if dkim_domain and dkim_key:\n            sig = dkim.sign(message,\n                            dkim_selector,\n                            dkim_domain,\n                            dkim_key,\n                            include_headers=dkim_headers)\n            message = sig + message\n    return message", "category": "Python"}, {"instruction": "def get_tunnel_info_output_tunnel_has_conflicts(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n", "input": "", "output": "        config = ET.Element(\"config\")\n        get_tunnel_info = ET.Element(\"get_tunnel_info\")\n        config = get_tunnel_info\n        output = ET.SubElement(get_tunnel_info, \"output\")\n        tunnel = ET.SubElement(output, \"tunnel\")\n        has_conflicts = ET.SubElement(tunnel, \"has-conflicts\")\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "category": "Python"}, {"instruction": "def task(ft):\n\t\"\"\"\n\tto create loading progress bar\n\t\"\"\"\n", "input": "", "output": "\tft.pack(expand = True,  fill = BOTH,  side = TOP)\n\tpb_hD = ttk.Progressbar(ft, orient = 'horizontal', mode = 'indeterminate')\n\tpb_hD.pack(expand = True, fill = BOTH, side = TOP)\n\tpb_hD.start(50)\n\tft.mainloop()", "category": "Python"}, {"instruction": "def get_header(self, header_name, default=None):\n        \"\"\"Retrieve ``header_name`` from this request headers.\n        \"\"\"\n", "input": "", "output": "        return self.headers.get(\n            header_name, self.unredirected_headers.get(header_name, default))", "category": "Python"}, {"instruction": "def into_buffer(self, buf, offset):\n    \"\"\"Produce a framed/packed SBP message into the provided buffer and offset.\n\n    \"\"\"\n", "input": "", "output": "    self.payload = containerize(exclude_fields(self))\n    self.parser = MsgEphemerisGPSDepF._parser\n    self.stream_payload.reset(buf, offset)\n    return self.pack_into(buf, offset, self._build_payload)", "category": "Python"}, {"instruction": "def parse_event_out(self, node):\n        \"\"\"\n        Parses <EventOut>\n\n        @param node: Node containing the <EventOut> element\n        @type node: xml.etree.Element\n        \"\"\"\n", "input": "", "output": "\n        try:\n            port = node.lattrib['port']\n        except:\n            self.raise_error('<EventOut> must be specify a port.')\n\n        action = EventOut(port)\n\n        self.current_event_handler.add_action(action)", "category": "Python"}, {"instruction": "def list_devices(self):\n        \"\"\"List devices in the ALDB.\"\"\"\n", "input": "", "output": "        if self.plm.devices:\n            for addr in self.plm.devices:\n                device = self.plm.devices[addr]\n                if device.address.is_x10:\n                    _LOGGING.info('Device: %s %s', device.address.human,\n                                  device.description)\n                else:\n                    _LOGGING.info('Device: %s cat: 0x%02x subcat: 0x%02x '\n                                  'desc: %s, model: %s',\n                                  device.address.human, device.cat,\n                                  device.subcat, device.description,\n                                  device.model)\n        else:\n            _LOGGING.info('No devices found')\n            if not self.plm.transport:\n                _LOGGING.info('IM connection has not been made.')\n                _LOGGING.info('Use `connect [device]` to open the connection')", "category": "Python"}, {"instruction": "def contour(c, subsample=1, size=10, color='g'):\n        \"\"\" Draws a contour on the current plot by scattering points.\n\n        Parameters\n        ----------\n        c : :obj:`autolab_core.Contour`\n            contour to draw\n        subsample : int\n            subsample rate for boundary pixels\n        size : int\n            size of scattered points\n        color : :obj:`str`\n            color of box\n        \"\"\"\n", "input": "", "output": "        if not isinstance(c, Contour):\n            raise ValueError('Input must be of type Contour')\n            \n        for i in range(c.num_pixels)[0::subsample]:\n            plt.scatter(c.boundary_pixels[i,1], c.boundary_pixels[i,0], s=size, c=color)", "category": "Python"}, {"instruction": "def aggregate(self, variable, components=None, append=False):\n        \"\"\"Compute the aggregate of timeseries components or sub-categories\n\n        Parameters\n        ----------\n        variable: str\n            variable for which the aggregate should be computed\n        components: list of str, default None\n            list of variables, defaults to all sub-categories of `variable`\n        append: bool, default False\n            append the aggregate timeseries to `data` and return None,\n            else return aggregate timeseries\n        \"\"\"\n", "input": "", "output": "        # default components to all variables one level below `variable`\n        components = components or self._variable_components(variable)\n\n        if not len(components):\n            msg = 'cannot aggregate variable `{}` because it has no components'\n            logger().info(msg.format(variable))\n\n            return\n\n        rows = self._apply_filters(variable=components)\n        _data = _aggregate(self.data[rows], 'variable')\n\n        if append is True:\n            self.append(_data, variable=variable, inplace=True)\n        else:\n            return _data", "category": "Python"}, {"instruction": "def op_gate_of_type(op: raw_types.Operation,\n                    gate_type: Type[TV]) -> Optional[TV]:\n    \"\"\"Returns the gate of given type, if the op has that gate otherwise None.\n    \"\"\"\n", "input": "", "output": "    if isinstance(op, GateOperation) and isinstance(op.gate, gate_type):\n        return op.gate\n    return None", "category": "Python"}, {"instruction": "def apply_log(a: tuple, func: Callable[[Any], Tuple[Any, Log]]) -> Tuple[Any, Log]:\n        \"\"\"Apply a function to a value with a log.\n\n        Helper function to apply a function to a value with a log tuple.\n        \"\"\"\n", "input": "", "output": "        value, log = a\n        new, entry = func(value)\n        return new, log + entry", "category": "Python"}, {"instruction": "def walk_dependencies(root, visitor):\n    \"\"\"\n    Call visitor on root and all dependencies reachable from it in breadth\n    first order.\n\n    Args:\n        root (component): component function or class\n        visitor (function): signature is `func(component, parent)`.  The\n            call on root is `visitor(root, None)`.\n    \"\"\"\n", "input": "", "output": "    def visit(parent, visitor):\n        for d in get_dependencies(parent):\n            visitor(d, parent)\n            visit(d, visitor)\n\n    visitor(root, None)\n    visit(root, visitor)", "category": "Python"}, {"instruction": "def _pydevd_log(level, msg, *args):\n    '''\n    Levels are:\n\n    0 most serious warnings/errors (always printed)\n    1 warnings/significant events\n    2 informational trace\n    3 verbose mode\n    '''\n", "input": "", "output": "    if level <= DebugInfoHolder.DEBUG_TRACE_LEVEL:\n        # yes, we can have errors printing if the console of the program has been finished (and we're still trying to print something)\n        try:\n            try:\n                if args:\n                    msg = msg % args\n            except:\n                msg = '%s - %s' % (msg, args)\n            DebugInfoHolder.DEBUG_STREAM.write('%s\\n' % (msg,))\n            DebugInfoHolder.DEBUG_STREAM.flush()\n        except:\n            pass\n        return True", "category": "Python"}, {"instruction": "def draw_random(obj, **kwds):\n    \"\"\"Draw random variates from obj.random method.\n\n    If the object has parents whose value must be updated, use\n    parent_name=trace_generator_function.\n\n    Ex:\n    R = draw_random(theta, beta=pymc.utils.trace_generator(beta.trace))\n    R.next()\n    \"\"\"\n", "input": "", "output": "    while True:\n        for k, v in six.iteritems(kwds):\n            obj.parents[k] = v.next()\n        yield obj.random()", "category": "Python"}, {"instruction": "def id(self, value):\n        \"\"\"Split into server_and_prefix and identifier.\"\"\"\n", "input": "", "output": "        i = value.rfind('/')\n        if (i > 0):\n            self.server_and_prefix = value[:i]\n            self.identifier = value[(i + 1):]\n        elif (i == 0):\n            self.server_and_prefix = ''\n            self.identifier = value[(i + 1):]\n        else:\n            self.server_and_prefix = ''\n            self.identifier = value", "category": "Python"}, {"instruction": "def logger(self):\n        ''' Lazy logger '''\n", "input": "", "output": "        if self.__logger is None:\n            self.__logger = logging.getLogger(self.__name)\n        return self.__logger", "category": "Python"}, {"instruction": "def SetQualifier(self, *args, **kwargs):\n        \"\"\"Create or modify a qualifier type in the local repository of this\n        class.\n\n        For a description of the parameters, see\n        :meth:`pywbem.WBEMConnection.SetQualifier`.\n        \"\"\"\n", "input": "", "output": "\n        qual = args[0] if args else kwargs['QualifierDeclaration']\n        try:\n            self.qualifiers[self.default_namespace][qual.name] = qual\n        except KeyError:\n            self.qualifiers[self.default_namespace] = \\\n                NocaseDict({qual.name: qual})", "category": "Python"}, {"instruction": "def get_report(session, vehicle_index):\n    \"\"\"Get vehicle health report summary.\"\"\"\n", "input": "", "output": "    vhr = get_vehicle_health_report(session, vehicle_index)\n    if 'reportCard' not in vhr:\n        raise MoparError(\"no vhr found\")\n    return _traverse_report(vhr['reportCard'])", "category": "Python"}, {"instruction": "def assertFileSizeAlmostEqual(\n            self, filename, size, places=None, msg=None, delta=None):\n        '''Fail if ``filename`` does not have the given ``size`` as\n        determined by their difference rounded to the given number of\n        decimal ``places`` (default 7) and comparing to zero, or if\n        their difference is greater than a given ``delta``.\n\n        Parameters\n        ----------\n        filename : str, bytes, file-like\n        size : int, float\n        places : int\n        msg : str\n            If not provided, the :mod:`marbles.mixins` or\n            :mod:`unittest` standard message will be used.\n        delta : int, float\n\n        Raises\n        ------\n        TypeError\n            If ``filename`` is not a str or bytes object and is not\n            file-like.\n        '''\n", "input": "", "output": "        fsize = self._get_file_size(filename)\n        self.assertAlmostEqual(\n                fsize, size, places=places, msg=msg, delta=delta)", "category": "Python"}, {"instruction": "def trace_integrations(integrations, tracer=None):\n    \"\"\"Enable tracing on the selected integrations.\n    :type integrations: list\n    :param integrations: The integrations to be traced.\n    \"\"\"\n", "input": "", "output": "    integrated = []\n\n    for item in integrations:\n        module_name = 'opencensus.ext.{}.trace'.format(item)\n        try:\n            module = importlib.import_module(module_name)\n            module.trace_integration(tracer=tracer)\n            integrated.append(item)\n        except Exception as e:\n            log.warning('Failed to integrate module: {}'.format(module_name))\n            log.warning('{}'.format(e))\n\n    return integrated", "category": "Python"}, {"instruction": "def calculate_cardinality(\n        angle,\n        earthquake_hazard=None,\n        place_exposure=None\n):\n    \"\"\"Simple postprocessor where we compute the cardinality of an angle.\n\n    :param angle: Bearing angle.\n    :type angle: float\n\n    :param earthquake_hazard: The hazard to use.\n    :type earthquake_hazard: str\n\n    :param place_exposure: The exposure to use.\n    :type place_exposure: str\n\n    :return: Cardinality text.\n    :rtype: str\n    \"\"\"\n", "input": "", "output": "    # this method could still be improved later, since the acquisition interval\n    # is a bit strange, i.e the input angle of 22.499\u00b0 will return `N` even\n    # though 22.5\u00b0 is the direction for `NNE`\n    _ = earthquake_hazard, place_exposure  # NOQA\n\n    direction_list = tr(\n        'N,NNE,NE,ENE,E,ESE,SE,SSE,S,SSW,SW,WSW,W,WNW,NW,NNW'\n    ).split(',')\n\n    bearing = float(angle)\n    direction_count = len(direction_list)\n    direction_interval = 360. / direction_count\n    index = int(floor(bearing / direction_interval))\n    index %= direction_count\n    return direction_list[index]", "category": "Python"}, {"instruction": "def ReadCronJobs(self, cronjob_ids=None, cursor=None):\n    \"\"\"Reads all cronjobs from the database.\"\"\"\n", "input": "", "output": "    query = (\"SELECT job, UNIX_TIMESTAMP(create_time), enabled, \"\n             \"forced_run_requested, last_run_status, \"\n             \"UNIX_TIMESTAMP(last_run_time), current_run_id, state, \"\n             \"UNIX_TIMESTAMP(leased_until), leased_by \"\n             \"FROM cron_jobs\")\n    if cronjob_ids is None:\n      cursor.execute(query)\n      return [self._CronJobFromRow(row) for row in cursor.fetchall()]\n\n    query += \" WHERE job_id IN (%s)\" % \", \".join([\"%s\"] * len(cronjob_ids))\n    cursor.execute(query, cronjob_ids)\n    res = []\n    for row in cursor.fetchall():\n      res.append(self._CronJobFromRow(row))\n\n    if len(res) != len(cronjob_ids):\n      missing = set(cronjob_ids) - set([c.cron_job_id for c in res])\n      raise db.UnknownCronJobError(\"CronJob(s) with id(s) %s not found.\" %\n                                   missing)\n    return res", "category": "Python"}, {"instruction": "def _time_to_datetime(value):\n  \"\"\"Convert a time to a datetime for Cloud Datastore storage.\n\n  Args:\n    value: A datetime.time object.\n\n  Returns:\n    A datetime object with date set to 1970-01-01.\n  \"\"\"\n", "input": "", "output": "  if not isinstance(value, datetime.time):\n    raise TypeError('Cannot convert to datetime expected time value; '\n                    'received %s' % value)\n  return datetime.datetime(1970, 1, 1,\n                           value.hour, value.minute, value.second,\n                           value.microsecond)", "category": "Python"}, {"instruction": "def get_behaviors(brain_or_object):\n    \"\"\"Iterate over all behaviors that are assigned to the object\n\n    :param brain_or_object: A single catalog brain or content object\n    :type brain_or_object: ATContentType/DexterityContentType/CatalogBrain\n    :returns: Behaviors\n    :rtype: list\n    \"\"\"\n", "input": "", "output": "    obj = get_object(brain_or_object)\n    if not is_dexterity_content(obj):\n        fail(400, \"Only Dexterity contents can have assigned behaviors\")\n    assignable = IBehaviorAssignable(obj, None)\n    if not assignable:\n        return {}\n    out = {}\n    for behavior in assignable.enumerateBehaviors():\n        for name, field in getFields(behavior.interface).items():\n            out[name] = field\n    return out", "category": "Python"}, {"instruction": "def contains(value: Union[str, 'Type']) -> bool:\n        \"\"\" Checks if a type is defined \"\"\"\n", "input": "", "output": "        if isinstance(value, str):\n            return any(value.lower() == i.value for i in Type)\n\n        return any(value == i for i in Type)", "category": "Python"}, {"instruction": "def set_gid(self):\n        \"\"\"Change the group of the running process\"\"\"\n", "input": "", "output": "        if self.group:\n            gid = getgrnam(self.group).gr_gid\n            try:\n                os.setgid(gid)\n            except Exception:\n                message = (\"Unable to switch ownership to {0}:{1}. \" +\n                           \"Did you start the daemon as root?\")\n                print(message.format(self.user, self.group))\n                sys.exit(1)", "category": "Python"}, {"instruction": "def defaultMachine(use_rpm_default=True):\n    \"\"\" Return the canonicalized machine name. \"\"\"\n", "input": "", "output": "\n    if use_rpm_default:\n        try:\n            # This should be the most reliable way to get the default arch\n            rmachine = subprocess.check_output(['rpm', '--eval=%_target_cpu'], shell=False).rstrip()\n            rmachine = SCons.Util.to_str(rmachine)\n        except Exception as e:\n            # Something went wrong, try again by looking up platform.machine()\n            return defaultMachine(False)\n    else:\n        rmachine = platform.machine()\n\n        # Try to lookup the string in the canon table\n        if rmachine in arch_canon:\n            rmachine = arch_canon[rmachine][0]\n\n    return rmachine", "category": "Python"}, {"instruction": "def get_users_in_organization(self, organization_id, start=0, limit=50):\n        \"\"\"\n        Get all the users of a specified organization\n\n        :param organization_id: str\n        :param start: OPTIONAL: int\n        :param limit: OPTIONAL: int\n        :return: Users list in organization\n        \"\"\"\n", "input": "", "output": "        url = 'rest/servicedeskapi/organization/{}/user'.format(organization_id)\n        params = {}\n        if start is not None:\n            params['start'] = int(start)\n        if limit is not None:\n            params['limit'] = int(limit)\n\n        return self.get(url, headers=self.experimental_headers, params=params)", "category": "Python"}, {"instruction": "def list_courses(args):\n    \"\"\"\n    List enrolled courses.\n\n    @param args: Command-line arguments.\n    @type args: namedtuple\n    \"\"\"\n", "input": "", "output": "    session = get_session()\n    login(session, args.username, args.password)\n    extractor = CourseraExtractor(session)\n    courses = extractor.list_courses()\n    logging.info('Found %d courses', len(courses))\n    for course in courses:\n        logging.info(course)", "category": "Python"}, {"instruction": "def add(self, *constraints: Tuple[Bool]) -> None:\n        \"\"\"Adds the constraints to this solver.\n\n        :param constraints: constraints to add\n        \"\"\"\n", "input": "", "output": "        raw_constraints = [\n            c.raw for c in cast(Tuple[Bool], constraints)\n        ]  # type: List[z3.BoolRef]\n        self.constraints.extend(raw_constraints)", "category": "Python"}, {"instruction": "def every_other(x, name=None):\n  \"\"\"Drops every other value from the tensor and returns a 1D tensor.\n\n  This is useful if you are running multiple inputs through a model tower\n  before splitting them and you want to line it up with some other data.\n\n  Args:\n    x: the target tensor.\n    name: the name for this op, defaults to every_other\n  Returns:\n    A tensorflow op.\n  \"\"\"\n", "input": "", "output": "  with tf.name_scope(name, 'every_other', [x]) as scope:\n    x = tf.convert_to_tensor(x, name='x')\n    return tf.reshape(\n        tf.slice(\n            tf.reshape(x, [-1, 2]), [0, 0], [-1, 1]),\n        [-1],\n        name=scope)", "category": "Python"}, {"instruction": "def fetch( hash ):\n    \"\"\"\n    Fetches CallDescriptor from the local database given a hash key representing the call. If it doesn't exist returns None.\n\n    :param str hash: The sha1 hexdigest to look the CallDescriptor up by.\n\n    :rtype: CallDescriptor corresponding to the hash passed or None if it wasn't found.\n    \"\"\"\n", "input": "", "output": "    res = select_io( hash )\n\n    if res:\n      p = { 'methodname': '', 'returnval': '', 'args': '', 'stack': '' }\n      for packet in res:\n        hash, stack, methodname, returnval, args, packet_num = packet\n        p['methodname'] = p['methodname'] + methodname\n        p['returnval']  = p['returnval'] + returnval\n        p['args']       = p['args'] + args\n        p['stack']      = p['stack'] + stack\n                             \n      return CallDescriptor( hash = hash,\n                             stack = p['stack'],\n                             method = p['methodname'],\n                             returnval = pickle.loads( str( p['returnval'] ) ),\n                             args = pickle.loads( str( p['args'] ) ) )\n    return None", "category": "Python"}, {"instruction": "def install_language(language):\n    \"\"\"Install translation service routines into default namespace.\"\"\"\n", "input": "", "output": "    translator = get_translator(default_domain, default_directory,\n        languages=[get_lang(language)], fallback=True)\n    do_unicode = True\n    translator.install(do_unicode)", "category": "Python"}, {"instruction": "def view(self, filename=None, directory=None, cleanup=False):\n        \"\"\"Save the source to file, open the rendered result in a viewer.\n\n        Args:\n            filename: Filename for saving the source (defaults to ``name`` + ``'.gv'``)\n            directory: (Sub)directory for source saving and rendering.\n            cleanup (bool): Delete the source file after rendering.\n        Returns:\n            The (possibly relative) path of the rendered file.\n        Raises:\n            graphviz.ExecutableNotFound: If the Graphviz executable is not found.\n            subprocess.CalledProcessError: If the exit status is non-zero.\n            RuntimeError: If opening the viewer is not supported.\n\n        Short-cut method for calling :meth:`.render` with ``view=True``.\n        \"\"\"\n", "input": "", "output": "        return self.render(filename=filename, directory=directory, view=True,\n                           cleanup=cleanup)", "category": "Python"}, {"instruction": "def experiments_fmri_upsert_property(self, experiment_id, properties):\n        \"\"\"Upsert property of fMRI data object associated with given experiment.\n\n        Raises ValueError if given property dictionary results in an illegal\n        operation.\n\n        Parameters\n        ----------\n        experiment_id : string\n            Unique experiment identifier\n        properties : Dictionary()\n            Dictionary of property names and their new values.\n\n        Returns\n        -------\n        FMRIDataHandle\n            Handle for updated object of None if object doesn't exist\n        \"\"\"\n", "input": "", "output": "        # Get experiment fMRI to ensure that it exists. Needed to get fMRI\n        # data object identifier for given experiment identifier\n        fmri = self.experiments_fmri_get(experiment_id)\n        if fmri is None:\n            return None\n        # Update properties for fMRI object using the object identifier\n        return self.funcdata.upsert_object_property(fmri.identifier, properties)", "category": "Python"}, {"instruction": "async def create_scene(self, room_id, name, color_id=0, icon_id=0):\n        \"\"\"Creates am empty scene.\n\n        Scenemembers need to be added after the scene has been created.\n\n        :returns: A json object including scene id.\n        \"\"\"\n", "input": "", "output": "        name = unicode_to_base64(name)\n        _data = {\n            \"scene\": {\n                ATTR_ROOM_ID: room_id,\n                ATTR_NAME: name,\n                ATTR_COLOR_ID: color_id,\n                ATTR_ICON_ID: icon_id,\n            }\n        }\n        _response = await self.request.post(self._base_path, data=_data)\n        return _response", "category": "Python"}, {"instruction": "def get_grade_system_gradebook_assignment_session(self, proxy):\n        \"\"\"Gets the session for assigning grade system to gradebook mappings.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.grading.GradeSystemGradebookSession) - a\n                ``GradeSystemGradebookAssignmentSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_grade_system_gradebook_assignment()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_grade_system_gradebook_assignment()`` is ``true``.*\n\n        \"\"\"\n", "input": "", "output": "        if not self.supports_grade_system_gradebook_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradeSystemGradebookAssignmentSession(proxy=proxy, runtime=self._runtime)", "category": "Python"}, {"instruction": "def _detect_available_configs():\n        \"\"\"\n        Returns all currently used channels as well as\n        one other currently unused channel.\n\n        .. note::\n\n            This method will run into problems if thousands of\n            autodetected busses are used at once.\n\n        \"\"\"\n", "input": "", "output": "        with channels_lock:\n            available_channels = list(channels.keys())\n\n        # find a currently unused channel\n        get_extra = lambda: \"channel-{}\".format(randint(0, 9999))\n        extra = get_extra()\n        while extra in available_channels:\n            extra = get_extra()\n\n        available_channels += [extra]\n\n        return [\n            {'interface': 'virtual', 'channel': channel}\n            for channel in available_channels\n        ]", "category": "Python"}, {"instruction": "def projection_box(self, min_x, min_y, max_x, max_y):\n        \"\"\"Add a bounding box in projected (native) coordinates to the query.\n\n        This adds a request for a spatial bounding box, bounded by (`min_x`, `max_x`) for\n        x direction and (`min_y`, `max_y`) for the y direction. This modifies the query\n        in-place, but returns ``self`` so that multiple queries can be chained together\n        on one line.\n\n        This replaces any existing spatial queries that have been set.\n\n        Parameters\n        ----------\n        min_x : float\n            The left edge of the bounding box\n        min_y : float\n            The bottom edge of the bounding box\n        max_x : float\n            The right edge of the bounding box\n        max_y: float\n            The top edge of the bounding box\n\n        Returns\n        -------\n        self : NCSSQuery\n            Returns self for chaining calls\n\n        \"\"\"\n", "input": "", "output": "        self._set_query(self.spatial_query, minx=min_x, miny=min_y,\n                        maxx=max_x, maxy=max_y)\n        return self", "category": "Python"}, {"instruction": "def path_pieces(vault_path):\n    \"\"\"Will return a two part tuple comprising of the vault path\n    and the key with in the stored object\"\"\"\n", "input": "", "output": "    path_bits = vault_path.split('/')\n    path = '/'.join(path_bits[0:len(path_bits) - 1])\n    key = path_bits[len(path_bits) - 1]\n    return path, key", "category": "Python"}, {"instruction": "def negotiate_safe(self, name, params):\n        \"\"\"\n        `name` and `params` are sent in the HTTP request by the client. Check\n        if the extension name is supported by this extension, and validate the\n        parameters. Returns a dict with accepted parameters, or None if not\n        accepted.\n        \"\"\"\n", "input": "", "output": "        for param in params.iterkeys():\n            if param not in self.defaults:\n                return\n\n        try:\n            return dict(self.negotiate(name, params))\n        except (KeyError, ValueError, AssertionError):\n            pass", "category": "Python"}, {"instruction": "def submit(self, func, *args, **kwargs):\n        \"\"\"Submit a function for serialized execution on sqs\n        \"\"\"\n", "input": "", "output": "        self.op_sequence += 1\n        self.sqs.send_message(\n            QueueUrl=self.map_queue,\n            MessageBody=utils.dumps({'args': args, 'kwargs': kwargs}),\n            MessageAttributes={\n                'sequence_id': {\n                    'StringValue': str(self.op_sequence),\n                    'DataType': 'Number'},\n                'op': {\n                    'StringValue': named(func),\n                    'DataType': 'String',\n                },\n                'ser': {\n                    'StringValue': 'json',\n                    'DataType': 'String'}}\n        )\n\n        self.futures[self.op_sequence] = f = SQSFuture(\n            self.op_sequence)\n        return f", "category": "Python"}, {"instruction": "def nominal_step(x=None):\n    \"\"\"Return nominal step\"\"\"\n", "input": "", "output": "    if x is None:\n        return 1.0\n    return np.log1p(np.abs(x)).clip(min=1.0)", "category": "Python"}, {"instruction": "def _GetFileSystemCacheIdentifier(self, path_spec):\n    \"\"\"Determines the file system cache identifier for the path specification.\n\n    Args:\n      path_spec (PathSpec): path specification.\n\n    Returns:\n      str: identifier of the VFS object.\n    \"\"\"\n", "input": "", "output": "    string_parts = []\n\n    string_parts.append(getattr(path_spec.parent, 'comparable', ''))\n    string_parts.append('type: {0:s}'.format(path_spec.type_indicator))\n\n    return ''.join(string_parts)", "category": "Python"}, {"instruction": "def compute_rewards(self, scores):\n        \"\"\"Compute the velocity of the best scores\n\n        The velocities are the k distances between the k+1 best scores.\n        \"\"\"\n", "input": "", "output": "        k = self.k\n        m = max(len(scores) - k, 0)\n        best_scores = sorted(scores)[-k - 1:]\n        velocities = np.diff(best_scores)\n        nans = np.full(m, np.nan)\n        return list(velocities) + list(nans)", "category": "Python"}, {"instruction": "def _handle_clear(self, load):\n        '''\n        Process a cleartext command\n\n        :param dict load: Cleartext payload\n        :return: The result of passing the load to a function in ClearFuncs corresponding to\n                 the command specified in the load's 'cmd' key.\n        '''\n", "input": "", "output": "        log.trace('Clear payload received with command %s', load['cmd'])\n        cmd = load['cmd']\n        if cmd.startswith('__'):\n            return False\n        if self.opts['master_stats']:\n            start = time.time()\n        ret = getattr(self.clear_funcs, cmd)(load), {'fun': 'send_clear'}\n        if self.opts['master_stats']:\n            stats = salt.utils.event.update_stats(self.stats, start, load)\n            self._post_stats(stats)\n        return ret", "category": "Python"}, {"instruction": "def _NTU_from_P_solver(P1, R1, NTU_min, NTU_max, function, **kwargs):\n    '''Private function to solve the P-NTU method backwards, given the\n    function to use, the upper and lower NTU bounds for consideration,\n    and the desired P1 and R1 values.\n    '''\n", "input": "", "output": "    P1_max = _NTU_from_P_objective(NTU_max, R1, 0, function, **kwargs)\n    P1_min = _NTU_from_P_objective(NTU_min, R1, 0, function, **kwargs)\n    if P1 > P1_max:\n        raise ValueError('No solution possible gives such a high P1; maximum P1=%f at NTU1=%f' %(P1_max, NTU_max))\n    if P1 < P1_min:\n        raise ValueError('No solution possible gives such a low P1; minimum P1=%f at NTU1=%f' %(P1_min, NTU_min))\n    # Construct the function as a lambda expression as solvers don't support kwargs\n    to_solve = lambda NTU1: _NTU_from_P_objective(NTU1, R1, P1, function, **kwargs)\n    return ridder(to_solve, NTU_min, NTU_max)", "category": "Python"}, {"instruction": "def to_np(*args):\n    \"\"\" convert GPU arras to numpy and return them\"\"\"\n", "input": "", "output": "    if len(args) > 1:\n        return (cp.asnumpy(x) for x in args)\n    else:\n        return cp.asnumpy(args[0])", "category": "Python"}, {"instruction": "def copy(self):\n        \"\"\"\n        Returns a copy of the datamat.\n        \"\"\"\n", "input": "", "output": "        return self.filter(np.ones(self._num_fix).astype(bool))", "category": "Python"}, {"instruction": "def truncate(self, percentage):\n        \"\"\"\n        Truncate ``percentage`` / 2 [%] of whole time from first and last time.\n\n        :param float percentage: Percentage of truncate.\n\n        :Sample Code:\n            .. code:: python\n\n                from datetimerange import DateTimeRange\n                time_range = DateTimeRange(\n                    \"2015-03-22T10:00:00+0900\", \"2015-03-22T10:10:00+0900\")\n                time_range.is_output_elapse = True\n                print(time_range)\n                time_range.truncate(10)\n                print(time_range)\n        :Output:\n            .. parsed-literal::\n\n                2015-03-22T10:00:00+0900 - 2015-03-22T10:10:00+0900 (0:10:00)\n                2015-03-22T10:00:30+0900 - 2015-03-22T10:09:30+0900 (0:09:00)\n        \"\"\"\n", "input": "", "output": "\n        self.validate_time_inversion()\n\n        if percentage < 0:\n            raise ValueError(\"discard_percent must be greater or equal to zero: \" + str(percentage))\n\n        if percentage == 0:\n            return\n\n        discard_time = self.timedelta // int(100) * int(percentage / 2)\n\n        self.__start_datetime += discard_time\n        self.__end_datetime -= discard_time", "category": "Python"}, {"instruction": "def send(self, data):\n        \"\"\"\n        Sends data to the server.\n        \"\"\"\n", "input": "", "output": "        self.logger.debug('Send data: {}'.format(data))\n\n        if not self.connected:\n            self.logger.warning('Connection not established. Return...')\n            return\n\n        self.websocket.send(json.dumps(data))", "category": "Python"}, {"instruction": "def _findLocation(self, reference_name, start, end):\n        \"\"\"\n        return a location key form the locationMap\n        \"\"\"\n", "input": "", "output": "        try:\n            # TODO - sequence_annotations does not have build?\n            return self._locationMap['hg19'][reference_name][start][end]\n        except:\n            return None", "category": "Python"}, {"instruction": "def next(self):\n        \"\"\"Returns the next batch of data.\"\"\"\n", "input": "", "output": "        if not self.iter_next():\n            raise StopIteration\n        data = self.getdata()\n        label = self.getlabel()\n        # iter should stop when last batch is not complete\n        if data[0].shape[0] != self.batch_size:\n        # in this case, cache it for next epoch\n            self._cache_data = data\n            self._cache_label = label\n            raise StopIteration\n        return DataBatch(data=data, label=label, \\\n            pad=self.getpad(), index=None)", "category": "Python"}, {"instruction": "def bartlett(timeseries, segmentlength, noverlap=None, window=None, plan=None):\n    # pylint: disable=unused-argument\n    \"\"\"Calculate an PSD of this `TimeSeries` using Bartlett's method\n\n    Parameters\n    ----------\n    timeseries : `~gwpy.timeseries.TimeSeries`\n        input `TimeSeries` data.\n\n    segmentlength : `int`\n        number of samples in single average.\n\n    noverlap : `int`\n        number of samples to overlap between segments, defaults to 50%.\n\n    window : `tuple`, `str`, optional\n        window parameters to apply to timeseries prior to FFT\n\n    plan : `REAL8FFTPlan`, optional\n        LAL FFT plan to use when generating average spectrum\n\n    Returns\n    -------\n    spectrum : `~gwpy.frequencyseries.FrequencySeries`\n        average power `FrequencySeries`\n\n    See also\n    --------\n    lal.REAL8AverageSpectrumWelch\n    \"\"\"\n", "input": "", "output": "    return _lal_spectrum(timeseries, segmentlength, noverlap=0,\n                         method='welch', window=window, plan=plan)", "category": "Python"}, {"instruction": "def instance_path_for(name, identifier_type, identifier_key=None):\n    \"\"\"\n    Get a path for thing.\n\n    \"\"\"\n", "input": "", "output": "    return \"/{}/<{}:{}>\".format(\n        name_for(name),\n        identifier_type,\n        identifier_key or \"{}_id\".format(name_for(name)),\n    )", "category": "Python"}, {"instruction": "def _find_tpls(self, name):\n        \"\"\"\n        Return plain, html templates for NAME\n\n        Arguments:\n        - `name`: str\n\n        Return: tuple\n        Exceptions: None\n        \"\"\"\n", "input": "", "output": "        return self._find_tpl(name, extension='.txt'), self._find_tpl(name, extension='.html')", "category": "Python"}, {"instruction": "def get_default_query_from_module(module):\n  \"\"\" Given a %%sql module return the default (last) query for the module.\n\n  Args:\n    module: the %%sql module.\n\n  Returns:\n    The default query associated with this module.\n  \"\"\"\n", "input": "", "output": "  if isinstance(module, types.ModuleType):\n    return module.__dict__.get(_SQL_MODULE_LAST, None)\n  return None", "category": "Python"}, {"instruction": "def _get_method(self, rdata):\n        \"\"\"\n        Returns jsonrpc request's method value.\n\n        InvalidRequestError will be raised if it's missing or is wrong type.\n        MethodNotFoundError will be raised if a method with given method name\n        does not exist.\n        \"\"\"\n", "input": "", "output": "        if 'method' in rdata:\n            if not isinstance(rdata['method'], basestring):\n                raise InvalidRequestError\n        else:\n            raise InvalidRequestError\n\n        if rdata['method'] not in self.method_data.keys():\n            raise MethodNotFoundError\n\n        return rdata['method']", "category": "Python"}, {"instruction": "def visit(self, node):\n        '''The main visit function. Visits the passed-in node and calls\n        finalize.\n        '''\n", "input": "", "output": "        for token in self.itervisit(node):\n            pass\n        result = self.finalize()\n        if result is not self:\n            return result", "category": "Python"}, {"instruction": "def freeze_subjects(self):\n        \"\"\"Converts variable data into numpy arrays.\n\n        This is required after all subjects have been added via the\n        add_subject function, since we don't know ahead of time who is\n        participating in the analysis due to various filtering possibilities.\n        \"\"\"\n", "input": "", "output": "        self.phenotype_data = numpy.array(self.phenotype_data)\n        self.covariate_data = numpy.array(self.covariate_data)", "category": "Python"}, {"instruction": "def _field_sort_name(cls, name):\n        \"\"\"Get a sort key for a field name that determines the order\n        fields should be written in.\n\n        Fields names are kept unchanged, unless they are instances of\n        :class:`DateItemField`, in which case `year`, `month`, and `day`\n        are replaced by `date0`, `date1`, and `date2`, respectively, to\n        make them appear in that order.\n        \"\"\"\n", "input": "", "output": "        if isinstance(cls.__dict__[name], DateItemField):\n            name = re.sub('year',  'date0', name)\n            name = re.sub('month', 'date1', name)\n            name = re.sub('day',   'date2', name)\n        return name", "category": "Python"}, {"instruction": "def indexTupleFromItem(self, treeItem): # TODO: move to BaseTreeItem?\n        \"\"\" Return (first column model index, last column model index) tuple for a configTreeItem\n        \"\"\"\n", "input": "", "output": "        if not treeItem:\n            return (QtCore.QModelIndex(), QtCore.QModelIndex())\n\n        if not treeItem.parentItem: # TODO: only necessary because of childNumber?\n            return (QtCore.QModelIndex(), QtCore.QModelIndex())\n\n        # Is there a bug in Qt in QStandardItemModel::indexFromItem?\n        # It passes the parent in createIndex. TODO: investigate\n\n        row =  treeItem.childNumber()\n        return (self.createIndex(row, 0, treeItem),\n                self.createIndex(row, self.columnCount() - 1, treeItem))", "category": "Python"}, {"instruction": "def log_request(self, code='-', size='-'):\n        \"\"\"Logs the current request.\"\"\"\n", "input": "", "output": "        print_size = getattr(thread_local, 'size', -1)\n        if size != '-':\n            size_str = ' (%s)' % size\n        elif print_size >= 0:\n            size_str = self.log_size_string(print_size) + ' '\n        else:\n            size_str = ''\n        if not self.server.suppress_noise or (code != 200 and code != 304):\n            self.log_message(\n                '%s\"%s\" %s', size_str, self.requestline, str(code))\n        if print_size >= 0:\n            thread_local.size = -1", "category": "Python"}, {"instruction": "def to_protobuf(self):\n        \"\"\"Convert the current object to protobuf.\n\n        :rtype: :class:`google.type.latlng_pb2.LatLng`.\n        :returns: The current point as a protobuf.\n        \"\"\"\n", "input": "", "output": "        return latlng_pb2.LatLng(latitude=self.latitude, longitude=self.longitude)", "category": "Python"}, {"instruction": "def incidental (self):\n        \"\"\" Returns incidental properties.\n        \"\"\"\n", "input": "", "output": "        result = [p for p in self.lazy_properties if p.feature.incidental]\n        result.extend(self.incidental_)\n        return result", "category": "Python"}, {"instruction": "def set_volume(self, volume):\n        \"\"\"Set a new volume level.\"\"\"\n", "input": "", "output": "        if volume > 100 or volume < 0:\n            raise Exception('Bad request to volume control. '\n                            'Must be between 0 and 100')\n        params = ('<InstanceID>0</InstanceID><Channel>Master</Channel>'\n                  '<DesiredVolume>{}</DesiredVolume>').format(volume)\n        self.soap_request(URL_CONTROL_DMR, URN_RENDERING_CONTROL,\n                          'SetVolume', params)", "category": "Python"}, {"instruction": "def Axn(mt, x, n):\n    \"\"\" (A^1)x:n : Returns the EPV (net single premium) of a term insurance. \"\"\"\n", "input": "", "output": "    return (mt.Mx[x] - mt.Mx[x + n]) / mt.Dx[x]", "category": "Python"}, {"instruction": "def _aix_memdata():\n    '''\n    Return the memory information for AIX systems\n    '''\n", "input": "", "output": "    grains = {'mem_total': 0, 'swap_total': 0}\n    prtconf = salt.utils.path.which('prtconf')\n    if prtconf:\n        for line in __salt__['cmd.run'](prtconf, python_shell=True).splitlines():\n            comps = [x for x in line.strip().split(' ') if x]\n            if len(comps) > 2 and 'Memory' in comps[0] and 'Size' in comps[1]:\n                grains['mem_total'] = int(comps[2])\n                break\n    else:\n        log.error('The \\'prtconf\\' binary was not found in $PATH.')\n\n    swap_cmd = salt.utils.path.which('swap')\n    if swap_cmd:\n        swap_data = __salt__['cmd.run']('{0} -s'.format(swap_cmd)).split()\n        try:\n            swap_total = (int(swap_data[-2]) + int(swap_data[-6])) * 4\n        except ValueError:\n            swap_total = None\n        grains['swap_total'] = swap_total\n    else:\n        log.error('The \\'swap\\' binary was not found in $PATH.')\n    return grains", "category": "Python"}, {"instruction": "def initialize_segment_register_x64(self, state, concrete_target):\n        \"\"\"\n        Set the fs register in the angr to the value of the fs register in the concrete process\n\n        :param state:               state which will be modified\n        :param concrete_target:     concrete target that will be used to read the fs register\n        :return: None\n        \"\"\"\n", "input": "", "output": "        _l.debug(\"Synchronizing fs segment register\")\n        state.regs.fs = self._read_fs_register_x64(concrete_target)", "category": "Python"}, {"instruction": "def mutation(self, config=None, info=None, save_dir=None):\n        \"\"\"\n        Parameters\n        ----------\n        config : str\n        info : str\n        save_dir : str\n        \"\"\"\n", "input": "", "output": "        self.result = None\n        self.config = config\n        self.restore_dir = self.save_dir\n        self.save_dir = save_dir\n        self.info = info", "category": "Python"}, {"instruction": "def entityId(self, partial, channel=None):\n        '''Get an entity's full id provided a partial one.\n\n        Raises EntityNotFound if partial cannot be resolved.\n        @param partial The partial id (e.g. mysql, precise/mysql).\n        @param channel Optional channel name.\n        '''\n", "input": "", "output": "        url = '{}/{}/meta/any'.format(self.url, _get_path(partial))\n        data = self._get(_add_channel(url, channel))\n        return data.json()['Id']", "category": "Python"}, {"instruction": "def chown(self, path, uid, gid):\n        \"\"\"\n        Change the owner (``uid``) and group (``gid``) of a file.  As with\n        Python's `os.chown` function, you must pass both arguments, so if you\n        only want to change one, use `stat` first to retrieve the current\n        owner and group.\n\n        :param str path: path of the file to change the owner and group of\n        :param int uid: new owner's uid\n        :param int gid: new group id\n        \"\"\"\n", "input": "", "output": "        path = self._adjust_cwd(path)\n        self._log(DEBUG, \"chown({!r}, {!r}, {!r})\".format(path, uid, gid))\n        attr = SFTPAttributes()\n        attr.st_uid, attr.st_gid = uid, gid\n        self._request(CMD_SETSTAT, path, attr)", "category": "Python"}, {"instruction": "def get_expanded_schema(self, schema_name):\n        \"\"\"\n        Return a schema file with all $ref properties expanded\n        \"\"\"\n", "input": "", "output": "        if schema_name not in self.expanded_schemas:\n            fn = self.get_schema_file(schema_name)\n            schemas_folder = self.get_schemas_folder()\n            base_uri = self.get_schema_path(schemas_folder)\n\n            with open(fn) as f:\n                jsn_schema = jsonref.load(f, base_uri=base_uri)\n\n                # cache the schema for future use\n                self.expanded_schemas[schema_name] = jsn_schema\n        else:\n            jsn_schema = self.expanded_schemas[schema_name]\n\n        return jsn_schema", "category": "Python"}, {"instruction": "def short_hash(*buffers):\n    \"\"\"\n    :param buffer: a binary buffer (e.g. serialized blob)\n    :return: the first 8 characters of base64 ASCII rendition SHA-1\n    \"\"\"\n", "input": "", "output": "    hashed = hashlib.sha1()\n    for buffer in buffers:\n        hashed.update(buffer)\n    return to_ascii(hashed.digest())[:8]", "category": "Python"}, {"instruction": "def as_rgb(self):\n        \"\"\"\n        Return a color palette with RGB values instead of hex codes.\n        \"\"\"\n", "input": "", "output": "        rgb = [mpl.colors.colorConverter.to_rgb(hex) for hex in self]\n        return ColorPalette(rgb)", "category": "Python"}, {"instruction": "def _add_chrome_proxy_extension(\n        chrome_options, proxy_string, proxy_user, proxy_pass):\n    \"\"\" Implementation of https://stackoverflow.com/a/35293284 for\n        https://stackoverflow.com/questions/12848327/\n        (Run Selenium on a proxy server that requires authentication.) \"\"\"\n", "input": "", "output": "    if not \"\".join(sys.argv) == \"-c\":\n        # Single-threaded\n        proxy_helper.create_proxy_zip(proxy_string, proxy_user, proxy_pass)\n    else:\n        # Pytest multi-threaded test\n        lock = threading.Lock()\n        with lock:\n            time.sleep(random.uniform(0.02, 0.15))\n            if not os.path.exists(PROXY_ZIP_PATH):\n                proxy_helper.create_proxy_zip(\n                    proxy_string, proxy_user, proxy_pass)\n            time.sleep(random.uniform(0.1, 0.2))\n    proxy_zip = PROXY_ZIP_PATH\n    if not os.path.exists(PROXY_ZIP_PATH):\n        # Handle \"Permission denied\" on the default proxy.zip path\n        proxy_zip = PROXY_ZIP_PATH_2\n    chrome_options.add_extension(proxy_zip)\n    return chrome_options", "category": "Python"}, {"instruction": "def _init_prtfmt(self, key=\"fmta\"):\n        \"\"\"Return print format for Grouper, which includes hdr1usr01 and num_usrgos.\"\"\"\n", "input": "", "output": "        prtfmt = self.gosubdag.prt_attr[key]\n        return prtfmt.replace(\"{NS}\", \"{NS} {hdr1usr01:2} {num_usrgos:>4} uGOs\")", "category": "Python"}, {"instruction": "def parent(self):\n        \"\"\"\n        Select the direct child(ren) from the UI element(s) given by the query expression, see ``QueryCondition`` for\n        more details about the selectors.\n\n        Warnings:\n            Experimental method, may not be available for all drivers.\n\n        Returns:\n            :py:class:`UIObjectProxy <poco.proxy.UIObjectProxy>`: a new UI proxy object representing the direct parent\n            of the first UI element.\n        \"\"\"\n", "input": "", "output": "\n        sub_query = build_query(None)  # as placeholder\n        query = ('^', (self.query, sub_query))\n        obj = UIObjectProxy(self.poco)\n        obj.query = query\n        return obj", "category": "Python"}, {"instruction": "def get_qemu_info(path, backing_chain=False, fail_on_error=True):\n    \"\"\"\n    Get info on a given qemu disk\n\n    Args:\n        path(str): Path to the required disk\n        backing_chain(boo): if true, include also info about\n        the image predecessors.\n    Return:\n        object: if backing_chain == True then a list of dicts else a dict\n    \"\"\"\n", "input": "", "output": "\n    cmd = ['qemu-img', 'info', '--output=json', path]\n\n    if backing_chain:\n        cmd.insert(-1, '--backing-chain')\n\n    result = run_command_with_validation(\n        cmd, fail_on_error, msg='Failed to get info for {}'.format(path)\n    )\n\n    return json.loads(result.out)", "category": "Python"}, {"instruction": "def consume(self, chars, min=0, max=-1):\n        \"\"\"\n        Consume chars until min/max is satisfied is valid.\n        \"\"\"\n", "input": "", "output": "        return self._src.consume(chars=chars, min=min, max=max)", "category": "Python"}, {"instruction": "def _parse(cls, data, key=None):\n        \"\"\"\n        Parse a set of data to extract entity-only data.\n\n        Use classmethod `parse` if available, otherwise use the `endpoint`\n        class variable to extract data from a data blob.\n        \"\"\"\n", "input": "", "output": "        parse = cls.parse if cls.parse is not None else cls.get_endpoint()\n\n        if callable(parse):\n            data = parse(data)\n        elif isinstance(parse, str):\n            data = data[key]\n        else:\n            raise Exception('\"parse\" should be a callable or string got, {0}'\n                            .format(parse))\n        return data", "category": "Python"}, {"instruction": "def camelcase_to_slash(name):\n    \"\"\" Converts CamelCase to camel/case\n\n    code ripped from http://stackoverflow.com/questions/1175208/does-the-python-standard-library-have-function-to-convert-camelcase-to-camel-cas\n    \"\"\"\n", "input": "", "output": "\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1/\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1/\\2', s1).lower()", "category": "Python"}, {"instruction": "def kunc_dPdV(v, v0, k0, k0p, order=5, precision=1.e-5):\n    \"\"\"\n    calculate dP/dV for numerical calculation of bulk modulus\n    according to test this differs from analytical result by 1.e-5\n\n    :param v: unit-cell volume in A^3\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param k0: bulk modulus at reference conditions\n    :param k0p: pressure derivative of bulk modulus at reference conditions\n    :param precision: precision for numerical calc (default = 1.e-5 * v0)\n    :return: dP/dV\n    \"\"\"\n", "input": "", "output": "    def f_scalar(v, v0, k0, k0p, order=order, precision=1.e-5):\n        return derivative(kunc_p, v, args=(v0, k0, k0p, order),\n                          dx=v0 * precision)\n    f_v = np.vectorize(f_scalar, excluded=[1, 2, 3, 4, 5])\n    return f_v(v, v0, k0, k0p, order=order, precision=precision)", "category": "Python"}, {"instruction": "def get_inters_direct(r, L, R_cut):\n    '''\n    Return points within a given cut-off of each other,\n    in a periodic system.\n\n    Uses a direct algorithm, which may be very slow for large numbers of\n    points.\n\n    Parameters\n    ----------\n    r: array, shape (n, d) where d is one of (2, 3).\n        A set of n point coordinates.\n        Coordinates are assumed to lie in [-L / 2, L / 2].\n    L: float.\n        Bounds of the system.\n    R_cut: float.\n        The maximum distance within which to consider points to lie\n        near each other.\n\n    Returns\n    -------\n    inters: array, shape (n, n)\n        Indices of the nearby points.\n        For each particle indexed by the first axis,\n        the second axis lists each index of a nearby point.\n    intersi: array, shape (n,)\n        Total number of nearby points.\n        This array should be used to index `inters`, as for point `i`,\n        elements in `inters[i]` beyond `intersi[i]` have no well-defined value.\n    '''\n", "input": "", "output": "    _cell_list.cell_list_direct.make_inters(r.T, L, R_cut)\n    return _parse_inters()", "category": "Python"}, {"instruction": "def col(s, c, bg=0, no_reset=0):\n    \"\"\"\n    print col('foo', 124) -> red 'foo' on the terminal\n    c = color, s the value to colorize \"\"\"\n", "input": "", "output": "    reset = reset_col\n    if no_reset:\n        reset = ''\n    for _strt, _end, _col in ((code_start, code_end, H2),\n                              (stng_start, stng_end, H2),\n                              (emph_start, emph_end, H3)):\n        if _strt in s:\n            # inline code:\n            s = s.replace(_strt, col('', _col, bg=background, no_reset=1))\n            s = s.replace(_end , col('', c, no_reset=1))\n\n    s =  '\\033[38;5;%sm%s%s' % (c, s, reset)\n    if bg:\n        pass\n        #s = col_bg(bg) + s\n    return s", "category": "Python"}, {"instruction": "def retreive_sigma_mu_data(self):\n        \"\"\"\n        For the general form of the GMPE this retrieves the sigma mu\n        values from the hdf5 file using the \"general\" model, i.e. sigma mu\n        factors that are independent of the choice of region or depth\n        \"\"\"\n", "input": "", "output": "        fle = h5py.File(os.path.join(BASE_PATH,\n                                     \"KothaEtAl2019_SigmaMu_Fixed.hdf5\"), \"r\")\n        self.mags = fle[\"M\"][:]\n        self.dists = fle[\"R\"][:]\n        self.periods = fle[\"T\"][:]\n        self.pga = fle[\"PGA\"][:]\n        self.pgv = fle[\"PGV\"][:]\n        self.s_a = fle[\"SA\"][:]\n        fle.close()", "category": "Python"}, {"instruction": "def runGetVariant(self, id_):\n        \"\"\"\n        Returns a variant with the given id\n        \"\"\"\n", "input": "", "output": "        compoundId = datamodel.VariantCompoundId.parse(id_)\n        dataset = self.getDataRepository().getDataset(compoundId.dataset_id)\n        variantSet = dataset.getVariantSet(compoundId.variant_set_id)\n        gaVariant = variantSet.getVariant(compoundId)\n        # TODO variant is a special case here, as it's returning a\n        # protocol element rather than a datamodel object. We should\n        # fix this for consistency.\n        jsonString = protocol.toJson(gaVariant)\n        return jsonString", "category": "Python"}, {"instruction": "def folderitems(self, full_objects=False, classic=True):\n        \"\"\"Sort by Categories\n        \"\"\"\n", "input": "", "output": "        bsc = getToolByName(self.context, \"bika_setup_catalog\")\n        self.an_cats = bsc(\n            portal_type=\"AnalysisCategory\",\n            sort_on=\"sortable_title\")\n        self.an_cats_order = dict([\n            (b.Title, \"{:04}\".format(a))\n            for a, b in enumerate(self.an_cats)])\n        items = super(AnalysisServicesView, self).folderitems()\n        if self.do_cats:\n            self.categories = map(lambda x: x[0],\n                                  sorted(self.categories, key=lambda x: x[1]))\n        else:\n            self.categories.sort()\n        return items", "category": "Python"}, {"instruction": "def _check_bounds(self, v):\n        \"\"\"Check which values are out of bounds.\n\n        Raises\n        ------\n        ValueError:\n\n        \"\"\"\n", "input": "", "output": "        below_bounds = v < self._x[0]\n        above_bounds = v > self._x[-1]\n\n        if self.bounds_error and below_bounds.any():\n            raise ValueError(\"A value in x_new is below the interpolation \"\n                \"range.\")\n        if self.bounds_error and above_bounds.any():\n            raise ValueError(\"A value in x_new is above the interpolation \"\n                \"range.\")\n\n        return below_bounds, above_bounds", "category": "Python"}, {"instruction": "def update_firmware(self,\n                        hardware_id,\n                        ipmi=True,\n                        raid_controller=True,\n                        bios=True,\n                        hard_drive=True):\n        \"\"\"Update hardware firmware.\n\n        This will cause the server to be unavailable for ~20 minutes.\n\n        :param int hardware_id: The ID of the hardware to have its firmware\n                                updated.\n        :param bool ipmi: Update the ipmi firmware.\n        :param bool raid_controller: Update the raid controller firmware.\n        :param bool bios: Update the bios firmware.\n        :param bool hard_drive: Update the hard drive firmware.\n\n        Example::\n\n            # Check the servers active transactions to see progress\n            result = mgr.update_firmware(hardware_id=1234)\n        \"\"\"\n", "input": "", "output": "\n        return self.hardware.createFirmwareUpdateTransaction(\n            bool(ipmi), bool(raid_controller), bool(bios), bool(hard_drive), id=hardware_id)", "category": "Python"}, {"instruction": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of AllTimeInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.usage.record.all_time.AllTimeInstance\n        :rtype: twilio.rest.api.v2010.account.usage.record.all_time.AllTimeInstance\n        \"\"\"\n", "input": "", "output": "        return AllTimeInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "category": "Python"}, {"instruction": "def reply(self, connection, reply, orig_req):\n        \"\"\"Send an asynchronous reply to an earlier request.\n\n        Parameters\n        ----------\n        connection : ClientConnection object\n            The client to send the reply to.\n        reply : Message object\n            The reply message to send.\n        orig_req : Message object\n            The request message being replied to. The reply message's\n            id is overridden with the id from orig_req before the\n            reply is sent.\n\n        \"\"\"\n", "input": "", "output": "        if isinstance(connection, ClientRequestConnection):\n            self._logger.warn(\n                'Deprecation warning: do not use self.reply() '\n                'within a reply handler context -- use req.reply(*msg_args)\\n'\n                'or req.reply_with_message(msg) Traceback:\\n %s',\n                \"\".join(traceback.format_stack()))\n            # Get the underlying ClientConnection instance\n            connection = connection.client_connection\n        connection.reply(reply, orig_req)", "category": "Python"}, {"instruction": "def cancel_port_forward(self, address, port):\n        \"\"\"\n        Ask the server to cancel a previous port-forwarding request.  No more\n        connections to the given address & port will be forwarded across this\n        ssh connection.\n\n        :param str address: the address to stop forwarding\n        :param int port: the port to stop forwarding\n        \"\"\"\n", "input": "", "output": "        if not self.active:\n            return\n        self._tcp_handler = None\n        self.global_request(\"cancel-tcpip-forward\", (address, port), wait=True)", "category": "Python"}, {"instruction": "def add(self, tool):\n        \"\"\"\n        Adds a Tool to the list, logs the reference and TODO\n        \"\"\"\n", "input": "", "output": "        self.lstTools.append(tool)\n        self.lg.record_process(self._get_tool_str(tool))", "category": "Python"}, {"instruction": "def contains_rigid(self):\n        \"\"\"Returns True if the Compound contains rigid bodies\n\n        If the Compound contains any particle with a rigid_id != None\n        then contains_rigid will return True. If the Compound has no\n        children (i.e. the Compound resides at the bottom of the containment\n        hierarchy) then contains_rigid will return False.\n\n        Returns\n        -------\n        bool\n            True if the Compound contains any particle with a rigid_id != None\n\n        Notes\n        -----\n        The private variable '_check_if_contains_rigid_bodies' is used to help\n        cache the status of 'contains_rigid'. If '_check_if_contains_rigid_bodies'\n        is False, then the rigid body containment of the Compound has not changed,\n        and the particle tree is not traversed, boosting performance.\n\n        \"\"\"\n", "input": "", "output": "        if self._check_if_contains_rigid_bodies:\n            self._check_if_contains_rigid_bodies = False\n            if any(particle.rigid_id is not None for particle in self._particles()):\n                self._contains_rigid = True\n            else:\n                self._contains_rigid = False\n        return self._contains_rigid", "category": "Python"}, {"instruction": "def has_gap_in_elf_shndx(self):\n        \"\"\"Return the has gap in elf shndx attribute of the BFD file being\n        processed.\n        \"\"\"\n", "input": "", "output": "        if not self._ptr:\n            raise BfdException(\"BFD not initialized\")\n\n        return _bfd.get_bfd_attribute(\n            self._ptr, BfdAttributes.HAS_GAP_IN_ELF_SHNDX)", "category": "Python"}, {"instruction": "def build_params(self, params, i):\n        \"\"\"\n        Populates a dictionary with the name/value pairs necessary\n        to identify this Tag in a request.\n        \"\"\"\n", "input": "", "output": "        prefix = 'Tags.member.%d.' % i\n        params[prefix+'ResourceId'] = self.resource_id\n        params[prefix+'ResourceType'] = self.resource_type\n        params[prefix+'Key'] = self.key\n        params[prefix+'Value'] = self.value\n        if self.propagate_at_launch:\n            params[prefix+'PropagateAtLaunch'] = 'true'\n        else:\n            params[prefix+'PropagateAtLaunch'] = 'false'", "category": "Python"}, {"instruction": "def issue_date(self):\n        \"\"\"Date when the DOI was issued (:class:`datetime.datetime.Datetime`).\n        \"\"\"\n", "input": "", "output": "        dates = _pluralize(self._r['dates'], 'date')\n        for date in dates:\n            if date['@dateType'] == 'Issued':\n                return datetime.datetime.strptime(date['#text'], '%Y-%m-%d')", "category": "Python"}, {"instruction": "def is_multisig_script(script, blockchain='bitcoin', **blockchain_opts):\n    \"\"\"\n    Is the given script a multisig script?\n    \"\"\"\n", "input": "", "output": "    if blockchain == 'bitcoin':\n        return btc_is_multisig_script(script, **blockchain_opts)\n    else:\n        raise ValueError('Unknown blockchain \"{}\"'.format(blockchain))", "category": "Python"}, {"instruction": "def request_generic(self, act, coro, perform, complete):\r\n        \"\"\"\r\n        Performs an overlapped request (via `perform` callable) and saves\r\n        the token and the (`overlapped`, `perform`, `complete`) trio.\r\n        \"\"\"\n", "input": "", "output": "        overlapped = OVERLAPPED()\r\n        overlapped.object = act\r\n        self.add_token(act, coro, (overlapped, perform, complete))\r\n\r\n        rc, nbytes = perform(act, overlapped)\r\n        completion_key = c_long(0)\r\n        if rc == 0:\r\n            # ah geez, it didn't got in the iocp, we have a result!\r\n            pass\r\n\r\n\r\n            # ok this is weird, apparently this doesn't need to be requeued\r\n            #  - need to investigate why (TODO)\r\n            #~ PostQueuedCompletionStatus(\r\n                #~ self.iocp, # HANDLE CompletionPort\r\n                #~ nbytes, # DWORD dwNumberOfBytesTransferred\r\n                #~ byref(completion_key), # ULONG_PTR dwCompletionKey\r\n                #~ overlapped # LPOVERLAPPED lpOverlapped\r\n            #~ )\r\n        elif rc != WSA_IO_PENDING:\r\n            self.remove_token(act)\r\n            raise SocketError(rc, \"%s on %r\" % (ctypes.FormatError(rc), act))", "category": "Python"}, {"instruction": "def get_odoo_args(self, ctx):\n        \"\"\"Return a list of Odoo command line arguments from the Click context.\"\"\"\n", "input": "", "output": "        config = ctx.params.get(\"config\")\n        addons_path = ctx.params.get(\"addons_path\")\n        database = ctx.params.get(\"database\")\n        log_level = ctx.params.get(\"log_level\")\n        logfile = ctx.params.get(\"logfile\")\n\n        odoo_args = []\n\n        if config:\n            odoo_args.extend([\"--config\", config])\n        if addons_path:\n            odoo_args.extend([\"--addons-path\", addons_path])\n        if database:\n            odoo_args.extend([\"--database\", database])\n        if log_level:\n            odoo_args.extend([\"--log-level\", log_level])\n        if logfile:\n            odoo_args.extend([\"--logfile\", logfile])\n\n        return odoo_args", "category": "Python"}, {"instruction": "def extract_files_from_dict(d):\n    \"\"\"Return any file objects from the provided dict.\n\n    >>> extract_files_from_dict({\n    ... 'oauth_token': 'foo',\n    ... 'track': {\n    ...   'title': 'bar',\n    ...   'asset_data': open('setup.py', 'rb')\n    ...  }})  # doctest:+ELLIPSIS\n    {'track': {'asset_data': <...}}\n    \"\"\"\n", "input": "", "output": "    files = {}\n    for key, value in six.iteritems(d):\n        if isinstance(value, dict):\n            files[key] = extract_files_from_dict(value)\n        elif is_file_like(value):\n            files[key] = value\n    return files", "category": "Python"}, {"instruction": "async def async_init(self):\n        \"\"\"\n        Handle here the asynchronous part of the init.\n        \"\"\"\n", "input": "", "output": "\n        self.pool = await aioredis.create_pool(\n            (self.host, self.port),\n            db=self.db_id,\n            minsize=self.min_pool_size,\n            maxsize=self.max_pool_size,\n            loop=asyncio.get_event_loop(),\n        )", "category": "Python"}, {"instruction": "def _get_netengine_arguments(self, required=False):\n        \"\"\"\n        returns list of available config params\n        returns list of required config params if required is True\n        for internal use only\n        \"\"\"\n", "input": "", "output": "        # inspect netengine class\n        backend_class = self._get_netengine_backend()\n        argspec = inspect.getargspec(backend_class.__init__)\n        # store args\n        args = argspec.args\n        # remove known arguments\n        for argument_name in ['self', 'host', 'port']:\n            args.remove(argument_name)\n\n        if required:\n            # list of default values\n            default_values = list(argspec.defaults)\n            # always remove last default value, which is port number\n            default_values = default_values[0:-1]\n\n            # remove an amount of arguments equals to number of default values, starting from right\n            args = args[0:len(args)-len(default_values)]\n\n        return args", "category": "Python"}, {"instruction": "def links(self, r_server=None, mask=None):\n        \"\"\"\n        Get LINKS information.\n        Optional arguments:\n        * r_server=None - Forward the query to this server.\n        * mask=None - Match mask servers.\n        \"\"\"\n", "input": "", "output": "        with self.lock:\n            if not r_server:\n                self.send('LINKS')\n            elif not mask and r_server:\n                self.send('LINKS %s' % r_server)\n            else:\n                self.send('LINKS %s %s' % (r_server, mask))\n            links = {}\n            while self.readable():\n                msg = self._recv(expected_replies=('364', '365'))\n                segments = msg[2].split()\n                if msg[0] == '364':\n                    server = segments[0]\n                    desc = ' '.join(segments[3:])\n                    links[server] = desc\n                elif msg[0] == '365':\n                    break\n            return links", "category": "Python"}, {"instruction": "def get_flat_models_from_models(models: Sequence[Type['main.BaseModel']]) -> Set[Type['main.BaseModel']]:\n    \"\"\"\n    Take a list of ``models`` and generate a set with them and all their sub-models in their trees. I.e. if you pass\n    a list of two models, ``Foo`` and ``Bar``, both subclasses of Pydantic ``BaseModel`` as models, and ``Bar`` has\n    a field of type ``Baz`` (also subclass of ``BaseModel``), the return value will be ``set([Foo, Bar, Baz])``.\n    \"\"\"\n", "input": "", "output": "    flat_models: Set[Type['main.BaseModel']] = set()\n    for model in models:\n        flat_models |= get_flat_models_from_model(model)\n    return flat_models", "category": "Python"}, {"instruction": "def add_slices(self, dashboard_id):\n        \"\"\"Add and save slices to a dashboard\"\"\"\n", "input": "", "output": "        data = json.loads(request.form.get('data'))\n        session = db.session()\n        Slice = models.Slice  # noqa\n        dash = (\n            session.query(models.Dashboard).filter_by(id=dashboard_id).first())\n        check_ownership(dash, raise_if_false=True)\n        new_slices = session.query(Slice).filter(\n            Slice.id.in_(data['slice_ids']))\n        dash.slices += new_slices\n        session.merge(dash)\n        session.commit()\n        session.close()\n        return 'SLICES ADDED'", "category": "Python"}, {"instruction": "def set(self, name, value):\n        \"\"\"\n        Sets the value of the field `name` to `value`, which is `True` or\n        `False`.\n        \"\"\"\n", "input": "", "output": "        flag = self.flags[name]\n        self._value = (self.value | flag) if value else (self.value & ~flag)", "category": "Python"}, {"instruction": "def filter(self, record):\n        \"\"\"Add contextual information to the log record\n\n        :param record: the log record\n        :type record: :class:`logging.LogRecord`\n        :returns: True, if log should get sent\n        :rtype: :class:`bool`\n        :raises: None\n        \"\"\"\n", "input": "", "output": "        record.sitename = self.sitename\n        record.platform = self.platform\n        record.jobid = self.jobid\n        record.submitter = self.logname\n        record.jobname = self.jobname\n        record.queue = self.queue\n        record.fqdn = self.fqdn\n        return True", "category": "Python"}, {"instruction": "def get_config_env() -> Dict[str, Any]:\n    \"\"\"\n    Returns the environment map that will be used for config checking when variables aren't set.\n    \"\"\"\n", "input": "", "output": "    if 'PULUMI_CONFIG' in os.environ:\n        env_config = os.environ['PULUMI_CONFIG']\n        return json.loads(env_config)\n    return dict()", "category": "Python"}, {"instruction": "def i18n_system_locale():\n    \"\"\"\n    Return the system locale\n    :return: the system locale (as a string)\n    \"\"\"\n", "input": "", "output": "    log.debug('i18n_system_locale() called')\n    lc, encoding = locale.getlocale()\n    log.debug('locale.getlocale() = (lc=\"{lc}\", encoding=\"{encoding}).'.format(lc=lc, encoding=encoding))\n    if lc is None:\n        lc, encoding = locale.getdefaultlocale()\n        log.debug('locale.getdefaultlocale() = (lc=\"{lc}\", encoding=\"{encoding}).'.format(lc=lc, encoding=encoding))\n    return lc", "category": "Python"}, {"instruction": "def _int(ctx, number):\n    \"\"\"\n    Rounds a number down to the nearest integer\n    \"\"\"\n", "input": "", "output": "    return conversions.to_integer(conversions.to_decimal(number, ctx).to_integral_value(ROUND_FLOOR), ctx)", "category": "Python"}, {"instruction": "def evaluate(self, x, y, flux, x_0, y_0, sigma):\n        \"\"\"Model function Gaussian PSF model.\"\"\"\n", "input": "", "output": "\n        return (flux / 4 *\n                ((self._erf((x - x_0 + 0.5) / (np.sqrt(2) * sigma)) -\n                  self._erf((x - x_0 - 0.5) / (np.sqrt(2) * sigma))) *\n                 (self._erf((y - y_0 + 0.5) / (np.sqrt(2) * sigma)) -\n                  self._erf((y - y_0 - 0.5) / (np.sqrt(2) * sigma)))))", "category": "Python"}, {"instruction": "def getSubtotal(self):\n        \"\"\" Compute Subtotal \"\"\"\n", "input": "", "output": "        if self.supplyorder_lineitems:\n            return sum(\n                [(Decimal(obj['Quantity']) * Decimal(obj['Price'])) for obj in self.supplyorder_lineitems])\n        return 0", "category": "Python"}, {"instruction": "def decode_hparams(overrides=\"\"):\n  \"\"\"Hparams for decoding.\"\"\"\n", "input": "", "output": "  hparams = decoding.decode_hparams()\n  # Number of interpolations between [0.0, 1.0].\n  hparams.add_hparam(\"num_interp\", 11)\n  # Which level(s) to interpolate.\n  hparams.add_hparam(\"level_interp\", [0, 1, 2])\n  # \"all\" or \"ranked\", interpolate all channels or a \"ranked\".\n  hparams.add_hparam(\"channel_interp\", \"all\")\n  # interpolate channels ranked according to squared L2 norm.\n  hparams.add_hparam(\"rank_interp\", 1)\n  # Whether on not to save frames as summaries\n  hparams.add_hparam(\"save_frames\", True)\n  hparams.parse(overrides)\n  return hparams", "category": "Python"}, {"instruction": "def is_parent_of(page1, page2):\n    \"\"\"\n    Determines whether a given page is the parent of another page\n\n    Example::\n\n        {% if page|is_parent_of:feincms_page %} ... {% endif %}\n    \"\"\"\n", "input": "", "output": "\n    try:\n        return page1.tree_id == page2.tree_id and page1.lft < page2.lft and page1.rght > page2.rght\n    except AttributeError:\n        return False", "category": "Python"}, {"instruction": "def incr(self, key, delta=1):\n        \"\"\"Increments the specified key value by the specified value.\n       \n        :param str|unicode key:\n    \n        :param int delta:\n\n        :rtype: bool\n        \"\"\"\n", "input": "", "output": "        return uwsgi.cache_inc(key, delta, self.timeout, self.name)", "category": "Python"}, {"instruction": "def initialize_media_descriptor(self) -> None:\n        \"\"\"\n        Returns the media descriptor for the first media descriptor where\n        the file can be found.\n        \"\"\"\n", "input": "", "output": "\n        for md in self.media_descriptors:\n            media_path = self.get_media_path(md)\n            if media_path.is_file():\n                self.media_descriptor = md\n                return\n\n        raise FileNotFoundError(\n            ", "category": "Python"}, {"instruction": "def update(self, cardconnection, ccevent):\n        '''CardConnectionObserver callback.'''\n", "input": "", "output": "\n        apduline = \"\"\n        if 'connect' == ccevent.type:\n            apduline += 'connecting to ' + cardconnection.getReader()\n\n        elif 'disconnect' == ccevent.type:\n            apduline += 'disconnecting from ' + cardconnection.getReader()\n\n        elif 'command' == ccevent.type:\n            apduline += '> ' + toHexString(ccevent.args[0])\n\n        elif 'response' == ccevent.type:\n            if [] == ccevent.args[0]:\n                apduline += \"< %-2X %-2X\" % tuple(ccevent.args[-2:])\n            else:\n                apduline += \"< \" + toHexString(ccevent.args[0]) + \\\n                            \"%-2X %-2X\" % tuple(ccevent.args[-2:])\n\n        self.apdutextctrl.AppendText(apduline + \"\\n\")", "category": "Python"}, {"instruction": "def iter(self, name):\n        '''\n        Iterate through values added with add() from each scope frame.\n        '''\n", "input": "", "output": "        for frame in self.frames:\n            vals = frame.get(name)\n            if vals is None:\n                continue\n            for valu in vals:\n                yield valu", "category": "Python"}, {"instruction": "def args(self, args):\n        '''Set additional arguments to be passed to the fitness function\n\n        Args:\n            args (dict): additional arguments\n        '''\n", "input": "", "output": "        self._args = args\n        self._logger.log('debug', 'Args set to {}'.format(args))", "category": "Python"}, {"instruction": "def _parse_contract(self, player_info):\n        \"\"\"\n        Parse the player's contract.\n\n        Depending on the player's contract status, a contract table is located\n        at the bottom of the stats page and includes player wages by season. If\n        found, create a dictionary housing the wages by season.\n\n        Parameters\n        ----------\n        player_info : PyQuery object\n            A PyQuery object containing the HTML from the player's stats page.\n        \"\"\"\n", "input": "", "output": "        contract = {}\n\n        salary_table = player_info('table#br-salaries')\n        for row in salary_table('tbody tr').items():\n            if 'class=\"spacer partial_table\"' in str(row):\n                continue\n            year = row('th[data-stat=\"year_ID\"]').text()\n            if year.strip() == '':\n                continue\n            age = row('td[data-stat=\"age\"]').text()\n            team = self._parse_team_name(str(row('td[data-stat=\"team_name\"]')))\n            salary = row('td[data-stat=\"Salary\"]').text()\n            contract[year] = {\n                'age': age,\n                'team': team,\n                'salary': salary\n            }\n        setattr(self, '_contract', contract)", "category": "Python"}, {"instruction": "def update(self, new_email_address, name, access_level, password=None):\n        \"\"\"Updates the details for a person. Password is optional and is only updated if supplied.\"\"\"\n", "input": "", "output": "        params = {\"email\": self.email_address}\n        body = {\n            \"EmailAddress\": new_email_address,\n            \"Name\": name,\n            \"AccessLevel\": access_level,\n            \"Password\": password}\n        response = self._put(\"/clients/%s/people.json\" % self.client_id,\n                             body=json.dumps(body), params=params)\n        # Update self.email_address, so this object can continue to be used\n        # reliably\n        self.email_address = new_email_address", "category": "Python"}, {"instruction": "def dump(self, raw=False):\n        ''' Dump all output currently in the arm's output queue. '''\n", "input": "", "output": "        raw_out = self.ser.read(self.ser.in_waiting)\n        if raw:\n            return raw_out\n        return raw_out.decode(OUTPUT_ENCODING)", "category": "Python"}, {"instruction": "def error_map_source(self, kwargs_source, x_grid, y_grid, cov_param):\n        \"\"\"\n        variance of the linear source reconstruction in the source plane coordinates,\n        computed by the diagonal elements of the covariance matrix of the source reconstruction as a sum of the errors\n        of the basis set.\n\n        :param kwargs_source: keyword arguments of source model\n        :param x_grid: x-axis of positions to compute error map\n        :param y_grid: y-axis of positions to compute error map\n        :param cov_param: covariance matrix of liner inversion parameters\n        :return: diagonal covariance errors at the positions (x_grid, y_grid)\n        \"\"\"\n", "input": "", "output": "\n        error_map = np.zeros_like(x_grid)\n        basis_functions, n_source = self.SourceModel.functions_split(x_grid, y_grid, kwargs_source)\n        basis_functions = np.array(basis_functions)\n\n        if cov_param is not None:\n            for i in range(len(error_map)):\n                error_map[i] = basis_functions[:, i].T.dot(cov_param[:n_source, :n_source]).dot(basis_functions[:, i])\n        return error_map", "category": "Python"}, {"instruction": "def SerializeExclusiveData(self, writer):\n        \"\"\"\n        Serialize object.\n\n        Args:\n            writer (neo.IO.BinaryWriter):\n        \"\"\"\n", "input": "", "output": "        writer.WriteVarBytes(self.Script)\n        if self.Version >= 1:\n            writer.WriteFixed8(self.Gas)", "category": "Python"}, {"instruction": "def delete_minion_cachedir(minion_id, provider, opts, base=None):\n    '''\n    Deletes a minion's entry from the cloud cachedir. It will search through\n    all cachedirs to find the minion's cache file.\n    Needs `update_cachedir` set to True.\n    '''\n", "input": "", "output": "    if isinstance(opts, dict):\n        __opts__.update(opts)\n\n    if __opts__.get('update_cachedir', False) is False:\n        return\n\n    if base is None:\n        base = __opts__['cachedir']\n\n    driver = next(six.iterkeys(__opts__['providers'][provider]))\n    fname = '{0}.p'.format(minion_id)\n    for cachedir in 'requested', 'active':\n        path = os.path.join(base, cachedir, driver, provider, fname)\n        log.debug('path: %s', path)\n        if os.path.exists(path):\n            os.remove(path)", "category": "Python"}, {"instruction": "def collapse_all(self):\n        \"\"\"Collapse all items.\"\"\"\n", "input": "", "output": "\n        def aux(item):\n            self.item(item, open=False)\n            children = self.get_children(item)\n            for c in children:\n                aux(c)\n\n        children = self.get_children(\"\")\n        for c in children:\n            aux(c)", "category": "Python"}, {"instruction": "def _datasets_line(args):\n  \"\"\"Implements the BigQuery datasets magic used to display datasets in a project.\n\n   The supported syntax is:\n\n       %bigquery datasets [-f <filter>] [-p|--project <project_id>]\n\n  Args:\n    args: the arguments following '%bigquery datasets'.\n  Returns:\n    The HTML rendering for the table of datasets.\n  \"\"\"\n", "input": "", "output": "  filter_ = args['filter'] if args['filter'] else '*'\n  return _render_list([str(dataset) for dataset in datalab.bigquery.Datasets(args['project'])\n                       if fnmatch.fnmatch(str(dataset), filter_)])", "category": "Python"}, {"instruction": "def mode(self):\n        \"\"\"\n        Reading returns the currently selected mode. Writing sets the mode.\n        Generally speaking when the mode changes any sensor or motor devices\n        associated with the port will be removed new ones loaded, however this\n        this will depend on the individual driver implementing this class.\n        \"\"\"\n", "input": "", "output": "        self._mode, value = self.get_attr_string(self._mode, 'mode')\n        return value", "category": "Python"}, {"instruction": "def _parse_json_with_fieldnames(self):\n        \"\"\" Parse the raw JSON with all attributes/methods defined in the class, except for the\n            ones defined starting with '_' or flagged in cls._TO_EXCLUDE.\n\n            The final result is stored in self.json\n        \"\"\"\n", "input": "", "output": "        for key in dir(self):\n            if not key.startswith('_') and key not in self._TO_EXCLUDE:\n                self.fieldnames.append(key)\n                value = getattr(self, key)\n                if value:\n                    self.json[key] = value\n        # Add OK attribute even if value is \"False\"\n        self.json['ok'] = self.ok", "category": "Python"}, {"instruction": "def setupDock(self):\n        \"\"\"Setup empty Dock at startup. \"\"\"\n", "input": "", "output": "        self.dock = QtWidgets.QDockWidget(\"Classes\", self)\n        self.dock.setWidget(self.tree)\n        self.dock.setFeatures(QtWidgets.QDockWidget.NoDockWidgetFeatures)\n        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.dock)", "category": "Python"}, {"instruction": "def get_cmdclass():\n    \"\"\" DEPRICATE \"\"\"\n", "input": "", "output": "    try:\n        from Cython.Distutils import build_ext\n        cmdclass = {'build_ext': build_ext}\n        return cmdclass\n    except Exception as ex:\n        print(ex)\n        print('WARNING: Cython is not installed. This is only a problem if you are building C extensions')\n        return {}", "category": "Python"}, {"instruction": "def get_collection(cls):\n        \"\"\"Return a reference to the database collection for the class\"\"\"\n", "input": "", "output": "\n        # By default the collection returned will be the published collection,\n        # however if the `draft` flag has been set against the global context\n        # (e.g `g`) then the collection returned will contain draft documents.\n\n        if g.get('draft'):\n            return getattr(\n                cls.get_db(),\n                '{collection}_draft'.format(collection=cls._collection)\n                )\n\n        return getattr(cls.get_db(), cls._collection)", "category": "Python"}, {"instruction": "def addprojecthook(self, project_id, url, push=False, issues=False, merge_requests=False, tag_push=False):\n        \"\"\"\n        add a hook to a project\n\n        :param project_id: project id\n        :param url: url of the hook\n        :return: True if success\n        \"\"\"\n", "input": "", "output": "        data = {\n            'id': project_id,\n            'url': url,\n            'push_events': int(bool(push)),\n            'issues_events': int(bool(issues)),\n            'merge_requests_events': int(bool(merge_requests)),\n            'tag_push_events': int(bool(tag_push)),\n        }\n\n        request = requests.post(\n            '{0}/{1}/hooks'.format(self.projects_url, project_id),\n            headers=self.headers, data=data, verify=self.verify_ssl, auth=self.auth, timeout=self.timeout)\n\n        if request.status_code == 201:\n            return request.json()\n        else:\n            return False", "category": "Python"}, {"instruction": "def urlEncodeAndJoin(self, seq, sepr=','):\n        '''sepr.join(urlencode(seq))\n        Args:\n            seq: string list to be urlencoded\n            sepr: join seq with sepr\n        Returns:\n            str\n        '''\n", "input": "", "output": "        try:\n            from urllib.parse import quote_plus as encode\n            return sepr.join([encode(x, encoding=CHARSET_UTF8) for x in seq])\n        except ImportError:\n            from urllib import quote as encode\n            return sepr.join([i for i in map(lambda x: encode(x), seq)])", "category": "Python"}, {"instruction": "def schema(self):\n        \"\"\"List[google.cloud.bigquery.schema.SchemaField]: Schema of the\n        destination table.\n\n        See\n        https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs#configuration.load.schema\n        \"\"\"\n", "input": "", "output": "        schema = _helpers._get_sub_prop(self._properties, [\"load\", \"schema\", \"fields\"])\n        if schema is None:\n            return\n        return [SchemaField.from_api_repr(field) for field in schema]", "category": "Python"}, {"instruction": "def get_complex_and_node_state(self, hosts, services):\n        \"\"\"Get state , handle AND aggregation ::\n\n           * Get the worst state. 2 or max of sons (3 <=> UNKNOWN < CRITICAL <=> 2)\n           * Revert if it's a not node\n\n        :param hosts: host objects\n        :param services: service objects\n        :return: 0, 1 or 2\n        :rtype: int\n        \"\"\"\n", "input": "", "output": "        # First we get the state of all our sons\n        states = [s.get_state(hosts, services) for s in self.sons]\n        # Next we calculate the worst state\n        if 2 in states:\n            worst_state = 2\n        else:\n            worst_state = max(states)\n        # Then we handle eventual not value\n        if self.not_value:\n            return self.get_reverse_state(worst_state)\n        return worst_state", "category": "Python"}, {"instruction": "def depsOf_of_mirteFile_module_definition(defs):\n    \"\"\" Returns a function that returns the dependencies of a module\n        definition by its name, where defs is a dictionary of module\n        definitions from a mirteFile \"\"\"\n", "input": "", "output": "    return lambda x: (list(filter(lambda z: z is not None and z in defs,\n                             map(lambda y: y[1].get('type'),\n                                 six.iteritems(defs[x]['settings'])\n                                 if 'settings' in defs[x] else [])))) + \\\n        (list(defs[x]['inherits']) if 'inherits' in defs[x] else [])", "category": "Python"}, {"instruction": "def get_splits(split_bed, gff_file, stype, key):\n    \"\"\"\n    Use intersectBed to find the fused gene => split genes mappings.\n    \"\"\"\n", "input": "", "output": "    bed_file = get_bed_file(gff_file, stype, key)\n    cmd = \"intersectBed -a {0} -b {1} -wao\".format(split_bed, bed_file)\n    cmd += \" | cut -f4,10\"\n    p = popen(cmd)\n    splits = defaultdict(set)\n    for row in p:\n        a, b = row.split()\n        splits[a].add(b)\n\n    return splits", "category": "Python"}, {"instruction": "def geometric_center(coords, periodic):\n    '''Geometric center taking into account periodic boundaries'''\n", "input": "", "output": "    max_vals = periodic\n    theta = 2 * np.pi * (coords / max_vals)\n    eps = np.cos(theta) * max_vals / (2 * np.pi)\n    zeta = np.sin(theta) * max_vals / (2 * np.pi)\n\n    eps_avg = eps.sum(axis=0)\n    zeta_avg = zeta.sum(axis=0)\n    theta_avg = np.arctan2(-zeta_avg, -eps_avg) + np.pi\n\n    return theta_avg * max_vals / (2 * np.pi)", "category": "Python"}, {"instruction": "def _initialize_repo_cache():\n    \"\"\"Initialize the repository cache used for scraping.\n\n    Retrieves a list of repositories with their provider and last scraping time\n    from Elasticsearch.\n    This list can be used to check which repos need to be scraped (e.g. after\n    a specific amount of time).\n    \"\"\"\n", "input": "", "output": "    LOGGER.info(\"Initializing repository cache\")\n    # Initialize Repo Cache\n    repo_cache = {}\n\n    # Get all repos from Elasticsearch\n    for hit in GitRepo.search().query(\"match_all\").scan():\n        # TODO (fschmidt): Maybe we can use this list as cache for the whole\n        # scraper-webhook part.\n        # This way, we could reduce the amount of operations needed for GitHub\n        # and ElasticSearch\n        repo_cache[hit.repo_name] = hit.to_dict(skip_empty=False)\n\n    return repo_cache", "category": "Python"}, {"instruction": "def _restart_target(self):\n        \"\"\"\n        Restart our Target.\n        \"\"\"\n", "input": "", "output": "        if self._server:\n            if self._server.returncode is None:\n                self._server.kill()\n                time.sleep(0.2)\n        self._server = subprocess.Popen(\"python session_server.py\", stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        time.sleep(0.2)", "category": "Python"}, {"instruction": "def merge_unscoped_hparams(scopes_and_hparams):\n  \"\"\"Merge multiple HParams into one with scopes.\"\"\"\n", "input": "", "output": "  merged_values = {}\n  for (scope, hparams) in scopes_and_hparams:\n    for key, value in six.iteritems(hparams.values()):\n      scoped_key = \"%s.%s\" % (scope, key)\n      merged_values[scoped_key] = value\n\n  return hparam.HParams(**merged_values)", "category": "Python"}, {"instruction": "def html_page_context(app, pagename, templatename, context, doctree):\n    ''' Collect page names for the sitemap as HTML pages are built.\n\n    '''\n", "input": "", "output": "    site = context['SITEMAP_BASE_URL']\n    version = context['version']\n    app.sitemap_links.add(site + version + '/' + pagename + \".html\")", "category": "Python"}, {"instruction": "def _create_request_map(cls, input_map):\n        \"\"\"Create request map.\"\"\"\n", "input": "", "output": "        mapped = super(Certificate, cls)._create_request_map(input_map)\n        if mapped.get('service') == CertificateType.developer:\n            mapped['service'] = CertificateType.bootstrap\n        return mapped", "category": "Python"}, {"instruction": "def _split_classes_and_methods(folds):\n    \"\"\"\n    Split out classes and methods into two separate lists.\n\n    Parameters\n    ----------\n    folds : list of :class:`FoldScopeHelper`\n        The result of :func:`_get_fold_levels`.\n\n    Returns\n    -------\n    classes, functions: list of :class:`FoldScopeHelper`\n        Two separate lists of :class:`FoldScopeHelper` objects. The former\n        contains only class definitions while the latter contains only\n        function/method definitions.\n    \"\"\"\n", "input": "", "output": "    classes = []\n    functions = []\n    for fold in folds:\n        if fold.def_type == OED.FUNCTION_TOKEN:\n            functions.append(fold)\n        elif fold.def_type == OED.CLASS_TOKEN:\n            classes.append(fold)\n\n    return classes, functions", "category": "Python"}, {"instruction": "def compute_distance_matrix(points):\n    \"\"\"\n    Return a matrix of distance (in meters) between every point in a given list\n    of (lat, lon) location tuples.\n    \"\"\"\n", "input": "", "output": "    n = len(points)\n    return [[1000 * great_circle_distance(points[i], points[j])\n             for j in range(n)] for i in range(n)]", "category": "Python"}, {"instruction": "def sendmail(self, to, message):\n        \"\"\"Send mail to one or more recipients. The required arguments are a\n        list of RFC 822 to-address strings (a bare string will be treated as a\n        list with 1 address), and a message string.\n\n        \"\"\"\n", "input": "", "output": "\n        # If we were passed a bare string as the To: address, convert it to\n        # a single element list.\n        if isinstance(to, str):\n            to = [ to, ]\n\n        # Send one email with the appropriate recipient list.\n        server = self._smtp_server()\n        server.sendmail(self.get_rfc2822_address(), to, message)\n        server.quit()", "category": "Python"}, {"instruction": "def __send_exc_clear(self, log_if_exc_set=None):\n        \"\"\"Clear send exception and time. If exception was previously was set, optionally log log_if_exc_set at INFO\n        level.\n        \"\"\"\n", "input": "", "output": "        if not (log_if_exc_set is None or self.__send_exc is None):\n            logger.info(log_if_exc_set)\n        self.__send_exc_time = None\n        self.__send_exc = None", "category": "Python"}, {"instruction": "def get_readwrite_instance(cls, working_dir, restore=False, restore_block_height=None):\n        \"\"\"\n        Get a read/write instance to the db, without the singleton check.\n        Used for low-level operations like db restore.\n        Not used in the steady state behavior of the system.\n        \"\"\"\n", "input": "", "output": "        log.warning(\"!!! Getting raw read/write DB instance !!!\")\n\n        import virtualchain_hooks\n        db_path = virtualchain.get_db_filename(virtualchain_hooks, working_dir)\n        db = BlockstackDB(db_path, DISPOSITION_RW, working_dir, get_genesis_block())\n        rc = db.db_setup()\n        if not rc:\n            if restore:\n                # restore from backup instead of bailing out\n                log.debug(\"Restoring from unclean shutdown\")\n                rc = db.db_restore(block_number=restore_block_height)\n                if rc:\n                    return db\n                else:\n                    log.error(\"Failed to restore from unclean shutdown\")\n\n            db.close()\n            raise Exception(\"Failed to set up db\")\n\n        return db", "category": "Python"}, {"instruction": "async def pause_writing(self):\n        \"\"\"Pause writing.\"\"\"\n", "input": "", "output": "        self._restart_writer = False\n        if self._writer_task:\n            self._writer_task.remove_done_callback(self.restart_writing)\n            self._writer_task.cancel()\n            await self._writer_task\n            await asyncio.sleep(0, loop=self._loop)", "category": "Python"}, {"instruction": "def get_refinement_options(self):\n        \"\"\" Returns possible specializations for the upper values in the taxonomy \"\"\"\n", "input": "", "output": "        domain = self.get_domain()\n        for upper_value in self.upper:\n            for suc in domain.successors(upper_value):\n                yield suc", "category": "Python"}, {"instruction": "def guard_retract(analysis):\n    \"\"\" Return whether the transition \"retract\" can be performed or not\n    \"\"\"\n", "input": "", "output": "    # Cannot retract if there are dependents that cannot be retracted\n    if not is_transition_allowed(analysis.getDependents(), \"retract\"):\n        return False\n\n    dependencies = analysis.getDependencies()\n    if not dependencies:\n        return True\n\n    # Cannot retract if all dependencies have been verified\n    if all(map(lambda an: IVerified.providedBy(an), dependencies)):\n        return False\n\n    return True", "category": "Python"}, {"instruction": "def _cache_translation_needs_fallback(instance, language_code, related_name, timeout=cache.default_timeout):\n    \"\"\"\n    Store the fact that a translation doesn't exist, and the fallback should be used.\n    \"\"\"\n", "input": "", "output": "    if not appsettings.PARLER_ENABLE_CACHING or not instance.pk or instance._state.adding:\n        return\n\n    tr_model = instance._parler_meta.get_model_by_related_name(related_name)\n    key = get_translation_cache_key(tr_model, instance.pk, language_code)\n    cache.set(key, {'__FALLBACK__': True}, timeout=timeout)", "category": "Python"}, {"instruction": "def course_feature(catalog, soup):\n    \"\"\"Parses all the courses (AKA, the most important part).\n    \"\"\"\n", "input": "", "output": "    courses = {}\n    course_crns = {}\n    for course in soup.findAll('course'):\n        c = Course.from_soup_tag(course)\n        courses[str(c)] = c\n    catalog.courses = courses\n    catalog.courses\n    logger.info('Catalog has %d courses' % len(courses))", "category": "Python"}, {"instruction": "def collaborations(self, key, value):\n    \"\"\"Populate the ``collaborations`` key.\"\"\"\n", "input": "", "output": "    result = []\n\n    for g_value in force_list(value.get('g')):\n        collaborations = normalize_collaboration(g_value)\n        if len(collaborations) == 1:\n            result.append({\n                'record': get_record_ref(maybe_int(value.get('0')), 'experiments'),\n                'value': collaborations[0],\n            })\n        else:\n            result.extend({'value': collaboration} for collaboration in collaborations)\n\n    return result", "category": "Python"}, {"instruction": "def op_decanonicalize(op_name, canonical_op):\n    \"\"\"\n    Get the current representation of a parsed operation's data, given the canonical representation\n    Meant for backwards-compatibility\n    \"\"\"\n", "input": "", "output": "    global DECANONICALIZE_METHODS\n\n    if op_name not in DECANONICALIZE_METHODS:\n        # no decanonicalization needed\n        return canonical_op\n    else:\n        return DECANONICALIZE_METHODS[op_name](canonical_op)", "category": "Python"}, {"instruction": "def diam_floc_vel_term(ConcAl, ConcClay, coag, material,\n                       DIM_FRACTAL, VelTerm, Temp):\n    \"\"\"Calculate floc diamter as a function of terminal velocity.\"\"\"\n", "input": "", "output": "    WaterDensity = pc.density_water(Temp).magnitude\n    return (material.Diameter * (((18 * VelTerm * PHI_FLOC\n                          * pc.viscosity_kinematic(Temp).magnitude\n                          )\n                         / (pc.gravity.magnitude * material.Diameter**2)\n                         )\n                         * (WaterDensity\n                            / (dens_floc_init(ConcAl, ConcClay, coag,\n                                              material).magnitude\n                               - WaterDensity\n                               )\n                            )\n                        ) ** (1 / (DIM_FRACTAL - 1))\n            )", "category": "Python"}, {"instruction": "def get_polling_override(self):\n        \"\"\"Get the current polling override value in milliseconds. \n\n        See :meth:`set_polling_override` for more information. \n\n        Returns:\n            None on error, otherwise the current override period in milliseconds \n            (0 = disabled). \n        \"\"\"\n", "input": "", "output": "        polling_override = self.get_characteristic_handle_from_uuid(UUID_POLLING_OVERRIDE)\n        if polling_override is None:\n            logger.warn('Failed to find handle for polling override')\n            return None\n        override_ms = self.dongle._read_attribute(self.conn_handle, polling_override, True)\n        return None if override_ms is None else ord(override_ms)", "category": "Python"}, {"instruction": "def keywords(s, top=10, **kwargs):\n    \"\"\" Returns a sorted list of keywords in the given string.\n    \"\"\"\n", "input": "", "output": "    return parser.find_keywords(s, top=top, frequency=parser.frequency)", "category": "Python"}, {"instruction": "def _checkObjectsToLearn(self, objects):\n    \"\"\"\n    Checks that objects have the correct format before being sent to the\n    experiment.\n    \"\"\"\n", "input": "", "output": "    for objectName, sensationList in objects.iteritems():\n      if objectName not in self.objects:\n        raise ValueError(\n          \"Invalid object name \\\"{}\\\" sent to experiment\".format(objectName)\n        )\n\n      for sensations in sensationList:\n        if set(sensations.keys()) != set(range(self.numColumns)):\n          raise ValueError(\n            \"Invalid number of cortical column sensations sent to experiment\"\n          )\n        for pair in sensations.values():\n          if not isinstance(pair, tuple) or len(pair) != 2 or \\\n                  not isinstance(pair[0], set) or \\\n                  not isinstance(pair[1], set):\n            raise ValueError(\"Invalid SDR's sent to experiment\")", "category": "Python"}, {"instruction": "def update_handler(feeds):\n\t\t'''Update all cross-referencing filters results for feeds and others, related to them.\n\t\t\tIntended to be called from non-Feed update hooks (like new Post saving).'''\n", "input": "", "output": "\t\t# Check if this call is a result of actions initiated from\n\t\t#  one of the hooks in a higher frame (resulting in recursion).\n\t\tif Feed._filters_update_handler_lock: return\n\t\treturn Feed._filters_update_handler(Feed, feeds, force=True)", "category": "Python"}, {"instruction": "def mapred(self, transport, inputs, query, timeout):\n        \"\"\"\n        mapred(inputs, query, timeout)\n\n        Executes a MapReduce query.\n\n        .. note:: This request is automatically retried :attr:`retries`\n           times if it fails due to network error.\n\n        :param inputs: the input list/structure\n        :type inputs: list, dict\n        :param query: the list of query phases\n        :type query: list\n        :param timeout: the query timeout\n        :type timeout: integer, None\n        :rtype: mixed\n        \"\"\"\n", "input": "", "output": "        _validate_timeout(timeout)\n        return transport.mapred(inputs, query, timeout)", "category": "Python"}, {"instruction": "def right(self, expand=None):\n        \"\"\" Returns a new Region right of the current region with a width of ``expand`` pixels.\n\n        Does not include the current region. If range is omitted, it reaches to the right border\n        of the screen. The new region has the same height and y-position as the current region.\n        \"\"\"\n", "input": "", "output": "        if expand == None:\n            x = self.x+self.w\n            y = self.y\n            w = self.getScreen().getBounds()[2] - x\n            h = self.h\n        else:\n            x = self.x+self.w\n            y = self.y\n            w = expand\n            h = self.h\n        return Region(x, y, w, h).clipRegionToScreen()", "category": "Python"}, {"instruction": "def clean(self):\n        \"\"\"\n        Checks for the identification and password.\n\n        If the combination can't be found will raise an invalid sign in error.\n\n        \"\"\"\n", "input": "", "output": "        identification = self.cleaned_data.get('identification')\n        password = self.cleaned_data.get('password')\n\n        if identification and password:\n            self.user_cache = authenticate(identification=identification, \n                                password=password)\n            if self.user_cache is None:\n                raise forms.ValidationError(_(u\"Please enter a correct \"\n                        \"username or email address and password. \"\n                        \"Note that both fields are case-sensitive.\"))\n        return self.cleaned_data", "category": "Python"}, {"instruction": "def reset(self):\n    \"\"\"Reset simulated and real environments.\"\"\"\n", "input": "", "output": "    self._frame_counter = 0\n    ob_real = self.real_env.reset()\n    # Initialize simulated environment with frames from real one.\n    self.sim_env.add_to_initial_stack(ob_real)\n    for _ in range(3):\n      ob_real, _, _, _ = self.real_env.step(self.name_to_action_num[\"NOOP\"])\n      self.sim_env.add_to_initial_stack(ob_real)\n    ob_sim = self.sim_env.reset()\n    assert np.all(ob_real == ob_sim)\n    self._last_step_tuples = self._pack_step_tuples((ob_real, 0, False, {}),\n                                                    (ob_sim, 0, False, {}))\n    self.set_zero_cumulative_rewards()\n    ob, _, _, _ = self._player_step_tuple(self._last_step_tuples)\n    return ob", "category": "Python"}, {"instruction": "def _send_command_wrapper(self, cmd):\n        \"\"\"\n        Send command to the remote device with a caching feature to avoid sending the same command\n        twice based on the SSH_MAPPER_BASE dict cmd key.\n\n        Parameters\n        ----------\n        cmd : str\n            The command to send to the remote device after checking cache.\n\n        Returns\n        -------\n        response : str\n            The response from the remote device.\n        \"\"\"\n", "input": "", "output": "        cached_results = self._results_cache.get(cmd)\n        if not cached_results:\n            response = self._send_command(cmd)\n            self._results_cache[cmd] = response\n            return response\n        else:\n            return cached_results", "category": "Python"}, {"instruction": "def bind_sockets(address, port):\n    ''' Bind a socket to a port on an address.\n\n    Args:\n        address (str) :\n            An address to bind a port on, e.g. ``\"localhost\"``\n\n        port (int) :\n            A port number to bind.\n\n            Pass 0 to have the OS automatically choose a free port.\n\n    This function returns a 2-tuple with the new socket as the first element,\n    and the port that was bound as the second. (Useful when passing 0 as a port\n    number to bind any free port.)\n\n    Returns:\n        (socket, port)\n\n    '''\n", "input": "", "output": "    ss = netutil.bind_sockets(port=port or 0, address=address)\n    assert len(ss)\n    ports = {s.getsockname()[1] for s in ss}\n    assert len(ports) == 1, \"Multiple ports assigned??\"\n    actual_port = ports.pop()\n    if port:\n        assert actual_port == port\n    return ss, actual_port", "category": "Python"}, {"instruction": "def add_files(self, *filenames, **kw):\n        \"\"\"\n        Include added and/or removed files in the working tree in the next commit.\n\n        :param filenames: The filenames of the files to include in the next\n                          commit (zero or more strings). If no arguments are\n                          given all untracked files are added.\n        :param kw: Keyword arguments are ignored (instead of raising\n                   :exc:`~exceptions.TypeError`) to enable backwards\n                   compatibility with older versions of `vcs-repo-mgr`\n                   where the keyword argument `all` was used.\n        \"\"\"\n", "input": "", "output": "        # Make sure the local repository exists and supports a working tree.\n        self.create()\n        self.ensure_working_tree()\n        # Include added and/or removed files in the next commit.\n        logger.info(\"Staging changes to be committed in %s ..\", format_path(self.local))\n        self.context.execute(*self.get_add_files_command(*filenames))", "category": "Python"}, {"instruction": "def getRunningBatchJobIDs(self):\n        \"\"\"\n        Retrieve running job IDs from local and batch scheduler.\n\n        Respects statePollingWait and will return cached results if not within\n        time period to talk with the scheduler.\n        \"\"\"\n", "input": "", "output": "        if (self._getRunningBatchJobIDsTimestamp and (\n                datetime.now() -\n                self._getRunningBatchJobIDsTimestamp).total_seconds() <\n                self.config.statePollingWait):\n            batchIds = self._getRunningBatchJobIDsCache\n        else:\n            batchIds = with_retries(self.worker.getRunningJobIDs)\n            self._getRunningBatchJobIDsCache = batchIds\n            self._getRunningBatchJobIDsTimestamp = datetime.now()\n        batchIds.update(self.getRunningLocalJobIDs())\n        return batchIds", "category": "Python"}, {"instruction": "def PROFILE_RAUTIAN(sg0,GamD,Gam0,Shift0,anuVC,eta,sg):\n    \"\"\"\n    # Rautian profile based on HTP.\n    # Input parameters:\n    #      sg0     : Unperturbed line position in cm-1 (Input).\n    #      GamD    : Doppler HWHM in cm-1 (Input)\n    #      Gam0    : Speed-averaged line-width in cm-1 (Input).       \n    #      anuVC   : Velocity-changing frequency in cm-1 (Input).\n    #      Shift0  : Speed-averaged line-shift in cm-1 (Input).\n    #      sg      : Current WaveNumber of the Computation in cm-1 (Input).\n    \"\"\"\n", "input": "", "output": "    return pcqsdhc(sg0,GamD,Gam0,cZero,Shift0,cZero,anuVC,cZero,sg)", "category": "Python"}, {"instruction": "def get_stp_mst_detail_output_msti_port_rx_bpdu_count(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n", "input": "", "output": "        config = ET.Element(\"config\")\n        get_stp_mst_detail = ET.Element(\"get_stp_mst_detail\")\n        config = get_stp_mst_detail\n        output = ET.SubElement(get_stp_mst_detail, \"output\")\n        msti = ET.SubElement(output, \"msti\")\n        instance_id_key = ET.SubElement(msti, \"instance-id\")\n        instance_id_key.text = kwargs.pop('instance_id')\n        port = ET.SubElement(msti, \"port\")\n        rx_bpdu_count = ET.SubElement(port, \"rx-bpdu-count\")\n        rx_bpdu_count.text = kwargs.pop('rx_bpdu_count')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "category": "Python"}, {"instruction": "def p_if_statement_2(self, p):\n        \"\"\"if_statement : IF LPAREN expr RPAREN statement ELSE statement\"\"\"\n", "input": "", "output": "        p[0] = self.asttypes.If(\n            predicate=p[3], consequent=p[5], alternative=p[7])\n        p[0].setpos(p)", "category": "Python"}, {"instruction": "def get_dates(self):\n        \"\"\" Returns a list of acquisition times from tile info data\n\n        :return: List of acquisition times in the order returned by WFS service.\n        :rtype: list(datetime.datetime)\n        \"\"\"\n", "input": "", "output": "        return [datetime.datetime.strptime('{}T{}'.format(tile_info['properties']['date'],\n                                                          tile_info['properties']['time'].split('.')[0]),\n                                           '%Y-%m-%dT%H:%M:%S') for tile_info in self]", "category": "Python"}, {"instruction": "def _find_datastream(self, name):\n        \"\"\"Find and return if a datastream exists, by name.\"\"\"\n", "input": "", "output": "        for stream in self.data_streams: #search to see if this is a new datastream or a known one\n            if stream.name == name:\n                return stream\n        return None", "category": "Python"}, {"instruction": "def get_topic_list(num=10, top_items=False):\n    \"\"\"\n    Returns a list of top recent topics, excluding less valuable forums.\n    Default is 10 topics.\n    Can be sorted for most active topics by votes and post count.\n    Usage:\n    {% get_topic_list 5 as topics %}\n    {% get_topic_list 7 top_items=True as topics %}\n    \"\"\"\n", "input": "", "output": "    excluded_forum_ids = [3, 7, 10, 12, 15, 16, 17, 18, 19, 23]\n    topics = Topic.objects.exclude(forum_id__in=excluded_forum_ids).order_by('-id')[0:num]\n    if top_items:\n        topics = sorted(list(topics), key=lambda t: (t.forum_id, -t.votes, -t.post_count))\n    return topics", "category": "Python"}, {"instruction": "def read_networks(folder):\n    \"\"\"\n    Read perseus network collection folder format\n    \n    >>> network_table, networks = read_networks(folder)\n    \n    :param folder: Path to network collection\n    :returns: Network table and dictionary with 'name', 'edge_table', and 'node_table' keys.\n    \"\"\"\n", "input": "", "output": "    network_table = read_perseus(path.join(folder, \"networks.txt\"))\n    networks = {}\n    for name, guid in network_table[['Name', 'GUID']].values:\n        networks[guid] = {\n                'name': name,\n                'guid': guid,\n                'node_table': read_perseus(path.join(folder, \"{}_nodes.txt\".format(guid))),\n                'edge_table': read_perseus(path.join(folder, \"{}_edges.txt\".format(guid)))\n                }\n    return network_table, networks", "category": "Python"}, {"instruction": "def from_bytes(cls, data):\n        \"\"\"\n        I am so sorry.\n        \"\"\"\n", "input": "", "output": "        len_username = int.from_bytes(data[0:2], byteorder=\"big\")\n        offset_username = 2 + len_username\n        username = data[2:offset_username].decode(\"UTF-8\")\n        offset_password = 2 + offset_username\n        len_password = int.from_bytes(\n            data[offset_username:offset_password], byteorder=\"big\"\n        )\n        pass_begin = offset_password\n        pass_end = offset_password + len_password\n        password = data[pass_begin:pass_end].decode(\"UTF-8\")\n\n        return cls(username, password)", "category": "Python"}, {"instruction": "def by_median_home_value(self,\n                             lower=-1,\n                             upper=2 ** 31,\n                             zipcode_type=ZipcodeType.Standard,\n                             sort_by=SimpleZipcode.median_home_value.name,\n                             ascending=False,\n                             returns=DEFAULT_LIMIT):\n        \"\"\"\n        Search zipcode information by median home value.\n        \"\"\"\n", "input": "", "output": "        return self.query(\n            median_home_value_lower=lower,\n            median_home_value_upper=upper,\n            sort_by=sort_by, zipcode_type=zipcode_type,\n            ascending=ascending, returns=returns,\n        )", "category": "Python"}, {"instruction": "async def track_event(event, state, service_name):\n    \"\"\"\n    Store state of events in memory\n    :param event: Event object\n    :param state: EventState object\n    :param service_name: Name of service name\n    \"\"\"\n", "input": "", "output": "    redis = await aioredis.create_redis(\n        (EVENT_TRACKING_HOST, 6379), loop=loop)\n\n    now = datetime.utcnow()\n    event_id = event.event_id\n\n    tracking_data = json.dumps({\n        \"event_id\": event_id,\n        \"timestamp\": str(now),\n        \"state\": state\n    })\n    await redis.rpush(service_name, tracking_data)\n    redis.close()\n    await redis.wait_closed()", "category": "Python"}, {"instruction": "def AsIter(arg):\n  \"\"\"Encapsulates an argument in a tuple, if it's not already iterable.\"\"\"\n", "input": "", "output": "  if isinstance(arg, string_types):\n    rslt = [arg]\n  elif isinstance(arg, collections.Iterable):\n    rslt = arg\n  elif not arg:\n    rslt = []\n  else:\n    rslt = [arg]\n  return tuple(rslt)", "category": "Python"}, {"instruction": "def resource_schema(raml_resource):\n    \"\"\" Get schema properties of RAML resource :raml_resource:.\n\n    Must be called with RAML resource that defines body schema. First\n    body that defines schema is used. Schema is converted on return using\n    'convert_schema'.\n\n    :param raml_resource: Instance of ramlfications.raml.ResourceNode of\n        POST method.\n    \"\"\"\n", "input": "", "output": "    # NOTE: Must be called with resource that defines body schema\n    log.info('Searching for model schema')\n    if not raml_resource.body:\n        raise ValueError('RAML resource has no body to setup database '\n                         'schema from')\n\n    for body in raml_resource.body:\n        if body.schema:\n            return convert_schema(body.schema, body.mime_type)\n    log.debug('No model schema found.')", "category": "Python"}, {"instruction": "def _push_condition(predicate):\n    \"\"\"As we enter new conditions, this pushes them on the predicate stack.\"\"\"\n", "input": "", "output": "    global _depth\n    _check_under_condition()\n    _depth += 1\n    if predicate is not otherwise and len(predicate) > 1:\n        raise PyrtlError('all predicates for conditional assignments must wirevectors of len 1')\n    _conditions_list_stack[-1].append(predicate)\n    _conditions_list_stack.append([])", "category": "Python"}, {"instruction": "def write(content, filename='cache'):\n\t\"\"\" write data to cache file\n\tparameters:\n\t\tcache_path - path to cache file\n\t\tcontent - a data structure to save into cache file\"\"\"\n", "input": "", "output": "\tcache_path = get_cache_path(filename)\n\twith open(cache_path, 'w') as file:\n\t\tif content is not None:\n\t\t\tjson.dump(content, file, indent=3, sort_keys=True)", "category": "Python"}, {"instruction": "def triangle(self, x1, y1, x2, y2, x3, y3, color):\n        \"\"\"\n        See the Processing function triangle():\n        https://processing.org/reference/triangle_.html\n        \"\"\"\n", "input": "", "output": "        self.context.set_source_rgb(*color)\n        self.context.move_to(self.tx(x1), self.ty(y1))\n        self.context.line_to(self.tx(x2), self.ty(y2))\n        self.context.line_to(self.tx(x3), self.ty(y3))\n        self.context.line_to(self.tx(x1), self.ty(y1))\n        self.context.fill()", "category": "Python"}, {"instruction": "def disable_cors(self):\n        \"\"\"\n        Switches CORS off.\n\n        :returns: CORS status in JSON format\n        \"\"\"\n", "input": "", "output": "        return self.update_cors_configuration(\n            enable_cors=False,\n            allow_credentials=False,\n            origins=[],\n            overwrite_origins=True\n        )", "category": "Python"}, {"instruction": "def _unparse_a_tags(cls, attrs_dict):\n        \"\"\" Iterates over the dictionary\n\n        :param: attrs_dict a dict of attributes\n        :returns:   a SimpleXMLElement list containing <a> tags\n        \"\"\"\n", "input": "", "output": "        prop_tags = []\n\n        for k, v in attrs_dict.items():\n            node = {cls.ATTRNAME_PROPERTY: k, '_content': utils.auto_type(v)}\n            prop_tags.append(node)\n\n        return prop_tags", "category": "Python"}, {"instruction": "def json_api_call(req_function):\n    \"\"\" Wrap a view-like function that returns an object that\n        is convertable from json\n    \"\"\"\n", "input": "", "output": "    @wraps(req_function)\n    def newreq(request, *args, **kwargs):\n        outp = req_function(request, *args, **kwargs)\n        if issubclass(outp.__class__, HttpResponse):\n            return outp\n        else:\n            return '%s' % json.dumps(outp, cls=LazyEncoder)\n    return string_to_response(\"application/json\")(newreq)", "category": "Python"}, {"instruction": "def tracked(self):\n        '''Return an array of job objects that are being tracked'''\n", "input": "", "output": "        results = json.loads(self.client('track'))\n        results['jobs'] = [Job(self, **job) for job in results['jobs']]\n        return results", "category": "Python"}, {"instruction": "def tr(text, kword, color):\n    \"\"\" tr(text, keyword, color)\n    \"\"\"\n", "input": "", "output": "    return re.sub(kword, colorize(BgColor.Null, Base.Null, color, kword), text)", "category": "Python"}, {"instruction": "def gpib_command(self, session, command_byte):\n        \"\"\"Write GPIB command byte on the bus.\n\n        Corresponds to viGpibCommand function of the VISA library.\n        See: https://linux-gpib.sourceforge.io/doc_html/gpib-protocol.html#REFERENCE-COMMAND-BYTES\n\n        :param command_byte: command byte to send\n        :type command_byte: int, must be [0 255]\n        :return: return value of the library call\n        :rtype: :class:`pyvisa.constants.StatusCode`\n        \"\"\"\n", "input": "", "output": "        try:\n            return self.sessions[session].gpib_command(command_byte)\n\n        except KeyError:\n            return constants.StatusCode.error_invalid_object", "category": "Python"}, {"instruction": "def update(self, td):\r\n        \"\"\"Update state of ball\"\"\"\n", "input": "", "output": "        self.sprite.last_position = self.sprite.position\r\n        self.sprite.last_velocity = self.sprite.velocity\r\n        if self.particle_group != None:\r\n            self.update_particle_group(td)", "category": "Python"}, {"instruction": "def await_metadata_by_name(self, name, metadata_key, timeout, caster=None):\n    \"\"\"Block up to a timeout for process metadata to arrive on disk.\n\n    :param string name: The ProcessMetadataManager identity/name (e.g. 'pantsd').\n    :param string metadata_key: The metadata key (e.g. 'pid').\n    :param int timeout: The deadline to write metadata.\n    :param type caster: A type-casting callable to apply to the read value (e.g. int, str).\n    :returns: The value of the metadata key (read from disk post-write).\n    :raises: :class:`ProcessMetadataManager.Timeout` on timeout.\n    \"\"\"\n", "input": "", "output": "    file_path = self._metadata_file_path(name, metadata_key)\n    self._wait_for_file(file_path, timeout=timeout)\n    return self.read_metadata_by_name(name, metadata_key, caster)", "category": "Python"}, {"instruction": "def _parse_ports(port_values: dict) -> dict:\n        \"\"\"Parse ports key.\n\n        Args:\n            port_values (dict): ports configuration values\n\n        Returns:\n            dict, Ports specification which contains exposed ports\n\n        \"\"\"\n", "input": "", "output": "        # Initialising empty dictionary\n        endpoints = {}\n\n        for port_element in port_values:\n            target_port = port_element.split(':')\n            for port in target_port:\n                endpoints[int(port)] = int(port)\n\n        # Setting the types\n        endpoint_spec = docker.types.EndpointSpec(ports=endpoints)\n        return endpoint_spec", "category": "Python"}, {"instruction": "def p_field_optional1_3(self, p):\n        \"\"\"\n        field : alias name arguments selection_set\n        \"\"\"\n", "input": "", "output": "        p[0] = Field(name=p[2], alias=p[1], arguments=p[3], selections=p[4])", "category": "Python"}, {"instruction": "def _surfdens(self,R,z,phi=0.,t=0.):\n        \"\"\"\n        NAME:\n           _surfdens\n        PURPOSE:\n           evaluate the surface density for this potential\n        INPUT:\n           R - Galactocentric cylindrical radius\n           z - vertical height\n           phi - azimuth\n           t - time\n        OUTPUT:\n           the surface density\n        HISTORY:\n           2018-08-19 - Written - Bovy (UofT)\n        \"\"\"\n", "input": "", "output": "        return 2.*integrate.quad(lambda x: self._dens(R,x,phi=phi,t=t),0,z)[0]", "category": "Python"}, {"instruction": "def p_do_loop_while(p):\n    \"\"\" statement : do_start program_co label_loop WHILE expr\n                  | do_start label_loop WHILE expr\n                  | DO label_loop WHILE expr\n    \"\"\"\n", "input": "", "output": "    if len(p) == 6:\n        q = make_block(p[2], p[3])\n        r = p[5]\n    else:\n        q = p[2]\n        r = p[4]\n\n    if p[1] == 'DO':\n        gl.LOOPS.append(('DO',))\n\n    p[0] = make_sentence('DO_WHILE', r, q)\n    gl.LOOPS.pop()\n\n    if is_number(r):\n        api.errmsg.warning_condition_is_always(p.lineno(3), bool(r.value))\n    if q is None:\n        api.errmsg.warning_empty_loop(p.lineno(3))", "category": "Python"}, {"instruction": "def _import_lua_dependencies(lua, lua_globals):\n        \"\"\"\n        Imports lua dependencies that are supported by redis lua scripts.\n\n        The current implementation is fragile to the target platform and lua version\n        and may be disabled if these imports are not needed.\n\n        Included:\n            - cjson lib.\n        Pending:\n            - base lib.\n            - table lib.\n            - string lib.\n            - math lib.\n            - debug lib.\n            - cmsgpack lib.\n        \"\"\"\n", "input": "", "output": "        if sys.platform not in ('darwin', 'windows'):\n            import ctypes\n            ctypes.CDLL('liblua5.2.so', mode=ctypes.RTLD_GLOBAL)\n\n        try:\n            lua_globals.cjson = lua.eval('require \"cjson\"')\n        except RuntimeError:\n            raise RuntimeError(\"cjson not installed\")", "category": "Python"}, {"instruction": "def contains_one_of(self, elements):\n        \"\"\"\n        Ensures :attr:`subject` contains exactly one of *elements*, which must be an iterable.\n        \"\"\"\n", "input": "", "output": "        if sum(e in self._subject for e in elements) != 1:\n            raise self._error_factory(_format(\"Expected {} to have exactly one of {}\", self._subject, elements))\n        return ChainInspector(self._subject)", "category": "Python"}, {"instruction": "def login(container):\n    \"\"\"Log into container.\"\"\"\n", "input": "", "output": "    columns, lines = shutil.get_terminal_size()  # Temporary\n    try:\n        subprocess.check_call([\n            \"docker\", \"exec\",\n            \"--env\", f\"COLUMNS={str(columns)},LINES={str(lines)}\",  # Temporary\n            \"--env\", f\"LINES={str(lines)}\",  # Temporary\n            \"--interactive\",\n            \"--tty\",\n            container,\n            \"bash\",\n            \"--login\"\n        ])\n    except subprocess.CalledProcessError:\n        raise RuntimeError() from None", "category": "Python"}, {"instruction": "def _keygen(self, event, ts=None):\n        \"\"\"Generate redis key for event at timestamp.\n\n        :param event: event name\n        :param ts: timestamp, default to current timestamp if left as None\n        \"\"\"\n", "input": "", "output": "        return \"%s:%s\" % (self.namespace(ts or time.time()), event)", "category": "Python"}, {"instruction": "def card_auth(self, auth_mode, block_address, key, uid):\n        \"\"\"\n        Authenticates to use specified block address. Tag must be selected using select_tag(uid) before auth.\n        auth_mode -- RFID.auth_a or RFID.auth_b\n        key -- list or tuple with six bytes key\n        uid -- list or tuple with four bytes tag ID\n        Returns error state.\n        \"\"\"\n", "input": "", "output": "        buf = []\n        buf.append(auth_mode)\n        buf.append(block_address)\n\n        for i in range(len(key)):\n            buf.append(key[i])\n\n        for i in range(4):\n            buf.append(uid[i])\n\n        (error, back_data, back_length) = self.card_write(self.mode_auth, buf)\n        if not (self.dev_read(0x08) & 0x08) != 0:\n            error = True\n\n        if not error:\n            self.authed = True\n\n        return error", "category": "Python"}, {"instruction": "def kernel_restarted_message(self, msg):\r\n        \"\"\"Show kernel restarted/died messages.\"\"\"\n", "input": "", "output": "        if not self.is_error_shown:\r\n            # If there are kernel creation errors, jupyter_client will\r\n            # try to restart the kernel and qtconsole prints a\r\n            # message about it.\r\n            # So we read the kernel's stderr_file and display its\r\n            # contents in the client instead of the usual message shown\r\n            # by qtconsole.\r\n            try:\r\n                stderr = self._read_stderr()\r\n            except Exception:\r\n                stderr = None\r\n            if stderr:\r\n                self.show_kernel_error('<tt>%s</tt>' % stderr)\r\n        else:\r\n            self.shellwidget._append_html(\"<br>%s<hr><br>\" % msg,\r\n                                          before_prompt=False)", "category": "Python"}, {"instruction": "def exclude_args(parser, args, excluded_args, target):\n    \"\"\"Delete options that are not appropriate for a following code path; exit\n    with an error if excluded options were passed in by the user.\n\n    argparse generates a namespace with all options it knows, but not every\n    attribute should be passed to all code paths (i.e. options about\n    interpolation should not reach `run_from_ufos()`). This function can be run\n    before entering a particular code path to clean up the kwargs passed to it.\n\n    Exit with an error message if the user actually passed the options in.\n    \"\"\"\n", "input": "", "output": "    msg = '\"%s\" option invalid for %s'\n    for argname in excluded_args:\n        if argname not in args:\n            continue\n        if args[argname]:\n            optname = \"--%s\" % argname.replace(\"_\", \"-\")\n            parser.error(msg % (optname, target))\n        del args[argname]", "category": "Python"}, {"instruction": "def isHereDoc(self, line, column):\n        \"\"\"Check if text at given position is a here document.\n\n        If language is not known, or text is not parsed yet, ``False`` is returned\n        \"\"\"\n", "input": "", "output": "        return self._highlighter is not None and \\\n               self._highlighter.isHereDoc(self.document().findBlockByNumber(line), column)", "category": "Python"}, {"instruction": "def by_group_and_perm(cls, group_id, perm_name, db_session=None):\n        \"\"\"\n        return by by_user_and_perm and permission name\n\n        :param group_id:\n        :param perm_name:\n        :param db_session:\n        :return:\n        \"\"\"\n", "input": "", "output": "        db_session = get_db_session(db_session)\n        query = db_session.query(cls.model).filter(cls.model.group_id == group_id)\n        query = query.filter(cls.model.perm_name == perm_name)\n        return query.first()", "category": "Python"}, {"instruction": "def flatten_model(model):\n    \"\"\"Flatten a model to a list of models.\n    This is used to flatten a ``Binder``'ish model down to a list\n    of contained models.\n    \"\"\"\n", "input": "", "output": "    yield model\n    if isinstance(model, (TranslucentBinder, Binder,)):\n        for m in model:\n            # yield from flatten_model(m)\n            for x in flatten_model(m):\n                yield x", "category": "Python"}, {"instruction": "def dedent(content):\n    \"\"\"\n    Remove leading indent from a block of text.\n    Used when generating descriptions from docstrings.\n\n    Note that python's `textwrap.dedent` doesn't quite cut it,\n    as it fails to dedent multiline docstrings that include\n    unindented text on the initial line.\n    \"\"\"\n", "input": "", "output": "    content = force_text(content)\n    whitespace_counts = [len(line) - len(line.lstrip(' '))\n                         for line in content.splitlines()[1:] if line.lstrip()]\n\n    # unindent the content if needed\n    if whitespace_counts:\n        whitespace_pattern = '^' + (' ' * min(whitespace_counts))\n        content = re.sub(re.compile(whitespace_pattern, re.MULTILINE), '', content)\n\n    return content.strip()", "category": "Python"}, {"instruction": "def close(self):\n        \"\"\"\n        Close the file.\n        \"\"\"\n", "input": "", "output": "        if not self.closed:\n            self.closed = True\n            retval = self.f.close()\n            if self.base_mode != \"r\":\n                self.__size = self.fs.get_path_info(self.name)[\"size\"]\n            return retval", "category": "Python"}, {"instruction": "async def connect(self, timeout=None, ssl=None):\n        \"\"\"\n        Establishes a connection with the server.\n        \"\"\"\n", "input": "", "output": "        await self._connect(timeout=timeout, ssl=ssl)\n        self._connected = True\n\n        self._send_task = self._loop.create_task(self._send_loop())\n        self._recv_task = self._loop.create_task(self._recv_loop())", "category": "Python"}, {"instruction": "def build_blast_cmd(self, fname, dbname):\n        \"\"\"Return BLASTN command\"\"\"\n", "input": "", "output": "        return self.funcs.blastn_func(fname, dbname, self.outdir, self.exes.blast_exe)", "category": "Python"}, {"instruction": "def _get_ds_descriptions_unsorted(\n            cls, data, ignore_keys=['attrs', 'plotter'], nums=None):\n        \"\"\"Recursive method to get all the file names or datasets out of a\n        dictionary `data` created with the :meth`array_info` method\"\"\"\n", "input": "", "output": "        ds_description = {'ds', 'fname', 'num', 'arr', 'store'}\n        if 'ds' in data:\n            # make sure that the data set has a number assigned to it\n            data['ds'].psy.num\n        keys_in_data = ds_description.intersection(data)\n        if keys_in_data:\n            return {key: data[key] for key in keys_in_data}\n        for key in ignore_keys:\n            data.pop(key, None)\n        func = partial(cls._get_ds_descriptions_unsorted,\n                       ignore_keys=ignore_keys, nums=nums)\n        return chain(*map(lambda d: [d] if isinstance(d, dict) else d,\n                          map(func, six.itervalues(data))))", "category": "Python"}, {"instruction": "def _connectToWP(self):\n        \"\"\"Establish the actual TCP connection to Flickr\"\"\"\n", "input": "", "output": "\n        if self.connected_to_wp:\n            logger.debug(\"Already connected to wp\")\n            return True\n\n        # Load config from file\n        info=json.load(open(WP_LOGIN_FILE,'r'))\n        self.wp = Client(info['url'],\\\n                info['username'],\\\n                info['password'])\n\n        logger.debug(\"Connecting to wp\")\n\n        self.connected_to_wp=True\n\n        return True", "category": "Python"}, {"instruction": "def computeDistortion(self, eEye, fU, fV):\n        \"\"\"\n        Gets the result of the distortion function for the specified eye and input UVs. UVs go from 0,0 in \n        the upper left of that eye's viewport and 1,1 in the lower right of that eye's viewport.\n        Returns true for success. Otherwise, returns false, and distortion coordinates are not suitable.\n        \"\"\"\n", "input": "", "output": "\n        fn = self.function_table.computeDistortion\n        pDistortionCoordinates = DistortionCoordinates_t()\n        result = fn(eEye, fU, fV, byref(pDistortionCoordinates))\n        return result, pDistortionCoordinates", "category": "Python"}, {"instruction": "def get_date_of_author(_id):\n    \"\"\"Pass author id and return the name of its associated date.\"\"\"\n", "input": "", "output": "    _dict = get_date_author()\n    for date, ids in _dict.items():\n        if _id in ids:\n            return date\n    return None", "category": "Python"}, {"instruction": "def options(self, parser, env):\n        \"\"\"Register commandline options.\n        \"\"\"\n", "input": "", "output": "        parser.add_option(\n            \"--epdb\", action=\"store_true\", dest=\"epdb_debugErrors\",\n            default=env.get('NOSE_EPDB', False),\n            help=\"Drop into extended debugger on errors\")\n        parser.add_option(\n            \"--epdb-failures\", action=\"store_true\",\n            dest=\"epdb_debugFailures\",\n            default=env.get('NOSE_EPDB_FAILURES', False),\n            help=\"Drop into extended debugger on failures\")", "category": "Python"}, {"instruction": "def _get_task_descriptor_info(self, courseid, taskid):\n        \"\"\"\n        :param courseid: the course id of the course\n        :param taskid: the task id of the task\n        :raise InvalidNameException, TaskNotFoundException\n        :return: a tuple, containing:\n            (descriptor filename,\n             task file manager for the descriptor)\n        \"\"\"\n", "input": "", "output": "        if not id_checker(courseid):\n            raise InvalidNameException(\"Course with invalid name: \" + courseid)\n        if not id_checker(taskid):\n            raise InvalidNameException(\"Task with invalid name: \" + taskid)\n\n        task_fs = self.get_task_fs(courseid, taskid)\n        for ext, task_file_manager in self._task_file_managers.items():\n            if task_fs.exists(\"task.\"+ext):\n                return \"task.\" + ext, task_file_manager\n\n        raise TaskNotFoundException()", "category": "Python"}, {"instruction": "def parse_comments_for_file(filename):\n    \"\"\"\n    Return a list of all parsed comments in a file.  Mostly for testing &\n    interactive use.\n    \"\"\"\n", "input": "", "output": "    return [parse_comment(strip_stars(comment), next_line)\n            for comment, next_line in get_doc_comments(read_file(filename))]", "category": "Python"}, {"instruction": "def _to_docstring(doc):\n    \"\"\"\n    format from Markdown to docstring\n    \"\"\"\n", "input": "", "output": "\n    def format_fn(line, status):\n        ", "category": "Python"}, {"instruction": "def format_command(\n    command_args,  # type: List[str]\n    command_output,  # type: str\n):\n    # type: (...) -> str\n    \"\"\"\n    Format command information for logging.\n    \"\"\"\n", "input": "", "output": "    text = 'Command arguments: {}\\n'.format(command_args)\n\n    if not command_output:\n        text += 'Command output: None'\n    elif logger.getEffectiveLevel() > logging.DEBUG:\n        text += 'Command output: [use --verbose to show]'\n    else:\n        if not command_output.endswith('\\n'):\n            command_output += '\\n'\n        text += (\n            'Command output:\\n{}'\n            '-----------------------------------------'\n        ).format(command_output)\n\n    return text", "category": "Python"}, {"instruction": "def wsgi(self, environ, start_response):\n        \"\"\"Implements the mapper's WSGI interface.\"\"\"\n", "input": "", "output": "        request = Request(environ)\n        ctx = Context(request)\n        try:\n            try:\n                response = self(request, ctx)\n                ctx._run_callbacks('finalize', (request, response))\n                response = response.conditional_to(request)\n            except HTTPException as e:\n                response = e.response\n            except Exception:\n                self.handle_error(request, ctx)\n                response = InternalServerError().response\n\n            response.add_callback(lambda: ctx._run_callbacks('close'))\n            return response(environ, start_response)\n        finally:\n            ctx._run_callbacks('teardown', log_errors=True)", "category": "Python"}, {"instruction": "def copyidfobject(self, idfobject):\n        \"\"\"Add an IDF object to the IDF.\n\n        Parameters\n        ----------\n        idfobject : EpBunch object\n            The IDF object to remove. This usually comes from another idf file,\n            or it can be used to copy within this idf file.\n\n        \"\"\"\n", "input": "", "output": "        return addthisbunch(self.idfobjects,\n                     self.model,\n                     self.idd_info,\n                     idfobject, self)", "category": "Python"}, {"instruction": "def intersection_update(self, *iterables):\n        \"\"\"\n        Update the set, keeping only elements found in it and all *iterables*.\n        \"\"\"\n", "input": "", "output": "        _set = self._set\n        _list = self._list\n        _set.intersection_update(*iterables)\n        _list.clear()\n        _list.update(_set)\n        return self", "category": "Python"}, {"instruction": "def get_point_source_fluxes(self, id, energies, tag=None):\n        \"\"\"\n        Get the fluxes from the id-th point source\n\n        :param id: id of the source\n        :param energies: energies at which you need the flux\n        :param tag: a tuple (integration variable, a, b) specifying the integration to perform. If this\n        parameter is specified then the returned value will be the average flux for the source computed as the integral\n        between a and b over the integration variable divided by (b-a). The integration variable must be an independent\n        variable contained in the model. If b is None, then instead of integrating the integration variable will be\n        set to a and the model evaluated in a.\n        :return: fluxes\n        \"\"\"\n", "input": "", "output": "\n        return self._point_sources.values()[id](energies, tag=tag)", "category": "Python"}, {"instruction": "def _titan_cn_file(cnr_file, work_dir, data):\n    \"\"\"Convert CNVkit or GATK4 normalized input into TitanCNA ready format.\n    \"\"\"\n", "input": "", "output": "    out_file = os.path.join(work_dir, \"%s.cn\" % (utils.splitext_plus(os.path.basename(cnr_file))[0]))\n    support_cols = {\"cnvkit\": [\"chromosome\", \"start\", \"end\", \"log2\"],\n                    \"gatk-cnv\": [\"CONTIG\", \"START\", \"END\", \"LOG2_COPY_RATIO\"]}\n    cols = support_cols[cnvkit.bin_approach(data)]\n    if not utils.file_uptodate(out_file, cnr_file):\n        with file_transaction(data, out_file) as tx_out_file:\n            iterator = pd.read_table(cnr_file, sep=\"\\t\", iterator=True, header=0, comment=\"@\")\n            with open(tx_out_file, \"w\") as handle:\n                for chunk in iterator:\n                    chunk = chunk[cols]\n                    chunk.columns = [\"chrom\", \"start\", \"end\", \"logR\"]\n                    if cnvkit.bin_approach(data) == \"cnvkit\":\n                        chunk['start'] += 1\n                    chunk.to_csv(handle, mode=\"a\", sep=\"\\t\", index=False)\n    return out_file", "category": "Python"}, {"instruction": "async def invites(self):\n        \"\"\"|coro|\n\n        Returns a list of all active instant invites from the guild.\n\n        You must have the :attr:`~Permissions.manage_guild` permission to get\n        this information.\n\n        Raises\n        -------\n        Forbidden\n            You do not have proper permissions to get the information.\n        HTTPException\n            An error occurred while fetching the information.\n\n        Returns\n        -------\n        List[:class:`Invite`]\n            The list of invites that are currently active.\n        \"\"\"\n", "input": "", "output": "\n        data = await self._state.http.invites_from(self.id)\n        result = []\n        for invite in data:\n            channel = self.get_channel(int(invite['channel']['id']))\n            invite['channel'] = channel\n            invite['guild'] = self\n            result.append(Invite(state=self._state, data=invite))\n\n        return result", "category": "Python"}, {"instruction": "def _reduce_boolean_pair(self, config_dict, key1, key2):\n        \"\"\"Ensure only one key with a boolean value is present in dict.\n\n        :param config_dict: dict -- dictionary of config or kwargs\n        :param key1: string -- first key name\n        :param key2: string -- second key name\n        :raises: BooleansToReduceHaveSameValue\n        \"\"\"\n", "input": "", "output": "\n        if key1 in config_dict and key2 in config_dict \\\n                and config_dict[key1] == config_dict[key2]:\n            msg = 'Boolean pair, %s and %s, have same value: %s. If both ' \\\n                'are given to this method, they cannot be the same, as this ' \\\n                'method cannot decide which one should be True.' \\\n                % (key1, key2, config_dict[key1])\n            raise BooleansToReduceHaveSameValue(msg)\n        elif key1 in config_dict and not config_dict[key1]:\n            config_dict[key2] = True\n            config_dict.pop(key1)\n        elif key2 in config_dict and not config_dict[key2]:\n            config_dict[key1] = True\n            config_dict.pop(key2)\n        return config_dict", "category": "Python"}, {"instruction": "def delete_dataset(self, dataset_name):\n        \"\"\" Deletes the dataset having the specified name\n\n        :param dataset_name: the name that the dataset has on the repository\n        :return: None\n        \"\"\"\n", "input": "", "output": "        url = self.address + \"/datasets/\" + dataset_name\n        header = self.__check_authentication()\n        response = requests.delete(url, headers=header)\n        if response.status_code != 200:\n            raise ValueError(\"Code {}: {}\".format(response.status_code, response.json().get(\"error\")))\n        self.logger.debug(\"Dataset {} was deleted from the repository\".format(dataset_name))", "category": "Python"}, {"instruction": "def synchronized(wrapped):\n    \"\"\"The missing @synchronized decorator\n\n    https://git.io/vydTA\"\"\"\n", "input": "", "output": "    _lock = threading.RLock()\n\n    @functools.wraps(wrapped)\n    def _wrapper(*args, **kwargs):\n        with _lock:\n            return wrapped(*args, **kwargs)\n    return _wrapper", "category": "Python"}, {"instruction": "def _sanitize_to_unicode(obj):\n        \"\"\"Convert all strings records of the object to unicode\n\n        :param obj: object to sanitize to unicode.\n        :type obj: object\n\n        :return: Unicode string representation of the given object.\n        :rtype: str\n        \"\"\"\n", "input": "", "output": "        if isinstance(obj, dict):\n            return dict((BaseGELFHandler._sanitize_to_unicode(k), BaseGELFHandler._sanitize_to_unicode(v)) for k, v in obj.items())\n        if isinstance(obj, (list, tuple)):\n            return obj.__class__([BaseGELFHandler._sanitize_to_unicode(i) for i in obj])\n        if isinstance(obj, data):\n            obj = obj.decode('utf-8', errors='replace')\n        return obj", "category": "Python"}, {"instruction": "def kml_network_link(href, name=None, region_coords=None, visible=True):\n    \"\"\"\n    Create the KML <NetworkLink> Tag for a certain Region in the RegionGrid.\n\n    Args:\n        region_coords (RegionCoordinate):\n        href (str): the href attribute of the NetworkLink\n        name (str): KML <name>\n        visible (bool): If true the network link will appear as 'visible'\n            (i.e. checked) in Google Earth.\n\n    Returns:\n        KMLElement: the KML <NetworkLink>\n\n    \"\"\"\n", "input": "", "output": "    nl = KML.NetworkLink()\n    if name is None and region_coords is not None:\n        name = kml_element_name(region_coords, \"NL\")\n    if name is not None:\n        nl.append(KML.name(name))\n    if region_coords is not None:\n        min_lod_pixels = DEFAULT_MIN_LOD_PIXELS * (2 ** region_coords.log_tiles_per_row)\n        nl.append(kml_region(region_coords, min_lod_pixels=min_lod_pixels))\n    if not visible:\n        nl.append(KML.visibility(0))\n\n    nl.append(KML.Link(\n        KML.href(href), KML.viewRefreshMode(\"onRegion\")))\n\n    return nl", "category": "Python"}, {"instruction": "def glymurrc_fname():\n    \"\"\"Return the path to the configuration file.\n\n    Search order:\n        1) current working directory\n        2) environ var XDG_CONFIG_HOME\n        3) $HOME/.config/glymur/glymurrc\n    \"\"\"\n", "input": "", "output": "\n    # Current directory.\n    fname = os.path.join(os.getcwd(), 'glymurrc')\n    if os.path.exists(fname):\n        return fname\n\n    confdir = get_configdir()\n    if confdir is not None:\n        fname = os.path.join(confdir, 'glymurrc')\n        if os.path.exists(fname):\n            return fname\n\n    # didn't find a configuration file.\n    return None", "category": "Python"}, {"instruction": "def from_base(cls, base, repo):\n        \"\"\"\n        Create a :class:`DXF` object which uses the same host, settings and\n        session as an existing :class:`DXFBase` object.\n\n        :param base: Existing :class:`DXFBase` object.\n        :type base: :class:`DXFBase`\n\n        :param repo: Name of the repository to access on the registry. Typically this is of the form ``username/reponame`` but for your own registries you don't actually have to stick to that.\n        :type repo: str\n\n        :returns: :class:`DXF` object which shares configuration and session with ``base`` but which can also be used to operate on the ``repo`` repository.\n        :rtype: :class:`DXF`\n        \"\"\"\n", "input": "", "output": "        # pylint: disable=protected-access\n        r = cls(base._host, repo, base._auth, base._insecure, base._auth_host, base._tlsverify)\n        r._token = base._token\n        r._headers = base._headers\n        r._sessions = [base._sessions[0]]\n        return r", "category": "Python"}, {"instruction": "def get_creators(self, *args, **kwargs):\n        \"\"\"Fetches lists of creators.\n        \n        get /v1/public/creators\n        \n        :returns:  CreatorDataWrapper\n\n        >>> m = Marvel(public_key, private_key)\n        >>> cdw = m.get_creators(lastName=\"Lee\", orderBy=\"firstName,-modified\", limit=\"5\", offset=\"15\")\n        >>> print cdw.data.total\n        25\n        >>> print cdw.data.results[0].fullName\n        Alvin Lee\n        \"\"\"\n", "input": "", "output": "        \n        response = json.loads(self._call(Creator.resource_url(), self._params(kwargs)).text)\n        return CreatorDataWrapper(self, response)", "category": "Python"}, {"instruction": "def serialize(self, outbuffer):\n\t\t\"\"\"Serialize this OmapiStartupMessage to the given outbuffer.\n\t\t@type outbuffer: OutBuffer\n\t\t\"\"\"\n", "input": "", "output": "\t\toutbuffer.add_net32int(self.protocol_version)\n\t\toutbuffer.add_net32int(self.header_size)", "category": "Python"}, {"instruction": "def setDocuments(self, documenting_pid, documented_pid):\n        \"\"\"Add a CiTO, the Citation Typing Ontology, triple asserting that\n        ``documenting_pid`` documents ``documented_pid``.\n\n        Adds assertion: ``documenting_pid cito:documents documented_pid``\n\n        Args:\n          documenting_pid: str\n            PID of a Science Object that documents ``documented_pid``.\n\n          documented_pid: str\n            PID of a Science Object that is documented by ``documenting_pid``.\n\n        \"\"\"\n", "input": "", "output": "        self._check_initialized()\n        documenting_id = self.getObjectByPid(documenting_pid)\n        documented_id = self.getObjectByPid(documented_pid)\n        self.add((documenting_id, CITO.documents, documented_id))", "category": "Python"}, {"instruction": "def calculate_lyapunov(self):\n        \"\"\"\n        Return the current Lyapunov Characteristic Number (LCN).\n        Note that you need to call init_megno() before the start of the simulation.\n        To get a timescale (the Lyapunov timescale), take the inverse of this quantity.\n        \"\"\"\n", "input": "", "output": "        if self._calculate_megno==0:\n            raise RuntimeError(\"Lyapunov Characteristic Number cannot be calculated. Make sure to call init_megno() after adding all particles but before integrating the simulation.\")\n\n        clibrebound.reb_tools_calculate_lyapunov.restype = c_double\n        return clibrebound.reb_tools_calculate_lyapunov(byref(self))", "category": "Python"}, {"instruction": "def _connect_control_flow_node(control_flow_node, next_node):\n    \"\"\"Connect a ControlFlowNode properly to the next_node.\"\"\"\n", "input": "", "output": "    for last in control_flow_node.last_nodes:\n        if isinstance(next_node, ControlFlowNode):\n            last.connect(next_node.test)  # connect to next if test case\n        elif isinstance(next_node, AssignmentCallNode):\n            call_node = next_node.call_node\n            inner_most_call_node = _get_inner_most_function_call(call_node)\n            last.connect(inner_most_call_node)\n        else:\n            last.connect(next_node)", "category": "Python"}, {"instruction": "def untrace_method(cls, method):\n    \"\"\"\n    Untraces given class method.\n\n    :param cls: Class of the method.\n    :type cls: object\n    :param method: Method to untrace.\n    :type method: object\n    :return: Definition success.\n    :rtype: bool\n    \"\"\"\n", "input": "", "output": "\n    if not is_traced(method):\n        return False\n\n    name = get_method_name(method)\n    if is_class_method(method):\n        setattr(cls, name, classmethod(untracer(method)))\n    elif is_static_method(method):\n        setattr(cls, name, staticmethod(untracer(method)))\n    else:\n        setattr(cls, name, untracer(method))\n    return True", "category": "Python"}, {"instruction": "def preprocess_input(userinput):\n  \"\"\"\n  <Purpose>\n    Preprocess the raw command line input string.\n\n  <Arguments>\n    The raw command line input string.  We assume it is pre-stripped.\n\n  <Side Effects>\n    The string will be processed by each module that has a defined preprocessor.\n\n  <Exceptions>\n    None\n\n  <Returns>\n    The preprocessed string.\n  \"\"\"\n", "input": "", "output": "  for module in get_enabled_modules():\n    # Not every module has a preprocessor...\n    if 'input_preprocessor' in module_data[module]:\n      userinput = module_data[module]['input_preprocessor'](userinput)\n  return userinput", "category": "Python"}, {"instruction": "def rescale_gradients(self, scale: float):\n        \"\"\"\n        Rescales gradient arrays of executors by scale.\n        \"\"\"\n", "input": "", "output": "        for exe in self.executors:\n            for arr in exe.grad_arrays:\n                if arr is None:\n                    continue\n                arr *= scale", "category": "Python"}, {"instruction": "def setBendLength(self, x):\n        \"\"\" set bend length\n\n        :param x: new bend length to be assigned, [m]\n        :return: None\n        \"\"\"\n", "input": "", "output": "        if x != self.bend_length:\n            self.bend_length = x\n            self.refresh = True", "category": "Python"}, {"instruction": "def clear_attendance(self):\n        \"\"\"\n        clear all attendance record\n\n        :return: bool\n        \"\"\"\n", "input": "", "output": "        command = const.CMD_CLEAR_ATTLOG\n        cmd_response = self.__send_command(command)\n        if cmd_response.get('status'):\n            return True\n        else:\n            raise ZKErrorResponse(\"Can't clear response\")", "category": "Python"}, {"instruction": "def process_ndex_network(network_id, username=None, password=None,\n                         require_grounding=True):\n    \"\"\"Process an NDEx network into Statements.\n\n    Parameters\n    ----------\n    network_id : str\n        NDEx network ID.\n    username : str\n        NDEx username.\n    password : str\n        NDEx password.\n    require_grounding: bool\n        Whether network nodes lacking grounding information should be included\n        among the extracted Statements (default is True).\n\n    Returns\n    -------\n    NdexCxProcessor\n        Processor containing Statements. Returns None if there if the HTTP\n        status code indicates an unsuccessful request.\n    \"\"\"\n", "input": "", "output": "    nd = ndex2.client.Ndex2(username=username, password=password)\n    res = nd.get_network_as_cx_stream(network_id)\n    if res.status_code != 200:\n        logger.error('Problem downloading network: status code %s' %\n                     res.status_code)\n        logger.error('Response: %s' % res.text)\n        return None\n    json_list = res.json()\n    summary = nd.get_network_summary(network_id)\n    return process_cx(json_list, summary=summary,\n                      require_grounding=require_grounding)", "category": "Python"}, {"instruction": "def locate(command, on):\n    \"\"\"Locate the command's man page.\"\"\"\n", "input": "", "output": "    location = find_page_location(command, on)\n    click.echo(location)", "category": "Python"}, {"instruction": "def delete(uid):\n        '''\n        Delete by uid\n        '''\n", "input": "", "output": "\n        q_u1 = TabPostHist.delete().where(TabPostHist.post_id == uid)\n        q_u1.execute()\n        q_u2 = TabRel.delete().where(TabRel.post_f_id == uid or TabRel.post_t_id == uid)\n        q_u2.execute()\n        q_u3 = TabCollect.delete().where(TabCollect.post_id == uid)\n        q_u3.execute()\n        q_u4 = TabPost2Tag.delete().where(TabPost2Tag.post_id == uid)\n        q_u4.execute()\n        q_u5 = TabUsage.delete().where(TabUsage.post_id == uid)\n        q_u5.execute()\n\n        reply_arr = []\n        for reply in TabUser2Reply.select().where(TabUser2Reply.reply_id == uid):\n            reply_arr.append(reply.reply_id.uid)\n\n        q_u6 = TabUser2Reply.delete().where(TabUser2Reply.reply_id == uid)\n        q_u6.execute()\n\n        for replyid in reply_arr:\n            TabReply.delete().where(TabReply.uid == replyid).execute()\n\n        q_u7 = TabEvaluation.delete().where(TabEvaluation.post_id == uid)\n        q_u7.execute()\n        q_u8 = TabRating.delete().where(TabRating.post_id == uid)\n        q_u8.execute()\n        return MHelper.delete(TabPost, uid)", "category": "Python"}, {"instruction": "def generate(env):\n    \"\"\"Add Builders and construction variables for the OS/2 to an Environment.\"\"\"\n", "input": "", "output": "    cc.generate(env)\n\n    env['CC']         = 'icc'\n    env['CCCOM']      = '$CC $CFLAGS $CCFLAGS $CPPFLAGS $_CPPDEFFLAGS $_CPPINCFLAGS /c $SOURCES /Fo$TARGET'\n    env['CXXCOM']     = '$CXX $CXXFLAGS $CPPFLAGS $_CPPDEFFLAGS $_CPPINCFLAGS /c $SOURCES /Fo$TARGET'\n    env['CPPDEFPREFIX']  = '/D'\n    env['CPPDEFSUFFIX']  = ''\n    env['INCPREFIX']  = '/I'\n    env['INCSUFFIX']  = ''\n    env['CFILESUFFIX'] = '.c'\n    env['CXXFILESUFFIX'] = '.cc'", "category": "Python"}, {"instruction": "def output_size(self) -> Tuple[Sequence[Shape], Sequence[Shape], Sequence[Shape], int]:\n        '''Returns the simulation output size.'''\n", "input": "", "output": "        return self._cell.output_size", "category": "Python"}, {"instruction": "def _set_verbosity(self):\n        '''\n        Sets the appropriate verbosity.\n        Must be called after self._test_target_files so that self.target_files is properly set.\n        '''\n", "input": "", "output": "        # If more than one target file was specified, enable verbose mode; else, there is\n        # nothing in some outputs to indicate which scan corresponds to which\n        # file.\n        if len(self.target_files) > 1 and not self.verbose:\n            self.verbose = True", "category": "Python"}, {"instruction": "def make_private(self, client=None):\n        \"\"\"Update blob's ACL, revoking read access for anonymous users.\n\n        :type client: :class:`~google.cloud.storage.client.Client` or\n                      ``NoneType``\n        :param client: Optional. The client to use.  If not passed, falls back\n                       to the ``client`` stored on the blob's bucket.\n        \"\"\"\n", "input": "", "output": "        self.acl.all().revoke_read()\n        self.acl.save(client=client)", "category": "Python"}, {"instruction": "def iter(self, bucket):\n        \"\"\"https://github.com/frictionlessdata/tableschema-bigquery-py#storage\n        \"\"\"\n", "input": "", "output": "\n        # Get schema/data\n        schema = tableschema.Schema(self.describe(bucket))\n        table_name = self.__mapper.convert_bucket(bucket)\n        response = self.__service.tabledata().list(\n            projectId=self.__project,\n            datasetId=self.__dataset,\n            tableId=table_name).execute()\n\n        # Collect rows\n        rows = []\n        for fields in response['rows']:\n            row = [field['v'] for field in fields['f']]\n            rows.append(row)\n\n        # Sort rows\n        # TODO: provide proper sorting solution\n        rows = sorted(rows, key=lambda row: row[0] if row[0] is not None else 'null')\n\n        # Emit rows\n        for row in rows:\n            row = self.__mapper.restore_row(row, schema=schema)\n            yield row", "category": "Python"}, {"instruction": "def get(self, filepath):\n        \"\"\"\n        Get the contents of the specified file.\n        \"\"\"\n", "input": "", "output": "        exists = self.fs.exists(filepath)\n        if exists:\n            mime = magic.Magic(mime=True)\n            mime_type = mime.from_file(filepath)\n            if mime_type in self.unsupported_types:\n                self.set_status(204)\n                return\n            else:\n                contents = self.fs.read_file(filepath)\n            self.write({'filepath':filepath,'contents': contents})\n        else:\n            raise tornado.web.HTTPError(404)", "category": "Python"}, {"instruction": "def _R2deriv(self,R,phi=0.,t=0.):\n        \"\"\"\n        NAME:\n           _R2deriv\n        PURPOSE:\n           evaluate the second radial derivative\n        INPUT:\n           R\n           phi\n           t\n        OUTPUT:\n           d2phi/dR2\n        HISTORY:\n           2016-06-02 - Written - Bovy (UofT)\n        \"\"\"\n", "input": "", "output": "        return self._Pot.R2deriv(R,0.,phi=phi,t=t,use_physical=False)", "category": "Python"}, {"instruction": "def retire(self, process_schemas):\n        \"\"\"Retire obsolete processes.\n\n        Remove old process versions without data. Find processes that have been\n        registered but do not exist in the code anymore, then:\n\n        - If they do not have data: remove them\n        - If they have data: flag them not active (``is_active=False``)\n\n        \"\"\"\n", "input": "", "output": "        process_slugs = set(ps['slug'] for ps in process_schemas)\n\n        # Processes that are in DB but not in the code\n        retired_processes = Process.objects.filter(~Q(slug__in=process_slugs))\n\n        # Remove retired processes which do not have data\n        retired_processes.filter(data__exact=None).delete()\n\n        # Remove non-latest processes which do not have data\n        latest_version_processes = Process.objects.order_by('slug', '-version').distinct('slug')\n        Process.objects.filter(data__exact=None).difference(latest_version_processes).delete()\n\n        # Deactivate retired processes which have data\n        retired_processes.update(is_active=False)", "category": "Python"}, {"instruction": "def from_ros_pose_msg(pose_msg,\n                          from_frame='unassigned',\n                          to_frame='world'):\n        \"\"\"Creates a RigidTransform from a ROS pose msg. \n        \n        Parameters\n        ----------\n        pose_msg : :obj:`geometry_msgs.msg.Pose`\n            ROS pose message\n        \"\"\"\n", "input": "", "output": "        quaternion = np.array([pose_msg.orientation.w,\n                               pose_msg.orientation.x,\n                               pose_msg.orientation.y,\n                               pose_msg.orientation.z])\n        position = np.array([pose_msg.position.x,\n                             pose_msg.position.y,\n                             pose_msg.position.z])\n        pose = RigidTransform(rotation=quaternion,\n                              translation=position,\n                              from_frame=from_frame,\n                              to_frame=to_frame)\n        return pose", "category": "Python"}, {"instruction": "def get_lookup_value(self, value):\n        \"\"\"\n        Override this method to convert displayed values to lookup values\n        \"\"\"\n", "input": "", "output": "        choices = self._field_choices()\n        if choices:\n            if isinstance(value, list):\n                return [c[0] for c in choices if c[1] in value]\n            else:\n                for c in choices:\n                    if c[1] == value:\n                        return c[0]\n        return value", "category": "Python"}, {"instruction": "def _format_executable(lines, element, spacer=\"\"):\n    \"\"\"Performs formatting specific to a Subroutine or Function code\n    element for relevant docstrings.\n    \"\"\"\n", "input": "", "output": "    rlines = []\n    rlines.append(element.signature)\n    _format_summary(rlines, element)\n\n    rlines.append(\"\")\n    rlines.append(\"PARAMETERS\")\n    for p in element.ordered_parameters:\n        _format_value_element(rlines, p)\n\n    rlines.append(\"\")\n    _format_generic(rlines, element, [\"summary\"])\n\n    #Subroutines can have embedded types and functions which need to be handled.\n    if len(element.types) > 0:\n        rlines.append(\"\\nEMBEDDED TYPES\")\n        for key, value in list(element.types.items()):\n            _format_type(rlines, value, \"  \")\n\n    if len(element.executables) > 0:\n        rlines.append(\"\\nEMBEDDED EXECUTABLES\")\n        for key, value in list(element.executables.items()):\n            _format_executable(rlines, value, \"  \")\n\n    lines.extend([spacer + l for l in rlines])", "category": "Python"}, {"instruction": "async def get_sleep_timer_settings(self) -> List[Setting]:\n        \"\"\"Get sleep timer settings.\"\"\"\n", "input": "", "output": "        return [\n            Setting.make(**x)\n            for x in await self.services[\"system\"][\"getSleepTimerSettings\"]({})\n        ]", "category": "Python"}, {"instruction": "def get_extents(self):\n        \"\"\"Return the extents of the recording-surface.\n\n        :returns:\n            A ``(x, y, width, height)`` tuple of floats,\n            or :obj:`None` if the surface is unbounded.\n\n        *New in cairo 1.12*\n\n        \"\"\"\n", "input": "", "output": "        extents = ffi.new('cairo_rectangle_t *')\n        if cairo.cairo_recording_surface_get_extents(self._pointer, extents):\n            return (extents.x, extents.y, extents.width, extents.height)", "category": "Python"}, {"instruction": "def calc_prob_mom(returns, other_returns):\n    \"\"\"\n    `Probabilistic momentum <http://cssanalytics.wordpress.com/2014/01/28/are-simple-momentum-strategies-too-dumb-introducing-probabilistic-momentum/>`_ (see `momentum investing <https://www.investopedia.com/terms/m/momentum_investing.asp>`_)\n\n    Basically the \"probability or confidence that one asset\n    is going to outperform the other\".\n\n    Source:\n        http://cssanalytics.wordpress.com/2014/01/28/are-simple-momentum-strategies-too-dumb-introducing-probabilistic-momentum/ # NOQA\n    \"\"\"\n", "input": "", "output": "    return t.cdf(returns.calc_information_ratio(other_returns),\n                 len(returns) - 1)", "category": "Python"}, {"instruction": "def all_stats(klass, account, ids, metric_groups, **kwargs):\n        \"\"\"\n        Pulls a list of metrics for a specified set of object IDs.\n        \"\"\"\n", "input": "", "output": "        params = klass._standard_params(ids, metric_groups, **kwargs)\n\n        resource = klass.RESOURCE_SYNC.format(account_id=account.id)\n        response = Request(account.client, 'get', resource, params=params).perform()\n        return response.body['data']", "category": "Python"}, {"instruction": "def contract_to_dict(contract):\n    \"\"\"Convert an IBPy Contract object to a dict containing any non-default values.\"\"\"\n", "input": "", "output": "    default = Contract()\n    return {field: val for field, val in vars(contract).items() if val != getattr(default, field, None)}", "category": "Python"}, {"instruction": "def get_packages_of_type(self, package_types, mask=None):\n        \"\"\"Get packages that match a certain type.\n\n        Each ordering package has a type, so return all packages that match\n        the types we are looking for\n\n        :param list package_types: List of strings representing the package\n                                   type keynames we are interested in.\n        :param string mask: Mask to specify the properties we want to retrieve\n        \"\"\"\n", "input": "", "output": "\n        _filter = {\n            'type': {\n                'keyName': {\n                    'operation': 'in',\n                    'options': [\n                        {'name': 'data',\n                         'value': package_types}\n                    ],\n                },\n            },\n        }\n\n        packages = self.package_svc.getAllObjects(mask=mask, filter=_filter)\n        packages = self.filter_outlet_packages(packages)\n        return packages", "category": "Python"}, {"instruction": "def remove_end_optionals(ir_blocks):\n    \"\"\"Return a list of IR blocks as a copy of the original, with EndOptional blocks removed.\"\"\"\n", "input": "", "output": "    new_ir_blocks = []\n    for block in ir_blocks:\n        if not isinstance(block, EndOptional):\n            new_ir_blocks.append(block)\n    return new_ir_blocks", "category": "Python"}, {"instruction": "def parse_response_start_line(line: str) -> ResponseStartLine:\n    \"\"\"Returns a (version, code, reason) tuple for an HTTP 1.x response line.\n\n    The response is a `collections.namedtuple`.\n\n    >>> parse_response_start_line(\"HTTP/1.1 200 OK\")\n    ResponseStartLine(version='HTTP/1.1', code=200, reason='OK')\n    \"\"\"\n", "input": "", "output": "    line = native_str(line)\n    match = re.match(\"(HTTP/1.[0-9]) ([0-9]+) ([^\\r]*)\", line)\n    if not match:\n        raise HTTPInputError(\"Error parsing response start line\")\n    return ResponseStartLine(match.group(1), int(match.group(2)), match.group(3))", "category": "Python"}, {"instruction": "def remove_description(self, id, **kwargs):  # noqa: E501\n        \"\"\"Remove description from a specific source  # noqa: E501\n\n          # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.remove_description(id, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id: (required)\n        :return: ResponseContainer\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n", "input": "", "output": "        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async_req'):\n            return self.remove_description_with_http_info(id, **kwargs)  # noqa: E501\n        else:\n            (data) = self.remove_description_with_http_info(id, **kwargs)  # noqa: E501\n            return data", "category": "Python"}, {"instruction": "def get_datas(callback, macs=[], run_flag=RunFlag(), bt_device=''):\n        \"\"\"\n        Get data for all ruuvitag sensors or sensors in the MAC's list.\n\n        Args:\n            callback (func): callback funcion to be called when new data is received\n            macs (list): MAC addresses\n            run_flag (object): RunFlag object. Function executes while run_flag.running\n            bt_device (string): Bluetooth device id\n        \"\"\"\n", "input": "", "output": "\n        log.info('Get latest data for sensors. Stop with Ctrl+C.')\n        log.info('MACs: %s', macs)\n\n        for new_data in RuuviTagSensor._get_ruuvitag_datas(macs, None, run_flag, bt_device):\n            callback(new_data)", "category": "Python"}, {"instruction": "def diff(self, n=1):\n    \"\"\"\n    Differentiate (n-th derivative, where the default n is 1).\n    \"\"\"\n", "input": "", "output": "    d = self._data\n    for unused in xrange(n):\n      d = OrderedDict((k - 1, k * v) for k, v in iteritems(d) if k != 0)\n    return Poly(d, zero=self.zero)", "category": "Python"}, {"instruction": "def flatten_iterable(iterable):\r\n    \"\"\"flatten iterable, but leaves out strings\r\n\r\n    [[[1, 2, 3], [4, 5]], 6] -> [1, 2, 3, 4, 5, 6]\r\n\r\n    \"\"\"\n", "input": "", "output": "    for item in iterable:\r\n        if isinstance(item, collections.Iterable) and not isinstance(item, basestring):\r\n            for sub in flatten_iterable(item):\r\n                yield sub\r\n        else:\r\n            yield item", "category": "Python"}, {"instruction": "def invalid_multipoly_handler(gdf, relation, way_ids):\n    \"\"\"\n    Handles invalid multipolygon geometries when there exists e.g. a feature without \n    geometry (geometry == NaN)\n\n    Parameters\n    ----------\n\n    gdf : gpd.GeoDataFrame\n        GeoDataFrame with Polygon geometries that should be converted into a MultiPolygon object.\n    relation : dict\n        OSM 'relation' dictionary\n    way_ids : list\n        A list of 'way' ids that should be converted into a MultiPolygon object. \n    \"\"\"\n", "input": "", "output": "\n    try:\n        gdf_clean = gdf.dropna(subset=['geometry'])\n        multipoly = MultiPolygon(list(gdf_clean['geometry']))\n        return multipoly\n\n    except Exception:\n        log(\"Invalid geometry at relation id %s.\\nWay-ids of the invalid MultiPolygon:\" % (\n        relation['id'], str(way_ids)))\n        return None", "category": "Python"}, {"instruction": "def new(cls, freeform_builder, x, y):\n        \"\"\"Return a new _LineSegment object ending at point *(x, y)*.\n\n        Both *x* and *y* are rounded to the nearest integer before use.\n        \"\"\"\n", "input": "", "output": "        return cls(freeform_builder, int(round(x)), int(round(y)))", "category": "Python"}, {"instruction": "def connectionMade(self):\n        \"\"\"Keep a reference to the protocol on the factory, and uses the\n        factory's store to find multiplexed connection factories.\n\n        Unfortunately, we can't add the protocol by TLS certificate\n        fingerprint, because the TLS handshake won't have completed\n        yet, so ``self.transport.getPeerCertificate()`` is still\n        ``None``.\n\n        \"\"\"\n", "input": "", "output": "        self.factory.protocols.add(self)\n        self._factories = multiplexing.FactoryDict(self.store)\n        super(AMP, self).connectionMade()", "category": "Python"}, {"instruction": "def filesystem_absent(name, force=False, recursive=False):\n    '''\n    ensure filesystem is absent on the system\n\n    name : string\n        name of filesystem\n    force : boolean\n        try harder to destroy the dataset (zfs destroy -f)\n    recursive : boolean\n        also destroy all the child datasets (zfs destroy -r)\n\n    .. warning::\n\n        If a volume with ``name`` exists, this state will succeed without\n        destroying the volume specified by ``name``. This module is dataset type sensitive.\n\n    '''\n", "input": "", "output": "    if not __utils__['zfs.is_dataset'](name):\n        ret = {'name': name,\n               'changes': {},\n               'result': False,\n               'comment': 'invalid dataset name: {0}'.format(name)}\n    else:\n        ret = _absent(name, 'filesystem', force, recursive)\n    return ret", "category": "Python"}, {"instruction": "def histogram_summary(tag, values, bins):\n    \"\"\"Outputs a `Summary` protocol buffer with a histogram.\n    Adding a histogram summary makes it possible to visualize the data's distribution in\n    TensorBoard. See detailed explanation of the TensorBoard histogram dashboard at\n    https://www.tensorflow.org/get_started/tensorboard_histograms\n    This op reports an `InvalidArgument` error if any value is not finite.\n    Adapted from the TensorFlow function `histogram()` at\n    https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/summary/summary.py\n\n    Parameters\n    ----------\n        tag : str\n            A name for the summary of the histogram. Will also serve as a series name in\n            TensorBoard.\n        values : MXNet `NDArray` or `numpy.ndarray`\n            Values for building the histogram.\n\n    Returns\n    -------\n        A `Summary` protobuf of the histogram.\n    \"\"\"\n", "input": "", "output": "    tag = _clean_tag(tag)\n    values = _make_numpy_array(values)\n    hist = _make_histogram(values.astype(float), bins)\n    return Summary(value=[Summary.Value(tag=tag, histo=hist)])", "category": "Python"}, {"instruction": "def basemz(df):\n    \"\"\"\n    The mz of the most abundant ion.\n    \"\"\"\n", "input": "", "output": "    # returns the\n    d = np.array(df.columns)[df.values.argmax(axis=1)]\n    return Trace(d, df.index, name='basemz')", "category": "Python"}, {"instruction": "def _delete(self, pk):\n        \"\"\"\n            Delete function logic, override to implement different logic\n            deletes the record with primary_key = pk\n\n            :param pk:\n                record primary key to delete\n        \"\"\"\n", "input": "", "output": "        item = self.datamodel.get(pk, self._base_filters)\n        if not item:\n            abort(404)\n        try:\n            self.pre_delete(item)\n        except Exception as e:\n            flash(str(e), \"danger\")\n        else:\n            if self.datamodel.delete(item):\n                self.post_delete(item)\n            flash(*self.datamodel.message)\n            self.update_redirect()", "category": "Python"}, {"instruction": "def reset_password(self, user, password):\n        \"\"\"\n        Service method to reset a user's password. The same as :meth:`change_password`\n        except we this method sends a different notification email.\n\n        Sends signal `password_reset`.\n\n        :param user:\n        :param password:\n        :return:\n        \"\"\"\n", "input": "", "output": "        user.password = password\n        self.user_manager.save(user)\n        if app.config.SECURITY_SEND_PASSWORD_RESET_NOTICE_EMAIL:\n            self.send_mail(\n                _('flask_unchained.bundles.security:email_subject.password_reset_notice'),\n                to=user.email,\n                template='security/email/password_reset_notice.html',\n                user=user)\n        password_reset.send(app._get_current_object(), user=user)", "category": "Python"}, {"instruction": "def new_worker(self, name: str):\n        \"\"\"Creates a new Worker and start a new Thread with it. Returns the Worker.\"\"\"\n", "input": "", "output": "        if not self.running:\n            return self.immediate_worker\n        worker = self._new_worker(name)\n        self._start_worker(worker)\n        return worker", "category": "Python"}, {"instruction": "def run(self, app):\n        \"\"\"Function starts the web server given configuration.\"\"\"\n", "input": "", "output": "        GlimLog.info('Glim server started on %s environment' % self.args.env)\n        try:\n            kwargs = Config.get('app.server.options')\n            run(app.wsgi,\n                host=Config.get('app.server.host'),\n                port=Config.get('app.server.port'),\n                debug=Config.get('app.server.debugger'),\n                reloader=Config.get('app.server.reloader'),\n                server=Config.get('app.server.wsgi'),\n                **kwargs)\n        except Exception as e:\n            print(traceback.format_exc())\n            exit()", "category": "Python"}, {"instruction": "def strip_spaces_and_quotes(value):\n    \"\"\"Remove invalid whitespace and/or single pair of dquotes and return None\n    for empty strings.\n\n    Used to prepare cookie values, path, and domain attributes in a way which\n    tolerates simple formatting mistakes and standards variations.\n    \"\"\"\n", "input": "", "output": "    value = value.strip() if value else \"\"\n    if value and len(value) > 1 and (value[0] == value[-1] == '\"'):\n        value = value[1:-1]\n    if not value:\n        value = \"\"\n    return value", "category": "Python"}, {"instruction": "def format_page(self, page):\n        \"\"\"\n        Banana banana\n        \"\"\"\n", "input": "", "output": "        self.formatting_page_signal(self, page)\n        return self._format_page(page)", "category": "Python"}, {"instruction": "def apply_flat(self, config, namespace_separator='_', prefix=''):\n        # type: (Dict[str, Any], str, str) -> None\n        \"\"\"Apply additional configuration from a flattened dictionary\n\n        This will look for dictionary items that match flattened keys from base_config and apply their values on the\n        current configuration object.\n\n        This can be useful for applying configuration from environment variables and flat configuration file formats\n        such as INI files.\n        \"\"\"\n", "input": "", "output": "        self._init_flat_pointers()\n        for key_stack, (container, orig_key) in self._flat_pointers.items():\n            flat_key = '{prefix}{joined_key}'.format(prefix=prefix, joined_key=namespace_separator.join(key_stack))\n            if flat_key in config:\n                container[orig_key] = config[flat_key]", "category": "Python"}, {"instruction": "def next(self):\n        \"\"\"Next point in iteration\n        \"\"\"\n", "input": "", "output": "        if self.probability == 1:\n            x, y = next(self.scan)\n        else:\n            while True:\n                x, y = next(self.scan)\n                if random.random() <= self.probability: break\n        return x, y", "category": "Python"}, {"instruction": "def do_gen(argdict):\n    '''Generate the whole site.'''\n", "input": "", "output": "    site = make_site_obj(argdict)\n    try:\n        st = time.time()\n        site.generate()\n        et = time.time()\n        print \"Generated Site in %f seconds.\"% (et-st)\n    except ValueError as e: # pragma: no cover\n        print \"Cannot generate. You are not within a simplystatic \\\ntree and you didn't specify a directory.\"", "category": "Python"}, {"instruction": "def save_config(self, cmd=\"save\", confirm=False, confirm_response=\"\"):\n        \"\"\" Save Config for HuaweiSSH\"\"\"\n", "input": "", "output": "        return super(HuaweiBase, self).save_config(\n            cmd=cmd, confirm=confirm, confirm_response=confirm_response\n        )", "category": "Python"}, {"instruction": "def build_indentation_list(parser: str = 'github'):\n    r\"\"\"Create a data structure that holds the state of indentations.\n\n    :parameter parser: decides the length of the list.\n         Defaults to ``github``.\n    :type parser: str\n    :returns: indentation_list, a list that contains the state of\n         indentations given a header type.\n    :rtype: list\n    :raises: a built-in exception.\n    \"\"\"\n", "input": "", "output": "    indentation_list = list()\n\n    if (parser == 'github' or parser == 'cmark' or parser == 'gitlab'\n            or parser == 'commonmarker' or parser == 'redcarpet'):\n        for i in range(0, md_parser[parser]['header']['max_levels']):\n            indentation_list.append(False)\n\n    return indentation_list", "category": "Python"}, {"instruction": "def setButtonText(self, which, text):\n        \"\"\"\n        Sets the display text for the inputed button to the given text.\n\n        :param      which | <XOverlayWizard.WizardButton>\n                    text  | <str>\n        \"\"\"\n", "input": "", "output": "        try:\n            self._buttons[which].setText(text)\n        except KeyError:\n            pass", "category": "Python"}, {"instruction": "def save(self, list_file):\n    \"\"\"Saves the current list of annotations to the given file.\n\n    **Parameters:**\n\n    ``list_file`` : str\n      The name of a list file to write the currently stored list into\n    \"\"\"\n", "input": "", "output": "    bob.io.base.create_directories_safe(os.path.dirname(list_file))\n    with open(list_file, 'w') as f:\n      for i in range(len(self.image_paths)):\n        f.write(self.image_paths[i])\n        for bbx in self.bounding_boxes[i]:\n          f.write(\"\\t[%f %f %f %f]\" % (bbx.top_f, bbx.left_f, bbx.size_f[0], bbx.size_f[1]))\n        f.write(\"\\n\")", "category": "Python"}, {"instruction": "def toString(self):\n        \"\"\"\n        Returns the network layers as a string.\n        \"\"\"\n", "input": "", "output": "        output = \"\"\n        for layer in reverse(self.layers):\n            output += layer.toString()\n        return output", "category": "Python"}, {"instruction": "def load(self):\r\n        \"\"\"\r\n        Loads the children for this record item.\r\n        \r\n        :return     <bool> | changed\r\n        \"\"\"\n", "input": "", "output": "        if self.__loaded:\r\n            return False\r\n        \r\n        self.__loaded = True\r\n        self.setChildIndicatorPolicy(self.DontShowIndicatorWhenChildless)\r\n        \r\n        # loads the children for this widget\r\n        tree = self.treeWidget()\r\n        if tree.groupBy():\r\n            grps = self.childRecords().grouped(tree.groupBy())\r\n            for grp, records in grps.items():\r\n                tree.createGroupItem(grp, records, self)\r\n        else:\r\n            for record in self.childRecords():\r\n                tree.createRecordItem(record, self)\r\n        \r\n        return True", "category": "Python"}, {"instruction": "def set_virtualization_realm_type(self):\n        \"\"\"Sets the virtualization realm type from deployment properties\n\n        :return: None\n        \"\"\"\n", "input": "", "output": "        log = logging.getLogger(self.cls_logger + '.set_virtualization_realm_type')\n        self.virtualization_realm_type = self.get_value('cons3rt.deploymentRun.virtRealm.type')\n        log.info('Found virtualization realm type : {t}'.format(t=self.virtualization_realm_type))", "category": "Python"}, {"instruction": "def initialize_segment_register_x64(self, state, concrete_target):\n        \"\"\"\n        Set the gs register in the angr to the value of the fs register in the concrete process\n\n        :param state:               state which will be modified\n        :param concrete_target:     concrete target that will be used to read the fs register\n        :return: None\n       \"\"\"\n", "input": "", "output": "        _l.debug(\"Synchronizing gs segment register\")\n        state.regs.gs = self._read_gs_register_x64(concrete_target)", "category": "Python"}, {"instruction": "def CreateFeedItemAddOperation(name, price, date, ad_customizer_feed):\n  \"\"\"Creates a FeedItemOperation.\n\n  The generated FeedItemOperation will create a FeedItem with the specified\n  values when sent to FeedItemService.mutate.\n\n  Args:\n    name: the value for the name attribute of the FeedItem.\n    price: the value for the price attribute of the FeedItem.\n    date: the value for the date attribute of the FeedItem.\n    ad_customizer_feed: the AdCustomizerFeed we're associating the FeedItems\n        with.\n\n  Returns:\n    A new FeedItemOperation for adding a FeedItem.\n  \"\"\"\n", "input": "", "output": "  feed_item = {\n      'feedId': ad_customizer_feed['feedId'],\n      'attributeValues': [\n          {\n              'feedAttributeId': ad_customizer_feed['feedAttributes'][0]['id'],\n              'stringValue': name\n          },\n          {\n              'feedAttributeId': ad_customizer_feed['feedAttributes'][1]['id'],\n              'stringValue': price\n          },\n          {\n              'feedAttributeId': ad_customizer_feed['feedAttributes'][2]['id'],\n              'stringValue': date\n          }\n      ]\n  }\n\n  operation = {\n      'operator': 'ADD',\n      'operand': feed_item\n  }\n\n  return operation", "category": "Python"}, {"instruction": "def apply(self, something: 'Reader') -> 'Reader':\n        r\"\"\"(<*>) :: f (a -> b) -> f a -> f b.\n\n        Haskell: f <*> g = \\x -> f x (g x)\n\n        Apply (<*>) is a beefed up map. It takes a Reader that\n        has a function in it and another Reader, and extracts that\n        function from the first Reader and then maps it over the second\n        one (composes the two functions).\n        \"\"\"\n", "input": "", "output": "\n        def _compose(x: Any):\n            f = self.run(x)\n            try:\n                ret = f(something.run(x))\n            except TypeError:\n                ret = partial(f, something.run(x))\n            return ret\n\n        return Reader(_compose)", "category": "Python"}, {"instruction": "def require_representation(self, req):\n        \"\"\"Require raw representation dictionary from falcon request object.\n\n        This does not perform any field parsing or validation but only uses\n        allowed content-encoding handler to decode content body.\n\n        Note:\n            Currently only JSON is allowed as content type.\n\n        Args:\n            req (falcon.Request): request object\n\n        Returns:\n            dict: raw dictionary of representation supplied in request body\n\n        \"\"\"\n", "input": "", "output": "        try:\n            type_, subtype, _ = parse_mime_type(req.content_type)\n            content_type = '/'.join((type_, subtype))\n        except:\n            raise falcon.HTTPUnsupportedMediaType(\n                description=\"Invalid Content-Type header: {}\".format(\n                    req.content_type\n                )\n            )\n\n        if content_type == 'application/json':\n            body = req.stream.read()\n            return json.loads(body.decode('utf-8'))\n        else:\n            raise falcon.HTTPUnsupportedMediaType(\n                description=\"only JSON supported, got: {}\".format(content_type)\n            )", "category": "Python"}, {"instruction": "def ls(self, src, extra_args=[]):\n        '''List files in a directory'''\n", "input": "", "output": "        src = [self._full_hdfs_path(x) for x in src]\n        output = self._getStdOutCmd([self._hadoop_cmd, 'fs', '-ls'] + extra_args + src, True)\n        return self._transform_ls_output(output, self.hdfs_url)", "category": "Python"}, {"instruction": "def vertex_fingerprints(self):\n        \"\"\"A fingerprint for each vertex\n\n           The result is invariant under permutation of the vertex indexes.\n           Vertices that are symmetrically equivalent will get the same\n           fingerprint, e.g. the hydrogens in methane would get the same\n           fingerprint.\n        \"\"\"\n", "input": "", "output": "        return self.get_vertex_fingerprints(\n            [self.get_vertex_string(i) for i in range(self.num_vertices)],\n            [self.get_edge_string(i) for i in range(self.num_edges)],\n        )", "category": "Python"}, {"instruction": "def median(array):\n    \"\"\"\n    Return the median value of a list of numbers.\n    \"\"\"\n", "input": "", "output": "    n = len(array)\n\n    if n < 1:\n        return 0\n    elif n == 1:\n        return array[0]\n\n    sorted_vals = sorted(array)\n    midpoint = int(n / 2)\n    if n % 2 == 1:\n        return sorted_vals[midpoint]\n    else:\n        return (sorted_vals[midpoint - 1] + sorted_vals[midpoint]) / 2.0", "category": "Python"}, {"instruction": "def discussions_notifications(user):\n    '''Notify user about open discussions'''\n", "input": "", "output": "    notifications = []\n\n    # Only fetch required fields for notification serialization\n    # Greatly improve performances and memory usage\n    qs = discussions_for(user).only('id', 'created', 'title', 'subject')\n\n    # Do not dereference subject (so it's a DBRef)\n    # Also improve performances and memory usage\n    for discussion in qs.no_dereference():\n        notifications.append((discussion.created, {\n            'id': discussion.id,\n            'title': discussion.title,\n            'subject': {\n                'id': discussion.subject['_ref'].id,\n                'type': discussion.subject['_cls'].lower(),\n            }\n        }))\n\n    return notifications", "category": "Python"}, {"instruction": "def query(self, queryEngine, query=None, vendorSpecific=None, **kwargs):\n        \"\"\"See Also: queryResponse()\n\n        Args:\n          queryEngine:\n          query:\n          vendorSpecific:\n          **kwargs:\n\n        Returns:\n\n        \"\"\"\n", "input": "", "output": "        response = self.queryResponse(queryEngine, query, vendorSpecific, **kwargs)\n        return self._read_stream_response(response)", "category": "Python"}, {"instruction": "def _file_md5(file_):\n    \"\"\"\n    Compute the md5 digest of a file in base64 encoding.\n    \"\"\"\n", "input": "", "output": "    md5 = hashlib.md5()\n    chunk_size = 128 * md5.block_size\n    for chunk in iter(lambda: file_.read(chunk_size), b''):\n        md5.update(chunk)\n    file_.seek(0)\n    byte_digest = md5.digest()\n    return base64.b64encode(byte_digest).decode()", "category": "Python"}, {"instruction": "def help(ctx, topic, **kw):\n    \"\"\"Show help for any command.\n    \"\"\"\n", "input": "", "output": "    # The help command implementation is taken from\n    # https://www.burgundywall.com/post/having-click-help-subcommand\n    if topic is None:\n        click.echo(ctx.parent.get_help())\n    else:\n        click.echo(main.commands[topic].get_help(ctx))", "category": "Python"}, {"instruction": "def _request(self, typ, id=0, method='GET', params=None, data=None, url=None):\n        \"\"\"\n        send the request, return response obj\n        \"\"\"\n", "input": "", "output": "\n        headers = { \"Accept\": \"application/json\" }\n        auth = None\n\n        if self.user:\n            auth = (self.user, self.password)\n\n        if not url:\n            if id:\n                url = \"%s/%s/%s\" % (self.url, typ, id)\n            else:\n                url = \"%s/%s\" % (self.url, typ)\n\n        return requests.request(method, url, params=params, data=data, auth=auth, headers=headers)", "category": "Python"}, {"instruction": "def rho2sigma(self, rho0, Ra, Rs):\n        \"\"\"\n        converts 3d density into 2d projected density parameter\n        :param rho0:\n        :param Ra:\n        :param Rs:\n        :return:\n        \"\"\"\n", "input": "", "output": "        return np.pi * rho0 * Ra * Rs / (Rs + Ra)", "category": "Python"}, {"instruction": "def wrap_sequence(sequence, books=None, tensor_shape=None):\n  \"\"\"Creates an input layer representing the given sequence of tensors.\n\n  Args:\n    sequence: A sequence of tensors.\n    books: The bookkeeper.\n    tensor_shape: An optional shape that will be set on the Tensor or verified\n      to match the tensor.\n  Returns:\n    A layer.\n  \"\"\"\n", "input": "", "output": "  if books is None:\n    books = bookkeeper.for_default_graph()\n  my_sequence = [\n      wrap(t, books=books, tensor_shape=tensor_shape) for t in sequence]\n  return Layer(books, sequence=my_sequence, name=my_sequence[0].name)", "category": "Python"}, {"instruction": "def is_not_null_predicate(\n    raw_crash, dumps, processed_crash, processor, key=''\n):\n    \"\"\"a predicate that converts the key'd source to boolean.\n\n    parameters:\n        raw_crash - dict\n        dumps - placeholder in a fat interface - unused\n        processed_crash - placeholder in a fat interface - unused\n        processor - placeholder in a fat interface - unused\n    \"\"\"\n", "input": "", "output": "    try:\n        return bool(raw_crash[key])\n    except KeyError:\n        return False", "category": "Python"}, {"instruction": "def reflected_light_intensity(self):\n        \"\"\"\n        A measurement of the reflected light intensity, as a percentage.\n        \"\"\"\n", "input": "", "output": "        self._ensure_mode(self.MODE_REFLECT)\n        return self.value(0) * self._scale('REFLECT')", "category": "Python"}, {"instruction": "def defaultFile(self):\n        \"\"\"Produce a reasonable default.\"\"\"\n", "input": "", "output": "        filename = self.curframe.f_code.co_filename\n        if filename == '<string>' and self.mainpyfile:\n            filename = self.mainpyfile\n        return filename", "category": "Python"}, {"instruction": "def get_client(self):\n        \"\"\"\n        Retrieves or creates a client instance from this configuration object. If instantiated from this configuration,\n        the resulting object is also cached in the property ``client`` and a reference to this configuration is stored\n        on the client object.\n\n        :return: Client object instance.\n        :rtype: docker.client.Client\n        \"\"\"\n", "input": "", "output": "        client = self._client\n        if not client:\n            self._client = client = self.client_constructor(**self.get_init_kwargs())\n            client.client_configuration = self\n            # Client might update the version number after construction.\n            updated_version = getattr(client, 'api_version', None)\n            if updated_version:\n                self.version = updated_version\n        return client", "category": "Python"}, {"instruction": "def get(cls, device_server_id, custom_headers=None):\n        \"\"\"\n        Get one of your DeviceServers.\n\n        :type api_context: context.ApiContext\n        :type device_server_id: int\n        :type custom_headers: dict[str, str]|None\n\n        :rtype: BunqResponseDeviceServer\n        \"\"\"\n", "input": "", "output": "\n        if custom_headers is None:\n            custom_headers = {}\n\n        api_client = client.ApiClient(cls._get_api_context())\n        endpoint_url = cls._ENDPOINT_URL_READ.format(device_server_id)\n        response_raw = api_client.get(endpoint_url, {}, custom_headers)\n\n        return BunqResponseDeviceServer.cast_from_bunq_response(\n            cls._from_json(response_raw, cls._OBJECT_TYPE_GET)\n        )", "category": "Python"}, {"instruction": "def extract_points(self, pid, points):\n        \"\"\"Extract values at certain points in the grid from a given parameter\n        set. Cells are selected by interpolating the centroids of the cells\n        towards the line using a \"nearest\" scheme.\n\n        Note that data is only returned for the points provided. If you want to\n        extract multiple data points along a line, defined by start and end\n        point, use the **extract_along_line** function.\n\n        Parameters\n        ----------\n        pid: int\n            The parameter id to extract values from\n        points: Nx2 numpy.ndarray\n            (x, y) pairs\n\n        Returns\n        -------\n        values: numpy.ndarray (n x 1)\n            data values for extracted data points\n        \"\"\"\n", "input": "", "output": "        xy = self.grid.get_element_centroids()\n        data = self.parsets[pid]\n\n        iobj = spi.NearestNDInterpolator(xy, data)\n        values = iobj(points)\n        return values", "category": "Python"}, {"instruction": "def add_selected(self, ):\n        \"\"\"Create a new reftrack with the selected element and type and add it to the root.\n\n        :returns: None\n        :rtype: None\n        :raises: NotImplementedError\n        \"\"\"\n", "input": "", "output": "        browser = self.shot_browser if self.browser_tabw.currentIndex() == 1 else self.asset_browser\n        selelements = browser.selected_indexes(2)\n        if not selelements:\n            return\n        seltypes = browser.selected_indexes(3)\n        if not seltypes:\n            return\n        elementi = selelements[0]\n        typi = seltypes[0]\n        if not elementi.isValid() or not typi.isValid():\n            return\n        element = elementi.internalPointer().internal_data()\n        typ = typi.internalPointer().internal_data()[0]\n\n        reftrack.Reftrack(self.root, self.refobjinter, typ=typ, element=element)", "category": "Python"}, {"instruction": "def get_formats(\n        self, token: dict = None, format_code: str = None, prot: str = \"https\"\n    ) -> dict:\n        \"\"\"Get formats.\n\n        :param str token: API auth token\n        :param str format_code: code of a specific format\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n        \"\"\"\n", "input": "", "output": "        # if specific format\n        if isinstance(format_code, str):\n            specific_format = \"/{}\".format(format_code)\n        else:\n            specific_format = \"\"\n\n        # search request\n        req_url = \"{}://v1.{}.isogeo.com/formats{}\".format(\n            prot, self.api_url, specific_format\n        )\n\n        req = self.get(\n            req_url, headers=self.header, proxies=self.proxies, verify=self.ssl\n        )\n\n        # checking response\n        checker.check_api_response(req)\n\n        # end of method\n        return req.json()", "category": "Python"}, {"instruction": "def _create_latent_variables(self):\n        \"\"\" Creates model latent variables\n\n        Returns\n        ----------\n        None (changes model attributes)\n        \"\"\"\n", "input": "", "output": "        for parm in range(self.z_no):\n            self.latent_variables.add_z('Sigma^2 ' + self.X_names[parm], fam.Flat(transform='exp'), fam.Normal(0,3))", "category": "Python"}, {"instruction": "def split_input(args):\n    \"\"\"Split query input into local files and URLs.\"\"\"\n", "input": "", "output": "    args['files'] = []\n    args['urls'] = []\n    for arg in args['query']:\n        if os.path.isfile(arg):\n            args['files'].append(arg)\n        else:\n            args['urls'].append(arg.strip('/'))", "category": "Python"}, {"instruction": "def simple_layer_stack(include_encdec_attention,\n                       num_layers=6,\n                       d_ff=2048,\n                       num_heads=8,\n                       d_kv=128,\n                       dropout_rate=0.1):\n  \"\"\"Create a layer stack.\n\n  Args:\n    include_encdec_attention: a boolean\n    num_layers: an integer\n    d_ff: an integer\n    num_heads: an integer\n    d_kv: an integer\n    dropout_rate: a float\n\n  Returns:\n    a LayerStack\n  \"\"\"\n", "input": "", "output": "  ret = []\n  for _ in xrange(num_layers):\n    ret.append(\n        transformer_layers.SelfAttention(\n            num_heads=num_heads,\n            key_value_size=d_kv,\n            attention_kwargs={\"dropout_rate\": dropout_rate}))\n    if include_encdec_attention:\n      ret.append(\n          transformer_layers.EncDecAttention(\n              num_heads=num_heads,\n              key_value_size=d_kv,\n              attention_kwargs={\"dropout_rate\": dropout_rate}))\n    ret.append(\n        transformer_layers.DenseReluDense(\n            hidden_size=d_ff,\n            dropout_rate=dropout_rate))\n  return transformer.LayerStack(ret)", "category": "Python"}, {"instruction": "def update_node_count(self, node, add_to_count):\n        \"\"\"\\\n        stores how many decent nodes are under a parent node\n        \"\"\"\n", "input": "", "output": "        current_score = 0\n        count_string = self.parser.getAttribute(node, 'gravityNodes')\n        if count_string:\n            current_score = int(count_string)\n\n        new_score = current_score + add_to_count\n        self.parser.setAttribute(node, \"gravityNodes\", str(new_score))", "category": "Python"}, {"instruction": "def get_filebase(path, pattern):\n    \"\"\"Get the end of *path* of same length as *pattern*.\"\"\"\n", "input": "", "output": "    # A pattern can include directories\n    tail_len = len(pattern.split(os.path.sep))\n    return os.path.join(*str(path).split(os.path.sep)[-tail_len:])", "category": "Python"}, {"instruction": "def connection_required(func):\n        \"\"\"Decorator to specify that a target connection is required in order\n        for the given method to be used.\n\n        Args:\n          func (function): function being decorated\n\n        Returns:\n          The wrapper function.\n        \"\"\"\n", "input": "", "output": "        @functools.wraps(func)\n        def wrapper(self, *args, **kwargs):\n            ", "category": "Python"}, {"instruction": "def handle(self):\n        \"\"\"\n        Executes the actual Stratum program.\n        \"\"\"\n", "input": "", "output": "        self.output = PyStratumStyle(self.input, self.output)\n\n        command = self.get_application().find('constants')\n        ret = command.execute(self.input, self.output)\n        if ret:\n            return ret\n\n        command = self.get_application().find('loader')\n        ret = command.execute(self.input, self.output)\n        if ret:\n            return ret\n\n        command = self.get_application().find('wrapper')\n        ret = command.execute(self.input, self.output)\n\n        self.output.writeln('')\n\n        return ret", "category": "Python"}, {"instruction": "def getoptS(X, Y, M_E, E):\r\n    ''' Find Sopt given X, Y\r\n    '''\n", "input": "", "output": "    n, r = X.shape\r\n    C = np.dot(np.dot(X.T, M_E), Y)\r\n    C = C.flatten()\r\n\r\n    A = np.zeros((r * r, r * r))\r\n    for i in range(r):\r\n        for j in range(r):\r\n            ind = j * r + i\r\n            temp = np.dot(\r\n                np.dot(X.T, np.dot(X[:, i, None], Y[:, j, None].T) * E), Y)\r\n            A[:, ind] = temp.flatten()\r\n\r\n    S = np.linalg.solve(A, C)\r\n\r\n    return np.reshape(S, (r, r)).T", "category": "Python"}, {"instruction": "def is_active(ext, metadata):\n    \"\"\"Is the cell active for the given file extension?\"\"\"\n", "input": "", "output": "    if metadata.get('run_control', {}).get('frozen') is True:\n        return False\n    if 'active' not in metadata:\n        return True\n    return ext.replace('.', '') in re.split('\\\\.|,', metadata['active'])", "category": "Python"}, {"instruction": "def _parse_value(self, stats, field):\n        \"\"\"\n        Pull the specified value from the HTML contents.\n\n        Given a field, find the corresponding HTML tag for that field and parse\n        its value before returning the value as a string. A couple fields, such\n        as 'conference' and 'team_abbreviation' don't follow a standard parsing\n        scheme and need to be handled differently to get the correct value.\n\n        Parameters\n        ----------\n        stats : PyQuery object\n            A PyQuery object containing all stats in HTML format for a\n            particular player.\n        field : string\n            A string of the field to parse from the HTML.\n\n        Returns\n        -------\n        string\n            Returns the desired value as a string.\n        \"\"\"\n", "input": "", "output": "        if field == 'conference':\n            value = self._parse_conference(stats)\n        elif field == 'team_abbreviation':\n            value = self._parse_team_abbreviation(stats)\n        else:\n            value = utils._parse_field(PLAYER_SCHEME, stats, field)\n        return value", "category": "Python"}, {"instruction": "def _error_on_missing_application(self, params):\n        \"\"\"Raise an ApplicationNotFoundError if the app is not accessible\n\n        In this case, checks for the java runtime and the RDP jar file.\n        \"\"\"\n", "input": "", "output": "        if not (os.path.exists('java') or which('java')):\n            raise ApplicationNotFoundError(\n                \"Cannot find java runtime. Is it installed? Is it in your \"\n                \"path?\")\n        jar_fp = self._get_jar_fp()\n        if jar_fp is None:\n            raise ApplicationNotFoundError(\n                \"JAR file not found in current directory and the RDP_JAR_PATH \"\n                \"environment variable is not set.  Please set RDP_JAR_PATH to \"\n                \"the full pathname of the JAR file.\")\n        if not os.path.exists(jar_fp):\n            raise ApplicationNotFoundError(\n                \"JAR file %s does not exist.\" % jar_fp)", "category": "Python"}, {"instruction": "def save_json(histogram: Union[HistogramBase, HistogramCollection], path: Optional[str] = None, **kwargs) -> str:\n    \"\"\"Save histogram to JSON format.\n\n    Parameters\n    ----------\n    histogram : Any histogram\n    path : If set, also writes to the path.\n\n    Returns\n    -------\n    json : The JSON representation of the histogram\n    \"\"\"\n", "input": "", "output": "    # TODO: Implement multiple histograms in one file?\n    data = histogram.to_dict()\n\n    data[\"physt_version\"] = CURRENT_VERSION\n    if isinstance(histogram, HistogramBase):\n        data[\"physt_compatible\"] = COMPATIBLE_VERSION\n    elif isinstance(histogram, HistogramCollection):\n        data[\"physt_compatible\"] = COLLECTION_COMPATIBLE_VERSION\n    else:\n        raise TypeError(\"Cannot save unknown type: {0}\".format(type(histogram)))\n\n    text = json.dumps(data, **kwargs)\n    if path:\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            f.write(text)\n    return text", "category": "Python"}, {"instruction": "def _dedent(text, tabsize=8, skip_first_line=False):\n    \"\"\"_dedent(text, tabsize=8, skip_first_line=False) -> dedented text\n\n        \"text\" is the text to dedent.\n        \"tabsize\" is the tab width to use for indent width calculations.\n        \"skip_first_line\" is a boolean indicating if the first line should\n            be skipped for calculating the indent width and for dedenting.\n            This is sometimes useful for docstrings and similar.\n\n    textwrap.dedent(s), but don't expand tabs to spaces\n    \"\"\"\n", "input": "", "output": "    lines = text.splitlines(1)\n    _dedentlines(lines, tabsize=tabsize, skip_first_line=skip_first_line)\n    return ''.join(lines)", "category": "Python"}, {"instruction": "def to_json(self, value):\n        \"\"\"\n        Serialize the data, ensuring that it is valid XML (or None).\n\n        Raises an lxml.etree.XMLSyntaxError if it is a basestring but not valid\n        XML.\n        \"\"\"\n", "input": "", "output": "        if self._enable_enforce_type:\n            value = self.enforce_type(value)\n        return super(XMLString, self).to_json(value)", "category": "Python"}, {"instruction": "def update(self, friendly_name=values.unset,\n               default_deployment_sid=values.unset):\n        \"\"\"\n        Update the FleetInstance\n\n        :param unicode friendly_name: A human readable description for this Fleet.\n        :param unicode default_deployment_sid: A default Deployment SID.\n\n        :returns: Updated FleetInstance\n        :rtype: twilio.rest.preview.deployed_devices.fleet.FleetInstance\n        \"\"\"\n", "input": "", "output": "        return self._proxy.update(\n            friendly_name=friendly_name,\n            default_deployment_sid=default_deployment_sid,\n        )", "category": "Python"}, {"instruction": "def from_proto(cls, proto_mesh, scale):\n        \"\"\"\n        TODO: add documentation\n        \"\"\"\n", "input": "", "output": "\n        mesh = cls(**proto_mesh.items())\n        mesh._copy_roche_values()\n        mesh._scale_mesh(scale=scale)\n\n        return mesh", "category": "Python"}, {"instruction": "def raw_corpus_rouge2(hypotheses: Iterable[str], references: Iterable[str]) -> float:\n    \"\"\"\n    Simple wrapper around ROUGE-2 implementation.\n\n    :param hypotheses: Hypotheses stream.\n    :param references: Reference stream.\n    :return: ROUGE-2 score as float between 0 and 1.\n    \"\"\"\n", "input": "", "output": "    return rouge.rouge_2(hypotheses, references)", "category": "Python"}, {"instruction": "def update_datastore(self, schema=None, primary_key=None,\n                         path=None):\n        # type: (Optional[List[Dict]], Optional[str], Optional[str]) -> None\n        \"\"\"For tabular data, update a resource in the HDX datastore which enables data preview in HDX. If no schema is provided\n        all fields are assumed to be text. If path is not supplied, the file is first downloaded from HDX.\n\n        Args:\n            schema (List[Dict]): List of fields and types of form {'id': 'FIELD', 'type': 'TYPE'}. Defaults to None.\n            primary_key (Optional[str]): Primary key of schema. Defaults to None.\n            path (Optional[str]): Local path to file that was uploaded. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n", "input": "", "output": "        self.create_datastore(schema, primary_key, 2, path=path)", "category": "Python"}, {"instruction": "def _route(self):\n        ''' Handles server route instantiation. '''\n", "input": "", "output": "        self._app.route('/',\n                        method='GET',\n                        callback=self._get_logger_list)\n        self._app.route('/stats',\n                        method='GET',\n                        callback=self._fetch_handler_stats)\n        self._app.route('/<name>/start',\n                        method='POST',\n                        callback=self._add_logger_by_name)\n        self._app.route('/<name>/stop',\n                        method='DELETE',\n                        callback=self._stop_logger_by_name)\n        self._app.route('/<name>/config',\n                        method='GET',\n                        callback=self._get_logger_conf)\n        self._app.route('/<name>/rotate',\n                        method='POST',\n                        callback=self._rotate_capturer_log)", "category": "Python"}, {"instruction": "def deserialize_by_field(value, field):\n    \"\"\"\n    Some types get serialized to JSON, as strings.\n    If we know what they are supposed to be, we can deserialize them\n    \"\"\"\n", "input": "", "output": "    if isinstance(field, forms.DateTimeField):\n        value = parse_datetime(value)\n    elif isinstance(field, forms.DateField):\n        value = parse_date(value)\n    elif isinstance(field, forms.TimeField):\n        value = parse_time(value)\n    return value", "category": "Python"}, {"instruction": "def put(self):\n        \"\"\"Update a credential by file path\"\"\"\n", "input": "", "output": "        cred_payload = utils.uni_to_str(json.loads(request.get_data()))\n        return self.manager.update_credential(cred_payload)", "category": "Python"}, {"instruction": "def key(self):\n        \"\"\"\n        Example::\n\n            /browse/homes/ca/ -> ca\n            /browse/homes/ca/los-angeles-county/ -> los-angeles-county\n            /browse/homes/ca/los-angeles-county/91001/ -> 91001\n            /browse/homes/ca/los-angeles-county/91001/tola-ave_5038895/ -> tola-ave_5038895\n\n        :return:\n        \"\"\"\n", "input": "", "output": "\n        return [part.strip() for part in self.href.split(\"/\") if part.strip()][\n            -1]", "category": "Python"}, {"instruction": "def license(self, license_id: str, token: dict = None, prot: str = \"https\") -> dict:\n        \"\"\"Get details about a specific license.\n\n        :param str token: API auth token\n        :param str license_id: license UUID\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n        \"\"\"\n", "input": "", "output": "        # handling request parameters\n        payload = {\"lid\": license_id}\n\n        # search request\n        license_url = \"{}://v1.{}.isogeo.com/licenses/{}\".format(\n            prot, self.api_url, license_id\n        )\n        license_req = self.get(\n            license_url,\n            headers=self.header,\n            params=payload,\n            proxies=self.proxies,\n            verify=self.ssl,\n        )\n\n        # checking response\n        checker.check_api_response(license_req)\n\n        # end of method\n        return license_req.json()", "category": "Python"}, {"instruction": "def stop(self):  # pylint: disable=no-self-use\n        \"\"\"Wrapper to stop the CherryPy server\n\n        :return: None\n        \"\"\"\n", "input": "", "output": "        cherrypy.log(\"Stopping CherryPy engine (current state: %s)...\" % cherrypy.engine.state)\n        try:\n            cherrypy.engine.exit()\n        except RuntimeWarning:\n            pass\n        except SystemExit:\n            cherrypy.log('SystemExit raised: shutting down bus')\n        cherrypy.log(\"Stopped\")", "category": "Python"}, {"instruction": "def cached(func):\n    \"\"\"Memoize a function result.\"\"\"\n", "input": "", "output": "    ret = None\n\n    def call_or_cache(*args, **kwargs):\n        nonlocal ret\n        if ret is None:\n            ret = func(*args, **kwargs)\n        return ret\n\n    return call_or_cache", "category": "Python"}, {"instruction": "def add_global(self, globalvalue):\n        \"\"\"\n        Add a new global value.\n        \"\"\"\n", "input": "", "output": "        assert globalvalue.name not in self.globals\n        self.globals[globalvalue.name] = globalvalue", "category": "Python"}, {"instruction": "def _join_host_port(host, port):\n    \"\"\"Adapted golang's net.JoinHostPort\"\"\"\n", "input": "", "output": "    template = \"%s:%s\"\n    host_requires_bracketing = ':' in host or '%' in host\n    if host_requires_bracketing:\n        template = \"[%s]:%s\"\n    return template % (host, port)", "category": "Python"}, {"instruction": "def as_cwd():\n    \"\"\" Use workdir.options.path as a temporary working directory \"\"\"\n", "input": "", "output": "    _set_log_level()\n    owd = os.getcwd()\n    logger.debug('entering working directory: ' + options.path)\n    os.chdir(os.path.expanduser(options.path))\n    yield\n    logger.debug('returning to original directory: ' + owd)\n    os.chdir(owd)", "category": "Python"}, {"instruction": "def SeriesXmlRewriterFactory(chart_type, chart_data):\n    \"\"\"\n    Return a |_BaseSeriesXmlRewriter| subclass appropriate to *chart_type*.\n    \"\"\"\n", "input": "", "output": "    XL_CT = XL_CHART_TYPE\n\n    RewriterCls = {\n        # There are 73 distinct chart types, only specify non-category\n        # types, others default to _CategorySeriesXmlRewriter. Stock-type\n        # charts are multi-plot charts, so no guaratees on how they turn\n        # out.\n        XL_CT.BUBBLE:                       _BubbleSeriesXmlRewriter,\n        XL_CT.BUBBLE_THREE_D_EFFECT:        _BubbleSeriesXmlRewriter,\n        XL_CT.XY_SCATTER:                   _XySeriesXmlRewriter,\n        XL_CT.XY_SCATTER_LINES:             _XySeriesXmlRewriter,\n        XL_CT.XY_SCATTER_LINES_NO_MARKERS:  _XySeriesXmlRewriter,\n        XL_CT.XY_SCATTER_SMOOTH:            _XySeriesXmlRewriter,\n        XL_CT.XY_SCATTER_SMOOTH_NO_MARKERS: _XySeriesXmlRewriter,\n    }.get(chart_type, _CategorySeriesXmlRewriter)\n\n    return RewriterCls(chart_data)", "category": "Python"}, {"instruction": "def ind_nodes(self, graph=None):\n        \"\"\" Returns a list of all nodes in the graph with no dependencies. \"\"\"\n", "input": "", "output": "        if graph is None:\n            graph = self.graph\n\n        dependent_nodes = set(\n            node for dependents in six.itervalues(graph) for node in dependents\n        )\n        return [node for node in graph.keys() if node not in dependent_nodes]", "category": "Python"}, {"instruction": "def run_blast_commands(ncbicommandline_method, **keywords):\n    \"\"\"Runs blastplus/tblastn search, collects result and pass as a xml temporary file.  \"\"\"\n", "input": "", "output": "\n    # temporary files for output\n    blast_out_tmp = tempfile.NamedTemporaryFile(mode=\"w+\",delete=False)\n    keywords['out'] = blast_out_tmp.name\n\n    # unpack query temp file object\n    query_file_object_tmp = keywords['query']\n    keywords['query'] = query_file_object_tmp.name\n\n    stderr = ''\n    error_string = ''\n    try:\n        # formating blastplus command\n        blastplusx_cline = ncbicommandline_method(**keywords)\n        stdout, stderr = blastplusx_cline()\n\n    except ApplicationError as e:\n        error_string = \"Runtime error: \" + stderr + \"\\n\" + e.cmd\n\n    # remove query temp file\n    os.unlink(query_file_object_tmp.name)\n    # os.remove(query_file_object_tmp.name)\n\n    return blast_out_tmp, error_string", "category": "Python"}, {"instruction": "def install_handler(self, app):\n        \"\"\"Install logging handler.\"\"\"\n", "input": "", "output": "        # Configure python logging\n        if app.config['LOGGING_CONSOLE_PYWARNINGS']:\n            self.capture_pywarnings(logging.StreamHandler())\n\n        if app.config['LOGGING_CONSOLE_LEVEL'] is not None:\n            for h in app.logger.handlers:\n                h.setLevel(app.config['LOGGING_CONSOLE_LEVEL'])\n\n        # Add request_id to log record\n        app.logger.addFilter(add_request_id_filter)", "category": "Python"}, {"instruction": "def print_data(data):\n    \"\"\"Prints object key-value pairs in a custom format\n\n    :param data: The dict to print\n    :type data: dict\n    :rtype: None\n    \"\"\"\n", "input": "", "output": "    print(\", \".join([\"{}=>{}\".format(key, value) for key, value in data]))", "category": "Python"}, {"instruction": "def hashes(self):\n        \"\"\"Hashes of all possible permutations of the URL in canonical form\"\"\"\n", "input": "", "output": "        for url_variant in self.url_permutations(self.canonical):\n            url_hash = self.digest(url_variant)\n            yield url_hash", "category": "Python"}, {"instruction": "def validate(self, instance, value):\n        \"\"\"Checks if value is an open PNG file, valid filename, or png.Image\n\n        Returns an open bytestream of the image\n        \"\"\"\n", "input": "", "output": "        # Pass if already validated\n        if getattr(value, '__valid__', False):\n            return value\n        # Validate that value is PNG\n        if isinstance(value, png.Image):\n            pass\n        else:\n            value = super(ImagePNG, self).validate(instance, value)\n            try:\n                png.Reader(value).validate_signature()\n            except png.FormatError:\n                self.error(instance, value, extra='Open file is not PNG.')\n            value.seek(0)\n        # Write input to new bytestream\n        output = BytesIO()\n        output.name = self.filename\n        output.__valid__ = True\n        if isinstance(value, png.Image):\n            value.save(output)\n        else:\n            fid = value\n            fid.seek(0)\n            output.write(fid.read())\n            fid.close()\n        output.seek(0)\n        return output", "category": "Python"}, {"instruction": "def uni_char_code(a: str, b: str, c: str, d: str):\n    \"\"\"Convert unicode characters to integers.\n\n    Converts four hexadecimal chars to the integer that the string represents.\n    For example, uni_char_code('0','0','0','f') will return 15,\n    and uni_char_code('0','0','f','f') returns 255.\n\n    Returns a negative number on error, if a char was invalid.\n\n    This is implemented by noting that char2hex() returns -1 on error,\n    which means the result of ORing the char2hex() will also be negative.\n    \"\"\"\n", "input": "", "output": "    return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d)", "category": "Python"}, {"instruction": "def perform_command(self):\n        \"\"\"\n        Perform command and return the appropriate exit code.\n\n        :rtype: int\n        \"\"\"\n", "input": "", "output": "        self.log(u\"This function should be overloaded in derived classes\")\n        self.log([u\"Invoked with %s\", self.actual_arguments])\n        return self.NO_ERROR_EXIT_CODE", "category": "Python"}, {"instruction": "def set_bpp(self, bpp):\n        \"\"\"\n        Set the bit depth (per band) for the output.\n        A typical \"32-bit RGBA\" image would be 8; a 48-bit image would\n        be 16, etc.\n        \"\"\"\n", "input": "", "output": "        self.bpp = bpp\n        self.maxc = 2 ** self.bpp - 1\n        self._set_dtype()\n        self.calc_cmap()\n        self.recalc(callback=False)", "category": "Python"}, {"instruction": "def can_be_(self, state):\n    \"\"\"Check if machine can transit to given state.\"\"\"\n", "input": "", "output": "    translator = self._meta['translator']\n    state = translator.translate(state)\n\n    if self._meta['complete']:\n        return True\n\n    if self.actual_state is None:\n        return True\n\n    transitions = self._meta['transitions'][self.actual_state]\n    return state in transitions", "category": "Python"}, {"instruction": "def status(self, job_ids):\n        \"\"\"Get the status of a list of jobs identified by their ids.\n\n        Parameters\n        ----------\n        job_ids : list of str\n            Identifiers for the jobs.\n\n        Returns\n        -------\n        list of int\n            Status codes for each requested job.\n        \"\"\"\n", "input": "", "output": "        states = []\n        statuses = self.deployer.get_vm_status([self.resources.get(job_id) for job_id in job_ids])\n        for status in statuses:\n            states.append(translate_table.get(status.state['Name'], \"PENDING\"))\n        return states", "category": "Python"}, {"instruction": "def _f16_to_32bit(ins):\n    \"\"\" If any of the operands within the ins(truction) are numeric,\n    convert them to its 32bit representation, otherwise leave them\n    as they are.\n    \"\"\"\n", "input": "", "output": "    ins.quad = [x for x in ins.quad]\n    for i in range(2, len(ins.quad)):\n        if is_float(ins.quad[i]):\n            de, hl = f16(ins.quad[i])\n            ins.quad[i] = str((de << 16) | hl)\n\n    ins.quad = tuple(ins.quad)\n    return ins", "category": "Python"}, {"instruction": "def _check_scalar_vertical_extents(self, ds, z_variable):\n        '''\n        Check the scalar value of Z compared to the vertical extents which\n        should also be equivalent\n\n        :param netCDF4.Dataset ds: An open netCDF dataset\n        :param str z_variable: Name of the variable representing the Z-Axis\n        '''\n", "input": "", "output": "        vert_min = ds.geospatial_vertical_min\n        vert_max = ds.geospatial_vertical_max\n        msgs = []\n        total = 2\n\n        zvalue = ds.variables[z_variable][:].item()\n        if not np.isclose(vert_min, vert_max):\n            msgs.append(\"geospatial_vertical_min != geospatial_vertical_max for scalar depth values, %s != %s\" % (\n                vert_min,\n                vert_max\n            ))\n\n        if not np.isclose(vert_max, zvalue):\n            msgs.append(\"geospatial_vertical_max != %s values, %s != %s\" % (\n                z_variable,\n                vert_max,\n                zvalue\n            ))\n\n        return Result(BaseCheck.MEDIUM,\n                      (total - len(msgs), total),\n                      'geospatial_vertical_extents_match',\n                      msgs)", "category": "Python"}, {"instruction": "def init_random(X, n_clusters, random_state):\n    \"\"\"K-means initialization using randomly chosen points\"\"\"\n", "input": "", "output": "    logger.info(\"Initializing randomly\")\n    idx = sorted(draw_seed(random_state, 0, len(X), size=n_clusters))\n    centers = X[idx].compute()\n    return centers", "category": "Python"}, {"instruction": "def libvlc_video_get_track_description(p_mi):\n    '''Get the description of available video tracks.\n    @param p_mi: media player.\n    @return: list with description of available video tracks, or NULL on error.\n    '''\n", "input": "", "output": "    f = _Cfunctions.get('libvlc_video_get_track_description', None) or \\\n        _Cfunction('libvlc_video_get_track_description', ((1,),), None,\n                    ctypes.POINTER(TrackDescription), MediaPlayer)\n    return f(p_mi)", "category": "Python"}, {"instruction": "def leaveoneout(self):\n        \"\"\"Train & Test using leave one out\"\"\"\n", "input": "", "output": "        traintestfile = self.fileprefix + '.train'\n        options = \"-F \" + self.format + \" \" +  self.timbloptions + \" -t leave_one_out\"\n        if sys.version < '3':\n            self.api = timblapi.TimblAPI(b(options), b\"\")\n        else:\n            self.api = timblapi.TimblAPI(options, \"\")\n        if self.debug:\n            print(\"Enabling debug for timblapi\",file=stderr)\n            self.api.enableDebug()\n        print(\"Calling Timbl API : \" + options,file=stderr)\n        if sys.version < '3':\n            self.api.learn(b(traintestfile))\n            self.api.test(b(traintestfile), b(self.fileprefix + '.out'),b'')\n        else:\n            self.api.learn(u(traintestfile))\n            self.api.test(u(traintestfile), u(self.fileprefix + '.out'),'')\n        return self.api.getAccuracy()", "category": "Python"}, {"instruction": "def _prompt_changer(attr, val):\n    \"\"\"Change the current prompt theme\"\"\"\n", "input": "", "output": "    try:\n        sys.ps1 = conf.color_theme.prompt(conf.prompt)\n    except Exception:\n        pass\n    try:\n        apply_ipython_style(get_ipython())\n    except NameError:\n        pass", "category": "Python"}, {"instruction": "def rbac_policy_update(request, policy_id, **kwargs):\n    \"\"\"Update a RBAC Policy.\n\n    :param request: request context\n    :param policy_id: target policy id\n    :param target_tenant: target tenant of the policy\n    :return: RBACPolicy object\n    \"\"\"\n", "input": "", "output": "    body = {'rbac_policy': kwargs}\n    rbac_policy = neutronclient(request).update_rbac_policy(\n        policy_id, body=body).get('rbac_policy')\n    return RBACPolicy(rbac_policy)", "category": "Python"}, {"instruction": "def qualified_name(self):\n        '''return the fully qualified name (`<module>.<interface>#<operation>`)'''\n", "input": "", "output": "        return '{0}.{1}#{2}'.format(self.module.name, self.interface.name, self.name)", "category": "Python"}, {"instruction": "def _parse_input_node(cls, node):\n        \"\"\"\n        :param node: xml node\n        :return: dict\n        \"\"\"\n", "input": "", "output": "        data = {}\n        child = node.getchildren()\n        if not child and node.get('name'):\n            val = node.text\n        elif child:  # if tag = \"{http://activiti.org/bpmn}script\" then data_typ = 'script'\n            data_typ = child[0].tag.split('}')[1]\n            val = getattr(cls, '_parse_%s' % data_typ)(child[0])\n        data[node.get('name')] = val\n        return data", "category": "Python"}, {"instruction": "def tag(self, repository_tag, tags=[]):\n        \"\"\"\n        Tags image with one or more tags.\n\n        Raises exception on failure.\n        \"\"\"\n", "input": "", "output": "        if not isinstance(repository_tag, six.string_types):\n            raise TypeError('repository_tag must be a string')\n\n        if not isinstance(tags, list):\n            raise TypeError('tags must be a list.')\n\n        if ':' in repository_tag:\n            repository, tag = repository_tag.split(':')\n            tags.append(tag)\n        else:\n            repository = repository_tag\n\n            if not tags:\n                tags.append('latest')\n\n        for tag in tags:\n            repo_tag = \"{0}:{1}\".format(repository, tag)\n\n            if repo_tag not in self.repo_tags:\n                logger.info(\"Tagging Image: {0} Repo Tag: {1}\".format(self.identifier, repo_tag))\n                self.repo_tags = self.repo_tags + (repo_tag, )\n\n                # always going to force tags until a feature is added to allow users to specify.\n                try:\n                    self.client.tag(self.id, repository, tag)\n                except:\n                    self.client.tag(self.id, repository, tag, force=True)", "category": "Python"}, {"instruction": "def pprint(self, file_=sys.stdout):\n        \"\"\"Print the code block to stdout.\n        Does syntax highlighting if possible.\n        \"\"\"\n", "input": "", "output": "\n        code = []\n        if self._deps:\n            code.append(\"# dependencies:\")\n        for k, v in _compat.iteritems(self._deps):\n            code.append(\"#   %s: %r\" % (k, v))\n        code.append(str(self))\n        code = \"\\n\".join(code)\n\n        if file_.isatty():\n            try:\n                from pygments import highlight\n                from pygments.lexers import PythonLexer\n                from pygments.formatters import TerminalFormatter\n            except ImportError:\n                pass\n            else:\n                formatter = TerminalFormatter(bg=\"dark\")\n                lexer = PythonLexer()\n                file_.write(highlight(code, lexer, formatter))\n                return\n        file_.write(code + \"\\n\")", "category": "Python"}, {"instruction": "def release(self):\n        \"\"\"Release the lock\"\"\"\n", "input": "", "output": "        base64_key = _encode(self.key)\n        base64_value = _encode(self._uuid)\n\n        txn = {\n            'compare': [{\n                'key': base64_key,\n                'result': 'EQUAL',\n                'target': 'VALUE',\n                'value': base64_value\n            }],\n            'success': [{\n                'request_delete_range': {\n                    'key': base64_key\n                }\n            }]\n        }\n\n        result = self.client.transaction(txn)\n        if 'succeeded' in result:\n            return result['succeeded']\n        return False", "category": "Python"}, {"instruction": "def add_image_description(self, dict):\n        \"\"\"Add a dict to image description.\"\"\"\n", "input": "", "output": "        if self._ef is not None:\n            self._ef['0th'][piexif.ImageIFD.ImageDescription] = json.dumps(\n                dict)", "category": "Python"}, {"instruction": "def _symbol_bottom_simple(x, model_hparams, vocab_size, name, reuse):\n  \"\"\"Bottom transformation for symbols.\"\"\"\n", "input": "", "output": "  with tf.variable_scope(name, reuse=reuse):\n    # Ensure the inputs are 3-D\n    if len(x.get_shape()) == 4:\n      x = tf.squeeze(x, axis=3)\n    while len(x.get_shape()) < 3:\n      x = tf.expand_dims(x, axis=-1)\n\n    var = get_weights(model_hparams, vocab_size)\n    x = common_layers.dropout_no_scaling(\n        x, 1.0 - model_hparams.symbol_dropout)\n    ret = common_layers.gather(var, x)\n    if model_hparams.multiply_embedding_mode == \"sqrt_depth\":\n      ret *= model_hparams.hidden_size**0.5\n    ret *= tf.expand_dims(\n        common_layers.cast_like(tf.not_equal(x, 0), ret), -1)\n    return ret", "category": "Python"}, {"instruction": "def list(self, identity_id, per_page=20, page=1):\n        \"\"\" Get a list of tokens\n\n            :param identity_id: The ID of the identity to retrieve tokens for\n            :param per_page: The number of results per page returned\n            :param page: The page number of the results\n            :return: dict of REST API output with headers attached\n            :rtype: :class:`~datasift.request.DictResponse`\n            :raises: :class:`~datasift.exceptions.DataSiftApiException`,\n                :class:`requests.exceptions.HTTPError`\n        \"\"\"\n", "input": "", "output": "\n        params = {'per_page': per_page, 'page': page}\n\n        return self.request.get(str(identity_id) + '/token', params)", "category": "Python"}, {"instruction": "def cloudant_iam(account_name, api_key, **kwargs):\n    \"\"\"\n    Provides a context manager to create a Cloudant session using IAM\n    authentication and provide access to databases, docs etc.\n\n    :param account_name: Cloudant account name.\n    :param api_key: IAM authentication API key.\n\n    For example:\n\n    .. code-block:: python\n\n        # cloudant context manager\n        from cloudant import cloudant_iam\n\n        with cloudant_iam(ACCOUNT_NAME, API_KEY) as client:\n            # Context handles connect() and disconnect() for you.\n            # Perform library operations within this context.  Such as:\n            print client.all_dbs()\n            # ...\n\n    \"\"\"\n", "input": "", "output": "    cloudant_session = Cloudant.iam(account_name, api_key, **kwargs)\n\n    cloudant_session.connect()\n    yield cloudant_session\n    cloudant_session.disconnect()", "category": "Python"}, {"instruction": "def reftrack_version_data(rt, role):\n    \"\"\"Return the data for the version that is loaded by the reftrack\n\n    :param rt: the :class:`jukeboxcore.reftrack.Reftrack` holds the data\n    :type rt: :class:`jukeboxcore.reftrack.Reftrack`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the version\n    :rtype: depending on role\n    :raises: None\n    \"\"\"\n", "input": "", "output": "    tfi = rt.get_taskfileinfo()\n    if not tfi:\n        return\n    return filesysitemdata.taskfileinfo_version_data(tfi, role)", "category": "Python"}, {"instruction": "def parse_structure(self, node):\n        \"\"\"\n        Parses <Structure>\n\n        @param node: Node containing the <Structure> element\n        @type node: xml.etree.Element\n        \"\"\"\n", "input": "", "output": "\n        self.current_structure = self.current_component_type.structure\n        self.process_nested_tags(node)\n        self.current_structure = None", "category": "Python"}, {"instruction": "def input_validate_nonce(nonce, name='nonce', pad = False):\n    \"\"\" Input validation for nonces. \"\"\"\n", "input": "", "output": "    if type(nonce) is not str:\n        raise pyhsm.exception.YHSM_WrongInputType( \\\n            name, str, type(nonce))\n    if len(nonce) > pyhsm.defines.YSM_AEAD_NONCE_SIZE:\n        raise pyhsm.exception.YHSM_InputTooLong(\n            name, pyhsm.defines.YSM_AEAD_NONCE_SIZE, len(nonce))\n    if pad:\n        return nonce.ljust(pyhsm.defines.YSM_AEAD_NONCE_SIZE, chr(0x0))\n    else:\n        return nonce", "category": "Python"}, {"instruction": "def create_xml_path(path, **kwargs):\n    '''\n    Start a transient domain based on the XML-file path passed to the function\n\n    :param path: path to a file containing the libvirt XML definition of the domain\n    :param connection: libvirt connection URI, overriding defaults\n\n        .. versionadded:: 2019.2.0\n    :param username: username to connect with, overriding defaults\n\n        .. versionadded:: 2019.2.0\n    :param password: password to connect with, overriding defaults\n\n        .. versionadded:: 2019.2.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virt.create_xml_path <path to XML file on the node>\n    '''\n", "input": "", "output": "    try:\n        with salt.utils.files.fopen(path, 'r') as fp_:\n            return create_xml_str(\n                salt.utils.stringutils.to_unicode(fp_.read()),\n                **kwargs\n            )\n    except (OSError, IOError):\n        return False", "category": "Python"}, {"instruction": "def active():\n    '''\n    List existing device-mapper device details.\n    '''\n", "input": "", "output": "    ret = {}\n    # TODO: This command should be extended to collect more information, such as UUID.\n    devices = __salt__['cmd.run_stdout']('dmsetup ls --target crypt')\n    out_regex = re.compile(r'(?P<devname>\\w+)\\W+\\((?P<major>\\d+), (?P<minor>\\d+)\\)')\n\n    log.debug(devices)\n    for line in devices.split('\\n'):\n        match = out_regex.match(line)\n        if match:\n            dev_info = match.groupdict()\n            ret[dev_info['devname']] = dev_info\n        else:\n            log.warning('dmsetup output does not match expected format')\n\n    return ret", "category": "Python"}, {"instruction": "def ping(hostname: str, timeout_s: int = 5) -> bool:\n    \"\"\"\n    Pings a host, using OS tools.\n\n    Args:\n        hostname: host name or IP address\n        timeout_s: timeout in seconds\n\n    Returns:\n        was the ping successful?\n\n    \"\"\"\n", "input": "", "output": "    if sys.platform == \"win32\":\n        timeout_ms = timeout_s * 1000\n        args = [\n            \"ping\",\n            hostname,\n            \"-n\", \"1\",  # ping count\n            \"-w\", str(timeout_ms),  # timeout\n        ]\n    elif sys.platform.startswith('linux'):\n        args = [\n            \"ping\",\n            hostname,\n            \"-c\", \"1\",  # ping count\n            \"-w\", str(timeout_s),  # timeout\n        ]\n    else:\n        raise AssertionError(\"Don't know how to ping on this operating system\")\n    proc = subprocess.Popen(args,\n                            stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    proc.communicate()\n    retcode = proc.returncode\n    return retcode == 0", "category": "Python"}, {"instruction": "def serialize(self):\n        \"\"\" Get the serialized Dynamo format for the update \"\"\"\n", "input": "", "output": "        if self.action == 'Create':\n            payload = self.extra['index'].schema()\n        else:\n            payload = {\n                'IndexName': self.index_name,\n            }\n            if self.action == 'Update':\n                payload['ProvisionedThroughput'] = \\\n                    self.extra['throughput'].schema()\n        return {\n            self.action: payload\n        }", "category": "Python"}, {"instruction": "def Take(self: dict, n):\n    \"\"\"\n    [\n        {\n            'self': [1, 2, 3],\n            'n': 2,\n            'assert': lambda ret: list(ret)  == [1, 2]\n         }\n    ]\n    \"\"\"\n", "input": "", "output": "\n    for i, e in enumerate(self.items()):\n        if i == n:\n            break\n        yield e", "category": "Python"}, {"instruction": "def delete_assessment(self, assessment):\n        \"\"\"\n        To delete a Assessment\n        :param assessment: string\n        \"\"\"\n", "input": "", "output": "        response = self.http.delete('/Assessment/' + str(assessment))\n        return response", "category": "Python"}, {"instruction": "def _extract_auth_config(self):\n        \"\"\"Obtains the authentication configurations.\"\"\"\n", "input": "", "output": "\n        service = self._service\n        if not service.authentication:\n            return {}\n\n        auth_infos = {}\n        for auth_rule in service.authentication.rules:\n            selector = auth_rule.selector\n            provider_ids_to_audiences = {}\n            for requirement in auth_rule.requirements:\n                provider_id = requirement.providerId\n                if provider_id and requirement.audiences:\n                    audiences = requirement.audiences.split(u\",\")\n                    provider_ids_to_audiences[provider_id] = audiences\n            auth_infos[selector] = AuthInfo(provider_ids_to_audiences)\n        return auth_infos", "category": "Python"}, {"instruction": "def render(self, template, **data):\n        \"\"\"Renders the template using Jinja2 with given data arguments.\n\n        \"\"\"\n", "input": "", "output": "        if(type(template) != str):\n            raise TypeError(\"String expected\")\n        \n        env = Environment(\n            loader=FileSystemLoader(os.getcwd() + '/View'),\n            autoescape=select_autoescape()\n        )\n\n        template = env.get_template(template)\n        return self.finish(template.render(data))", "category": "Python"}, {"instruction": "def get_checks_paths(checks_paths=None):\n    \"\"\"\n    Get path to checks.\n\n    :param checks_paths: list of str, directories where the checks are present\n    :return: list of str (absolute path of directory with checks)\n    \"\"\"\n", "input": "", "output": "    p = os.path.join(__file__, os.pardir, os.pardir, os.pardir, \"checks\")\n    p = os.path.abspath(p)\n    # let's utilize the default upstream checks always\n    if checks_paths:\n        p += [os.path.abspath(x) for x in checks_paths]\n    return [p]", "category": "Python"}, {"instruction": "def _container_start_handler(ion_type, length, ctx):\n    \"\"\"Handles container delegation.\"\"\"\n", "input": "", "output": "    _, self = yield\n\n    container_ctx = ctx.derive_container_context(length)\n    if ctx.annotations and ctx.limit != container_ctx.limit:\n        # 'ctx' is the annotation wrapper context. `container_ctx` represents the wrapper's 'value' subfield. Their\n        # limits must match.\n        raise IonException('Incorrect annotation wrapper length.')\n    delegate = _container_handler(ion_type, container_ctx)\n\n    # We start the container, and transition to the new container processor.\n    yield ctx.event_transition(\n        IonEvent, IonEventType.CONTAINER_START, ion_type, value=None, whence=delegate\n    )", "category": "Python"}, {"instruction": "def current_branch(self):\n        \"\"\"The name of the branch that's currently checked out in the working tree (a string or :data:`None`).\"\"\"\n", "input": "", "output": "        output = self.context.capture('git', 'rev-parse', '--abbrev-ref', 'HEAD', check=False, silent=True)\n        return output if output != 'HEAD' else None", "category": "Python"}, {"instruction": "def find_java_home(cratedb_version: tuple) -> str:\n    \"\"\" Return a path to a JAVA_HOME suites for the given CrateDB version \"\"\"\n", "input": "", "output": "    if MIN_VERSION_FOR_JVM11 <= cratedb_version < (4, 0):\n        # Supports 8 to 11+, use whatever is set\n        return os.environ.get('JAVA_HOME', '')\n    if cratedb_version < MIN_VERSION_FOR_JVM11:\n        return _find_matching_java_home(lambda ver: ver[0] == 8)\n    else:\n        return _find_matching_java_home(lambda ver: ver[0] >= 11)", "category": "Python"}, {"instruction": "async def sources(client: Client, pubkey: str) -> dict:\n    \"\"\"\n    GET transaction sources\n\n    :param client: Client to connect to the api\n    :param pubkey: Public key\n    :return:\n    \"\"\"\n", "input": "", "output": "    return await client.get(MODULE + '/sources/%s' % pubkey, schema=SOURCES_SCHEMA)", "category": "Python"}, {"instruction": "def redef(obj, key, value, **kwargs):\n    '''A static constructor helper function'''\n", "input": "", "output": "    return Redef(obj, key, value=value, **kwargs)", "category": "Python"}, {"instruction": "def _shape(self):\n        \"\"\" Returns the shape of the data array associated with this file.\"\"\"\n", "input": "", "output": "        hdu = self.open()\n        _shape = hdu.shape\n        if not self.inmemory:\n            self.close()\n            del hdu\n        return _shape", "category": "Python"}, {"instruction": "def remove_setting(self, section, name, save=False):\n    '''remove a setting from the global config\n    '''\n", "input": "", "output": "    configfile = get_configfile()\n    return _remove_setting(section, name, configfile, save)", "category": "Python"}, {"instruction": "def _run_train_step(self, train_set):\n        \"\"\"Run a training step.\n\n        A training step is made by randomly shuffling the training set,\n        divide into batches and run the variable update nodes for each batch.\n        :param train_set: training set\n        :return: self\n        \"\"\"\n", "input": "", "output": "        np.random.shuffle(train_set)\n\n        batches = [_ for _ in utilities.gen_batches(train_set,\n                                                    self.batch_size)]\n        updates = [self.w_upd8, self.bh_upd8, self.bv_upd8]\n\n        for batch in batches:\n            self.tf_session.run(updates,\n                                feed_dict=self._create_feed_dict(batch))", "category": "Python"}, {"instruction": "def _get_battery(self):\n        \"\"\"\n        Get the battery\n        \"\"\"\n", "input": "", "output": "        try:\n            battery = {\n                \"charge\": self._dev.charge(),\n                \"isCharging\": self._dev.isCharging() == 1,\n            }\n        except Exception:\n            return None\n\n        return battery", "category": "Python"}, {"instruction": "def _setDefaults(configObj={}):\n    \"\"\"set up the default parameters to run drizzle\n       build,single,units,wt_scl,pixfrac,kernel,fillval,\n       rot,scale,xsh,ysh,blotnx,blotny,outnx,outny,data\n\n       Used exclusively for unit-testing, if any are defined.\n\n    \"\"\"\n", "input": "", "output": "\n    paramDict={\"build\":True,\n              \"single\":True,\n              \"stepsize\":10,\n              \"in_units\":\"cps\",\n              \"wt_scl\":1.,\n              \"pixfrac\":1.,\n              \"kernel\":\"square\",\n              \"fillval\":999.,\n              \"maskval\": None,\n              \"rot\":0.,\n              \"scale\":1.,\n              \"xsh\":0.,\n              \"ysh\":0.,\n              \"blotnx\":2048,\n              \"blotny\":2048,\n              \"outnx\":4096,\n              \"outny\":4096,\n              \"data\":None,\n              \"driz_separate\":True,\n              \"driz_combine\":False}\n\n    if(len(configObj) !=0):\n        for key in configObj.keys():\n            paramDict[key]=configObj[key]\n\n    return paramDict", "category": "Python"}, {"instruction": "def checkOutputPath(self, output_path):\n        \"\"\"\n        Create or clean up output path\n        \"\"\"\n", "input": "", "output": "        if not output_path:\n            # output_path = self.output_path_DEFAULT\n            output_path = os.path.join(self.output_path_DEFAULT,\n                                       slugify(unicode(self.title)))\n        if os.path.exists(output_path):\n            shutil.rmtree(output_path)\n        os.makedirs(output_path)\n        return output_path", "category": "Python"}, {"instruction": "def register_job_definition(self, json_fpath):\n        \"\"\"Register a job definition with AWS Batch, using a JSON\"\"\"\n", "input": "", "output": "        with open(json_fpath) as f:\n            job_def = json.load(f)\n        response = self._client.register_job_definition(**job_def)\n        status_code = response['ResponseMetadata']['HTTPStatusCode']\n        if status_code != 200:\n            msg = 'Register job definition request received status code {0}:\\n{1}'\n            raise Exception(msg.format(status_code, response))\n        return response", "category": "Python"}, {"instruction": "def requeue(self):\n        \"\"\"Reject this message and put it back on the queue.\n\n        You must not use this method as a means of selecting messages\n        to process.\n\n        :raises MessageStateError: If the message has already been\n            acknowledged/requeued/rejected.\n\n        \"\"\"\n", "input": "", "output": "        if self.acknowledged:\n            raise self.MessageStateError(\n                \"Message already acknowledged with state: %s\" % self._state)\n        self.backend.requeue(self.delivery_tag)\n        self._state = \"REQUEUED\"", "category": "Python"}, {"instruction": "def get_newest(blocks, layout_blocks):\n    \"\"\"Filter out old layout blocks from list\n\n    Arguments:\n    List:blocks        -- List of block objects\n    List:layout_blocks -- List of layout block indexes\n\n    Returns:\n    List -- Newest layout blocks in list\n    \"\"\"\n", "input": "", "output": "    layout_temp = list(layout_blocks)\n\n    for i in range(0, len(layout_temp)):\n        for k in range(0, len(layout_blocks)):\n            if blocks[layout_temp[i]].ec_hdr.image_seq != blocks[layout_blocks[k]].ec_hdr.image_seq:\n                continue\n\n            if blocks[layout_temp[i]].leb_num != blocks[layout_blocks[k]].leb_num:\n                continue\n\n            if blocks[layout_temp[i]].vid_hdr.sqnum > blocks[layout_blocks[k]].vid_hdr.sqnum:\n                del layout_blocks[k]\n                break\n\n    return layout_blocks", "category": "Python"}, {"instruction": "def hit(self, pt):\n        \"\"\"Find the view (self, child, or None) under the point `pt`.\"\"\"\n", "input": "", "output": "\n        if self.hidden or not self._enabled:\n            return None\n\n        if not self.frame.collidepoint(pt):\n            return None\n\n        local_pt = (pt[0] - self.frame.topleft[0],\n                    pt[1] - self.frame.topleft[1])\n\n        for child in reversed(self.children):   # front to back\n            hit_view = child.hit(local_pt)\n            if hit_view is not None:\n                return hit_view\n\n        return self", "category": "Python"}, {"instruction": "def filter(self, datax, datay):\n        \"\"\"Filter a set of datax and datay according to `self.points`\"\"\"\n", "input": "", "output": "        f = np.ones(datax.shape, dtype=bool)\n        for i, p in enumerate(zip(datax, datay)):\n            f[i] = PolygonFilter.point_in_poly(p, self.points)\n\n        if self.inverted:\n            np.invert(f, f)\n\n        return f", "category": "Python"}, {"instruction": "def cacheable(self):\n        \"\"\"Return the cacheable attribute of the BFD file being processed.\"\"\"\n", "input": "", "output": "        if not self._ptr:\n            raise BfdException(\"BFD not initialized\")\n\n        return _bfd.get_bfd_attribute(self._ptr, BfdAttributes.CACHEABLE)", "category": "Python"}, {"instruction": "def get_remaining_width(sample_string, max_terminal_width=None):\n    \"\"\"Returns the number of characters available if sample string were to be printed in the terminal.\n\n    Positional arguments:\n    sample_string -- gets the length of this string.\n\n    Keyword arguments:\n    max_terminal_width -- limit the overall width of everything to these many characters.\n\n    Returns:\n    Integer.\n    \"\"\"\n", "input": "", "output": "    if max_terminal_width is not None:\n        available_width = min(terminal_width(), max_terminal_width)\n    else:\n        available_width = terminal_width()\n    return available_width - len(sample_string)", "category": "Python"}, {"instruction": "def getExtensions(self, extname='SCI', section=None):\n        \"\"\" Return the list of EXTVER values for extensions with name specified\n        in extname.\n\n        \"\"\"\n", "input": "", "output": "        if section is None:\n            numext = 0\n            section = []\n            for hdu in self._image:\n                if 'extname' in hdu.header and hdu.header['extname'] == extname:\n                    section.append(hdu.header['extver'])\n        else:\n            if not isinstance(section,list):\n                section = [section]\n\n        return section", "category": "Python"}, {"instruction": "def lookup_family_by_name(name):\n    \"\"\"https://github.com/thom311/libnl/blob/libnl3_2_25/lib/genl/mngt.c#L106.\n\n    Positional arguments:\n    name -- string.\n\n    Returns:\n    genl_ops class instance or None.\n    \"\"\"\n", "input": "", "output": "    for ops in nl_list_for_each_entry(genl_ops(), genl_ops_list, 'o_list'):\n        if ops.o_name == name:\n            return ops\n    return None", "category": "Python"}, {"instruction": "def Add(self, other):\n    \"\"\"Add other to self pointwise.\n\n    Requires that both self and other are of the same length, and contain\n    identical timestamps. Typically this means that Normalize has been called\n    on both with identical time parameters.\n\n    Args:\n      other: The sequence to add to self.\n\n    Raises:\n      RuntimeError: other does not contain the same timestamps as self.\n    \"\"\"\n", "input": "", "output": "    if len(self.data) != len(other.data):\n      raise RuntimeError(\"Can only add series of identical lengths.\")\n    for i in range(len(self.data)):\n      if self.data[i][1] != other.data[i][1]:\n        raise RuntimeError(\"Timestamp mismatch.\")\n      if self.data[i][0] is None and other.data[i][0] is None:\n        continue\n      self.data[i][0] = (self.data[i][0] or 0) + (other.data[i][0] or 0)", "category": "Python"}, {"instruction": "def protocol_authenticate(self, account=None):\n        \"\"\"\n        Low-level API to perform protocol-level authentication on protocols\n        that support it.\n\n        .. HINT::\n           In most cases, you want to use the login() method instead, as\n           it automatically chooses the best login method for each protocol.\n\n        :type  account: Account\n        :param account: An account object, like login().\n        \"\"\"\n", "input": "", "output": "        with self._get_account(account) as account:\n            user = account.get_name()\n            password = account.get_password()\n            key = account.get_key()\n            if key is None:\n                self._dbg(1, \"Attempting to authenticate %s.\" % user)\n                self._protocol_authenticate(user, password)\n            else:\n                self._dbg(1, \"Authenticate %s with key.\" % user)\n                self._protocol_authenticate_by_key(user, key)\n        self.proto_authenticated = True", "category": "Python"}, {"instruction": "def get_hcurves(self, imtls=None):\n        \"\"\"\n        :param imtls: intensity measure types and levels\n        :returns: an array of (R, N) hazard curves\n        \"\"\"\n", "input": "", "output": "        self.init()\n        if imtls is None:\n            imtls = self.imtls\n        pmaps = [pmap.convert2(imtls, self.sids)\n                 for pmap in self.get_pmaps()]\n        return numpy.array(pmaps)", "category": "Python"}, {"instruction": "def call(self, itemMethod):\n        \"\"\"\n        Invoke the given bound item method in the batch process.\n\n        Return a Deferred which fires when the method has been invoked.\n        \"\"\"\n", "input": "", "output": "        item = itemMethod.im_self\n        method = itemMethod.im_func.func_name\n        return self.batchController.getProcess().addCallback(\n            CallItemMethod(storepath=item.store.dbdir,\n                           storeid=item.storeID,\n                           method=method).do)", "category": "Python"}, {"instruction": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n", "input": "", "output": "        super(edXNumericResponseQuestionFormRecord, self)._init_metadata()\n        QuestionTextFormRecord._init_metadata(self)\n        QuestionFilesFormRecord._init_metadata(self)", "category": "Python"}, {"instruction": "def handleConnectionState(self, msg):\n        \"\"\":Return: True if IBPy message `msg` indicates the connection is unavailable for any reason, else False.\"\"\"\n", "input": "", "output": "        self.connected = not (msg.typeName == \"error\" and\n                              msg.errorCode in dataTypes[\"DISCONNECT_ERROR_CODES\"])\n\n        if self.connected:\n            self.connection_tracking[\"errors\"] = []\n            self.connection_tracking[\"disconnected\"] = False\n\n            if msg.typeName == dataTypes[\"MSG_CURRENT_TIME\"] and not self.connection_tracking[\"connected\"]:\n                self.log.info(\"[CONNECTION TO IB ESTABLISHED]\")\n                self.connection_tracking[\"connected\"] = True\n                self.ibCallback(caller=\"handleConnectionOpened\", msg=\"<connectionOpened>\")\n        else:\n            self.connection_tracking[\"connected\"] = False\n\n            if not self.connection_tracking[\"disconnected\"]:\n                self.connection_tracking[\"disconnected\"] = True\n                self.log.info(\"[CONNECTION TO IB LOST]\")", "category": "Python"}, {"instruction": "def check_int(self, param, error_msg):\n        \"\"\"\n        This function check if the parameter is int.\n        If yes, the function returns the parameter,\n        if not, it raises error message.\n        \n        **Args:**\n        \n        * `param` : parameter to check (int or similar)\n\n        * `error_ms` : lowest allowed value (int), or None        \n        \n        **Returns:**\n        \n        * `param` : parameter (int)\n        \"\"\"\n", "input": "", "output": "        if type(param) == int:\n            return int(param)\n        else:\n            raise ValueError(error_msg)", "category": "Python"}, {"instruction": "def check_value(self, value):\n        \"\"\"Check the validity of a value for the field.\"\"\"\n", "input": "", "output": "        #if self.readonly:\n        #    raise error.Error(\n        #        \"'{field_name}' field is readonly\".format(\n        #            field_name=self.name))\n        if value and self.size:\n            if not is_string(value):\n                raise ValueError(\"Value supplied has to be a string\")\n            if len(value) > self.size:\n                raise ValueError(\n                    \"Lenght of the '{0}' is limited to {1}\".format(\n                        self.name, self.size))\n        if not value and self.required:\n            raise ValueError(\"'{0}' field is required\".format(self.name))\n        return value", "category": "Python"}, {"instruction": "def half_light_radius_source(self, kwargs_source, center_x=0, center_y=0, deltaPix=None, numPix=None):\n        \"\"\"\n        computes numerically the half-light-radius of the deflector light and the total photon flux\n\n        :param kwargs_source:\n        :return:\n        \"\"\"\n", "input": "", "output": "        if numPix is None:\n            numPix = 1000\n        if deltaPix is None:\n            deltaPix = 0.005\n        x_grid, y_grid = util.make_grid(numPix=numPix, deltapix=deltaPix)\n        x_grid += center_x\n        y_grid += center_y\n        source_light = self.SourceModel.surface_brightness(x_grid, y_grid, kwargs_source)\n        R_h = analysis_util.half_light_radius(source_light, x_grid, y_grid, center_x=center_x, center_y=center_y)\n        return R_h", "category": "Python"}, {"instruction": "def ngrok_url():\n    \"\"\"\n    If ngrok is running, it exposes an API on port 4040. We can use that\n    to figure out what URL it has assigned, and suggest that to the user.\n    https://ngrok.com/docs#list-tunnels\n    \"\"\"\n", "input": "", "output": "    try:\n        ngrok_resp = requests.get(\"http://localhost:4040/api/tunnels\")\n    except requests.ConnectionError:\n        # I guess ngrok isn't running.\n        return None\n    ngrok_data = ngrok_resp.json()\n    secure_urls = [\n        tunnel[\"public_url\"]\n        for tunnel in ngrok_data[\"tunnels\"]\n        if tunnel[\"proto\"] == \"https\"\n    ]\n    return secure_urls[0]", "category": "Python"}, {"instruction": "def split_filename(filename):\n    \"\"\"\n    Received a standard style rpm fullname and returns\n    name, version, release, epoch, arch\n    Example: foo-1.0-1.i386.rpm returns foo, 1.0, 1, i386\n             1:bar-9-123a.ia64.rpm returns bar, 9, 123a, 1, ia64\n\n    This function replaces rpmUtils.miscutils.splitFilename, see\n    https://bugzilla.redhat.com/1452801\n    \"\"\"\n", "input": "", "output": "\n    # Remove .rpm suffix\n    if filename.endswith('.rpm'):\n        filename = filename.split('.rpm')[0]\n\n    # is there an epoch?\n    components = filename.split(':')\n    if len(components) > 1:\n        epoch = components[0]\n    else:\n        epoch = ''\n\n    # Arch is the last item after .\n    arch = filename.rsplit('.')[-1]\n    remaining = filename.rsplit('.%s' % arch)[0]\n    release = remaining.rsplit('-')[-1]\n    version = remaining.rsplit('-')[-2]\n    name = '-'.join(remaining.rsplit('-')[:-2])\n\n    return name, version, release, epoch, arch", "category": "Python"}, {"instruction": "def parse_example_line(lisp_string: str) -> Dict:\n    \"\"\"\n    Training data in WikitableQuestions comes with examples in the form of lisp strings in the format:\n        (example (id <example-id>)\n                 (utterance <question>)\n                 (context (graph tables.TableKnowledgeGraph <table-filename>))\n                 (targetValue (list (description <answer1>) (description <answer2>) ...)))\n\n    We parse such strings and return the parsed information here.\n    \"\"\"\n", "input": "", "output": "    id_piece, rest = lisp_string.split(') (utterance \"')\n    example_id = id_piece.split('(id ')[1]\n    question, rest = rest.split('\") (context (graph tables.TableKnowledgeGraph ')\n    table_filename, rest = rest.split(')) (targetValue (list')\n    target_value_strings = rest.strip().split(\"(description\")\n    target_values = []\n    for string in target_value_strings:\n        string = string.replace(\")\", \"\").replace('\"', '').strip()\n        if string != \"\":\n            target_values.append(string)\n    return {'id': example_id,\n            'question': question,\n            'table_filename': table_filename,\n            'target_values': target_values}", "category": "Python"}, {"instruction": "def asset(self, asset_id, asset_type, action='GET'):\n        \"\"\"\n        Gets the asset with the provided id\n        Args:\n            asset_id: The id of the asset to be retrieved\n            asset_type: (str) Either PHONE, HANDLER, or URL\n            action:\n\n        Returns:\n\n        \"\"\"\n", "input": "", "output": "        if not self.can_update():\n            self._tcex.handle_error(910, [self.type])\n\n        if asset_type == 'PHONE':\n            return self.tc_requests.adversary_phone_asset(\n                self.api_type, self.api_sub_type, self.unique_id, asset_id, action=action\n            )\n        if asset_type == 'HANDLER':\n            return self.tc_requests.adversary_handle_asset(\n                self.api_type, self.api_sub_type, self.unique_id, asset_id, action=action\n            )\n        if asset_type == 'URL':\n            return self.tc_requests.adversary_url_asset(\n                self.api_type, self.api_sub_type, self.unique_id, asset_id, action=action\n            )\n        self._tcex.handle_error(\n            925, ['asset_type', 'assets', 'asset_type', 'asset_type', asset_type]\n        )\n        return None", "category": "Python"}, {"instruction": "def missing_nodes(self):\n        \"\"\"The set of targets known as dependencies but not yet defined.\"\"\"\n", "input": "", "output": "        missing = set()\n        for target_addr, target_attrs in self.graph.node.items():\n            if 'target_obj' not in target_attrs:\n                missing.add(target_addr)\n        return missing", "category": "Python"}, {"instruction": "def cube2matrix(data_cube):\n    r\"\"\"Cube to Matrix\n\n    This method transforms a 3D cube to a 2D matrix\n\n    Parameters\n    ----------\n    data_cube : np.ndarray\n        Input data cube, 3D array\n\n    Returns\n    -------\n    np.ndarray 2D matrix\n\n    Examples\n    --------\n    >>> from modopt.base.transform import cube2matrix\n    >>> a = np.arange(16).reshape((4, 2, 2))\n    >>> cube2matrix(a)\n    array([[ 0,  4,  8, 12],\n           [ 1,  5,  9, 13],\n           [ 2,  6, 10, 14],\n           [ 3,  7, 11, 15]])\n\n    \"\"\"\n", "input": "", "output": "\n    return data_cube.reshape([data_cube.shape[0]] +\n                             [np.prod(data_cube.shape[1:])]).T", "category": "Python"}, {"instruction": "async def on_raw_422(self, message):\n        \"\"\" MOTD is missing. \"\"\"\n", "input": "", "output": "        await self._registration_completed(message)\n        self.motd = None\n        await self.on_connect()", "category": "Python"}, {"instruction": "def get(self, *args, **kwargs):\n        \"\"\"\n        Works just like the default Manager's :func:`get` method, but\n        you can pass an additional keyword argument named ``path`` specifying\n        the full path of the object you want to retrieve, e.g.\n        ``\"path/to/folder/readme.txt\"``.\n        \"\"\"\n", "input": "", "output": "        if 'path' in kwargs:\n            kwargs = self.get_filter_args_with_path(True, **kwargs)\n        return super(FileNodeManager, self).get(\n            *args, **kwargs)", "category": "Python"}, {"instruction": "def iter(self, match=\"*\", count=1000):\n        \"\"\" Iterates the set of keys in :prop:key_prefix in :prop:_client\n            @match: #str pattern to match after the :prop:key_prefix\n            @count: the user specified the amount of work that should be done\n                at every call in order to retrieve elements from the collection\n\n            -> yields redis keys within this instance\n        \"\"\"\n", "input": "", "output": "        replace_this = self.key_prefix+\":\"\n        for key in self._client.scan_iter(\n           match=\"{}:{}\".format(self.key_prefix, match), count=count):\n            yield self._decode(key).replace(replace_this, \"\", 1)", "category": "Python"}, {"instruction": "def _full_pipeline(self):\n        \"\"\"Return the full aggregation pipeline for this ChangeStream.\"\"\"\n", "input": "", "output": "        options = self._pipeline_options()\n        full_pipeline = [{'$changeStream': options}]\n        full_pipeline.extend(self._pipeline)\n        return full_pipeline", "category": "Python"}, {"instruction": "def floatify_latlng(input_value):\n    \"\"\"\n    Work around a JSON dict with string, not float, lat/lngs.\n\n    Given anything (list/dict/etc) it will return that thing again, *but* any\n    dict (at any level) that has only 2 elements lat & lng, will be replaced\n    with the lat & lng turned into floats.\n\n    If the API returns the lat/lng as strings, and not numbers, then this\n    function will 'clean them up' to be floats.\n    \"\"\"\n", "input": "", "output": "    if isinstance(input_value, collections.Mapping):\n        if len(input_value) == 2 and sorted(input_value.keys()) == ['lat', 'lng']:\n            # This dict has only 2 keys 'lat' & 'lon'\n            return {'lat': float_if_float(input_value[\"lat\"]), 'lng': float_if_float(input_value[\"lng\"])}\n        else:\n            return dict((key, floatify_latlng(value)) for key, value in input_value.items())\n    elif isinstance(input_value, collections.MutableSequence):\n        return [floatify_latlng(x) for x in input_value]\n    else:\n        return input_value", "category": "Python"}, {"instruction": "def paths_from_iddname(iddname):\n    \"\"\"Get the EnergyPlus install directory and executable path.\n\n    Parameters\n    ----------\n    iddname : str, optional\n        File path to the IDD.\n\n    Returns\n    -------\n    eplus_exe : str\n        Full path to the EnergyPlus executable.\n    eplus_home : str\n        Full path to the EnergyPlus install directory.\n\n    Raises\n    ------\n    AttributeError (TypeError on Windows)\n        If iddname does not have a directory component (e.g. if None).\n    ValueError\n        If eplus_exe is not a file.\n\n    \"\"\"\n", "input": "", "output": "    eplus_home = os.path.abspath(os.path.dirname(iddname))\n    if platform.system() == 'Windows':\n        eplus_exe = os.path.join(eplus_home, 'energyplus.exe')\n    elif platform.system() == \"Linux\":\n        eplus_exe = os.path.join(eplus_home, 'energyplus')\n    else:\n        eplus_exe = os.path.join(eplus_home, 'energyplus')\n    if not os.path.isfile(eplus_exe):\n        raise ValueError\n    return eplus_exe, eplus_home", "category": "Python"}, {"instruction": "def _build_url(self):\n        \"\"\"Build url based on searching by date or by show.\"\"\"\n", "input": "", "output": "        url_params = [\n            BASE_URL, self.category + ' ratings', self.day, self.year, self.month\n        ]\n\n        return SEARCH_URL.format(*url_params)", "category": "Python"}, {"instruction": "def _rapply(d, func, *args, **kwargs):\n    \"\"\"Apply a function to all values in a dictionary or list of dictionaries, recursively.\"\"\"\n", "input": "", "output": "    if isinstance(d, (tuple, list)):\n        return [_rapply(each, func, *args, **kwargs) for each in d]\n    if isinstance(d, dict):\n        return {\n            key: _rapply(value, func, *args, **kwargs) for key, value in iteritems(d)\n        }\n    else:\n        return func(d, *args, **kwargs)", "category": "Python"}, {"instruction": "def _get_iterator(self):\n        \"\"\"The iterator passed in can take several forms: a class that can be\n        instantiated and then iterated over; a function that when called\n        returns an iterator; an actual iterator/generator or an iterable\n        collection.  This function sorts all that out and returns an iterator\n        that can be used\"\"\"\n", "input": "", "output": "        try:\n            return self.job_param_source_iter(self.config)\n        except TypeError:\n            try:\n                return self.job_param_source_iter()\n            except TypeError:\n                return self.job_param_source_iter", "category": "Python"}, {"instruction": "def handle(self, *args, **options):\n        \"\"\"Django command handler.\"\"\"\n", "input": "", "output": "        self.verbosity = int(options.get('verbosity'))\n        self.quiet = options.get('quiet')\n        self._set_logger_level()\n\n        self.servername = options.get('servername')\n        self.decrypt = options.get('decrypt')\n        self.uncompress = options.get('uncompress')\n\n        self.filename = options.get('input_filename')\n        self.path = options.get('input_path')\n\n        self.replace = options.get('replace')\n        self.passphrase = options.get('passphrase')\n        self.interactive = options.get('interactive')\n\n        self.storage = get_storage()\n        self.media_storage = get_storage_class()()\n        self._restore_backup()", "category": "Python"}, {"instruction": "def p_class_declaration_statement(p):\n    '''class_declaration_statement : class_entry_type STRING extends_from implements_list LBRACE class_statement_list RBRACE\n                                   | INTERFACE STRING interface_extends_list LBRACE class_statement_list RBRACE'''\n", "input": "", "output": "    if len(p) == 8:\n        p[0] = ast.Class(p[2], p[1], p[3], p[4], p[6], lineno=p.lineno(2))\n    else:\n        p[0] = ast.Interface(p[2], p[3], p[5], lineno=p.lineno(1))", "category": "Python"}, {"instruction": "def untlpydict2dcformatteddict(untl_dict, **kwargs):\n    \"\"\"Convert a UNTL data dictionary to a formatted DC data dictionary.\"\"\"\n", "input": "", "output": "    ark = kwargs.get('ark', None)\n    domain_name = kwargs.get('domain_name', None)\n    scheme = kwargs.get('scheme', 'http')\n    resolve_values = kwargs.get('resolve_values', None)\n    resolve_urls = kwargs.get('resolve_urls', None)\n    verbose_vocabularies = kwargs.get('verbose_vocabularies', None)\n    # Get the UNTL object.\n    untl_py = untldict2py(untl_dict)\n    # Convert it to a DC object.\n    dc_py = untlpy2dcpy(\n        untl_py,\n        ark=ark,\n        domain_name=domain_name,\n        resolve_values=resolve_values,\n        resolve_urls=resolve_urls,\n        verbose_vocabularies=verbose_vocabularies,\n        scheme=scheme\n    )\n    # Return a formatted DC dictionary.\n    return dcpy2formatteddcdict(dc_py)", "category": "Python"}, {"instruction": "def create_media_asset(access_token, name, options=\"0\"):\n    '''Create Media Service Asset.\n\n    Args:\n        access_token (str): A valid Azure authentication token.\n        name (str): Media Service Asset Name.\n        options (str): Media Service Options.\n\n    Returns:\n        HTTP response. JSON body.\n    '''\n", "input": "", "output": "    path = '/Assets'\n    endpoint = ''.join([ams_rest_endpoint, path])\n    body = '{\"Name\": \"' + name + '\", \"Options\": \"' + str(options) + '\"}'\n    return do_ams_post(endpoint, path, body, access_token)", "category": "Python"}, {"instruction": "def runUAT(self, args):\n\t\t\"\"\"\n\t\tRuns the Unreal Automation Tool with the supplied arguments\n\t\t\"\"\"\n", "input": "", "output": "\t\tUtility.run([self.getRunUATScript()] + args, cwd=self.getEngineRoot(), raiseOnError=True)", "category": "Python"}, {"instruction": "def comment (self, data):\n        \"\"\"\n        Print HTML comment.\n\n        @param data: the comment\n        @type data: string\n        @return: None\n        \"\"\"\n", "input": "", "output": "        data = data.encode(self.encoding, \"ignore\")\n        self.fd.write(\"<!--%s-->\" % data)", "category": "Python"}, {"instruction": "def getHeader(self):\n        \"\"\"\n        Returns the file header as dict\n\n        Parameters\n        ----------\n        None\n        \"\"\"\n", "input": "", "output": "        return {\"technician\": self.getTechnician(), \"recording_additional\": self.getRecordingAdditional(),\n                \"patientname\": self.getPatientName(), \"patient_additional\": self.getPatientAdditional(),\n                \"patientcode\": self.getPatientCode(), \"equipment\": self.getEquipment(),\n                \"admincode\": self.getAdmincode(), \"gender\": self.getGender(), \"startdate\": self.getStartdatetime(),\n                \"birthdate\": self.getBirthdate()}", "category": "Python"}, {"instruction": "def dist(self, x1, x2):\n        \"\"\"Return the distance between ``x1`` and ``x2``.\n\n        Parameters\n        ----------\n        x1, x2 : `LinearSpaceElement`\n            Elements whose distance to compute.\n\n        Returns\n        -------\n        dist : float\n            Distance between ``x1`` and ``x2``.\n        \"\"\"\n", "input": "", "output": "        if x1 not in self:\n            raise LinearSpaceTypeError('`x1` {!r} is not an element of '\n                                       '{!r}'.format(x1, self))\n        if x2 not in self:\n            raise LinearSpaceTypeError('`x2` {!r} is not an element of '\n                                       '{!r}'.format(x2, self))\n        return float(self._dist(x1, x2))", "category": "Python"}, {"instruction": "def union(*argv):\n        \"\"\"Returns union of sets as a new set. basically it's\n        Items are ordered by set1, set2, ...\n        \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u6c42\u591a\u4e2a\u6709\u5e8f\u96c6\u5408\u7684\u5e76\u96c6, \u6309\u7167\u7b2c\u4e00\u4e2a\u96c6\u5408, \u7b2c\u4e8c\u4e2a, ..., \u8fd9\u6837\u7684\u987a\u5e8f\u3002\n        \"\"\"\n", "input": "", "output": "        res = OrderedSet()\n        for ods in argv:\n            res = res | ods\n        return res", "category": "Python"}, {"instruction": "def get_trunk_interfaces(devId):\n    \"\"\"Function takes devId as input to RESTFULL call to HP IMC platform\n    :param devId: output of get_dev_details\n    :return: list of dictionaries containing of interfaces configured as an 802.1q trunk\n    \"\"\"\n", "input": "", "output": "\n    # checks to see if the imc credentials are already available\n    if auth is None or url is None:\n        set_imc_creds()\n    global r\n    get_trunk_interfaces_url = \"/imcrs/vlan/trunk?devId=\" + str(devId) + \"&start=1&size=5000&total=false\"\n    f_url = url + get_trunk_interfaces_url\n    payload = None\n    # creates the URL using the payload variable as the contents\n    r = requests.get(f_url, auth=auth, headers=headers)\n    # r.status_code\n    if r.status_code == 200:\n        dev_trunk_interfaces = (json.loads(r.text))\n        if len(dev_trunk_interfaces) == 2:\n            return dev_trunk_interfaces['trunkIf']\n        else:\n            dev_trunk_interfaces['trunkIf'] = [\"No trunk inteface\"]\n            return dev_trunk_interfaces['trunkIf']", "category": "Python"}, {"instruction": "def get_intercom_data(self):\n        \"\"\"Specify the data sent to Intercom API according to event type\"\"\"\n", "input": "", "output": "        data = {\n            \"event_name\": self.get_type_display(),  # event type\n            \"created_at\": calendar.timegm(self.created.utctimetuple()),  # date\n            \"metadata\": self.metadata\n        }\n        if self.user:\n            data[\"user_id\"] = self.user.intercom_id\n        return data", "category": "Python"}, {"instruction": "def _select_row_by_column_value(tree_view, list_store, column, value):\n        \"\"\"Helper method to select a tree view row\n\n        :param Gtk.TreeView tree_view: Tree view who's row is to be selected\n        :param Gtk.ListStore list_store: List store of the tree view\n        :param int column: Column in which the value is searched\n        :param value: Value to search for\n        :returns: Row of list store that has selected\n        :rtype: int\n        \"\"\"\n", "input": "", "output": "        for row_num, iter_elem in enumerate(list_store):\n            if iter_elem[column] == value:\n                tree_view.set_cursor(row_num)\n                return row_num", "category": "Python"}, {"instruction": "def add(self, dpid, ports):\n        \"\"\"add a setting of a bonding i/f.\n        'add' method takes the corresponding args in this order.\n\n        ========= =====================================================\n        Attribute Description\n        ========= =====================================================\n        dpid      datapath id.\n\n        ports     a list of integer values that means the ports face\n                  with the slave i/fs.\n        ========= =====================================================\n\n        if you want to use multi LAG, call 'add' method more than once.\n        \"\"\"\n", "input": "", "output": "        assert isinstance(ports, list)\n        assert len(ports) >= 2\n        ifs = {}\n        for port in ports:\n            ifs[port] = {'enabled': False, 'timeout': 0}\n        bond = {dpid: ifs}\n        self._bonds.append(bond)", "category": "Python"}, {"instruction": "def dump_conndata(self):\n        \"\"\"Developer tool for debugging forensics.\"\"\"\n", "input": "", "output": "        attrs = vars(self)\n        return ', '.join(\"%s: %s\" % item for item in attrs.items())", "category": "Python"}, {"instruction": "def stop_program(self, turn_off_load=True):\n        \"\"\"\n        Stops running programmed test sequence\n        :return: None\n        \"\"\"\n", "input": "", "output": "        self.__set_buffer_start(self.CMD_STOP_PROG)\n        self.__set_checksum()\n        self.__send_buffer()\n        if turn_off_load and self.load_on:\n            self.load_on = False", "category": "Python"}, {"instruction": "def mkdir(self, pathobj, _):\n        \"\"\"\n        Creates remote directory\n        Note that this operation is not recursive\n        \"\"\"\n", "input": "", "output": "        if not pathobj.drive or not pathobj.root:\n            raise RuntimeError(\"Full path required: '%s'\" % str(pathobj))\n\n        if pathobj.exists():\n            raise OSError(17, \"File exists: '%s'\" % str(pathobj))\n\n        url = str(pathobj) + '/'\n        text, code = self.rest_put(url, session=pathobj.session, verify=pathobj.verify, cert=pathobj.cert)\n\n        if not code == 201:\n            raise RuntimeError(\"%s %d\" % (text, code))", "category": "Python"}, {"instruction": "def _to_dict(self):\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n", "input": "", "output": "        _dict = {}\n        if hasattr(self, 'aggregations') and self.aggregations is not None:\n            _dict['aggregations'] = [x._to_dict() for x in self.aggregations]\n        return _dict", "category": "Python"}, {"instruction": "def save_dir(key, dir_path, *refs):\n    \"\"\"Convert the given parameters to a special JSON object.\n\n    JSON object is of the form:\n    { key: {\"dir\": dir_path}}, or\n    { key: {\"dir\": dir_path, \"refs\": [refs[0], refs[1], ... ]}}\n\n    \"\"\"\n", "input": "", "output": "    if not os.path.isdir(dir_path):\n        return error(\n            \"Output '{}' set to a missing directory: '{}'.\".format(key, dir_path)\n        )\n\n    result = {key: {\"dir\": dir_path}}\n\n    if refs:\n        missing_refs = [\n            ref for ref in refs if not (os.path.isfile(ref) or os.path.isdir(ref))\n        ]\n        if len(missing_refs) > 0:\n            return error(\n                \"Output '{}' set to missing references: '{}'.\".format(\n                    key, ', '.join(missing_refs)\n                )\n            )\n        result[key][\"refs\"] = refs\n\n    return json.dumps(result)", "category": "Python"}, {"instruction": "def context_changed(self, context):\n        \"\"\" :type context: dict \"\"\"\n", "input": "", "output": "        self._image.set_cmap(context['colormap'])\n        self._image.set_clim(context['min'], context['max'])\n        self._image.set_interpolation(context['interpolation'])\n        self._update_indicators(context)\n\n        self._set_view_limits()\n\n        if self._model.index_direction is not SliceDirection.depth:\n            self._image.axes.set_ylabel(context['samples_unit'])", "category": "Python"}, {"instruction": "def WaitUntilDone(self, timeout=None):\n    \"\"\"Wait until the operation is done.\n\n    Args:\n      timeout: timeout in seconds. None means default timeout (1 hour).\n               0 means no timeout (wait forever).\n    Returns:\n      Operation object with refreshed target_file.\n    Raises:\n      PollTimeoutError: if timeout is reached.\n    \"\"\"\n", "input": "", "output": "\n    utils.Poll(\n        generator=self.GetState,\n        condition=lambda s: s != self.__class__.STATE_RUNNING,\n        timeout=timeout)\n    self.target_file = self.target_file.Get()\n    return self", "category": "Python"}, {"instruction": "def split_locale(loc):\n    '''\n    Split a locale specifier.  The general format is\n\n    language[_territory][.codeset][@modifier] [charmap]\n\n    For example:\n\n    ca_ES.UTF-8@valencia UTF-8\n    '''\n", "input": "", "output": "    def split(st, char):\n        ", "category": "Python"}, {"instruction": "def group_concat(arg, sep=',', where=None):\n    \"\"\"\n    Concatenate values using the indicated separator (comma by default) to\n    produce a string\n\n    Parameters\n    ----------\n    arg : array expression\n    sep : string, default ','\n    where : bool, default None\n\n    Returns\n    -------\n    concatenated : string scalar\n    \"\"\"\n", "input": "", "output": "    return ops.GroupConcat(arg, sep, where).to_expr()", "category": "Python"}, {"instruction": "def get_comments_content_object(parser, token):\n    \"\"\"\n    Get a limited set of comments for a given object.\n    Defaults to a limit of 5. Setting the limit to -1 disables limiting.\n\n    usage:\n\n        {% get_comments_content_object for form_object as variable_name %}\n\n    \"\"\"\n", "input": "", "output": "    keywords = token.contents.split()\n    if len(keywords) != 5:\n        raise template.TemplateSyntaxError(\n            \"'%s' tag takes exactly 2 arguments\" % (keywords[0],))\n    if keywords[1] != 'for':\n        raise template.TemplateSyntaxError(\n            \"first argument to '%s' tag must be 'for'\" % (keywords[0],))\n    if keywords[3] != 'as':\n        raise template.TemplateSyntaxError(\n            \"first argument to '%s' tag must be 'as'\" % (keywords[0],))\n    return GetCommentsContentObject(keywords[2], keywords[4])", "category": "Python"}, {"instruction": "def normalize(dt, tz=UTC):\n    \"\"\"\n    Convert date or datetime to datetime with timezone.\n\n    :param dt: date to normalize\n    :param tz: the normalized date's timezone\n    :return: date as datetime with timezone\n    \"\"\"\n", "input": "", "output": "    if type(dt) is date:\n        dt = dt + relativedelta(hour=0)\n    elif type(dt) is datetime:\n        pass\n    else:\n        raise ValueError(\"unknown type %s\" % type(dt))\n\n    if dt.tzinfo:\n        dt = dt.astimezone(tz)\n    else:\n        dt = dt.replace(tzinfo=tz)\n\n    return dt", "category": "Python"}, {"instruction": "def raw(self, klass, _name=\"default\", **attributes):\n        \"\"\"\n        Get the raw attribute dict for a given named model.\n\n        :param klass: The class\n        :type klass: class\n\n        :param _name: The type\n        :type _name: str\n\n        :param attributes: The instance attributes\n        :type attributes: dict\n\n        :return: dict\n        \"\"\"\n", "input": "", "output": "        raw = self._definitions[klass][_name](self._faker)\n\n        raw.update(attributes)\n\n        return raw", "category": "Python"}, {"instruction": "def stat(filename):\n    \"\"\"Returns os.stat for a given file, adjusting the timestamps as appropriate.\"\"\"\n", "input": "", "output": "    import os\n    try:\n        # on the host, lstat won't try to follow symlinks\n        rstat = os.lstat(filename)\n    except:\n        rstat = os.stat(filename)\n    return rstat[:7] + tuple(tim + TIME_OFFSET for tim in rstat[7:])", "category": "Python"}, {"instruction": "def check_positive_integer(name, value):\n    \"\"\"Check a value is a positive integer.\n\n    Returns the value if so, raises ValueError otherwise.\n\n    \"\"\"\n", "input": "", "output": "    try:\n        value = int(value)\n        is_positive = (value > 0)\n    except ValueError:\n        raise ValueError('%s should be an integer; got %r' % (name, value))\n\n    if is_positive:\n        return value\n    else:\n        raise ValueError('%s should be positive; got %r' % (name, value))", "category": "Python"}, {"instruction": "def distribute(self, func, partitioned_chunks, kwargs):\n        \"\"\"\n        Calculates the features in a sequential fashion by pythons map command\n\n        :param func: the function to send to each worker.\n        :type func: callable\n        :param partitioned_chunks: The list of data chunks - each element is again\n            a list of chunks - and should be processed by one worker.\n        :type partitioned_chunks: iterable\n        :param kwargs: parameters for the map function\n        :type kwargs: dict of string to parameter\n\n        :return: The result of the calculation as a list - each item should be the result of the application of func\n            to a single element.\n        \"\"\"\n", "input": "", "output": "        return map(partial(func, **kwargs), partitioned_chunks)", "category": "Python"}, {"instruction": "def get_kernel_spec(self, kernel_name):\n        \"\"\"Returns a :class:`KernelSpec` instance for the given kernel_name.\n\n        Raises :exc:`NoSuchKernel` if the given kernel name is not found.\n        \"\"\"\n", "input": "", "output": "        try:\n            return super(EnvironmentKernelSpecManager,\n                         self).get_kernel_spec(kernel_name)\n        except (NoSuchKernel, FileNotFoundError):\n            venv_kernel_name = kernel_name.lower()\n            specs = self.get_all_kernel_specs_for_envs()\n            if venv_kernel_name in specs:\n                return specs[venv_kernel_name]\n            else:\n                raise NoSuchKernel(kernel_name)", "category": "Python"}, {"instruction": "def _get_error_response(self, exception):\n        \"\"\"\n        Trasform pyston exceptions to Is-core exceptions and raise it\n        \"\"\"\n", "input": "", "output": "        response_exceptions = {\n            MimerDataException: HTTPBadRequestResponseException,\n            NotAllowedException: HTTPForbiddenResponseException,\n            UnsupportedMediaTypeException: HTTPUnsupportedMediaTypeResponseException,\n            Http404: Http404,\n            ResourceNotFoundException: Http404,\n            NotAllowedMethodException: HTTPMethodNotAllowedResponseException,\n            DuplicateEntryException: HTTPDuplicateResponseException,\n            ConflictException: HTTPDuplicateResponseException,\n        }\n        response_exception = response_exceptions.get(type(exception))\n        if response_exception:\n            raise response_exception\n        return super(RESTResourceMixin, self)._get_error_response(exception)", "category": "Python"}, {"instruction": "def trim(self, video_name, out, start, duration):\n        \"\"\"\n        Trims a clip to be duration starting at start\n        @param video_name : name of the input video\n        @param out : name of the output video\n        @param start : starting position after the trim\n        @param duration : duration of video after start\n        \"\"\"\n", "input": "", "output": "        command = ['ffmpeg', '-ss', start, '-i', video_name, '-c:v', 'huffyuv',\n                   '-y', '-preset', 'veryslow', '-t', duration, out]\n        if self.verbose:\n            print 'Trimming {0} into {1}'.format(video_name, out)\n            print ' '.join(command)\n        call(command)", "category": "Python"}, {"instruction": "def schedule_and_propagate_host_downtime(self, host, start_time, end_time,\n                                             fixed, trigger_id, duration, author, comment):\n        \"\"\"DOES NOTHING (Should create host downtime and start it?)\n        Format of the line that triggers function call::\n\n        SCHEDULE_AND_PROPAGATE_HOST_DOWNTIME;<host_name>;<start_time>;<end_time>;\n        <fixed>;<trigger_id>;<duration>;<author>;<comment>\n\n        :return: None\n        \"\"\"\n", "input": "", "output": "        logger.warning(\"The external command 'SCHEDULE_AND_PROPAGATE_HOST_DOWNTIME' \"\n                       \"is not currently implemented in Alignak. If you really need it, \"\n                       \"request for its implementation in the project repository: \"\n                       \"https://github.com/Alignak-monitoring/alignak\")\n        self.send_an_element(make_monitoring_log(\n            'warning', 'SCHEDULE_AND_PROPAGATE_HOST_DOWNTIME: this command is not implemented!'))", "category": "Python"}, {"instruction": "def get_street(street, areacode, api=None):\n    \"\"\"\n    Retrieve streets in a given bounding area\n\n    :param overpy.Overpass api: First street of intersection\n    :param String street: Name of street\n    :param String areacode: The OSM id of the bounding area\n    :return: Parsed result\n    :raises overpy.exception.OverPyException: If something bad happens.\n    \"\"\"\n", "input": "", "output": "    if api is None:\n        api = overpy.Overpass()\n\n    query = ", "category": "Python"}, {"instruction": "def min_periodic_distance(self, xyz0, xyz1):\n        \"\"\"Vectorized distance calculation considering minimum image.\n\n        Parameters\n        ----------\n        xyz0 : np.ndarray, shape=(3,), dtype=float\n            Coordinates of first point\n        xyz1 : np.ndarray, shape=(3,), dtype=float\n            Coordinates of second point\n\n        Returns\n        -------\n        float\n            Vectorized distance between the two points following minimum\n            image convention\n\n        \"\"\"\n", "input": "", "output": "        d = np.abs(xyz0 - xyz1)\n        d = np.where(d > 0.5 * self.periodicity, self.periodicity - d, d)\n        return np.sqrt((d ** 2).sum(axis=-1))", "category": "Python"}, {"instruction": "async def insert(self, **kwargs):\n\t\t\"\"\"\n\t\tAccepts request object, retrieves data from the one`s body\n\t\tand creates new account. \n\t\t\"\"\"\n", "input": "", "output": "\t\t\n\t\tif kwargs:\n\t\t\t# Create autoincrement for account\n\t\t\tpk = await self.autoincrement()\n\t\t\tkwargs.update({\"id\": pk})\n\n\t\t\t# Create account with received data and autoincrement\n\t\t\tawait self.collection.insert_one(kwargs)\n\n\t\t\trow = await self.collection.find_one({\"id\": pk})\n\n\t\telse:\n\t\t\trow = None\n\n\t\tif row:\n\t\t\treturn {i:row[i] for i in row if i != \"_id\"}\n\t\telse:\n\t\t\treturn {\"error\":500, \n\t\t\t\t\t\"reason\":\"Not created\"}", "category": "Python"}, {"instruction": "def cat_net_img(url='', indent=4, img_height=0, img_cache_dir='/tmp', use_cache=False):\n    \"\"\"\n        - \u4f18\u5148 \u4ece\u5fae\u535a\u7f13\u5b58\u76ee\u5f55\u8bfb\u53d6\u56fe\u7247\n        - \u5982\u679c\u5931\u8d25, \u518d\u4ece\u76f8\u5e94\u7684url\u8bfb\u53d6\u7167\u7247\n\n    :param use_cache: ``\u4f7f\u7528\u7f13\u5b58``\n    :type use_cache:\n    :param img_cache_dir:\n    :type img_cache_dir:\n    :param url:\n    :type url:\n    :param indent:\n    :type indent:\n    :param img_height:\n    :type img_height:\n    :return:\n    :rtype:\n    \"\"\"\n", "input": "", "output": "    name = url.split('/')[-1]\n    pth = os.path.join(img_cache_dir, name)\n\n    # \u5982\u679c\u4e0d\u4f7f\u7528\u7f13\u5b58 \u6216\u8005 \u6587\u4ef6\u4e0d\u5b58\u5728, \u5219\u5148\u4e0b\u8f7d\u5230\u672c\u5730, \u7136\u540e\u518d\u8bfb\u53d6\n    if not use_cache or not is_file_ok(pth):\n        raw = requests.get(url)\n        write_file(raw.content, pth)\n\n    with textui.indent(indent, quote=' {}'.format(' ')):\n        textui.puts(cat_img_by_path(pth, img_height))", "category": "Python"}, {"instruction": "def equivalent_to(std_function):\n    \"\"\"\n    Decorates a cloud object compatible function\n    to provides fall back to standard function if\n    used on local files.\n\n    Args:\n        std_function (function): standard function to\n            used with local files.\n\n    Returns:\n        function: new function\n    \"\"\"\n", "input": "", "output": "\n    def decorate(cos_function):\n        ", "category": "Python"}, {"instruction": "def _bubbleP(cls, T):\n        \"\"\"Using ancillary equation return the pressure of bubble point\"\"\"\n", "input": "", "output": "        c = cls._blend[\"bubble\"]\n        Tj = cls._blend[\"Tj\"]\n        Pj = cls._blend[\"Pj\"]\n        Tita = 1-T/Tj\n\n        suma = 0\n        for i, n in zip(c[\"i\"], c[\"n\"]):\n            suma += n*Tita**(i/2.)\n        P = Pj*exp(Tj/T*suma)\n        return P", "category": "Python"}, {"instruction": "def convert(self, vroot, entry_variables):\n        \"\"\"\n        All functions are replaced with the same `new` function.\n\n        Args:\n            vroot (:obj:`Variable`): NNabla Variable\n            entry_variables (:obj:`Variable`): Entry variable from which the conversion starts.\n        \"\"\"\n", "input": "", "output": "        self.graph_info = GraphInfo(vroot)\n        self.entry_variables = entry_variables\n\n        with nn.parameter_scope(self.name):\n            # Function loop in the forward order\n            for t, func in enumerate(self.graph_info.funcs):\n                if func.name in self.inner_prod_functions:\n                    inner_prod_func = func\n                    o = self._fixed_point_weight_conversion(inner_prod_func)\n                    continue\n                # Identity conversion\n                o = self._identity_conversion(func)\n\n        self.end_variable = o\n\n        if self.call_forward:\n            o.forward(clear_buffer=True)\n        return self.end_variable", "category": "Python"}, {"instruction": "def blocked(self):\n        r\"\"\"Returns a :class:`list` of :class:`User`\\s that the user has blocked.\n\n        .. note::\n\n            This only applies to non-bot accounts.\n        \"\"\"\n", "input": "", "output": "        return [r.user for r in self._relationships.values() if r.type is RelationshipType.blocked]", "category": "Python"}, {"instruction": "def scalar_summary(tag, scalar):\n    \"\"\"Outputs a `Summary` protocol buffer containing a single scalar value.\n    The generated Summary has a Tensor.proto containing the input Tensor.\n    Adapted from the TensorFlow function `scalar()` at\n    https://github.com/tensorflow/tensorflow/blob/r1.6/tensorflow/python/summary/summary.py\n\n    Parameters\n    ----------\n      tag : str\n          A name for the generated summary. Will also serve as the series name in TensorBoard.\n      scalar : int, MXNet `NDArray`, or `numpy.ndarray`\n          A scalar value or an ndarray of shape (1,).\n\n    Returns\n    -------\n      A `Summary` protobuf of the `scalar` value.\n\n    Raises\n    ------\n      ValueError: If the scalar has the wrong shape or type.\n    \"\"\"\n", "input": "", "output": "    tag = _clean_tag(tag)\n    scalar = _make_numpy_array(scalar)\n    assert(scalar.squeeze().ndim == 0), 'scalar should be 0D'\n    scalar = float(scalar)\n    return Summary(value=[Summary.Value(tag=tag, simple_value=scalar)])", "category": "Python"}, {"instruction": "def _read_depth_image(self):\n        \"\"\" Reads a depth image from the device \"\"\"\n", "input": "", "output": "        # read raw uint16 buffer\n        im_arr = self._depth_stream.read_frame()\n        raw_buf = im_arr.get_buffer_as_uint16()\n        buf_array = np.array([raw_buf[i] for i in range(PrimesenseSensor.DEPTH_IM_WIDTH * PrimesenseSensor.DEPTH_IM_HEIGHT)])\n\n        # convert to image in meters\n        depth_image = buf_array.reshape(PrimesenseSensor.DEPTH_IM_HEIGHT,\n                                        PrimesenseSensor.DEPTH_IM_WIDTH)\n        depth_image = depth_image * MM_TO_METERS # convert to meters\n        if self._flip_images:\n            depth_image = np.flipud(depth_image)\n        else:\n            depth_image = np.fliplr(depth_image)\n        return DepthImage(depth_image, frame=self._frame)", "category": "Python"}, {"instruction": "def rel_path(name, available_tools):\n        \"\"\"\n        Extracts relative path to a tool (from the main cloned directory) out\n        of available_tools based on the name it is given\n        \"\"\"\n", "input": "", "output": "        if name == '@' or name == '.' or name == '/':\n            name = ''\n        multi_tool = '@' in name\n        for tool in available_tools:\n            t_name = tool[0].lower()\n            if multi_tool:\n                if name.split('@')[-1] == t_name.split('@')[-1]:\n                    return t_name, t_name\n            else:\n                if name == t_name.split('/')[-1]:\n                    return t_name, tool[0]\n                elif name == '' and t_name.split('@')[-1] == 'unspecified':\n                    return '', ''\n        return None, None", "category": "Python"}, {"instruction": "def CanSetRoleTo(self, Role):\n        \"\"\"Checks if the new role can be applied to the member.\n\n        :Parameters:\n          Role : `enums`.chatMemberRole*\n            New chat member role.\n\n        :return: True if the new role can be applied, False otherwise.\n        :rtype: bool\n        \"\"\"\n", "input": "", "output": "        t = self._Owner._Alter('CHATMEMBER', self.Id, 'CANSETROLETO', Role,\n                               'ALTER CHATMEMBER CANSETROLETO')\n        return (chop(t, 1)[-1] == 'TRUE')", "category": "Python"}, {"instruction": "def join_session(self, sid):\n        \"\"\"Attach to an existing session.\"\"\"\n", "input": "", "output": "        self._rest.add_header('X-STC-API-Session', sid)\n        self._sid = sid\n        try:\n            status, data = self._rest.get_request('objects', 'system1',\n                                                  ['version', 'name'])\n        except resthttp.RestHttpError as e:\n            self._rest.del_header('X-STC-API-Session')\n            self._sid = None\n            raise RuntimeError('failed to join session \"%s\": %s' % (sid, e))\n\n        return data['version']", "category": "Python"}, {"instruction": "def reward_bonus(self, assignment_id, amount, reason):\n        \"\"\"Print out bonus info for the assignment\"\"\"\n", "input": "", "output": "        logger.info(\n            'Award ${} for assignment {}, with reason \"{}\"'.format(\n                amount, assignment_id, reason\n            )\n        )", "category": "Python"}, {"instruction": "def Escape(self, string=\"\", **_):\n    \"\"\"Support standard string escaping.\"\"\"\n", "input": "", "output": "    # Translate special escapes:\n    self.stack[-1] += self.STRING_ESCAPES.get(string, string)", "category": "Python"}, {"instruction": "def _get_file_content(source):\n    \"\"\"Return a tuple, each value being a line of the source file.\n\n    Remove empty lines and comments (lines starting with a '#').\n\n    \"\"\"\n", "input": "", "output": "    filepath = os.path.join('siglists', source + '.txt')\n\n    lines = []\n    with resource_stream(__name__, filepath) as f:\n        for i, line in enumerate(f):\n            line = line.decode('utf-8', 'strict').strip()\n            if not line or line.startswith('#'):\n                continue\n\n            try:\n                re.compile(line)\n            except Exception as ex:\n                raise BadRegularExpressionLineError(\n                    'Regex error: {} in file {} at line {}'.format(\n                        str(ex),\n                        filepath,\n                        i\n                    )\n                )\n\n            lines.append(line)\n\n    if source in _SPECIAL_EXTENDED_VALUES:\n        lines = lines + _SPECIAL_EXTENDED_VALUES[source]\n\n    return tuple(lines)", "category": "Python"}, {"instruction": "def end_range(self):\n      \"\"\"Similar to the junction range but don't need to check for leftmost or rightmost\"\"\"\n", "input": "", "output": "      if len(self._exons) == 0: return None\n      return GenomicRange(self._exons[0].chr,\n             min([x.end for x in self._exons]),\n             max([x.end for x in self._exons]))", "category": "Python"}, {"instruction": "def local_minima(img, min_distance = 4):\n    r\"\"\"\n    Returns all local minima from an image.\n    \n    Parameters\n    ----------\n    img : array_like\n        The image.\n    min_distance : integer\n        The minimal distance between the minimas in voxels. If it is less, only the lower minima is returned.\n    \n    Returns\n    -------\n    indices : sequence\n        List of all minima indices.\n    values : sequence\n        List of all minima values.\n    \"\"\"\n", "input": "", "output": "    # @TODO: Write a unittest for this.\n    fits = numpy.asarray(img)\n    minfits = minimum_filter(fits, size=min_distance) # default mode is reflect\n    minima_mask = fits == minfits\n    good_indices = numpy.transpose(minima_mask.nonzero())\n    good_fits = fits[minima_mask]\n    order = good_fits.argsort()\n    return good_indices[order], good_fits[order]", "category": "Python"}, {"instruction": "def _download(self, force_overwrite=False, verbose=False):\n        \"\"\"\n        Download the file if it's not already there.\n        We shouldn't *need* to overwrite; the xml is not supposed to update.\n        \"\"\"\n", "input": "", "output": "        if not force_overwrite:\n            # If the file is already there, we're done\n            if os.path.isfile(self.filepath):\n                if verbose:\n                    print(\n                        \"File already available at %s -- skipping\"\n                        % (self.filepath)\n                    )\n                return False\n        stream_download(self.URL, self.filepath, verbose=verbose)\n        return True", "category": "Python"}, {"instruction": "def NoExclusions(self):\n        \"\"\"Determine that there are no exclusion criterion in play\n\n        :return: True if there is no real boundary specification of any kind.\n\n        Simple method allowing parsers to short circuit the determination of\n        missingness, which can be moderately compute intensive.\n        \"\"\"\n", "input": "", "output": "        if len(self.start_bounds) + len(self.target_rs) + len(self.ignored_rs) == 0:\n            return BoundaryCheck.chrom == -1\n        return False", "category": "Python"}, {"instruction": "def plotJacobi(self,*args,**kwargs):\n        \"\"\"\n        NAME:\n\n           plotJacobi\n\n        PURPOSE:\n\n           plot the Jacobi integral along the orbit\n\n        INPUT:\n\n           OmegaP= pattern speed\n\n           pot= - Potential instance or list of instances in which the orbit \n                 was integrated\n\n           d1= - plot Ez vs d1: e.g., 't', 'z', 'R', 'vR', 'vT', 'vz'      \n\n           normed= if set, plot E(t)/E(0) rather than E(t)\n\n           ro= (Object-wide default) physical scale for distances to use to convert (can be Quantity)\n\n           vo= (Object-wide default) physical scale for velocities to use to convert (can be Quantity)\n\n           use_physical= use to override Object-wide default for using a physical scale for output\n\n           +bovy_plot.bovy_plot inputs\n\n        OUTPUT:\n\n           figure to output device\n\n        HISTORY:\n\n           2011-10-10 - Written - Bovy (IAS)\n\n        \"\"\"\n", "input": "", "output": "        if not kwargs.get('pot',None) is None: kwargs['pot']= flatten_potential(kwargs.get('pot'))\n        return self._orb.plotJacobi(*args,**kwargs)", "category": "Python"}, {"instruction": "def get_features(self, jid):\n        \"\"\"\n        Return the features supported by a service.\n\n        :param jid: Address of the PubSub service to query.\n        :type jid: :class:`aioxmpp.JID`\n        :return: Set of supported features\n        :rtype: set containing :class:`~.pubsub.xso.Feature` enumeration\n                members.\n\n        This simply uses service discovery to obtain the set of features and\n        converts the features to :class:`~.pubsub.xso.Feature` enumeration\n        members. To get the full feature information, resort to using\n        :meth:`.DiscoClient.query_info` directly on `jid`.\n\n        Features returned by the peer which are not valid pubsub features are\n        not returned.\n        \"\"\"\n", "input": "", "output": "\n        response = yield from self._disco.query_info(jid)\n        result = set()\n        for feature in response.features:\n            try:\n                result.add(pubsub_xso.Feature(feature))\n            except ValueError:\n                continue\n        return result", "category": "Python"}, {"instruction": "def _notebook(trigger, note_store):\n        \"\"\"\n        :param trigger:\u00a0trigger object\n        :param note_store: note_store object\n        :return: note object\n        \"\"\"\n", "input": "", "output": "        note = Types.Note()\n        if trigger.notebook:\n            # get the notebookGUID ...\n            notebook_id = EvernoteMgr.get_notebook(note_store, trigger.notebook)\n            # create notebookGUID if it does not exist then return its id\n            note.notebookGuid = EvernoteMgr.set_notebook(note_store, trigger.notebook, notebook_id)\n\n            if trigger.tag:\n                # ... and get the tagGUID if a tag has been provided\n                tag_id = EvernoteMgr.get_tag(note_store, trigger.tag)\n                if tag_id is False:\n                    tag_id = EvernoteMgr.set_tag(note_store, trigger.tag, tag_id)\n                    # set the tag to the note if a tag has been provided\n                    if tag_id:\n                        note.tagGuids = tag_id\n\n            logger.debug(\"notebook that will be used %s\", trigger.notebook)\n        return note", "category": "Python"}, {"instruction": "def get_credentials():\n    \"\"\"Gets valid user credentials from storage.\n\n    If nothing has been stored, or if the stored credentials are invalid,\n    the OAuth2 flow is completed to obtain the new credentials.\n\n    Returns:\n        Credentials, the obtained credential.\n    \"\"\"\n", "input": "", "output": "    home_dir = os.path.expanduser('~')\n    credential_dir = os.path.join(home_dir, '.credentials')\n    if not os.path.exists(credential_dir):\n        os.makedirs(credential_dir)\n    credential_path = os.path.join(credential_dir,\n                                   'calendar-python-quickstart.json')\n\n    store = Storage(credential_path)\n    credentials = store.get()\n    if not credentials or credentials.invalid:\n        flow = client.flow_from_clientsecrets(CLIENT_SECRET_FILE, SCOPES)\n        flow.user_agent = APPLICATION_NAME\n        if flags:\n            credentials = tools.run_flow(flow, store, flags)\n        else: # Needed only for compatibility with Python 2.6\n            credentials = tools.run(flow, store)\n        print('Storing credentials to ' + credential_path)\n    return credentials", "category": "Python"}, {"instruction": "def chi_squared(source_frequency, target_frequency):\n    \"\"\"Calculate the Chi Squared statistic by comparing ``source_frequency`` with ``target_frequency``.\n\n    Example:\n        >>> chi_squared({'a': 2, 'b': 3}, {'a': 1, 'b': 2})\n        0.1\n\n    Args:\n        source_frequency (dict): Frequency map of the text you are analyzing\n        target_frequency (dict): Frequency map of the target language to compare with\n\n    Returns:\n        Decimal value of the chi-squared statistic\n    \"\"\"\n", "input": "", "output": "    # Ignore any symbols from source that are not in target.\n    # TODO: raise Error if source_len is 0?\n    target_prob = frequency_to_probability(target_frequency)\n    source_len = sum(v for k, v in source_frequency.items() if k in target_frequency)\n\n    result = 0\n    for symbol, prob in target_prob.items():\n        symbol_frequency = source_frequency.get(symbol, 0)  # Frequecy is 0 if it doesnt appear in source\n        result += _calculate_chi_squared(symbol_frequency, prob, source_len)\n\n    return result", "category": "Python"}, {"instruction": "def checkout(self, revision_id):\n        \"\"\"\n        :param revision_id: :class:`revision.data.Revision` ID.\n        :type revision_id: str\n        \"\"\"\n", "input": "", "output": "        index = 0\n        found = False\n        for revision in self.revisions:\n            if revision.revision_id == revision_id:\n                self.current_index = index\n                found = True\n\n            index += 1\n\n        if not found:\n            raise RuntimeError(\"\")", "category": "Python"}, {"instruction": "def populate_all_metadata():\n    \"\"\" Create metadata instances for all models in seo_models if empty.\n        Once you have created a single metadata instance, this will not run.\n        This is because it is a potentially slow operation that need only be\n        done once. If you want to ensure that everything is populated, run the\n        populate_metadata management command.\n    \"\"\"\n", "input": "", "output": "    for Metadata in registry.values():\n        InstanceMetadata = Metadata._meta.get_model('modelinstance')\n        if InstanceMetadata is not None:\n            for model in Metadata._meta.seo_models:\n                populate_metadata(model, InstanceMetadata)", "category": "Python"}, {"instruction": "def bipartition(seq):\n    \"\"\"Return a list of bipartitions for a sequence.\n\n    Args:\n        a (Iterable): The sequence to partition.\n\n    Returns:\n        list[tuple[tuple]]: A list of tuples containing each of the two\n        partitions.\n\n    Example:\n        >>> bipartition((1,2,3))\n        [((), (1, 2, 3)), ((1,), (2, 3)), ((2,), (1, 3)), ((1, 2), (3,))]\n    \"\"\"\n", "input": "", "output": "    return [(tuple(seq[i] for i in part0_idx),\n             tuple(seq[j] for j in part1_idx))\n            for part0_idx, part1_idx in bipartition_indices(len(seq))]", "category": "Python"}, {"instruction": "def on_event(self, evt, is_final):\n        \"\"\" this is invoked from in response to COM PumpWaitingMessages - different thread \"\"\"\n", "input": "", "output": "        for msg in XmlHelper.message_iter(evt):\n            for node, error in XmlHelper.security_iter(msg.GetElement('securityData')):\n                if error:\n                    self.security_errors.append(error)\n                else:\n                    self.on_security_node(node)\n\n        if is_final and self.response_type == 'frame':\n            index = self.response.pop('security')\n            frame = DataFrame(self.response, columns=self.fields, index=index)\n            frame.index.name = 'security'\n            self.response = frame", "category": "Python"}, {"instruction": "def with_router(func):\n    \"\"\"\n    Decorator version of :func:`run_with_router`. Example:\n\n    .. code-block:: python\n\n        @with_router\n        def do_stuff(router, arg):\n            pass\n\n        do_stuff(blah, 123)\n    \"\"\"\n", "input": "", "output": "    def wrapper(*args, **kwargs):\n        return run_with_router(func, *args, **kwargs)\n    if mitogen.core.PY3:\n        wrapper.func_name = func.__name__\n    else:\n        wrapper.func_name = func.func_name\n    return wrapper", "category": "Python"}, {"instruction": "def _after_handler(self, iid, callback, args):\n        \"\"\"Proxy to called by after() in mainloop\"\"\"\n", "input": "", "output": "        self._after_id = None\n        self.update_state(iid, \"normal\")\n        self.call_callbacks(iid, callback, args)", "category": "Python"}, {"instruction": "def iscsi_iqn():\n    '''\n    Return iSCSI IQN\n    '''\n", "input": "", "output": "    grains = {}\n    grains['iscsi_iqn'] = False\n    if salt.utils.platform.is_linux():\n        grains['iscsi_iqn'] = _linux_iqn()\n    elif salt.utils.platform.is_windows():\n        grains['iscsi_iqn'] = _windows_iqn()\n    elif salt.utils.platform.is_aix():\n        grains['iscsi_iqn'] = _aix_iqn()\n    return grains", "category": "Python"}, {"instruction": "def service(cls):\n    '''\n    Marks the decorated class as a singleton ``service``.\n\n    Injects following classmethods:\n\n        .. py:method:: .get(context)\n\n            Returns a singleton instance of the class for given ``context``\n\n            :param context: context to look in\n            :type context: :class:`Context`\n            :returns: ``cls``\n    '''\n", "input": "", "output": "\n    if not cls:\n        return None\n\n    # Inject methods\n    def get(cls, context):\n        return context.get_service(cls)\n    cls.get = get.__get__(cls)\n\n    log.debug('Registering [%s] (service)', get_fqdn(cls))\n\n    return cls", "category": "Python"}, {"instruction": "def _colored_time(self, time_taken, color=None):\n        \"\"\"Get formatted and colored string for a given time taken.\"\"\"\n", "input": "", "output": "        if self.timer_no_color:\n            return \"{0:0.4f}s\".format(time_taken)\n\n        return _colorize(\"{0:0.4f}s\".format(time_taken), color)", "category": "Python"}, {"instruction": "def get_argv_for_command(self):\n        \"\"\"\n        Returns stripped arguments that would be passed into the command.\n        \"\"\"\n", "input": "", "output": "        argv = [a for a in self.argv]\n        argv.insert(0, self.prog_name)\n        return argv", "category": "Python"}, {"instruction": "def search_registered_query_for_facets(self, **kwargs):  # noqa: E501\n        \"\"\"Lists the values of one or more facets over the customer's non-deleted derived metric definition  # noqa: E501\n\n          # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.search_registered_query_for_facets(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param FacetsSearchRequestContainer body:\n        :return: ResponseContainerFacetsResponseContainer\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n", "input": "", "output": "        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async_req'):\n            return self.search_registered_query_for_facets_with_http_info(**kwargs)  # noqa: E501\n        else:\n            (data) = self.search_registered_query_for_facets_with_http_info(**kwargs)  # noqa: E501\n            return data", "category": "Python"}, {"instruction": "def process(self):\n        \"\"\"Process current event.\"\"\"\n", "input": "", "output": "        try:\n            self.receiver(self)\n        # TODO RESTException\n        except Exception as e:\n            current_app.logger.exception('Could not process event.')\n            self.response_code = 500\n            self.response = dict(status=500, message=str(e))\n        return self", "category": "Python"}, {"instruction": "def select(table, index_track, field_name, op, value, includeMissing):\n    '''Modifies the table and index_track lists based on the comparison.\n    '''\n", "input": "", "output": "    result = []\n    result_index = []\n    counter = 0\n    for row in table:\n        if detect_fields(field_name, convert_to_dict(row)):\n            final_value = get_value(row, field_name)\n            if do_op(final_value, op, value):\n                result.append(row)\n                result_index.append(index_track[counter])\n        else:\n            if includeMissing:\n                result.append(row)\n                result_index.append(index_track[counter])\n        counter += 1\n    #table = result\n    #index_track = result_index\n    return (result, result_index)", "category": "Python"}, {"instruction": "def _get_from_riak(self, key):\n        \"\"\"\n        Args:\n            key (str): riak key\n        Returns:\n            (tuple): riak obj json data and riak key\n        \"\"\"\n", "input": "", "output": "\n        obj = self.bucket.get(key)\n\n        if obj.exists:\n            return obj.data, obj.key\n\n        raise ObjectDoesNotExist(\"%s %s\" % (key, self.compiled_query))", "category": "Python"}, {"instruction": "def ComputeRoot(hashes):\n        \"\"\"\n        Compute the root hash.\n\n        Args:\n            hashes (list): the list of hashes to build the root from.\n\n        Returns:\n            bytes: the root hash.\n        \"\"\"\n", "input": "", "output": "        if not len(hashes):\n            raise Exception('Hashes must have length')\n        if len(hashes) == 1:\n            return hashes[0]\n\n        tree = MerkleTree(hashes)\n        return tree.Root.Hash", "category": "Python"}, {"instruction": "def string_width(word: str) -> int:\n    \"\"\"\n    :param word:\n    :return: Widths of word\n\n    Usage:\n\n        >>> string_width('abc')\n        3\n        >>> string_width('\uff21b\u3057\u30fc')\n        7\n        >>> string_width('')\n        0\n    \"\"\"\n", "input": "", "output": "    return sum(map(lambda x: 2 if east_asian_width(x) in 'FWA' else 1, word))", "category": "Python"}, {"instruction": "def translate_sites(self, indices, vector, frac_coords=True,\n                        to_unit_cell=True):\n        \"\"\"\n        Translate specific sites by some vector, keeping the sites within the\n        unit cell.\n\n        Args:\n            indices: Integer or List of site indices on which to perform the\n                translation.\n            vector: Translation vector for sites.\n            frac_coords (bool): Whether the vector corresponds to fractional or\n                cartesian coordinates.\n            to_unit_cell (bool): Whether new sites are transformed to unit\n                cell\n        \"\"\"\n", "input": "", "output": "        if not isinstance(indices, collections.abc.Iterable):\n            indices = [indices]\n\n        for i in indices:\n            site = self._sites[i]\n            if frac_coords:\n                fcoords = site.frac_coords + vector\n            else:\n                fcoords = self._lattice.get_fractional_coords(\n                    site.coords + vector)\n            if to_unit_cell:\n                fcoords = np.mod(fcoords, 1)\n            self._sites[i].frac_coords = fcoords", "category": "Python"}, {"instruction": "def _error(self, x):\n        \"\"\"Error function.\n        Once self.y_desired has been defined, compute the error\n        of input x using the forward model.\n        \"\"\"\n", "input": "", "output": "        y_pred = self.fmodel.predict_y(x)\n        err_v  = y_pred - self.goal\n        error = sum(e*e for e in err_v)\n        return error", "category": "Python"}, {"instruction": "def find_class_files(self):\n        \"\"\"Find compiled class files recursively in the root path\n\n        :return: list of absolute file paths\n        \"\"\"\n", "input": "", "output": "        files = self._find_files()\n        self.announce(\n            \"found '{}' compiled class files in '{}'\".format(\n                len(files), self.root\n            )\n        )\n        return files", "category": "Python"}, {"instruction": "def compile(self, expr, params=None, limit=None):\n        \"\"\"\n        Translate expression to one or more queries according to backend target\n\n        Returns\n        -------\n        output : single query or list of queries\n        \"\"\"\n", "input": "", "output": "        query_ast = self._build_ast_ensure_limit(expr, limit, params=params)\n        return query_ast.compile()", "category": "Python"}, {"instruction": "def setcreated(self, dt=None):\n        \"\"\"\n        Set I{created}.\n        @param dt: The created date & time.\n            Set as datetime.utc() when I{None}.\n        @type dt: L{datetime}\n        \"\"\"\n", "input": "", "output": "        if dt is None:\n            self.created = Token.utc()\n        else:\n            self.created = dt", "category": "Python"}, {"instruction": "def getResponse(self, http_request, request):\n        \"\"\"\n        Processes the AMF request, returning an AMF response.\n\n        @param http_request: The underlying HTTP Request.\n        @type http_request: U{HTTPRequest<http://docs.djangoproject.com\n            /en/dev/ref/request-response/#httprequest-objects>}\n        @param request: The AMF Request.\n        @type request: L{Envelope<pyamf.remoting.Envelope>}\n        @rtype: L{Envelope<pyamf.remoting.Envelope>}\n        \"\"\"\n", "input": "", "output": "        response = remoting.Envelope(request.amfVersion)\n\n        for name, message in request:\n            http_request.amf_request = message\n\n            processor = self.getProcessor(message)\n            response[name] = processor(message, http_request=http_request)\n\n        return response", "category": "Python"}, {"instruction": "def get_group(self):\n        \"\"\"Get the group of the Dataset.\n\n        Returns\n        -------\n        group : numpy array or None\n            Group size of each group.\n        \"\"\"\n", "input": "", "output": "        if self.group is None:\n            self.group = self.get_field('group')\n            if self.group is not None:\n                # group data from LightGBM is boundaries data, need to convert to group size\n                self.group = np.diff(self.group)\n        return self.group", "category": "Python"}, {"instruction": "def get_rows( self, key ):\n        \"\"\"Get the set of rows for the type-key\"\"\"\n", "input": "", "output": "        if key not in self.roots:\n            self.get_root( key )\n        if key == 'location':\n            return self.location_rows \n        else:\n            return self.rows", "category": "Python"}, {"instruction": "def followers(self):\n        \"\"\" :class:`Feed <pypump.models.feed.Feed>` with all\n        :class:`Person <pypump.models.person.Person>` objects following the person.\n\n        Example:\n            >>> alice = pump.Person('alice@example.org')\n            >>> for follower in alice.followers[:2]:\n            ...     print(follower.id)\n            ...\n            acct:bob@example.org\n            acct:carol@example.org\n        \"\"\"\n", "input": "", "output": "        if self._followers is None:\n            self._followers = Followers(self.links['followers'], pypump=self._pump)\n        return self._followers", "category": "Python"}, {"instruction": "def get_attributes(self):\n        \"\"\"\n        Used by the uni_form_tags to get helper attributes\n        \"\"\"\n", "input": "", "output": "        items = {}\n        items['form_method'] = self.form_method.strip()\n        items['form_tag'] = self.form_tag\n        items['form_style'] = self.form_style.strip()\n        \n        if self.form_action:\n            items['form_action'] = self.form_action.strip()\n        if self.form_id:\n            items['id'] = self.form_id.strip()\n        if self.form_class:\n            items['class'] = self.form_class.strip()\n        if self.inputs:\n            items['inputs'] = self.inputs\n        if self.form_error_title:\n            items['form_error_title'] = self.form_error_title.strip()\n        if self.formset_error_title:\n            items['formset_error_title'] = self.formset_error_title.strip()\n        return items", "category": "Python"}, {"instruction": "def parse_args():\n  \"\"\"Parses command line arguments.\"\"\"\n", "input": "", "output": "  parser = ArgumentParser(description=\"ModelBase builder\")\n  subparsers = parser.add_subparsers()\n\n  sql_parser = subparsers.add_parser(\n    \"get-query\",\n    description=\"Usage: e.g. psql -c \\\"copy ($(python3 lib/generate_models.py get-query)) to \" +\n                \"stdout with csv header\\\" DB_NAME postgres\")\n  sql_parser.set_defaults(func=print_sql_query)\n\n  gen_parser = subparsers.add_parser(\"generate\")\n  gen_parser.add_argument(\"filename\", nargs=\"?\", help=\"Read this file for input, or STDIN if not \" \\\n                                                      \"given\")\n  gen_parser.add_argument(\"-i\", \"--indent\", default=\"  \")\n  gen_parser.add_argument(\"-c\", \"--created-at-col-name\", default=\"created_at\")\n  gen_parser.add_argument(\"-u\", \"--updated-at-col-name\", default=\"updated_at\")\n  gen_parser.set_defaults(func=generate_models)\n\n  args = parser.parse_args()\n\n  if hasattr(args, \"func\"):\n    return args\n  else:\n    arg_parser.print_help()\n    sys.exit(1)", "category": "Python"}, {"instruction": "def add_lock(packages, root=None, **kwargs):  # pylint: disable=unused-argument\n    '''\n    Add a package lock. Specify packages to lock by exact name.\n\n    root\n        operate on a different root directory.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.add_lock <package name>\n        salt '*' pkg.add_lock <package1>,<package2>,<package3>\n        salt '*' pkg.add_lock pkgs='[\"foo\", \"bar\"]'\n    '''\n", "input": "", "output": "    salt.utils.versions.warn_until('Sodium', 'This function is deprecated. Please use hold() instead.')\n    locks = list_locks(root)\n    added = []\n    try:\n        packages = list(__salt__['pkg_resource.parse_targets'](packages)[0].keys())\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n\n    for pkg in packages:\n        if not locks.get(pkg):\n            added.append(pkg)\n\n    if added:\n        __zypper__(root=root).call('al', *added)\n\n    return {'added': len(added), 'packages': added}", "category": "Python"}, {"instruction": "def db_for_write(self, model, **hints):\n        \"\"\"\n        Prevent write actions on read-only tables.\n\n        Raises:\n            WriteNotSupportedError: If models.sf_access is ``read_only``.\n\n        \"\"\"\n", "input": "", "output": "        try:\n            if model.sf_access == READ_ONLY:\n                raise WriteNotSupportedError(\"%r is a read-only model.\" % model)\n        except AttributeError:\n            pass\n        return None", "category": "Python"}, {"instruction": "def add_bits_to_path(path_, filename_prefix=None, extension=None):\r\n    \"\"\"\r\n    Adds prefix/suffix to filename\r\n\r\n    Arguments:\r\n        path_ -- path to file\r\n        filename_prefix -- prefix to be added to file name\r\n        extension -- extension to be added to file name. The dot is automatically added, such as\r\n            \"ext\" and \".ext\" will have the same effect\r\n\r\n    Examples:\r\n        > add_bits_to_path(\"/home/user/file\", \"prefix-\")\r\n        /home/user/prefix-file\r\n\r\n        > add_bits_to_path(\"/home/user/file\", None, \".ext\")\r\n        /home/user/file.ext\r\n\r\n        > add_bits_to_path(\"/home/user/file\", None, \"ext\")  # dot in extension is optional\r\n        /home/user/file.ext\r\n\r\n        > add_bits_to_path(\"/home/user/\", None, \".ext\")\r\n        /home/user/.ext\r\n    \"\"\"\n", "input": "", "output": "\r\n    dir_, basename = os.path.split(path_)\r\n\r\n    if filename_prefix:\r\n        basename = filename_prefix+basename\r\n    if extension:\r\n        if not extension.startswith(\".\"):\r\n            extension = \".\"+extension\r\n        basename = basename+extension\r\n\r\n    return os.path.join(dir_, basename)", "category": "Python"}, {"instruction": "def unwrap(self, message, signature):\n        \"\"\"\n        NTLM GSSUnwrap()\n        :param message: The message to be decrypted\n        :return: The decrypted message\n        \"\"\"\n", "input": "", "output": "        plain_text = _Ntlm2Session.decrypt(self, message)\n        _Ntlm2Session.verify(self, plain_text, signature)\n        return plain_text", "category": "Python"}, {"instruction": "def delete_nic(access_token, subscription_id, resource_group, nic_name):\n    '''Delete a network interface.\n\n    Args:\n        access_token (str): A valid Azure authentication token.\n        subscription_id (str): Azure subscription id.\n        resource_group (str): Azure resource group name.\n        nic_name (str): Name of the NIC.\n\n    Returns:\n        HTTP response.\n    '''\n", "input": "", "output": "    endpoint = ''.join([get_rm_endpoint(),\n                        '/subscriptions/', subscription_id,\n                        '/resourceGroups/', resource_group,\n                        '/providers/Microsoft.Network/networkInterfaces/', nic_name,\n                        '?api-version=', NETWORK_API])\n    return do_delete(endpoint, access_token)", "category": "Python"}, {"instruction": "def kunc_v(p, v0, k0, k0p, order=5, min_strain=0.01):\n    \"\"\"\n    find volume at given pressure using brenth in scipy.optimize\n\n    :param p: pressure in GPa\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param k0: bulk modulus at reference conditions\n    :param k0p: pressure derivative of bulk modulus at reference conditions\n    :param order: order of Kunc function\n    :param min_strain: defining minimum v/v0 value to search volume for\n    :return: unit-cell volume at high pressure in GPa\n    :note: a wrapper function vectorizing kunc_v_single\n    \"\"\"\n", "input": "", "output": "    if isuncertainties([p, v0, k0, k0p]):\n        f_u = np.vectorize(uct.wrap(kunc_v_single), excluded=[1, 2, 3, 4, 5])\n        return f_u(p, v0, k0, k0p, order=order, min_strain=min_strain)\n    else:\n        f_v = np.vectorize(kunc_v_single, excluded=[1, 2, 3, 4, 5])\n        return f_v(p, v0, k0, k0p, order=order, min_strain=min_strain)", "category": "Python"}, {"instruction": "def send(self, data, **kws):\r\n        \"\"\"Send data to the socket. The socket must be connected to a remote\r\n        socket. Ammount sent may be less than the data provided.\"\"\"\n", "input": "", "output": "        return yield_(Send(self, data, timeout=self._timeout, **kws))", "category": "Python"}, {"instruction": "def SetSchema(self, reader):\n        \"\"\"Use XSD Schema to validate the document as it is processed.\n          Activation is only possible before the first Read(). if\n          @schema is None, then Schema validation is desactivated. @\n          The @schema should not be freed until the reader is\n           deallocated or its use has been deactivated. \"\"\"\n", "input": "", "output": "        if reader is None: reader__o = None\n        else: reader__o = reader._o\n        ret = libxml2mod.xmlTextReaderSetSchema(reader__o, self._o)\n        return ret", "category": "Python"}, {"instruction": "def connect(self):\n        \"\"\"\n        Connects to Redis\n        \"\"\"\n", "input": "", "output": "        logger.info(\"Connecting to Redis on {host}:{port}...\".format(\n            host=self.host, port=self.port))\n\n        super(RedisSubscriber, self).connect()\n        logger.info(\"Successfully connected to Redis\")\n\n        # Subscribe to channel\n        self.pubsub = self.client.pubsub()\n        self.pubsub.subscribe(self.channel)\n\n        logger.info(\"Subscribed to [{channel}] Redis channel\".format(\n            channel=self.channel))\n\n        # Start listening\n        t = Thread(target=self.listen)\n        t.setDaemon(True)\n        t.start()", "category": "Python"}, {"instruction": "def copy_dataset_files(self, ds, incver=False, cb=None, **kwargs):\n        \"\"\"\n        Copy only files and configs into the database.\n        :param ds: The source dataset to copy\n        :param cb: A progress callback, taking two parameters: cb(message, num_records)\n        :return:\n        \"\"\"\n", "input": "", "output": "        from ambry.orm import File\n\n        tables = [File]\n\n        return self._copy_dataset_copy(ds, tables, incver, cb, **kwargs)", "category": "Python"}, {"instruction": "def get_foreign_keys_in_altered_table(self, diff):\n        \"\"\"\n        :param diff: The table diff\n        :type diff: eloquent.dbal.table_diff.TableDiff\n\n        :rtype: list\n        \"\"\"\n", "input": "", "output": "        foreign_keys = diff.from_table.get_foreign_keys()\n        column_names = self.get_column_names_in_altered_table(diff)\n\n        for key, constraint in foreign_keys.items():\n            changed = False\n            local_columns = []\n            for column_name in constraint.get_local_columns():\n                normalized_column_name = column_name.lower()\n                if normalized_column_name not in column_names:\n                    del foreign_keys[key]\n                    break\n                else:\n                    local_columns.append(column_names[normalized_column_name])\n                    if column_name != column_names[normalized_column_name]:\n                        changed = True\n\n            if changed:\n                pass\n\n        return foreign_keys", "category": "Python"}, {"instruction": "def start(self, reloading=False):\n        \"\"\"Called when the module is loaded.\n\n        If the load is due to a reload of the module, then the 'reloading'\n        argument will be set to True. By default, this method calls the\n        controller's listen() for each event in the self.event_handlers dict.\n        \"\"\"\n", "input": "", "output": "        for event in self.event_handlers:\n            self.controller.listen(event)", "category": "Python"}, {"instruction": "def search(**criteria):\n    \"\"\"\n    Search registered *component* classes matching the given criteria.\n\n    :param criteria: search criteria of the form: ``a='1', b='x'``\n    :return: parts registered with the given criteria\n    :rtype: :class:`set`\n\n    Will return an empty :class:`set` if nothing is found.\n\n    ::\n\n        from cqparts.search import search\n        import cqparts_motors  # example of a 3rd party lib\n\n        # Get all DC motor classes\n        dc_motors = search(type='motor', current_class='dc')\n\n        # For more complex queries:\n        air_cooled = search(cooling='air')\n        non_aircooled_dcmotors = dc_motors - air_cooled\n        # will be all DC motors that aren't air-cooled\n    \"\"\"\n", "input": "", "output": "    # Find all parts that match the given criteria\n    results = copy(class_list)  # start with full list\n    for (category, value) in criteria.items():\n        results &= index[category][value]\n\n    return results", "category": "Python"}, {"instruction": "def uf(sigla):\n    \"\"\"\n    Valida a sigla da Unidade Federativa. Se n\u00e3o for uma sigla de UF v\u00e1lida,\n    ser\u00e1 lan\u00e7ada a exce\u00e7\u00e3o :exc:`UnidadeFederativaError`.\n    \"\"\"\n", "input": "", "output": "    if not sigla in [s for s, i, n, r in UNIDADES_FEDERACAO]:\n        raise UnidadeFederativaError('Estado (sigla) UF \"%s\" '\n                'inexistente' % sigla)", "category": "Python"}, {"instruction": "def match_repository_configuration(url, page_size=10, page_index=0, sort=\"\"):\n    \"\"\"\n    Search for Repository Configurations based on internal or external url with exact match\n    \"\"\"\n", "input": "", "output": "    content = match_repository_configuration_raw(url, page_size, page_index, sort)\n    if content:\n        return utils.format_json_list(content)", "category": "Python"}, {"instruction": "def is_cnpjcpf(numero, estrito=False):\n    \"\"\"Uma vers\u00e3o conveniente para usar em testes condicionais. Apenas retorna\n    verdadeiro ou falso, conforme o argumento \u00e9 validado.\n\n    :param bool estrito: Padr\u00e3o ``False``, indica se apenas os d\u00edgitos do\n        n\u00famero dever\u00e3o ser considerados. Se verdadeiro, potenciais caracteres\n        que formam a m\u00e1scara ser\u00e3o removidos antes da valida\u00e7\u00e3o ser realizada.\n\n    \"\"\"\n", "input": "", "output": "    _numero = digitos(numero) if not estrito else numero\n    try:\n        cnpj(_numero)\n        return True\n    except NumeroCNPJError:\n        try:\n            cpf(_numero)\n            return True\n        except NumeroCPFError:\n            pass\n    return False", "category": "Python"}, {"instruction": "async def try_trigger_before_first_request_functions(self) -> None:\n        \"\"\"Trigger the before first request methods.\"\"\"\n", "input": "", "output": "        if self._got_first_request:\n            return\n\n        # Reverse the teardown functions, so as to match the expected usage\n        self.teardown_appcontext_funcs = list(reversed(self.teardown_appcontext_funcs))\n        for key, value in self.teardown_request_funcs.items():\n            self.teardown_request_funcs[key] = list(reversed(value))\n        for key, value in self.teardown_websocket_funcs.items():\n            self.teardown_websocket_funcs[key] = list(reversed(value))\n\n        async with self._first_request_lock:\n            if self._got_first_request:\n                return\n            for function in self.before_first_request_funcs:\n                await function()\n            self._got_first_request = True", "category": "Python"}, {"instruction": "def recherche(self, pattern, entete):\n        \"\"\"Performs a search field by field, using functions defined in formats.\n        Matchs are marked with info[`font`]\n\n        :param pattern: String to look for\n        :param entete: Fields to look into\n        :return: Nothing. The collection is changed in place\n        \"\"\"\n", "input": "", "output": "\n        new_liste = []\n        sub_patterns = pattern.split(\" \")\n        for p in self:\n            d_font = {att: False for att in entete}\n            row_valid = True\n            for sub_pattern in sub_patterns:\n                found = False\n                for att in entete:\n                    fonction_recherche = formats.ASSOCIATION[att][1]\n                    attr_found = bool(fonction_recherche(p[att], sub_pattern))\n                    if attr_found:\n                        found = True\n                        d_font[att] = True\n                if not found:\n                    row_valid = False\n                    break\n            if row_valid:\n                new_liste.append(p)\n                info = dict(self.get_info(Id=p.Id),font=d_font)\n                self.infos[p.Id] = info\n\n        list.__init__(self, new_liste)", "category": "Python"}, {"instruction": "def decode_feedback(binary_tuples):\n  \"\"\" Returns a list of tuples in (datetime, token_str) format \n  \n        binary_tuples   the binary-encoded feedback tuples\n  \"\"\"\n", "input": "", "output": "  \n  fmt = '!lh32s'\n  size = struct.calcsize(fmt)\n  with StringIO(binary_tuples) as f:\n    return [(datetime.datetime.fromtimestamp(ts), binascii.hexlify(tok))\n            for ts, toklen, tok in (struct.unpack(fmt, tup) \n                              for tup in iter(lambda: f.read(size), ''))]", "category": "Python"}, {"instruction": "def qos_rcv_queue_multicast_threshold_traffic_class6(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n", "input": "", "output": "        config = ET.Element(\"config\")\n        qos = ET.SubElement(config, \"qos\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")\n        rcv_queue = ET.SubElement(qos, \"rcv-queue\")\n        multicast = ET.SubElement(rcv_queue, \"multicast\")\n        threshold = ET.SubElement(multicast, \"threshold\")\n        traffic_class6 = ET.SubElement(threshold, \"traffic-class6\")\n        traffic_class6.text = kwargs.pop('traffic_class6')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "category": "Python"}, {"instruction": "def _create_table(self, table_name):\n        ''' create sqlite's table for storing simple dictionaries\n        '''\n", "input": "", "output": "        if self.fieldnames:\n            sql_fields = []\n            for field in self._fields:\n                if field != '_id':\n                    if 'dblite' in self._fields[field]:\n                        sql_fields.append(' '.join([field, self._fields[field]['dblite']]))\n                    else:\n                        sql_fields.append(field)\n            sql_fields = ','.join(sql_fields)\n            SQL = 'CREATE TABLE IF NOT EXISTS %s (%s);' % (table_name, sql_fields)\n            try:\n                self._cursor.execute(SQL)\n            except sqlite3.OperationalError, err:\n                raise RuntimeError('Create table error, %s, SQL: %s' % (err, SQL))", "category": "Python"}, {"instruction": "def dir_tails(self, rr_id: str) -> str:\n        \"\"\"\n        Return path to the correct directory for the tails file on input revocation registry identifier.\n\n        :param rr_id: revocation registry identifier of interest\n        :return: path to tails dir for input revocation registry identifier\n        \"\"\"\n", "input": "", "output": "\n        return Tails.dir(self._dir_tails, rr_id)", "category": "Python"}, {"instruction": "def _get_content_type_queryset(models_list):\n    \"\"\" Get list of services content types \"\"\"\n", "input": "", "output": "    content_type_ids = {c.id for c in ContentType.objects.get_for_models(*models_list).values()}\n    return ContentType.objects.filter(id__in=content_type_ids)", "category": "Python"}, {"instruction": "def _prepare_sample_data(self, submission_type):\n    \"\"\"Prepares sample data for the submission.\n\n    Args:\n      submission_type: type of the submission.\n    \"\"\"\n", "input": "", "output": "    # write images\n    images = np.random.randint(0, 256,\n                               size=[BATCH_SIZE, 299, 299, 3], dtype=np.uint8)\n    for i in range(BATCH_SIZE):\n      Image.fromarray(images[i, :, :, :]).save(\n          os.path.join(self._sample_input_dir, IMAGE_NAME_PATTERN.format(i)))\n    # write target class for targeted attacks\n    if submission_type == 'targeted_attack':\n      target_classes = np.random.randint(1, 1001, size=[BATCH_SIZE])\n      target_class_filename = os.path.join(self._sample_input_dir,\n                                           'target_class.csv')\n      with open(target_class_filename, 'w') as f:\n        for i in range(BATCH_SIZE):\n          f.write((IMAGE_NAME_PATTERN + ',{1}\\n').format(i, target_classes[i]))", "category": "Python"}, {"instruction": "def raw_repr(obj):\n    '''Produce a representation using the default repr() regardless of\n    whether the object provides an implementation of its own.'''\n", "input": "", "output": "    if isproxy(obj):\n        return '<%s with prime_id=%d>' % (obj.__class__.__name__, obj.prime_id)\n    else:\n        return repr(obj)", "category": "Python"}, {"instruction": "def sleep_if_necessary(cls, user, token, endpoint='search', msg=''):\n        \"\"\"Sleep a little if hit github recently to honor rate limit.\n        \"\"\"\n", "input": "", "output": "        my_kw = {'auth': (user, token)} if user else {}\n        info = requests.get('https://api.github.com/rate_limit', **my_kw)\n        info_dict = info.json()\n        remaining = info_dict['resources'][endpoint]['remaining']\n        logging.debug('Search remaining on github is at %s', remaining)\n\n        if remaining <= 5:\n            sleep_time = 120\n        else:\n            sleep_time = 0\n        if sleep_time:\n            logging.warning('Sleep %i since github requests remaining  = %i%s',\n                            sleep_time, remaining, msg)\n            time.sleep(sleep_time)\n            return True\n\n        return False", "category": "Python"}, {"instruction": "def apply_to_segmentlist(self, seglist):\n\t\t\"\"\"\n\t\tApply our low and high windows to the segments in a\n\t\tsegmentlist.\n\t\t\"\"\"\n", "input": "", "output": "\t\tfor i, seg in enumerate(seglist):\n\t\t\tseglist[i] = seg.__class__(seg[0] - self.low_window, seg[1] + self.high_window)", "category": "Python"}, {"instruction": "def receive_ping(self, ping: Ping):\n        \"\"\" Handle a Ping message by answering with a Pong. \"\"\"\n", "input": "", "output": "\n        self.log_healthcheck.debug(\n            'Ping received',\n            message_id=ping.nonce,\n            message=ping,\n            sender=pex(ping.sender),\n        )\n\n        pong = Pong(nonce=ping.nonce)\n        self.raiden.sign(pong)\n\n        try:\n            self.maybe_send(ping.sender, pong)\n        except (InvalidAddress, UnknownAddress) as e:\n            self.log.debug(\"Couldn't send the `Delivered` message\", e=e)", "category": "Python"}, {"instruction": "def security_iter(nodearr):\n        \"\"\" provide a security data iterator by returning a tuple of (Element, SecurityError) which are mutually exclusive \"\"\"\n", "input": "", "output": "        assert nodearr.name() == 'securityData' and nodearr.isArray()\n        for i in range(nodearr.numValues()):\n            node = nodearr.getValue(i)\n            err = XmlHelper.get_security_error(node)\n            result = (None, err) if err else (node, None)\n            yield result", "category": "Python"}, {"instruction": "def _get_image_size(self, maxcharno, maxlineno):\n        \"\"\"\n        Get the required image size.\n        \"\"\"\n", "input": "", "output": "        return (self._get_char_x(maxcharno) + self.image_pad,\n                self._get_line_y(maxlineno + 0) + self.image_pad)", "category": "Python"}, {"instruction": "def _subperiod_tick(self, current_interval, intervals):\n        \"\"\"Tick each sub-period, copying group_decisions to subperiod_group_decisions.\"\"\"\n", "input": "", "output": "        self.refresh_from_db()\n        for key, value in self.group_decisions.items():\n            self.subperiod_group_decisions[key] = value\n        self.send('group_decisions', self.subperiod_group_decisions)\n        self.save(update_fields=['subperiod_group_decisions'])", "category": "Python"}, {"instruction": "def get_cloud_masks(self, threshold=None, non_valid_value=False):\n        \"\"\" The binary cloud mask is computed on the fly. Be cautious. The pixels without valid data are assigned\n        non_valid_value.\n\n        :param threshold: A float from [0,1] specifying threshold\n        :type threshold: float\n        :param non_valid_value: Value which will be assigned to pixels without valid data\n        :type non_valid_value: int in range `[-254, 255]`\n        :return: Binary cloud masks of shape `(times, height, width)` and `dtype=numpy.int8`\n        :rtype: numpy.ndarray\n        \"\"\"\n", "input": "", "output": "        self.get_probability_masks()\n\n        cloud_masks = self.cloud_detector.get_mask_from_prob(self.probability_masks, threshold)\n        cloud_masks[~self.valid_data] = non_valid_value\n\n        return cloud_masks", "category": "Python"}, {"instruction": "def isfile(self, version=None, *args, **kwargs):\n        '''\n        Check whether the path exists and is a file\n        '''\n", "input": "", "output": "        version = _process_version(self, version)\n\n        path = self.get_version_path(version)\n        self.authority.fs.isfile(path, *args, **kwargs)", "category": "Python"}, {"instruction": "def timestamp_from_datetime(date_time):\n    \"\"\"Returns POSIX timestamp as float\"\"\"\n", "input": "", "output": "    if date_time.tzinfo is None:\n      return time.mktime((date_time.year, date_time.month, date_time.day, date_time.hour,\n                          date_time.minute, date_time.second,\n                          -1, -1, -1)) + date_time.microsecond / 1e6\n    return (date_time - _EPOCH).total_seconds()", "category": "Python"}, {"instruction": "def iresolve(self, *keys):\n        '''\n        Iterates over resolved instances for given provider keys.\n\n        :param keys: Provider keys\n        :type keys: tuple\n        :return: Iterator of resolved instances\n        :rtype: generator\n        '''\n", "input": "", "output": "        for key in keys:\n            missing = self.get_missing_deps(key)\n            if missing:\n                raise UnresolvableError(\"Missing dependencies for %s: %s\" % (key, missing))\n\n            provider = self._providers.get(key)\n            if not provider:\n                raise UnresolvableError(\"Provider does not exist for %s\" % key)\n\n            yield provider()", "category": "Python"}, {"instruction": "def pitching_stats(start_season, end_season=None, league='all', qual=1, ind=1):\n    \"\"\"\n    Get season-level pitching data from FanGraphs. \n\n    ARGUMENTS:\n    start_season : int : first season you want data for (or the only season if you do not specify an end_season)\n    end_season : int : final season you want data for \n    league : \"all\", \"nl\", or \"al\"\n    qual: minimum number of pitches thrown to be included in the data (integer). Use the string 'y' for fangraphs default.\n    ind : int : =1 if you want individual season-level data, =0 if you want a player's aggreagate data over all seasons in the query\n    \"\"\"\n", "input": "", "output": "    if start_season is None:\n        raise ValueError(\"You need to provide at least one season to collect data for. Try pitching_leaders(season) or pitching_leaders(start_season, end_season).\")\n    if end_season is None:\n        end_season = start_season\n    soup = get_soup(start_season=start_season, end_season=end_season, league=league, qual=qual, ind=ind)\n    table = get_table(soup, ind)\n    return table", "category": "Python"}, {"instruction": "def _api_delete(path, data, server=None):\n    '''\n    Do a DELETE request to the API\n    '''\n", "input": "", "output": "    server = _get_server(server)\n    response = requests.delete(\n            url=_get_url(server['ssl'], server['url'], server['port'], path),\n            auth=_get_auth(server['user'], server['password']),\n            headers=_get_headers(),\n            params=data,\n            verify=False\n    )\n    return _api_response(response)", "category": "Python"}, {"instruction": "def make_temp(string, suffix='', decode=True, delete=True):\n    \"\"\" xmlsec needs files in some cases where only strings exist, hence the\n    need for this function. It creates a temporary file with the\n    string as only content.\n\n    :param string: The information to be placed in the file\n    :param suffix: The temporary file might have to have a specific\n        suffix in certain circumstances.\n    :param decode: The input string might be base64 coded. If so it\n        must, in some cases, be decoded before being placed in the file.\n    :return: 2-tuple with file pointer ( so the calling function can\n        close the file) and filename (which is for instance needed by the\n        xmlsec function).\n    \"\"\"\n", "input": "", "output": "    ntf = NamedTemporaryFile(suffix=suffix, delete=delete)\n    # Python3 tempfile requires byte-like object\n    if not isinstance(string, six.binary_type):\n        string = string.encode('utf-8')\n\n    if decode:\n        ntf.write(base64.b64decode(string))\n    else:\n        ntf.write(string)\n    ntf.seek(0)\n    return ntf, ntf.name", "category": "Python"}, {"instruction": "def _get_device_info(self, device_id):\n        \"\"\"Queries the Spark Cloud for detailed information about a device.\"\"\"\n", "input": "", "output": "        params = {'access_token': self.access_token}\n        r = self.spark_api(device_id).GET(params=params, timeout=30)\n        self._check_error(r)\n        return r.json()", "category": "Python"}, {"instruction": "def __upload(self, resource, bytes):\n        \"\"\"Performs a single chunk upload.\"\"\"\n", "input": "", "output": "\n        # note: string conversion required here due to open encoding bug in requests-oauthlib.\n        headers = {\n            'x-ton-expires': http_time(self.options.get('x-ton-expires', self._DEFAULT_EXPIRE)),\n            'content-length': str(self._file_size),\n            'content-type': self.content_type\n        }\n\n        return Request(self._client, 'post', resource,\n                       domain=self._DEFAULT_DOMAIN, headers=headers, body=bytes).perform()", "category": "Python"}, {"instruction": "def get_stp_brief_info_output_spanning_tree_info_spanning_tree_mode_pvstp_pvstp_port_interface_type(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n", "input": "", "output": "        config = ET.Element(\"config\")\n        get_stp_brief_info = ET.Element(\"get_stp_brief_info\")\n        config = get_stp_brief_info\n        output = ET.SubElement(get_stp_brief_info, \"output\")\n        spanning_tree_info = ET.SubElement(output, \"spanning-tree-info\")\n        spanning_tree_mode = ET.SubElement(spanning_tree_info, \"spanning-tree-mode\")\n        pvstp = ET.SubElement(spanning_tree_mode, \"pvstp\")\n        pvstp = ET.SubElement(pvstp, \"pvstp\")\n        vlan_id_key = ET.SubElement(pvstp, \"vlan-id\")\n        vlan_id_key.text = kwargs.pop('vlan_id')\n        port = ET.SubElement(pvstp, \"port\")\n        interface_type = ET.SubElement(port, \"interface-type\")\n        interface_type.text = kwargs.pop('interface_type')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "category": "Python"}, {"instruction": "def _check_vpcs_version(self):\n        \"\"\"\n        Checks if the VPCS executable version is >= 0.8b or == 0.6.1.\n        \"\"\"\n", "input": "", "output": "        try:\n            output = yield from subprocess_check_output(self._vpcs_path(), \"-v\", cwd=self.working_dir)\n            match = re.search(\"Welcome to Virtual PC Simulator, version ([0-9a-z\\.]+)\", output)\n            if match:\n                version = match.group(1)\n                self._vpcs_version = parse_version(version)\n                if self._vpcs_version < parse_version(\"0.6.1\"):\n                    raise VPCSError(\"VPCS executable version must be >= 0.6.1 but not a 0.8\")\n            else:\n                raise VPCSError(\"Could not determine the VPCS version for {}\".format(self._vpcs_path()))\n        except (OSError, subprocess.SubprocessError) as e:\n            raise VPCSError(\"Error while looking for the VPCS version: {}\".format(e))", "category": "Python"}, {"instruction": "async def unformat(self):\n        \"\"\"Unformat this block device.\"\"\"\n", "input": "", "output": "        self._data = await self._handler.unformat(\n            system_id=self.node.system_id, id=self.id)", "category": "Python"}, {"instruction": "def copy(self):\n        \"\"\"\n        Returns a deep copy of the particle. The particle is not added to any simulation by default.\n        \"\"\"\n", "input": "", "output": "        np = Particle()\n        memmove(byref(np), byref(self), sizeof(self))\n        return np", "category": "Python"}, {"instruction": "def ensure_regex_namespace(self, keyword: str, pattern: str) -> Namespace:\n        \"\"\"Get or create a regular expression namespace.\n\n        :param keyword: The keyword of a regular expression namespace\n        :param pattern: The pattern for a regular expression namespace\n        \"\"\"\n", "input": "", "output": "        if pattern is None:\n            raise ValueError('cannot have null pattern')\n\n        namespace = self.get_namespace_by_keyword_pattern(keyword, pattern)\n\n        if namespace is None:\n            log.info('creating regex namespace: %s:%s', keyword, pattern)\n            namespace = Namespace(\n                keyword=keyword,\n                pattern=pattern\n            )\n            self.session.add(namespace)\n            self.session.commit()\n\n        return namespace", "category": "Python"}, {"instruction": "def extract_features(self, phrase):\n        \"\"\"\n        This function will extract features from the phrase being used. \n        Currently, the feature we are extracting are unigrams of the text corpus.\n        \"\"\"\n", "input": "", "output": "        \n        words = nltk.word_tokenize(phrase)\n        features = {}\n        for word in words:\n            features['contains(%s)' % word] = (word in words)\n        return features", "category": "Python"}, {"instruction": "def readFAM(basefilename,usecols=None):\n    \"\"\"\n    helper method for speeding up read FAM\n    \"\"\"\n", "input": "", "output": "    fam = basefilename+'.fam'\n    fam = SP.loadtxt(fam,dtype=bytes,usecols=usecols)\n    return fam", "category": "Python"}, {"instruction": "def add_database_args(parser):\n    '''\n    Add a standard set of database arguments for argparse\n    '''\n", "input": "", "output": "    parser.add_argument(\n        'url',\n        nargs='?',\n        default='sqlite:///ncbi_taxonomy.db',\n        type=sqlite_default(),\n        help=('Database string URI or filename.  If no database scheme '\n              'specified \\\"sqlite:///\\\" will be prepended. [%(default)s]'))\n    db_parser = parser.add_argument_group(title='database options')\n\n    # TODO: better description of what --schema does\n    db_parser.add_argument(\n        '--schema',\n        help=('Name of SQL schema in database to query '\n              '(if database flavor supports this).'))\n\n    return parser", "category": "Python"}, {"instruction": "def flip_labels(obj):\n    \"\"\"\n    Rename fields x to y and y to x\n\n    Parameters\n    ----------\n    obj : dict_like\n        Object with labels to rename\n    \"\"\"\n", "input": "", "output": "    def sub(a, b):\n        ", "category": "Python"}, {"instruction": "def to_satoshis(input_quantity, input_type):\n    ''' convert to satoshis, no rounding '''\n", "input": "", "output": "    assert input_type in UNIT_CHOICES, input_type\n\n    # convert to satoshis\n    if input_type in ('btc', 'mbtc', 'bit'):\n        satoshis = float(input_quantity) * float(UNIT_MAPPINGS[input_type]['satoshis_per'])\n    elif input_type == 'satoshi':\n        satoshis = input_quantity\n    else:\n        raise Exception('Invalid Unit Choice: %s' % input_type)\n\n    return int(satoshis)", "category": "Python"}, {"instruction": "def range_mac(mac_start, mac_end, step=1):\n    \"\"\"Iterate over mac addresses (given as string).\"\"\"\n", "input": "", "output": "    start = int(EUI(mac_start))\n    end = int(EUI(mac_end))\n    for i_mac in range(start, end, step):\n        mac = EUI(int(EUI(i_mac)) + 1)\n        ip = ['10'] + [str(int(i, 2)) for i in mac.bits().split('-')[-3:]]\n        yield str(mac).replace('-', ':'), '.'.join(ip)", "category": "Python"}, {"instruction": "async def delete(self, key, param=None):\n        \"\"\"\n        delete cache corresponding to identity\n        generated from key and param\n        \"\"\"\n", "input": "", "output": "        identity = self._gen_identity(key, param)\n        return await self.client.delete(identity)", "category": "Python"}, {"instruction": "def line_break(self):\n        \"\"\"insert as many line breaks as the insert_line_break variable says\n        \"\"\"\n", "input": "", "output": "        for i in range(self.slide.insert_line_break):\n            # needs to be inside text:p\n            if not self._in_tag(ns(\"text\", \"p\")):\n                # we can just add a text:p and no line-break\n                # Create paragraph style first\n                self.add_node(ns(\"text\", \"p\"))\n            self.add_node(ns(\"text\", \"line-break\"))\n            self.pop_node()\n            if self.cur_node.tag == ns(\"text\", \"p\"):\n                return\n\n            if self.cur_node.getparent().tag != ns(\"text\", \"p\"):\n                self.pop_node()\n        self.slide.insert_line_break = 0", "category": "Python"}, {"instruction": "def load(self, cellpy_file, parent_level=\"CellpyData\"):\n        \"\"\"Loads a cellpy file.\n\n        Args:\n            cellpy_file (path, str): Full path to the cellpy file.\n            parent_level (str, optional): Parent level\n\n        \"\"\"\n", "input": "", "output": "\n        try:\n            self.logger.debug(\"loading cellpy-file (hdf5):\")\n            self.logger.debug(cellpy_file)\n            new_datasets = self._load_hdf5(cellpy_file, parent_level)\n            self.logger.debug(\"cellpy-file loaded\")\n        except AttributeError:\n            new_datasets = []\n            self.logger.warning(\"This cellpy-file version is not supported by\"\n                                \"current reader (try to update cellpy).\")\n\n        if new_datasets:\n            for dataset in new_datasets:\n                self.datasets.append(dataset)\n        else:\n            # raise LoadError\n            self.logger.warning(\"Could not load\")\n            self.logger.warning(str(cellpy_file))\n\n        self.number_of_datasets = len(self.datasets)\n        self.status_datasets = self._validate_datasets()\n        self._invent_a_name(cellpy_file)\n        return self", "category": "Python"}, {"instruction": "def _object_to_json(obj):\n        \"\"\"Convert objects that cannot be natively serialized into JSON\n        into their string representation\n\n        For datetime based objects convert them into their ISO formatted\n        string as specified by :meth:`datetime.datetime.isoformat`.\n\n        :param obj: object to convert into a JSON via getting its string\n            representation.\n        :type obj: object\n\n        :return: String value representing the given object ready to be\n            encoded into a JSON.\n        :rtype: str\n        \"\"\"\n", "input": "", "output": "        if isinstance(obj, datetime.datetime):\n            return obj.isoformat()\n        return repr(obj)", "category": "Python"}, {"instruction": "def CountClientPlatformsByLabel(self, day_buckets):\n    \"\"\"Computes client-activity stats for all client platforms in the DB.\"\"\"\n", "input": "", "output": "\n    def ExtractPlatform(client_info):\n      return client_info.last_snapshot.knowledge_base.os\n\n    return self._CountClientStatisticByLabel(day_buckets, ExtractPlatform)", "category": "Python"}, {"instruction": "def prepare_request(self, **kwargs):\n        \"\"\"\n        Configure all things to make real network request.\n        This method is called before doing real request via\n        transport extension.\n        \"\"\"\n", "input": "", "output": "\n        if self.transport is None:\n            self.setup_transport(self.transport_param)\n        self.reset()\n        self.request_counter = next(REQUEST_COUNTER)\n        if kwargs:\n            self.setup(**kwargs)\n        if self.proxylist.size() and self.config['proxy_auto_change']:\n            self.change_proxy()\n        self.request_method = self.detect_request_method()\n        self.transport.process_config(self)", "category": "Python"}, {"instruction": "def rm_keys_from_dict(d, keys):\n    \"\"\"\n    Given a dictionary and a key list, remove any data in the dictionary with the given keys.\n\n    :param dict d: Metadata\n    :param list keys: Keys to be removed\n    :return dict d: Metadata\n    \"\"\"\n", "input": "", "output": "    # Loop for each key given\n    for key in keys:\n        # Is the key in the dictionary?\n        if key in d:\n            try:\n                d.pop(key, None)\n            except KeyError:\n                # Not concerned with an error. Keep going.\n                pass\n    return d", "category": "Python"}, {"instruction": "def _sumterm_prime(lexer):\n    \"\"\"Return a sum term' expression, eliminates left recursion.\"\"\"\n", "input": "", "output": "    tok = next(lexer)\n    # '|' XORTERM SUMTERM'\n    if isinstance(tok, OP_or):\n        xorterm = _xorterm(lexer)\n        sumterm_prime = _sumterm_prime(lexer)\n        if sumterm_prime is None:\n            return xorterm\n        else:\n            return ('or', xorterm, sumterm_prime)\n    # null\n    else:\n        lexer.unpop_token(tok)\n        return None", "category": "Python"}, {"instruction": "def valid_api_plugin(self, plugin):\n        \"\"\"\n        Validate an API plugin, ensuring it is an API plugin and has the\n        necessary fields present.\n\n        `plugin` is a subclass of scruffy's Plugin class.\n        \"\"\"\n", "input": "", "output": "        if (issubclass(plugin, APIPlugin)       and\n            hasattr(plugin, 'plugin_type')      and plugin.plugin_type == 'api' and\n            hasattr(plugin, 'request')          and plugin.request != None and\n            hasattr(plugin, 'request_class')    and plugin.request_class != None and\n            hasattr(plugin, 'response_class')   and plugin.response_class != None):\n            return True\n        return False", "category": "Python"}, {"instruction": "def RIBNextHopLimitExceeded_RIBNextHopLimit(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n", "input": "", "output": "        config = ET.Element(\"config\")\n        RIBNextHopLimitExceeded = ET.SubElement(config, \"RIBNextHopLimitExceeded\", xmlns=\"http://brocade.com/ns/brocade-notification-stream\")\n        RIBNextHopLimit = ET.SubElement(RIBNextHopLimitExceeded, \"RIBNextHopLimit\")\n        RIBNextHopLimit.text = kwargs.pop('RIBNextHopLimit')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "category": "Python"}, {"instruction": "def cancel(self):\n        \"\"\"\n        Cancel itself and following NOTs as far as possible.\n        Returns the simplified expression.\n        \"\"\"\n", "input": "", "output": "        expr = self\n        while True:\n            arg = expr.args[0]\n            if not isinstance(arg, self.__class__):\n                return expr\n            expr = arg.args[0]\n            if not isinstance(expr, self.__class__):\n                return expr", "category": "Python"}, {"instruction": "def cli(yamlfile, format, classes, directory):\n    \"\"\" Generate a UML representation of a biolink model \"\"\"\n", "input": "", "output": "    print(YumlGenerator(yamlfile, format).serialize(classes=classes, directory=directory), end=\"\")", "category": "Python"}, {"instruction": "def modifie_options(self, field_option, value):\n        \"\"\"Set options in modifications.\n        All options will be stored since it should be grouped in the DB.\"\"\"\n", "input": "", "output": "        options = dict(self[\"options\"] or {}, **{field_option: value})\n        self.modifications[\"options\"] = options", "category": "Python"}, {"instruction": "def list_domains():\n    '''\n    Return a list of virtual machine names on the minion\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virt.list_domains\n    '''\n", "input": "", "output": "    data = __salt__['vmadm.list'](keyed=True)\n    vms = [\"UUID                                  TYPE  RAM      STATE             ALIAS\"]\n    for vm in data:\n        vms.append(\"{vmuuid}{vmtype}{vmram}{vmstate}{vmalias}\".format(\n            vmuuid=vm.ljust(38),\n            vmtype=data[vm]['type'].ljust(6),\n            vmram=data[vm]['ram'].ljust(9),\n            vmstate=data[vm]['state'].ljust(18),\n            vmalias=data[vm]['alias'],\n        ))\n    return vms", "category": "Python"}, {"instruction": "def remove_query_param(self, key, value=None):\n        \"\"\"\n        Remove a query param from a URL\n\n        Set the value parameter if removing from a list.\n\n        :param string key: The key to delete\n        :param string value: The value of the param to delete (of more than one)\n        \"\"\"\n", "input": "", "output": "        parse_result = self.query_params()\n        if value is not None:\n            index = parse_result[key].index(value)\n            del parse_result[key][index]\n        else:\n            del parse_result[key]\n        return URL._mutate(self, query=unicode_urlencode(parse_result, doseq=True))", "category": "Python"}, {"instruction": "def encode_request(name, max_size):\n    \"\"\" Encode request into client_message\"\"\"\n", "input": "", "output": "    client_message = ClientMessage(payload_size=calculate_size(name, max_size))\n    client_message.set_message_type(REQUEST_TYPE)\n    client_message.set_retryable(RETRYABLE)\n    client_message.append_str(name)\n    client_message.append_int(max_size)\n    client_message.update_frame_length()\n    return client_message", "category": "Python"}, {"instruction": "def end(self):\n        \"\"\"\n        Ends the response. Useful for quickly ending connection with no data\n        sent\n        \"\"\"\n", "input": "", "output": "        self.send_headers()\n        self.write()\n        self.write_eof()\n        self.has_ended = True", "category": "Python"}, {"instruction": "def __flush(self, async=True):\n        \"\"\" Flushes messages through current HttpRequest and closes it.\n            It assumes a current requesthandler and requires a lock\n            on self.lock \"\"\"\n", "input": "", "output": "        rh = self.rh\n        messages = list(self.messages)\n        stream_notices = list(self.stream_notices)\n        self.stream_notices = []\n        self.messages = []\n        args = (rh, messages, stream_notices)\n        if async:\n            self.hub.threadPool.execute_named(self.__inner_flush,\n                '%s __inner__flush' % self.hub.l.name, *args)\n        else:\n            self.__inner_flush(*args)\n        self.rh = None\n        self._set_timeout(int(time.time() + self.hub.timeout))", "category": "Python"}, {"instruction": "def _cellrepr(value, allow_formulas):\n    \"\"\"\n    Get a string representation of dataframe value.\n\n    :param :value: the value to represent\n    :param :allow_formulas: if True, allow values starting with '='\n            to be interpreted as formulas; otherwise, escape\n            them with an apostrophe to avoid formula interpretation.\n    \"\"\"\n", "input": "", "output": "    if pd.isnull(value) is True:\n        return \"\"\n    if isinstance(value, float):\n        value = repr(value)\n    else:\n        value = str(value)\n    if (not allow_formulas) and value.startswith('='):\n        value = \"'%s\" % value\n    return value", "category": "Python"}, {"instruction": "def to_task(self):\n        \"\"\"Return a task object representing this message.\"\"\"\n", "input": "", "output": "        from google.appengine.api.taskqueue import Task\n\n        task_args = self.get_task_args().copy()\n\n        payload = None\n        if 'payload' in task_args:\n            payload = task_args.pop('payload')\n\n        kwargs = {\n            'method': METHOD_TYPE,\n            'payload': json.dumps(payload)\n        }\n\n        kwargs.update(task_args)\n\n        return Task(**kwargs)", "category": "Python"}, {"instruction": "def route_table_get(name, resource_group, **kwargs):\n    '''\n    .. versionadded:: 2019.2.0\n\n    Get details about a specific route table.\n\n    :param name: The name of the route table to query.\n\n    :param resource_group: The resource group name assigned to the\n        route table.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-call azurearm_network.route_table_get test-rt-table testgroup\n\n    '''\n", "input": "", "output": "    expand = kwargs.get('expand')\n\n    netconn = __utils__['azurearm.get_client']('network', **kwargs)\n\n    try:\n        table = netconn.route_tables.get(\n            route_table_name=name,\n            resource_group_name=resource_group,\n            expand=expand\n        )\n        result = table.as_dict()\n    except CloudError as exc:\n        __utils__['azurearm.log_cloud_error']('network', str(exc), **kwargs)\n        result = {'error': str(exc)}\n\n    return result", "category": "Python"}, {"instruction": "def decodeEntities(self, len, what, end, end2, end3):\n        \"\"\"This function is deprecated, we now always process entities\n          content through xmlStringDecodeEntities  TODO: remove it in\n          next major release.  [67] Reference ::= EntityRef | CharRef\n            [69] PEReference ::= '%' Name ';' \"\"\"\n", "input": "", "output": "        ret = libxml2mod.xmlDecodeEntities(self._o, len, what, end, end2, end3)\n        return ret", "category": "Python"}, {"instruction": "def _generate_overview_note(pass_count, only_warning_count, error_count, total_count):\n    \"\"\" Generates and returns the HTML note that provides a summary of validation status. \"\"\"\n", "input": "", "output": "\n    note_html = ['<div class=\"progress\">']\n    pbars = [\n        [ float(error_count), 'danger', 'had errors' ],\n        [ float(only_warning_count), 'warning', 'had warnings' ],\n        [ float(pass_count), 'success', 'passed' ]\n    ]\n    for b in pbars:\n        if b[0]:\n            note_html.append(\n                '<div class=\"progress-bar progress-bar-{pbcol}\" style=\"width: {pct}%\" data-toggle=\"tooltip\" title=\"{count} {sample} {txt}\">{count}</div>'. \\\n                format(\n                    pbcol = b[1],\n                    count = int(b[0]),\n                    pct = (b[0]/float(total_count))*100.0,\n                    txt = b[2],\n                    sample = 'samples' if b[0] > 1 else 'sample'\n                )\n            )\n    note_html.append('</div>')\n\n    return \"\\n\".join(note_html)", "category": "Python"}, {"instruction": "def set_compression_pool_size(pool_size):\n    \"\"\"\n    Set the size of the compression workers thread pool.\n    If the pool is already created, it waits until all jobs are finished, and then proceeds with setting the new size.\n\n    Parameters\n    ----------\n        pool_size : `int`\n            The size of the pool (must be a positive integer)\n\n    Returns\n    -------\n    `None`\n    \"\"\"\n", "input": "", "output": "    pool_size = int(pool_size)\n    if pool_size < 1:\n        raise ValueError(\"The compression thread pool size cannot be of size {}\".format(pool_size))\n\n    global _compress_thread_pool\n    if _compress_thread_pool is not None:\n        _compress_thread_pool.close()\n        _compress_thread_pool.join()\n    _compress_thread_pool = ThreadPool(pool_size)", "category": "Python"}, {"instruction": "def get(self, sid):\n        \"\"\"\n        Constructs a TranscriptionContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.transcription.TranscriptionContext\n        :rtype: twilio.rest.api.v2010.account.transcription.TranscriptionContext\n        \"\"\"\n", "input": "", "output": "        return TranscriptionContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )", "category": "Python"}, {"instruction": "def get(self, item, default=None):\n        \"\"\"\n        Returns the value ``item`` from the host or hosts group variables.\n\n        Arguments:\n            item(``str``): The variable to get\n            default(``any``): Return value if item not found\n        \"\"\"\n", "input": "", "output": "        if hasattr(self, item):\n            return getattr(self, item)\n        try:\n            return self.__getitem__(item)\n\n        except KeyError:\n            return default", "category": "Python"}, {"instruction": "def tangent(obj, params, **kwargs):\n    \"\"\" Evaluates the tangent vector of the curves or surfaces at the input parameter values.\n\n    This function is designed to evaluate tangent vectors of the B-Spline and NURBS shapes at single or\n    multiple parameter positions.\n\n    :param obj: input shape\n    :type obj: abstract.Curve or abstract.Surface\n    :param params: parameters\n    :type params: float, list or tuple\n    :return: a list containing \"point\" and \"vector\" pairs\n    :rtype: tuple\n    \"\"\"\n", "input": "", "output": "    normalize = kwargs.get('normalize', True)\n    if isinstance(obj, abstract.Curve):\n        if isinstance(params, (list, tuple)):\n            return ops.tangent_curve_single_list(obj, params, normalize)\n        else:\n            return ops.tangent_curve_single(obj, params, normalize)\n    if isinstance(obj, abstract.Surface):\n        if isinstance(params[0], float):\n            return ops.tangent_surface_single(obj, params, normalize)\n        else:\n            return ops.tangent_surface_single_list(obj, params, normalize)", "category": "Python"}, {"instruction": "def _create_paths(self, basedir, name=None):\n        \"\"\"Create datadir and subdir paths.\"\"\"\n", "input": "", "output": "        if name:\n            datapath = os.path.join(basedir, name)\n        else:\n            datapath = basedir\n\n        dbpath = os.path.join(datapath, 'db')\n        if not os.path.exists(dbpath):\n            os.makedirs(dbpath)\n        if self.args['verbose']:\n            print('creating directory: %s' % dbpath)\n\n        return datapath", "category": "Python"}, {"instruction": "def create_or_edit(self, id, seq, resource): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Create or edit a highlight.\n\n        :param id: Result ID as an int.\n        :param seq: TestResult sequence ID as an int.\n        :param resource: :class:`highlights.Highlight <highlights.Highlight>` object\n        :return: :class:`highlights.Highlight <highlights.Highlight>` object\n        :rtype: highlights.Highlight\n        \"\"\"\n", "input": "", "output": "        schema = HighlightSchema(exclude=('id', 'seq'))\n        json = self.service.encode(schema, resource)\n\n        schema = HighlightSchema()\n        resp = self.service.edit(self._base(id, seq), resource.line, json)\n        return self.service.decode(schema, resp)", "category": "Python"}, {"instruction": "def points(self, size=1.0, highlight=None, colorlist=None, opacity=1.0):\n        \"\"\"Display the system as points.\n\n        :param float size: the size of the points.\n\n\n        \"\"\"\n", "input": "", "output": "        if colorlist is None:\n            colorlist = [get_atom_color(t) for t in self.topology['atom_types']]\n        if highlight is not None:\n            if isinstance(highlight, int):\n                colorlist[highlight] = 0xff0000\n            if isinstance(highlight, (list, np.ndarray)):\n                for i in highlight:\n                    colorlist[i] = 0xff0000\n\n        sizes = [size] * len(self.topology['atom_types'])\n\n        points = self.add_representation('points', {'coordinates': self.coordinates.astype('float32'),\n                                                    'colors': colorlist,\n                                                    'sizes': sizes,\n                                                    'opacity': opacity})\n        # Update closure\n        def update(self=self, points=points):\n            self.update_representation(points, {'coordinates': self.coordinates.astype('float32')})\n\n        self.update_callbacks.append(update)\n        self.autozoom(self.coordinates)", "category": "Python"}, {"instruction": "def match_one(template, image, options=None):\n    \"\"\"\n    Match template and find exactly one match in the Image using specified features.\n\n    :param template: Template Image\n    :param image: Search Image\n    :param options: Options include\n        - features: List of options for each feature\n    :return: (Box, Score) Bounding box of the matched object, Heatmap value\n    \"\"\"\n", "input": "", "output": "    heatmap, scale = multi_feat_match(template, image, options)\n\n    min_val, _, min_loc, _ = cv.minMaxLoc(heatmap)\n    top_left = tuple(scale * x for x in min_loc)\n    score = min_val\n\n    h, w = template.shape[:2]\n    return Box(top_left[0], top_left[1], w, h), score", "category": "Python"}, {"instruction": "def _humanSortKey(s):\n  \"\"\"Sort strings with numbers in a way that makes sense to humans (e.g., 5 < 20)\"\"\"\n", "input": "", "output": "  if isinstance(s, str):\n    return [w.isdigit() and int(w) or w for w in re.split(r'(\\d+)', s)]\n  else:\n    return s", "category": "Python"}, {"instruction": "def get_link(self, path, method, callback, view):\n        \"\"\"\n        Return a `coreapi.Link` instance for the given endpoint.\n        \"\"\"\n", "input": "", "output": "        fields = self.get_path_fields(path, method, callback, view)\n        fields += self.get_serializer_fields(path, method, callback, view)\n        fields += self.get_pagination_fields(path, method, callback, view)\n        fields += self.get_filter_fields(path, method, callback, view)\n\n        if fields and any([field.location in ('form', 'body')\n                           for field in fields]):\n            encoding = self.get_encoding(path, method, callback, view)\n        else:\n            encoding = None\n\n        description = self.get_description(path, method, callback, view)\n\n        link = coreapi.Link(\n            url=urlparse.urljoin(self.url, path),\n            action=method.lower(),\n            encoding=encoding,\n            description=description,\n            fields=fields,\n            transform=None,  # Not handled, but here for future reference\n        )\n        link._responses = self.get_responses(path, method, callback, view)\n        link._produces = self.get_produces(path, method, callback, view)\n\n        return link", "category": "Python"}, {"instruction": "def compute_empirical(cls, X):\n        \"\"\"Compute empirical distribution.\"\"\"\n", "input": "", "output": "        z_left = []\n        z_right = []\n        L = []\n        R = []\n\n        U, V = cls.split_matrix(X)\n        N = len(U)\n        base = np.linspace(EPSILON, 1.0 - EPSILON, COMPUTE_EMPIRICAL_STEPS)\n        # See https://github.com/DAI-Lab/Copulas/issues/45\n\n        for k in range(COMPUTE_EMPIRICAL_STEPS):\n            left = sum(np.logical_and(U <= base[k], V <= base[k])) / N\n            right = sum(np.logical_and(U >= base[k], V >= base[k])) / N\n\n            if left > 0:\n\n                z_left.append(base[k])\n                L.append(left / base[k] ** 2)\n\n            if right > 0:\n                z_right.append(base[k])\n                R.append(right / (1 - z_right[k]) ** 2)\n\n        return z_left, L, z_right, R", "category": "Python"}, {"instruction": "def remove(self):\n        \"\"\"Remove this file.\"\"\"\n", "input": "", "output": "        if self.exists() or self.islink():\n            self.fs.unlink(self.get_internal_path())\n            return 1\n        return None", "category": "Python"}, {"instruction": "def find_content(self, text):\n        \"\"\"Find content.\"\"\"\n", "input": "", "output": "\n        for m in self.pattern.finditer(self.norm_nl(text)):\n            self.evaluate(m)", "category": "Python"}, {"instruction": "def flag_forgotten_entries(session, today=None):\n    \"\"\"Flag any entries from previous days where users forgot to sign\n    out.\n\n    :param session: SQLAlchemy session through which to access the database.\n    :param today: (optional) The current date as a `datetime.date` object. Used for testing.\n    \"\"\"\n", "input": "", "output": "    today = date.today() if today is None else today\n\n    forgotten = (\n        session\n        .query(Entry)\n        .filter(Entry.time_out.is_(None))\n        .filter(Entry.forgot_sign_out.is_(False))\n        .filter(Entry.date < today)\n    )\n\n    for entry in forgotten:\n        e = sign_out(entry, forgot=True)\n        logger.debug('Signing out forgotten entry: {}'.format(e))\n        session.add(e)\n\n    session.commit()", "category": "Python"}, {"instruction": "def random_id(length):\n    \"\"\"Generates a random ID of given length\"\"\"\n", "input": "", "output": "\n    def char():\n        ", "category": "Python"}, {"instruction": "def _floatize_x(x, new_x):\n    \"\"\" Make x and new_x float.\n    This is particulary useful for datetime dtype.\n    x, new_x: tuple of np.ndarray\n    \"\"\"\n", "input": "", "output": "    x = list(x)\n    new_x = list(new_x)\n    for i in range(len(x)):\n        if _contains_datetime_like_objects(x[i]):\n            # Scipy casts coordinates to np.float64, which is not accurate\n            # enough for datetime64 (uses 64bit integer).\n            # We assume that the most of the bits are used to represent the\n            # offset (min(x)) and the variation (x - min(x)) can be\n            # represented by float.\n            xmin = x[i].values.min()\n            x[i] = x[i]._to_numeric(offset=xmin, dtype=np.float64)\n            new_x[i] = new_x[i]._to_numeric(offset=xmin, dtype=np.float64)\n    return x, new_x", "category": "Python"}, {"instruction": "def _GetStat(self):\n    \"\"\"Retrieves information about the file entry.\n\n    Returns:\n      VFSStat: a stat object.\n    \"\"\"\n", "input": "", "output": "    stat_object = super(BDEFileEntry, self)._GetStat()\n\n    stat_object.size = self._bde_volume.get_size()\n\n    return stat_object", "category": "Python"}, {"instruction": "def path_to(self, p):\n        \"\"\"Returns the absolute path to a given relative path.\"\"\"\n", "input": "", "output": "        if os.path.isabs(p):\n            return p\n\n        return os.sep.join([self._original_dir, p])", "category": "Python"}, {"instruction": "def generate_tar_files(directory_list):\n    \"\"\"Public function that reads a list of local directories and generates tar archives from them\"\"\"\n", "input": "", "output": "    \n    tar_file_list = []\n\n    for directory in directory_list:\n        if dir_exists(directory):\n            _generate_tar(directory)                  # create the tar archive\n            tar_file_list.append(directory + '.tar')  # append the tar archive filename to the returned tar_file_list list\n        else:\n            stderr(\"The directory '\" + directory + \"' does not exist and a tar archive could not be created from it.\", exit=1)            \n\n    return tar_file_list", "category": "Python"}, {"instruction": "def codepoints2bitstream(codepoints):\n    \"\"\"\n    >>> list(codepoints2bitstream([0x48,0x45]))\n    [0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0]\n    >>> list(codepoints2bitstream(0x48))\n    [0, 0, 0, 1, 0, 0, 1, 0]\n    \"\"\"\n", "input": "", "output": "    if isinstance(codepoints, int):\n        codepoints = [codepoints]\n    for codepoint in codepoints:\n        bit_string = byte2bit_string(codepoint)\n        for bit in bit_string:\n            yield int(bit)", "category": "Python"}, {"instruction": "def query_ssos(self):\n        \"\"\"\n        Use the MPC file that has been built up in processing this work\n        unit to generate another workunit.\n        \"\"\"\n", "input": "", "output": "        self._ssos_queried = True\n        mpc_filename = self.save()\n        return self.builder.build_workunit(mpc_filename)", "category": "Python"}, {"instruction": "def _iterparse(xmlfile):\n    \"\"\"\n    Avoid bug in python 3.{2,3}. See http://bugs.python.org/issue9257.\n\n    :param xmlfile: XML file or file-like object\n    \"\"\"\n", "input": "", "output": "    try:\n        return ET.iterparse(xmlfile, events=(\"start-ns\", ))\n    except TypeError:\n        return ET.iterparse(xmlfile, events=(b\"start-ns\", ))", "category": "Python"}, {"instruction": "def _FormatDataToken(self, token_data):\n    \"\"\"Formats a data token as a dictionary of values.\n\n    Args:\n      token_data (bsm_token_data_data): AUT_DATA token data.\n\n    Returns:\n      dict[str, str]: token values.\n    \"\"\"\n", "input": "", "output": "    format_string = bsmtoken.BSM_TOKEN_DATA_PRINT.get(\n        token_data.data_format, 'UNKNOWN')\n\n    if token_data.data_format == 4:\n      data = bytes(bytearray(token_data.data)).split(b'\\x00')[0]\n      data = data.decode('utf-8')\n    else:\n      data = ''.join(['{0:02x}'.format(byte) for byte in token_data.data])\n    return {\n        'format': format_string,\n        'data': data}", "category": "Python"}, {"instruction": "def prune_empty_node(node, seen):\n    \"\"\"\n    Recursively remove empty branches and return whether this makes the node\n    itself empty.\n\n    The ``seen`` parameter is used to avoid infinite recursion due to cycles\n    (you never know).\n    \"\"\"\n", "input": "", "output": "    if node.methods:\n        return False\n    if id(node) in seen:\n        return True\n    seen = seen | {id(node)}\n    for branch in list(node.branches):\n        if prune_empty_node(branch, seen):\n            node.branches.remove(branch)\n        else:\n            return False\n    return True", "category": "Python"}, {"instruction": "def reset_network(roles, extra_vars=None):\n    \"\"\"Reset the network constraints (latency, bandwidth ...)\n\n    Remove any filter that have been applied to shape the traffic.\n\n    Args:\n        roles (dict): role->hosts mapping as returned by\n            :py:meth:`enoslib.infra.provider.Provider.init`\n        inventory (str): path to the inventory\n    \"\"\"\n", "input": "", "output": "    logger.debug('Reset the constraints')\n\n    if not extra_vars:\n        extra_vars = {}\n\n    tmpdir = os.path.join(os.getcwd(), TMP_DIRNAME)\n\n    _check_tmpdir(tmpdir)\n    utils_playbook = os.path.join(ANSIBLE_DIR, 'utils.yml')\n    options = {'enos_action': 'tc_reset',\n               'tc_output_dir': tmpdir}\n    options.update(extra_vars)\n    run_ansible([utils_playbook], roles=roles, extra_vars=options)", "category": "Python"}, {"instruction": "def erase(self, **kwargs):\n        \"\"\"Erase the job (remove job artifacts and trace).\n\n        Args:\n            **kwargs: Extra options to send to the server (e.g. sudo)\n\n        Raises:\n            GitlabAuthenticationError: If authentication is not correct\n            GitlabJobEraseError: If the job could not be erased\n        \"\"\"\n", "input": "", "output": "        path = '%s/%s/erase' % (self.manager.path, self.get_id())\n        self.manager.gitlab.http_post(path)", "category": "Python"}, {"instruction": "def from_hertz(self, hertz, standard_pitch=440):\n        \"\"\"Set the Note name and pitch, calculated from the hertz value.\n\n        The standard_pitch argument can be used to set the pitch of A-4,\n        from which the rest is calculated.\n        \"\"\"\n", "input": "", "output": "        value = ((log((float(hertz) * 1024) / standard_pitch, 2) +\n            1.0 / 24) * 12 + 9)  # notes.note_to_int(\"A\")\n        self.name = notes.int_to_note(int(value) % 12)\n        self.octave = int(value / 12) - 6\n        return self", "category": "Python"}, {"instruction": "def reentrancies(self):\n        \"\"\"\n        Return a mapping of variables to their re-entrancy count.\n\n        A re-entrancy is when more than one edge selects a node as its\n        target. These graphs are rooted, so the top node always has an\n        implicit entrancy. Only nodes with re-entrancies are reported,\n        and the count is only for the entrant edges beyond the first.\n        Also note that these counts are for the interpreted graph, not\n        for the linearized form, so inverted edges are always\n        re-entrant.\n        \"\"\"\n", "input": "", "output": "        entrancies = defaultdict(int)\n        entrancies[self.top] += 1  # implicit entrancy to top\n        for t in self.edges():\n            entrancies[t.target] += 1\n        return dict((v, cnt - 1) for v, cnt in entrancies.items() if cnt >= 2)", "category": "Python"}, {"instruction": "def unflatten(obj):\n  '''\n  TODO: add docs\n  '''\n", "input": "", "output": "  if not isdict(obj):\n    raise ValueError(\n      'only dict-like objects can be unflattened, not %r' % (obj,))\n  ret = dict()\n  sub = dict()\n  for key, value in obj.items():\n    if '.' not in key and '[' not in key:\n      ret[key] = value\n      continue\n    if '.' in key and '[' in key:\n      idx = min(key.find('.'), key.find('['))\n    elif '.' in key:\n      idx = key.find('.')\n    else:\n      idx = key.find('[')\n    prefix = key[:idx]\n    if prefix not in sub:\n      sub[prefix] = dict()\n    sub[prefix][key[idx:]] = value\n  for pfx, values in sub.items():\n    if pfx in ret:\n      raise ValueError(\n        'conflicting scalar vs. structure for prefix: %s' % (pfx,))\n    ret[pfx] = _relunflatten(pfx, values)\n  return ret", "category": "Python"}, {"instruction": "def peers(cls):\n        \"\"\"Return others of the same concrete type.\"\"\"\n", "input": "", "output": "        contentType = ContentType.objects.get_for_model(cls)\n        return cls.objects.filter(content_type=contentType)", "category": "Python"}, {"instruction": "def validate(self):\n        \"\"\"  Confirms the current token is still valid.\n        Returns True if it is valid, False otherwise. \"\"\"\n", "input": "", "output": "\n        try:\n            resp = self.request().get(self.validate_url, verify=self.verifySSL).json()\n        except TokenExpiredError:\n            return False\n        except AttributeError:\n            return False\n\n        if 'error' in resp:\n            return False\n        return True", "category": "Python"}, {"instruction": "def _iand(self, other):\n\t\t\"\"\"Set multiplicity of each element to the minimum of the two collections.\n\n\t\tif isinstance(other, _basebag):\n\t\t\tThis runs in O(other.num_unique_elements())\n\t\telse:\n\t\t\tThis runs in O(len(other))\n\t\t\"\"\"\n", "input": "", "output": "\t\t# TODO do we have to create a bag from the other first?\n\t\tif not isinstance(other, _basebag):\n\t\t\tother = self._from_iterable(other)\n\t\tfor elem, old_count in set(self.counts()):\n\t\t\tother_count = other.count(elem)\n\t\t\tnew_count = min(other_count, old_count)\n\t\t\tself._set_count(elem, new_count)\n\t\treturn self", "category": "Python"}, {"instruction": "def unpack_grad_tuple(gv, gpt):\n    \"\"\"Unpack a previously packed collection of gradient tensors.\n\n  Args:\n    gv: A (grad, var) pair to be unpacked.\n    gpt: A GradPackTuple describing the packing operation that produced gv.\n\n  Returns:\n    A list of (grad, var) pairs corresponding to the values that were\n     originally packed into gv, maybe following subsequent operations like\n     reduction.\n  \"\"\"\n", "input": "", "output": "    elt_widths = [x.num_elements() for x in gpt.shapes]\n    with tf.device(gv[0][0].device):\n        with tf.name_scope(\"unpack\"):\n            splits = tf.split(gv[0], elt_widths)\n            unpacked_gv = []\n            for idx, s in enumerate(splits):\n                unpacked_gv.append((tf.reshape(s, gpt.shapes[idx]),\n                                    gpt.vars[idx]))\n    return unpacked_gv", "category": "Python"}, {"instruction": "def _get_appointee(id):\n    \"\"\"\n    Return a restclients.models.hrp.AppointeePerson object\n    \"\"\"\n", "input": "", "output": "    url = \"%s%s.json\" % (URL_PREFIX, id)\n    response = get_resource(url)\n    return process_json(response)", "category": "Python"}, {"instruction": "def cmap(self, background_color='#000000', random_state=None):\n        \"\"\"\n        Define a matplotlib colormap consisting of (random) muted\n        colors.\n\n        This is very useful for plotting the segmentation image.\n\n        Parameters\n        ----------\n        background_color : str or `None`, optional\n            A hex string in the \"#rrggbb\" format defining the first\n            color in the colormap.  This color will be used as the\n            background color (label = 0) when plotting the segmentation\n            image.  The default is black ('#000000').\n\n        random_state : int or `~numpy.random.RandomState`, optional\n            The pseudo-random number generator state used for random\n            sampling.  Separate function calls with the same\n            ``random_state`` will generate the same colormap.\n        \"\"\"\n", "input": "", "output": "\n        return self.make_cmap(background_color=background_color,\n                              random_state=random_state)", "category": "Python"}, {"instruction": "def returned(n):\n\t\"\"\"Generate a random walk and return True if the walker has returned to\n\tthe origin after taking `n` steps.\n\t\"\"\"\n", "input": "", "output": "\t## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk\n\tfor pos in randwalk() >> drop(1) >> takei(xrange(n-1)):\n\t\tif pos == Origin:\n\t\t\treturn True\n\treturn False", "category": "Python"}, {"instruction": "def add_gateway_responses(self, gateway_responses):\n        \"\"\"\n        Add Gateway Response definitions to Swagger.\n\n        :param dict gateway_responses: Dictionary of GatewayResponse configuration which gets translated.\n        \"\"\"\n", "input": "", "output": "        self.gateway_responses = self.gateway_responses or {}\n\n        for response_type, response in gateway_responses.items():\n            self.gateway_responses[response_type] = response.generate_swagger()", "category": "Python"}, {"instruction": "def disconnect(self):\n        \"\"\"Disconnect from event stream.\"\"\"\n", "input": "", "output": "        _LOGGING.debug('Disconnecting from stream: %s', self.name)\n        self.kill_thrd.set()\n        self.thrd.join()\n        _LOGGING.debug('Event stream thread for %s is stopped', self.name)\n        self.kill_thrd.clear()", "category": "Python"}, {"instruction": "def get_beautiful_soup(self, source=None):\n        \"\"\" BeautifulSoup is a toolkit for dissecting an HTML document\n            and extracting what you need. It's great for screen-scraping! \"\"\"\n", "input": "", "output": "        from bs4 import BeautifulSoup\n        if not source:\n            self.wait_for_ready_state_complete()\n            source = self.get_page_source()\n        soup = BeautifulSoup(source, \"html.parser\")\n        return soup", "category": "Python"}, {"instruction": "def deserialize(self, mimetypes):  # pylint: disable=arguments-differ\n        \"\"\" Invoke the deserializer\n\n        Upon successful deserialization a dict will be returned\n        containing the following key/vals:\n\n            {\n                'content': <uploaded object>,\n                'content-type': <content-type of content>,\n                'file-ext': <file extension based on content-type>,\n                'file-name': <file name of content>,\n            }\n\n        :param mimetypes:\n            allowed mimetypes of the object in the request\n            payload\n        :return:\n            normalized dict\n        \"\"\"\n", "input": "", "output": "\n        super(Deserializer, self).deserialize()\n\n        parts = self.parse(mimetypes)\n        data = self.normalize(parts)\n\n        return data", "category": "Python"}, {"instruction": "def to_xml(self):\n        '''\n        Returns an XMLi representation of the shipping details.\n        @return: Element\n        '''\n", "input": "", "output": "        for n, v in {\"recipient\": self.recipient}.items():\n            if is_empty_or_none(v):\n                raise ValueError(\"'%s' attribute cannot be empty or None.\" % n)\n\n        doc = Document()\n        root = doc.createElement(\"shipping\")\n        root.appendChild(self.recipient.to_xml(\"recipient\"))\n        return root", "category": "Python"}, {"instruction": "def get_url(\n    width, height=None, background_color=\"cccccc\",\n    text_color=\"969696\", text=None, random_background_color=False\n):\n    \"\"\"\n    Craft the URL for a placeholder image.\n\n    You can customize the background color, text color and text using\n    the optional keyword arguments\n\n    If you want to use a random color pass in random_background_color as True.\n    \"\"\"\n", "input": "", "output": "    if random_background_color:\n        background_color = _get_random_color()\n\n    # If height is not provided, presume it is will be a square\n    if not height:\n        height = width\n    d = dict(\n        width=width,\n        height=height,\n        bcolor=background_color,\n        tcolor=text_color\n    )\n    url = URL % d\n    if text:\n        text = text.replace(\" \", \"+\")\n        url = url + \"?text=\" + text\n    return url", "category": "Python"}, {"instruction": "def walk(self, visitor):\n        \"\"\"\n        Walk the branch and call the visitor function\n        on each node.\n        @param visitor: A function.\n        @return: self\n        @rtype: L{Element}\n        \"\"\"\n", "input": "", "output": "        visitor(self)\n        for c in self.children:\n            c.walk(visitor)\n        return self", "category": "Python"}, {"instruction": "def import_sanitizer(sanitizer):\n    \"\"\"\n    Imports the sanitizer python module.\n\n    :param sanitizer: Sanitizer python module file.\n    :type sanitizer: unicode\n    :return: Module.\n    :rtype: object\n    \"\"\"\n", "input": "", "output": "\n    directory = os.path.dirname(sanitizer)\n    not directory in sys.path and sys.path.append(directory)\n\n    namespace = __import__(foundations.strings.get_splitext_basename(sanitizer))\n    if hasattr(namespace, \"bleach\"):\n        return namespace\n    else:\n        raise foundations.exceptions.ProgrammingError(\n            \"{0} | '{1}' is not a valid sanitizer module file!\".format(sanitizer))", "category": "Python"}, {"instruction": "def future(self, rev=None):\n        \"\"\"Return a Mapping of items after the given revision.\n\n        Default revision is the last one looked up.\n\n        \"\"\"\n", "input": "", "output": "        if rev is not None:\n            self.seek(rev)\n        return WindowDictFutureView(self._future)", "category": "Python"}, {"instruction": "def i18n(msg, event=None, lang='en', domain='backend'):\n    \"\"\"Gettext function wrapper to return a message in a specified language by domain\n\n    To use internationalization (i18n) on your messages, import it as '_' and use as usual.\n    Do not forget to supply the client's language setting.\"\"\"\n", "input": "", "output": "\n    if event is not None:\n        language = event.client.language\n    else:\n        language = lang\n\n    domain = Domain(domain)\n    return domain.get(language, msg)", "category": "Python"}, {"instruction": "def update_bounds_boxes(self):\n        \"\"\"\n        updates bounds boxes with bounds of current specimen and fit\n        \"\"\"\n", "input": "", "output": "        if self.s not in list(self.Data.keys()):\n            self.select_specimen(list(self.Data.keys())[0])\n        self.T_list = self.Data[self.s]['zijdblock_steps']\n        if self.current_fit:\n            self.tmin_box.SetItems(self.T_list)\n            self.tmax_box.SetItems(self.T_list)\n            if type(self.current_fit.tmin) == str and type(self.current_fit.tmax) == str:\n                self.tmin_box.SetStringSelection(self.current_fit.tmin)\n                self.tmax_box.SetStringSelection(self.current_fit.tmax)\n        if self.ie_open:\n            self.ie.update_bounds_boxes(self.T_list)", "category": "Python"}, {"instruction": "def create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):\n    \"\"\"Creates a W3C compliant URL. Output will look like this:\n    'urlbase?param1=value1&amp;param2=value2'\n    @param urlbase: base url (e.g. config.CFG_SITE_URL/search)\n    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param urlhash: hash string to add at the end of the link\n    \"\"\"\n", "input": "", "output": "    separator = '&amp;'\n    output = urlbase\n    if urlargd:\n        output += '?'\n        if escape_urlargd:\n            arguments = [escape(quote(str(key)), quote=True) + '=' +\n                         escape(quote(str(urlargd[key])), quote=True)\n                         for key in urlargd.keys()]\n        else:\n            arguments = [str(key) + '=' + str(urlargd[key])\n                         for key in urlargd.keys()]\n        output += separator.join(arguments)\n    if urlhash:\n        output += \"#\" + escape(quote(str(urlhash)))\n    return output", "category": "Python"}, {"instruction": "def torrent_from_url(self, url, cache=True, prefetch=False):\n        \"\"\"Create a Torrent object from a given URL.\n\n        If the cache option is set, check to see if we already have a Torrent\n        object representing it. If prefetch is set, automatically query the\n        torrent's info page to fill in the torrent object. (If prefetch is\n        false, then the torrent page will be queried lazily on-demand.)\n\n        \"\"\"\n", "input": "", "output": "        if self._use_cache(cache) and url in self._torrent_cache:\n            return self._torrent_cache[url]\n        torrent = Torrent(url, cache, prefetch)\n        if cache:\n            self._torrent_cache[url] = torrent\n        return torrent", "category": "Python"}, {"instruction": "def _set(self, **kwargs):\n        \"\"\"\n        Sets user-supplied params.\n        \"\"\"\n", "input": "", "output": "        for param, value in kwargs.items():\n            p = getattr(self, param)\n            if value is not None:\n                try:\n                    value = p.typeConverter(value)\n                except TypeError as e:\n                    raise TypeError('Invalid param value given for param \"%s\". %s' % (p.name, e))\n            self._paramMap[p] = value\n        return self", "category": "Python"}, {"instruction": "def sub(self, b):\n        \"\"\"\n        Binary operation: sub\n\n        :param b: The other operand\n        :return: self - b\n        \"\"\"\n", "input": "", "output": "        new_bits = max(self.bits, b.bits)\n\n        overflow = self._wrapped_overflow_sub(self, b)\n        if overflow:\n            return StridedInterval.top(self.bits)\n\n        lb = self._modular_sub(self.lower_bound, b.upper_bound, new_bits)\n        ub = self._modular_sub(self.upper_bound, b.lower_bound, new_bits)\n\n        # Is it initialized?\n        uninitialized = self.uninitialized or b.uninitialized\n\n        # Take the GCD of two operands' strides\n        stride = fractions.gcd(self.stride, b.stride)\n\n        return StridedInterval(bits=new_bits, stride=stride, lower_bound=lb, upper_bound=ub,\n                               uninitialized=uninitialized).normalize()", "category": "Python"}, {"instruction": "def get_tile_gid(self, x, y, layer):\n        \"\"\" Return the tile image GID for this location\n\n        :param x: x coordinate\n        :param y: y coordinate\n        :param layer: layer number\n        :rtype: surface if found, otherwise ValueError\n        \"\"\"\n", "input": "", "output": "        try:\n            assert (x >= 0 and y >= 0 and layer >= 0)\n        except AssertionError:\n            raise ValueError\n\n        try:\n            return self.layers[int(layer)].data[int(y)][int(x)]\n        except (IndexError, ValueError):\n            msg = \"Coords: ({0},{1}) in layer {2} is invalid\"\n            logger.debug(msg, (x, y, layer))\n            raise ValueError", "category": "Python"}, {"instruction": "def extract_mfd(dstore, what):\n    \"\"\"\n    Display num_ruptures by magnitude for event based calculations.\n    Example: http://127.0.0.1:8800/v1/calc/30/extract/event_based_mfd\n    \"\"\"\n", "input": "", "output": "    dd = collections.defaultdict(int)\n    for rup in dstore['ruptures'].value:\n        dd[rup['mag']] += 1\n    dt = numpy.dtype([('mag', float), ('freq', int)])\n    magfreq = numpy.array(sorted(dd.items(), key=operator.itemgetter(0)), dt)\n    return magfreq", "category": "Python"}, {"instruction": "def generatePlugins(widgetPath = None, buildPath = None):\r\n    \"\"\"\r\n    Generates all the plugin files for the system and imports them.\r\n    \r\n    :param      widgetPath | <str> || None\r\n                buildPath  | <str> || None\r\n    \"\"\"\n", "input": "", "output": "    if widgetPath is None:\r\n        widgetPath = WIDGET_PATH\r\n        \r\n    if buildPath is None:\r\n        buildPath = BUILD_PATH\r\n    \r\n    for basepath in widgetPath.split(os.path.pathsep):\r\n        if not basepath:\r\n            continue\r\n            \r\n        # load packaged widgets\r\n        for filepath in glob.glob(os.path.join(basepath, '*/__init__.py')):\r\n            generatePlugins(os.path.dirname(filepath), buildPath)\r\n        \r\n        # load module widgets\r\n        for filepath in glob.glob(os.path.join(basepath, '*.py')):\r\n            generatePlugin(filepath, buildPath)", "category": "Python"}, {"instruction": "def script_level(self, container):\n        \"\"\"Nesting level of super/subscript.\"\"\"\n", "input": "", "output": "        try:\n            level = self.parent.script_level(container)\n        except AttributeError:\n            level = -1\n        return level + 1 if self.is_script(container) else level", "category": "Python"}, {"instruction": "def get_command(self, name):\n        \"\"\"Get a :class:`.Command` or subclasses from the internal list\n        of commands.\n\n        This could also be used as a way to get aliases.\n\n        The name could be fully qualified (e.g. ``'foo bar'``) will get\n        the subcommand ``bar`` of the group command ``foo``. If a\n        subcommand is not found then ``None`` is returned just as usual.\n\n        Parameters\n        -----------\n        name: :class:`str`\n            The name of the command to get.\n\n        Returns\n        --------\n        :class:`Command` or subclass\n            The command that was requested. If not found, returns ``None``.\n        \"\"\"\n", "input": "", "output": "\n        # fast path, no space in name.\n        if ' ' not in name:\n            return self.all_commands.get(name)\n\n        names = name.split()\n        obj = self.all_commands.get(names[0])\n        if not isinstance(obj, GroupMixin):\n            return obj\n\n        for name in names[1:]:\n            try:\n                obj = obj.all_commands[name]\n            except (AttributeError, KeyError):\n                return None\n\n        return obj", "category": "Python"}, {"instruction": "def highpass(cutoff):\n  \"\"\"\n  This strategy uses an exponential approximation for cut-off frequency\n  calculation, found by matching the single pole and single zero Laplace\n  highpass filter.\n  \"\"\"\n", "input": "", "output": "  R = thub(exp(-cutoff), 2)\n  G = (R + 1) / 2\n  return G * (1 - z ** -1) / (1 - R * z ** -1)", "category": "Python"}, {"instruction": "def post(self, url, body=None):\n        \"\"\"Sends this `Resource` instance to the service with a\n        ``POST`` request to the given URL. Takes an optional body\"\"\"\n", "input": "", "output": "        response = self.http_request(url, 'POST', body or self, {'Content-Type': 'application/xml; charset=utf-8'})\n        if response.status not in (200, 201, 204):\n            self.raise_http_error(response)\n\n        self._url = response.getheader('Location')\n\n        if response.status in (200, 201):\n            response_xml = response.read()\n            logging.getLogger('recurly.http.response').debug(response_xml)\n            self.update_from_element(ElementTree.fromstring(response_xml))", "category": "Python"}, {"instruction": "def decode(self, offset):\n        \"\"\"Decode a section of the data section starting at offset\n\n        Arguments:\n        offset -- the location of the data structure to decode\n        \"\"\"\n", "input": "", "output": "        new_offset = offset + 1\n        (ctrl_byte,) = struct.unpack(b'!B', self._buffer[offset:new_offset])\n        type_num = ctrl_byte >> 5\n        # Extended type\n        if not type_num:\n            (type_num, new_offset) = self._read_extended(new_offset)\n\n        (size, new_offset) = self._size_from_ctrl_byte(\n            ctrl_byte, new_offset, type_num)\n        return self._type_decoder[type_num](self, size, new_offset)", "category": "Python"}, {"instruction": "def learn_ids(self, item_list):\n        \"\"\" read in already set ids on objects \"\"\"\n", "input": "", "output": "        self._reset_sequence()\n        for item in item_list:\n            key = self.nondup_key_for_item(item)\n            self.ids[key] = item[self.id_key]", "category": "Python"}, {"instruction": "def edit_config_input_edit_content_url_url(self, **kwargs):\n        \"\"\"Auto Generated Code\n        \"\"\"\n", "input": "", "output": "        config = ET.Element(\"config\")\n        edit_config = ET.Element(\"edit_config\")\n        config = edit_config\n        input = ET.SubElement(edit_config, \"input\")\n        edit_content = ET.SubElement(input, \"edit-content\")\n        url = ET.SubElement(edit_content, \"url\")\n        url = ET.SubElement(url, \"url\")\n        url.text = kwargs.pop('url')\n\n        callback = kwargs.pop('callback', self._callback)\n        return callback(config)", "category": "Python"}, {"instruction": "async def is_user_authorized(self):\n        \"\"\"\n        Returns ``True`` if the user is authorized.\n        \"\"\"\n", "input": "", "output": "        if self._authorized is None:\n            try:\n                # Any request that requires authorization will work\n                await self(functions.updates.GetStateRequest())\n                self._authorized = True\n            except errors.RPCError:\n                self._authorized = False\n\n        return self._authorized", "category": "Python"}, {"instruction": "def reduced_chi_squareds(self, p=None):\n        \"\"\"\n        Returns the reduced chi squared for each massaged data set. \n\n        p=None means use the fit results.\n        \"\"\"\n", "input": "", "output": "        if len(self._set_xdata)==0 or len(self._set_ydata)==0: return None\n\n        if p is None: p = self.results[0]\n        r = self.studentized_residuals(p)\n        \n        # In case it's not possible to calculate\n        if r is None: return\n\n        # calculate the number of points\n        N = 0\n        for i in range(len(r)): N += len(r[i])\n\n        # degrees of freedom\n        dof_per_point = self.degrees_of_freedom()/N\n\n        for n in range(len(r)):\n            r[n] = sum(r[n]**2)/(len(r[n])*dof_per_point)\n\n        return r", "category": "Python"}, {"instruction": "def build(self):\n        \"\"\"\n        Builds the query string, which can be used for a search query\n\n        :return: the query string\n        \"\"\"\n", "input": "", "output": "        if self.es_version == '1':\n            if len(self.filters) > 0:\n                return {\n                    'filtered': {\n                        'query': self.query,\n                        'filter': {\n                            'and': self.filters\n                        }\n                    }\n                }\n            else:\n                return self.query\n        else:\n            query = {\n                'bool': {\n                    'must': self.query\n                }\n            }\n            if len(self.filters) > 0:\n                query[\"bool\"][\"filter\"] = self.filters\n            return query", "category": "Python"}, {"instruction": "def addMonitor(self, monitorFriendlyName, monitorURL):\n        \"\"\"\n        Returns True if Monitor was added, otherwise False.\n        \"\"\"\n", "input": "", "output": "        url = self.baseUrl\n        url += \"newMonitor?apiKey=%s\" % self.apiKey\n        url += \"&monitorFriendlyName=%s\" % monitorFriendlyName\n        url += \"&monitorURL=%s&monitorType=1\" % monitorURL\n        url += \"&monitorAlertContacts=%s\" % monitorAlertContacts\n        url += \"&noJsonCallback=1&format=json\"\n        success, response = self.requestApi(url)\n        if success:\n            return True\n        else:\n            return False", "category": "Python"}, {"instruction": "def parse_options_header(value):\n    \"\"\"Parse a ``Content-Type`` like header into a tuple with the content\n    type and the options:\n\n    >>> parse_options_header('text/html; charset=utf8')\n    ('text/html', {'charset': 'utf8'})\n\n    This should not be used to parse ``Cache-Control`` like headers that use\n    a slightly different format.  For these headers use the\n    :func:`parse_dict_header` function.\n\n    .. versionadded:: 0.5\n\n    :param value: the header to parse.\n    :return: (str, options)\n    \"\"\"\n", "input": "", "output": "    def _tokenize(string):\n        for match in _option_header_piece_re.finditer(string):\n            key, value = match.groups()\n            key = unquote_header_value(key)\n            if value is not None:\n                value = unquote_header_value(value, key == 'filename')\n            yield key, value\n\n    if not value:\n        return '', {}\n\n    parts = _tokenize(';' + value)\n    name = next(parts)[0]\n    extra = dict(parts)\n    return name, extra", "category": "Python"}, {"instruction": "def _to_dict(self):\n        \"\"\"\n        Converts object into a dictionary.\n        \"\"\"\n", "input": "", "output": "        for i, tag in enumerate(self.tags):\n            if tag in (\"\", None):\n                self.tags.pop(i)\n\n        data = {\n            'name': self.name,\n            'referenceId': self.reference_id,\n            'shortDescription': self.short_description,\n            'longDescription': self.long_description,\n            'itemState': self.item_state,\n            'linkURL': self.link_url,\n            'linkText': self.link_text,\n            'tags': self.tags,\n            'economics': self.economics,\n            'id': self.id,\n            'end_date': _make_tstamp(self.end_date),\n            'start_date': _make_tstamp(self.start_date)}\n        if len(self.renditions) > 0:\n            data['renditions'] = []\n            for r in self.renditions:\n                data['renditions'].append(r.to_dict())\n        if len(self.metadata) > 0:\n            data['customFields'] = {}\n            for meta in self.metadata:\n                data['customFields'][meta['key']] = meta['value']\n        [data.pop(key) for key in data.keys() if data[key] == None]\n        return data", "category": "Python"}, {"instruction": "def add_acquisition_source(\n        self,\n        method,\n        submission_number=None,\n        internal_uid=None,\n        email=None,\n        orcid=None,\n        source=None,\n        datetime=None,\n    ):\n        \"\"\"Add acquisition source.\n\n        :type submission_number: integer\n\n        :type email: integer\n\n        :type source: string\n\n        :param method: method of acquisition for the suggested document\n        :type method: string\n\n        :param orcid: orcid of the user that is creating the record\n        :type orcid: string\n\n        :param internal_uid: id of the user that is creating the record\n        :type internal_uid: string\n\n        :param datetime: UTC datetime in ISO 8601 format\n        :type datetime: string\n        \"\"\"\n", "input": "", "output": "        acquisition_source = self._sourced_dict(source)\n\n        acquisition_source['submission_number'] = str(submission_number)\n        for key in ('datetime', 'email', 'method', 'orcid', 'internal_uid'):\n            if locals()[key] is not None:\n                acquisition_source[key] = locals()[key]\n\n        self.obj['acquisition_source'] = acquisition_source", "category": "Python"}, {"instruction": "async def quit(self, message=None):\n        \"\"\" Quit network. \"\"\"\n", "input": "", "output": "        if message is None:\n            message = self.DEFAULT_QUIT_MESSAGE\n\n        await self.rawmsg('QUIT', message)\n        await self.disconnect(expected=True)", "category": "Python"}, {"instruction": "def unassign_comment_from_book(self, comment_id, book_id):\n        \"\"\"Removes a ``Comment`` from a ``Book``.\n\n        arg:    comment_id (osid.id.Id): the ``Id`` of the ``Comment``\n        arg:    book_id (osid.id.Id): the ``Id`` of the ``Book``\n        raise:  NotFound - ``comment_id`` or ``book_id`` not found or\n                ``comment_id`` not assigned to ``book_id``\n        raise:  NullArgument - ``comment_id`` or ``book_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n", "input": "", "output": "        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('COMMENTING', local=True)\n        lookup_session = mgr.get_book_lookup_session(proxy=self._proxy)\n        lookup_session.get_book(book_id)  # to raise NotFound\n        self._unassign_object_from_catalog(comment_id, book_id)", "category": "Python"}, {"instruction": "def get_large_image(self, page=1):\n        \"\"\"\n        Downloads and returns the large sized image of a single page.\n\n        The page kwarg specifies which page to return. One is the default.\n        \"\"\"\n", "input": "", "output": "        url = self.get_large_image_url(page=page)\n        return self._get_url(url)", "category": "Python"}, {"instruction": "def update_rec(self, rec, name, value):\n        \"\"\"Update current GOTerm with optional record.\"\"\"\n", "input": "", "output": "        # 'def' is a reserved word in python, do not use it as a Class attr.\n        if name == \"def\":\n            name = \"defn\"\n\n        # If we have a relationship, then we will split this into a further\n        # dictionary.\n\n        if hasattr(rec, name):\n            if name not in self.attrs_scalar:\n                if name not in self.attrs_nested:\n                    getattr(rec, name).add(value)\n                else:\n                    self._add_nested(rec, name, value)\n            else:\n                raise Exception(\"ATTR({NAME}) ALREADY SET({VAL})\".format(\n                    NAME=name, VAL=getattr(rec, name)))\n        else: # Initialize new GOTerm attr\n            if name in self.attrs_scalar:\n                setattr(rec, name, value)\n            elif name not in self.attrs_nested:\n                setattr(rec, name, set([value]))\n            else:\n                name = '_{:s}'.format(name)\n                setattr(rec, name, defaultdict(list))\n                self._add_nested(rec, name, value)", "category": "Python"}, {"instruction": "def get_country_info_from_iso3(cls, iso3, use_live=True, exception=None):\n        # type: (str, bool, Optional[ExceptionUpperBound]) -> Optional[Dict[str]]\n        \"\"\"Get country information from ISO3 code\n\n        Args:\n            iso3 (str): ISO3 code for which to get country information\n            use_live (bool): Try to get use latest data from web rather than file in package. Defaults to True.\n            exception (Optional[ExceptionUpperBound]): An exception to raise if country not found. Defaults to None.\n\n        Returns:\n            Optional[Dict[str]]: country information\n        \"\"\"\n", "input": "", "output": "        countriesdata = cls.countriesdata(use_live=use_live)\n        country = countriesdata['countries'].get(iso3.upper())\n        if country is not None:\n            return country\n\n        if exception is not None:\n            raise exception\n        return None", "category": "Python"}, {"instruction": "def get_aoi(self, solar_zenith, solar_azimuth):\n        \"\"\"Get the angle of incidence on the system.\n\n        Parameters\n        ----------\n        solar_zenith : float or Series.\n            Solar zenith angle.\n        solar_azimuth : float or Series.\n            Solar azimuth angle.\n\n        Returns\n        -------\n        aoi : Series\n            The angle of incidence\n        \"\"\"\n", "input": "", "output": "\n        aoi = irradiance.aoi(self.surface_tilt, self.surface_azimuth,\n                             solar_zenith, solar_azimuth)\n        return aoi", "category": "Python"}, {"instruction": "def logpost(self, theta, t=None):\n        \"\"\"Posterior log-density at given parameter values. \n\n        Parameters\n        ----------\n        theta: dict-like\n            theta['par'] is a ndarray containing the N values for parameter par\n        t: int \n            time (if set to None, the full posterior is returned)\n\n        Returns\n        -------\n        l: float numpy.ndarray\n            the N log-likelihood values \n        \"\"\"\n", "input": "", "output": "        return self.prior.logpdf(theta) + self.loglik(theta, t)", "category": "Python"}, {"instruction": "def cli(ctx, id_number, new_value):\n    \"\"\"Update a status name\n\nOutput:\n\n    an empty dictionary\n    \"\"\"\n", "input": "", "output": "    return ctx.gi.status.update_status(id_number, new_value)", "category": "Python"}, {"instruction": "def post(f, *args, **kwargs):\n    \"\"\"Automatically log progress on function exit. Default logging value:\n    info.\n\n    *Logging with values contained in the parameters of the decorated function*\n    Message (args[0]) may be a string to be formatted with parameters passed to\n    the decorated function. Each '{varname}' will be replaced by the value of\n    the parameter of the same name.\n\n    *Keyword parameters*\n    - log :: integer\n      - Specifies a custom level of logging to pass to the active logger.\n      - Default: INFO\n\n    *Exceptions:*\n    - IndexError and ValueError\n      - will be returned if *args contains a string that does not correspond to\n        a parameter name of the decorated function, or if there are more '{}'s\n        than there are *args.\n\n    \"\"\"\n", "input": "", "output": "    kwargs.update({'postfix_only': True})\n    return _stump(f, *args, **kwargs)", "category": "Python"}, {"instruction": "def post(method, hmc, uri, uri_parms, body, logon_required,\n             wait_for_completion):\n        \"\"\"Operation: Reassign Storage Adapter Port (requires DPM mode).\"\"\"\n", "input": "", "output": "        assert wait_for_completion is True  # async not supported yet\n        partition_oid = uri_parms[0]\n        partition_uri = '/api/partitions/' + partition_oid\n        hba_oid = uri_parms[1]\n        hba_uri = '/api/partitions/' + partition_oid + '/hbas/' + hba_oid\n        try:\n            hba = hmc.lookup_by_uri(hba_uri)\n        except KeyError:\n            raise InvalidResourceError(method, uri)\n        partition = hmc.lookup_by_uri(partition_uri)  # assert it exists\n        cpc = partition.manager.parent\n        assert cpc.dpm_enabled\n        check_valid_cpc_status(method, uri, cpc)\n        check_partition_status(method, uri, partition,\n                               invalid_statuses=['starting', 'stopping'])\n        check_required_fields(method, uri, body, ['adapter-port-uri'])\n\n        # Reflect the effect of the operation on the HBA\n        new_port_uri = body['adapter-port-uri']\n        hba.properties['adapter-port-uri'] = new_port_uri", "category": "Python"}, {"instruction": "def get_field_list(fields, schema):\n  \"\"\" Convert a field list spec into a real list of field names.\n\n      For tables, we return only the top-level non-RECORD fields as Google charts\n      can't handle nested data.\n  \"\"\"\n", "input": "", "output": "  # If the fields weren't supplied get them from the schema.\n  if schema:\n    all_fields = [f['name'] for f in schema._bq_schema if f['type'] != 'RECORD']\n\n  if isinstance(fields, list):\n    if schema:\n      # validate fields exist\n      for f in fields:\n        if f not in all_fields:\n          raise Exception('Cannot find field %s in given schema' % f)\n    return fields\n  if isinstance(fields, basestring) and fields != '*':\n    if schema:\n      # validate fields exist\n      for f in fields.split(','):\n        if f not in all_fields:\n          raise Exception('Cannot find field %s in given schema' % f)\n      return fields.split(',')\n  if not schema:\n    return []\n  return all_fields", "category": "Python"}, {"instruction": "def public_decrypt(pub, message):\n    '''\n    Verify an M2Crypto-compatible signature\n\n    :param Crypto.PublicKey.RSA._RSAobj key: The RSA public key object\n    :param str message: The signed message to verify\n    :rtype: str\n    :return: The message (or digest) recovered from the signature, or an\n        empty string if the verification failed\n    '''\n", "input": "", "output": "    if HAS_M2:\n        return pub.public_decrypt(message, salt.utils.rsax931.RSA_X931_PADDING)\n    else:\n        verifier = salt.utils.rsax931.RSAX931Verifier(pub.exportKey('PEM'))\n        return verifier.verify(message)", "category": "Python"}, {"instruction": "def num_nanoclusters(ConcAluminum, coag):\n    \"\"\"Return the number of Aluminum nanoclusters.\"\"\"\n", "input": "", "output": "    return (ConcAluminum / (dens_alum_nanocluster(coag).magnitude\n                            * np.pi * coag.Diameter**3))", "category": "Python"}, {"instruction": "def in_casapy (helper, caltable=None, selectcals={}, plotoptions={},\n               xaxis=None, yaxis=None, figfile=None):\n    \"\"\"This function is run inside the weirdo casapy IPython environment! A\n    strange set of modules is available, and the\n    `pwkit.environments.casa.scripting` system sets up a very particular\n    environment to allow encapsulated scripting.\n\n    \"\"\"\n", "input": "", "output": "    if caltable is None:\n        raise ValueError ('caltable')\n\n    show_gui = (figfile is None)\n    cp = helper.casans.cp\n\n    helper.casans.tp.setgui (show_gui)\n    cp.open (caltable)\n    cp.selectcal (**selectcals)\n    cp.plotoptions (**plotoptions)\n    cp.plot (xaxis, yaxis)\n\n    if show_gui:\n        import pylab as pl\n        pl.show ()\n    else:\n        cp.savefig (figfile)", "category": "Python"}, {"instruction": "def get_validator_list(self):\n        \"\"\"Return a list of validators specified in the override file\"\"\"\n", "input": "", "output": "        ignore = [\n            'dict',\n        ]\n        vlist = []\n        if not self.override:\n            return vlist\n\n        for k, v in list(self.override['classes'].items()):\n            if 'validator' in v:\n                validator = v['validator']\n                if validator not in ignore and validator not in vlist:\n                    vlist.append(validator)\n\n        for k, v in list(self.override['classes'].items()):\n            for kp, vp in list(v.items()):\n                if 'validator' in vp:\n                    validator = vp['validator']\n                    if validator not in ignore and validator not in vlist:\n                        vlist.append(validator)\n        return sorted(vlist)", "category": "Python"}, {"instruction": "def handle(self, *args, **options):\n        \"\"\"\n        Iterates a command over all registered schemata.\n        \"\"\"\n", "input": "", "output": "        if options['schema_name']:\n            # only run on a particular schema\n            connection.set_schema_to_public()\n            self.execute_command(get_tenant_model().objects.get(schema_name=options['schema_name']), self.COMMAND_NAME,\n                                 *args, **options)\n        else:\n            for tenant in get_tenant_model().objects.all():\n                if not (options['skip_public'] and tenant.schema_name == get_public_schema_name()):\n                    self.execute_command(tenant, self.COMMAND_NAME, *args, **options)", "category": "Python"}, {"instruction": "def copy(self, deep=True, data=None):\n        \"\"\"Returns a copy of this object.\n\n        `deep` is ignored since data is stored in the form of\n        pandas.Index, which is already immutable. Dimensions, attributes\n        and encodings are always copied.\n\n        Use `data` to create a new object with the same structure as\n        original but entirely new data.\n\n        Parameters\n        ----------\n        deep : bool, optional\n            Deep is always ignored.\n        data : array_like, optional\n            Data to use in the new object. Must have same shape as original.\n\n        Returns\n        -------\n        object : Variable\n            New object with dimensions, attributes, encodings, and optionally\n            data copied from original.\n        \"\"\"\n", "input": "", "output": "        if data is None:\n            data = self._data\n        else:\n            data = as_compatible_data(data)\n            if self.shape != data.shape:\n                raise ValueError(\"Data shape {} must match shape of object {}\"\n                                 .format(data.shape, self.shape))\n        return type(self)(self.dims, data, self._attrs,\n                          self._encoding, fastpath=True)", "category": "Python"}, {"instruction": "def __copy_tree(src_dir, dest_dir):\r\n    \"\"\"\r\n    The shutil.copytree() or distutils.dir_util.copy_tree() will happen to report\r\n    error list below if we invoke it again and again ( at least in python 2.7.4 ):\r\n\r\n    IOError: [Errno 2] No such file or directory: ...\r\n\r\n    So we have to write our's copy_tree() for that purpose.\r\n    \"\"\"\n", "input": "", "output": "\r\n    if not os.path.exists(dest_dir):\r\n        os.makedirs(dest_dir)\r\n        shutil.copystat(src_dir, dest_dir)\r\n\r\n    for entry in os.listdir(src_dir):\r\n        from_path = os.path.join(src_dir, entry)\r\n        to_path = os.path.join(dest_dir, entry)\r\n        if os.path.isdir(from_path):\r\n            __copy_tree(from_path, to_path)\r\n        else:\r\n            shutil.copy2(from_path, to_path)", "category": "Python"}, {"instruction": "def unit_ball_L_inf(shape, precondition=True):\n  \"\"\"A tensorflow variable tranfomed to be constrained in a L_inf unit ball.\n\n  Note that this code also preconditions the gradient to go in the L_inf\n  direction of steepest descent.\n\n  EXPERIMENTAL: Do not use for adverserial examples if you need to be confident\n  they are strong attacks. We are not yet confident in this code.\n  \"\"\"\n", "input": "", "output": "  x = tf.Variable(tf.zeros(shape))\n  if precondition:\n    return constrain_L_inf_precondition(x)\n  else:\n    return constrain_L_inf(x)", "category": "Python"}, {"instruction": "def instagram_config(self, id, secret, scope=None, **_):\n        \"\"\" Get config dictionary for instagram oauth \"\"\"\n", "input": "", "output": "        scope = scope if scope else 'basic'\n        token_params = dict(scope=scope)\n\n        config = dict(\n            # request_token_url=None,\n            access_token_url='/oauth/access_token/',\n            authorize_url='/oauth/authorize/',\n            base_url='https://api.instagram.com/',\n            consumer_key=id,\n            consumer_secret=secret,\n            request_token_params=token_params\n        )\n        return config", "category": "Python"}, {"instruction": "def cublasZgerc(handle, m, n, alpha, x, incx, y, incy, A, lda):\n    \"\"\"\n    Rank-1 operation on complex general matrix.\n\n    \"\"\"\n", "input": "", "output": "\n    status = _libcublas.cublasZgerc_v2(handle,\n                                       m, n, ctypes.byref(cuda.cuDoubleComplex(alpha.real,\n                                                                               alpha.imag)),\n                                       int(x), incx, int(y), incy, int(A), lda)\n    cublasCheckStatus(status)", "category": "Python"}, {"instruction": "def track_exists(self, localdir):\n        \"\"\" Check if track exists in local directory. \"\"\"\n", "input": "", "output": "        path = glob.glob(self.gen_localdir(localdir) +\n                         self.gen_filename() + \"*\")\n        if len(path) > 0 and os.path.getsize(path[0]) > 0:\n            return True\n        return False", "category": "Python"}, {"instruction": "def conf_merger(user_dict, variable):\n    \"\"\"\n    Merge global configuration with user's personal configuration.\n\n    Global configuration has always higher priority.\n    \"\"\"\n", "input": "", "output": "    if variable not in globals().keys():\n        raise NameError(\"Unknown variable '%s'.\" % variable)\n\n    if variable not in user_dict:\n        return globals()[variable]\n\n    return globals()[variable] and user_dict[variable]", "category": "Python"}, {"instruction": "def _CopyDateFromString(self, date_string):\n    \"\"\"Copies a date from a string.\n\n    Args:\n      date_string (str): date value formatted as: YYYY-MM-DD\n\n    Returns:\n      tuple[int, int, int]: year, month, day of month.\n\n    Raises:\n      ValueError: if the date string is invalid or not supported.\n    \"\"\"\n", "input": "", "output": "    date_string_length = len(date_string)\n\n    # The date string should at least contain 'YYYY-MM-DD'.\n    if date_string_length < 10:\n      raise ValueError('Date string too short.')\n\n    if date_string[4] != '-' or date_string[7] != '-':\n      raise ValueError('Invalid date string.')\n\n    try:\n      year = int(date_string[0:4], 10)\n    except ValueError:\n      raise ValueError('Unable to parse year.')\n\n    try:\n      month = int(date_string[5:7], 10)\n    except ValueError:\n      raise ValueError('Unable to parse month.')\n\n    try:\n      day_of_month = int(date_string[8:10], 10)\n    except ValueError:\n      raise ValueError('Unable to parse day of month.')\n\n    days_per_month = self._GetDaysPerMonth(year, month)\n    if day_of_month < 1 or day_of_month > days_per_month:\n      raise ValueError('Day of month value out of bounds.')\n\n    return year, month, day_of_month", "category": "Python"}, {"instruction": "def cmpxchg(self, ptr, cmp, val, ordering, failordering=None, name=''):\n        \"\"\"\n        Atomic compared-and-set:\n            atomic {\n                old = *ptr\n                success = (old == cmp)\n                if (success)\n                    *ptr = val\n                }\n            name = { old, success }\n\n        If failordering is `None`, the value of `ordering` is used.\n        \"\"\"\n", "input": "", "output": "        failordering = ordering if failordering is None else failordering\n        inst = instructions.CmpXchg(self.block, ptr, cmp, val, ordering,\n                                    failordering, name=name)\n        self._insert(inst)\n        return inst", "category": "Python"}, {"instruction": "def create_powerflow_problem(timerange, components):\n    \"\"\"\n    Create PyPSA network object and fill with data\n    Parameters\n    ----------\n    timerange: Pandas DatetimeIndex\n        Time range to be analyzed by PF\n    components: dict\n    Returns\n    -------\n    network: PyPSA powerflow problem object\n    \"\"\"\n", "input": "", "output": "\n    # initialize powerflow problem\n    network, snapshots = init_pypsa_network(timerange)\n\n    # add components to network\n    for component in components.keys():\n        network.import_components_from_dataframe(components[component],\n                                                 component)\n\n    return network, snapshots", "category": "Python"}, {"instruction": "def loadXMLGenericData(filename):  # not tested\n    \"\"\"Read any type of vtk data object encoded in XML format. Return an ``Actor(vtkActor)`` object.\"\"\"\n", "input": "", "output": "    reader = vtk.vtkXMLGenericDataObjectReader()\n    reader.SetFileName(filename)\n    reader.Update()\n    return Actor(reader.GetOutput())", "category": "Python"}, {"instruction": "def txt_line_iterator(txt_path):\n  \"\"\"Iterate through lines of file.\"\"\"\n", "input": "", "output": "  with tf.gfile.Open(txt_path) as f:\n    for line in f:\n      yield line.strip()", "category": "Python"}, {"instruction": "def update_metadata_from_rmd_options(name, value, metadata):\n    \"\"\"\n    Update metadata using the _BOOLEAN_OPTIONS_DICTIONARY mapping\n    :param name: option name\n    :param value: option value\n    :param metadata:\n    :return:\n    \"\"\"\n", "input": "", "output": "    for jupyter_option, rmd_option, rev in _BOOLEAN_OPTIONS_DICTIONARY:\n        if name == rmd_option:\n            try:\n                metadata[jupyter_option] = _py_logical_values(value) != rev\n                return True\n            except RLogicalValueError:\n                pass\n    return False", "category": "Python"}, {"instruction": "def _startReapingProcesses(self):\n        \"\"\"\n        Start a LoopingCall that calls reapAllProcesses.\n        \"\"\"\n", "input": "", "output": "        lc = LoopingCall(self._reapAllProcesses)\n        lc.clock = self._reactor\n        lc.start(0.1, False)", "category": "Python"}, {"instruction": "def _refresh_editor_and_scrollbars(self):\n        \"\"\"\n        Refrehes editor content and scollbars.\n\n        We generate a fake resize event to refresh scroll bar.\n\n        We have the same problem as described here:\n        http://www.qtcentre.org/threads/44803 and we apply the same solution\n        (don't worry, there is no visual effect, the editor does not grow up\n        at all, even with a value = 500)\n        \"\"\"\n", "input": "", "output": "        TextHelper(self.editor).mark_whole_doc_dirty()\n        self.editor.repaint()\n        s = self.editor.size()\n        s.setWidth(s.width() + 1)\n        self.editor.resizeEvent(QResizeEvent(self.editor.size(), s))", "category": "Python"}, {"instruction": "def open(hdfs_path, mode=\"r\", buff_size=0, replication=0, blocksize=0,\n         user=None, encoding=None, errors=None):\n    \"\"\"\n    Open a file, returning an :class:`~.file.hdfs_file` object.\n\n    ``hdfs_path`` and ``user`` are passed to :func:`~path.split`,\n    while the other args are passed to the :class:`~.file.hdfs_file`\n    constructor.\n    \"\"\"\n", "input": "", "output": "    host, port, path_ = path.split(hdfs_path, user)\n    fs = hdfs(host, port, user)\n    return fs.open_file(path_, mode, buff_size, replication, blocksize,\n                        encoding, errors)", "category": "Python"}, {"instruction": "def abrt(self, s=None, post=None, noraise=False):\n        \"\"\" Prints the abrt banner and raises ``ProgressAbrt`` exception\n\n        When ``noraise`` flag is set to ``True``, then the exception is not\n        raised, and progress is allowed to continue.\n\n        If ``post`` function is supplied it is invoked with no arguments after\n        the close banner is printed, but before exceptions are raised. The\n        ``post`` function takes no arguments.\n        \"\"\"\n", "input": "", "output": "        s = s or self.abrt_msg\n        self.printer(self.color.red(s))\n        if post:\n            post()\n        if noraise:\n            return\n        raise ProgressAbrt()", "category": "Python"}, {"instruction": "def load_fn_matches_ext(file_path, file_type):\n    \"\"\"\n    Check that the file extension matches the target extension given.\n\n    :param str file_path: Path to be checked\n    :param str file_type: Target extension\n    :return bool correct_ext: Extension match or does not match\n    \"\"\"\n", "input": "", "output": "    correct_ext = False\n    curr_ext = os.path.splitext(file_path)[1]\n    exts = [curr_ext, file_type]\n    try:\n        # special case: if file type is excel, both extensions are valid.\n        if \".xlsx\" in exts and \".xls\" in exts:\n            correct_ext = True\n        elif curr_ext == file_type:\n            correct_ext = True\n        else:\n            print(\"Use '{}' to load this file: {}\".format(FILE_TYPE_MAP[curr_ext][\"load_fn\"],\n                                                          os.path.basename(file_path)))\n    except Exception as e:\n        logger_misc.debug(\"load_fn_matches_ext: {}\".format(e))\n\n    return correct_ext", "category": "Python"}, {"instruction": "def getControls(self):\n        '''\n        Calculates consumption for each consumer of this type using the consumption functions.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        None\n        '''\n", "input": "", "output": "        cLvlNow = np.zeros(self.AgentCount) + np.nan\n        MPCnow = np.zeros(self.AgentCount) + np.nan\n        for t in range(self.T_cycle):\n            these = t == self.t_cycle\n            cLvlNow[these] = self.solution[t].cFunc(self.mLvlNow[these],self.pLvlNow[these])\n            MPCnow[these]  = self.solution[t].cFunc.derivativeX(self.mLvlNow[these],self.pLvlNow[these])\n        self.cLvlNow = cLvlNow\n        self.MPCnow  = MPCnow", "category": "Python"}, {"instruction": "def _loop_thread_main(self):\n        \"\"\"Main background thread running the event loop.\"\"\"\n", "input": "", "output": "\n        asyncio.set_event_loop(self.loop)\n        self._loop_check.inside_loop = True\n\n        try:\n            self._logger.debug(\"Starting loop in background thread\")\n            self.loop.run_forever()\n            self._logger.debug(\"Finished loop in background thread\")\n        except:  # pylint:disable=bare-except;This is a background worker thread.\n            self._logger.exception(\"Exception raised from event loop thread\")\n        finally:\n            self.loop.close()", "category": "Python"}, {"instruction": "def _is_not_considered_falsey(value, ignore_types=()):\n    '''\n    Helper function for filter_falsey to determine if something is not to be\n    considered falsey.\n\n    :param any value: The value to consider\n    :param list ignore_types: The types to ignore when considering the value.\n\n    :return bool\n    '''\n", "input": "", "output": "    return isinstance(value, bool) or type(value) in ignore_types or value", "category": "Python"}, {"instruction": "def _sendAction(self, action, attrs=None, chan_vars=None):\n        \"\"\"Send action to Asterisk Manager Interface.\n        \n        @param action:    Action name\n        @param attrs:     Tuple of key-value pairs for action attributes.\n        @param chan_vars: Tuple of key-value pairs for channel variables.\n\n        \"\"\"\n", "input": "", "output": "        self._conn.write(\"Action: %s\\r\\n\" % action)\n        if attrs:\n            for (key,val) in attrs:\n                self._conn.write(\"%s: %s\\r\\n\" % (key, val))\n        if chan_vars:\n            for (key,val) in chan_vars:\n                self._conn.write(\"Variable: %s=%s\\r\\n\" % (key, val))\n        self._conn.write(\"\\r\\n\")", "category": "Python"}, {"instruction": "def get_host_address(host=None, default_address=DEFAULT_HOST_IP):\n    \"\"\"\n    Returns the given host address.\n\n    :param host: Host to retrieve the address.\n    :type host: unicode\n    :param default_address: Default address if the host is unreachable.\n    :type default_address: unicode\n    :return: Host address.\n    :rtype: unicode\n    \"\"\"\n", "input": "", "output": "\n    try:\n        return unicode(socket.gethostbyname(host or socket.gethostname()),\n                       Constants.default_codec,\n                       Constants.codec_error)\n    except Exception as error:\n        return default_address", "category": "Python"}, {"instruction": "def _serialize_parameters(parameters):\n        \"\"\"Serialize some parameters to match python native types with formats\n        specified in google api docs like:\n        * True/False -> \"true\"/\"false\",\n        * {\"a\": 1, \"b\":2} -> \"a:1|b:2\"\n\n        :type parameters: dict oif query parameters\n        \"\"\"\n", "input": "", "output": "\n        for key, value in parameters.items():\n            if isinstance(value, bool):\n                parameters[key] = \"true\" if value else \"false\"\n            elif isinstance(value, dict):\n                parameters[key] = \"|\".join(\n                    (\"%s:%s\" % (k, v) for k, v in value.items()))\n            elif isinstance(value, (list, tuple)):\n                parameters[key] = \"|\".join(value)\n        return parameters", "category": "Python"}, {"instruction": "def delete_cors(Bucket,\n           region=None, key=None, keyid=None, profile=None):\n    '''\n    Delete the CORS configuration for the given bucket\n\n    Returns {deleted: true} if CORS was deleted and returns\n    {deleted: False} if CORS was not deleted.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt myminion boto_s3_bucket.delete_cors my_bucket\n\n    '''\n", "input": "", "output": "\n    try:\n        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)\n        conn.delete_bucket_cors(Bucket=Bucket)\n        return {'deleted': True, 'name': Bucket}\n    except ClientError as e:\n        return {'deleted': False, 'error': __utils__['boto3.get_error'](e)}", "category": "Python"}, {"instruction": "def getResourceMapPid(self):\n        \"\"\"Returns:\n\n        str : PID of the Resource Map itself.\n\n        \"\"\"\n", "input": "", "output": "        ore = [\n            o for o in self.subjects(predicate=rdflib.RDF.type, object=ORE.ResourceMap)\n        ][0]\n        pid = [str(o) for o in self.objects(predicate=DCTERMS.identifier, subject=ore)][\n            0\n        ]\n        return pid", "category": "Python"}, {"instruction": "def shp2geom(shp_fn):\n    \"\"\"Extract geometries from input shapefile\n    \n    Need to handle multi-part geom: http://osgeo-org.1560.x6.nabble.com/Multipart-to-singlepart-td3746767.html\n    \"\"\"\n", "input": "", "output": "    ds = ogr.Open(shp_fn)\n    lyr = ds.GetLayer()\n    srs = lyr.GetSpatialRef()\n    lyr.ResetReading()\n    geom_list = []\n    for feat in lyr:\n        geom = feat.GetGeometryRef()\n        geom.AssignSpatialReference(srs)\n        #Duplicate the geometry, or segfault\n        #See: http://trac.osgeo.org/gdal/wiki/PythonGotchas\n        #g = ogr.CreateGeometryFromWkt(geom.ExportToWkt())\n        #g.AssignSpatialReference(srs)\n        g = geom_dup(geom)\n        geom_list.append(g)\n    #geom = ogr.ForceToPolygon(' '.join(geom_list))    \n    #Dissolve should convert multipolygon to single polygon \n    #return geom_list[0]\n    ds = None\n    return geom_list", "category": "Python"}, {"instruction": "def voidage_experimental(m, rho, D, H):\n    r'''Calculates voidage of a bed or mesh given an experimental weight and\n    fixed density, diameter, and height, as shown in [1]_. The formula is also\n    self-evident.\n\n    .. math::\n        \\epsilon = 1 - \\frac{\\frac{m_{mesh}}{\\frac{\\pi}{4}d_{column}^2\n        L_{mesh}}}{\\rho_{material}}\n\n    Parameters\n    ----------\n    m : float\n        Mass of mesh or bed particles weighted, [kg]\n    rho : float\n        Density of solid particles or mesh [kg/m^3]\n    D : float\n        Diameter of the cylindrical bed [m]\n    H : float\n        Height of the demister or bed [m]\n\n    Returns\n    -------\n    voidage : float\n        Voidage of bed of the material []\n\n    Notes\n    -----\n    Should be trusted over manufacturer data.\n\n    Examples\n    --------\n    >>> voidage_experimental(m=126, rho=8000, D=1, H=1)\n    0.9799464771704212\n\n    References\n    ----------\n    .. [1] Hels\u00f8r, T., and H. Svendsen. \"Experimental Characterization of\n       Pressure Drop in Dry Demisters at Low and Elevated Pressures.\" Chemical\n       Engineering Research and Design 85, no. 3 (2007): 377-85.\n       doi:10.1205/cherd06048.\n    '''\n", "input": "", "output": "    return 1 - m/(pi/4*D**2*H)/rho", "category": "Python"}, {"instruction": "def get_html_output(self):\n        \"\"\" Return line generator. \"\"\"\n", "input": "", "output": "        def html_splitlines(lines):\n            # this cool function was taken from trac.\n            # http://projects.edgewall.com/trac/\n            open_tag_re = re.compile(r'<(\\w+)(\\s.*)?[^/]?>')\n            close_tag_re = re.compile(r'</(\\w+)>')\n            open_tags = []\n            for line in lines:\n                for tag in open_tags:\n                    line = tag.group(0) + line\n                open_tags = []\n                for tag in open_tag_re.finditer(line):\n                    open_tags.append(tag)\n                open_tags.reverse()\n                for ctag in close_tag_re.finditer(line):\n                    for otag in open_tags:\n                        if otag.group(1) == ctag.group(1):\n                            open_tags.remove(otag)\n                            break\n                for tag in open_tags:\n                    line += '</%s>' % tag.group(1)\n                yield line\n\n        if self.error:\n            return escape(self.raw).splitlines()\n        return list(html_splitlines(self.out.getvalue().splitlines()))", "category": "Python"}, {"instruction": "Sets up the current instance using members from the passed data object.\n\n@param {Object} aData               An object with members of the duration\n@param {Number} aData.weeks         Duration in weeks\n@param {Number} aData.days          Duration in days\n@param {Number} aData.hours         Duration in hours\n@param {Number} aData.minutes       Duration in minutes\n@param {Number} aData.seconds       Duration in seconds\n@param {Boolean} aData.isNegative   If true, the duration is negative", "input": "JavaScript", "output": "function fromData(aData) {\n      var propsToCopy = [\"weeks\", \"days\", \"hours\",\n                         \"minutes\", \"seconds\", \"isNegative\"];\n      for (var key in propsToCopy) {\n        /* istanbul ignore if */\n        if (!propsToCopy.hasOwnProperty(key)) {\n          continue;\n        }\n        var prop = propsToCopy[key];\n        if (aData && prop in aData) {\n          this[prop] = aData[prop];\n        } else {\n          this[prop] = 0;\n        }\n      }\n    }", "category": "Python"}, {"instruction": "/* make sligthly rotated, scaled and mirrored variants of the input image /* can be useful to increase the training set in order to get better results /* but also training time increases with numJitters", "input": "JavaScript", "output": "function makeGetJitteredFaces(fr) {\n  return function(face, numJitters) {\n    if (numJitters && (face.rows !== face.cols)) {\n      throw new Error('jittering requires the face to have the same number of rows and cols')\n    }\n    return [face].concat(!numJitters ? [] : fr.jitterImage(face, numJitters))\n  }\n}", "category": "Python"}, {"instruction": "Move the access token from the request body to the request header", "input": "JavaScript", "output": "function formatRequest(p, qs) {\n\t\tvar token = qs.access_token;\n\t\tdelete qs.access_token;\n\t\tp.headers.Authorization = 'Bearer ' + token;\n\n\t\treturn true;\n\t}", "category": "Python"}, {"instruction": "// newEndpointImpl creates a new endpoint for the given resourceName.\n// This is to be used during normal device plugin registration.", "input": "go language", "output": "func newEndpointImpl(socketPath, resourceName string, callback monitorCallback) (*endpointImpl, error) {\n\tclient, c, err := dial(socketPath)\n\tif err != nil {\n\t\tklog.Errorf(\"Can't create new endpoint with path %s err %v\", socketPath, err)\n\t\treturn nil, err\n\t}\n\n\treturn &endpointImpl{\n\t\tclient:     client,\n\t\tclientConn: c,\n\n\t\tsocketPath:   socketPath,\n\t\tresourceName: resourceName,\n\n\t\tcb: callback,\n\t}, nil\n}", "category": "Python"}, {"instruction": "// NewPSTMTPlanCacheKey creates a new pstmtPlanCacheKey object.", "input": "go language", "output": "func NewPSTMTPlanCacheKey(sessionVars *variable.SessionVars, pstmtID uint32, schemaVersion int64) kvcache.Key {\n\ttimezoneOffset := 0\n\tif sessionVars.TimeZone != nil {\n\t\t_, timezoneOffset = time.Now().In(sessionVars.TimeZone).Zone()\n\t}\n\treturn &pstmtPlanCacheKey{\n\t\tdatabase:       sessionVars.CurrentDB,\n\t\tconnID:         sessionVars.ConnectionID,\n\t\tpstmtID:        pstmtID,\n\t\tsnapshot:       sessionVars.SnapshotTS,\n\t\tschemaVersion:  schemaVersion,\n\t\tsqlMode:        sessionVars.SQLMode,\n\t\ttimezoneOffset: timezoneOffset,\n\t}\n}", "category": "Python"}, {"instruction": "// KillApplicationTasks provides a mock function with given fields: applicationID, opts", "input": "go language", "output": "func (_m *Marathon) KillApplicationTasks(applicationID string, opts *marathon.KillApplicationTasksOpts) (*marathon.Tasks, error) {\n\tret := _m.Called(applicationID, opts)\n\n\tvar r0 *marathon.Tasks\n\tif rf, ok := ret.Get(0).(func(string, *marathon.KillApplicationTasksOpts) *marathon.Tasks); ok {\n\t\tr0 = rf(applicationID, opts)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(*marathon.Tasks)\n\t\t}\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(string, *marathon.KillApplicationTasksOpts) error); ok {\n\t\tr1 = rf(applicationID, opts)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}", "category": "Python"}, {"instruction": "// getBucketScore gets the score for merge this bucket with previous one.\n// TODO: We also need to consider the bucket hit count.", "input": "go language", "output": "func getBucketScore(bkts []bucket, totalCount float64, id int) bucketScore {\n\tpreCount, count := float64(bkts[id-1].Count), float64(bkts[id].Count)\n\t// do not merge if the result bucket is too large\n\tif (preCount + count) > maxBucketFraction*totalCount {\n\t\treturn bucketScore{id, math.MaxFloat64}\n\t}\n\t// Merge them if the result bucket is already too small.\n\tif (preCount + count) < minBucketFraction*totalCount {\n\t\treturn bucketScore{id, 0}\n\t}\n\tlow, mid, high := bkts[id-1].Lower, bkts[id-1].Upper, bkts[id].Upper\n\t// If we choose to merge, err is the absolute estimate error for the previous bucket.\n\terr := calcFraction4Datums(low, high, mid)*(preCount+count) - preCount\n\treturn bucketScore{id, math.Abs(err / (preCount + count))}\n}", "category": "Python"}, {"instruction": "// RegisterConversions adds conversion functions to the given scheme.\n// Public to allow building arbitrary schemes.", "input": "go language", "output": "func RegisterConversions(s *runtime.Scheme) error {\n\tif err := s.AddGeneratedConversionFunc((*Configuration)(nil), (*podtolerationrestriction.Configuration)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_v1alpha1_Configuration_To_podtolerationrestriction_Configuration(a.(*Configuration), b.(*podtolerationrestriction.Configuration), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := s.AddGeneratedConversionFunc((*podtolerationrestriction.Configuration)(nil), (*Configuration)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_podtolerationrestriction_Configuration_To_v1alpha1_Configuration(a.(*podtolerationrestriction.Configuration), b.(*Configuration), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// New creates rate limiter middleware.", "input": "go language", "output": "func New(ctx context.Context, next http.Handler, config config.RateLimit, name string) (http.Handler, error) {\n\tmiddlewares.GetLogger(ctx, name, typeName).Debug(\"Creating middleware\")\n\n\textractFunc, err := utils.NewExtractor(config.ExtractorFunc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trateSet := ratelimit.NewRateSet()\n\tfor _, rate := range config.RateSet {\n\t\tif err = rateSet.Add(time.Duration(rate.Period), rate.Average, rate.Burst); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\trl, err := ratelimit.New(next, extractFunc, rateSet)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &rateLimiter{handler: rl, name: name}, nil\n}", "category": "Python"}, {"instruction": "// DropTable will proceed even if some table in the list does not exists.", "input": "go language", "output": "func (d *ddl) DropTable(ctx sessionctx.Context, ti ast.Ident) (err error) {\n\tschema, tb, err := d.getSchemaAndTableByIdent(ctx, ti)\n\tif err != nil {\n\t\treturn errors.Trace(err)\n\t}\n\n\tjob := &model.Job{\n\t\tSchemaID:   schema.ID,\n\t\tTableID:    tb.Meta().ID,\n\t\tType:       model.ActionDropTable,\n\t\tBinlogInfo: &model.HistoryInfo{},\n\t}\n\n\terr = d.doDDLJob(ctx, job)\n\terr = d.callHookOnChanged(err)\n\treturn errors.Trace(err)\n}", "category": "Python"}, {"instruction": "// Deprecated informs about a deprecation, but only once for a given set of arguments' values.\n// If the err flag is enabled, it logs as an ERROR (will exit with -1) and the text will\n// point at the next Hugo release.\n// The idea is two remove an item in two Hugo releases to give users and theme authors\n// plenty of time to fix their templates.", "input": "go language", "output": "func Deprecated(object, item, alternative string, err bool) {\n\tif !strings.HasSuffix(alternative, \".\") {\n\t\talternative += \".\"\n\t}\n\n\tif err {\n\t\tDistinctErrorLog.Printf(\"%s's %s is deprecated and will be removed in Hugo %s. %s\", object, item, hugo.CurrentVersion.Next().ReleaseVersion(), alternative)\n\n\t} else {\n\t\tDistinctWarnLog.Printf(\"%s's %s is deprecated and will be removed in a future release. %s\", object, item, alternative)\n\t}\n}", "category": "Python"}, {"instruction": "// inferTypeFromDefault contains the logic for the old method of inferring\n// variable types - we can also use this for validating that the declared\n// type matches the type of the default value", "input": "go language", "output": "func (v *Variable) inferTypeFromDefault() VariableType {\n\tif v.Default == nil {\n\t\treturn VariableTypeString\n\t}\n\n\tvar s string\n\tif err := hilmapstructure.WeakDecode(v.Default, &s); err == nil {\n\t\tv.Default = s\n\t\treturn VariableTypeString\n\t}\n\n\tvar m map[string]interface{}\n\tif err := hilmapstructure.WeakDecode(v.Default, &m); err == nil {\n\t\tv.Default = m\n\t\treturn VariableTypeMap\n\t}\n\n\tvar l []interface{}\n\tif err := hilmapstructure.WeakDecode(v.Default, &l); err == nil {\n\t\tv.Default = l\n\t\treturn VariableTypeList\n\t}\n\n\treturn VariableTypeUnknown\n}", "category": "Python"}, {"instruction": "// NewOperationGenerator is returns instance of operationGenerator", "input": "go language", "output": "func NewOperationGenerator(kubeClient clientset.Interface,\n\tvolumePluginMgr *volume.VolumePluginMgr,\n\trecorder record.EventRecorder,\n\tcheckNodeCapabilitiesBeforeMount bool,\n\tblkUtil volumepathhandler.BlockVolumePathHandler) OperationGenerator {\n\n\treturn &operationGenerator{\n\t\tkubeClient:                       kubeClient,\n\t\tvolumePluginMgr:                  volumePluginMgr,\n\t\trecorder:                         recorder,\n\t\tcheckNodeCapabilitiesBeforeMount: checkNodeCapabilitiesBeforeMount,\n\t\tblkUtil:                          blkUtil,\n\t}\n}", "category": "Python"}, {"instruction": "// DeleteTeam will delete a team, its member and any permissions connected to the team", "input": "go language", "output": "func DeleteTeam(cmd *m.DeleteTeamCommand) error {\n\treturn inTransaction(func(sess *DBSession) error {\n\t\tif _, err := teamExists(cmd.OrgId, cmd.Id, sess); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tdeletes := []string{\n\t\t\t\"DELETE FROM team_member WHERE org_id=? and team_id = ?\",\n\t\t\t\"DELETE FROM team WHERE org_id=? and id = ?\",\n\t\t\t\"DELETE FROM dashboard_acl WHERE org_id=? and team_id = ?\",\n\t\t}\n\n\t\tfor _, sql := range deletes {\n\t\t\t_, err := sess.Exec(sql, cmd.OrgId, cmd.Id)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}", "category": "Python"}, {"instruction": "// Open implements the Executor Open interface.", "input": "go language", "output": "func (e *CleanupIndexExec) Open(ctx context.Context) error {\n\tif err := e.baseExecutor.Open(ctx); err != nil {\n\t\treturn err\n\t}\n\te.idxChunk = chunk.New(e.getIdxColTypes(), e.initCap, e.maxChunkSize)\n\te.idxValues = make(map[int64][][]types.Datum, e.batchSize)\n\te.batchKeys = make([]kv.Key, 0, e.batchSize)\n\te.idxValsBufs = make([][]types.Datum, e.batchSize)\n\tsc := e.ctx.GetSessionVars().StmtCtx\n\tidxKey, _, err := e.index.GenIndexKey(sc, []types.Datum{{}}, math.MinInt64, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\te.lastIdxKey = idxKey\n\treturn nil\n}", "category": "Python"}, {"instruction": "// UnusedFilename finds a filename that isn't already used by a file in\n// the receiving sources and returns it.\n//\n// The given \"proposed\" name is returned verbatim if it isn't already used.\n// Otherwise, the function will try appending incrementing integers to the\n// proposed name until an unused name is found. Callers should propose names\n// that they do not expect to already be in use so that numeric suffixes are\n// only used in rare cases.\n//\n// The proposed name must end in either \".tf\" or \".tf.json\" because a\n// ModuleSources only has visibility into such files. This function will\n// panic if given a file whose name does not end with one of these\n// extensions.\n//\n// A ModuleSources only works on one directory at a time, so the proposed\n// name must not contain any directory separator characters.", "input": "go language", "output": "func (ms ModuleSources) UnusedFilename(proposed string) string {\n\text := fileExt(proposed)\n\tif ext == \"\" {\n\t\tpanic(fmt.Errorf(\"method UnusedFilename used with invalid proposal %q\", proposed))\n\t}\n\n\tif _, exists := ms[proposed]; !exists {\n\t\treturn proposed\n\t}\n\n\tbase := proposed[:len(proposed)-len(ext)]\n\tfor i := 1; ; i++ {\n\t\ttry := fmt.Sprintf(\"%s-%d%s\", base, i, ext)\n\t\tif _, exists := ms[try]; !exists {\n\t\t\treturn try\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// Create creates Kubernetes resources from an io.reader.\n//\n// Namespace will set the namespace.", "input": "go language", "output": "func (c *Client) Create(namespace string, reader io.Reader, timeout int64, shouldWait bool) error {\n\tclient, err := c.KubernetesClientSet()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := ensureNamespace(client, namespace); err != nil {\n\t\treturn err\n\t}\n\tc.Log(\"building resources from manifest\")\n\tinfos, buildErr := c.BuildUnstructured(namespace, reader)\n\tif buildErr != nil {\n\t\treturn buildErr\n\t}\n\tc.Log(\"creating %d resource(s)\", len(infos))\n\tif err := perform(infos, createResource); err != nil {\n\t\treturn err\n\t}\n\tif shouldWait {\n\t\treturn c.waitForResources(time.Duration(timeout)*time.Second, infos)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// increments priority of the given child and reorders if necessary.", "input": "go language", "output": "func (n *node) incrementChildPrio(pos int) int {\n\tn.children[pos].priority++\n\tprio := n.children[pos].priority\n\n\t// adjust position (move to front)\n\tnewPos := pos\n\tfor newPos > 0 && n.children[newPos-1].priority < prio {\n\t\t// swap node positions\n\t\tn.children[newPos-1], n.children[newPos] = n.children[newPos], n.children[newPos-1]\n\n\t\tnewPos--\n\t}\n\n\t// build new index char string\n\tif newPos != pos {\n\t\tn.indices = n.indices[:newPos] + // unchanged prefix, might be empty\n\t\t\tn.indices[pos:pos+1] + // the index char we move\n\t\t\tn.indices[newPos:pos] + n.indices[pos+1:] // rest without char at 'pos'\n\t}\n\n\treturn newPos\n}", "category": "Python"}, {"instruction": "// nodesWatch is used to watch the list of available nodes", "input": "go language", "output": "func nodesWatch(params map[string]interface{}) (WatcherFunc, error) {\n\tstale := false\n\tif err := assignValueBool(params, \"stale\", &stale); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfn := func(p *Plan) (BlockingParamVal, interface{}, error) {\n\t\tcatalog := p.client.Catalog()\n\t\topts := makeQueryOptionsWithContext(p, stale)\n\t\tdefer p.cancelFunc()\n\t\tnodes, meta, err := catalog.Nodes(&opts)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\treturn WaitIndexVal(meta.LastIndex), nodes, err\n\t}\n\treturn fn, nil\n}", "category": "Python"}, {"instruction": "// PerformStaticPodUpgrade performs the upgrade of the control plane components for a static pod hosted cluster", "input": "go language", "output": "func PerformStaticPodUpgrade(client clientset.Interface, waiter apiclient.Waiter, internalcfg *kubeadmapi.InitConfiguration, etcdUpgrade, renewCerts bool) error {\n\tpathManager, err := GetPathManagerForUpgrade(internalcfg, etcdUpgrade)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// The arguments oldEtcdClient and newEtdClient, are uninitialized because passing in the clients allow for mocking the client during testing\n\treturn upgrade.StaticPodControlPlane(client, waiter, pathManager, internalcfg, etcdUpgrade, renewCerts, nil, nil)\n}", "category": "Python"}, {"instruction": "// StringFlagPutHandler wraps an http Handler to set string type flag.", "input": "go language", "output": "func StringFlagPutHandler(setter StringFlagSetterFunc) http.HandlerFunc {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\tswitch {\n\t\tcase req.Method == \"PUT\":\n\t\t\tbody, err := ioutil.ReadAll(req.Body)\n\t\t\tif err != nil {\n\t\t\t\twritePlainText(http.StatusBadRequest, \"error reading request body: \"+err.Error(), w)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer req.Body.Close()\n\t\t\tresponse, err := setter(string(body))\n\t\t\tif err != nil {\n\t\t\t\twritePlainText(http.StatusBadRequest, err.Error(), w)\n\t\t\t\treturn\n\t\t\t}\n\t\t\twritePlainText(http.StatusOK, response, w)\n\t\t\treturn\n\t\tdefault:\n\t\t\twritePlainText(http.StatusNotAcceptable, \"unsupported http method\", w)\n\t\t\treturn\n\t\t}\n\t})\n}", "category": "Python"}, {"instruction": "// grantColumnPriv manipulates mysql.tables_priv table.", "input": "go language", "output": "func (e *GrantExec) grantColumnPriv(priv *ast.PrivElem, user *ast.UserSpec) error {\n\tdbName, tbl, err := getTargetSchemaAndTable(e.ctx, e.Level.DBName, e.Level.TableName, e.is)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, c := range priv.Cols {\n\t\tcol := table.FindCol(tbl.Cols(), c.Name.L)\n\t\tif col == nil {\n\t\t\treturn errors.Errorf(\"Unknown column: %s\", c)\n\t\t}\n\t\tasgns, err := composeColumnPrivUpdateForGrant(e.ctx, priv.Priv, user.User.Username, user.User.Hostname, dbName, tbl.Meta().Name.O, col.Name.O)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsql := fmt.Sprintf(`UPDATE %s.%s SET %s WHERE User='%s' AND Host='%s' AND DB='%s' AND Table_name='%s' AND Column_name='%s';`, mysql.SystemDB, mysql.ColumnPrivTable, asgns, user.User.Username, user.User.Hostname, dbName, tbl.Meta().Name.O, col.Name.O)\n\t\t_, _, err = e.ctx.(sqlexec.RestrictedSQLExecutor).ExecRestrictedSQL(e.ctx, sql)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Validate if the remote version is one Minor release newer than the client version.\n// This is done to conform with \"stable-X\" and only allow remote versions from\n// the same Patch level release.", "input": "go language", "output": "func validateStableVersion(remoteVersion, clientVersion string) (string, error) {\n\tverRemote, err := versionutil.ParseGeneric(remoteVersion)\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"remote version error\")\n\t}\n\tverClient, err := versionutil.ParseGeneric(clientVersion)\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"client version error\")\n\t}\n\t// If the remote Major version is bigger or if the Major versions are the same,\n\t// but the remote Minor is bigger use the client version release. This handles Major bumps too.\n\tif verClient.Major() < verRemote.Major() ||\n\t\t(verClient.Major() == verRemote.Major()) && verClient.Minor() < verRemote.Minor() {\n\t\testimatedRelease := fmt.Sprintf(\"stable-%d.%d\", verClient.Major(), verClient.Minor())\n\t\tklog.Infof(\"remote version is much newer: %s; falling back to: %s\", remoteVersion, estimatedRelease)\n\t\treturn estimatedRelease, nil\n\t}\n\treturn remoteVersion, nil\n}", "category": "Python"}, {"instruction": "// NewController returns a new instance of the IPAM controller.", "input": "go language", "output": "func NewController(\n\tconfig *Config,\n\tkubeClient clientset.Interface,\n\tcloud cloudprovider.Interface,\n\tclusterCIDR, serviceCIDR *net.IPNet,\n\tnodeCIDRMaskSize int) (*Controller, error) {\n\n\tif !nodesync.IsValidMode(config.Mode) {\n\t\treturn nil, fmt.Errorf(\"invalid IPAM controller mode %q\", config.Mode)\n\t}\n\n\tgceCloud, ok := cloud.(*gce.Cloud)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"cloud IPAM controller does not support %q provider\", cloud.ProviderName())\n\t}\n\n\tset, err := cidrset.NewCIDRSet(clusterCIDR, nodeCIDRMaskSize)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := &Controller{\n\t\tconfig:  config,\n\t\tadapter: newAdapter(kubeClient, gceCloud),\n\t\tsyncers: make(map[string]*nodesync.NodeSync),\n\t\tset:     set,\n\t}\n\n\tif err := occupyServiceCIDR(c.set, clusterCIDR, serviceCIDR); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn c, nil\n}", "category": "Python"}, {"instruction": "// OnDigest notifies the engine that a digest has arrived", "input": "go language", "output": "func (engine *PullEngine) OnDigest(digest []string, nonce uint64, context interface{}) {\n\tif !engine.isAcceptingDigests() || !engine.outgoingNONCES.Exists(nonce) {\n\t\treturn\n\t}\n\n\tengine.lock.Lock()\n\tdefer engine.lock.Unlock()\n\n\tfor _, n := range digest {\n\t\tif engine.state.Exists(n) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif _, exists := engine.item2owners[n]; !exists {\n\t\t\tengine.item2owners[n] = make([]string, 0)\n\t\t}\n\n\t\tengine.item2owners[n] = append(engine.item2owners[n], engine.nonces2peers[nonce])\n\t}\n}", "category": "Python"}, {"instruction": "// filterNodeDump is used to filter through all parts of a node dump and\n// remove elements the provided ACL token cannot access.", "input": "go language", "output": "func (f *aclFilter) filterNodeDump(dump *structs.NodeDump) {\n\tnd := *dump\n\tfor i := 0; i < len(nd); i++ {\n\t\tinfo := nd[i]\n\n\t\t// Filter nodes\n\t\tif node := info.Node; !f.allowNode(node) {\n\t\t\tf.logger.Printf(\"[DEBUG] consul: dropping node %q from result due to ACLs\", node)\n\t\t\tnd = append(nd[:i], nd[i+1:]...)\n\t\t\ti--\n\t\t\tcontinue\n\t\t}\n\n\t\t// Filter services\n\t\tfor j := 0; j < len(info.Services); j++ {\n\t\t\tsvc := info.Services[j].Service\n\t\t\tif f.allowService(svc) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tf.logger.Printf(\"[DEBUG] consul: dropping service %q from result due to ACLs\", svc)\n\t\t\tinfo.Services = append(info.Services[:j], info.Services[j+1:]...)\n\t\t\tj--\n\t\t}\n\n\t\t// Filter checks\n\t\tfor j := 0; j < len(info.Checks); j++ {\n\t\t\tchk := info.Checks[j]\n\t\t\tif f.allowService(chk.ServiceName) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tf.logger.Printf(\"[DEBUG] consul: dropping check %q from result due to ACLs\", chk.CheckID)\n\t\t\tinfo.Checks = append(info.Checks[:j], info.Checks[j+1:]...)\n\t\t\tj--\n\t\t}\n\t}\n\t*dump = nd\n}", "category": "Python"}, {"instruction": "// Parse API configuration from parameters or secret", "input": "go language", "output": "func parseAPIConfig(params map[string]string) (*storageosAPIConfig, error) {\n\n\tif len(params) == 0 {\n\t\treturn nil, fmt.Errorf(\"empty API config\")\n\t}\n\n\tc := &storageosAPIConfig{}\n\n\tfor name, data := range params {\n\t\tswitch strings.ToLower(name) {\n\t\tcase \"apiaddress\":\n\t\t\tc.apiAddr = string(data)\n\t\tcase \"apiusername\":\n\t\t\tc.apiUser = string(data)\n\t\tcase \"apipassword\":\n\t\t\tc.apiPass = string(data)\n\t\tcase \"apiversion\":\n\t\t\tc.apiVersion = string(data)\n\t\t}\n\t}\n\n\treturn c, nil\n}", "category": "Python"}, {"instruction": "// evalString evals a builtinPasswordSig.\n// See https://dev.mysql.com/doc/refman/5.7/en/encryption-functions.html#function_password", "input": "go language", "output": "func (b *builtinPasswordSig) evalString(row chunk.Row) (d string, isNull bool, err error) {\n\tpass, isNull, err := b.args[0].EvalString(b.ctx, row)\n\tif isNull || err != nil {\n\t\treturn \"\", err != nil, err\n\t}\n\n\tif len(pass) == 0 {\n\t\treturn \"\", false, nil\n\t}\n\n\t// We should append a warning here because function \"PASSWORD\" is deprecated since MySQL 5.7.6.\n\t// See https://dev.mysql.com/doc/refman/5.7/en/encryption-functions.html#function_password\n\tb.ctx.GetSessionVars().StmtCtx.AppendWarning(errDeprecatedSyntaxNoReplacement.GenWithStackByArgs(\"PASSWORD\"))\n\n\treturn auth.EncodePassword(pass), false, nil\n}", "category": "Python"}, {"instruction": "// LockOpts returns a handle to a lock struct which can be used\n// to acquire and release the mutex. The key used must have\n// write permissions.", "input": "go language", "output": "func (c *Client) LockOpts(opts *LockOptions) (*Lock, error) {\n\tif opts.Key == \"\" {\n\t\treturn nil, fmt.Errorf(\"missing key\")\n\t}\n\tif opts.SessionName == \"\" {\n\t\topts.SessionName = DefaultLockSessionName\n\t}\n\tif opts.SessionTTL == \"\" {\n\t\topts.SessionTTL = DefaultLockSessionTTL\n\t} else {\n\t\tif _, err := time.ParseDuration(opts.SessionTTL); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid SessionTTL: %v\", err)\n\t\t}\n\t}\n\tif opts.MonitorRetryTime == 0 {\n\t\topts.MonitorRetryTime = DefaultMonitorRetryTime\n\t}\n\tif opts.LockWaitTime == 0 {\n\t\topts.LockWaitTime = DefaultLockWaitTime\n\t}\n\tl := &Lock{\n\t\tc:    c,\n\t\topts: opts,\n\t}\n\treturn l, nil\n}", "category": "Python"}, {"instruction": "// GetModifiedAccountsByNumber returns all accounts that have changed between the\n// two blocks specified. A change is defined as a difference in nonce, balance,\n// code hash, or storage hash.\n//\n// With one parameter, returns the list of accounts modified in the specified block.", "input": "go language", "output": "func (api *PrivateDebugAPI) GetModifiedAccountsByNumber(startNum uint64, endNum *uint64) ([]common.Address, error) {\n\tvar startBlock, endBlock *types.Block\n\n\tstartBlock = api.eth.blockchain.GetBlockByNumber(startNum)\n\tif startBlock == nil {\n\t\treturn nil, fmt.Errorf(\"start block %x not found\", startNum)\n\t}\n\n\tif endNum == nil {\n\t\tendBlock = startBlock\n\t\tstartBlock = api.eth.blockchain.GetBlockByHash(startBlock.ParentHash())\n\t\tif startBlock == nil {\n\t\t\treturn nil, fmt.Errorf(\"block %x has no parent\", endBlock.Number())\n\t\t}\n\t} else {\n\t\tendBlock = api.eth.blockchain.GetBlockByNumber(*endNum)\n\t\tif endBlock == nil {\n\t\t\treturn nil, fmt.Errorf(\"end block %d not found\", *endNum)\n\t\t}\n\t}\n\treturn api.getModifiedAccounts(startBlock, endBlock)\n}", "category": "Python"}, {"instruction": "// SwarmUpdate updates the swarm.", "input": "go language", "output": "func (cli *Client) SwarmUpdate(ctx context.Context, version swarm.Version, swarm swarm.Spec, flags swarm.UpdateFlags) error {\n\tquery := url.Values{}\n\tquery.Set(\"version\", strconv.FormatUint(version.Index, 10))\n\tquery.Set(\"rotateWorkerToken\", fmt.Sprintf(\"%v\", flags.RotateWorkerToken))\n\tquery.Set(\"rotateManagerToken\", fmt.Sprintf(\"%v\", flags.RotateManagerToken))\n\tquery.Set(\"rotateManagerUnlockKey\", fmt.Sprintf(\"%v\", flags.RotateManagerUnlockKey))\n\tresp, err := cli.post(ctx, \"/swarm/update\", query, swarm, nil)\n\tensureReaderClosed(resp)\n\treturn err\n}", "category": "Python"}, {"instruction": "// ExpectDeletions records expectations for the given deleteKeys, against the given controller.", "input": "go language", "output": "func (u *UIDTrackingControllerExpectations) ExpectDeletions(rcKey string, deletedKeys []string) error {\n\tu.uidStoreLock.Lock()\n\tdefer u.uidStoreLock.Unlock()\n\n\tif existing := u.GetUIDs(rcKey); existing != nil && existing.Len() != 0 {\n\t\tklog.Errorf(\"Clobbering existing delete keys: %+v\", existing)\n\t}\n\texpectedUIDs := sets.NewString()\n\tfor _, k := range deletedKeys {\n\t\texpectedUIDs.Insert(k)\n\t}\n\tklog.V(4).Infof(\"Controller %v waiting on deletions for: %+v\", rcKey, deletedKeys)\n\tif err := u.uidStore.Add(&UIDSet{expectedUIDs, rcKey}); err != nil {\n\t\treturn err\n\t}\n\treturn u.ControllerExpectationsInterface.ExpectDeletions(rcKey, expectedUIDs.Len())\n}", "category": "Python"}, {"instruction": "// Format produces and returns a text representation of the receiving plan\n// intended for display in a terminal.\n//\n// If color is not nil, it is used to colorize the output.", "input": "go language", "output": "func (p *Plan) Format(color *colorstring.Colorize) string {\n\tif p.Empty() {\n\t\treturn \"This plan does nothing.\"\n\t}\n\n\tif color == nil {\n\t\tcolor = &colorstring.Colorize{\n\t\t\tColors: colorstring.DefaultColors,\n\t\t\tReset:  false,\n\t\t}\n\t}\n\n\t// Find the longest path length of all the paths that are changing,\n\t// so we can align them all.\n\tkeyLen := 0\n\tfor _, r := range p.Resources {\n\t\tfor _, attr := range r.Attributes {\n\t\t\tkey := attr.Path\n\n\t\t\tif len(key) > keyLen {\n\t\t\t\tkeyLen = len(key)\n\t\t\t}\n\t\t}\n\t}\n\n\tbuf := new(bytes.Buffer)\n\tfor _, r := range p.Resources {\n\t\tformatPlanInstanceDiff(buf, r, keyLen, color)\n\t}\n\n\treturn strings.TrimSpace(buf.String())\n}", "category": "Python"}, {"instruction": "// parseMessageBlock", "input": "go language", "output": "func parseMessageBlock(data []byte) (*hapi.Metadata, *SumCollection, error) {\n\t// This sucks.\n\tparts := bytes.Split(data, []byte(\"\\n...\\n\"))\n\tif len(parts) < 2 {\n\t\treturn nil, nil, errors.New(\"message block must have at least two parts\")\n\t}\n\n\tmd := &hapi.Metadata{}\n\tsc := &SumCollection{}\n\n\tif err := yaml.Unmarshal(parts[0], md); err != nil {\n\t\treturn md, sc, err\n\t}\n\terr := yaml.Unmarshal(parts[1], sc)\n\treturn md, sc, err\n}", "category": "Python"}, {"instruction": "// CountStmtNode records the number of statements with the same type.", "input": "go language", "output": "func CountStmtNode(stmtNode ast.StmtNode, inRestrictedSQL bool) {\n\tif inRestrictedSQL {\n\t\treturn\n\t}\n\n\ttypeLabel := GetStmtLabel(stmtNode)\n\tswitch typeLabel {\n\tcase \"Use\":\n\t\tstmtNodeCounterUse.Inc()\n\tcase \"Show\":\n\t\tstmtNodeCounterShow.Inc()\n\tcase \"Begin\":\n\t\tstmtNodeCounterBegin.Inc()\n\tcase \"Commit\":\n\t\tstmtNodeCounterCommit.Inc()\n\tcase \"Rollback\":\n\t\tstmtNodeCounterRollback.Inc()\n\tcase \"Insert\":\n\t\tstmtNodeCounterInsert.Inc()\n\tcase \"Replace\":\n\t\tstmtNodeCounterReplace.Inc()\n\tcase \"Delete\":\n\t\tstmtNodeCounterDelete.Inc()\n\tcase \"Update\":\n\t\tstmtNodeCounterUpdate.Inc()\n\tcase \"Select\":\n\t\tstmtNodeCounterSelect.Inc()\n\tdefault:\n\t\tmetrics.StmtNodeCounter.WithLabelValues(typeLabel).Inc()\n\t}\n\n\tif !config.GetGlobalConfig().Status.RecordQPSbyDB {\n\t\treturn\n\t}\n\n\tdbLabels := getStmtDbLabel(stmtNode)\n\tfor dbLabel := range dbLabels {\n\t\tmetrics.DbStmtNodeCounter.WithLabelValues(dbLabel, typeLabel).Inc()\n\t}\n}", "category": "Python"}, {"instruction": "// SignCertificate creates a signed certificate based on a built-in template\n// and saves it in baseDir/name", "input": "go language", "output": "func (ca *CA) SignCertificate(baseDir, name string, ous, sans []string, pub *ecdsa.PublicKey,\n\tku x509.KeyUsage, eku []x509.ExtKeyUsage) (*x509.Certificate, error) {\n\n\ttemplate := x509Template()\n\ttemplate.KeyUsage = ku\n\ttemplate.ExtKeyUsage = eku\n\n\t//set the organization for the subject\n\tsubject := subjectTemplateAdditional(ca.Country, ca.Province, ca.Locality, ca.OrganizationalUnit, ca.StreetAddress, ca.PostalCode)\n\tsubject.CommonName = name\n\n\tsubject.OrganizationalUnit = append(subject.OrganizationalUnit, ous...)\n\n\ttemplate.Subject = subject\n\tfor _, san := range sans {\n\t\t// try to parse as an IP address first\n\t\tip := net.ParseIP(san)\n\t\tif ip != nil {\n\t\t\ttemplate.IPAddresses = append(template.IPAddresses, ip)\n\t\t} else {\n\t\t\ttemplate.DNSNames = append(template.DNSNames, san)\n\t\t}\n\t}\n\n\tcert, err := genCertificateECDSA(baseDir, name, &template, ca.SignCert,\n\t\tpub, ca.Signer)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cert, nil\n}", "category": "Python"}, {"instruction": "// convertPodNamedPortToNumber converts named ports into port numbers\n// It returns an error when a named port can't be found in the pod containers", "input": "go language", "output": "func convertPodNamedPortToNumber(ports []string, pod corev1.Pod) ([]string, error) {\n\tvar converted []string\n\tfor _, port := range ports {\n\t\tlocalPort, remotePort := splitPort(port)\n\n\t\tcontainerPortStr := remotePort\n\t\t_, err := strconv.Atoi(remotePort)\n\t\tif err != nil {\n\t\t\tcontainerPort, err := util.LookupContainerPortNumberByName(pod, remotePort)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tcontainerPortStr = strconv.Itoa(int(containerPort))\n\t\t}\n\n\t\tif localPort != remotePort {\n\t\t\tconverted = append(converted, fmt.Sprintf(\"%s:%s\", localPort, containerPortStr))\n\t\t} else {\n\t\t\tconverted = append(converted, containerPortStr)\n\t\t}\n\t}\n\n\treturn converted, nil\n}", "category": "Python"}, {"instruction": "// ShardRowID shards the implicit row ID by adding shard value to the row ID's first few bits.", "input": "go language", "output": "func (d *ddl) ShardRowID(ctx sessionctx.Context, tableIdent ast.Ident, uVal uint64) error {\n\tschema, t, err := d.getSchemaAndTableByIdent(ctx, tableIdent)\n\tif err != nil {\n\t\treturn errors.Trace(err)\n\t}\n\tok, _ := hasAutoIncrementColumn(t.Meta())\n\tif ok && uVal != 0 {\n\t\treturn errUnsupportedShardRowIDBits\n\t}\n\tif uVal == t.Meta().ShardRowIDBits {\n\t\t// Nothing need to do.\n\t\treturn nil\n\t}\n\terr = verifyNoOverflowShardBits(d.sessPool, t, uVal)\n\tif err != nil {\n\t\treturn err\n\t}\n\tjob := &model.Job{\n\t\tType:       model.ActionShardRowID,\n\t\tSchemaID:   schema.ID,\n\t\tTableID:    t.Meta().ID,\n\t\tBinlogInfo: &model.HistoryInfo{},\n\t\tArgs:       []interface{}{uVal},\n\t}\n\terr = d.doDDLJob(ctx, job)\n\terr = d.callHookOnChanged(err)\n\treturn errors.Trace(err)\n}", "category": "Python"}, {"instruction": "// getH2Settings returns the []http2.Setting that are encoded in the\n// HTTP2-Settings header.", "input": "go language", "output": "func getH2Settings(h http.Header) ([]http2.Setting, error) {\n\tvals, ok := h[textproto.CanonicalMIMEHeaderKey(\"HTTP2-Settings\")]\n\tif !ok {\n\t\treturn nil, errors.New(\"missing HTTP2-Settings header\")\n\t}\n\tif len(vals) != 1 {\n\t\treturn nil, fmt.Errorf(\"expected 1 HTTP2-Settings. Got: %v\", vals)\n\t}\n\tsettings, err := decodeSettings(vals[0])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid HTTP2-Settings: %q\", vals[0])\n\t}\n\treturn settings, nil\n}", "category": "Python"}, {"instruction": "// Start starts a containerd daemon and monitors it", "input": "go language", "output": "func Start(ctx context.Context, rootDir, stateDir string, opts ...DaemonOpt) (Daemon, error) {\n\tr := &remote{\n\t\trootDir:  rootDir,\n\t\tstateDir: stateDir,\n\t\tConfig: config.Config{\n\t\t\tRoot:  filepath.Join(rootDir, \"daemon\"),\n\t\t\tState: filepath.Join(stateDir, \"daemon\"),\n\t\t},\n\t\tpluginConfs:   pluginConfigs{make(map[string]interface{})},\n\t\tdaemonPid:     -1,\n\t\tlogger:        logrus.WithField(\"module\", \"libcontainerd\"),\n\t\tdaemonStartCh: make(chan error, 1),\n\t\tdaemonStopCh:  make(chan struct{}),\n\t}\n\n\tfor _, opt := range opts {\n\t\tif err := opt(r); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tr.setDefaults()\n\n\tif err := system.MkdirAll(stateDir, 0700, \"\"); err != nil {\n\t\treturn nil, err\n\t}\n\n\tgo r.monitorDaemon(ctx)\n\n\tselect {\n\tcase <-time.After(startupTimeout):\n\t\treturn nil, errors.New(\"timeout waiting for containerd to start\")\n\tcase err := <-r.daemonStartCh:\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn r, nil\n}", "category": "Python"}, {"instruction": "// Evaluate uses the PolicyChecker to determine if a request should be allowed.\n// The decision is cached until the identity expires or the chain configuration\n// changes.", "input": "go language", "output": "func (ac *SessionAccessControl) Evaluate() error {\n\tif !ac.sessionEndTime.IsZero() && time.Now().After(ac.sessionEndTime) {\n\t\treturn errors.Errorf(\"client identity expired %v before\", time.Since(ac.sessionEndTime))\n\t}\n\n\tpolicyCheckNeeded := !ac.usedAtLeastOnce\n\n\tif currentConfigSequence := ac.sequencer.Sequence(); currentConfigSequence > ac.lastConfigSequence {\n\t\tac.lastConfigSequence = currentConfigSequence\n\t\tpolicyCheckNeeded = true\n\t}\n\n\tif !policyCheckNeeded {\n\t\treturn nil\n\t}\n\n\tac.usedAtLeastOnce = true\n\treturn ac.policyChecker.CheckPolicy(ac.envelope, ac.channelID)\n}", "category": "Python"}, {"instruction": "// vcConnect connects to vCenter with existing credentials\n// If credentials are invalid:\n// \t\t1. It will fetch credentials from credentialManager\n//      2. Update the credentials\n//\t\t3. Connects again to vCenter with fetched credentials", "input": "go language", "output": "func (nm *NodeManager) vcConnect(ctx context.Context, vsphereInstance *VSphereInstance) error {\n\terr := vsphereInstance.conn.Connect(ctx)\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\tcredentialManager := nm.CredentialManager()\n\tif !vclib.IsInvalidCredentialsError(err) || credentialManager == nil {\n\t\tklog.Errorf(\"Cannot connect to vCenter with err: %v\", err)\n\t\treturn err\n\t}\n\n\tklog.V(4).Infof(\"Invalid credentials. Cannot connect to server %q. Fetching credentials from secrets.\", vsphereInstance.conn.Hostname)\n\n\t// Get latest credentials from SecretCredentialManager\n\tcredentials, err := credentialManager.GetCredential(vsphereInstance.conn.Hostname)\n\tif err != nil {\n\t\tklog.Errorf(\"Failed to get credentials from Secret Credential Manager with err: %v\", err)\n\t\treturn err\n\t}\n\tvsphereInstance.conn.UpdateCredentials(credentials.User, credentials.Password)\n\treturn vsphereInstance.conn.Connect(ctx)\n}", "category": "Python"}, {"instruction": "// LastRevision finds the second max revision number in all replica sets (the last revision)", "input": "go language", "output": "func LastRevision(allRSs []*apps.ReplicaSet) int64 {\n\tmax, secMax := int64(0), int64(0)\n\tfor _, rs := range allRSs {\n\t\tif v, err := Revision(rs); err != nil {\n\t\t\t// Skip the replica sets when it failed to parse their revision information\n\t\t\tklog.V(4).Infof(\"Error: %v. Couldn't parse revision for replica set %#v, deployment controller will skip it when reconciling revisions.\", err, rs)\n\t\t} else if v >= max {\n\t\t\tsecMax = max\n\t\t\tmax = v\n\t\t} else if v > secMax {\n\t\t\tsecMax = v\n\t\t}\n\t}\n\treturn secMax\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *HorizontalPodAutoscalerSpec) DeepCopyInto(out *HorizontalPodAutoscalerSpec) {\n\t*out = *in\n\tout.ScaleTargetRef = in.ScaleTargetRef\n\tif in.MinReplicas != nil {\n\t\tin, out := &in.MinReplicas, &out.MinReplicas\n\t\t*out = new(int32)\n\t\t**out = **in\n\t}\n\tif in.TargetCPUUtilizationPercentage != nil {\n\t\tin, out := &in.TargetCPUUtilizationPercentage, &out.TargetCPUUtilizationPercentage\n\t\t*out = new(int32)\n\t\t**out = **in\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// IsConfigBlock validates whenever given block contains configuration\n// update transaction", "input": "go language", "output": "func IsConfigBlock(block *cb.Block) bool {\n\tenvelope, err := ExtractEnvelope(block, 0)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tpayload, err := GetPayload(envelope)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif payload.Header == nil {\n\t\treturn false\n\t}\n\n\thdr, err := UnmarshalChannelHeader(payload.Header.ChannelHeader)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn cb.HeaderType(hdr.Type) == cb.HeaderType_CONFIG || cb.HeaderType(hdr.Type) == cb.HeaderType_ORDERER_TRANSACTION\n}", "category": "Python"}, {"instruction": "// InsertTxn adds a new tombstone.", "input": "go language", "output": "func (g *Graveyard) InsertTxn(tx *memdb.Txn, key string, idx uint64) error {\n\t// Insert the tombstone.\n\tstone := &Tombstone{Key: key, Index: idx}\n\tif err := tx.Insert(\"tombstones\", stone); err != nil {\n\t\treturn fmt.Errorf(\"failed inserting tombstone: %s\", err)\n\t}\n\n\tif err := tx.Insert(\"index\", &IndexEntry{\"tombstones\", idx}); err != nil {\n\t\treturn fmt.Errorf(\"failed updating index: %s\", err)\n\t}\n\n\t// If GC is configured, then we hint that this index requires reaping.\n\tif g.gc != nil {\n\t\ttx.Defer(func() { g.gc.Hint(idx) })\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Update takes the representation of a horizontalPodAutoscaler and updates it. Returns the server's representation of the horizontalPodAutoscaler, and an error, if there is any.", "input": "go language", "output": "func (c *FakeHorizontalPodAutoscalers) Update(horizontalPodAutoscaler *v2beta1.HorizontalPodAutoscaler) (result *v2beta1.HorizontalPodAutoscaler, err error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewUpdateAction(horizontalpodautoscalersResource, c.ns, horizontalPodAutoscaler), &v2beta1.HorizontalPodAutoscaler{})\n\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\treturn obj.(*v2beta1.HorizontalPodAutoscaler), err\n}", "category": "Python"}, {"instruction": "// ValidateObjectMetaUpdate validates an object's metadata when updated", "input": "go language", "output": "func ValidateObjectMetaUpdate(newMeta, oldMeta *metav1.ObjectMeta, fldPath *field.Path) field.ErrorList {\n\tnewMetadata, err := meta.Accessor(newMeta)\n\tif err != nil {\n\t\tallErrs := field.ErrorList{}\n\t\tallErrs = append(allErrs, field.Invalid(fldPath, newMeta, err.Error()))\n\t\treturn allErrs\n\t}\n\toldMetadata, err := meta.Accessor(oldMeta)\n\tif err != nil {\n\t\tallErrs := field.ErrorList{}\n\t\tallErrs = append(allErrs, field.Invalid(fldPath, oldMeta, err.Error()))\n\t\treturn allErrs\n\t}\n\treturn ValidateObjectMetaAccessorUpdate(newMetadata, oldMetadata, fldPath)\n}", "category": "Python"}, {"instruction": "// start starts the progressReporter", "input": "go language", "output": "func (p *progressReporter) start() {\n\tgo func() {\n\t\tticker := time.NewTicker(defaultImagePullingProgressReportInterval)\n\t\tdefer ticker.Stop()\n\t\tfor {\n\t\t\t// TODO(random-liu): Report as events.\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\tprogress, timestamp := p.progress.get()\n\t\t\t\t// If there is no progress for p.imagePullProgressDeadline, cancel the operation.\n\t\t\t\tif time.Since(timestamp) > p.imagePullProgressDeadline {\n\t\t\t\t\tklog.Errorf(\"Cancel pulling image %q because of no progress for %v, latest progress: %q\", p.image, p.imagePullProgressDeadline, progress)\n\t\t\t\t\tp.cancel()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tklog.V(2).Infof(\"Pulling image %q: %q\", p.image, progress)\n\t\t\tcase <-p.stopCh:\n\t\t\t\tprogress, _ := p.progress.get()\n\t\t\t\tklog.V(2).Infof(\"Stop pulling image %q: %q\", p.image, progress)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n}", "category": "Python"}, {"instruction": "// SetLocalSystemVar sets values of the local variables which in \"server\" scope.", "input": "go language", "output": "func SetLocalSystemVar(name string, val string) {\n\tswitch name {\n\tcase TiDBDDLReorgWorkerCount:\n\t\tSetDDLReorgWorkerCounter(int32(tidbOptPositiveInt32(val, DefTiDBDDLReorgWorkerCount)))\n\tcase TiDBDDLReorgBatchSize:\n\t\tSetDDLReorgBatchSize(int32(tidbOptPositiveInt32(val, DefTiDBDDLReorgBatchSize)))\n\tcase TiDBDDLErrorCountLimit:\n\t\tSetDDLErrorCountLimit(tidbOptInt64(val, DefTiDBDDLErrorCountLimit))\n\t}\n}", "category": "Python"}, {"instruction": "// PatchNodeTaints patches node's taints.", "input": "go language", "output": "func PatchNodeTaints(c clientset.Interface, nodeName string, oldNode *v1.Node, newNode *v1.Node) error {\n\toldData, err := json.Marshal(oldNode)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal old node %#v for node %q: %v\", oldNode, nodeName, err)\n\t}\n\n\tnewTaints := newNode.Spec.Taints\n\tnewNodeClone := oldNode.DeepCopy()\n\tnewNodeClone.Spec.Taints = newTaints\n\tnewData, err := json.Marshal(newNodeClone)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal new node %#v for node %q: %v\", newNodeClone, nodeName, err)\n\t}\n\n\tpatchBytes, err := strategicpatch.CreateTwoWayMergePatch(oldData, newData, v1.Node{})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create patch for node %q: %v\", nodeName, err)\n\t}\n\n\t_, err = c.CoreV1().Nodes().Patch(nodeName, types.StrategicMergePatchType, patchBytes)\n\treturn err\n}", "category": "Python"}, {"instruction": "// WriteError translates a CRI streaming error into an appropriate HTTP response.", "input": "go language", "output": "func WriteError(err error, w http.ResponseWriter) error {\n\tvar status int\n\tswitch grpc.Code(err) {\n\tcase codes.NotFound:\n\t\tstatus = http.StatusNotFound\n\tcase codes.ResourceExhausted:\n\t\t// We only expect to hit this if there is a DoS, so we just wait the full TTL.\n\t\t// If this is ever hit in steady-state operations, consider increasing the maxInFlight requests,\n\t\t// or plumbing through the time to next expiration.\n\t\tw.Header().Set(\"Retry-After\", strconv.Itoa(int(cacheTTL.Seconds())))\n\t\tstatus = http.StatusTooManyRequests\n\tdefault:\n\t\tstatus = http.StatusInternalServerError\n\t}\n\tw.WriteHeader(status)\n\t_, writeErr := w.Write([]byte(err.Error()))\n\treturn writeErr\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *Policy) DeepCopyInto(out *Policy) {\n\t*out = *in\n\tout.TypeMeta = in.TypeMeta\n\tif in.Predicates != nil {\n\t\tin, out := &in.Predicates, &out.Predicates\n\t\t*out = make([]PredicatePolicy, len(*in))\n\t\tfor i := range *in {\n\t\t\t(*in)[i].DeepCopyInto(&(*out)[i])\n\t\t}\n\t}\n\tif in.Priorities != nil {\n\t\tin, out := &in.Priorities, &out.Priorities\n\t\t*out = make([]PriorityPolicy, len(*in))\n\t\tfor i := range *in {\n\t\t\t(*in)[i].DeepCopyInto(&(*out)[i])\n\t\t}\n\t}\n\tif in.ExtenderConfigs != nil {\n\t\tin, out := &in.ExtenderConfigs, &out.ExtenderConfigs\n\t\t*out = make([]ExtenderConfig, len(*in))\n\t\tfor i := range *in {\n\t\t\t(*in)[i].DeepCopyInto(&(*out)[i])\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// getPullSecretsForPod inspects the Pod and retrieves the referenced pull\n// secrets.", "input": "go language", "output": "func (kl *Kubelet) getPullSecretsForPod(pod *v1.Pod) []v1.Secret {\n\tpullSecrets := []v1.Secret{}\n\n\tfor _, secretRef := range pod.Spec.ImagePullSecrets {\n\t\tsecret, err := kl.secretManager.GetSecret(pod.Namespace, secretRef.Name)\n\t\tif err != nil {\n\t\t\tklog.Warningf(\"Unable to retrieve pull secret %s/%s for %s/%s due to %v.  The image pull may not succeed.\", pod.Namespace, secretRef.Name, pod.Namespace, pod.Name, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tpullSecrets = append(pullSecrets, *secret)\n\t}\n\n\treturn pullSecrets\n}", "category": "Python"}, {"instruction": "// NewHub creates a new hardware wallet manager for smartcards.", "input": "go language", "output": "func NewHub(scheme string, datadir string) (*Hub, error) {\n\tcontext, err := pcsc.EstablishContext(pcsc.ScopeSystem)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thub := &Hub{\n\t\tscheme:  scheme,\n\t\tcontext: context,\n\t\tdatadir: datadir,\n\t\twallets: make(map[string]*Wallet),\n\t\tquit:    make(chan chan error),\n\t}\n\tif err := hub.readPairings(); err != nil {\n\t\treturn nil, err\n\t}\n\thub.refreshWallets()\n\treturn hub, nil\n}", "category": "Python"}, {"instruction": "// ReceivedReply adjusts estimated buffer value according to the value included in\n// the latest request reply.", "input": "go language", "output": "func (node *ServerNode) ReceivedReply(reqID, bv uint64) {\n\tnode.lock.Lock()\n\tdefer node.lock.Unlock()\n\n\tnow := node.clock.Now()\n\tnode.recalcBLE(now)\n\tif bv > node.params.BufLimit {\n\t\tbv = node.params.BufLimit\n\t}\n\tsc, ok := node.pending[reqID]\n\tif !ok {\n\t\treturn\n\t}\n\tdelete(node.pending, reqID)\n\tcc := node.sumCost - sc\n\tnewEstimate := uint64(0)\n\tif bv > cc {\n\t\tnewEstimate = bv - cc\n\t}\n\tif newEstimate > node.bufEstimate {\n\t\t// Note: we never reduce the buffer estimate based on the reported value because\n\t\t// this can only happen because of the delayed delivery of the latest reply.\n\t\t// The lowest estimate based on the previous reply can still be considered valid.\n\t\tnode.bufEstimate = newEstimate\n\t}\n\n\tnode.bufRecharge = node.bufEstimate < node.params.BufLimit\n\tnode.lastTime = now\n\tif node.log != nil {\n\t\tnode.log.add(now, fmt.Sprintf(\"received  reqID=%d  bufEst=%d  reportedBv=%d  sumCost=%d  oldSumCost=%d\", reqID, node.bufEstimate, bv, node.sumCost, sc))\n\t}\n}", "category": "Python"}, {"instruction": "// ValidateObjectMetaUpdate validates an object's metadata when updated", "input": "go language", "output": "func ValidateObjectMetaUpdate(newMeta, oldMeta *metav1.ObjectMeta, fldPath *field.Path) field.ErrorList {\n\tallErrs := apimachineryvalidation.ValidateObjectMetaUpdate(newMeta, oldMeta, fldPath)\n\t// run additional checks for the finalizer name\n\tfor i := range newMeta.Finalizers {\n\t\tallErrs = append(allErrs, validateKubeFinalizerName(string(newMeta.Finalizers[i]), fldPath.Child(\"finalizers\").Index(i))...)\n\t}\n\n\treturn allErrs\n}", "category": "Python"}, {"instruction": "// startTableWorker launchs some background goroutines which pick tasks from workCh and execute the task.", "input": "go language", "output": "func (e *IndexLookUpExecutor) startTableWorker(ctx context.Context, workCh <-chan *lookupTableTask) {\n\tlookupConcurrencyLimit := e.ctx.GetSessionVars().IndexLookupConcurrency\n\te.tblWorkerWg.Add(lookupConcurrencyLimit)\n\tfor i := 0; i < lookupConcurrencyLimit; i++ {\n\t\tworker := &tableWorker{\n\t\t\tidxLookup:      e,\n\t\t\tworkCh:         workCh,\n\t\t\tfinished:       e.finished,\n\t\t\tbuildTblReader: e.buildTableReader,\n\t\t\tkeepOrder:      e.keepOrder,\n\t\t\thandleIdx:      e.handleIdx,\n\t\t\tisCheckOp:      e.isCheckOp,\n\t\t\tmemTracker:     memory.NewTracker(tableWorkerLabel, -1),\n\t\t}\n\t\tworker.memTracker.AttachTo(e.memTracker)\n\t\tctx1, cancel := context.WithCancel(ctx)\n\t\tgo func() {\n\t\t\tworker.pickAndExecTask(ctx1)\n\t\t\tcancel()\n\t\t\te.tblWorkerWg.Done()\n\t\t}()\n\t}\n}", "category": "Python"}, {"instruction": "// DefaultAttachFunc is the default AttachFunc used", "input": "go language", "output": "func DefaultAttachFunc(o *AttachOptions, containerToAttach *corev1.Container, raw bool, sizeQueue remotecommand.TerminalSizeQueue) func() error {\n\treturn func() error {\n\t\trestClient, err := restclient.RESTClientFor(o.Config)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treq := restClient.Post().\n\t\t\tResource(\"pods\").\n\t\t\tName(o.Pod.Name).\n\t\t\tNamespace(o.Pod.Namespace).\n\t\t\tSubResource(\"attach\")\n\t\treq.VersionedParams(&corev1.PodAttachOptions{\n\t\t\tContainer: containerToAttach.Name,\n\t\t\tStdin:     o.Stdin,\n\t\t\tStdout:    o.Out != nil,\n\t\t\tStderr:    !o.DisableStderr,\n\t\t\tTTY:       raw,\n\t\t}, scheme.ParameterCodec)\n\n\t\treturn o.Attach.Attach(\"POST\", req.URL(), o.Config, o.In, o.Out, o.ErrOut, raw, sizeQueue)\n\t}\n}", "category": "Python"}, {"instruction": "// DeriveStats implement LogicalPlan DeriveStats interface.", "input": "go language", "output": "func (la *LogicalApply) DeriveStats(childStats []*property.StatsInfo) (*property.StatsInfo, error) {\n\tleftProfile := childStats[0]\n\tla.stats = &property.StatsInfo{\n\t\tRowCount:    leftProfile.RowCount,\n\t\tCardinality: make([]float64, la.schema.Len()),\n\t}\n\tcopy(la.stats.Cardinality, leftProfile.Cardinality)\n\tif la.JoinType == LeftOuterSemiJoin || la.JoinType == AntiLeftOuterSemiJoin {\n\t\tla.stats.Cardinality[len(la.stats.Cardinality)-1] = 2.0\n\t} else {\n\t\tfor i := la.children[0].Schema().Len(); i < la.schema.Len(); i++ {\n\t\t\tla.stats.Cardinality[i] = leftProfile.RowCount\n\t\t}\n\t}\n\treturn la.stats, nil\n}", "category": "Python"}, {"instruction": "// NodePublishVolume implements CSI NodePublishVolume", "input": "go language", "output": "func (f *NodeClient) NodePublishVolume(ctx context.Context, req *csipb.NodePublishVolumeRequest, opts ...grpc.CallOption) (*csipb.NodePublishVolumeResponse, error) {\n\tif f.nextErr != nil {\n\t\treturn nil, f.nextErr\n\t}\n\n\tif req.GetVolumeId() == \"\" {\n\t\treturn nil, errors.New(\"missing volume id\")\n\t}\n\tif req.GetTargetPath() == \"\" {\n\t\treturn nil, errors.New(\"missing target path\")\n\t}\n\tfsTypes := \"block|ext4|xfs|zfs\"\n\tfsType := req.GetVolumeCapability().GetMount().GetFsType()\n\tif !strings.Contains(fsTypes, fsType) {\n\t\treturn nil, errors.New(\"invalid fstype\")\n\t}\n\tf.nodePublishedVolumes[req.GetVolumeId()] = CSIVolume{\n\t\tVolumeHandle:    req.GetVolumeId(),\n\t\tPath:            req.GetTargetPath(),\n\t\tDeviceMountPath: req.GetStagingTargetPath(),\n\t\tVolumeContext:   req.GetVolumeContext(),\n\t\tFSType:          req.GetVolumeCapability().GetMount().GetFsType(),\n\t\tMountFlags:      req.GetVolumeCapability().GetMount().MountFlags,\n\t}\n\treturn &csipb.NodePublishVolumeResponse{}, nil\n}", "category": "Python"}, {"instruction": "// Will insert if needed any new key/value pars and return ids", "input": "go language", "output": "func (r *SqlAnnotationRepo) ensureTagsExist(sess *DBSession, tags []*models.Tag) ([]*models.Tag, error) {\n\tfor _, tag := range tags {\n\t\tvar existingTag models.Tag\n\n\t\t// check if it exists\n\t\tif exists, err := sess.Table(\"tag\").Where(dialect.Quote(\"key\")+\"=? AND \"+dialect.Quote(\"value\")+\"=?\", tag.Key, tag.Value).Get(&existingTag); err != nil {\n\t\t\treturn nil, err\n\t\t} else if exists {\n\t\t\ttag.Id = existingTag.Id\n\t\t} else {\n\t\t\tif _, err := sess.Table(\"tag\").Insert(tag); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn tags, nil\n}", "category": "Python"}, {"instruction": "// Check if a proposed update can be committed.", "input": "go language", "output": "func (p *MemoryPool) checkUpdate(transactionData []tms.TransactionData) error {\n\tfor _, td := range transactionData {\n\t\taction := td.Tx.GetPlainAction()\n\t\tif action == nil {\n\t\t\treturn errors.Errorf(\"check update failed for transaction '%s': missing token action\", td.TxID)\n\t\t}\n\n\t\terr := p.checkAction(action, td.TxID)\n\t\tif err != nil {\n\t\t\treturn errors.WithMessage(err, \"check update failed\")\n\t\t}\n\n\t\tif p.history[td.TxID] != nil {\n\t\t\treturn errors.Errorf(\"transaction already exists: %s\", td.TxID)\n\t\t}\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// TranslateCSIPVToInTree takes a PV with CSIPersistentVolumeSource set and\n// translates the GCE PD CSI source to a GCEPersistentDisk source.", "input": "go language", "output": "func (g *gcePersistentDiskCSITranslator) TranslateCSIPVToInTree(pv *v1.PersistentVolume) (*v1.PersistentVolume, error) {\n\tif pv == nil || pv.Spec.CSI == nil {\n\t\treturn nil, fmt.Errorf(\"pv is nil or CSI source not defined on pv\")\n\t}\n\tcsiSource := pv.Spec.CSI\n\n\tpdName, err := pdNameFromVolumeID(csiSource.VolumeHandle)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tgceSource := &v1.GCEPersistentDiskVolumeSource{\n\t\tPDName:   pdName,\n\t\tFSType:   csiSource.FSType,\n\t\tReadOnly: csiSource.ReadOnly,\n\t}\n\tif partition, ok := csiSource.VolumeAttributes[\"partition\"]; ok && partition != \"\" {\n\t\tpartInt, err := strconv.Atoi(partition)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Failed to convert partition %v to integer: %v\", partition, err)\n\t\t}\n\t\tgceSource.Partition = int32(partInt)\n\t}\n\n\t// TODO: Take the zone/regional information and stick it into the label.\n\n\tpv.Spec.CSI = nil\n\tpv.Spec.GCEPersistentDisk = gceSource\n\n\treturn pv, nil\n}", "category": "Python"}, {"instruction": "// Delete an existing Group expression.", "input": "go language", "output": "func (g *Group) Delete(e *GroupExpr) {\n\tfingerprint := e.FingerPrint()\n\tequiv, ok := g.Fingerprints[fingerprint]\n\tif !ok {\n\t\treturn // Can not find the target GroupExpr.\n\t}\n\n\tg.Equivalents.Remove(equiv)\n\tdelete(g.Fingerprints, fingerprint)\n\n\toperand := GetOperand(equiv.Value.(*GroupExpr).ExprNode)\n\tif g.FirstExpr[operand] != equiv {\n\t\treturn // The target GroupExpr is not the first Element of the same Operand.\n\t}\n\n\tnextElem := equiv.Next()\n\tif nextElem != nil && GetOperand(nextElem.Value.(*GroupExpr).ExprNode) == operand {\n\t\tg.FirstExpr[operand] = nextElem\n\t\treturn // The first Element of the same Operand has been changed.\n\t}\n\tdelete(g.FirstExpr, operand)\n}", "category": "Python"}, {"instruction": "// howSimilar is a naive diff implementation that returns\n// a number between 0-100 indicating how similar a and b are.\n// 100 is when all words in a also exists in b.", "input": "go language", "output": "func howSimilarStrings(a, b string) int {\n\n\t// Give some weight to the word positions.\n\tconst partitionSize = 4\n\n\taf, bf := strings.Fields(a), strings.Fields(b)\n\tif len(bf) > len(af) {\n\t\taf, bf = bf, af\n\t}\n\n\tm1 := make(map[string]bool)\n\tfor i, x := range bf {\n\t\tpartition := partition(i, partitionSize)\n\t\tkey := x + \"/\" + strconv.Itoa(partition)\n\t\tm1[key] = true\n\t}\n\n\tcommon := 0\n\tfor i, x := range af {\n\t\tpartition := partition(i, partitionSize)\n\t\tkey := x + \"/\" + strconv.Itoa(partition)\n\t\tif m1[key] {\n\t\t\tcommon++\n\t\t}\n\t}\n\n\treturn int(math.Floor((float64(common) / float64(len(af)) * 100)))\n}", "category": "Python"}, {"instruction": "// buildGlobalHashTable builds a global hash table for the inner relation.\n// key of hash table: hash value of key columns\n// value of hash table: RowPtr of the corresponded row", "input": "go language", "output": "func (e *HashJoinExec) buildGlobalHashTable() error {\n\te.globalHashTable = mvmap.NewMVMap()\n\tvar (\n\t\thasNull bool\n\t\terr     error\n\t\tkeyBuf  = make([]byte, 0, 64)\n\t\tvalBuf  = make([]byte, 8)\n\t)\n\n\tfor chkIdx := 0; chkIdx < e.innerResult.NumChunks(); chkIdx++ {\n\t\tif e.finished.Load().(bool) {\n\t\t\treturn nil\n\t\t}\n\t\tchk := e.innerResult.GetChunk(chkIdx)\n\t\tfor j, numRows := 0, chk.NumRows(); j < numRows; j++ {\n\t\t\thasNull, keyBuf, err = e.getJoinKeyFromChkRow(false, chk.GetRow(j), keyBuf)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif hasNull {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\trowPtr := chunk.RowPtr{ChkIdx: uint32(chkIdx), RowIdx: uint32(j)}\n\t\t\t*(*chunk.RowPtr)(unsafe.Pointer(&valBuf[0])) = rowPtr\n\t\t\te.globalHashTable.Put(keyBuf, valBuf)\n\t\t}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// RegisterServices registers the given Services which can then be used to\n// start devp2p nodes using either the Exec or Docker adapters.\n//\n// It should be called in an init function so that it has the opportunity to\n// execute the services before main() is called.", "input": "go language", "output": "func RegisterServices(services Services) {\n\tfor name, f := range services {\n\t\tif _, exists := serviceFuncs[name]; exists {\n\t\t\tpanic(fmt.Sprintf(\"node service already exists: %q\", name))\n\t\t}\n\t\tserviceFuncs[name] = f\n\t}\n\n\t// now we have registered the services, run reexec.Init() which will\n\t// potentially start one of the services if the current binary has\n\t// been exec'd with argv[0] set to \"p2p-node\"\n\tif reexec.Init() {\n\t\tos.Exit(0)\n\t}\n}", "category": "Python"}, {"instruction": "// getCgroupPath gets the file path to the \"devices\" subsystem of the desired cgroup.\n// cgroupPath is the path in the cgroup hierarchy.", "input": "go language", "output": "func getCgroupPath(cgroupPath string) (string, error) {\n\tcgroupPath = libcontainerutils.CleanPath(cgroupPath)\n\n\tmnt, root, err := libcontainercgroups.FindCgroupMountpointAndRoot(\"devices\")\n\t// If we didn't mount the subsystem, there is no point we make the path.\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// If the cgroup name/path is absolute do not look relative to the cgroup of the init process.\n\tif filepath.IsAbs(cgroupPath) {\n\t\t// Sometimes subsystems can be mounted together as 'cpu,cpuacct'.\n\t\treturn filepath.Join(root, mnt, cgroupPath), nil\n\t}\n\n\tparentPath, err := getCgroupParentPath(mnt, root)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn filepath.Join(parentPath, cgroupPath), nil\n}", "category": "Python"}, {"instruction": "// readDefaultBigInt reads a single line from stdin, trimming if from spaces,\n// enforcing it to parse into a big integer. If an empty line is entered, the\n// default value is returned.", "input": "go language", "output": "func (w *wizard) readDefaultBigInt(def *big.Int) *big.Int {\n\tfor {\n\t\tfmt.Printf(\"> \")\n\t\ttext, err := w.in.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tlog.Crit(\"Failed to read user input\", \"err\", err)\n\t\t}\n\t\tif text = strings.TrimSpace(text); text == \"\" {\n\t\t\treturn def\n\t\t}\n\t\tval, ok := new(big.Int).SetString(text, 0)\n\t\tif !ok {\n\t\t\tlog.Error(\"Invalid input, expected big integer\")\n\t\t\tcontinue\n\t\t}\n\t\treturn val\n\t}\n}", "category": "Python"}, {"instruction": "// createPriceOracle sets up a matrix which can be queried to get\n// the price for a message via the Price method", "input": "go language", "output": "func (r *Registry) createPriceOracle() {\n\tsp := &StreamerPrices{\n\t\tregistry: r,\n\t}\n\tsp.priceMatrix = map[reflect.Type]*protocols.Price{\n\t\treflect.TypeOf(ChunkDeliveryMsgRetrieval{}): {\n\t\t\tValue:   sp.getChunkDeliveryMsgRetrievalPrice(), // arbitrary price for now\n\t\t\tPerByte: true,\n\t\t\tPayer:   protocols.Receiver,\n\t\t},\n\t\treflect.TypeOf(RetrieveRequestMsg{}): {\n\t\t\tValue:   sp.getRetrieveRequestMsgPrice(), // arbitrary price for now\n\t\t\tPerByte: false,\n\t\t\tPayer:   protocols.Sender,\n\t\t},\n\t}\n\tr.prices = sp\n}", "category": "Python"}, {"instruction": "// update executes periodic operations on the peer, including message transmission\n// and expiration.", "input": "go language", "output": "func (peer *Peer) update() {\n\t// Start the tickers for the updates\n\texpire := time.NewTicker(expirationCycle)\n\ttransmit := time.NewTicker(transmissionCycle)\n\n\t// Loop and transmit until termination is requested\n\tfor {\n\t\tselect {\n\t\tcase <-expire.C:\n\t\t\tpeer.expire()\n\n\t\tcase <-transmit.C:\n\t\t\tif err := peer.broadcast(); err != nil {\n\t\t\t\tlog.Trace(\"broadcast failed\", \"reason\", err, \"peer\", peer.ID())\n\t\t\t\treturn\n\t\t\t}\n\n\t\tcase <-peer.quit:\n\t\t\treturn\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// monitorLock is a long running routine to monitor a semaphore ownership\n// It closes the stopCh if we lose our slot.", "input": "go language", "output": "func (s *Semaphore) monitorLock(session string, stopCh chan struct{}) {\n\tdefer close(stopCh)\n\tkv := s.c.KV()\n\topts := &QueryOptions{RequireConsistent: true}\nWAIT:\n\tretries := s.opts.MonitorRetries\nRETRY:\n\tpairs, meta, err := kv.List(s.opts.Prefix, opts)\n\tif err != nil {\n\t\t// If configured we can try to ride out a brief Consul unavailability\n\t\t// by doing retries. Note that we have to attempt the retry in a non-\n\t\t// blocking fashion so that we have a clean place to reset the retry\n\t\t// counter if service is restored.\n\t\tif retries > 0 && IsRetryableError(err) {\n\t\t\ttime.Sleep(s.opts.MonitorRetryTime)\n\t\t\tretries--\n\t\t\topts.WaitIndex = 0\n\t\t\tgoto RETRY\n\t\t}\n\t\treturn\n\t}\n\tlockPair := s.findLock(pairs)\n\tlock, err := s.decodeLock(lockPair)\n\tif err != nil {\n\t\treturn\n\t}\n\ts.pruneDeadHolders(lock, pairs)\n\tif _, ok := lock.Holders[session]; ok {\n\t\topts.WaitIndex = meta.LastIndex\n\t\tgoto WAIT\n\t}\n}", "category": "Python"}, {"instruction": "// Checksum sends a checksum request.", "input": "go language", "output": "func Checksum(ctx context.Context, client kv.Client, kvReq *kv.Request, vars *kv.Variables) (SelectResult, error) {\n\tresp := client.Send(ctx, kvReq, vars)\n\tif resp == nil {\n\t\treturn nil, errors.New(\"client returns nil response\")\n\t}\n\tresult := &selectResult{\n\t\tlabel:    \"checksum\",\n\t\tresp:     resp,\n\t\tresults:  make(chan resultWithErr, kvReq.Concurrency),\n\t\tclosed:   make(chan struct{}),\n\t\tfeedback: statistics.NewQueryFeedback(0, nil, 0, false),\n\t\tsqlType:  metrics.LblGeneral,\n\t}\n\treturn result, nil\n}", "category": "Python"}, {"instruction": "// Scan queries continuous kv pairs in range [startKey, endKey), up to limit pairs.\n// If endKey is empty, it means unbounded.\n// If you want to exclude the startKey or include the endKey, append a '\\0' to the key. For example, to scan\n// (startKey, endKey], you can write:\n// `Scan(append(startKey, '\\0'), append(endKey, '\\0'), limit)`.", "input": "go language", "output": "func (c *RawKVClient) Scan(startKey, endKey []byte, limit int) (keys [][]byte, values [][]byte, err error) {\n\tstart := time.Now()\n\tdefer func() { tikvRawkvCmdHistogramWithRawScan.Observe(time.Since(start).Seconds()) }()\n\n\tif limit > MaxRawKVScanLimit {\n\t\treturn nil, nil, errors.Trace(ErrMaxScanLimitExceeded)\n\t}\n\n\tfor len(keys) < limit {\n\t\treq := &tikvrpc.Request{\n\t\t\tType: tikvrpc.CmdRawScan,\n\t\t\tRawScan: &kvrpcpb.RawScanRequest{\n\t\t\t\tStartKey: startKey,\n\t\t\t\tEndKey:   endKey,\n\t\t\t\tLimit:    uint32(limit - len(keys)),\n\t\t\t},\n\t\t}\n\t\tresp, loc, err := c.sendReq(startKey, req, false)\n\t\tif err != nil {\n\t\t\treturn nil, nil, errors.Trace(err)\n\t\t}\n\t\tcmdResp := resp.RawScan\n\t\tif cmdResp == nil {\n\t\t\treturn nil, nil, errors.Trace(ErrBodyMissing)\n\t\t}\n\t\tfor _, pair := range cmdResp.Kvs {\n\t\t\tkeys = append(keys, pair.Key)\n\t\t\tvalues = append(values, pair.Value)\n\t\t}\n\t\tstartKey = loc.EndKey\n\t\tif len(startKey) == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// CreateEnvelope creates a common.Envelope with given tx bytes, header, and Signer", "input": "go language", "output": "func CreateEnvelope(data []byte, header *common.Header, signer SignerIdentity) (*common.Envelope, error) {\n\tpayload := &common.Payload{\n\t\tHeader: header,\n\t\tData:   data,\n\t}\n\n\tpayloadBytes, err := proto.Marshal(payload)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to marshal common.Payload\")\n\t}\n\n\tsignature, err := signer.Sign(payloadBytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttxEnvelope := &common.Envelope{\n\t\tPayload:   payloadBytes,\n\t\tSignature: signature,\n\t}\n\n\treturn txEnvelope, nil\n}", "category": "Python"}, {"instruction": "// UnmarshalBinary decodes msgpack encoded ServiceConfigResponse. It used\n// default msgpack encoding but fixes up the uint8 strings and other problems we\n// have with encoding map[string]interface{}.", "input": "go language", "output": "func (r *ServiceConfigResponse) UnmarshalBinary(data []byte) error {\n\tdec := codec.NewDecoderBytes(data, msgpackHandle)\n\n\ttype Alias ServiceConfigResponse\n\tvar a Alias\n\n\tif err := dec.Decode(&a); err != nil {\n\t\treturn err\n\t}\n\n\t*r = ServiceConfigResponse(a)\n\n\tvar err error\n\n\t// Fix strings and maps in the returned maps\n\tr.ProxyConfig, err = lib.MapWalk(r.ProxyConfig)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor k := range r.UpstreamConfigs {\n\t\tr.UpstreamConfigs[k], err = lib.MapWalk(r.UpstreamConfigs[k])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// capabilities builds a Capabilities from discovery information.", "input": "go language", "output": "func capabilities(disc discovery.DiscoveryInterface) (*chartutil.Capabilities, error) {\n\tsv, err := disc.ServerVersion()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvs, err := GetVersionSet(disc)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Could not get apiVersions from Kubernetes: %s\", err)\n\t}\n\treturn &chartutil.Capabilities{\n\t\tAPIVersions:   vs,\n\t\tKubeVersion:   sv,\n\t\tTillerVersion: version.GetVersionProto(),\n\t}, nil\n}", "category": "Python"}, {"instruction": "// exceedMemoryRequests compares whether or not pods' memory usage exceeds their requests", "input": "go language", "output": "func exceedMemoryRequests(stats statsFunc) cmpFunc {\n\treturn func(p1, p2 *v1.Pod) int {\n\t\tp1Stats, p1Found := stats(p1)\n\t\tp2Stats, p2Found := stats(p2)\n\t\tif !p1Found || !p2Found {\n\t\t\t// prioritize evicting the pod for which no stats were found\n\t\t\treturn cmpBool(!p1Found, !p2Found)\n\t\t}\n\n\t\tp1Memory := memoryUsage(p1Stats.Memory)\n\t\tp2Memory := memoryUsage(p2Stats.Memory)\n\t\tp1ExceedsRequests := p1Memory.Cmp(podRequest(p1, v1.ResourceMemory)) == 1\n\t\tp2ExceedsRequests := p2Memory.Cmp(podRequest(p2, v1.ResourceMemory)) == 1\n\t\t// prioritize evicting the pod which exceeds its requests\n\t\treturn cmpBool(p1ExceedsRequests, p2ExceedsRequests)\n\t}\n}", "category": "Python"}, {"instruction": "// PendingPods returns all the pending pods in the queue. This function is\n// used for debugging purposes in the scheduler cache dumper and comparer.", "input": "go language", "output": "func (p *PriorityQueue) PendingPods() []*v1.Pod {\n\tp.lock.RLock()\n\tdefer p.lock.RUnlock()\n\tresult := []*v1.Pod{}\n\tfor _, pInfo := range p.activeQ.List() {\n\t\tresult = append(result, pInfo.(*podInfo).pod)\n\t}\n\tfor _, pInfo := range p.podBackoffQ.List() {\n\t\tresult = append(result, pInfo.(*podInfo).pod)\n\t}\n\tfor _, pInfo := range p.unschedulableQ.podInfoMap {\n\t\tresult = append(result, pInfo.pod)\n\t}\n\treturn result\n}", "category": "Python"}, {"instruction": "// AdoptControllerRevision sends a patch to take control of the ControllerRevision. It returns the error if\n// the patching fails.", "input": "go language", "output": "func (m *ControllerRevisionControllerRefManager) AdoptControllerRevision(history *apps.ControllerRevision) error {\n\tif err := m.CanAdopt(); err != nil {\n\t\treturn fmt.Errorf(\"can't adopt ControllerRevision %v/%v (%v): %v\", history.Namespace, history.Name, history.UID, err)\n\t}\n\t// Note that ValidateOwnerReferences() will reject this patch if another\n\t// OwnerReference exists with controller=true.\n\taddControllerPatch := fmt.Sprintf(\n\t\t`{\"metadata\":{\"ownerReferences\":[{\"apiVersion\":\"%s\",\"kind\":\"%s\",\"name\":\"%s\",\"uid\":\"%s\",\"controller\":true,\"blockOwnerDeletion\":true}],\"uid\":\"%s\"}}`,\n\t\tm.controllerKind.GroupVersion(), m.controllerKind.Kind,\n\t\tm.Controller.GetName(), m.Controller.GetUID(), history.UID)\n\treturn m.crControl.PatchControllerRevision(history.Namespace, history.Name, []byte(addControllerPatch))\n}", "category": "Python"}, {"instruction": "// RenderResult renders the explain result as specified format.", "input": "go language", "output": "func (e *Explain) RenderResult() error {\n\tif e.StmtPlan == nil {\n\t\treturn nil\n\t}\n\tswitch strings.ToLower(e.Format) {\n\tcase ast.ExplainFormatROW:\n\t\te.explainedPlans = map[int]bool{}\n\t\te.explainPlanInRowFormat(e.StmtPlan.(PhysicalPlan), \"root\", \"\", true)\n\tcase ast.ExplainFormatDOT:\n\t\te.prepareDotInfo(e.StmtPlan.(PhysicalPlan))\n\tdefault:\n\t\treturn errors.Errorf(\"explain format '%s' is not supported now\", e.Format)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// MockPumpsClient creates a PumpsClient, used for test.", "input": "go language", "output": "func MockPumpsClient(client binlog.PumpClient) *pumpcli.PumpsClient {\n\tnodeID := \"pump-1\"\n\tpump := &pumpcli.PumpStatus{\n\t\tStatus: node.Status{\n\t\t\tNodeID: nodeID,\n\t\t\tState:  node.Online,\n\t\t},\n\t\tClient: client,\n\t}\n\n\tpumpInfos := &pumpcli.PumpInfos{\n\t\tPumps:            make(map[string]*pumpcli.PumpStatus),\n\t\tAvaliablePumps:   make(map[string]*pumpcli.PumpStatus),\n\t\tUnAvaliablePumps: make(map[string]*pumpcli.PumpStatus),\n\t}\n\tpumpInfos.Pumps[nodeID] = pump\n\tpumpInfos.AvaliablePumps[nodeID] = pump\n\n\tpCli := &pumpcli.PumpsClient{\n\t\tClusterID:          1,\n\t\tPumps:              pumpInfos,\n\t\tSelector:           pumpcli.NewSelector(pumpcli.Range),\n\t\tBinlogWriteTimeout: time.Second,\n\t}\n\tpCli.Selector.SetPumps([]*pumpcli.PumpStatus{pump})\n\n\treturn pCli\n}", "category": "Python"}, {"instruction": "// CreateProposalResponseFailure creates a proposal response for cases where\n// endorsement proposal fails either due to a endorsement failure or a\n// chaincode failure (chaincode response status >= shim.ERRORTHRESHOLD)", "input": "go language", "output": "func CreateProposalResponseFailure(hdrbytes []byte, payl []byte, response *peer.Response, results []byte, events []byte, ccid *peer.ChaincodeID, visibility []byte) (*peer.ProposalResponse, error) {\n\thdr, err := GetHeader(hdrbytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// obtain the proposal hash given proposal header, payload and the requested visibility\n\tpHashBytes, err := GetProposalHash1(hdr, payl, visibility)\n\tif err != nil {\n\t\treturn nil, errors.WithMessage(err, \"error computing proposal hash\")\n\t}\n\n\t// get the bytes of the proposal response payload\n\tprpBytes, err := GetBytesProposalResponsePayload(pHashBytes, response, results, events, ccid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp := &peer.ProposalResponse{\n\t\t// Timestamp: TODO!\n\t\tPayload:  prpBytes,\n\t\tResponse: response,\n\t}\n\n\treturn resp, nil\n}", "category": "Python"}, {"instruction": "// Init takes two arguments, a string and int. These are stored in the key/value pair in the state", "input": "go language", "output": "func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {\n\tvar event string // Indicates whether event has happened. Initially 0\n\tvar eventVal int // State of event\n\tvar err error\n\t_, args := stub.GetFunctionAndParameters()\n\tif len(args) != 2 {\n\t\treturn shim.Error(\"Incorrect number of arguments. Expecting 2\")\n\t}\n\n\t// Initialize the chaincode\n\tevent = args[0]\n\teventVal, err = strconv.Atoi(args[1])\n\tif err != nil {\n\t\treturn shim.Error(\"Expecting integer value for event status\")\n\t}\n\tfmt.Printf(\"eventVal = %d\\n\", eventVal)\n\n\terr = stub.PutState(event, []byte(strconv.Itoa(eventVal)))\n\tif err != nil {\n\t\treturn shim.Error(err.Error())\n\t}\n\n\treturn shim.Success(nil)\n}", "category": "Python"}, {"instruction": "// RequestHeadersByHash implements downloader.Peer, returning a batch of headers\n// defined by the origin hash and the associated query parameters.", "input": "go language", "output": "func (p *FakePeer) RequestHeadersByHash(hash common.Hash, amount int, skip int, reverse bool) error {\n\tvar (\n\t\theaders []*types.Header\n\t\tunknown bool\n\t)\n\tfor !unknown && len(headers) < amount {\n\t\torigin := p.hc.GetHeaderByHash(hash)\n\t\tif origin == nil {\n\t\t\tbreak\n\t\t}\n\t\tnumber := origin.Number.Uint64()\n\t\theaders = append(headers, origin)\n\t\tif reverse {\n\t\t\tfor i := 0; i <= skip; i++ {\n\t\t\t\tif header := p.hc.GetHeader(hash, number); header != nil {\n\t\t\t\t\thash = header.ParentHash\n\t\t\t\t\tnumber--\n\t\t\t\t} else {\n\t\t\t\t\tunknown = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar (\n\t\t\t\tcurrent = origin.Number.Uint64()\n\t\t\t\tnext    = current + uint64(skip) + 1\n\t\t\t)\n\t\t\tif header := p.hc.GetHeaderByNumber(next); header != nil {\n\t\t\t\tif p.hc.GetBlockHashesFromHash(header.Hash(), uint64(skip+1))[skip] == hash {\n\t\t\t\t\thash = header.Hash()\n\t\t\t\t} else {\n\t\t\t\t\tunknown = true\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunknown = true\n\t\t\t}\n\t\t}\n\t}\n\tp.dl.DeliverHeaders(p.id, headers)\n\treturn nil\n}", "category": "Python"}, {"instruction": "// PullImage is a test-spy implementation of Interface.PullImage.\n// It adds an entry \"pull\" to the internal method call record.", "input": "go language", "output": "func (f *FakeDockerClient) PullImage(image string, auth dockertypes.AuthConfig, opts dockertypes.ImagePullOptions) error {\n\tf.Lock()\n\tdefer f.Unlock()\n\tf.appendCalled(CalledDetail{name: \"pull\"})\n\terr := f.popError(\"pull\")\n\tif err == nil {\n\t\tif !f.isAuthorizedForImage(image, auth) {\n\t\t\treturn ImageNotFoundError{ID: image}\n\t\t}\n\n\t\tauthJson, _ := json.Marshal(auth)\n\t\tinspect := createImageInspectFromRef(image)\n\t\tf.ImageInspects[image] = inspect\n\t\tf.appendPulled(fmt.Sprintf(\"%s using %s\", image, string(authJson)))\n\t\tf.Images = append(f.Images, *createImageFromImageInspect(*inspect))\n\t\tf.ImagesPulled = append(f.ImagesPulled, image)\n\t}\n\treturn err\n}", "category": "Python"}, {"instruction": "// enqueueTx inserts a new transaction into the non-executable transaction queue.\n//\n// Note, this method assumes the pool lock is held!", "input": "go language", "output": "func (pool *TxPool) enqueueTx(hash common.Hash, tx *types.Transaction) (bool, error) {\n\t// Try to insert the transaction into the future queue\n\tfrom, _ := types.Sender(pool.signer, tx) // already validated\n\tif pool.queue[from] == nil {\n\t\tpool.queue[from] = newTxList(false)\n\t}\n\tinserted, old := pool.queue[from].Add(tx, pool.config.PriceBump)\n\tif !inserted {\n\t\t// An older transaction was better, discard this\n\t\tqueuedDiscardCounter.Inc(1)\n\t\treturn false, ErrReplaceUnderpriced\n\t}\n\t// Discard any previous transaction and mark this\n\tif old != nil {\n\t\tpool.all.Remove(old.Hash())\n\t\tpool.priced.Removed()\n\t\tqueuedReplaceCounter.Inc(1)\n\t}\n\tif pool.all.Get(hash) == nil {\n\t\tpool.all.Add(tx)\n\t\tpool.priced.Put(tx)\n\t}\n\treturn old != nil, nil\n}", "category": "Python"}, {"instruction": "// newTikvHandlerTool checks and prepares for tikv handler.\n// It would panic when any error happens.", "input": "go language", "output": "func (s *Server) newTikvHandlerTool() *tikvHandlerTool {\n\tvar tikvStore tikv.Storage\n\tstore, ok := s.driver.(*TiDBDriver)\n\tif !ok {\n\t\tpanic(\"Invalid KvStore with illegal driver\")\n\t}\n\n\tif tikvStore, ok = store.store.(tikv.Storage); !ok {\n\t\tpanic(\"Invalid KvStore with illegal store\")\n\t}\n\n\tregionCache := tikvStore.GetRegionCache()\n\n\treturn &tikvHandlerTool{\n\t\thelper.Helper{\n\t\t\tRegionCache: regionCache,\n\t\t\tStore:       tikvStore,\n\t\t},\n\t}\n}", "category": "Python"}, {"instruction": "// WeakDecode behaves in the same way as mapstructure.WeakDecode but has a\n// DecodeHook which defeats the backward compatibility mode of mapstructure\n// which WeakDecodes []interface{}{} into an empty map[string]interface{}. This\n// allows us to use WeakDecode (desirable), but not fail on empty lists.", "input": "go language", "output": "func WeakDecode(m interface{}, rawVal interface{}) error {\n\tconfig := &mapstructure.DecoderConfig{\n\t\tDecodeHook: func(source reflect.Type, target reflect.Type, val interface{}) (interface{}, error) {\n\t\t\tsliceType := reflect.TypeOf(hilMapstructureDecodeHookEmptySlice)\n\t\t\tstringSliceType := reflect.TypeOf(hilMapstructureDecodeHookStringSlice)\n\t\t\tmapType := reflect.TypeOf(hilMapstructureDecodeHookEmptyMap)\n\n\t\t\tif (source == sliceType || source == stringSliceType) && target == mapType {\n\t\t\t\treturn nil, fmt.Errorf(\"Cannot convert a []interface{} into a map[string]interface{}\")\n\t\t\t}\n\n\t\t\treturn val, nil\n\t\t},\n\t\tWeaklyTypedInput: true,\n\t\tResult:           rawVal,\n\t}\n\n\tdecoder, err := mapstructure.NewDecoder(config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn decoder.Decode(m)\n}", "category": "Python"}, {"instruction": "// NewFilteredCustomResourceDefinitionInformer constructs a new informer for CustomResourceDefinition type.\n// Always prefer using an informer factory to get a shared informer instead of getting an independent\n// one. This reduces memory footprint and number of connections to the server.", "input": "go language", "output": "func NewFilteredCustomResourceDefinitionInformer(client internalclientset.Interface, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {\n\treturn cache.NewSharedIndexInformer(\n\t\t&cache.ListWatch{\n\t\t\tListFunc: func(options v1.ListOptions) (runtime.Object, error) {\n\t\t\t\tif tweakListOptions != nil {\n\t\t\t\t\ttweakListOptions(&options)\n\t\t\t\t}\n\t\t\t\treturn client.Apiextensions().CustomResourceDefinitions().List(options)\n\t\t\t},\n\t\t\tWatchFunc: func(options v1.ListOptions) (watch.Interface, error) {\n\t\t\t\tif tweakListOptions != nil {\n\t\t\t\t\ttweakListOptions(&options)\n\t\t\t\t}\n\t\t\t\treturn client.Apiextensions().CustomResourceDefinitions().Watch(options)\n\t\t\t},\n\t\t},\n\t\t&apiextensions.CustomResourceDefinition{},\n\t\tresyncPeriod,\n\t\tindexers,\n\t)\n}", "category": "Python"}, {"instruction": "// HugePageLimits converts the API representation to a map\n// from huge page size (in bytes) to huge page limit (in bytes).", "input": "go language", "output": "func HugePageLimits(resourceList v1.ResourceList) map[int64]int64 {\n\thugePageLimits := map[int64]int64{}\n\tfor k, v := range resourceList {\n\t\tif v1helper.IsHugePageResourceName(k) {\n\t\t\tpageSize, _ := v1helper.HugePageSizeFromResourceName(k)\n\t\t\tif value, exists := hugePageLimits[pageSize.Value()]; exists {\n\t\t\t\thugePageLimits[pageSize.Value()] = value + v.Value()\n\t\t\t} else {\n\t\t\t\thugePageLimits[pageSize.Value()] = v.Value()\n\t\t\t}\n\t\t}\n\t}\n\treturn hugePageLimits\n}", "category": "Python"}, {"instruction": "// CreateDirIfMissing creates a dir for dirPath if not already exists. If the dir is empty it returns true", "input": "go language", "output": "func CreateDirIfMissing(dirPath string) (bool, error) {\n\t// if dirPath does not end with a path separator, it leaves out the last segment while creating directories\n\tif !strings.HasSuffix(dirPath, \"/\") {\n\t\tdirPath = dirPath + \"/\"\n\t}\n\tlogger.Debugf(\"CreateDirIfMissing [%s]\", dirPath)\n\tlogDirStatus(\"Before creating dir\", dirPath)\n\terr := os.MkdirAll(path.Dir(dirPath), 0755)\n\tif err != nil {\n\t\tlogger.Debugf(\"Error creating dir [%s]\", dirPath)\n\t\treturn false, errors.Wrapf(err, \"error creating dir [%s]\", dirPath)\n\t}\n\tlogDirStatus(\"After creating dir\", dirPath)\n\treturn DirEmpty(dirPath)\n}", "category": "Python"}, {"instruction": "// HandleDates updates all the dates given the current configuration and the\n// supplied front matter params. Note that this requires all lower-case keys\n// in the params map.", "input": "go language", "output": "func (f FrontMatterHandler) HandleDates(d *FrontMatterDescriptor) error {\n\tif d.Dates == nil {\n\t\tpanic(\"missing dates\")\n\t}\n\n\tif f.dateHandler == nil {\n\t\tpanic(\"missing date handler\")\n\t}\n\n\tif _, err := f.dateHandler(d); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := f.lastModHandler(d); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := f.publishDateHandler(d); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := f.expiryDateHandler(d); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// interpolationFuncSlice returns a portion of the input list between from, inclusive and to, exclusive.", "input": "go language", "output": "func interpolationFuncSlice() ast.Function {\n\treturn ast.Function{\n\t\tArgTypes: []ast.Type{\n\t\t\tast.TypeList, // inputList\n\t\t\tast.TypeInt,  // from\n\t\t\tast.TypeInt,  // to\n\t\t},\n\t\tReturnType: ast.TypeList,\n\t\tVariadic:   false,\n\t\tCallback: func(args []interface{}) (interface{}, error) {\n\t\t\tinputList := args[0].([]ast.Variable)\n\t\t\tfrom := args[1].(int)\n\t\t\tto := args[2].(int)\n\n\t\t\tif from < 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"from index must be >= 0\")\n\t\t\t}\n\t\t\tif to > len(inputList) {\n\t\t\t\treturn nil, fmt.Errorf(\"to index must be <= length of the input list\")\n\t\t\t}\n\t\t\tif from > to {\n\t\t\t\treturn nil, fmt.Errorf(\"from index must be <= to index\")\n\t\t\t}\n\n\t\t\tvar outputList []ast.Variable\n\t\t\tfor i, val := range inputList {\n\t\t\t\tif i >= from && i < to {\n\t\t\t\t\toutputList = append(outputList, val)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn outputList, nil\n\t\t},\n\t}\n}", "category": "Python"}, {"instruction": "// Connect returns a handler for the pod exec proxy", "input": "go language", "output": "func (r *ExecREST) Connect(ctx context.Context, name string, opts runtime.Object, responder rest.Responder) (http.Handler, error) {\n\texecOpts, ok := opts.(*api.PodExecOptions)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"invalid options object: %#v\", opts)\n\t}\n\tlocation, transport, err := pod.ExecLocation(r.Store, r.KubeletConn, ctx, name, execOpts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn newThrottledUpgradeAwareProxyHandler(location, transport, false, true, true, responder), nil\n}", "category": "Python"}, {"instruction": "// StructuredGenerate outputs a pod disruption budget object using the configured fields.", "input": "go language", "output": "func (s *PodDisruptionBudgetV1Generator) StructuredGenerate() (runtime.Object, error) {\n\tif len(s.MinAvailable) == 0 {\n\t\t// defaulting behavior seen in Kubernetes 1.6 and below.\n\t\ts.MinAvailable = \"1\"\n\t}\n\n\tif err := s.validate(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tselector, err := metav1.ParseToLabelSelector(s.Selector)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tminAvailable := intstr.Parse(s.MinAvailable)\n\treturn &policy.PodDisruptionBudget{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: s.Name,\n\t\t},\n\t\tSpec: policy.PodDisruptionBudgetSpec{\n\t\t\tMinAvailable: &minAvailable,\n\t\t\tSelector:     selector,\n\t\t},\n\t}, nil\n}", "category": "Python"}, {"instruction": "// New creates a new Cluster instance using provided config.", "input": "go language", "output": "func New(config Config) (*Cluster, error) {\n\troot := filepath.Join(config.Root, swarmDirName)\n\tif err := os.MkdirAll(root, 0700); err != nil {\n\t\treturn nil, err\n\t}\n\tif config.RuntimeRoot == \"\" {\n\t\tconfig.RuntimeRoot = root\n\t}\n\tif config.RaftHeartbeatTick == 0 {\n\t\tconfig.RaftHeartbeatTick = 1\n\t}\n\tif config.RaftElectionTick == 0 {\n\t\t// 10X heartbeat tick is the recommended ratio according to etcd docs.\n\t\tconfig.RaftElectionTick = 10 * config.RaftHeartbeatTick\n\t}\n\n\tif err := os.MkdirAll(config.RuntimeRoot, 0700); err != nil {\n\t\treturn nil, err\n\t}\n\tc := &Cluster{\n\t\troot:        root,\n\t\tconfig:      config,\n\t\tconfigEvent: make(chan lncluster.ConfigEventType, 10),\n\t\truntimeRoot: config.RuntimeRoot,\n\t\tattachers:   make(map[string]*attacher),\n\t\twatchStream: config.WatchStream,\n\t}\n\treturn c, nil\n}", "category": "Python"}, {"instruction": "// createProvidersFromPolicies creates providers from the constraints supplied.", "input": "go language", "output": "func (c *PodSecurityPolicyPlugin) createProvidersFromPolicies(psps []*policyv1beta1.PodSecurityPolicy, namespace string) ([]psp.Provider, []error) {\n\tvar (\n\t\t// collected providers\n\t\tproviders []psp.Provider\n\t\t// collected errors to return\n\t\terrs []error\n\t)\n\n\tfor _, constraint := range psps {\n\t\tprovider, err := psp.NewSimpleProvider(constraint, namespace, c.strategyFactory)\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Errorf(\"error creating provider for PSP %s: %v\", constraint.Name, err))\n\t\t\tcontinue\n\t\t}\n\t\tproviders = append(providers, provider)\n\t}\n\treturn providers, errs\n}", "category": "Python"}, {"instruction": "// nextRotationDeadline returns a value for the threshold at which the\n// current certificate should be rotated, 80%+/-10% of the expiration of the\n// certificate.", "input": "go language", "output": "func (m *manager) nextRotationDeadline() time.Time {\n\t// forceRotation is not protected by locks\n\tif m.forceRotation {\n\t\tm.forceRotation = false\n\t\treturn time.Now()\n\t}\n\n\tm.certAccessLock.RLock()\n\tdefer m.certAccessLock.RUnlock()\n\n\tif !m.certSatisfiesTemplateLocked() {\n\t\treturn time.Now()\n\t}\n\n\tnotAfter := m.cert.Leaf.NotAfter\n\ttotalDuration := float64(notAfter.Sub(m.cert.Leaf.NotBefore))\n\tdeadline := m.cert.Leaf.NotBefore.Add(jitteryDuration(totalDuration))\n\n\tklog.V(2).Infof(\"Certificate expiration is %v, rotation deadline is %v\", notAfter, deadline)\n\tif m.certificateExpiration != nil {\n\t\tm.certificateExpiration.Set(float64(notAfter.Unix()))\n\t}\n\treturn deadline\n}", "category": "Python"}, {"instruction": "// watchTillerUntilReady waits for the tiller pod to become available. This is useful in situations where we\n// want to wait before we call New().\n//\n// Returns true if it exists. If the timeout was reached and it could not find the pod, it returns false.", "input": "go language", "output": "func watchTillerUntilReady(namespace string, client kubernetes.Interface, timeout int64, newImage string) bool {\n\tdeadlinePollingChan := time.NewTimer(time.Duration(timeout) * time.Second).C\n\tcheckTillerPodTicker := time.NewTicker(500 * time.Millisecond)\n\tdoneChan := make(chan bool)\n\n\tdefer checkTillerPodTicker.Stop()\n\n\tgo func() {\n\t\tfor range checkTillerPodTicker.C {\n\t\t\timage, err := portforwarder.GetTillerPodImage(client.CoreV1(), namespace)\n\t\t\tif err == nil && image == newImage {\n\t\t\t\tdoneChan <- true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-deadlinePollingChan:\n\t\t\treturn false\n\t\tcase <-doneChan:\n\t\t\treturn true\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// UploadDirectory uploads a directory tree to swarm and either adds the files\n// to an existing manifest (if the manifest argument is non-empty) or creates a\n// new manifest, returning the resulting manifest hash (files from the\n// directory will then be available at bzz:/<hash>/path/to/file), with\n// the file specified in defaultPath being uploaded to the root of the manifest\n// (i.e. bzz:/<hash>/)", "input": "go language", "output": "func (c *Client) UploadDirectory(dir, defaultPath, manifest string, toEncrypt bool) (string, error) {\n\tstat, err := os.Stat(dir)\n\tif err != nil {\n\t\treturn \"\", err\n\t} else if !stat.IsDir() {\n\t\treturn \"\", fmt.Errorf(\"not a directory: %s\", dir)\n\t}\n\tif defaultPath != \"\" {\n\t\tif _, err := os.Stat(filepath.Join(dir, defaultPath)); err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\treturn \"\", fmt.Errorf(\"the default path %q was not found in the upload directory %q\", defaultPath, dir)\n\t\t\t}\n\t\t\treturn \"\", fmt.Errorf(\"default path: %v\", err)\n\t\t}\n\t}\n\treturn c.TarUpload(manifest, &DirectoryUploader{dir}, defaultPath, toEncrypt)\n}", "category": "Python"}, {"instruction": "// Remove disassociates a metadata entry from a layer DiffID.", "input": "go language", "output": "func (serv *v2MetadataService) Remove(metadata V2Metadata) error {\n\tif serv.store == nil {\n\t\t// Support a service which has no backend storage, in this case\n\t\t// an remove becomes a no-op.\n\t\t// TODO: implement in memory storage\n\t\treturn nil\n\t}\n\tdiffID, err := serv.GetDiffID(metadata.Digest)\n\tif err != nil {\n\t\treturn err\n\t}\n\toldMetadata, err := serv.GetMetadata(diffID)\n\tif err != nil {\n\t\toldMetadata = nil\n\t}\n\tnewMetadata := make([]V2Metadata, 0, len(oldMetadata))\n\n\t// Copy all other metadata to new slice\n\tfor _, oldMeta := range oldMetadata {\n\t\tif oldMeta != metadata {\n\t\t\tnewMetadata = append(newMetadata, oldMeta)\n\t\t}\n\t}\n\n\tif len(newMetadata) == 0 {\n\t\treturn serv.store.Delete(serv.diffIDNamespace(), serv.diffIDKey(diffID))\n\t}\n\n\tjsonBytes, err := json.Marshal(newMetadata)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn serv.store.Set(serv.diffIDNamespace(), serv.diffIDKey(diffID), jsonBytes)\n}", "category": "Python"}, {"instruction": "// List takes label and field selectors, and returns the list of CertificateSigningRequests that match those selectors.", "input": "go language", "output": "func (c *FakeCertificateSigningRequests) List(opts v1.ListOptions) (result *v1beta1.CertificateSigningRequestList, err error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewRootListAction(certificatesigningrequestsResource, certificatesigningrequestsKind, opts), &v1beta1.CertificateSigningRequestList{})\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n\tif label == nil {\n\t\tlabel = labels.Everything()\n\t}\n\tlist := &v1beta1.CertificateSigningRequestList{ListMeta: obj.(*v1beta1.CertificateSigningRequestList).ListMeta}\n\tfor _, item := range obj.(*v1beta1.CertificateSigningRequestList).Items {\n\t\tif label.Matches(labels.Set(item.Labels)) {\n\t\t\tlist.Items = append(list.Items, item)\n\t\t}\n\t}\n\treturn list, err\n}", "category": "Python"}, {"instruction": "// ComputeHash returns a hash value calculated from pod template and\n// a collisionCount to avoid hash collision. The hash will be safe encoded to\n// avoid bad words.", "input": "go language", "output": "func ComputeHash(template *v1.PodTemplateSpec, collisionCount *int32) string {\n\tpodTemplateSpecHasher := fnv.New32a()\n\thashutil.DeepHashObject(podTemplateSpecHasher, *template)\n\n\t// Add collisionCount in the hash if it exists.\n\tif collisionCount != nil {\n\t\tcollisionCountBytes := make([]byte, 8)\n\t\tbinary.LittleEndian.PutUint32(collisionCountBytes, uint32(*collisionCount))\n\t\tpodTemplateSpecHasher.Write(collisionCountBytes)\n\t}\n\n\treturn rand.SafeEncodeString(fmt.Sprint(podTemplateSpecHasher.Sum32()))\n}", "category": "Python"}, {"instruction": "// prepareTempDir prepares and returns the default directory to use\n// for temporary files.\n// If it doesn't exist, it is created. If it exists, its content is removed.", "input": "go language", "output": "func prepareTempDir(rootDir string, rootIdentity idtools.Identity) (string, error) {\n\tvar tmpDir string\n\tif tmpDir = os.Getenv(\"DOCKER_TMPDIR\"); tmpDir == \"\" {\n\t\ttmpDir = filepath.Join(rootDir, \"tmp\")\n\t\tnewName := tmpDir + \"-old\"\n\t\tif err := os.Rename(tmpDir, newName); err == nil {\n\t\t\tgo func() {\n\t\t\t\tif err := os.RemoveAll(newName); err != nil {\n\t\t\t\t\tlogrus.Warnf(\"failed to delete old tmp directory: %s\", newName)\n\t\t\t\t}\n\t\t\t}()\n\t\t} else if !os.IsNotExist(err) {\n\t\t\tlogrus.Warnf(\"failed to rename %s for background deletion: %s. Deleting synchronously\", tmpDir, err)\n\t\t\tif err := os.RemoveAll(tmpDir); err != nil {\n\t\t\t\tlogrus.Warnf(\"failed to delete old tmp directory: %s\", tmpDir)\n\t\t\t}\n\t\t}\n\t}\n\t// We don't remove the content of tmpdir if it's not the default,\n\t// it may hold things that do not belong to us.\n\treturn tmpDir, idtools.MkdirAllAndChown(tmpDir, 0700, rootIdentity)\n}", "category": "Python"}, {"instruction": "// DecodeToNode Converts the labels to a node.\n// labels -> nodes", "input": "go language", "output": "func DecodeToNode(labels map[string]string, filters ...string) (*Node, error) {\n\tvar sortedKeys []string\n\tfor key := range labels {\n\t\tif len(filters) == 0 {\n\t\t\tsortedKeys = append(sortedKeys, key)\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, filter := range filters {\n\t\t\tif len(key) >= len(filter) && strings.EqualFold(key[:len(filter)], filter) {\n\t\t\t\tsortedKeys = append(sortedKeys, key)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\tsort.Strings(sortedKeys)\n\n\tlabelRoot := \"traefik\"\n\n\tvar node *Node\n\tfor i, key := range sortedKeys {\n\t\tsplit := strings.Split(key, \".\")\n\n\t\tif split[0] != labelRoot {\n\t\t\t// TODO (@ldez): error or continue\n\t\t\treturn nil, fmt.Errorf(\"invalid label root %s\", split[0])\n\t\t}\n\n\t\tlabelRoot = split[0]\n\n\t\tif i == 0 {\n\t\t\tnode = &Node{}\n\t\t}\n\t\tdecodeToNode(node, split, labels[key])\n\t}\n\n\treturn node, nil\n}", "category": "Python"}, {"instruction": "// updateStats bumps the various state sync progress counters and displays a log\n// message for the user to see.", "input": "go language", "output": "func (s *stateSync) updateStats(written, duplicate, unexpected int, duration time.Duration) {\n\ts.d.syncStatsLock.Lock()\n\tdefer s.d.syncStatsLock.Unlock()\n\n\ts.d.syncStatsState.pending = uint64(s.sched.Pending())\n\ts.d.syncStatsState.processed += uint64(written)\n\ts.d.syncStatsState.duplicate += uint64(duplicate)\n\ts.d.syncStatsState.unexpected += uint64(unexpected)\n\n\tif written > 0 || duplicate > 0 || unexpected > 0 {\n\t\tlog.Info(\"Imported new state entries\", \"count\", written, \"elapsed\", common.PrettyDuration(duration), \"processed\", s.d.syncStatsState.processed, \"pending\", s.d.syncStatsState.pending, \"retry\", len(s.tasks), \"duplicate\", s.d.syncStatsState.duplicate, \"unexpected\", s.d.syncStatsState.unexpected)\n\t}\n\tif written > 0 {\n\t\trawdb.WriteFastTrieProgress(s.d.stateDB, s.d.syncStatsState.processed)\n\t}\n}", "category": "Python"}, {"instruction": "// GetOperatingSystem gets the name of the current operating system.", "input": "go language", "output": "func GetOperatingSystem() (string, error) {\n\n\t// Default return value\n\tret := \"Unknown Operating System\"\n\n\tk, err := registry.OpenKey(registry.LOCAL_MACHINE, `SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion`, registry.QUERY_VALUE)\n\tif err != nil {\n\t\treturn ret, err\n\t}\n\tdefer k.Close()\n\n\tpn, _, err := k.GetStringValue(\"ProductName\")\n\tif err != nil {\n\t\treturn ret, err\n\t}\n\tret = pn\n\n\tri, _, err := k.GetStringValue(\"ReleaseId\")\n\tif err != nil {\n\t\treturn ret, err\n\t}\n\tret = fmt.Sprintf(\"%s Version %s\", ret, ri)\n\n\tcbn, _, err := k.GetStringValue(\"CurrentBuildNumber\")\n\tif err != nil {\n\t\treturn ret, err\n\t}\n\n\tubr, _, err := k.GetIntegerValue(\"UBR\")\n\tif err != nil {\n\t\treturn ret, err\n\t}\n\tret = fmt.Sprintf(\"%s (OS Build %s.%d)\", ret, cbn, ubr)\n\n\treturn ret, nil\n}", "category": "Python"}, {"instruction": "// The Vector type represents a version vector. The zero value is a usable\n// version vector. The vector has slice semantics and some operations on it\n// are \"append-like\" in that they may return the same vector modified, or v\n// new allocated Vector with the modified contents.\n// Counter represents a single counter in the version vector.\n// Update returns a Vector with the index for the specific ID incremented by\n// one. If it is possible, the vector v is updated and returned. If it is not,\n// a copy will be created, updated and returned.", "input": "go language", "output": "func (v Vector) Update(id ShortID) Vector {\n\tfor i := range v.Counters {\n\t\tif v.Counters[i].ID == id {\n\t\t\t// Update an existing index\n\t\t\tv.Counters[i].Value++\n\t\t\treturn v\n\t\t} else if v.Counters[i].ID > id {\n\t\t\t// Insert a new index\n\t\t\tnv := make([]Counter, len(v.Counters)+1)\n\t\t\tcopy(nv, v.Counters[:i])\n\t\t\tnv[i].ID = id\n\t\t\tnv[i].Value = 1\n\t\t\tcopy(nv[i+1:], v.Counters[i:])\n\t\t\treturn Vector{Counters: nv}\n\t\t}\n\t}\n\t// Append a new index\n\treturn Vector{Counters: append(v.Counters, Counter{ID: id, Value: 1})}\n}", "category": "Python"}, {"instruction": "// formatVirtualKey converts a virtual key (e.g., up arrow) into the appropriate ANSI string.", "input": "go language", "output": "func formatVirtualKey(key uint16, controlState uint32, escapeSequence []byte) string {\n\tshift, alt, control := getControlKeys(controlState)\n\tmodifier := getControlKeysModifier(shift, alt, control)\n\n\tif format, ok := arrowKeyMapPrefix[key]; ok {\n\t\treturn fmt.Sprintf(format, escapeSequence, modifier)\n\t}\n\n\tif format, ok := keyMapPrefix[key]; ok {\n\t\treturn fmt.Sprintf(format, modifier)\n\t}\n\n\treturn \"\"\n}", "category": "Python"}, {"instruction": "// Normalize args convert multiple resources to resource tuples, a,b,c d\n// as a transform to a/d b/d c/d", "input": "go language", "output": "func normalizeMultipleResourcesArgs(args []string) []string {\n\tif len(args) >= 2 {\n\t\tresources := []string{}\n\t\tresources = append(resources, SplitResourceArgument(args[0])...)\n\t\tif len(resources) > 1 {\n\t\t\tnames := []string{}\n\t\t\tnames = append(names, args[1:]...)\n\t\t\tnewArgs := []string{}\n\t\t\tfor _, resource := range resources {\n\t\t\t\tfor _, name := range names {\n\t\t\t\t\tnewArgs = append(newArgs, strings.Join([]string{resource, name}, \"/\"))\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn newArgs\n\t\t}\n\t}\n\treturn args\n}", "category": "Python"}, {"instruction": "// loadBufferedEvents iterates over the cached events in the buffer\n// and returns those that were emitted between two specific dates.\n// It uses `time.Unix(seconds, nanoseconds)` to generate valid dates with those arguments.\n// It filters those buffered messages with a topic function if it's not nil, otherwise it adds all messages.", "input": "go language", "output": "func (e *Events) loadBufferedEvents(since, until time.Time, topic func(interface{}) bool) []eventtypes.Message {\n\tvar buffered []eventtypes.Message\n\tif since.IsZero() && until.IsZero() {\n\t\treturn buffered\n\t}\n\n\tvar sinceNanoUnix int64\n\tif !since.IsZero() {\n\t\tsinceNanoUnix = since.UnixNano()\n\t}\n\n\tvar untilNanoUnix int64\n\tif !until.IsZero() {\n\t\tuntilNanoUnix = until.UnixNano()\n\t}\n\n\tfor i := len(e.events) - 1; i >= 0; i-- {\n\t\tev := e.events[i]\n\n\t\tif ev.TimeNano < sinceNanoUnix {\n\t\t\tbreak\n\t\t}\n\n\t\tif untilNanoUnix > 0 && ev.TimeNano > untilNanoUnix {\n\t\t\tcontinue\n\t\t}\n\n\t\tif topic == nil || topic(ev) {\n\t\t\tbuffered = append([]eventtypes.Message{ev}, buffered...)\n\t\t}\n\t}\n\treturn buffered\n}", "category": "Python"}, {"instruction": "// uniqueToken generates a random URL-safe token and ensures uniqueness.", "input": "go language", "output": "func (c *requestCache) uniqueToken() (string, error) {\n\tconst maxTries = 10\n\t// Number of bytes to be tokenLen when base64 encoded.\n\ttokenSize := math.Ceil(float64(tokenLen) * 6 / 8)\n\trawToken := make([]byte, int(tokenSize))\n\tfor i := 0; i < maxTries; i++ {\n\t\tif _, err := rand.Read(rawToken); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tencoded := base64.RawURLEncoding.EncodeToString(rawToken)\n\t\ttoken := encoded[:tokenLen]\n\t\t// If it's unique, return it. Otherwise retry.\n\t\tif _, exists := c.tokens[encoded]; !exists {\n\t\t\treturn token, nil\n\t\t}\n\t}\n\treturn \"\", fmt.Errorf(\"failed to generate unique token\")\n}", "category": "Python"}, {"instruction": "// PersistWithConfig provides a mock function with given fields: txid, blockHeight, privateSimulationResultsWithConfig", "input": "go language", "output": "func (_m *Store) PersistWithConfig(txid string, blockHeight uint64, privateSimulationResultsWithConfig *protostransientstore.TxPvtReadWriteSetWithConfigInfo) error {\n\tret := _m.Called(txid, blockHeight, privateSimulationResultsWithConfig)\n\n\tvar r0 error\n\tif rf, ok := ret.Get(0).(func(string, uint64, *protostransientstore.TxPvtReadWriteSetWithConfigInfo) error); ok {\n\t\tr0 = rf(txid, blockHeight, privateSimulationResultsWithConfig)\n\t} else {\n\t\tr0 = ret.Error(0)\n\t}\n\n\treturn r0\n}", "category": "Python"}, {"instruction": "// NewDefinitionNamer constructs a new DefinitionNamer to be used to customize OpenAPI spec.", "input": "go language", "output": "func NewDefinitionNamer(schemes ...*runtime.Scheme) *DefinitionNamer {\n\tret := &DefinitionNamer{\n\t\ttypeGroupVersionKinds: map[string]groupVersionKinds{},\n\t}\n\tfor _, s := range schemes {\n\t\tfor gvk, rtype := range s.AllKnownTypes() {\n\t\t\tnewGVK := gvkConvert(gvk)\n\t\t\texists := false\n\t\t\tfor _, existingGVK := range ret.typeGroupVersionKinds[typeName(rtype)] {\n\t\t\t\tif newGVK == existingGVK {\n\t\t\t\t\texists = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !exists {\n\t\t\t\tret.typeGroupVersionKinds[typeName(rtype)] = append(ret.typeGroupVersionKinds[typeName(rtype)], newGVK)\n\t\t\t}\n\t\t}\n\t}\n\tfor _, gvk := range ret.typeGroupVersionKinds {\n\t\tsort.Sort(gvk)\n\t}\n\treturn ret\n}", "category": "Python"}, {"instruction": "// createCompositeKey and its related functions and consts copied from core/chaincode/shim/chaincode.go", "input": "go language", "output": "func createCompositeKey(objectType string, attributes []string) (string, error) {\n\tif err := validateCompositeKeyAttribute(objectType); err != nil {\n\t\treturn \"\", err\n\t}\n\tck := compositeKeyNamespace + objectType + string(minUnicodeRuneValue)\n\tfor _, att := range attributes {\n\t\tif err := validateCompositeKeyAttribute(att); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tck += att + string(minUnicodeRuneValue)\n\t}\n\treturn ck, nil\n}", "category": "Python"}, {"instruction": "// New creates a new chunk.\n//  cap: the limit for the max number of rows.\n//  maxChunkSize: the max limit for the number of rows.", "input": "go language", "output": "func New(fields []*types.FieldType, cap, maxChunkSize int) *Chunk {\n\tchk := new(Chunk)\n\tchk.columns = make([]*column, 0, len(fields))\n\tchk.capacity = mathutil.Min(cap, maxChunkSize)\n\tfor _, f := range fields {\n\t\telemLen := getFixedLen(f)\n\t\tif elemLen == varElemLen {\n\t\t\tchk.columns = append(chk.columns, newVarLenColumn(chk.capacity, nil))\n\t\t} else {\n\t\t\tchk.columns = append(chk.columns, newFixedLenColumn(elemLen, chk.capacity))\n\t\t}\n\t}\n\tchk.numVirtualRows = 0\n\n\t// set the default value of requiredRows to maxChunkSize to let chk.IsFull() behave\n\t// like how we judge whether a chunk is full now, then the statement\n\t// \"chk.NumRows() < maxChunkSize\"\n\t// is equal to\n\t// \"!chk.IsFull()\".\n\tchk.requiredRows = maxChunkSize\n\treturn chk\n}", "category": "Python"}, {"instruction": "// VisitKind prints a Kind type. It prints each key in the kind, with\n// the type, the required flag, and the description.", "input": "go language", "output": "func (f *regularFieldsPrinter) VisitKind(k *proto.Kind) {\n\tfor _, key := range k.Keys() {\n\t\tv := k.Fields[key]\n\t\trequired := \"\"\n\t\tif k.IsRequired(key) {\n\t\t\trequired = \" -required-\"\n\t\t}\n\n\t\tif err := f.Writer.Write(\"%s\\t<%s>%s\", key, GetTypeName(v), required); err != nil {\n\t\t\tf.Error = err\n\t\t\treturn\n\t\t}\n\t\tif err := f.Writer.Indent(indentDesc).WriteWrapped(\"%s\", v.GetDescription()); err != nil {\n\t\t\tf.Error = err\n\t\t\treturn\n\t\t}\n\t\tif err := f.Writer.Write(\"\"); err != nil {\n\t\t\tf.Error = err\n\t\t\treturn\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// checkName checks the provided name against the request", "input": "go language", "output": "func checkName(obj runtime.Object, name, namespace string, namer ScopeNamer) error {\n\tobjNamespace, objName, err := namer.ObjectName(obj)\n\tif err != nil {\n\t\treturn errors.NewBadRequest(fmt.Sprintf(\n\t\t\t\"the name of the object (%s based on URL) was undeterminable: %v\", name, err))\n\t}\n\tif objName != name {\n\t\treturn errors.NewBadRequest(fmt.Sprintf(\n\t\t\t\"the name of the object (%s) does not match the name on the URL (%s)\", objName, name))\n\t}\n\tif len(namespace) > 0 {\n\t\tif len(objNamespace) > 0 && objNamespace != namespace {\n\t\t\treturn errors.NewBadRequest(fmt.Sprintf(\n\t\t\t\t\"the namespace of the object (%s) does not match the namespace on the request (%s)\", objNamespace, namespace))\n\t\t}\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// GetMemberID returns the member ID of the given peer URL", "input": "go language", "output": "func (c *Client) GetMemberID(peerURL string) (uint64, error) {\n\tcli, err := clientv3.New(clientv3.Config{\n\t\tEndpoints:   c.Endpoints,\n\t\tDialTimeout: 30 * time.Second,\n\t\tTLS:         c.TLS,\n\t})\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer cli.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tresp, err := cli.MemberList(ctx)\n\tcancel()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tfor _, member := range resp.Members {\n\t\tif member.GetPeerURLs()[0] == peerURL {\n\t\t\treturn member.GetID(), nil\n\t\t}\n\t}\n\treturn 0, nil\n}", "category": "Python"}, {"instruction": "// Open implements the Executor Open interface.", "input": "go language", "output": "func (e *CheckIndexRangeExec) Open(ctx context.Context) error {\n\ttCols := e.table.Cols()\n\tfor _, ic := range e.index.Columns {\n\t\tcol := tCols[ic.Offset]\n\t\te.cols = append(e.cols, col)\n\t}\n\n\tcolTypeForHandle := e.schema.Columns[len(e.cols)].RetType\n\te.cols = append(e.cols, &model.ColumnInfo{\n\t\tID:        model.ExtraHandleID,\n\t\tName:      model.ExtraHandleName,\n\t\tFieldType: *colTypeForHandle,\n\t})\n\n\te.srcChunk = e.newFirstChunk()\n\tdagPB, err := e.buildDAGPB()\n\tif err != nil {\n\t\treturn err\n\t}\n\tsc := e.ctx.GetSessionVars().StmtCtx\n\tvar builder distsql.RequestBuilder\n\tkvReq, err := builder.SetIndexRanges(sc, e.table.ID, e.index.ID, ranger.FullRange()).\n\t\tSetDAGRequest(dagPB).\n\t\tSetKeepOrder(true).\n\t\tSetFromSessionVars(e.ctx.GetSessionVars()).\n\t\tBuild()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\te.result, err = distsql.Select(ctx, e.ctx, kvReq, e.retFieldTypes, statistics.NewQueryFeedback(0, nil, 0, false))\n\tif err != nil {\n\t\treturn err\n\t}\n\te.result.Fetch(ctx)\n\treturn nil\n}", "category": "Python"}, {"instruction": "// FetchBodies sends a block body retrieval request to the remote peer.", "input": "go language", "output": "func (p *peerConnection) FetchBodies(request *fetchRequest) error {\n\t// Sanity check the protocol version\n\tif p.version < 62 {\n\t\tpanic(fmt.Sprintf(\"body fetch [eth/62+] requested on eth/%d\", p.version))\n\t}\n\t// Short circuit if the peer is already fetching\n\tif !atomic.CompareAndSwapInt32(&p.blockIdle, 0, 1) {\n\t\treturn errAlreadyFetching\n\t}\n\tp.blockStarted = time.Now()\n\n\t// Convert the header set to a retrievable slice\n\thashes := make([]common.Hash, 0, len(request.Headers))\n\tfor _, header := range request.Headers {\n\t\thashes = append(hashes, header.Hash())\n\t}\n\tgo p.peer.RequestBodies(hashes)\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// GetFromKubeletConfigMap returns the pointer to the ComponentConfig API object read from the kubelet-config-version\n// ConfigMap map stored in the cluster", "input": "go language", "output": "func GetFromKubeletConfigMap(client clientset.Interface, version *version.Version) (runtime.Object, error) {\n\n\t// Read the ConfigMap from the cluster based on what version the kubelet is\n\tconfigMapName := kubeadmconstants.GetKubeletConfigMapName(version)\n\tkubeletCfg, err := client.CoreV1().ConfigMaps(metav1.NamespaceSystem).Get(configMapName, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkubeletConfigData, ok := kubeletCfg.Data[kubeadmconstants.KubeletBaseConfigurationConfigMapKey]\n\tif !ok {\n\t\treturn nil, errors.Errorf(\"unexpected error when reading %s ConfigMap: %s key value pair missing\",\n\t\t\tconfigMapName, kubeadmconstants.KubeletBaseConfigurationConfigMapKey)\n\t}\n\n\t// Decodes the kubeletConfigData into the internal component config\n\tobj := &kubeletconfig.KubeletConfiguration{}\n\terr = unmarshalObject(obj, []byte(kubeletConfigData))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn obj, nil\n}", "category": "Python"}, {"instruction": "// MarshalInitConfigurationToBytes marshals the internal InitConfiguration object to bytes. It writes the embedded\n// ClusterConfiguration object with ComponentConfigs out as separate YAML documents", "input": "go language", "output": "func MarshalInitConfigurationToBytes(cfg *kubeadmapi.InitConfiguration, gv schema.GroupVersion) ([]byte, error) {\n\tinitbytes, err := kubeadmutil.MarshalToYamlForCodecs(cfg, gv, kubeadmscheme.Codecs)\n\tif err != nil {\n\t\treturn []byte{}, err\n\t}\n\tallFiles := [][]byte{initbytes}\n\n\t// Exception: If the specified groupversion is targeting the internal type, don't print embedded ClusterConfiguration contents\n\t// This is mostly used for unit testing. In a real scenario the internal version of the API is never marshalled as-is.\n\tif gv.Version != runtime.APIVersionInternal {\n\t\tclusterbytes, err := MarshalClusterConfigurationToBytes(&cfg.ClusterConfiguration, gv)\n\t\tif err != nil {\n\t\t\treturn []byte{}, err\n\t\t}\n\t\tallFiles = append(allFiles, clusterbytes)\n\t}\n\treturn bytes.Join(allFiles, []byte(kubeadmconstants.YAMLDocumentSeparator)), nil\n}", "category": "Python"}, {"instruction": "// evalString evals a builtinInet6AtonSig.\n// See https://dev.mysql.com/doc/refman/5.7/en/miscellaneous-functions.html#function_inet6-aton", "input": "go language", "output": "func (b *builtinInet6AtonSig) evalString(row chunk.Row) (string, bool, error) {\n\tval, isNull, err := b.args[0].EvalString(b.ctx, row)\n\tif err != nil || isNull {\n\t\treturn \"\", true, err\n\t}\n\n\tif len(val) == 0 {\n\t\treturn \"\", true, nil\n\t}\n\n\tip := net.ParseIP(val)\n\tif ip == nil {\n\t\treturn \"\", true, nil\n\t}\n\n\tvar isMappedIpv6 bool\n\tif ip.To4() != nil && strings.Contains(val, \":\") {\n\t\t//mapped ipv6 address.\n\t\tisMappedIpv6 = true\n\t}\n\n\tvar result []byte\n\tif isMappedIpv6 || ip.To4() == nil {\n\t\tresult = make([]byte, net.IPv6len)\n\t} else {\n\t\tresult = make([]byte, net.IPv4len)\n\t}\n\n\tif isMappedIpv6 {\n\t\tcopy(result[12:], ip.To4())\n\t\tresult[11] = 0xff\n\t\tresult[10] = 0xff\n\t} else if ip.To4() == nil {\n\t\tcopy(result, ip.To16())\n\t} else {\n\t\tcopy(result, ip.To4())\n\t}\n\n\treturn string(result[:]), false, nil\n}", "category": "Python"}, {"instruction": "// newPuller returns a Puller interface that will pull from either a v1 or v2\n// registry. The endpoint argument contains a Version field that determines\n// whether a v1 or v2 puller will be created. The other parameters are passed\n// through to the underlying puller implementation for use during the actual\n// pull operation.", "input": "go language", "output": "func newPuller(endpoint registry.APIEndpoint, repoInfo *registry.RepositoryInfo, imagePullConfig *ImagePullConfig) (Puller, error) {\n\tswitch endpoint.Version {\n\tcase registry.APIVersion2:\n\t\treturn &v2Puller{\n\t\t\tV2MetadataService: metadata.NewV2MetadataService(imagePullConfig.MetadataStore),\n\t\t\tendpoint:          endpoint,\n\t\t\tconfig:            imagePullConfig,\n\t\t\trepoInfo:          repoInfo,\n\t\t}, nil\n\tcase registry.APIVersion1:\n\t\treturn &v1Puller{\n\t\t\tv1IDService: metadata.NewV1IDService(imagePullConfig.MetadataStore),\n\t\t\tendpoint:    endpoint,\n\t\t\tconfig:      imagePullConfig,\n\t\t\trepoInfo:    repoInfo,\n\t\t}, nil\n\t}\n\treturn nil, fmt.Errorf(\"unknown version %d for registry %s\", endpoint.Version, endpoint.URL)\n}", "category": "Python"}, {"instruction": "// StartSaveSpan stores the span specified in the passed context for later retrieval\n// The span object but be context value on the key StoreLabelId.\n// It will be stored under the the following string key context.Value(StoreLabelId)|.|context.Value(StoreLabelMeta)", "input": "go language", "output": "func StartSaveSpan(ctx context.Context) context.Context {\n\tif !Enabled {\n\t\treturn ctx\n\t}\n\ttraceId := ctx.Value(StoreLabelId)\n\n\tif traceId != nil {\n\t\ttraceStr := traceId.(string)\n\t\tvar sp opentracing.Span\n\t\tctx, sp = spancontext.StartSpan(\n\t\t\tctx,\n\t\t\ttraceStr,\n\t\t)\n\t\ttraceMeta := ctx.Value(StoreLabelMeta)\n\t\tif traceMeta != nil {\n\t\t\ttraceStr = traceStr + \".\" + traceMeta.(string)\n\t\t}\n\t\tstore.spans.Store(traceStr, sp)\n\t}\n\treturn ctx\n}", "category": "Python"}, {"instruction": "// EqualDatums compare if a and b contains the same datum values.", "input": "go language", "output": "func EqualDatums(sc *stmtctx.StatementContext, a []Datum, b []Datum) (bool, error) {\n\tif len(a) != len(b) {\n\t\treturn false, nil\n\t}\n\tif a == nil && b == nil {\n\t\treturn true, nil\n\t}\n\tif a == nil || b == nil {\n\t\treturn false, nil\n\t}\n\tfor i, ai := range a {\n\t\tv, err := ai.CompareDatum(sc, &b[i])\n\t\tif err != nil {\n\t\t\treturn false, errors.Trace(err)\n\t\t}\n\t\tif v != 0 {\n\t\t\treturn false, nil\n\t\t}\n\t}\n\treturn true, nil\n}", "category": "Python"}, {"instruction": "// GetSubresourcesForVersion returns the subresources for given version or nil.", "input": "go language", "output": "func GetSubresourcesForVersion(crd *CustomResourceDefinition, version string) (*CustomResourceSubresources, error) {\n\tif !HasPerVersionSubresources(crd.Spec.Versions) {\n\t\treturn crd.Spec.Subresources, nil\n\t}\n\tif crd.Spec.Subresources != nil {\n\t\treturn nil, fmt.Errorf(\"malformed CustomResourceDefinition %s version %s: top-level and per-version subresources must be mutual exclusive\", crd.Name, version)\n\t}\n\tfor _, v := range crd.Spec.Versions {\n\t\tif version == v.Name {\n\t\t\treturn v.Subresources, nil\n\t\t}\n\t}\n\treturn nil, fmt.Errorf(\"version %s not found in CustomResourceDefinition: %v\", version, crd.Name)\n}", "category": "Python"}, {"instruction": "// RecommendedDefaultNodeLifecycleControllerConfiguration defaults a pointer to a\n// NodeLifecycleControllerConfiguration struct. This will set the recommended default\n// values, but they may be subject to change between API versions. This function\n// is intentionally not registered in the scheme as a \"normal\" `SetDefaults_Foo`\n// function to allow consumers of this type to set whatever defaults for their\n// embedded configs. Forcing consumers to use these defaults would be problematic\n// as defaulting in the scheme is done as part of the conversion, and there would\n// be no easy way to opt-out. Instead, if you want to use this defaulting method\n// run it in your wrapper struct of this type in its `SetDefaults_` method.", "input": "go language", "output": "func RecommendedDefaultNodeLifecycleControllerConfiguration(obj *kubectrlmgrconfigv1alpha1.NodeLifecycleControllerConfiguration) {\n\tzero := metav1.Duration{}\n\tif obj.PodEvictionTimeout == zero {\n\t\tobj.PodEvictionTimeout = metav1.Duration{Duration: 5 * time.Minute}\n\t}\n\tif obj.NodeMonitorGracePeriod == zero {\n\t\tobj.NodeMonitorGracePeriod = metav1.Duration{Duration: 40 * time.Second}\n\t}\n\tif obj.NodeStartupGracePeriod == zero {\n\t\tobj.NodeStartupGracePeriod = metav1.Duration{Duration: 60 * time.Second}\n\t}\n\tif obj.EnableTaintManager == nil {\n\t\tobj.EnableTaintManager = utilpointer.BoolPtr(true)\n\t}\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *ISCSIVolumeSource) DeepCopyInto(out *ISCSIVolumeSource) {\n\t*out = *in\n\tif in.Portals != nil {\n\t\tin, out := &in.Portals, &out.Portals\n\t\t*out = make([]string, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\tif in.SecretRef != nil {\n\t\tin, out := &in.SecretRef, &out.SecretRef\n\t\t*out = new(LocalObjectReference)\n\t\t**out = **in\n\t}\n\tif in.InitiatorName != nil {\n\t\tin, out := &in.InitiatorName, &out.InitiatorName\n\t\t*out = new(string)\n\t\t**out = **in\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// Admit makes an admission decision based on the request attributes", "input": "go language", "output": "func (a *AlwaysPullImages) Admit(attributes admission.Attributes, o admission.ObjectInterfaces) (err error) {\n\t// Ignore all calls to subresources or resources other than pods.\n\tif shouldIgnore(attributes) {\n\t\treturn nil\n\t}\n\tpod, ok := attributes.GetObject().(*api.Pod)\n\tif !ok {\n\t\treturn apierrors.NewBadRequest(\"Resource was marked with kind Pod but was unable to be converted\")\n\t}\n\n\tfor i := range pod.Spec.InitContainers {\n\t\tpod.Spec.InitContainers[i].ImagePullPolicy = api.PullAlways\n\t}\n\n\tfor i := range pod.Spec.Containers {\n\t\tpod.Spec.Containers[i].ImagePullPolicy = api.PullAlways\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// GetExec gets the URL the exec will be served from, or nil if the Kubelet will serve it.", "input": "go language", "output": "func (kl *Kubelet) GetExec(podFullName string, podUID types.UID, containerName string, cmd []string, streamOpts remotecommandserver.Options) (*url.URL, error) {\n\tcontainer, err := kl.findContainer(podFullName, podUID, containerName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif container == nil {\n\t\treturn nil, fmt.Errorf(\"container not found (%q)\", containerName)\n\t}\n\treturn kl.streamingRuntime.GetExec(container.ID, cmd, streamOpts.Stdin, streamOpts.Stdout, streamOpts.Stderr, streamOpts.TTY)\n}", "category": "Python"}, {"instruction": "// points2Ranges build index ranges from range points.\n// Only one column is built there. If there're multiple columns, use appendPoints2Ranges.", "input": "go language", "output": "func points2Ranges(sc *stmtctx.StatementContext, rangePoints []point, tp *types.FieldType) ([]*Range, error) {\n\tranges := make([]*Range, 0, len(rangePoints)/2)\n\tfor i := 0; i < len(rangePoints); i += 2 {\n\t\tstartPoint, err := convertPoint(sc, rangePoints[i], tp)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Trace(err)\n\t\t}\n\t\tendPoint, err := convertPoint(sc, rangePoints[i+1], tp)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Trace(err)\n\t\t}\n\t\tless, err := validInterval(sc, startPoint, endPoint)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Trace(err)\n\t\t}\n\t\tif !less {\n\t\t\tcontinue\n\t\t}\n\t\t// If column has not null flag, [null, null] should be removed.\n\t\tif mysql.HasNotNullFlag(tp.Flag) && endPoint.value.Kind() == types.KindNull {\n\t\t\tcontinue\n\t\t}\n\n\t\tran := &Range{\n\t\t\tLowVal:      []types.Datum{startPoint.value},\n\t\t\tLowExclude:  startPoint.excl,\n\t\t\tHighVal:     []types.Datum{endPoint.value},\n\t\t\tHighExclude: endPoint.excl,\n\t\t}\n\t\tranges = append(ranges, ran)\n\t}\n\treturn ranges, nil\n}", "category": "Python"}, {"instruction": "// setProjectQuota - set the quota for project id on xfs block device", "input": "go language", "output": "func setProjectQuota(backingFsBlockDev string, projectID uint32, quota Quota) error {\n\tvar d C.fs_disk_quota_t\n\td.d_version = C.FS_DQUOT_VERSION\n\td.d_id = C.__u32(projectID)\n\td.d_flags = C.XFS_PROJ_QUOTA\n\n\td.d_fieldmask = C.FS_DQ_BHARD | C.FS_DQ_BSOFT\n\td.d_blk_hardlimit = C.__u64(quota.Size / 512)\n\td.d_blk_softlimit = d.d_blk_hardlimit\n\n\tvar cs = C.CString(backingFsBlockDev)\n\tdefer C.free(unsafe.Pointer(cs))\n\n\t_, _, errno := unix.Syscall6(unix.SYS_QUOTACTL, C.Q_XSETPQLIM,\n\t\tuintptr(unsafe.Pointer(cs)), uintptr(d.d_id),\n\t\tuintptr(unsafe.Pointer(&d)), 0, 0)\n\tif errno != 0 {\n\t\treturn errors.Wrapf(errno, \"failed to set quota limit for projid %d on %s\",\n\t\t\tprojectID, backingFsBlockDev)\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// validateMetaPair checks that the given key/value pair is in a valid format", "input": "go language", "output": "func validateMetaPair(key, value string, allowConsulPrefix bool) error {\n\tif key == \"\" {\n\t\treturn fmt.Errorf(\"Key cannot be blank\")\n\t}\n\tif !metaKeyFormat(key) {\n\t\treturn fmt.Errorf(\"Key contains invalid characters\")\n\t}\n\tif len(key) > metaKeyMaxLength {\n\t\treturn fmt.Errorf(\"Key is too long (limit: %d characters)\", metaKeyMaxLength)\n\t}\n\tif strings.HasPrefix(key, metaKeyReservedPrefix) && !allowConsulPrefix {\n\t\treturn fmt.Errorf(\"Key prefix '%s' is reserved for internal use\", metaKeyReservedPrefix)\n\t}\n\tif len(value) > metaValueMaxLength {\n\t\treturn fmt.Errorf(\"Value is too long (limit: %d characters)\", metaValueMaxLength)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// ===== Example: Ad hoc rich query ========================================================\n// queryMarbles uses a query string to perform a query for marbles.\n// Query string matching state database syntax is passed in and executed as is.\n// Supports ad hoc queries that can be defined at runtime by the client.\n// If this is not desired, follow the queryMarblesForOwner example for parameterized queries.\n// Only available on state databases that support rich query (e.g. CouchDB)\n// =========================================================================================", "input": "go language", "output": "func (t *SimpleChaincode) queryMarbles(stub shim.ChaincodeStubInterface, args []string) pb.Response {\n\n\t//   0\n\t// \"queryString\"\n\tif len(args) < 1 {\n\t\treturn shim.Error(\"Incorrect number of arguments. Expecting 1\")\n\t}\n\n\tqueryString := args[0]\n\n\tqueryResults, err := getQueryResultForQueryString(stub, queryString)\n\tif err != nil {\n\t\treturn shim.Error(err.Error())\n\t}\n\treturn shim.Success(queryResults)\n}", "category": "Python"}, {"instruction": "// splitNodeItemKey returns the components of a key created by nodeItemKey.", "input": "go language", "output": "func splitNodeItemKey(key []byte) (id ID, ip net.IP, field string) {\n\tid, key = splitNodeKey(key)\n\t// Skip discover root.\n\tif string(key) == dbDiscoverRoot {\n\t\treturn id, nil, \"\"\n\t}\n\tkey = key[len(dbDiscoverRoot)+1:]\n\t// Split out the IP.\n\tip = net.IP(key[:16])\n\tif ip4 := ip.To4(); ip4 != nil {\n\t\tip = ip4\n\t}\n\tkey = key[16+1:]\n\t// Field is the remainder of key.\n\tfield = string(key)\n\treturn id, ip, field\n}", "category": "Python"}, {"instruction": "// filterMembers redacts members that the token doesn't have access to.", "input": "go language", "output": "func (a *Agent) filterMembers(token string, members *[]serf.Member) error {\n\t// Resolve the token and bail if ACLs aren't enabled.\n\trule, err := a.resolveToken(token)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif rule == nil {\n\t\treturn nil\n\t}\n\n\t// Filter out members based on the node policy.\n\tm := *members\n\tfor i := 0; i < len(m); i++ {\n\t\tnode := m[i].Name\n\t\tif rule.NodeRead(node) {\n\t\t\tcontinue\n\t\t}\n\t\ta.logger.Printf(\"[DEBUG] agent: dropping node %q from result due to ACLs\", node)\n\t\tm = append(m[:i], m[i+1:]...)\n\t\ti--\n\t}\n\t*members = m\n\treturn nil\n}", "category": "Python"}, {"instruction": "// ResolveIndices implements Plan interface.", "input": "go language", "output": "func (p *basePhysicalAgg) ResolveIndices() (err error) {\n\terr = p.physicalSchemaProducer.ResolveIndices()\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, aggFun := range p.AggFuncs {\n\t\tfor i, arg := range aggFun.Args {\n\t\t\taggFun.Args[i], err = arg.ResolveIndices(p.children[0].Schema())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tfor i, item := range p.GroupByItems {\n\t\tp.GroupByItems[i], err = item.ResolveIndices(p.children[0].Schema())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// update keeps track of the downloader events. Please be aware that this is a one shot type of update loop.\n// It's entered once and as soon as `Done` or `Failed` has been broadcasted the events are unregistered and\n// the loop is exited. This to prevent a major security vuln where external parties can DOS you with blocks\n// and halt your mining operation for as long as the DOS continues.", "input": "go language", "output": "func (self *Miner) update() {\n\tevents := self.mux.Subscribe(downloader.StartEvent{}, downloader.DoneEvent{}, downloader.FailedEvent{})\n\tdefer events.Unsubscribe()\n\n\tfor {\n\t\tselect {\n\t\tcase ev := <-events.Chan():\n\t\t\tif ev == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tswitch ev.Data.(type) {\n\t\t\tcase downloader.StartEvent:\n\t\t\t\tatomic.StoreInt32(&self.canStart, 0)\n\t\t\t\tif self.Mining() {\n\t\t\t\t\tself.Stop()\n\t\t\t\t\tatomic.StoreInt32(&self.shouldStart, 1)\n\t\t\t\t\tlog.Info(\"Mining aborted due to sync\")\n\t\t\t\t}\n\t\t\tcase downloader.DoneEvent, downloader.FailedEvent:\n\t\t\t\tshouldStart := atomic.LoadInt32(&self.shouldStart) == 1\n\n\t\t\t\tatomic.StoreInt32(&self.canStart, 1)\n\t\t\t\tatomic.StoreInt32(&self.shouldStart, 0)\n\t\t\t\tif shouldStart {\n\t\t\t\t\tself.Start(self.coinbase)\n\t\t\t\t}\n\t\t\t\t// stop immediately and ignore all further pending events\n\t\t\t\treturn\n\t\t\t}\n\t\tcase <-self.exitCh:\n\t\t\treturn\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// SetFormat updates how log records are formatted and encoded. Log entries\n// created after this method has completed will use the new format.\n//\n// An error is returned if the log format specification cannot be parsed.", "input": "go language", "output": "func (s *Logging) SetFormat(format string) error {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\tif format == \"\" {\n\t\tformat = defaultFormat\n\t}\n\n\tif format == \"json\" {\n\t\ts.encoding = JSON\n\t\treturn nil\n\t}\n\n\tif format == \"logfmt\" {\n\t\ts.encoding = LOGFMT\n\t\treturn nil\n\t}\n\n\tformatters, err := fabenc.ParseFormat(format)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.multiFormatter.SetFormatters(formatters)\n\ts.encoding = CONSOLE\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// ticketsInWindow returns the tickets of a given topic in the registration window.", "input": "go language", "output": "func (s *ticketStore) ticketsInWindow(topic Topic) []ticketRef {\n\t// Sanity check that the topic still exists before operating on it\n\tif s.tickets[topic] == nil {\n\t\tlog.Warn(\"Listing non-existing discovery tickets\", \"topic\", topic)\n\t\treturn nil\n\t}\n\t// Gather all the tickers in the next time window\n\tvar tickets []ticketRef\n\n\tbuckets := s.tickets[topic].buckets\n\tfor idx := timeBucket(0); idx < timeWindow; idx++ {\n\t\ttickets = append(tickets, buckets[s.lastBucketFetched+idx]...)\n\t}\n\tlog.Trace(\"Retrieved discovery registration tickets\", \"topic\", topic, \"from\", s.lastBucketFetched, \"tickets\", len(tickets))\n\treturn tickets\n}", "category": "Python"}, {"instruction": "// DeleteExpectations deletes the UID set and invokes DeleteExpectations on the\n// underlying ControllerExpectationsInterface.", "input": "go language", "output": "func (u *UIDTrackingControllerExpectations) DeleteExpectations(rcKey string) {\n\tu.uidStoreLock.Lock()\n\tdefer u.uidStoreLock.Unlock()\n\n\tu.ControllerExpectationsInterface.DeleteExpectations(rcKey)\n\tif uidExp, exists, err := u.uidStore.GetByKey(rcKey); err == nil && exists {\n\t\tif err := u.uidStore.Delete(uidExp); err != nil {\n\t\t\tklog.V(2).Infof(\"Error deleting uid expectations for controller %v: %v\", rcKey, err)\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// GetPath returns the path to the user specific mount of a Quobyte volume\n// Returns a path in the format ../user#group@volume", "input": "go language", "output": "func (quobyteVolume *quobyte) GetPath() string {\n\tuser := quobyteVolume.user\n\tif len(user) == 0 {\n\t\tuser = \"root\"\n\t}\n\n\tgroup := quobyteVolume.group\n\tif len(group) == 0 {\n\t\tgroup = \"nfsnobody\"\n\t}\n\n\t// Quobyte has only one mount in the PluginDir where all Volumes are mounted\n\t// The Quobyte client does a fixed-user mapping\n\tpluginDir := quobyteVolume.plugin.host.GetPluginDir(utilstrings.EscapeQualifiedName(quobytePluginName))\n\treturn filepath.Join(pluginDir, fmt.Sprintf(\"%s#%s@%s\", user, group, quobyteVolume.volume))\n}", "category": "Python"}, {"instruction": "// ReadDataSource mocks base method", "input": "go language", "output": "func (m *MockProviderClient) ReadDataSource(arg0 context.Context, arg1 *tfplugin5.ReadDataSource_Request, arg2 ...grpc.CallOption) (*tfplugin5.ReadDataSource_Response, error) {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{arg0, arg1}\n\tfor _, a := range arg2 {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"ReadDataSource\", varargs...)\n\tret0, _ := ret[0].(*tfplugin5.ReadDataSource_Response)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}", "category": "Python"}, {"instruction": "// ToProtoModels builds the proto formatted models from OpenAPI spec", "input": "go language", "output": "func ToProtoModels(openAPISpec *spec.Swagger) (proto.Models, error) {\n\tspecBytes, err := json.MarshalIndent(openAPISpec, \" \", \" \")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar info yaml.MapSlice\n\terr = yaml.Unmarshal(specBytes, &info)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdoc, err := openapi_v2.NewDocument(info, compiler.NewContext(\"$root\", nil))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmodels, err := proto.NewOpenAPIData(doc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn models, nil\n}", "category": "Python"}, {"instruction": "// MatchDomain return true if a domain match the cert domain", "input": "go language", "output": "func MatchDomain(domain string, certDomain string) bool {\n\tif domain == certDomain {\n\t\treturn true\n\t}\n\n\tfor len(certDomain) > 0 && certDomain[len(certDomain)-1] == '.' {\n\t\tcertDomain = certDomain[:len(certDomain)-1]\n\t}\n\n\tlabels := strings.Split(domain, \".\")\n\tfor i := range labels {\n\t\tlabels[i] = \"*\"\n\t\tcandidate := strings.Join(labels, \".\")\n\t\tif certDomain == candidate {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "category": "Python"}, {"instruction": "// Equal compares two diffs for exact equality.\n//\n// This is different from the Same comparison that is supported which\n// checks for operation equality taking into account computed values. Equal\n// instead checks for exact equality.", "input": "go language", "output": "func (d *Diff) Equal(d2 *Diff) bool {\n\t// If one is nil, they must both be nil\n\tif d == nil || d2 == nil {\n\t\treturn d == d2\n\t}\n\n\t// Sort the modules\n\tsort.Sort(moduleDiffSort(d.Modules))\n\tsort.Sort(moduleDiffSort(d2.Modules))\n\n\t// Copy since we have to modify the module destroy flag to false so\n\t// we don't compare that. TODO: delete this when we get rid of the\n\t// destroy flag on modules.\n\tdCopy := d.DeepCopy()\n\td2Copy := d2.DeepCopy()\n\tfor _, m := range dCopy.Modules {\n\t\tm.Destroy = false\n\t}\n\tfor _, m := range d2Copy.Modules {\n\t\tm.Destroy = false\n\t}\n\n\t// Use DeepEqual\n\treturn reflect.DeepEqual(dCopy, d2Copy)\n}", "category": "Python"}, {"instruction": "// Compare compares the nodes and pods of NodeLister with Cache.Snapshot.", "input": "go language", "output": "func (c *CacheComparer) Compare() error {\n\tklog.V(3).Info(\"cache comparer started\")\n\tdefer klog.V(3).Info(\"cache comparer finished\")\n\n\tnodes, err := c.NodeLister.List(labels.Everything())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpods, err := c.PodLister.List(labels.Everything())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsnapshot := c.Cache.Snapshot()\n\n\tpendingPods := c.PodQueue.PendingPods()\n\n\tif missed, redundant := c.CompareNodes(nodes, snapshot.Nodes); len(missed)+len(redundant) != 0 {\n\t\tklog.Warningf(\"cache mismatch: missed nodes: %s; redundant nodes: %s\", missed, redundant)\n\t}\n\n\tif missed, redundant := c.ComparePods(pods, pendingPods, snapshot.Nodes); len(missed)+len(redundant) != 0 {\n\t\tklog.Warningf(\"cache mismatch: missed pods: %s; redundant pods: %s\", missed, redundant)\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// EnsurePortProxyRule checks if the specified redirect exists, if not creates it.", "input": "go language", "output": "func (runner *runner) EnsurePortProxyRule(args []string) (bool, error) {\n\tklog.V(4).Infof(\"running netsh interface portproxy add v4tov4 %v\", args)\n\tout, err := runner.exec.Command(cmdNetsh, args...).CombinedOutput()\n\n\tif err == nil {\n\t\treturn true, nil\n\t}\n\tif ee, ok := err.(utilexec.ExitError); ok {\n\t\t// netsh uses exit(0) to indicate a success of the operation,\n\t\t// as compared to a malformed commandline, for example.\n\t\tif ee.Exited() && ee.ExitStatus() != 0 {\n\t\t\treturn false, nil\n\t\t}\n\t}\n\treturn false, fmt.Errorf(\"error checking portproxy rule: %v: %s\", err, out)\n\n}", "category": "Python"}, {"instruction": "// PrepareForCreate clears the status of a CustomResource before creation.", "input": "go language", "output": "func (a customResourceStrategy) PrepareForCreate(ctx context.Context, obj runtime.Object) {\n\tif utilfeature.DefaultFeatureGate.Enabled(apiextensionsfeatures.CustomResourceSubresources) && a.status != nil {\n\t\tcustomResourceObject := obj.(*unstructured.Unstructured)\n\t\tcustomResource := customResourceObject.UnstructuredContent()\n\n\t\t// create cannot set status\n\t\tif _, ok := customResource[\"status\"]; ok {\n\t\t\tdelete(customResource, \"status\")\n\t\t}\n\t}\n\n\taccessor, _ := meta.Accessor(obj)\n\taccessor.SetGeneration(1)\n}", "category": "Python"}, {"instruction": "// PeersInfo returns an array of metadata objects describing connected peers.", "input": "go language", "output": "func (srv *Server) PeersInfo() []*PeerInfo {\n\t// Gather all the generic and sub-protocol specific infos\n\tinfos := make([]*PeerInfo, 0, srv.PeerCount())\n\tfor _, peer := range srv.Peers() {\n\t\tif peer != nil {\n\t\t\tinfos = append(infos, peer.Info())\n\t\t}\n\t}\n\t// Sort the result array alphabetically by node identifier\n\tfor i := 0; i < len(infos); i++ {\n\t\tfor j := i + 1; j < len(infos); j++ {\n\t\t\tif infos[i].ID > infos[j].ID {\n\t\t\t\tinfos[i], infos[j] = infos[j], infos[i]\n\t\t\t}\n\t\t}\n\t}\n\treturn infos\n}", "category": "Python"}, {"instruction": "// DropDisabledFields removes disabled fields from the pod security policy spec.\n// This should be called from PrepareForCreate/PrepareForUpdate for all resources containing a od security policy spec.", "input": "go language", "output": "func DropDisabledFields(pspSpec, oldPSPSpec *policy.PodSecurityPolicySpec) {\n\tif !utilfeature.DefaultFeatureGate.Enabled(features.ProcMountType) && !allowedProcMountTypesInUse(oldPSPSpec) {\n\t\tpspSpec.AllowedProcMountTypes = nil\n\t}\n\tif !utilfeature.DefaultFeatureGate.Enabled(features.RunAsGroup) && (oldPSPSpec == nil || oldPSPSpec.RunAsGroup == nil) {\n\t\tpspSpec.RunAsGroup = nil\n\t}\n\tif !utilfeature.DefaultFeatureGate.Enabled(features.Sysctls) && !sysctlsInUse(oldPSPSpec) {\n\t\tpspSpec.AllowedUnsafeSysctls = nil\n\t\tpspSpec.ForbiddenSysctls = nil\n\t}\n\tif !utilfeature.DefaultFeatureGate.Enabled(features.CSIInlineVolume) {\n\t\tpspSpec.AllowedCSIDrivers = nil\n\t}\n\tif !utilfeature.DefaultFeatureGate.Enabled(features.RuntimeClass) &&\n\t\t(oldPSPSpec == nil || oldPSPSpec.RuntimeClass == nil) {\n\t\tpspSpec.RuntimeClass = nil\n\t}\n}", "category": "Python"}, {"instruction": "// parseConfig returns a parsed configuration for an Azure cloudprovider config file", "input": "go language", "output": "func parseConfig(configReader io.Reader) (*Config, error) {\n\tvar config Config\n\n\tif configReader == nil {\n\t\treturn &config, nil\n\t}\n\n\tconfigContents, err := ioutil.ReadAll(configReader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = yaml.Unmarshal(configContents, &config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The resource group name may be in different cases from different Azure APIs, hence it is converted to lower here.\n\t// See more context at https://github.com/kubernetes/kubernetes/issues/71994.\n\tconfig.ResourceGroup = strings.ToLower(config.ResourceGroup)\n\treturn &config, nil\n}", "category": "Python"}, {"instruction": "// createTxidRangeEndKey returns a endKey to do a range query on transient store using txid", "input": "go language", "output": "func createTxidRangeEndKey(txid string) []byte {\n\tvar endKey []byte\n\tendKey = append(endKey, prwsetPrefix)\n\tendKey = append(endKey, compositeKeySep)\n\tendKey = append(endKey, []byte(txid)...)\n\t// As txid is a fixed length string (i.e., 128 bits long UUID), 0xff can be used as a stopper.\n\t// Otherwise a super-string of a given txid would also fall under the end key of range query.\n\tendKey = append(endKey, byte(0xff))\n\treturn endKey\n}", "category": "Python"}, {"instruction": "// updateSchemaVersion increments the schema version by 1 and sets SchemaDiff.", "input": "go language", "output": "func updateSchemaVersion(t *meta.Meta, job *model.Job) (int64, error) {\n\tschemaVersion, err := t.GenSchemaVersion()\n\tif err != nil {\n\t\treturn 0, errors.Trace(err)\n\t}\n\tdiff := &model.SchemaDiff{\n\t\tVersion:  schemaVersion,\n\t\tType:     job.Type,\n\t\tSchemaID: job.SchemaID,\n\t}\n\tif job.Type == model.ActionTruncateTable {\n\t\t// Truncate table has two table ID, should be handled differently.\n\t\terr = job.DecodeArgs(&diff.TableID)\n\t\tif err != nil {\n\t\t\treturn 0, errors.Trace(err)\n\t\t}\n\t\tdiff.OldTableID = job.TableID\n\t} else if job.Type == model.ActionRenameTable {\n\t\terr = job.DecodeArgs(&diff.OldSchemaID)\n\t\tif err != nil {\n\t\t\treturn 0, errors.Trace(err)\n\t\t}\n\t\tdiff.TableID = job.TableID\n\t} else {\n\t\tdiff.TableID = job.TableID\n\t}\n\terr = t.SetSchemaDiff(diff)\n\treturn schemaVersion, errors.Trace(err)\n}", "category": "Python"}, {"instruction": "// String implements fmt.Stringer and sanitizes sensitive fields of\n// TLSClientConfig to prevent accidental leaking via logs.", "input": "go language", "output": "func (c TLSClientConfig) String() string {\n\tcc := sanitizedTLSClientConfig{\n\t\tInsecure:   c.Insecure,\n\t\tServerName: c.ServerName,\n\t\tCertFile:   c.CertFile,\n\t\tKeyFile:    c.KeyFile,\n\t\tCAFile:     c.CAFile,\n\t\tCertData:   c.CertData,\n\t\tKeyData:    c.KeyData,\n\t\tCAData:     c.CAData,\n\t}\n\t// Explicitly mark non-empty credential fields as redacted.\n\tif len(cc.CertData) != 0 {\n\t\tcc.CertData = []byte(\"--- TRUNCATED ---\")\n\t}\n\tif len(cc.KeyData) != 0 {\n\t\tcc.KeyData = []byte(\"--- REDACTED ---\")\n\t}\n\treturn fmt.Sprintf(\"%#v\", cc)\n}", "category": "Python"}, {"instruction": "// Visit walks the provided node, transforming field initializations of the form\n// m.Field = &OptionalType{} -> m.Field = OptionalType{}", "input": "go language", "output": "func (v optionalAssignmentVisitor) Visit(n ast.Node) ast.Visitor {\n\tswitch t := n.(type) {\n\tcase *ast.AssignStmt:\n\t\tif len(t.Lhs) == 1 && len(t.Rhs) == 1 {\n\t\t\tif !isFieldSelector(t.Lhs[0], \"m\", \"\") {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tunary, ok := t.Rhs[0].(*ast.UnaryExpr)\n\t\t\tif !ok || unary.Op != token.AND {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tcomposite, ok := unary.X.(*ast.CompositeLit)\n\t\t\tif !ok || composite.Type == nil || len(composite.Elts) != 0 {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif ident, ok := composite.Type.(*ast.Ident); ok && v.fn(ident.Name) {\n\t\t\t\tt.Rhs[0] = composite\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\treturn v\n}", "category": "Python"}, {"instruction": "// Get the remote state.", "input": "go language", "output": "func (r *remoteClient) Get() (*remote.Payload, error) {\n\tctx := context.Background()\n\n\tsv, err := r.client.StateVersions.Current(ctx, r.workspace.ID)\n\tif err != nil {\n\t\tif err == tfe.ErrResourceNotFound {\n\t\t\t// If no state exists, then return nil.\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"Error retrieving state: %v\", err)\n\t}\n\n\tstate, err := r.client.StateVersions.Download(ctx, sv.DownloadURL)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error downloading state: %v\", err)\n\t}\n\n\t// If the state is empty, then return nil.\n\tif len(state) == 0 {\n\t\treturn nil, nil\n\t}\n\n\t// Get the MD5 checksum of the state.\n\tsum := md5.Sum(state)\n\n\treturn &remote.Payload{\n\t\tData: state,\n\t\tMD5:  sum[:],\n\t}, nil\n}", "category": "Python"}, {"instruction": "// MergeExecDetails merges a single region execution details into self, used to print\n// the information in slow query log.", "input": "go language", "output": "func (sc *StatementContext) MergeExecDetails(details *execdetails.ExecDetails, commitDetails *execdetails.CommitDetails) {\n\tsc.mu.Lock()\n\tif details != nil {\n\t\tsc.mu.execDetails.ProcessTime += details.ProcessTime\n\t\tsc.mu.execDetails.WaitTime += details.WaitTime\n\t\tsc.mu.execDetails.BackoffTime += details.BackoffTime\n\t\tsc.mu.execDetails.RequestCount++\n\t\tsc.mu.execDetails.TotalKeys += details.TotalKeys\n\t\tsc.mu.execDetails.ProcessedKeys += details.ProcessedKeys\n\t\tsc.mu.allExecDetails = append(sc.mu.allExecDetails, details)\n\t}\n\tsc.mu.execDetails.CommitDetail = commitDetails\n\tsc.mu.Unlock()\n}", "category": "Python"}, {"instruction": "// ConfigInspectWithRaw returns the config information with raw data", "input": "go language", "output": "func (cli *Client) ConfigInspectWithRaw(ctx context.Context, id string) (swarm.Config, []byte, error) {\n\tif id == \"\" {\n\t\treturn swarm.Config{}, nil, objectNotFoundError{object: \"config\", id: id}\n\t}\n\tif err := cli.NewVersionError(\"1.30\", \"config inspect\"); err != nil {\n\t\treturn swarm.Config{}, nil, err\n\t}\n\tresp, err := cli.get(ctx, \"/configs/\"+id, nil, nil)\n\tdefer ensureReaderClosed(resp)\n\tif err != nil {\n\t\treturn swarm.Config{}, nil, wrapResponseError(err, resp, \"config\", id)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.body)\n\tif err != nil {\n\t\treturn swarm.Config{}, nil, err\n\t}\n\n\tvar config swarm.Config\n\trdr := bytes.NewReader(body)\n\terr = json.NewDecoder(rdr).Decode(&config)\n\n\treturn config, body, err\n}", "category": "Python"}, {"instruction": "// Commit implements the function in the interface `Store`", "input": "go language", "output": "func (s *store) Commit() error {\n\tif !s.batchPending {\n\t\treturn &ErrIllegalCall{\"No pending batch to commit\"}\n\t}\n\tcommittingBlockNum := s.nextBlockNum()\n\tlogger.Debugf(\"Committing private data for block [%d]\", committingBlockNum)\n\tbatch := leveldbhelper.NewUpdateBatch()\n\tbatch.Delete(pendingCommitKey)\n\tbatch.Put(lastCommittedBlkkey, encodeLastCommittedBlockVal(committingBlockNum))\n\tif err := s.db.WriteBatch(batch, true); err != nil {\n\t\treturn err\n\t}\n\ts.batchPending = false\n\ts.isEmpty = false\n\ts.lastCommittedBlock = committingBlockNum\n\tlogger.Debugf(\"Committed private data for block [%d]\", committingBlockNum)\n\ts.performPurgeIfScheduled(committingBlockNum)\n\treturn nil\n}", "category": "Python"}, {"instruction": "// validatePSPSupplementalGroup validates the SupplementalGroupsStrategyOptions fields of the PodSecurityPolicy.", "input": "go language", "output": "func validatePSPSupplementalGroup(fldPath *field.Path, groupOptions *policy.SupplementalGroupsStrategyOptions) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\n\tsupportedRules := sets.NewString(\n\t\tstring(policy.SupplementalGroupsStrategyRunAsAny),\n\t\tstring(policy.SupplementalGroupsStrategyMayRunAs),\n\t\tstring(policy.SupplementalGroupsStrategyMustRunAs),\n\t)\n\tif !supportedRules.Has(string(groupOptions.Rule)) {\n\t\tallErrs = append(allErrs, field.NotSupported(fldPath.Child(\"rule\"), groupOptions.Rule, supportedRules.List()))\n\t}\n\n\tfor idx, rng := range groupOptions.Ranges {\n\t\tallErrs = append(allErrs, validateGroupIDRange(fldPath.Child(\"ranges\").Index(idx), rng)...)\n\t}\n\treturn allErrs\n}", "category": "Python"}, {"instruction": "// getAttach handles requests to attach to a container.", "input": "go language", "output": "func (s *Server) getAttach(request *restful.Request, response *restful.Response) {\n\tparams := getExecRequestParams(request)\n\tstreamOpts, err := remotecommandserver.NewOptions(request.Request)\n\tif err != nil {\n\t\tutilruntime.HandleError(err)\n\t\tresponse.WriteError(http.StatusBadRequest, err)\n\t\treturn\n\t}\n\tpod, ok := s.host.GetPodByName(params.podNamespace, params.podName)\n\tif !ok {\n\t\tresponse.WriteError(http.StatusNotFound, fmt.Errorf(\"pod does not exist\"))\n\t\treturn\n\t}\n\n\tpodFullName := kubecontainer.GetPodFullName(pod)\n\turl, err := s.host.GetAttach(podFullName, params.podUID, params.containerName, *streamOpts)\n\tif err != nil {\n\t\tstreaming.WriteError(err, response.ResponseWriter)\n\t\treturn\n\t}\n\n\tif s.redirectContainerStreaming {\n\t\thttp.Redirect(response.ResponseWriter, request.Request, url.String(), http.StatusFound)\n\t\treturn\n\t}\n\tproxyStream(response.ResponseWriter, request.Request, url)\n}", "category": "Python"}, {"instruction": "// GetMountPoints gives a platform specific transformation to types.MountPoint. Callers must hold a Container lock.", "input": "go language", "output": "func (container *Container) GetMountPoints() []types.MountPoint {\n\tmountPoints := make([]types.MountPoint, 0, len(container.MountPoints))\n\tfor _, m := range container.MountPoints {\n\t\tmountPoints = append(mountPoints, types.MountPoint{\n\t\t\tType:        m.Type,\n\t\t\tName:        m.Name,\n\t\t\tSource:      m.Path(),\n\t\t\tDestination: m.Destination,\n\t\t\tDriver:      m.Driver,\n\t\t\tMode:        m.Mode,\n\t\t\tRW:          m.RW,\n\t\t\tPropagation: m.Propagation,\n\t\t})\n\t}\n\treturn mountPoints\n}", "category": "Python"}, {"instruction": "// Read is used to perform a read-only transaction that doesn't modify the state\n// store. This is much more scalable since it doesn't go through Raft and\n// supports staleness, so this should be preferred if you're just performing\n// reads.", "input": "go language", "output": "func (t *Txn) Read(args *structs.TxnReadRequest, reply *structs.TxnReadResponse) error {\n\tif done, err := t.srv.forward(\"Txn.Read\", args, args, reply); done {\n\t\treturn err\n\t}\n\tdefer metrics.MeasureSince([]string{\"txn\", \"read\"}, time.Now())\n\n\t// We have to do this ourselves since we are not doing a blocking RPC.\n\tt.srv.setQueryMeta(&reply.QueryMeta)\n\tif args.RequireConsistent {\n\t\tif err := t.srv.consistentRead(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Run the pre-checks before we perform the read.\n\tauthorizer, err := t.srv.ResolveToken(args.Token)\n\tif err != nil {\n\t\treturn err\n\t}\n\treply.Errors = t.preCheck(authorizer, args.Ops)\n\tif len(reply.Errors) > 0 {\n\t\treturn nil\n\t}\n\n\t// Run the read transaction.\n\tstate := t.srv.fsm.State()\n\treply.Results, reply.Errors = state.TxnRO(args.Ops)\n\tif authorizer != nil {\n\t\treply.Results = FilterTxnResults(authorizer, reply.Results)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// controlledHistories returns all ControllerRevisions in namespace that selected by selector and owned by accessor\n// TODO: Rename this to controllerHistory when other controllers have been upgraded", "input": "go language", "output": "func controlledHistoryV1(\n\tapps clientappsv1.AppsV1Interface,\n\tnamespace string,\n\tselector labels.Selector,\n\taccessor metav1.Object) ([]*appsv1.ControllerRevision, error) {\n\tvar result []*appsv1.ControllerRevision\n\thistoryList, err := apps.ControllerRevisions(namespace).List(metav1.ListOptions{LabelSelector: selector.String()})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor i := range historyList.Items {\n\t\thistory := historyList.Items[i]\n\t\t// Only add history that belongs to the API object\n\t\tif metav1.IsControlledBy(&history, accessor) {\n\t\t\tresult = append(result, &history)\n\t\t}\n\t}\n\treturn result, nil\n}", "category": "Python"}, {"instruction": "// RunConfigView gets the configuration persisted in the cluster", "input": "go language", "output": "func RunConfigView(out io.Writer, client clientset.Interface) error {\n\n\tklog.V(1).Infoln(\"[config] getting the cluster configuration\")\n\tcfgConfigMap, err := client.CoreV1().ConfigMaps(metav1.NamespaceSystem).Get(constants.KubeadmConfigConfigMap, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn err\n\t}\n\t// No need to append \\n as that already exists in the ConfigMap\n\tfmt.Fprintf(out, \"%s\", cfgConfigMap.Data[constants.ClusterConfigurationConfigMapKey])\n\treturn nil\n}", "category": "Python"}, {"instruction": "// makeProtocols creates protocol descriptors for the given LES versions.", "input": "go language", "output": "func (c *lesCommons) makeProtocols(versions []uint) []p2p.Protocol {\n\tprotos := make([]p2p.Protocol, len(versions))\n\tfor i, version := range versions {\n\t\tversion := version\n\t\tprotos[i] = p2p.Protocol{\n\t\t\tName:     \"les\",\n\t\t\tVersion:  version,\n\t\t\tLength:   ProtocolLengths[version],\n\t\t\tNodeInfo: c.nodeInfo,\n\t\t\tRun: func(p *p2p.Peer, rw p2p.MsgReadWriter) error {\n\t\t\t\treturn c.protocolManager.runPeer(version, p, rw)\n\t\t\t},\n\t\t\tPeerInfo: func(id enode.ID) interface{} {\n\t\t\t\tif p := c.protocolManager.peers.Peer(fmt.Sprintf(\"%x\", id.Bytes())); p != nil {\n\t\t\t\t\treturn p.Info()\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t}\n\t}\n\treturn protos\n}", "category": "Python"}, {"instruction": "// popOldEvents finds events that should be scheduled for scanning recursively in dirs,\n// removes those events and empty eventDirs and returns a map with all the removed\n// events referenced by their filesystem path", "input": "go language", "output": "func (a *aggregator) popOldEventsTo(to map[string]*aggregatedEvent, dir *eventDir, dirPath string, currTime time.Time, delayRem bool) {\n\tfor childName, childDir := range dir.dirs {\n\t\ta.popOldEventsTo(to, childDir, filepath.Join(dirPath, childName), currTime, delayRem)\n\t\tif childDir.childCount() == 0 {\n\t\t\tdelete(dir.dirs, childName)\n\t\t}\n\t}\n\tfor name, event := range dir.events {\n\t\tif a.isOld(event, currTime, delayRem) {\n\t\t\tto[filepath.Join(dirPath, name)] = event\n\t\t\tdelete(dir.events, name)\n\t\t\ta.counts[event.evType]--\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// InstanceKeyLess returns true if the first given instance key i should sort\n// before the second key j, and false otherwise.", "input": "go language", "output": "func InstanceKeyLess(i, j InstanceKey) bool {\n\tiTy := instanceKeyType(i)\n\tjTy := instanceKeyType(j)\n\n\tswitch {\n\tcase i == j:\n\t\treturn false\n\tcase i == NoKey:\n\t\treturn true\n\tcase j == NoKey:\n\t\treturn false\n\tcase iTy != jTy:\n\t\t// The ordering here is arbitrary except that we want NoKeyType\n\t\t// to sort before the others, so we'll just use the enum values\n\t\t// of InstanceKeyType here (where NoKey is zero, sorting before\n\t\t// any other).\n\t\treturn uint32(iTy) < uint32(jTy)\n\tcase iTy == IntKeyType:\n\t\treturn int(i.(IntKey)) < int(j.(IntKey))\n\tcase iTy == StringKeyType:\n\t\treturn string(i.(StringKey)) < string(j.(StringKey))\n\tdefault:\n\t\t// Shouldn't be possible to get down here in practice, since the\n\t\t// above is exhaustive.\n\t\treturn false\n\t}\n}", "category": "Python"}, {"instruction": "// splitSlicesAndValues moves all slice values defined in c to 'slices'\n// and all other values to 'values'.", "input": "go language", "output": "func (b *Builder) splitSlicesAndValues(c Config) (slices, values Config) {\n\tv, t := reflect.ValueOf(c), reflect.TypeOf(c)\n\trs, rv := reflect.New(t), reflect.New(t)\n\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tf := t.Field(i)\n\t\tif f.Type.Kind() == reflect.Slice {\n\t\t\trs.Elem().Field(i).Set(v.Field(i))\n\t\t} else {\n\t\t\trv.Elem().Field(i).Set(v.Field(i))\n\t\t}\n\t}\n\treturn rs.Elem().Interface().(Config), rv.Elem().Interface().(Config)\n}", "category": "Python"}, {"instruction": "// NewOwnerManager creates a new Manager.", "input": "go language", "output": "func NewOwnerManager(etcdCli *clientv3.Client, prompt, id, key string, cancel context.CancelFunc) Manager {\n\tlogPrefix := fmt.Sprintf(\"[%s] %s ownerManager %s\", prompt, key, id)\n\treturn &ownerManager{\n\t\tetcdCli:   etcdCli,\n\t\tid:        id,\n\t\tkey:       key,\n\t\tprompt:    prompt,\n\t\tcancel:    cancel,\n\t\tlogPrefix: logPrefix,\n\t\tlogCtx:    logutil.WithKeyValue(context.Background(), \"owner info\", logPrefix),\n\t}\n}", "category": "Python"}, {"instruction": "// NewCommandStartWardleServer provides a CLI handler for 'start master' command\n// with a default WardleServerOptions.", "input": "go language", "output": "func NewCommandStartWardleServer(defaults *WardleServerOptions, stopCh <-chan struct{}) *cobra.Command {\n\to := *defaults\n\tcmd := &cobra.Command{\n\t\tShort: \"Launch a wardle API server\",\n\t\tLong:  \"Launch a wardle API server\",\n\t\tRunE: func(c *cobra.Command, args []string) error {\n\t\t\tif err := o.Complete(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := o.Validate(args); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := o.RunWardleServer(stopCh); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tflags := cmd.Flags()\n\to.RecommendedOptions.AddFlags(flags)\n\tutilfeature.DefaultMutableFeatureGate.AddFlag(flags)\n\n\treturn cmd\n}", "category": "Python"}, {"instruction": "// resolveWindowSpec resolve window specifications for sql like `select ... from t window w1 as (w2), w2 as (partition by a)`.\n// We need to resolve the referenced window to get the definition of current window spec.", "input": "go language", "output": "func resolveWindowSpec(spec *ast.WindowSpec, specs map[string]ast.WindowSpec, inStack map[string]bool) error {\n\tif inStack[spec.Name.L] {\n\t\treturn errors.Trace(ErrWindowCircularityInWindowGraph)\n\t}\n\tif spec.Ref.L == \"\" {\n\t\treturn nil\n\t}\n\tref, ok := specs[spec.Ref.L]\n\tif !ok {\n\t\treturn ErrWindowNoSuchWindow.GenWithStackByArgs(spec.Ref.O)\n\t}\n\tinStack[spec.Name.L] = true\n\terr := resolveWindowSpec(&ref, specs, inStack)\n\tif err != nil {\n\t\treturn err\n\t}\n\tinStack[spec.Name.L] = false\n\treturn mergeWindowSpec(spec, &ref)\n}", "category": "Python"}, {"instruction": "// getSessionVarsWaitTimeout get session variable wait_timeout", "input": "go language", "output": "func (cc *clientConn) getSessionVarsWaitTimeout(ctx context.Context) uint64 {\n\tvalStr, exists := cc.ctx.GetSessionVars().GetSystemVar(variable.WaitTimeout)\n\tif !exists {\n\t\treturn variable.DefWaitTimeout\n\t}\n\twaitTimeout, err := strconv.ParseUint(valStr, 10, 64)\n\tif err != nil {\n\t\tlogutil.Logger(ctx).Warn(\"get sysval wait_timeout error, use default value\", zap.Error(err))\n\t\t// if get waitTimeout error, use default value\n\t\treturn variable.DefWaitTimeout\n\t}\n\treturn waitTimeout\n}", "category": "Python"}, {"instruction": "// doEncHandshake runs the protocol handshake using authenticated\n// messages. the protocol handshake is the first authenticated message\n// and also verifies whether the encryption handshake 'worked' and the\n// remote side actually provided the right public key.", "input": "go language", "output": "func (t *rlpx) doEncHandshake(prv *ecdsa.PrivateKey, dial *ecdsa.PublicKey) (*ecdsa.PublicKey, error) {\n\tvar (\n\t\tsec secrets\n\t\terr error\n\t)\n\tif dial == nil {\n\t\tsec, err = receiverEncHandshake(t.fd, prv)\n\t} else {\n\t\tsec, err = initiatorEncHandshake(t.fd, prv, dial)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tt.wmu.Lock()\n\tt.rw = newRLPXFrameRW(t.fd, sec)\n\tt.wmu.Unlock()\n\treturn sec.Remote.ExportECDSA(), nil\n}", "category": "Python"}, {"instruction": "// IsPodCgroup returns true if the literal cgroupfs name corresponds to a pod", "input": "go language", "output": "func (m *podContainerManagerImpl) IsPodCgroup(cgroupfs string) (bool, types.UID) {\n\t// convert the literal cgroupfs form to the driver specific value\n\tcgroupName := m.cgroupManager.CgroupName(cgroupfs)\n\tqosContainersList := [3]CgroupName{m.qosContainersInfo.BestEffort, m.qosContainersInfo.Burstable, m.qosContainersInfo.Guaranteed}\n\tbasePath := \"\"\n\tfor _, qosContainerName := range qosContainersList {\n\t\t// a pod cgroup is a direct child of a qos node, so check if its a match\n\t\tif len(cgroupName) == len(qosContainerName)+1 {\n\t\t\tbasePath = cgroupName[len(qosContainerName)]\n\t\t}\n\t}\n\tif basePath == \"\" {\n\t\treturn false, types.UID(\"\")\n\t}\n\tif !strings.HasPrefix(basePath, podCgroupNamePrefix) {\n\t\treturn false, types.UID(\"\")\n\t}\n\tparts := strings.Split(basePath, podCgroupNamePrefix)\n\tif len(parts) != 2 {\n\t\treturn false, types.UID(\"\")\n\t}\n\treturn true, types.UID(parts[1])\n}", "category": "Python"}, {"instruction": "// waitForJob is a helper that waits for a job to complete.\n//\n// This operates on an event returned from a watcher.", "input": "go language", "output": "func (c *Client) waitForJob(e watch.Event, name string) (bool, error) {\n\tjob := &batch.Job{}\n\terr := legacyscheme.Scheme.Convert(e.Object, job, nil)\n\tif err != nil {\n\t\treturn true, err\n\t}\n\n\tfor _, c := range job.Status.Conditions {\n\t\tif c.Type == batch.JobComplete && c.Status == v1.ConditionTrue {\n\t\t\treturn true, nil\n\t\t} else if c.Type == batch.JobFailed && c.Status == v1.ConditionTrue {\n\t\t\treturn true, fmt.Errorf(\"Job failed: %s\", c.Reason)\n\t\t}\n\t}\n\n\tc.Log(\"%s: Jobs active: %d, jobs failed: %d, jobs succeeded: %d\", name, job.Status.Active, job.Status.Failed, job.Status.Succeeded)\n\treturn false, nil\n}", "category": "Python"}, {"instruction": "// login calls SessionManager.LoginByToken if certificate and private key are configured,\n// otherwise calls SessionManager.Login with user and password.", "input": "go language", "output": "func (connection *VSphereConnection) login(ctx context.Context, client *vim25.Client) error {\n\tm := session.NewManager(client)\n\tconnection.credentialsLock.Lock()\n\tdefer connection.credentialsLock.Unlock()\n\n\tsigner, err := connection.Signer(ctx, client)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif signer == nil {\n\t\tklog.V(3).Infof(\"SessionManager.Login with username %q\", connection.Username)\n\t\treturn m.Login(ctx, neturl.UserPassword(connection.Username, connection.Password))\n\t}\n\n\tklog.V(3).Infof(\"SessionManager.LoginByToken with certificate %q\", connection.Username)\n\n\theader := soap.Header{Security: signer}\n\n\treturn m.LoginByToken(client.WithHeader(ctx, header))\n}", "category": "Python"}, {"instruction": "// SetRestarting sets the container state to \"restarting\" without locking.\n// It also sets the container PID to 0.", "input": "go language", "output": "func (s *State) SetRestarting(exitStatus *ExitStatus) {\n\t// we should consider the container running when it is restarting because of\n\t// all the checks in docker around rm/stop/etc\n\ts.Running = true\n\ts.Restarting = true\n\ts.Paused = false\n\ts.Pid = 0\n\ts.FinishedAt = time.Now().UTC()\n\ts.ExitCodeValue = exitStatus.ExitCode\n\ts.OOMKilled = exitStatus.OOMKilled\n\tclose(s.waitStop) // fire waiters for stop\n\ts.waitStop = make(chan struct{})\n}", "category": "Python"}, {"instruction": "// Recv blocks until a response is received from the stream or the\n// timeout expires.", "input": "go language", "output": "func (stream *ImpatientStream) Recv() (*orderer.DeliverResponse, error) {\n\t// Initialize a timeout to cancel the stream when it expires\n\ttimeout := time.NewTimer(stream.waitTimeout)\n\tdefer timeout.Stop()\n\n\tresponseChan := make(chan errorAndResponse, 1)\n\n\t// receive waitGroup ensures the goroutine below exits before\n\t// this function exits.\n\tvar receive sync.WaitGroup\n\treceive.Add(1)\n\tdefer receive.Wait()\n\n\tgo func() {\n\t\tdefer receive.Done()\n\t\tresp, err := stream.AtomicBroadcast_DeliverClient.Recv()\n\t\tresponseChan <- errorAndResponse{err: err, resp: resp}\n\t}()\n\n\tselect {\n\tcase <-timeout.C:\n\t\tstream.cancelFunc()\n\t\treturn nil, errors.Errorf(\"didn't receive a response within %v\", stream.waitTimeout)\n\tcase respAndErr := <-responseChan:\n\t\treturn respAndErr.resp, respAndErr.err\n\t}\n}", "category": "Python"}, {"instruction": "// build a marshalGraph structure from a *Graph", "input": "go language", "output": "func newMarshalGraph(name string, g *Graph) *marshalGraph {\n\tmg := &marshalGraph{\n\t\tType:  \"Graph\",\n\t\tName:  name,\n\t\tAttrs: make(map[string]string),\n\t}\n\n\tfor _, v := range g.Vertices() {\n\t\tid := marshalVertexID(v)\n\t\tif sg, ok := marshalSubgrapher(v); ok {\n\t\t\tsmg := newMarshalGraph(VertexName(v), sg)\n\t\t\tsmg.ID = id\n\t\t\tmg.Subgraphs = append(mg.Subgraphs, smg)\n\t\t}\n\n\t\tmv := newMarshalVertex(v)\n\t\tmg.Vertices = append(mg.Vertices, mv)\n\t}\n\n\tsort.Sort(vertices(mg.Vertices))\n\n\tfor _, e := range g.Edges() {\n\t\tmg.Edges = append(mg.Edges, newMarshalEdge(e))\n\t}\n\n\tsort.Sort(edges(mg.Edges))\n\n\tfor _, c := range (&AcyclicGraph{*g}).Cycles() {\n\t\tvar cycle []*marshalVertex\n\t\tfor _, v := range c {\n\t\t\tmv := newMarshalVertex(v)\n\t\t\tcycle = append(cycle, mv)\n\t\t}\n\t\tmg.Cycles = append(mg.Cycles, cycle)\n\t}\n\n\treturn mg\n}", "category": "Python"}, {"instruction": "// WaitForCacheSync is a helper function that waits for cache sync for CSIDriverLister", "input": "go language", "output": "func (kvh *kubeletVolumeHost) WaitForCacheSync() error {\n\tif kvh.csiDriversSynced == nil {\n\t\tklog.Error(\"csiDriversSynced not found on KubeletVolumeHost\")\n\t\treturn fmt.Errorf(\"csiDriversSynced not found on KubeletVolumeHost\")\n\t}\n\n\tsynced := []cache.InformerSynced{kvh.csiDriversSynced}\n\tif !cache.WaitForCacheSync(wait.NeverStop, synced...) {\n\t\tklog.Warning(\"failed to wait for cache sync for CSIDriverLister\")\n\t\treturn fmt.Errorf(\"failed to wait for cache sync for CSIDriverLister\")\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// canAdmitPod determines if a pod can be admitted, and gives a reason if it\n// cannot. \"pod\" is new pod, while \"pods\" are all admitted pods\n// The function returns a boolean value indicating whether the pod\n// can be admitted, a brief single-word reason and a message explaining why\n// the pod cannot be admitted.", "input": "go language", "output": "func (kl *Kubelet) canAdmitPod(pods []*v1.Pod, pod *v1.Pod) (bool, string, string) {\n\t// the kubelet will invoke each pod admit handler in sequence\n\t// if any handler rejects, the pod is rejected.\n\t// TODO: move out of disk check into a pod admitter\n\t// TODO: out of resource eviction should have a pod admitter call-out\n\tattrs := &lifecycle.PodAdmitAttributes{Pod: pod, OtherPods: pods}\n\tfor _, podAdmitHandler := range kl.admitHandlers {\n\t\tif result := podAdmitHandler.Admit(attrs); !result.Admit {\n\t\t\treturn false, result.Reason, result.Message\n\t\t}\n\t}\n\n\treturn true, \"\", \"\"\n}", "category": "Python"}, {"instruction": "// SetPBColumnsDefaultValue sets the default values of tipb.ColumnInfos.", "input": "go language", "output": "func SetPBColumnsDefaultValue(ctx sessionctx.Context, pbColumns []*tipb.ColumnInfo, columns []*model.ColumnInfo) error {\n\tfor i, c := range columns {\n\t\tif c.OriginDefaultValue == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tsessVars := ctx.GetSessionVars()\n\t\toriginStrict := sessVars.StrictSQLMode\n\t\tsessVars.StrictSQLMode = false\n\t\td, err := table.GetColOriginDefaultValue(ctx, c)\n\t\tsessVars.StrictSQLMode = originStrict\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpbColumns[i].DefaultVal, err = tablecodec.EncodeValue(ctx.GetSessionVars().StmtCtx, d)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// NewBootstrapTokenString converts the given Bootstrap Token as a string\n// to the BootstrapTokenString object used for serialization/deserialization\n// and internal usage. It also automatically validates that the given token\n// is of the right format", "input": "go language", "output": "func NewBootstrapTokenString(token string) (*BootstrapTokenString, error) {\n\tsubstrs := bootstraputil.BootstrapTokenRegexp.FindStringSubmatch(token)\n\t// TODO: Add a constant for the 3 value here, and explain better why it's needed (other than because how the regexp parsin works)\n\tif len(substrs) != 3 {\n\t\treturn nil, errors.Errorf(\"the bootstrap token %q was not of the form %q\", token, bootstrapapi.BootstrapTokenPattern)\n\t}\n\n\treturn &BootstrapTokenString{ID: substrs[1], Secret: substrs[2]}, nil\n}", "category": "Python"}, {"instruction": "// verifyIntegrity is a debug method to iterate over the entire trie stored in\n// memory and check whether every node is reachable from the meta root. The goal\n// is to find any errors that might cause memory leaks and or trie nodes to go\n// missing.\n//\n// This method is extremely CPU and memory intensive, only use when must.", "input": "go language", "output": "func (db *Database) verifyIntegrity() {\n\t// Iterate over all the cached nodes and accumulate them into a set\n\treachable := map[common.Hash]struct{}{{}: {}}\n\n\tfor child := range db.dirties[common.Hash{}].children {\n\t\tdb.accumulate(child, reachable)\n\t}\n\t// Find any unreachable but cached nodes\n\tvar unreachable []string\n\tfor hash, node := range db.dirties {\n\t\tif _, ok := reachable[hash]; !ok {\n\t\t\tunreachable = append(unreachable, fmt.Sprintf(\"%x: {Node: %v, Parents: %d, Prev: %x, Next: %x}\",\n\t\t\t\thash, node.node, node.parents, node.flushPrev, node.flushNext))\n\t\t}\n\t}\n\tif len(unreachable) != 0 {\n\t\tpanic(fmt.Sprintf(\"trie cache memory leak: %v\", unreachable))\n\t}\n}", "category": "Python"}, {"instruction": "// updateAllServiceIndexesOfNode updates the Raft index of all the services associated with this node", "input": "go language", "output": "func (s *Store) updateAllServiceIndexesOfNode(tx *memdb.Txn, idx uint64, nodeID string) error {\n\tservices, err := tx.Get(\"services\", \"node\", nodeID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed updating services for node %s: %s\", nodeID, err)\n\t}\n\tfor service := services.Next(); service != nil; service = services.Next() {\n\t\tsvc := service.(*structs.ServiceNode).ToNodeService()\n\t\tif err := tx.Insert(\"index\", &IndexEntry{serviceIndexName(svc.Service), idx}); err != nil {\n\t\t\treturn fmt.Errorf(\"failed updating index: %s\", err)\n\t\t}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// NodeKeys returns a paginated list of keys on a node with provided address.", "input": "go language", "output": "func (s *GlobalStore) NodeKeys(addr common.Address, startKey []byte, limit int) (keys mock.Keys, err error) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\tvar i int\n\tif startKey != nil {\n\t\ti, _ = s.nodeKeyIndex(addr, startKey)\n\t}\n\ttotal := len(s.nodeKeys[addr])\n\tmax := maxIndex(i, limit, total)\n\tkeys.Keys = make([][]byte, 0, max-i)\n\tfor ; i < max; i++ {\n\t\tkeys.Keys = append(keys.Keys, append([]byte(nil), s.nodeKeys[addr][i]...))\n\t}\n\tif total > max {\n\t\tkeys.Next = s.nodeKeys[addr][max]\n\t}\n\treturn keys, nil\n}", "category": "Python"}, {"instruction": "// EvalString returns string representation of Column.", "input": "go language", "output": "func (col *Column) EvalString(ctx sessionctx.Context, row chunk.Row) (string, bool, error) {\n\tif row.IsNull(col.Index) {\n\t\treturn \"\", true, nil\n\t}\n\n\t// Specially handle the ENUM/SET/BIT input value.\n\tif col.GetType().Hybrid() {\n\t\tval := row.GetDatum(col.Index, col.RetType)\n\t\tres, err := val.ToString()\n\t\treturn res, err != nil, err\n\t}\n\n\tval := row.GetString(col.Index)\n\tif ctx.GetSessionVars().StmtCtx.PadCharToFullLength && col.GetType().Tp == mysql.TypeString {\n\t\tvalLen := len([]rune(val))\n\t\tif valLen < col.RetType.Flen {\n\t\t\tval = val + strings.Repeat(\" \", col.RetType.Flen-valLen)\n\t\t}\n\t}\n\treturn val, false, nil\n}", "category": "Python"}, {"instruction": "// Create takes the representation of a customResourceDefinition and creates it.  Returns the server's representation of the customResourceDefinition, and an error, if there is any.", "input": "go language", "output": "func (c *FakeCustomResourceDefinitions) Create(customResourceDefinition *v1beta1.CustomResourceDefinition) (result *v1beta1.CustomResourceDefinition, err error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewRootCreateAction(customresourcedefinitionsResource, customResourceDefinition), &v1beta1.CustomResourceDefinition{})\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\treturn obj.(*v1beta1.CustomResourceDefinition), err\n}", "category": "Python"}, {"instruction": "// init registers the windows graph drivers to the register.", "input": "go language", "output": "func init() {\n\tgraphdriver.Register(\"windowsfilter\", InitFilter)\n\t// DOCKER_WINDOWSFILTER_NOREEXEC allows for inline processing which makes\n\t// debugging issues in the re-exec codepath significantly easier.\n\tif os.Getenv(\"DOCKER_WINDOWSFILTER_NOREEXEC\") != \"\" {\n\t\tlogrus.Warnf(\"WindowsGraphDriver is set to not re-exec. This is intended for debugging purposes only.\")\n\t\tnoreexec = true\n\t} else {\n\t\treexec.Register(\"docker-windows-write-layer\", writeLayerReexec)\n\t}\n}", "category": "Python"}, {"instruction": "// TranslateInTreePVToCSI takes a PV with Cinder set from in-tree\n// and converts the Cinder source to a CSIPersistentVolumeSource", "input": "go language", "output": "func (t *osCinderCSITranslator) TranslateInTreePVToCSI(pv *v1.PersistentVolume) (*v1.PersistentVolume, error) {\n\tif pv == nil || pv.Spec.Cinder == nil {\n\t\treturn nil, fmt.Errorf(\"pv is nil or Cinder not defined on pv\")\n\t}\n\n\tcinderSource := pv.Spec.Cinder\n\n\tcsiSource := &v1.CSIPersistentVolumeSource{\n\t\tDriver:           CinderDriverName,\n\t\tVolumeHandle:     cinderSource.VolumeID,\n\t\tReadOnly:         cinderSource.ReadOnly,\n\t\tFSType:           cinderSource.FSType,\n\t\tVolumeAttributes: map[string]string{},\n\t}\n\n\tpv.Spec.Cinder = nil\n\tpv.Spec.CSI = csiSource\n\treturn pv, nil\n}", "category": "Python"}, {"instruction": "//\n// Setting, updating & deleting state object methods.\n//\n// updateStateObject writes the given object to the trie.", "input": "go language", "output": "func (s *StateDB) updateStateObject(stateObject *stateObject) {\n\t// Track the amount of time wasted on updating the account from the trie\n\tif metrics.EnabledExpensive {\n\t\tdefer func(start time.Time) { s.AccountUpdates += time.Since(start) }(time.Now())\n\t}\n\t// Encode the account and update the account trie\n\taddr := stateObject.Address()\n\n\tdata, err := rlp.EncodeToBytes(stateObject)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"can't encode object at %x: %v\", addr[:], err))\n\t}\n\ts.setError(s.trie.TryUpdate(addr[:], data))\n}", "category": "Python"}, {"instruction": "// notify sends notifications for pod with the given id, if the requirements\n// are met. Note that the caller should acquire the lock.", "input": "go language", "output": "func (c *cache) notify(id types.UID, timestamp time.Time) {\n\tlist, ok := c.subscribers[id]\n\tif !ok {\n\t\t// No one to notify.\n\t\treturn\n\t}\n\tnewList := []*subRecord{}\n\tfor i, r := range list {\n\t\tif timestamp.Before(r.time) {\n\t\t\t// Doesn't meet the time requirement; keep the record.\n\t\t\tnewList = append(newList, list[i])\n\t\t\tcontinue\n\t\t}\n\t\tr.ch <- c.get(id)\n\t\tclose(r.ch)\n\t}\n\tif len(newList) == 0 {\n\t\tdelete(c.subscribers, id)\n\t} else {\n\t\tc.subscribers[id] = newList\n\t}\n}", "category": "Python"}, {"instruction": "// MakePortMappings creates internal port mapping from api port mapping.", "input": "go language", "output": "func MakePortMappings(container *v1.Container) (ports []PortMapping) {\n\tnames := make(map[string]struct{})\n\tfor _, p := range container.Ports {\n\t\tpm := PortMapping{\n\t\t\tHostPort:      int(p.HostPort),\n\t\t\tContainerPort: int(p.ContainerPort),\n\t\t\tProtocol:      p.Protocol,\n\t\t\tHostIP:        p.HostIP,\n\t\t}\n\n\t\t// We need to create some default port name if it's not specified, since\n\t\t// this is necessary for rkt.\n\t\t// http://issue.k8s.io/7710\n\t\tif p.Name == \"\" {\n\t\t\tpm.Name = fmt.Sprintf(\"%s-%s:%d\", container.Name, p.Protocol, p.ContainerPort)\n\t\t} else {\n\t\t\tpm.Name = fmt.Sprintf(\"%s-%s\", container.Name, p.Name)\n\t\t}\n\n\t\t// Protect against exposing the same protocol-port more than once in a container.\n\t\tif _, ok := names[pm.Name]; ok {\n\t\t\tklog.Warningf(\"Port name conflicted, %q is defined more than once\", pm.Name)\n\t\t\tcontinue\n\t\t}\n\t\tports = append(ports, pm)\n\t\tnames[pm.Name] = struct{}{}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// Visit will call the visitor function on the path if it's a file, or for each\n// file in the path if it's a directory. Directories will not be recursed into,\n// and files in the directory will be visited in alphabetical order.", "input": "go language", "output": "func Visit(path string, visitor VisitFn) error {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error reading %q: %v\", path, err)\n\t}\n\tdefer f.Close()\n\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error checking %q: %v\", path, err)\n\t}\n\n\tif !fi.IsDir() {\n\t\tif err := visitor(path); err != nil {\n\t\t\treturn fmt.Errorf(\"error in %q: %v\", path, err)\n\t\t}\n\t\treturn nil\n\t}\n\n\tcontents, err := f.Readdir(-1)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error listing %q: %v\", path, err)\n\t}\n\n\tsort.Sort(dirEnts(contents))\n\tfor _, fi := range contents {\n\t\tif fi.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tfullPath := filepath.Join(path, fi.Name())\n\t\tif err := visitor(fullPath); err != nil {\n\t\t\treturn fmt.Errorf(\"error in %q: %v\", fullPath, err)\n\t\t}\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// gatherAllHostports returns all hostports that should be presented on node,\n// given the list of pods running on that node and ignoring host network\n// pods (which don't need hostport <-> container port mapping).", "input": "go language", "output": "func gatherAllHostports(activePodPortMappings []*PodPortMapping) (map[*PortMapping]targetPod, error) {\n\tpodHostportMap := make(map[*PortMapping]targetPod)\n\tfor _, pm := range activePodPortMappings {\n\t\tif pm.IP.To4() == nil {\n\t\t\treturn nil, fmt.Errorf(\"Invalid or missing pod %s IP\", getPodFullName(pm))\n\t\t}\n\t\t// should not handle hostports for hostnetwork pods\n\t\tif pm.HostNetwork {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, port := range pm.PortMappings {\n\t\t\tif port.HostPort != 0 {\n\t\t\t\tpodHostportMap[port] = targetPod{podFullName: getPodFullName(pm), podIP: pm.IP.String()}\n\t\t\t}\n\t\t}\n\t}\n\treturn podHostportMap, nil\n}", "category": "Python"}, {"instruction": "// execute fetches Chunks from src and update each aggregate function for each row in Chunk.", "input": "go language", "output": "func (e *HashAggExec) execute(ctx context.Context) (err error) {\n\tinputIter := chunk.NewIterator4Chunk(e.childResult)\n\tfor {\n\t\terr := e.children[0].Next(ctx, chunk.NewRecordBatch(e.childResult))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfailpoint.Inject(\"unparallelHashAggError\", func(val failpoint.Value) {\n\t\t\tif val.(bool) {\n\t\t\t\tfailpoint.Return(errors.New(\"HashAggExec.unparallelExec error\"))\n\t\t\t}\n\t\t})\n\n\t\t// no more data.\n\t\tif e.childResult.NumRows() == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tfor row := inputIter.Begin(); row != inputIter.End(); row = inputIter.Next() {\n\t\t\tgroupKey, err := e.getGroupKey(row)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !e.groupSet.Exist(groupKey) {\n\t\t\t\te.groupSet.Insert(groupKey)\n\t\t\t\te.groupKeys = append(e.groupKeys, groupKey)\n\t\t\t}\n\t\t\tpartialResults := e.getPartialResults(groupKey)\n\t\t\tfor i, af := range e.PartialAggFuncs {\n\t\t\t\terr = af.UpdatePartialResult(e.ctx, []chunk.Row{row}, partialResults[i])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// Validate checks ServerRunOptions and return a slice of found errs.", "input": "go language", "output": "func (s *ServerRunOptions) Validate() []error {\n\tvar errs []error\n\tif s.MasterCount <= 0 {\n\t\terrs = append(errs, fmt.Errorf(\"--apiserver-count should be a positive number, but value '%d' provided\", s.MasterCount))\n\t}\n\terrs = append(errs, s.Etcd.Validate()...)\n\terrs = append(errs, validateClusterIPFlags(s)...)\n\terrs = append(errs, validateServiceNodePort(s)...)\n\terrs = append(errs, s.SecureServing.Validate()...)\n\terrs = append(errs, s.Authentication.Validate()...)\n\terrs = append(errs, s.Authorization.Validate()...)\n\terrs = append(errs, s.Audit.Validate()...)\n\terrs = append(errs, s.Admission.Validate()...)\n\terrs = append(errs, s.InsecureServing.Validate()...)\n\terrs = append(errs, s.APIEnablement.Validate(legacyscheme.Scheme, apiextensionsapiserver.Scheme, aggregatorscheme.Scheme)...)\n\terrs = append(errs, validateTokenRequest(s)...)\n\n\treturn errs\n}", "category": "Python"}, {"instruction": "// ValidateUpdate is the default update validation for an end user.", "input": "go language", "output": "func (jobStrategy) ValidateUpdate(ctx context.Context, obj, old runtime.Object) field.ErrorList {\n\tjob := obj.(*batch.Job)\n\toldJob := old.(*batch.Job)\n\tvalidationErrorList := validation.ValidateJob(job)\n\tupdateErrorList := validation.ValidateJobUpdate(job, oldJob)\n\tupdateErrorList = append(updateErrorList, corevalidation.ValidateConditionalPodTemplate(&job.Spec.Template, &oldJob.Spec.Template, field.NewPath(\"spec.template\"))...)\n\treturn append(validationErrorList, updateErrorList...)\n}", "category": "Python"}, {"instruction": "// checkFolderDeviceStatusLocked first checks the folder and then whether the\n// given device is connected and shares this folder.\n// Need to hold (read) lock on both m.fmut and m.pmut when calling this.", "input": "go language", "output": "func (m *model) checkDeviceFolderConnectedLocked(device protocol.DeviceID, folder string) error {\n\tif err := m.checkFolderRunningLocked(folder); err != nil {\n\t\treturn err\n\t}\n\n\tif cfg, ok := m.cfg.Device(device); !ok {\n\t\treturn errDeviceUnknown\n\t} else if cfg.Paused {\n\t\treturn errDevicePaused\n\t}\n\n\tif _, ok := m.conn[device]; !ok {\n\t\treturn errors.New(\"device is not connected\")\n\t}\n\n\tif cfg, ok := m.cfg.Folder(folder); !ok || !cfg.SharedWith(device) {\n\t\treturn errors.New(\"folder is not shared with device\")\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// ParseBitStr parses bit string.\n// The string format can be b'val', B'val' or 0bval, val must be 0 or 1.\n// See https://dev.mysql.com/doc/refman/5.7/en/bit-value-literals.html", "input": "go language", "output": "func ParseBitStr(s string) (BinaryLiteral, error) {\n\tif len(s) == 0 {\n\t\treturn nil, errors.Errorf(\"invalid empty string for parsing bit type\")\n\t}\n\n\tif s[0] == 'b' || s[0] == 'B' {\n\t\t// format is b'val' or B'val'\n\t\ts = strings.Trim(s[1:], \"'\")\n\t} else if strings.HasPrefix(s, \"0b\") {\n\t\ts = s[2:]\n\t} else {\n\t\t// here means format is not b'val', B'val' or 0bval.\n\t\treturn nil, errors.Errorf(\"invalid bit type format %s\", s)\n\t}\n\n\tif len(s) == 0 {\n\t\treturn ZeroBinaryLiteral, nil\n\t}\n\n\talignedLength := (len(s) + 7) &^ 7\n\ts = (\"00000000\" + s)[len(s)+8-alignedLength:] // Pad with zero (slice from `-alignedLength`)\n\tbyteLength := len(s) >> 3\n\tbuf := make([]byte, byteLength)\n\n\tfor i := 0; i < byteLength; i++ {\n\t\tstrPosition := i << 3\n\t\tval, err := strconv.ParseUint(s[strPosition:strPosition+8], 2, 8)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Trace(err)\n\t\t}\n\t\tbuf[i] = byte(val)\n\t}\n\n\treturn buf, nil\n}", "category": "Python"}, {"instruction": "// Subscribe creates a subscription for events of the given types. The\n// subscription's channel is closed when it is unsubscribed\n// or the mux is closed.", "input": "go language", "output": "func (mux *TypeMux) Subscribe(types ...interface{}) *TypeMuxSubscription {\n\tsub := newsub(mux)\n\tmux.mutex.Lock()\n\tdefer mux.mutex.Unlock()\n\tif mux.stopped {\n\t\t// set the status to closed so that calling Unsubscribe after this\n\t\t// call will short circuit.\n\t\tsub.closed = true\n\t\tclose(sub.postC)\n\t} else {\n\t\tif mux.subm == nil {\n\t\t\tmux.subm = make(map[reflect.Type][]*TypeMuxSubscription)\n\t\t}\n\t\tfor _, t := range types {\n\t\t\trtyp := reflect.TypeOf(t)\n\t\t\toldsubs := mux.subm[rtyp]\n\t\t\tif find(oldsubs, sub) != -1 {\n\t\t\t\tpanic(fmt.Sprintf(\"event: duplicate type %s in Subscribe\", rtyp))\n\t\t\t}\n\t\t\tsubs := make([]*TypeMuxSubscription, len(oldsubs)+1)\n\t\t\tcopy(subs, oldsubs)\n\t\t\tsubs[len(oldsubs)] = sub\n\t\t\tmux.subm[rtyp] = subs\n\t\t}\n\t}\n\treturn sub\n}", "category": "Python"}, {"instruction": "// Implements p2p.MsgWriter", "input": "go language", "output": "func (prw *PssReadWriter) WriteMsg(msg p2p.Msg) error {\n\tlog.Trace(\"pssrw writemsg\", \"msg\", msg)\n\tif prw.closed {\n\t\treturn fmt.Errorf(\"connection closed\")\n\t}\n\trlpdata := make([]byte, msg.Size)\n\tmsg.Payload.Read(rlpdata)\n\tpmsg, err := rlp.EncodeToBytes(ProtocolMsg{\n\t\tCode:    msg.Code,\n\t\tSize:    msg.Size,\n\t\tPayload: rlpdata,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn prw.sendFunc(prw.key, *prw.topic, pmsg)\n}", "category": "Python"}, {"instruction": "// ReloadGlobalConfig reloads global configuration for this server.", "input": "go language", "output": "func ReloadGlobalConfig() error {\n\tconfReloadLock.Lock()\n\tdefer confReloadLock.Unlock()\n\n\tnc := NewConfig()\n\tif err := nc.Load(reloadConfPath); err != nil {\n\t\treturn err\n\t}\n\tif err := nc.Valid(); err != nil {\n\t\treturn err\n\t}\n\tc := GetGlobalConfig()\n\n\tdiffs := collectsDiff(*nc, *c, \"\")\n\tif len(diffs) == 0 {\n\t\treturn nil\n\t}\n\tvar formattedDiff bytes.Buffer\n\tfor k, vs := range diffs {\n\t\tformattedDiff.WriteString(fmt.Sprintf(\", %v:%v->%v\", k, vs[1], vs[0]))\n\t}\n\tunsupported := make([]string, 0, 2)\n\tfor k := range diffs {\n\t\tif _, ok := supportedReloadConfigs[k]; !ok {\n\t\t\tunsupported = append(unsupported, k)\n\t\t}\n\t}\n\tif len(unsupported) > 0 {\n\t\treturn fmt.Errorf(\"reloading config %v is not supported, only %v are supported now, \"+\n\t\t\t\"your changes%s\", unsupported, supportedReloadConfList, formattedDiff.String())\n\t}\n\n\tconfReloader(nc, c)\n\tglobalConf.Store(nc)\n\tlogutil.Logger(context.Background()).Info(\"reload config changes\" + formattedDiff.String())\n\treturn nil\n}", "category": "Python"}, {"instruction": "// marshalPlanModules iterates over a list of modules to recursively describe\n// the full module tree.", "input": "go language", "output": "func marshalPlanModules(\n\tchanges *plans.Changes,\n\tschemas *terraform.Schemas,\n\tchildModules []addrs.ModuleInstance,\n\tmoduleMap map[string][]addrs.ModuleInstance,\n\tmoduleResourceMap map[string][]addrs.AbsResourceInstance,\n) ([]module, error) {\n\n\tvar ret []module\n\n\tfor _, child := range childModules {\n\t\tmoduleResources := moduleResourceMap[child.String()]\n\t\t// cm for child module, naming things is hard.\n\t\tvar cm module\n\t\t// don't populate the address for the root module\n\t\tif child.String() != \"\" {\n\t\t\tcm.Address = child.String()\n\t\t}\n\t\trs, err := marshalPlanResources(changes, moduleResources, schemas)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcm.Resources = rs\n\n\t\tif len(moduleMap[child.String()]) > 0 {\n\t\t\tmoreChildModules, err := marshalPlanModules(changes, schemas, moduleMap[child.String()], moduleMap, moduleResourceMap)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tcm.ChildModules = moreChildModules\n\t\t}\n\n\t\tret = append(ret, cm)\n\t}\n\n\treturn ret, nil\n}", "category": "Python"}, {"instruction": "// IntentionGet returns the given intention by ID.", "input": "go language", "output": "func (s *Store) IntentionGet(ws memdb.WatchSet, id string) (uint64, *structs.Intention, error) {\n\ttx := s.db.Txn(false)\n\tdefer tx.Abort()\n\n\t// Get the table index.\n\tidx := maxIndexTxn(tx, intentionsTableName)\n\tif idx < 1 {\n\t\tidx = 1\n\t}\n\n\t// Look up by its ID.\n\twatchCh, intention, err := tx.FirstWatch(intentionsTableName, \"id\", id)\n\tif err != nil {\n\t\treturn 0, nil, fmt.Errorf(\"failed intention lookup: %s\", err)\n\t}\n\tws.Add(watchCh)\n\n\t// Convert the interface{} if it is non-nil\n\tvar result *structs.Intention\n\tif intention != nil {\n\t\tresult = intention.(*structs.Intention)\n\t}\n\n\treturn idx, result, nil\n}", "category": "Python"}, {"instruction": "// newDependencyUpdateCmd creates a new dependency update command.", "input": "go language", "output": "func newDependencyUpdateCmd(out io.Writer) *cobra.Command {\n\tduc := &dependencyUpdateCmd{out: out}\n\n\tcmd := &cobra.Command{\n\t\tUse:     \"update [flags] CHART\",\n\t\tAliases: []string{\"up\"},\n\t\tShort:   \"update charts/ based on the contents of requirements.yaml\",\n\t\tLong:    dependencyUpDesc,\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tcp := \".\"\n\t\t\tif len(args) > 0 {\n\t\t\t\tcp = args[0]\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\tduc.chartpath, err = filepath.Abs(cp)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tduc.helmhome = settings.Home\n\n\t\t\treturn duc.run()\n\t\t},\n\t}\n\n\tf := cmd.Flags()\n\tf.BoolVar(&duc.verify, \"verify\", false, \"verify the packages against signatures\")\n\tf.StringVar(&duc.keyring, \"keyring\", defaultKeyring(), \"keyring containing public keys\")\n\tf.BoolVar(&duc.skipRefresh, \"skip-refresh\", false, \"do not refresh the local repository cache\")\n\n\treturn cmd\n}", "category": "Python"}, {"instruction": "// handshake works like TCP handshake, but in a higher level, it first writes initial packet to client,\n// during handshake, client and server negotiate compatible features and do authentication.\n// After handshake, client can send sql query to server.", "input": "go language", "output": "func (cc *clientConn) handshake(ctx context.Context) error {\n\tif err := cc.writeInitialHandshake(); err != nil {\n\t\treturn err\n\t}\n\tif err := cc.readOptionalSSLRequestAndHandshakeResponse(ctx); err != nil {\n\t\terr1 := cc.writeError(err)\n\t\tif err1 != nil {\n\t\t\tlogutil.Logger(ctx).Debug(\"writeError failed\", zap.Error(err1))\n\t\t}\n\t\treturn err\n\t}\n\tdata := cc.alloc.AllocWithLen(4, 32)\n\tdata = append(data, mysql.OKHeader)\n\tdata = append(data, 0, 0)\n\tif cc.capability&mysql.ClientProtocol41 > 0 {\n\t\tdata = dumpUint16(data, mysql.ServerStatusAutocommit)\n\t\tdata = append(data, 0, 0)\n\t}\n\n\terr := cc.writePacket(data)\n\tcc.pkt.sequence = 0\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn cc.flush()\n}", "category": "Python"}, {"instruction": "// Validate checks validation of GenericOptions.", "input": "go language", "output": "func (o *GenericControllerManagerConfigurationOptions) Validate(allControllers []string, disabledByDefaultControllers []string) []error {\n\tif o == nil {\n\t\treturn nil\n\t}\n\n\terrs := []error{}\n\terrs = append(errs, o.Debugging.Validate()...)\n\n\tallControllersSet := sets.NewString(allControllers...)\n\tfor _, controller := range o.Controllers {\n\t\tif controller == \"*\" {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasPrefix(controller, \"-\") {\n\t\t\tcontroller = controller[1:]\n\t\t}\n\t\tif !allControllersSet.Has(controller) {\n\t\t\terrs = append(errs, fmt.Errorf(\"%q is not in the list of known controllers\", controller))\n\t\t}\n\t}\n\n\treturn errs\n}", "category": "Python"}, {"instruction": "// BatchGet queries values with the keys.", "input": "go language", "output": "func (c *RawKVClient) BatchGet(keys [][]byte) ([][]byte, error) {\n\tstart := time.Now()\n\tdefer func() {\n\t\ttikvRawkvCmdHistogramWithBatchGet.Observe(time.Since(start).Seconds())\n\t}()\n\n\tbo := NewBackoffer(context.Background(), rawkvMaxBackoff)\n\tresp, err := c.sendBatchReq(bo, keys, tikvrpc.CmdRawBatchGet)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tcmdResp := resp.RawBatchGet\n\tif cmdResp == nil {\n\t\treturn nil, errors.Trace(ErrBodyMissing)\n\t}\n\n\tkeyToValue := make(map[string][]byte, len(keys))\n\tfor _, pair := range cmdResp.Pairs {\n\t\tkeyToValue[string(pair.Key)] = pair.Value\n\t}\n\n\tvalues := make([][]byte, len(keys))\n\tfor i, key := range keys {\n\t\tvalues[i] = keyToValue[string(key)]\n\t}\n\treturn values, nil\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *GenericControllerManagerConfiguration) DeepCopyInto(out *GenericControllerManagerConfiguration) {\n\t*out = *in\n\tout.MinResyncPeriod = in.MinResyncPeriod\n\tout.ClientConnection = in.ClientConnection\n\tout.ControllerStartInterval = in.ControllerStartInterval\n\tin.LeaderElection.DeepCopyInto(&out.LeaderElection)\n\tif in.Controllers != nil {\n\t\tin, out := &in.Controllers, &out.Controllers\n\t\t*out = make([]string, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\tout.Debugging = in.Debugging\n\treturn\n}", "category": "Python"}, {"instruction": "// RecoverPubkey returns the public key of the signer.\n// msg must be the 32-byte hash of the message to be signed.\n// sig must be a 65-byte compact ECDSA signature containing the\n// recovery id as the last element.", "input": "go language", "output": "func RecoverPubkey(msg []byte, sig []byte) ([]byte, error) {\n\tif len(msg) != 32 {\n\t\treturn nil, ErrInvalidMsgLen\n\t}\n\tif err := checkSignature(sig); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar (\n\t\tpubkey  = make([]byte, 65)\n\t\tsigdata = (*C.uchar)(unsafe.Pointer(&sig[0]))\n\t\tmsgdata = (*C.uchar)(unsafe.Pointer(&msg[0]))\n\t)\n\tif C.secp256k1_ext_ecdsa_recover(context, (*C.uchar)(unsafe.Pointer(&pubkey[0])), sigdata, msgdata) == 0 {\n\t\treturn nil, ErrRecoverFailed\n\t}\n\treturn pubkey, nil\n}", "category": "Python"}, {"instruction": "// NewRemoteRuntimeService creates a new internalapi.RuntimeService.", "input": "go language", "output": "func NewRemoteRuntimeService(endpoint string, connectionTimeout time.Duration) (internalapi.RuntimeService, error) {\n\tklog.V(3).Infof(\"Connecting to runtime service %s\", endpoint)\n\taddr, dailer, err := util.GetAddressAndDialer(endpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), connectionTimeout)\n\tdefer cancel()\n\n\tconn, err := grpc.DialContext(ctx, addr, grpc.WithInsecure(), grpc.WithDialer(dailer), grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(maxMsgSize)))\n\tif err != nil {\n\t\tklog.Errorf(\"Connect remote runtime %s failed: %v\", addr, err)\n\t\treturn nil, err\n\t}\n\n\treturn &RemoteRuntimeService{\n\t\ttimeout:       connectionTimeout,\n\t\truntimeClient: runtimeapi.NewRuntimeServiceClient(conn),\n\t\tlogReduction:  logreduction.NewLogReduction(identicalErrorDelay),\n\t}, nil\n}", "category": "Python"}, {"instruction": "// Open implements the Executor Open interface.", "input": "go language", "output": "func (e *ShowDDLJobQueriesExec) Open(ctx context.Context) error {\n\tif err := e.baseExecutor.Open(ctx); err != nil {\n\t\treturn err\n\t}\n\ttxn, err := e.ctx.Txn(true)\n\tif err != nil {\n\t\treturn err\n\t}\n\tjobs, err := admin.GetDDLJobs(txn)\n\tif err != nil {\n\t\treturn err\n\t}\n\thistoryJobs, err := admin.GetHistoryDDLJobs(txn, admin.DefNumHistoryJobs)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\te.jobs = append(e.jobs, jobs...)\n\te.jobs = append(e.jobs, historyJobs...)\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Derive attempts to explicitly derive a hierarchical deterministic account at\n// the specified derivation path. If requested, the derived account will be added\n// to the wallet's tracked account list.", "input": "go language", "output": "func (w *Wallet) Derive(path accounts.DerivationPath, pin bool) (accounts.Account, error) {\n\tw.lock.Lock()\n\tdefer w.lock.Unlock()\n\n\taccount, err := w.session.derive(path)\n\tif err != nil {\n\t\treturn accounts.Account{}, err\n\t}\n\n\tif pin {\n\t\tpairing := w.Hub.pairing(w)\n\t\tpairing.Accounts[account.Address] = path\n\t\tif err := w.Hub.setPairing(w, pairing); err != nil {\n\t\t\treturn accounts.Account{}, err\n\t\t}\n\t}\n\n\treturn account, nil\n}", "category": "Python"}, {"instruction": "// Run starts the AvailableConditionController loop which manages the availability condition of API services.", "input": "go language", "output": "func (c *AvailableConditionController) Run(threadiness int, stopCh <-chan struct{}) {\n\tdefer utilruntime.HandleCrash()\n\tdefer c.queue.ShutDown()\n\n\tklog.Infof(\"Starting AvailableConditionController\")\n\tdefer klog.Infof(\"Shutting down AvailableConditionController\")\n\n\tif !controllers.WaitForCacheSync(\"AvailableConditionController\", stopCh, c.apiServiceSynced, c.servicesSynced, c.endpointsSynced) {\n\t\treturn\n\t}\n\n\tfor i := 0; i < threadiness; i++ {\n\t\tgo wait.Until(c.runWorker, time.Second, stopCh)\n\t}\n\n\t<-stopCh\n}", "category": "Python"}, {"instruction": "// setLimits updates the allowed peer count and total capacity of the priority\n// client pool. Since the free client pool is a child of the priority pool the\n// remaining peer count and capacity is assigned to the free pool by calling its\n// own setLimits function.\n//\n// Note: a decreasing change of the total capacity is applied with a delay.", "input": "go language", "output": "func (v *priorityClientPool) setLimits(count int, totalCap uint64) {\n\tv.lock.Lock()\n\tdefer v.lock.Unlock()\n\n\tv.totalCapAnnounced = totalCap\n\tif totalCap > v.totalCap {\n\t\tv.setLimitsNow(count, totalCap)\n\t\tv.subs.send(totalCap, false)\n\t\treturn\n\t}\n\tv.setLimitsNow(count, v.totalCap)\n\tif totalCap < v.totalCap {\n\t\tv.subs.send(totalCap, totalCap < v.totalConnectedCap)\n\t\tfor i, s := range v.updateSchedule {\n\t\t\tif totalCap >= s.totalCap {\n\t\t\t\ts.totalCap = totalCap\n\t\t\t\tv.updateSchedule = v.updateSchedule[:i+1]\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tv.updateSchedule = append(v.updateSchedule, scheduledUpdate{time: mclock.Now() + mclock.AbsTime(dropCapacityDelay), totalCap: totalCap})\n\t\tif len(v.updateSchedule) == 1 {\n\t\t\tv.scheduleCounter++\n\t\t\tid := v.scheduleCounter\n\t\t\tv.updateSchedule[0].id = id\n\t\t\ttime.AfterFunc(dropCapacityDelay, func() { v.checkUpdate(id) })\n\t\t}\n\t} else {\n\t\tv.updateSchedule = nil\n\t}\n}", "category": "Python"}, {"instruction": "// hasCorrectIssuer returns true if tokenData is a valid JWT in compact\n// serialization format and the \"iss\" claim matches the iss field of this token\n// authenticator, and otherwise returns false.\n//\n// Note: go-jose currently does not allow access to unverified JWS payloads.\n// See https://github.com/square/go-jose/issues/169", "input": "go language", "output": "func (j *jwtTokenAuthenticator) hasCorrectIssuer(tokenData string) bool {\n\tparts := strings.Split(tokenData, \".\")\n\tif len(parts) != 3 {\n\t\treturn false\n\t}\n\tpayload, err := base64.RawURLEncoding.DecodeString(parts[1])\n\tif err != nil {\n\t\treturn false\n\t}\n\tclaims := struct {\n\t\t// WARNING: this JWT is not verified. Do not trust these claims.\n\t\tIssuer string `json:\"iss\"`\n\t}{}\n\tif err := json.Unmarshal(payload, &claims); err != nil {\n\t\treturn false\n\t}\n\tif claims.Issuer != j.iss {\n\t\treturn false\n\t}\n\treturn true\n\n}", "category": "Python"}, {"instruction": "// CoordinateNode returns the LAN node in the given datacenter, along with\n// raw network coordinates.", "input": "go language", "output": "func (s *HTTPServer) CoordinateNode(resp http.ResponseWriter, req *http.Request) (interface{}, error) {\n\tif s.checkCoordinateDisabled(resp, req) {\n\t\treturn nil, nil\n\t}\n\n\tnode := strings.TrimPrefix(req.URL.Path, \"/v1/coordinate/node/\")\n\targs := structs.NodeSpecificRequest{Node: node}\n\tif done := s.parse(resp, req, &args.Datacenter, &args.QueryOptions); done {\n\t\treturn nil, nil\n\t}\n\n\tvar out structs.IndexedCoordinates\n\tdefer setMeta(resp, &out.QueryMeta)\n\tif err := s.agent.RPC(\"Coordinate.Node\", &args, &out); err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult := filterCoordinates(req, out.Coordinates)\n\tif len(result) == 0 {\n\t\tresp.WriteHeader(http.StatusNotFound)\n\t\treturn nil, nil\n\t}\n\n\treturn result, nil\n}", "category": "Python"}, {"instruction": "// Upload performs the upload of the directory and default path", "input": "go language", "output": "func (d *DirectoryUploader) Upload(upload UploadFn) error {\n\treturn filepath.Walk(d.Dir, func(path string, f os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif f.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tfile, err := Open(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trelPath, err := filepath.Rel(d.Dir, path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfile.Path = filepath.ToSlash(relPath)\n\t\treturn upload(file)\n\t})\n}", "category": "Python"}, {"instruction": "// wantsCompressedResponse reads the Accept-Encoding header to see if and which encoding is requested.", "input": "go language", "output": "func wantsCompressedResponse(req *http.Request) (bool, string) {\n\t// don't compress watches\n\tctx := req.Context()\n\tinfo, ok := request.RequestInfoFrom(ctx)\n\tif !ok {\n\t\treturn false, \"\"\n\t}\n\tif !info.IsResourceRequest {\n\t\treturn false, \"\"\n\t}\n\tif info.Verb == \"watch\" {\n\t\treturn false, \"\"\n\t}\n\theader := req.Header.Get(headerAcceptEncoding)\n\tgi := strings.Index(header, encodingGzip)\n\tzi := strings.Index(header, encodingDeflate)\n\t// use in order of appearance\n\tswitch {\n\tcase gi == -1:\n\t\treturn zi != -1, encodingDeflate\n\tcase zi == -1:\n\t\treturn gi != -1, encodingGzip\n\tcase gi < zi:\n\t\treturn true, encodingGzip\n\tdefault:\n\t\treturn true, encodingDeflate\n\t}\n}", "category": "Python"}, {"instruction": "// deleteFromIndices removes the object from each of the managed indexes\n// it is intended to be called from a function that already has a lock on the cache", "input": "go language", "output": "func (c *threadSafeMap) deleteFromIndices(obj interface{}, key string) {\n\tfor name, indexFunc := range c.indexers {\n\t\tindexValues, err := indexFunc(obj)\n\t\tif err != nil {\n\t\t\tpanic(fmt.Errorf(\"unable to calculate an index entry for key %q on index %q: %v\", key, name, err))\n\t\t}\n\n\t\tindex := c.indices[name]\n\t\tif index == nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, indexValue := range indexValues {\n\t\t\tset := index[indexValue]\n\t\t\tif set != nil {\n\t\t\t\tset.Delete(key)\n\t\t\t}\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// SigningIdentityForRequest provides a mock function with given fields: _a0", "input": "go language", "output": "func (_m *SigningIdentityFetcher) SigningIdentityForRequest(_a0 *peer.SignedProposal) (endorsement.SigningIdentity, error) {\n\tret := _m.Called(_a0)\n\n\tvar r0 endorsement.SigningIdentity\n\tif rf, ok := ret.Get(0).(func(*peer.SignedProposal) endorsement.SigningIdentity); ok {\n\t\tr0 = rf(_a0)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(endorsement.SigningIdentity)\n\t\t}\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(*peer.SignedProposal) error); ok {\n\t\tr1 = rf(_a0)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}", "category": "Python"}, {"instruction": "// Validate validates all the required options.", "input": "go language", "output": "func (o *Options) Validate() []error {\n\tvar errs []error\n\n\tif err := validation.ValidateKubeSchedulerConfiguration(&o.ComponentConfig).ToAggregate(); err != nil {\n\t\terrs = append(errs, err.Errors()...)\n\t}\n\terrs = append(errs, o.SecureServing.Validate()...)\n\terrs = append(errs, o.CombinedInsecureServing.Validate()...)\n\terrs = append(errs, o.Authentication.Validate()...)\n\terrs = append(errs, o.Authorization.Validate()...)\n\terrs = append(errs, o.Deprecated.Validate()...)\n\n\treturn errs\n}", "category": "Python"}, {"instruction": "// Encrypt encrypts a payload with a given secret.", "input": "go language", "output": "func Encrypt(payload []byte, secret string) ([]byte, error) {\n\tsalt := GetRandomString(saltLength)\n\n\tkey := encryptionKeyToBytes(secret, salt)\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The IV needs to be unique, but not secure. Therefore it's common to\n\t// include it at the beginning of the ciphertext.\n\tciphertext := make([]byte, saltLength+aes.BlockSize+len(payload))\n\tcopy(ciphertext[:saltLength], []byte(salt))\n\tiv := ciphertext[saltLength : saltLength+aes.BlockSize]\n\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n\t\treturn nil, err\n\t}\n\n\tstream := cipher.NewCFBEncrypter(block, iv)\n\tstream.XORKeyStream(ciphertext[saltLength+aes.BlockSize:], payload)\n\n\treturn ciphertext, nil\n}", "category": "Python"}, {"instruction": "// newTimestampDir creates a new timestamp directory", "input": "go language", "output": "func (w *AtomicWriter) newTimestampDir() (string, error) {\n\ttsDir, err := ioutil.TempDir(w.targetDir, time.Now().UTC().Format(\"..2006_01_02_15_04_05.\"))\n\tif err != nil {\n\t\tklog.Errorf(\"%s: unable to create new temp directory: %v\", w.logContext, err)\n\t\treturn \"\", err\n\t}\n\n\t// 0755 permissions are needed to allow 'group' and 'other' to recurse the\n\t// directory tree.  do a chmod here to ensure that permissions are set correctly\n\t// regardless of the process' umask.\n\terr = os.Chmod(tsDir, 0755)\n\tif err != nil {\n\t\tklog.Errorf(\"%s: unable to set mode on new temp directory: %v\", w.logContext, err)\n\t\treturn \"\", err\n\t}\n\n\treturn tsDir, nil\n}", "category": "Python"}, {"instruction": "// Create a container", "input": "go language", "output": "func (c *containerManager) Create(runConfig *container.Config, hostConfig *container.HostConfig) (container.ContainerCreateCreatedBody, error) {\n\tcontainer, err := c.backend.ContainerCreateIgnoreImagesArgsEscaped(types.ContainerCreateConfig{\n\t\tConfig:     runConfig,\n\t\tHostConfig: hostConfig,\n\t})\n\tif err != nil {\n\t\treturn container, err\n\t}\n\tc.tmpContainers[container.ID] = struct{}{}\n\treturn container, nil\n}", "category": "Python"}, {"instruction": "// NewControllerRevision returns a ControllerRevision with a ControllerRef pointing to parent and indicating that\n// parent is of parentKind. The ControllerRevision has labels matching template labels, contains Data equal to data, and\n// has a Revision equal to revision. The collisionCount is used when creating the name of the ControllerRevision\n// so the name is likely unique. If the returned error is nil, the returned ControllerRevision is valid. If the\n// returned error is not nil, the returned ControllerRevision is invalid for use.", "input": "go language", "output": "func NewControllerRevision(parent metav1.Object,\n\tparentKind schema.GroupVersionKind,\n\ttemplateLabels map[string]string,\n\tdata runtime.RawExtension,\n\trevision int64,\n\tcollisionCount *int32) (*apps.ControllerRevision, error) {\n\tlabelMap := make(map[string]string)\n\tfor k, v := range templateLabels {\n\t\tlabelMap[k] = v\n\t}\n\tcr := &apps.ControllerRevision{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tLabels:          labelMap,\n\t\t\tOwnerReferences: []metav1.OwnerReference{*metav1.NewControllerRef(parent, parentKind)},\n\t\t},\n\t\tData:     data,\n\t\tRevision: revision,\n\t}\n\thash := HashControllerRevision(cr, collisionCount)\n\tcr.Name = ControllerRevisionName(parent.GetName(), hash)\n\tcr.Labels[ControllerRevisionHashLabel] = hash\n\treturn cr, nil\n}", "category": "Python"}, {"instruction": "// SelectorFromValidatedSet returns a Selector which will match exactly the given Set.\n// A nil and empty Sets are considered equivalent to Everything().\n// It assumes that Set is already validated and doesn't do any validation.", "input": "go language", "output": "func SelectorFromValidatedSet(ls Set) Selector {\n\tif ls == nil || len(ls) == 0 {\n\t\treturn internalSelector{}\n\t}\n\tvar requirements internalSelector\n\tfor label, value := range ls {\n\t\trequirements = append(requirements, Requirement{key: label, operator: selection.Equals, strValues: []string{value}})\n\t}\n\t// sort to have deterministic string representation\n\tsort.Sort(ByKey(requirements))\n\treturn requirements\n}", "category": "Python"}, {"instruction": "// setClientCapacity sets the priority capacity assigned to a given client", "input": "go language", "output": "func (v *priorityClientPool) setClientCapacity(id enode.ID, cap uint64) error {\n\tv.lock.Lock()\n\tdefer v.lock.Unlock()\n\n\tc := v.clients[id]\n\tif c.cap == cap {\n\t\treturn nil\n\t}\n\tif c.connected {\n\t\tif v.totalConnectedCap+cap > v.totalCap+c.cap {\n\t\t\treturn ErrTotalCap\n\t\t}\n\t\tif c.cap == 0 {\n\t\t\tif v.child != nil {\n\t\t\t\tv.child.unregisterPeer(c.peer)\n\t\t\t}\n\t\t\tv.priorityCount++\n\t\t}\n\t\tif cap == 0 {\n\t\t\tv.priorityCount--\n\t\t}\n\t\tv.totalConnectedCap += cap - c.cap\n\t\tif v.child != nil {\n\t\t\tv.child.setLimits(v.maxPeers-v.priorityCount, v.totalCap-v.totalConnectedCap)\n\t\t}\n\t\tif cap == 0 {\n\t\t\tif v.child != nil {\n\t\t\t\tv.child.registerPeer(c.peer)\n\t\t\t}\n\t\t\tc.peer.updateCapacity(v.freeClientCap)\n\t\t} else {\n\t\t\tc.peer.updateCapacity(cap)\n\t\t}\n\t}\n\tif cap != 0 || c.connected {\n\t\tc.cap = cap\n\t\tv.clients[id] = c\n\t} else {\n\t\tdelete(v.clients, id)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// SetNamedPortsOfInstanceGroup sets the list of named ports on a given instance group", "input": "go language", "output": "func (g *Cloud) SetNamedPortsOfInstanceGroup(igName, zone string, namedPorts []*compute.NamedPort) error {\n\tctx, cancel := cloud.ContextWithCallTimeout()\n\tdefer cancel()\n\n\tmc := newInstanceGroupMetricContext(\"set_namedports\", zone)\n\treq := &compute.InstanceGroupsSetNamedPortsRequest{NamedPorts: namedPorts}\n\treturn mc.Observe(g.c.InstanceGroups().SetNamedPorts(ctx, meta.ZonalKey(igName, zone), req))\n}", "category": "Python"}, {"instruction": "// verifySandboxStatus verified whether all required fields are set in PodSandboxStatus.", "input": "go language", "output": "func verifySandboxStatus(status *runtimeapi.PodSandboxStatus) error {\n\tif status.Id == \"\" {\n\t\treturn fmt.Errorf(\"Id is not set\")\n\t}\n\n\tif status.Metadata == nil {\n\t\treturn fmt.Errorf(\"Metadata is not set\")\n\t}\n\n\tmetadata := status.Metadata\n\tif metadata.Name == \"\" || metadata.Namespace == \"\" || metadata.Uid == \"\" {\n\t\treturn fmt.Errorf(\"Name, Namespace or Uid is not in metadata %q\", metadata)\n\t}\n\n\tif status.CreatedAt == 0 {\n\t\treturn fmt.Errorf(\"CreatedAt is not set\")\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// reloadShutdownTimeout updates configuration with daemon shutdown timeout option\n// and updates the passed attributes", "input": "go language", "output": "func (daemon *Daemon) reloadShutdownTimeout(conf *config.Config, attributes map[string]string) {\n\t// update corresponding configuration\n\tif conf.IsValueSet(\"shutdown-timeout\") {\n\t\tdaemon.configStore.ShutdownTimeout = conf.ShutdownTimeout\n\t\tlogrus.Debugf(\"Reset Shutdown Timeout: %d\", daemon.configStore.ShutdownTimeout)\n\t}\n\n\t// prepare reload event attributes with updatable configurations\n\tattributes[\"shutdown-timeout\"] = fmt.Sprintf(\"%d\", daemon.configStore.ShutdownTimeout)\n}", "category": "Python"}, {"instruction": "// Copy data from a remote to a destination directory.", "input": "go language", "output": "func (cst *ClientSessionTransport) Copy(ctx context.Context, id fscache.RemoteIdentifier, dest string, cu filesync.CacheUpdater) error {\n\tcsi, ok := id.(*ClientSessionSourceIdentifier)\n\tif !ok {\n\t\treturn errors.New(\"invalid identifier for client session\")\n\t}\n\n\treturn filesync.FSSync(ctx, csi.caller, filesync.FSSendRequestOpt{\n\t\tIncludePatterns: csi.includePatterns,\n\t\tDestDir:         dest,\n\t\tCacheUpdater:    cu,\n\t})\n}", "category": "Python"}, {"instruction": "// NewCmdWait returns a cobra command for waiting", "input": "go language", "output": "func NewCmdWait(restClientGetter genericclioptions.RESTClientGetter, streams genericclioptions.IOStreams) *cobra.Command {\n\tflags := NewWaitFlags(restClientGetter, streams)\n\n\tcmd := &cobra.Command{\n\t\tUse:     \"wait ([-f FILENAME] | resource.group/resource.name | resource.group [(-l label | --all)]) [--for=delete|--for condition=available]\",\n\t\tShort:   \"Experimental: Wait for a specific condition on one or many resources.\",\n\t\tLong:    waitLong,\n\t\tExample: waitExample,\n\n\t\tDisableFlagsInUseLine: true,\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\to, err := flags.ToOptions(args)\n\t\t\tcmdutil.CheckErr(err)\n\t\t\terr = o.RunWait()\n\t\t\tcmdutil.CheckErr(err)\n\t\t},\n\t\tSuggestFor: []string{\"list\", \"ps\"},\n\t}\n\n\tflags.AddFlags(cmd)\n\n\treturn cmd\n}", "category": "Python"}, {"instruction": "// Hex returns an EIP55-compliant hex string representation of the address.", "input": "go language", "output": "func (a Address) Hex() string {\n\tunchecksummed := hex.EncodeToString(a[:])\n\tsha := sha3.NewLegacyKeccak256()\n\tsha.Write([]byte(unchecksummed))\n\thash := sha.Sum(nil)\n\n\tresult := []byte(unchecksummed)\n\tfor i := 0; i < len(result); i++ {\n\t\thashByte := hash[i/2]\n\t\tif i%2 == 0 {\n\t\t\thashByte = hashByte >> 4\n\t\t} else {\n\t\t\thashByte &= 0xf\n\t\t}\n\t\tif result[i] > '9' && hashByte > 7 {\n\t\t\tresult[i] -= 32\n\t\t}\n\t}\n\treturn \"0x\" + string(result)\n}", "category": "Python"}, {"instruction": "// NodeUnpublishVolume implements csi method", "input": "go language", "output": "func (f *NodeClient) NodeUnpublishVolume(ctx context.Context, req *csipb.NodeUnpublishVolumeRequest, opts ...grpc.CallOption) (*csipb.NodeUnpublishVolumeResponse, error) {\n\tif f.nextErr != nil {\n\t\treturn nil, f.nextErr\n\t}\n\n\tif req.GetVolumeId() == \"\" {\n\t\treturn nil, errors.New(\"missing volume id\")\n\t}\n\tif req.GetTargetPath() == \"\" {\n\t\treturn nil, errors.New(\"missing target path\")\n\t}\n\tdelete(f.nodePublishedVolumes, req.GetVolumeId())\n\treturn &csipb.NodeUnpublishVolumeResponse{}, nil\n}", "category": "Python"}, {"instruction": "// SetSecurityPolicyForAlphaGlobalBackendService sets the given\n// SecurityPolicyReference for the BackendService identified by the given name.", "input": "go language", "output": "func (g *Cloud) SetSecurityPolicyForAlphaGlobalBackendService(backendServiceName string, securityPolicyReference *computealpha.SecurityPolicyReference) error {\n\tctx, cancel := cloud.ContextWithCallTimeout()\n\tdefer cancel()\n\n\tmc := newBackendServiceMetricContextWithVersion(\"set_security_policy\", \"\", computeAlphaVersion)\n\treturn mc.Observe(g.c.AlphaBackendServices().SetSecurityPolicy(ctx, meta.GlobalKey(backendServiceName), securityPolicyReference))\n}", "category": "Python"}, {"instruction": "// Create makes a new prepared query. The ID of the new query is returned.", "input": "go language", "output": "func (c *PreparedQuery) Create(query *PreparedQueryDefinition, q *WriteOptions) (string, *WriteMeta, error) {\n\tr := c.c.newRequest(\"POST\", \"/v1/query\")\n\tr.setWriteOptions(q)\n\tr.obj = query\n\trtt, resp, err := requireOK(c.c.doRequest(r))\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\twm := &WriteMeta{}\n\twm.RequestTime = rtt\n\n\tvar out struct{ ID string }\n\tif err := decodeBody(resp, &out); err != nil {\n\t\treturn \"\", nil, err\n\t}\n\treturn out.ID, wm, nil\n}", "category": "Python"}, {"instruction": "// AnonymousClientConfig returns a copy of the given config with all user credentials (cert/key, bearer token, and username/password) and custom transports (WrapTransport, Transport) removed", "input": "go language", "output": "func AnonymousClientConfig(config *Config) *Config {\n\t// copy only known safe fields\n\treturn &Config{\n\t\tHost:          config.Host,\n\t\tAPIPath:       config.APIPath,\n\t\tContentConfig: config.ContentConfig,\n\t\tTLSClientConfig: TLSClientConfig{\n\t\t\tInsecure:   config.Insecure,\n\t\t\tServerName: config.ServerName,\n\t\t\tCAFile:     config.TLSClientConfig.CAFile,\n\t\t\tCAData:     config.TLSClientConfig.CAData,\n\t\t},\n\t\tRateLimiter: config.RateLimiter,\n\t\tUserAgent:   config.UserAgent,\n\t\tQPS:         config.QPS,\n\t\tBurst:       config.Burst,\n\t\tTimeout:     config.Timeout,\n\t\tDial:        config.Dial,\n\t}\n}", "category": "Python"}, {"instruction": "// Compile compiles the current tokens and returns a\n// binary string that can be interpreted by the EVM\n// and an error if it failed.\n//\n// compile is the second stage in the compile phase\n// which compiles the tokens to EVM instructions.", "input": "go language", "output": "func (c *Compiler) Compile() (string, []error) {\n\tvar errors []error\n\t// continue looping over the tokens until\n\t// the stack has been exhausted.\n\tfor c.pos < len(c.tokens) {\n\t\tif err := c.compileLine(); err != nil {\n\t\t\terrors = append(errors, err)\n\t\t}\n\t}\n\n\t// turn the binary to hex\n\tvar bin string\n\tfor _, v := range c.binary {\n\t\tswitch v := v.(type) {\n\t\tcase vm.OpCode:\n\t\t\tbin += fmt.Sprintf(\"%x\", []byte{byte(v)})\n\t\tcase []byte:\n\t\t\tbin += fmt.Sprintf(\"%x\", v)\n\t\t}\n\t}\n\treturn bin, errors\n}", "category": "Python"}, {"instruction": "// SetCapabilities sets the provided capabilities on the spec\n// All capabilities are added if privileged is true", "input": "go language", "output": "func SetCapabilities(s *specs.Spec, caplist []string) error {\n\ts.Process.Capabilities.Effective = caplist\n\ts.Process.Capabilities.Bounding = caplist\n\ts.Process.Capabilities.Permitted = caplist\n\ts.Process.Capabilities.Inheritable = caplist\n\t// setUser has already been executed here\n\t// if non root drop capabilities in the way execve does\n\tif s.Process.User.UID != 0 {\n\t\ts.Process.Capabilities.Effective = []string{}\n\t\ts.Process.Capabilities.Permitted = []string{}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// ContainerStatus returns the container status.", "input": "go language", "output": "func (r *RemoteRuntimeService) ContainerStatus(containerID string) (*runtimeapi.ContainerStatus, error) {\n\tctx, cancel := getContextWithTimeout(r.timeout)\n\tdefer cancel()\n\n\tresp, err := r.runtimeClient.ContainerStatus(ctx, &runtimeapi.ContainerStatusRequest{\n\t\tContainerId: containerID,\n\t})\n\tif err != nil {\n\t\t// Don't spam the log with endless messages about the same failure.\n\t\tif r.logReduction.ShouldMessageBePrinted(err.Error(), containerID) {\n\t\t\tklog.Errorf(\"ContainerStatus %q from runtime service failed: %v\", containerID, err)\n\t\t}\n\t\treturn nil, err\n\t}\n\tr.logReduction.ClearID(containerID)\n\n\tif resp.Status != nil {\n\t\tif err := verifyContainerStatus(resp.Status); err != nil {\n\t\t\tklog.Errorf(\"ContainerStatus of %q failed: %v\", containerID, err)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn resp.Status, nil\n}", "category": "Python"}, {"instruction": "// Unlock released the lock. It is an error to call this\n// if the lock is not currently held.", "input": "go language", "output": "func (l *Lock) Unlock() error {\n\t// Hold the lock as we try to release\n\tl.l.Lock()\n\tdefer l.l.Unlock()\n\n\t// Ensure the lock is actually held\n\tif !l.isHeld {\n\t\treturn ErrLockNotHeld\n\t}\n\n\t// Set that we no longer own the lock\n\tl.isHeld = false\n\n\t// Stop the session renew\n\tif l.sessionRenew != nil {\n\t\tdefer func() {\n\t\t\tclose(l.sessionRenew)\n\t\t\tl.sessionRenew = nil\n\t\t}()\n\t}\n\n\t// Get the lock entry, and clear the lock session\n\tlockEnt := l.lockEntry(l.lockSession)\n\tl.lockSession = \"\"\n\n\t// Release the lock explicitly\n\tkv := l.c.KV()\n\t_, _, err := kv.Release(lockEnt, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to release lock: %v\", err)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// defaultPodLimitsForDownwardAPI copies the input pod, and optional container,\n// and applies default resource limits. it returns a copy of the input pod,\n// and a copy of the input container (if specified) with default limits\n// applied. if a container has no limit specified, it will default the limit to\n// the node allocatable.\n// TODO: if/when we have pod level resources, we need to update this function\n// to use those limits instead of node allocatable.", "input": "go language", "output": "func (kl *Kubelet) defaultPodLimitsForDownwardAPI(pod *v1.Pod, container *v1.Container) (*v1.Pod, *v1.Container, error) {\n\tif pod == nil {\n\t\treturn nil, nil, fmt.Errorf(\"invalid input, pod cannot be nil\")\n\t}\n\n\tnode, err := kl.getNodeAnyWay()\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to find node object, expected a node\")\n\t}\n\tallocatable := node.Status.Allocatable\n\tklog.Infof(\"allocatable: %v\", allocatable)\n\toutputPod := pod.DeepCopy()\n\tfor idx := range outputPod.Spec.Containers {\n\t\tresource.MergeContainerResourceLimits(&outputPod.Spec.Containers[idx], allocatable)\n\t}\n\n\tvar outputContainer *v1.Container\n\tif container != nil {\n\t\toutputContainer = container.DeepCopy()\n\t\tresource.MergeContainerResourceLimits(outputContainer, allocatable)\n\t}\n\treturn outputPod, outputContainer, nil\n}", "category": "Python"}, {"instruction": "// Get is used to lookup a single key.", "input": "go language", "output": "func (k *KVS) Get(args *structs.KeyRequest, reply *structs.IndexedDirEntries) error {\n\tif done, err := k.srv.forward(\"KVS.Get\", args, args, reply); done {\n\t\treturn err\n\t}\n\n\taclRule, err := k.srv.ResolveToken(args.Token)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn k.srv.blockingQuery(\n\t\t&args.QueryOptions,\n\t\t&reply.QueryMeta,\n\t\tfunc(ws memdb.WatchSet, state *state.Store) error {\n\t\t\tindex, ent, err := state.KVSGet(ws, args.Key)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif aclRule != nil && !aclRule.KeyRead(args.Key) {\n\t\t\t\treturn acl.ErrPermissionDenied\n\t\t\t}\n\n\t\t\tif ent == nil {\n\t\t\t\t// Must provide non-zero index to prevent blocking\n\t\t\t\t// Index 1 is impossible anyways (due to Raft internals)\n\t\t\t\tif index == 0 {\n\t\t\t\t\treply.Index = 1\n\t\t\t\t} else {\n\t\t\t\t\treply.Index = index\n\t\t\t\t}\n\t\t\t\treply.Entries = nil\n\t\t\t} else {\n\t\t\t\treply.Index = ent.ModifyIndex\n\t\t\t\treply.Entries = structs.DirEntries{ent}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n}", "category": "Python"}, {"instruction": "// convertVolPathsToDevicePaths removes cluster or folder path from volPaths and convert to canonicalPath", "input": "go language", "output": "func (vs *VSphere) convertVolPathsToDevicePaths(ctx context.Context, nodeVolumes map[k8stypes.NodeName][]string) (map[k8stypes.NodeName][]string, error) {\n\tvmVolumes := make(map[k8stypes.NodeName][]string)\n\tfor nodeName, volPaths := range nodeVolumes {\n\t\tnodeInfo, err := vs.nodeManager.GetNodeInfo(nodeName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t_, err = vs.getVSphereInstanceForServer(nodeInfo.vcServer, ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor i, volPath := range volPaths {\n\t\t\tdeviceVolPath, err := convertVolPathToDevicePath(ctx, nodeInfo.dataCenter, volPath)\n\t\t\tif err != nil {\n\t\t\t\tklog.Errorf(\"Failed to convert vsphere volume path %s to device path for volume %s. err: %+v\", volPath, deviceVolPath, err)\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tvolPaths[i] = deviceVolPath\n\t\t}\n\t\tvmVolumes[nodeName] = volPaths\n\t}\n\treturn vmVolumes, nil\n}", "category": "Python"}, {"instruction": "// simplifyNode traverses the hierarchy of an expanded memory node and discards\n// all the internal caches, returning a node that only contains the raw data.", "input": "go language", "output": "func simplifyNode(n node) node {\n\tswitch n := n.(type) {\n\tcase *shortNode:\n\t\t// Short nodes discard the flags and cascade\n\t\treturn &rawShortNode{Key: n.Key, Val: simplifyNode(n.Val)}\n\n\tcase *fullNode:\n\t\t// Full nodes discard the flags and cascade\n\t\tnode := rawFullNode(n.Children)\n\t\tfor i := 0; i < len(node); i++ {\n\t\t\tif node[i] != nil {\n\t\t\t\tnode[i] = simplifyNode(node[i])\n\t\t\t}\n\t\t}\n\t\treturn node\n\n\tcase valueNode, hashNode, rawNode:\n\t\treturn n\n\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unknown node type: %T\", n))\n\t}\n}", "category": "Python"}, {"instruction": "// UpstreamResolverFuncFromClient returns a closure that captures a consul\n// client and when called provides a ConsulResolver that can resolve the given\n// UpstreamConfig using the provided api.Client dependency.", "input": "go language", "output": "func UpstreamResolverFuncFromClient(client *api.Client) func(cfg UpstreamConfig) (connect.Resolver, error) {\n\treturn func(cfg UpstreamConfig) (connect.Resolver, error) {\n\t\t// For now default to service as it has the most natural meaning and the error\n\t\t// that the service doesn't exist is probably reasonable if misconfigured. We\n\t\t// should probably handle actual configs that have invalid types at a higher\n\t\t// level anyway (like when parsing).\n\t\ttyp := connect.ConsulResolverTypeService\n\t\tif cfg.DestinationType == \"prepared_query\" {\n\t\t\ttyp = connect.ConsulResolverTypePreparedQuery\n\t\t}\n\t\treturn &connect.ConsulResolver{\n\t\t\tClient:     client,\n\t\t\tNamespace:  cfg.DestinationNamespace,\n\t\t\tName:       cfg.DestinationName,\n\t\t\tType:       typ,\n\t\t\tDatacenter: cfg.Datacenter,\n\t\t}, nil\n\t}\n}", "category": "Python"}, {"instruction": "// SyntaxError converts parser error to TiDB's syntax error.", "input": "go language", "output": "func SyntaxError(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tlogutil.Logger(context.Background()).Error(\"syntax error\", zap.Error(err))\n\n\t// If the error is already a terror with stack, pass it through.\n\tif errors.HasStack(err) {\n\t\tcause := errors.Cause(err)\n\t\tif _, ok := cause.(*terror.Error); ok {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn parser.ErrParse.GenWithStackByArgs(syntaxErrorPrefix, err.Error())\n}", "category": "Python"}, {"instruction": "// ValidateIgnorePreflightErrors validates duplicates in ignore-preflight-errors flag.", "input": "go language", "output": "func ValidateIgnorePreflightErrors(ignorePreflightErrors []string) (sets.String, error) {\n\tignoreErrors := sets.NewString()\n\tallErrs := field.ErrorList{}\n\n\tfor _, item := range ignorePreflightErrors {\n\t\tignoreErrors.Insert(strings.ToLower(item)) // parameters are case insensitive\n\t}\n\n\tif ignoreErrors.Has(\"all\") && ignoreErrors.Len() > 1 {\n\t\tallErrs = append(allErrs, field.Invalid(field.NewPath(\"ignore-preflight-errors\"), strings.Join(ignoreErrors.List(), \",\"), \"don't specify individual checks if 'all' is used\"))\n\t}\n\n\treturn ignoreErrors, allErrs.ToAggregate()\n}", "category": "Python"}, {"instruction": "// creates a unique path for disks (even if they share the same *.vhd name)", "input": "go language", "output": "func makeGlobalPDPath(host volume.VolumeHost, diskUri string, isManaged bool) (string, error) {\n\tdiskUri = libstrings.ToLower(diskUri) // always lower uri because users may enter it in caps.\n\tuniqueDiskNameTemplate := \"%s%s\"\n\thashedDiskUri := azure.MakeCRC32(diskUri)\n\tprefix := \"b\"\n\tif isManaged {\n\t\tprefix = \"m\"\n\t}\n\t// \"{m for managed b for blob}{hashed diskUri or DiskId depending on disk kind }\"\n\tdiskName := fmt.Sprintf(uniqueDiskNameTemplate, prefix, hashedDiskUri)\n\tpdPath := filepath.Join(host.GetPluginDir(azureDataDiskPluginName), util.MountsInGlobalPDPath, diskName)\n\n\treturn pdPath, nil\n}", "category": "Python"}, {"instruction": "// UpdateAPIServiceSpec updates the api service's OpenAPI spec. It is thread safe.", "input": "go language", "output": "func (s *specAggregator) UpdateAPIServiceSpec(apiServiceName string, spec *spec.Swagger, etag string) error {\n\ts.rwMutex.Lock()\n\tdefer s.rwMutex.Unlock()\n\n\tspecInfo, existingService := s.openAPISpecs[apiServiceName]\n\tif !existingService {\n\t\treturn fmt.Errorf(\"APIService %q does not exists\", apiServiceName)\n\t}\n\n\t// For APIServices (non-local) specs, only merge their /apis/ prefixed endpoint as it is the only paths\n\t// proxy handler delegates.\n\tif specInfo.apiService.Spec.Service != nil {\n\t\tspec = aggregator.FilterSpecByPathsWithoutSideEffects(spec, []string{\"/apis/\"})\n\t}\n\n\treturn s.tryUpdatingServiceSpecs(&openAPISpecInfo{\n\t\tapiService: specInfo.apiService,\n\t\tspec:       spec,\n\t\thandler:    specInfo.handler,\n\t\tetag:       etag,\n\t})\n}", "category": "Python"}, {"instruction": "// Into stores the result into obj, if possible. If obj is nil it is ignored.\n// If the returned object is of type Status and has .Status != StatusSuccess, the\n// additional information in Status will be used to enrich the error.", "input": "go language", "output": "func (r Result) Into(obj runtime.Object) error {\n\tif r.err != nil {\n\t\t// Check whether the result has a Status object in the body and prefer that.\n\t\treturn r.Error()\n\t}\n\tif r.decoder == nil {\n\t\treturn fmt.Errorf(\"serializer for %s doesn't exist\", r.contentType)\n\t}\n\tif len(r.body) == 0 {\n\t\treturn fmt.Errorf(\"0-length response with status code: %d and content type: %s\",\n\t\t\tr.statusCode, r.contentType)\n\t}\n\n\tout, _, err := r.decoder.Decode(r.body, nil, obj)\n\tif err != nil || out == obj {\n\t\treturn err\n\t}\n\t// if a different object is returned, see if it is Status and avoid double decoding\n\t// the object.\n\tswitch t := out.(type) {\n\tcase *metav1.Status:\n\t\t// any status besides StatusSuccess is considered an error.\n\t\tif t.Status != metav1.StatusSuccess {\n\t\t\treturn errors.FromObject(t)\n\t\t}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// RemoveMember notifies an etcd cluster to remove an existing member", "input": "go language", "output": "func (c *Client) RemoveMember(id uint64) ([]Member, error) {\n\tcli, err := clientv3.New(clientv3.Config{\n\t\tEndpoints:   c.Endpoints,\n\t\tDialTimeout: 30 * time.Second,\n\t\tTLS:         c.TLS,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer cli.Close()\n\n\t// Remove an existing member from the cluster\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tresp, err := cli.MemberRemove(ctx, id)\n\tcancel()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Returns the updated list of etcd members\n\tret := []Member{}\n\tfor _, m := range resp.Members {\n\t\tret = append(ret, Member{Name: m.Name, PeerURL: m.PeerURLs[0]})\n\t}\n\n\treturn ret, nil\n}", "category": "Python"}, {"instruction": "// CreateOrUpdateRouteTable invokes az.RouteTablesClient.CreateOrUpdate with exponential backoff retry", "input": "go language", "output": "func (az *Cloud) CreateOrUpdateRouteTable(routeTable network.RouteTable) error {\n\tif az.Config.shouldOmitCloudProviderBackoff() {\n\t\tctx, cancel := getContextWithCancel()\n\t\tdefer cancel()\n\n\t\tresp, err := az.RouteTablesClient.CreateOrUpdate(ctx, az.RouteTableResourceGroup, az.RouteTableName, routeTable)\n\t\treturn az.processHTTPResponse(nil, \"\", resp, err)\n\t}\n\n\treturn az.createOrUpdateRouteTableWithRetry(routeTable)\n}", "category": "Python"}, {"instruction": "// NewVolumeBinder sets up the volume binding library and binding queue", "input": "go language", "output": "func NewVolumeBinder(\n\tclient clientset.Interface,\n\tnodeInformer coreinformers.NodeInformer,\n\tpvcInformer coreinformers.PersistentVolumeClaimInformer,\n\tpvInformer coreinformers.PersistentVolumeInformer,\n\tstorageClassInformer storageinformers.StorageClassInformer,\n\tbindTimeout time.Duration) *VolumeBinder {\n\n\treturn &VolumeBinder{\n\t\tBinder: persistentvolume.NewVolumeBinder(client, nodeInformer, pvcInformer, pvInformer, storageClassInformer, bindTimeout),\n\t}\n}", "category": "Python"}, {"instruction": "// GetContainerLogs get container logs directly from docker daemon.", "input": "go language", "output": "func (d *dockerService) GetContainerLogs(_ context.Context, pod *v1.Pod, containerID kubecontainer.ContainerID, logOptions *v1.PodLogOptions, stdout, stderr io.Writer) error {\n\tcontainer, err := d.client.InspectContainer(containerID.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar since int64\n\tif logOptions.SinceSeconds != nil {\n\t\tt := metav1.Now().Add(-time.Duration(*logOptions.SinceSeconds) * time.Second)\n\t\tsince = t.Unix()\n\t}\n\tif logOptions.SinceTime != nil {\n\t\tsince = logOptions.SinceTime.Unix()\n\t}\n\topts := dockertypes.ContainerLogsOptions{\n\t\tShowStdout: true,\n\t\tShowStderr: true,\n\t\tSince:      strconv.FormatInt(since, 10),\n\t\tTimestamps: logOptions.Timestamps,\n\t\tFollow:     logOptions.Follow,\n\t}\n\tif logOptions.TailLines != nil {\n\t\topts.Tail = strconv.FormatInt(*logOptions.TailLines, 10)\n\t}\n\n\tsopts := libdocker.StreamOptions{\n\t\tOutputStream: stdout,\n\t\tErrorStream:  stderr,\n\t\tRawTerminal:  container.Config.Tty,\n\t}\n\treturn d.client.Logs(containerID.ID, opts, sopts)\n}", "category": "Python"}, {"instruction": "// BatchDelete deletes key-value pairs from TiKV", "input": "go language", "output": "func (c *RawKVClient) BatchDelete(keys [][]byte) error {\n\tstart := time.Now()\n\tdefer func() {\n\t\ttikvRawkvCmdHistogramWithBatchDelete.Observe(time.Since(start).Seconds())\n\t}()\n\n\tbo := NewBackoffer(context.Background(), rawkvMaxBackoff)\n\tresp, err := c.sendBatchReq(bo, keys, tikvrpc.CmdRawBatchDelete)\n\tif err != nil {\n\t\treturn errors.Trace(err)\n\t}\n\tcmdResp := resp.RawBatchDelete\n\tif cmdResp == nil {\n\t\treturn errors.Trace(ErrBodyMissing)\n\t}\n\tif cmdResp.GetError() != \"\" {\n\t\treturn errors.New(cmdResp.GetError())\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// IsCorruptedMnt return true if err is about corrupted mount point", "input": "go language", "output": "func IsCorruptedMnt(err error) bool {\n\tif err == nil {\n\t\treturn false\n\t}\n\tvar underlyingError error\n\tswitch pe := err.(type) {\n\tcase nil:\n\t\treturn false\n\tcase *os.PathError:\n\t\tunderlyingError = pe.Err\n\tcase *os.LinkError:\n\t\tunderlyingError = pe.Err\n\tcase *os.SyscallError:\n\t\tunderlyingError = pe.Err\n\t}\n\n\treturn underlyingError == syscall.ENOTCONN || underlyingError == syscall.ESTALE || underlyingError == syscall.EIO || underlyingError == syscall.EACCES\n}", "category": "Python"}, {"instruction": "// InitializeStdio is called by libcontainerd to connect the stdio.", "input": "go language", "output": "func (container *Container) InitializeStdio(iop *cio.DirectIO) (cio.IO, error) {\n\tif err := container.startLogging(); err != nil {\n\t\tcontainer.Reset(false)\n\t\treturn nil, err\n\t}\n\n\tcontainer.StreamConfig.CopyToPipe(iop)\n\n\tif container.StreamConfig.Stdin() == nil && !container.Config.Tty {\n\t\tif iop.Stdin != nil {\n\t\t\tif err := iop.Stdin.Close(); err != nil {\n\t\t\t\tlogrus.Warnf(\"error closing stdin: %+v\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &rio{IO: iop, sc: container.StreamConfig}, nil\n}", "category": "Python"}, {"instruction": "// MetadataFromContext extracts Metadata from a given context.Context", "input": "go language", "output": "func MetadataFromContext(ctx context.Context) Metadata {\n\tm := Metadata{\"NA\", \"NA\", \"NA\", \"\", \"\"} // batman\n\n\tif v := ctx.Value(\"remote\"); v != nil {\n\t\tm.Remote = v.(string)\n\t}\n\tif v := ctx.Value(\"scheme\"); v != nil {\n\t\tm.Scheme = v.(string)\n\t}\n\tif v := ctx.Value(\"local\"); v != nil {\n\t\tm.Local = v.(string)\n\t}\n\tif v := ctx.Value(\"Origin\"); v != nil {\n\t\tm.Origin = v.(string)\n\t}\n\tif v := ctx.Value(\"User-Agent\"); v != nil {\n\t\tm.UserAgent = v.(string)\n\t}\n\treturn m\n}", "category": "Python"}, {"instruction": "// assignPod assigns the given pod to the given machine.", "input": "go language", "output": "func (r *BindingREST) assignPod(ctx context.Context, podID string, machine string, annotations map[string]string, dryRun bool) (err error) {\n\tif _, err = r.setPodHostAndAnnotations(ctx, podID, \"\", machine, annotations, dryRun); err != nil {\n\t\terr = storeerr.InterpretGetError(err, api.Resource(\"pods\"), podID)\n\t\terr = storeerr.InterpretUpdateError(err, api.Resource(\"pods\"), podID)\n\t\tif _, ok := err.(*errors.StatusError); !ok {\n\t\t\terr = errors.NewConflict(api.Resource(\"pods/binding\"), podID, err)\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// AllocAutoID implements table.Table AllocAutoID interface.", "input": "go language", "output": "func (t *tableCommon) AllocAutoID(ctx sessionctx.Context) (int64, error) {\n\trowID, err := t.Allocator(ctx).Alloc(t.tableID)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif t.meta.ShardRowIDBits > 0 {\n\t\t// Use max record ShardRowIDBits to check overflow.\n\t\tif OverflowShardBits(rowID, t.meta.MaxShardRowIDBits) {\n\t\t\t// If overflow, the rowID may be duplicated. For examples,\n\t\t\t// t.meta.ShardRowIDBits = 4\n\t\t\t// rowID = 0010111111111111111111111111111111111111111111111111111111111111\n\t\t\t// shard = 01000000000000000000000000000000000000000000000000000000000000000\n\t\t\t// will be duplicated with:\n\t\t\t// rowID = 0100111111111111111111111111111111111111111111111111111111111111\n\t\t\t// shard = 0010000000000000000000000000000000000000000000000000000000000000\n\t\t\treturn 0, autoid.ErrAutoincReadFailed\n\t\t}\n\t\ttxnCtx := ctx.GetSessionVars().TxnCtx\n\t\tif txnCtx.Shard == nil {\n\t\t\tshard := t.calcShard(txnCtx.StartTS)\n\t\t\ttxnCtx.Shard = &shard\n\t\t}\n\t\trowID |= *txnCtx.Shard\n\t}\n\treturn rowID, nil\n}", "category": "Python"}, {"instruction": "// Heap returns a pprof heap dump", "input": "go language", "output": "func (d *Debug) Heap() ([]byte, error) {\n\tr := d.c.newRequest(\"GET\", \"/debug/pprof/heap\")\n\t_, resp, err := d.c.doRequest(r)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error making request: %s\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\t// We return a raw response because we're just passing through a response\n\t// from the pprof handlers\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error decoding body: %s\", err)\n\t}\n\n\treturn body, nil\n}", "category": "Python"}, {"instruction": "// LoadOrGenerateKeyFile looks for a key in the file at the given path. If it\n// can't find one, it will generate a new key and store it there.", "input": "go language", "output": "func LoadOrGenerateKeyFile(keyPath string) (data []byte, wasGenerated bool, err error) {\n\tloadedData, err := ioutil.ReadFile(keyPath)\n\t// Call verifyKeyData to ensure the file wasn't empty/corrupt.\n\tif err == nil && verifyKeyData(loadedData) {\n\t\treturn loadedData, false, err\n\t}\n\tif !os.IsNotExist(err) {\n\t\treturn nil, false, fmt.Errorf(\"error loading key from %s: %v\", keyPath, err)\n\t}\n\n\tgeneratedData, err := MakeEllipticPrivateKeyPEM()\n\tif err != nil {\n\t\treturn nil, false, fmt.Errorf(\"error generating key: %v\", err)\n\t}\n\tif err := WriteKey(keyPath, generatedData); err != nil {\n\t\treturn nil, false, fmt.Errorf(\"error writing key to %s: %v\", keyPath, err)\n\t}\n\treturn generatedData, true, nil\n}", "category": "Python"}, {"instruction": "// isSingleReference returns true when all references are from one repository\n// and there is at most one tag. Returns false for empty input.", "input": "go language", "output": "func isSingleReference(repoRefs []reference.Named) bool {\n\tif len(repoRefs) <= 1 {\n\t\treturn len(repoRefs) == 1\n\t}\n\tvar singleRef reference.Named\n\tcanonicalRefs := map[string]struct{}{}\n\tfor _, repoRef := range repoRefs {\n\t\tif _, isCanonical := repoRef.(reference.Canonical); isCanonical {\n\t\t\tcanonicalRefs[repoRef.Name()] = struct{}{}\n\t\t} else if singleRef == nil {\n\t\t\tsingleRef = repoRef\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\tif singleRef == nil {\n\t\t// Just use first canonical ref\n\t\tsingleRef = repoRefs[0]\n\t}\n\t_, ok := canonicalRefs[singleRef.Name()]\n\treturn len(canonicalRefs) == 1 && ok\n}", "category": "Python"}, {"instruction": "// GetResourcesAndPairs retrieves resources and \"KEY=VALUE or KEY-\" pair args from given args", "input": "go language", "output": "func GetResourcesAndPairs(args []string, pairType string) (resources []string, pairArgs []string, err error) {\n\tfoundPair := false\n\tfor _, s := range args {\n\t\tnonResource := (strings.Contains(s, \"=\") && s[0] != '=') || (strings.HasSuffix(s, \"-\") && s != \"-\")\n\t\tswitch {\n\t\tcase !foundPair && nonResource:\n\t\t\tfoundPair = true\n\t\t\tfallthrough\n\t\tcase foundPair && nonResource:\n\t\t\tpairArgs = append(pairArgs, s)\n\t\tcase !foundPair && !nonResource:\n\t\t\tresources = append(resources, s)\n\t\tcase foundPair && !nonResource:\n\t\t\terr = fmt.Errorf(\"all resources must be specified before %s changes: %s\", pairType, s)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// Generate an elliptic curve public / private keypair. If params is nil,\n// the recommended default parameters for the key will be chosen.", "input": "go language", "output": "func GenerateKey(rand io.Reader, curve elliptic.Curve, params *ECIESParams) (prv *PrivateKey, err error) {\n\tpb, x, y, err := elliptic.GenerateKey(curve, rand)\n\tif err != nil {\n\t\treturn\n\t}\n\tprv = new(PrivateKey)\n\tprv.PublicKey.X = x\n\tprv.PublicKey.Y = y\n\tprv.PublicKey.Curve = curve\n\tprv.D = new(big.Int).SetBytes(pb)\n\tif params == nil {\n\t\tparams = ParamsFromCurve(curve)\n\t}\n\tprv.PublicKey.Params = params\n\treturn\n}", "category": "Python"}, {"instruction": "// NewREST returns a RESTStorage object that will work against priority classes.", "input": "go language", "output": "func NewREST(optsGetter generic.RESTOptionsGetter) *REST {\n\tstore := &genericregistry.Store{\n\t\tNewFunc:                  func() runtime.Object { return &scheduling.PriorityClass{} },\n\t\tNewListFunc:              func() runtime.Object { return &scheduling.PriorityClassList{} },\n\t\tDefaultQualifiedResource: scheduling.Resource(\"priorityclasses\"),\n\n\t\tCreateStrategy: priorityclass.Strategy,\n\t\tUpdateStrategy: priorityclass.Strategy,\n\t\tDeleteStrategy: priorityclass.Strategy,\n\n\t\tTableConvertor: printerstorage.TableConvertor{TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)},\n\t}\n\toptions := &generic.StoreOptions{RESTOptions: optsGetter}\n\tif err := store.CompleteWithOptions(options); err != nil {\n\t\tpanic(err) // TODO: Propagate error up\n\t}\n\n\treturn &REST{store}\n}", "category": "Python"}, {"instruction": "// sniffJSONStateTerraformVersion attempts to sniff the Terraform version\n// specification from the given state file source code. The result is either\n// a version string or an empty string if no version number could be extracted.\n//\n// This is a best-effort function intended to produce nicer error messages. It\n// should not be used for any real processing.", "input": "go language", "output": "func sniffJSONStateTerraformVersion(src []byte) string {\n\ttype VersionSniff struct {\n\t\tVersion string `json:\"terraform_version\"`\n\t}\n\tvar sniff VersionSniff\n\n\terr := json.Unmarshal(src, &sniff)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\t// Attempt to parse the string as a version so we won't report garbage\n\t// as a version number.\n\t_, err = version.NewVersion(sniff.Version)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\treturn sniff.Version\n}", "category": "Python"}, {"instruction": "// NewWatchingConfigMapManager creates a manager that keeps a cache of all configmaps\n// necessary for registered pods.\n// It implements the following logic:\n// - whenever a pod is created or updated, we start inidvidual watches for all\n//   referenced objects that aren't referenced from other registered pods\n// - every GetObject() returns a value from local cache propagated via watches", "input": "go language", "output": "func NewWatchingConfigMapManager(kubeClient clientset.Interface) Manager {\n\tlistConfigMap := func(namespace string, opts metav1.ListOptions) (runtime.Object, error) {\n\t\treturn kubeClient.CoreV1().ConfigMaps(namespace).List(opts)\n\t}\n\twatchConfigMap := func(namespace string, opts metav1.ListOptions) (watch.Interface, error) {\n\t\treturn kubeClient.CoreV1().ConfigMaps(namespace).Watch(opts)\n\t}\n\tnewConfigMap := func() runtime.Object {\n\t\treturn &v1.ConfigMap{}\n\t}\n\tgr := corev1.Resource(\"configmap\")\n\treturn &configMapManager{\n\t\tmanager: manager.NewWatchBasedManager(listConfigMap, watchConfigMap, newConfigMap, gr, getConfigMapNames),\n\t}\n}", "category": "Python"}, {"instruction": "// List takes label and field selectors, and returns the list of Jobs that match those selectors.", "input": "go language", "output": "func (c *FakeJobs) List(opts v1.ListOptions) (result *batchv1.JobList, err error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewListAction(jobsResource, jobsKind, c.ns, opts), &batchv1.JobList{})\n\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n\tif label == nil {\n\t\tlabel = labels.Everything()\n\t}\n\tlist := &batchv1.JobList{ListMeta: obj.(*batchv1.JobList).ListMeta}\n\tfor _, item := range obj.(*batchv1.JobList).Items {\n\t\tif label.Matches(labels.Set(item.Labels)) {\n\t\t\tlist.Items = append(list.Items, item)\n\t\t}\n\t}\n\treturn list, err\n}", "category": "Python"}, {"instruction": "// PatchNodeStatus patches node status.", "input": "go language", "output": "func PatchNodeStatus(c v1core.CoreV1Interface, nodeName types.NodeName, oldNode *v1.Node, newNode *v1.Node) (*v1.Node, []byte, error) {\n\tpatchBytes, err := preparePatchBytesforNodeStatus(nodeName, oldNode, newNode)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tupdatedNode, err := c.Nodes().Patch(string(nodeName), types.StrategicMergePatchType, patchBytes, \"status\")\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to patch status %q for node %q: %v\", patchBytes, nodeName, err)\n\t}\n\treturn updatedNode, patchBytes, nil\n}", "category": "Python"}, {"instruction": "// SelectPeers returns a slice of peers that match the routing filter", "input": "go language", "output": "func SelectPeers(k int, peerPool []discovery.NetworkMember, filter RoutingFilter) []*comm.RemotePeer {\n\tvar res []*comm.RemotePeer\n\trand.Seed(int64(util.RandomUInt64()))\n\t// Iterate over the possible candidates in random order\n\tfor _, index := range rand.Perm(len(peerPool)) {\n\t\t// If we collected K peers, we can stop the iteration.\n\t\tif len(res) == k {\n\t\t\tbreak\n\t\t}\n\t\tpeer := peerPool[index]\n\t\t// For each one, check if it is a worthy candidate to be selected\n\t\tif !filter(peer) {\n\t\t\tcontinue\n\t\t}\n\t\tp := &comm.RemotePeer{PKIID: peer.PKIid, Endpoint: peer.PreferredEndpoint()}\n\t\tres = append(res, p)\n\t}\n\treturn res\n}", "category": "Python"}, {"instruction": "// ParseSetValue creates a Set with special number.", "input": "go language", "output": "func ParseSetValue(elems []string, number uint64) (Set, error) {\n\tif number == 0 {\n\t\treturn zeroSet, nil\n\t}\n\n\tvalue := number\n\tvar items []string\n\tfor i := 0; i < len(elems); i++ {\n\t\tif number&setIndexValue[i] > 0 {\n\t\t\titems = append(items, elems[i])\n\t\t\tnumber &= setIndexInvertValue[i]\n\t\t}\n\t}\n\n\tif number != 0 {\n\t\treturn Set{}, errors.Errorf(\"invalid number %d for Set %v\", number, elems)\n\t}\n\n\treturn Set{Name: strings.Join(items, \",\"), Value: value}, nil\n}", "category": "Python"}, {"instruction": "// toggleRecursorHandlerFromConfig enables or disables the recursor handler based on config idempotently", "input": "go language", "output": "func (d *DNSServer) toggleRecursorHandlerFromConfig(cfg *dnsConfig) {\n\tshouldEnable := len(cfg.Recursors) > 0\n\n\tif shouldEnable && atomic.CompareAndSwapUint32(&d.recursorEnabled, 0, 1) {\n\t\td.mux.HandleFunc(\".\", d.handleRecurse)\n\t\td.logger.Println(\"[DEBUG] dns: recursor enabled\")\n\t\treturn\n\t}\n\n\tif !shouldEnable && atomic.CompareAndSwapUint32(&d.recursorEnabled, 1, 0) {\n\t\td.mux.HandleRemove(\".\")\n\t\td.logger.Println(\"[DEBUG] dns: recursor disabled\")\n\t\treturn\n\t}\n}", "category": "Python"}, {"instruction": "// eventLoop runs a loop until the event mux closes. It will install and uninstall new\n// sync subscriptions and broadcasts sync status updates to the installed sync subscriptions.", "input": "go language", "output": "func (api *PublicDownloaderAPI) eventLoop() {\n\tvar (\n\t\tsub               = api.mux.Subscribe(StartEvent{}, DoneEvent{}, FailedEvent{})\n\t\tsyncSubscriptions = make(map[chan interface{}]struct{})\n\t)\n\n\tfor {\n\t\tselect {\n\t\tcase i := <-api.installSyncSubscription:\n\t\t\tsyncSubscriptions[i] = struct{}{}\n\t\tcase u := <-api.uninstallSyncSubscription:\n\t\t\tdelete(syncSubscriptions, u.c)\n\t\t\tclose(u.uninstalled)\n\t\tcase event := <-sub.Chan():\n\t\t\tif event == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar notification interface{}\n\t\t\tswitch event.Data.(type) {\n\t\t\tcase StartEvent:\n\t\t\t\tnotification = &SyncingResult{\n\t\t\t\t\tSyncing: true,\n\t\t\t\t\tStatus:  api.d.Progress(),\n\t\t\t\t}\n\t\t\tcase DoneEvent, FailedEvent:\n\t\t\t\tnotification = false\n\t\t\t}\n\t\t\t// broadcast\n\t\t\tfor c := range syncSubscriptions {\n\t\t\t\tc <- notification\n\t\t\t}\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// Shutdown stops all nodes in the network and closes the quit channel", "input": "go language", "output": "func (net *Network) Shutdown() {\n\tfor _, node := range net.Nodes {\n\t\tlog.Debug(\"Stopping node\", \"id\", node.ID())\n\t\tif err := node.Stop(); err != nil {\n\t\t\tlog.Warn(\"Can't stop node\", \"id\", node.ID(), \"err\", err)\n\t\t}\n\t\t// If the node has the close method, call it.\n\t\tif closer, ok := node.Node.(io.Closer); ok {\n\t\t\tif err := closer.Close(); err != nil {\n\t\t\t\tlog.Warn(\"Can't close node\", \"id\", node.ID(), \"err\", err)\n\t\t\t}\n\t\t}\n\t}\n\tclose(net.quitc)\n}", "category": "Python"}, {"instruction": "// DownloadIndexFile fetches the index from a repository.\n//\n// cachePath is prepended to any index that does not have an absolute path. This\n// is for pre-2.2.0 repo files.", "input": "go language", "output": "func (r *ChartRepository) DownloadIndexFile(cachePath string) error {\n\tvar indexURL string\n\tparsedURL, err := url.Parse(r.Config.URL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tparsedURL.Path = strings.TrimSuffix(parsedURL.Path, \"/\") + \"/index.yaml\"\n\n\tindexURL = parsedURL.String()\n\n\tr.setCredentials()\n\tresp, err := r.Client.Get(indexURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tindex, err := ioutil.ReadAll(resp)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := loadIndex(index); err != nil {\n\t\treturn err\n\t}\n\n\t// In Helm 2.2.0 the config.cache was accidentally switched to an absolute\n\t// path, which broke backward compatibility. This fixes it by prepending a\n\t// global cache path to relative paths.\n\t//\n\t// It is changed on DownloadIndexFile because that was the method that\n\t// originally carried the cache path.\n\tcp := r.Config.Cache\n\tif !filepath.IsAbs(cp) {\n\t\tcp = filepath.Join(cachePath, cp)\n\t}\n\n\treturn ioutil.WriteFile(cp, index, 0644)\n}", "category": "Python"}, {"instruction": "// killContainersWithSyncResult kills all pod's containers with sync results.", "input": "go language", "output": "func (m *kubeGenericRuntimeManager) killContainersWithSyncResult(pod *v1.Pod, runningPod kubecontainer.Pod, gracePeriodOverride *int64) (syncResults []*kubecontainer.SyncResult) {\n\tcontainerResults := make(chan *kubecontainer.SyncResult, len(runningPod.Containers))\n\twg := sync.WaitGroup{}\n\n\twg.Add(len(runningPod.Containers))\n\tfor _, container := range runningPod.Containers {\n\t\tgo func(container *kubecontainer.Container) {\n\t\t\tdefer utilruntime.HandleCrash()\n\t\t\tdefer wg.Done()\n\n\t\t\tkillContainerResult := kubecontainer.NewSyncResult(kubecontainer.KillContainer, container.Name)\n\t\t\tif err := m.killContainer(pod, container.ID, container.Name, \"\", gracePeriodOverride); err != nil {\n\t\t\t\tkillContainerResult.Fail(kubecontainer.ErrKillContainer, err.Error())\n\t\t\t}\n\t\t\tcontainerResults <- killContainerResult\n\t\t}(container)\n\t}\n\twg.Wait()\n\tclose(containerResults)\n\n\tfor containerResult := range containerResults {\n\t\tsyncResults = append(syncResults, containerResult)\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// StringInSlice returns a SchemaValidateFunc which tests if the provided value\n// is of type string and matches the value of an element in the valid slice\n// will test with in lower case if ignoreCase is true", "input": "go language", "output": "func StringInSlice(valid []string, ignoreCase bool) schema.SchemaValidateFunc {\n\treturn func(i interface{}, k string) (s []string, es []error) {\n\t\tv, ok := i.(string)\n\t\tif !ok {\n\t\t\tes = append(es, fmt.Errorf(\"expected type of %s to be string\", k))\n\t\t\treturn\n\t\t}\n\n\t\tfor _, str := range valid {\n\t\t\tif v == str || (ignoreCase && strings.ToLower(v) == strings.ToLower(str)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tes = append(es, fmt.Errorf(\"expected %s to be one of %v, got %s\", k, valid, v))\n\t\treturn\n\t}\n}", "category": "Python"}, {"instruction": "// ValidateConditionalService validates conditionally valid fields.", "input": "go language", "output": "func ValidateConditionalService(service, oldService *api.Service) field.ErrorList {\n\tvar errs field.ErrorList\n\t// If the SCTPSupport feature is disabled, and the old object isn't using the SCTP feature, prevent the new object from using it\n\tif !utilfeature.DefaultFeatureGate.Enabled(features.SCTPSupport) && len(serviceSCTPFields(oldService)) == 0 {\n\t\tfor _, f := range serviceSCTPFields(service) {\n\t\t\terrs = append(errs, field.NotSupported(f, api.ProtocolSCTP, []string{string(api.ProtocolTCP), string(api.ProtocolUDP)}))\n\t\t}\n\t}\n\treturn errs\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *Event) DeepCopyInto(out *Event) {\n\t*out = *in\n\tout.TypeMeta = in.TypeMeta\n\tin.ObjectMeta.DeepCopyInto(&out.ObjectMeta)\n\tin.EventTime.DeepCopyInto(&out.EventTime)\n\tif in.Series != nil {\n\t\tin, out := &in.Series, &out.Series\n\t\t*out = new(EventSeries)\n\t\t(*in).DeepCopyInto(*out)\n\t}\n\tout.Regarding = in.Regarding\n\tif in.Related != nil {\n\t\tin, out := &in.Related, &out.Related\n\t\t*out = new(v1.ObjectReference)\n\t\t**out = **in\n\t}\n\tout.DeprecatedSource = in.DeprecatedSource\n\tin.DeprecatedFirstTimestamp.DeepCopyInto(&out.DeprecatedFirstTimestamp)\n\tin.DeprecatedLastTimestamp.DeepCopyInto(&out.DeprecatedLastTimestamp)\n\treturn\n}", "category": "Python"}, {"instruction": "// A Zero date is a signal that the name can not be parsed.\n// This follows the format as outlined in Jekyll, https://jekyllrb.com/docs/posts/:\n// \"Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers\"", "input": "go language", "output": "func dateAndSlugFromBaseFilename(name string) (time.Time, string) {\n\twithoutExt, _ := helpers.FileAndExt(name)\n\n\tif len(withoutExt) < 10 {\n\t\t// This can not be a date.\n\t\treturn time.Time{}, \"\"\n\t}\n\n\t// Note: Hugo currently have no custom timezone support.\n\t// We will have to revisit this when that is in place.\n\td, err := time.Parse(\"2006-01-02\", withoutExt[:10])\n\tif err != nil {\n\t\treturn time.Time{}, \"\"\n\t}\n\n\t// Be a little lenient with the format here.\n\tslug := strings.Trim(withoutExt[10:], \" -_\")\n\n\treturn d, slug\n}", "category": "Python"}, {"instruction": "// MakeChainDatabase open an LevelDB using the flags passed to the client and will hard crash if it fails.", "input": "go language", "output": "func MakeChainDatabase(ctx *cli.Context, stack *node.Node) ethdb.Database {\n\tvar (\n\t\tcache   = ctx.GlobalInt(CacheFlag.Name) * ctx.GlobalInt(CacheDatabaseFlag.Name) / 100\n\t\thandles = makeDatabaseHandles()\n\t)\n\tname := \"chaindata\"\n\tif ctx.GlobalString(SyncModeFlag.Name) == \"light\" {\n\t\tname = \"lightchaindata\"\n\t}\n\tchainDb, err := stack.OpenDatabase(name, cache, handles, \"\")\n\tif err != nil {\n\t\tFatalf(\"Could not open database: %v\", err)\n\t}\n\treturn chainDb\n}", "category": "Python"}, {"instruction": "// FillNilSlices sets default value on slices that are still nil.", "input": "go language", "output": "func FillNilSlices(data interface{}) error {\n\ts := reflect.ValueOf(data).Elem()\n\tt := s.Type()\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\ttag := t.Field(i).Tag\n\n\t\tv := tag.Get(\"default\")\n\t\tif len(v) > 0 {\n\t\t\tswitch f.Interface().(type) {\n\t\t\tcase []string:\n\t\t\t\tif f.IsNil() {\n\t\t\t\t\t// Treat the default as a comma separated slice\n\t\t\t\t\tvs := strings.Split(v, \",\")\n\t\t\t\t\tfor i := range vs {\n\t\t\t\t\t\tvs[i] = strings.TrimSpace(vs[i])\n\t\t\t\t\t}\n\n\t\t\t\t\trv := reflect.MakeSlice(reflect.TypeOf([]string{}), len(vs), len(vs))\n\t\t\t\t\tfor i, v := range vs {\n\t\t\t\t\t\trv.Index(i).SetString(v)\n\t\t\t\t\t}\n\t\t\t\t\tf.Set(rv)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// findMaxScores returns the indexes of nodes in the \"priorityList\" that has the highest \"Score\".", "input": "go language", "output": "func findMaxScores(priorityList schedulerapi.HostPriorityList) []int {\n\tmaxScoreIndexes := make([]int, 0, len(priorityList)/2)\n\tmaxScore := priorityList[0].Score\n\tfor i, hp := range priorityList {\n\t\tif hp.Score > maxScore {\n\t\t\tmaxScore = hp.Score\n\t\t\tmaxScoreIndexes = maxScoreIndexes[:0]\n\t\t\tmaxScoreIndexes = append(maxScoreIndexes, i)\n\t\t} else if hp.Score == maxScore {\n\t\t\tmaxScoreIndexes = append(maxScoreIndexes, i)\n\t\t}\n\t}\n\treturn maxScoreIndexes\n}", "category": "Python"}, {"instruction": "// EvalReference evaluates the given reference in the receiving scope and\n// returns the resulting value. The value will be converted to the given type before\n// it is returned if possible, or else an error diagnostic will be produced\n// describing the conversion error.\n//\n// Pass an expected type of cty.DynamicPseudoType to skip automatic conversion\n// and just obtain the returned value directly.\n//\n// If the returned diagnostics contains errors then the result may be\n// incomplete, but will always be of the requested type.", "input": "go language", "output": "func (s *Scope) EvalReference(ref *addrs.Reference, wantType cty.Type) (cty.Value, tfdiags.Diagnostics) {\n\tvar diags tfdiags.Diagnostics\n\n\t// We cheat a bit here and just build an EvalContext for our requested\n\t// reference with the \"self\" address overridden, and then pull the \"self\"\n\t// result out of it to return.\n\tctx, ctxDiags := s.evalContext([]*addrs.Reference{ref}, ref.Subject)\n\tdiags = diags.Append(ctxDiags)\n\tval := ctx.Variables[\"self\"]\n\tif val == cty.NilVal {\n\t\tval = cty.DynamicVal\n\t}\n\n\tvar convErr error\n\tval, convErr = convert.Convert(val, wantType)\n\tif convErr != nil {\n\t\tval = cty.UnknownVal(wantType)\n\t\tdiags = diags.Append(&hcl.Diagnostic{\n\t\t\tSeverity: hcl.DiagError,\n\t\t\tSummary:  \"Incorrect value type\",\n\t\t\tDetail:   fmt.Sprintf(\"Invalid expression value: %s.\", tfdiags.FormatError(convErr)),\n\t\t\tSubject:  ref.SourceRange.ToHCL().Ptr(),\n\t\t})\n\t}\n\n\treturn val, diags\n}", "category": "Python"}, {"instruction": "// GetDriver initializes and returns the registered driver", "input": "go language", "output": "func GetDriver(name string, pg plugingetter.PluginGetter, config Options) (Driver, error) {\n\tif initFunc, exists := drivers[name]; exists {\n\t\treturn initFunc(filepath.Join(config.Root, name), config.DriverOptions, config.UIDMaps, config.GIDMaps)\n\t}\n\n\tpluginDriver, err := lookupPlugin(name, pg, config)\n\tif err == nil {\n\t\treturn pluginDriver, nil\n\t}\n\tlogrus.WithError(err).WithField(\"driver\", name).WithField(\"home-dir\", config.Root).Error(\"Failed to GetDriver graph\")\n\treturn nil, ErrNotSupported\n}", "category": "Python"}, {"instruction": "// New creates a new table convertor for the provided CRD column definition. If the printer definition cannot be parsed,\n// error will be returned along with a default table convertor.", "input": "go language", "output": "func New(crdColumns []apiextensions.CustomResourceColumnDefinition) (rest.TableConvertor, error) {\n\theaders := []metav1beta1.TableColumnDefinition{\n\t\t{Name: \"Name\", Type: \"string\", Format: \"name\", Description: swaggerMetadataDescriptions[\"name\"]},\n\t}\n\tc := &convertor{\n\t\theaders: headers,\n\t}\n\n\tfor _, col := range crdColumns {\n\t\tpath := jsonpath.New(col.Name)\n\t\tif err := path.Parse(fmt.Sprintf(\"{%s}\", col.JSONPath)); err != nil {\n\t\t\treturn c, fmt.Errorf(\"unrecognized column definition %q\", col.JSONPath)\n\t\t}\n\t\tpath.AllowMissingKeys(true)\n\n\t\tdesc := fmt.Sprintf(\"Custom resource definition column (in JSONPath format): %s\", col.JSONPath)\n\t\tif len(col.Description) > 0 {\n\t\t\tdesc = col.Description\n\t\t}\n\n\t\tc.additionalColumns = append(c.additionalColumns, path)\n\t\tc.headers = append(c.headers, metav1beta1.TableColumnDefinition{\n\t\t\tName:        col.Name,\n\t\t\tType:        col.Type,\n\t\t\tFormat:      col.Format,\n\t\t\tDescription: desc,\n\t\t\tPriority:    col.Priority,\n\t\t})\n\t}\n\n\treturn c, nil\n}", "category": "Python"}, {"instruction": "// localEvent is called when we receive an event on the local Serf", "input": "go language", "output": "func (c *Client) localEvent(event serf.UserEvent) {\n\t// Handle only consul events\n\tif !strings.HasPrefix(event.Name, \"consul:\") {\n\t\treturn\n\t}\n\n\tswitch name := event.Name; {\n\tcase name == newLeaderEvent:\n\t\tc.logger.Printf(\"[INFO] consul: New leader elected: %s\", event.Payload)\n\n\t\t// Trigger the callback\n\t\tif c.config.ServerUp != nil {\n\t\t\tc.config.ServerUp()\n\t\t}\n\tcase isUserEvent(name):\n\t\tevent.Name = rawUserEventName(name)\n\t\tc.logger.Printf(\"[DEBUG] consul: user event: %s\", event.Name)\n\n\t\t// Trigger the callback\n\t\tif c.config.UserEventHandler != nil {\n\t\t\tc.config.UserEventHandler(event)\n\t\t}\n\tdefault:\n\t\tif !c.handleEnterpriseUserEvents(event) {\n\t\t\tc.logger.Printf(\"[WARN] consul: Unhandled local event: %v\", event)\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// DeleteVolume uses the cloud entrypoint to delete specified volume", "input": "go language", "output": "func (util *DiskUtil) DeleteVolume(cd *cinderVolumeDeleter) error {\n\tcloud, err := cd.plugin.getCloudProvider()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = cloud.DeleteVolume(cd.pdName); err != nil {\n\t\t// OpenStack cloud provider returns volume.tryAgainError when necessary,\n\t\t// no handling needed here.\n\t\tklog.V(2).Infof(\"Error deleting cinder volume %s: %v\", cd.pdName, err)\n\t\treturn err\n\t}\n\tklog.V(2).Infof(\"Successfully deleted cinder volume %s\", cd.pdName)\n\treturn nil\n}", "category": "Python"}, {"instruction": "// AuthenticateToken authenticates the token using a chain of authenticator.Token objects.", "input": "go language", "output": "func (authHandler *unionAuthTokenHandler) AuthenticateToken(ctx context.Context, token string) (*authenticator.Response, bool, error) {\n\tvar errlist []error\n\tfor _, currAuthRequestHandler := range authHandler.Handlers {\n\t\tinfo, ok, err := currAuthRequestHandler.AuthenticateToken(ctx, token)\n\t\tif err != nil {\n\t\t\tif authHandler.FailOnError {\n\t\t\t\treturn info, ok, err\n\t\t\t}\n\t\t\terrlist = append(errlist, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif ok {\n\t\t\treturn info, ok, err\n\t\t}\n\t}\n\n\treturn nil, false, utilerrors.NewAggregate(errlist)\n}", "category": "Python"}, {"instruction": "// composeGlobalPrivUpdate composes update stmt assignment list string for global scope privilege update.", "input": "go language", "output": "func composeGlobalPrivUpdate(priv mysql.PrivilegeType, value string) (string, error) {\n\tif priv == mysql.AllPriv {\n\t\tstrs := make([]string, 0, len(mysql.Priv2UserCol))\n\t\tfor _, v := range mysql.Priv2UserCol {\n\t\t\tstrs = append(strs, fmt.Sprintf(`%s='%s'`, v, value))\n\t\t}\n\t\treturn strings.Join(strs, \", \"), nil\n\t}\n\tcol, ok := mysql.Priv2UserCol[priv]\n\tif !ok {\n\t\treturn \"\", errors.Errorf(\"Unknown priv: %v\", priv)\n\t}\n\treturn fmt.Sprintf(`%s='%s'`, col, value), nil\n}", "category": "Python"}, {"instruction": "// NewPathSpecWithBaseBaseFsProvided creats a new PathSpec from the given filesystems and language.\n// If an existing BaseFs is provided, parts of that is reused.", "input": "go language", "output": "func NewPathSpecWithBaseBaseFsProvided(fs *hugofs.Fs, cfg config.Provider, baseBaseFs *filesystems.BaseFs) (*PathSpec, error) {\n\n\tp, err := paths.New(fs, cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar options []func(*filesystems.BaseFs) error\n\tif baseBaseFs != nil {\n\t\toptions = []func(*filesystems.BaseFs) error{\n\t\t\tfilesystems.WithBaseFs(baseBaseFs),\n\t\t}\n\t}\n\tbfs, err := filesystems.NewBase(p, options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tps := &PathSpec{\n\t\tPaths:           p,\n\t\tBaseFs:          bfs,\n\t\tFs:              fs,\n\t\tCfg:             cfg,\n\t\tProcessingStats: NewProcessingStats(p.Lang()),\n\t}\n\n\tbasePath := ps.BaseURL.Path()\n\tif basePath != \"\" && basePath != \"/\" {\n\t\tps.BasePath = basePath\n\t}\n\n\treturn ps, nil\n}", "category": "Python"}, {"instruction": "// New builds a new IPWhiteLister given a list of CIDR-Strings to whitelist", "input": "go language", "output": "func New(ctx context.Context, next http.Handler, config config.IPWhiteList, name string) (http.Handler, error) {\n\tlogger := middlewares.GetLogger(ctx, name, typeName)\n\tlogger.Debug(\"Creating middleware\")\n\n\tif len(config.SourceRange) == 0 {\n\t\treturn nil, errors.New(\"sourceRange is empty, IPWhiteLister not created\")\n\t}\n\n\tchecker, err := ip.NewChecker(config.SourceRange)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot parse CIDR whitelist %s: %v\", config.SourceRange, err)\n\t}\n\n\tstrategy, err := config.IPStrategy.Get()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlogger.Debugf(\"Setting up IPWhiteLister with sourceRange: %s\", config.SourceRange)\n\treturn &ipWhiteLister{\n\t\tstrategy:    strategy,\n\t\twhiteLister: checker,\n\t\tnext:        next,\n\t\tname:        name,\n\t}, nil\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *NetworkPolicyPeer) DeepCopyInto(out *NetworkPolicyPeer) {\n\t*out = *in\n\tif in.PodSelector != nil {\n\t\tin, out := &in.PodSelector, &out.PodSelector\n\t\t*out = new(metav1.LabelSelector)\n\t\t(*in).DeepCopyInto(*out)\n\t}\n\tif in.NamespaceSelector != nil {\n\t\tin, out := &in.NamespaceSelector, &out.NamespaceSelector\n\t\t*out = new(metav1.LabelSelector)\n\t\t(*in).DeepCopyInto(*out)\n\t}\n\tif in.IPBlock != nil {\n\t\tin, out := &in.IPBlock, &out.IPBlock\n\t\t*out = new(IPBlock)\n\t\t(*in).DeepCopyInto(*out)\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// GetLabelsForVolume gets the volume labels for a volume", "input": "go language", "output": "func (c *Cloud) GetLabelsForVolume(ctx context.Context, pv *v1.PersistentVolume) (map[string]string, error) {\n\t// Ignore if not AWSElasticBlockStore.\n\tif pv.Spec.AWSElasticBlockStore == nil {\n\t\treturn nil, nil\n\t}\n\n\t// Ignore any volumes that are being provisioned\n\tif pv.Spec.AWSElasticBlockStore.VolumeID == cloudvolume.ProvisionedVolumeName {\n\t\treturn nil, nil\n\t}\n\n\tspec := KubernetesVolumeID(pv.Spec.AWSElasticBlockStore.VolumeID)\n\tlabels, err := c.GetVolumeLabels(spec)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn labels, nil\n}", "category": "Python"}, {"instruction": "// evalDecimal evals ABS(value).\n// See https://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_abs", "input": "go language", "output": "func (b *builtinAbsDecSig) evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error) {\n\tval, isNull, err := b.args[0].EvalDecimal(b.ctx, row)\n\tif isNull || err != nil {\n\t\treturn nil, isNull, err\n\t}\n\tto := new(types.MyDecimal)\n\tif !val.IsNegative() {\n\t\t*to = *val\n\t} else {\n\t\tif err = types.DecimalSub(new(types.MyDecimal), val, to); err != nil {\n\t\t\treturn nil, true, err\n\t\t}\n\t}\n\treturn to, false, nil\n}", "category": "Python"}, {"instruction": "// extractToDeleteItems takes a list and\n// returns 2 lists: one contains items that should be kept and the other contains items to be deleted.", "input": "go language", "output": "func extractToDeleteItems(l []interface{}) ([]interface{}, []interface{}, error) {\n\tvar nonDelete, toDelete []interface{}\n\tfor _, v := range l {\n\t\tm, ok := v.(map[string]interface{})\n\t\tif !ok {\n\t\t\treturn nil, nil, mergepatch.ErrBadArgType(m, v)\n\t\t}\n\n\t\tdirective, foundDirective := m[directiveMarker]\n\t\tif foundDirective && directive == deleteDirective {\n\t\t\ttoDelete = append(toDelete, v)\n\t\t} else {\n\t\t\tnonDelete = append(nonDelete, v)\n\t\t}\n\t}\n\treturn nonDelete, toDelete, nil\n}", "category": "Python"}, {"instruction": "// GetLackHandles gets the handles in expectedHandles but not in obtainedHandlesMap.", "input": "go language", "output": "func GetLackHandles(expectedHandles []int64, obtainedHandlesMap map[int64]struct{}) []int64 {\n\tdiffCnt := len(expectedHandles) - len(obtainedHandlesMap)\n\tdiffHandles := make([]int64, 0, diffCnt)\n\tvar cnt int\n\tfor _, handle := range expectedHandles {\n\t\tisExist := false\n\t\tif _, ok := obtainedHandlesMap[handle]; ok {\n\t\t\tdelete(obtainedHandlesMap, handle)\n\t\t\tisExist = true\n\t\t}\n\t\tif !isExist {\n\t\t\tdiffHandles = append(diffHandles, handle)\n\t\t\tcnt++\n\t\t\tif cnt == diffCnt {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn diffHandles\n}", "category": "Python"}, {"instruction": "// Transformer returns a func that can be used in the transformer publishing chain.\n// TODO(bep) minify config etc", "input": "go language", "output": "func (m Client) Transformer(mediatype media.Type) transform.Transformer {\n\t_, params, min := m.m.Match(mediatype.Type())\n\tif min == nil {\n\t\t// No minifier for this MIME type\n\t\treturn nil\n\t}\n\n\treturn func(ft transform.FromTo) error {\n\t\t// Note that the source io.Reader will already be buffered, but it implements\n\t\t// the Bytes() method, which is recognized by the Minify library.\n\t\treturn min.Minify(m.m, ft.To(), ft.From(), params)\n\t}\n}", "category": "Python"}, {"instruction": "// ValidateSocketPath validates format of socket path or url", "input": "go language", "output": "func ValidateSocketPath(socket string, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\n\tu, err := url.Parse(socket)\n\tif err != nil {\n\t\treturn append(allErrs, field.Invalid(fldPath, socket, fmt.Sprintf(\"URL parsing error: %v\", err)))\n\t}\n\n\tif u.Scheme == \"\" {\n\t\tif !filepath.IsAbs(u.Path) {\n\t\t\treturn append(allErrs, field.Invalid(fldPath, socket, fmt.Sprintf(\"path is not absolute: %s\", socket)))\n\t\t}\n\t} else if u.Scheme != kubeadmapiv1beta2.DefaultUrlScheme {\n\t\treturn append(allErrs, field.Invalid(fldPath, socket, fmt.Sprintf(\"URL scheme %s is not supported\", u.Scheme)))\n\t}\n\n\treturn allErrs\n}", "category": "Python"}, {"instruction": "// New creates a new ledger factory", "input": "go language", "output": "func New(directory string) blockledger.Factory {\n\tlogger.Debugf(\"Initializing ledger at: %s\", directory)\n\tif err := os.MkdirAll(directory, 0700); err != nil {\n\t\tlogger.Panicf(\"Could not create directory %s: %s\", directory, err)\n\t}\n\n\tjlf := &jsonLedgerFactory{\n\t\tdirectory: directory,\n\t\tledgers:   make(map[string]blockledger.ReadWriter),\n\t}\n\n\tinfos, err := ioutil.ReadDir(jlf.directory)\n\tif err != nil {\n\t\tlogger.Panicf(\"Error reading from directory %s while initializing ledger: %s\", jlf.directory, err)\n\t}\n\n\tfor _, info := range infos {\n\t\tif !info.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tvar chainID string\n\t\t_, err := fmt.Sscanf(info.Name(), chainDirectoryFormatString, &chainID)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tjlf.GetOrCreate(chainID)\n\t}\n\n\treturn jlf\n}", "category": "Python"}, {"instruction": "// validateParameters tests that keys are qualified names and that provisionerParameter are < 256kB.", "input": "go language", "output": "func validateParameters(params map[string]string, fldPath *field.Path) field.ErrorList {\n\tvar totalSize int64\n\tallErrs := field.ErrorList{}\n\n\tif len(params) > maxProvisionerParameterLen {\n\t\tallErrs = append(allErrs, field.TooLong(fldPath, \"Provisioner Parameters exceeded max allowed\", maxProvisionerParameterLen))\n\t\treturn allErrs\n\t}\n\n\tfor k, v := range params {\n\t\tif len(k) < 1 {\n\t\t\tallErrs = append(allErrs, field.Invalid(fldPath, k, \"field can not be empty.\"))\n\t\t}\n\t\ttotalSize += (int64)(len(k)) + (int64)(len(v))\n\t}\n\n\tif totalSize > maxProvisionerParameterSize {\n\t\tallErrs = append(allErrs, field.TooLong(fldPath, \"\", maxProvisionerParameterSize))\n\t}\n\treturn allErrs\n}", "category": "Python"}, {"instruction": "// writeToTar writes a single file to a tar archive.", "input": "go language", "output": "func writeToTar(out *tar.Writer, name string, body []byte) error {\n\t// TODO: Do we need to create dummy parent directory names if none exist?\n\th := &tar.Header{\n\t\tName:    filepath.ToSlash(name),\n\t\tMode:    0755,\n\t\tSize:    int64(len(body)),\n\t\tModTime: time.Now(),\n\t}\n\tif err := out.WriteHeader(h); err != nil {\n\t\treturn err\n\t}\n\tif _, err := out.Write(body); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// ObjectKinds returns all possible group,version,kind of the go object, true if the\n// object is considered unversioned, or an error if it's not a pointer or is unregistered.", "input": "go language", "output": "func (s *Scheme) ObjectKinds(obj Object) ([]schema.GroupVersionKind, bool, error) {\n\t// Unstructured objects are always considered to have their declared GVK\n\tif _, ok := obj.(Unstructured); ok {\n\t\t// we require that the GVK be populated in order to recognize the object\n\t\tgvk := obj.GetObjectKind().GroupVersionKind()\n\t\tif len(gvk.Kind) == 0 {\n\t\t\treturn nil, false, NewMissingKindErr(\"unstructured object has no kind\")\n\t\t}\n\t\tif len(gvk.Version) == 0 {\n\t\t\treturn nil, false, NewMissingVersionErr(\"unstructured object has no version\")\n\t\t}\n\t\treturn []schema.GroupVersionKind{gvk}, false, nil\n\t}\n\n\tv, err := conversion.EnforcePtr(obj)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tt := v.Type()\n\n\tgvks, ok := s.typeToGVK[t]\n\tif !ok {\n\t\treturn nil, false, NewNotRegisteredErrForType(s.schemeName, t)\n\t}\n\t_, unversionedType := s.unversionedTypes[t]\n\n\treturn gvks, unversionedType, nil\n}", "category": "Python"}, {"instruction": "// NewWorker instantiates a local worker", "input": "go language", "output": "func NewWorker(opt Opt) (*Worker, error) {\n\tsm, err := source.NewManager()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcm := opt.CacheManager\n\tsm.Register(opt.ImageSource)\n\n\tgs, err := git.NewSource(git.Opt{\n\t\tCacheAccessor: cm,\n\t\tMetadataStore: opt.MetadataStore,\n\t})\n\tif err == nil {\n\t\tsm.Register(gs)\n\t} else {\n\t\tlogrus.Warnf(\"Could not register builder git source: %s\", err)\n\t}\n\n\ths, err := http.NewSource(http.Opt{\n\t\tCacheAccessor: cm,\n\t\tMetadataStore: opt.MetadataStore,\n\t\tTransport:     opt.Transport,\n\t})\n\tif err == nil {\n\t\tsm.Register(hs)\n\t} else {\n\t\tlogrus.Warnf(\"Could not register builder http source: %s\", err)\n\t}\n\n\tss, err := local.NewSource(local.Opt{\n\t\tCacheAccessor: cm,\n\t\tMetadataStore: opt.MetadataStore,\n\t})\n\tif err == nil {\n\t\tsm.Register(ss)\n\t} else {\n\t\tlogrus.Warnf(\"Could not register builder local source: %s\", err)\n\t}\n\n\treturn &Worker{\n\t\tOpt:           opt,\n\t\tSourceManager: sm,\n\t}, nil\n}", "category": "Python"}, {"instruction": "// NewEditOptions returns an initialized EditOptions instance", "input": "go language", "output": "func NewEditOptions(editMode EditMode, ioStreams genericclioptions.IOStreams) *EditOptions {\n\treturn &EditOptions{\n\t\tRecordFlags: genericclioptions.NewRecordFlags(),\n\n\t\tEditMode: editMode,\n\n\t\tPrintFlags: genericclioptions.NewPrintFlags(\"edited\").WithTypeSetter(scheme.Scheme),\n\n\t\teditPrinterOptions: &editPrinterOptions{\n\t\t\t// create new editor-specific PrintFlags, with all\n\t\t\t// output flags disabled, except json / yaml\n\t\t\tprintFlags: (&genericclioptions.PrintFlags{\n\t\t\t\tJSONYamlPrintFlags: genericclioptions.NewJSONYamlPrintFlags(),\n\t\t\t}).WithDefaultOutput(\"yaml\"),\n\t\t\text:       \".yaml\",\n\t\t\taddHeader: true,\n\t\t},\n\n\t\tWindowsLineEndings: goruntime.GOOS == \"windows\",\n\n\t\tRecorder: genericclioptions.NoopRecorder{},\n\n\t\tIOStreams: ioStreams,\n\t}\n}", "category": "Python"}, {"instruction": "// loadChartRepositories reads the repositories.yaml, and then builds a map of\n// ChartRepositories.\n//\n// The key is the local name (which is only present in the repositories.yaml).", "input": "go language", "output": "func (m *Manager) loadChartRepositories() (map[string]*repo.ChartRepository, error) {\n\tindices := map[string]*repo.ChartRepository{}\n\trepoyaml := m.HelmHome.RepositoryFile()\n\n\t// Load repositories.yaml file\n\trf, err := repo.LoadRepositoriesFile(repoyaml)\n\tif err != nil {\n\t\treturn indices, fmt.Errorf(\"failed to load %s: %s\", repoyaml, err)\n\t}\n\n\tfor _, re := range rf.Repositories {\n\t\tlname := re.Name\n\t\tcacheindex := m.HelmHome.CacheIndex(lname)\n\t\tindex, err := repo.LoadIndexFile(cacheindex)\n\t\tif err != nil {\n\t\t\treturn indices, err\n\t\t}\n\n\t\t// TODO: use constructor\n\t\tcr := &repo.ChartRepository{\n\t\t\tConfig:    re,\n\t\t\tIndexFile: index,\n\t\t}\n\t\tindices[lname] = cr\n\t}\n\treturn indices, nil\n}", "category": "Python"}, {"instruction": "// AddFlags adds flags related to NamespaceController for controller manager to the specified FlagSet.", "input": "go language", "output": "func (o *NamespaceControllerOptions) AddFlags(fs *pflag.FlagSet) {\n\tif o == nil {\n\t\treturn\n\t}\n\n\tfs.DurationVar(&o.NamespaceSyncPeriod.Duration, \"namespace-sync-period\", o.NamespaceSyncPeriod.Duration, \"The period for syncing namespace life-cycle updates\")\n\tfs.Int32Var(&o.ConcurrentNamespaceSyncs, \"concurrent-namespace-syncs\", o.ConcurrentNamespaceSyncs, \"The number of namespace objects that are allowed to sync concurrently. Larger number = more responsive namespace termination, but more CPU (and network) load\")\n}", "category": "Python"}, {"instruction": "// isVolumeUsed returns list of pods that use given PV.", "input": "go language", "output": "func (ctrl *PersistentVolumeController) isVolumeUsed(pv *v1.PersistentVolume) ([]string, bool, error) {\n\tif pv.Spec.ClaimRef == nil {\n\t\treturn nil, false, nil\n\t}\n\tclaimName := pv.Spec.ClaimRef.Name\n\n\tpodNames := sets.NewString()\n\tpods, err := ctrl.podLister.Pods(pv.Spec.ClaimRef.Namespace).List(labels.Everything())\n\tif err != nil {\n\t\treturn nil, false, fmt.Errorf(\"error listing pods: %s\", err)\n\t}\n\tfor _, pod := range pods {\n\t\tif util.IsPodTerminated(pod, pod.Status) {\n\t\t\tcontinue\n\t\t}\n\t\tfor i := range pod.Spec.Volumes {\n\t\t\tusedPV := &pod.Spec.Volumes[i]\n\t\t\tif usedPV.PersistentVolumeClaim != nil && usedPV.PersistentVolumeClaim.ClaimName == claimName {\n\t\t\t\tpodNames.Insert(pod.Namespace + \"/\" + pod.Name)\n\t\t\t}\n\t\t}\n\t}\n\treturn podNames.List(), podNames.Len() != 0, nil\n}", "category": "Python"}, {"instruction": "// gvkWithDefaults returns group kind and version defaulting from provided default", "input": "go language", "output": "func gvkWithDefaults(actual, defaultGVK schema.GroupVersionKind) schema.GroupVersionKind {\n\tif len(actual.Kind) == 0 {\n\t\tactual.Kind = defaultGVK.Kind\n\t}\n\tif len(actual.Version) == 0 && len(actual.Group) == 0 {\n\t\tactual.Group = defaultGVK.Group\n\t\tactual.Version = defaultGVK.Version\n\t}\n\tif len(actual.Version) == 0 && actual.Group == defaultGVK.Group {\n\t\tactual.Version = defaultGVK.Version\n\t}\n\treturn actual\n}", "category": "Python"}, {"instruction": "// GetPvtDataAndBlockByNum provides a mock function with given fields: seqNum", "input": "go language", "output": "func (_m *Committer) GetPvtDataAndBlockByNum(seqNum uint64) (*ledger.BlockAndPvtData, error) {\n\tret := _m.Called(seqNum)\n\n\tvar r0 *ledger.BlockAndPvtData\n\tif rf, ok := ret.Get(0).(func(uint64) *ledger.BlockAndPvtData); ok {\n\t\tr0 = rf(seqNum)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(*ledger.BlockAndPvtData)\n\t\t}\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(uint64) error); ok {\n\t\tr1 = rf(seqNum)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}", "category": "Python"}, {"instruction": "// SupportsAttributes ignores all calls that do not deal with pod resources or storage requests (PVCs).\n// Also ignores any call that has a subresource defined.", "input": "go language", "output": "func (d *DefaultLimitRangerActions) SupportsAttributes(a admission.Attributes) bool {\n\tif a.GetSubresource() != \"\" {\n\t\treturn false\n\t}\n\n\t// Since containers and initContainers cannot currently be added, removed, or updated, it is unnecessary\n\t// to mutate and validate limitrange on pod updates. Trying to mutate containers or initContainers on a pod\n\t// update request will always fail pod validation because those fields are immutable once the object is created.\n\tif a.GetKind().GroupKind() == api.Kind(\"Pod\") && a.GetOperation() == admission.Update {\n\t\treturn false\n\t}\n\n\treturn a.GetKind().GroupKind() == api.Kind(\"Pod\") || a.GetKind().GroupKind() == api.Kind(\"PersistentVolumeClaim\")\n}", "category": "Python"}, {"instruction": "// Func gets the translate func for the given language, or for the default\n// configured language if not found.", "input": "go language", "output": "func (t Translator) Func(lang string) bundle.TranslateFunc {\n\tif f, ok := t.translateFuncs[lang]; ok {\n\t\treturn f\n\t}\n\tt.logger.INFO.Printf(\"Translation func for language %v not found, use default.\", lang)\n\tif f, ok := t.translateFuncs[t.cfg.GetString(\"defaultContentLanguage\")]; ok {\n\t\treturn f\n\t}\n\tt.logger.INFO.Println(\"i18n not initialized; if you need string translations, check that you have a bundle in /i18n that matches the site language or the default language.\")\n\treturn func(translationID string, args ...interface{}) string {\n\t\treturn \"\"\n\t}\n\n}", "category": "Python"}, {"instruction": "// List takes label and field selectors, and returns the list of ReplicaSets that match those selectors.", "input": "go language", "output": "func (c *FakeReplicaSets) List(opts v1.ListOptions) (result *v1beta2.ReplicaSetList, err error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewListAction(replicasetsResource, replicasetsKind, c.ns, opts), &v1beta2.ReplicaSetList{})\n\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n\tif label == nil {\n\t\tlabel = labels.Everything()\n\t}\n\tlist := &v1beta2.ReplicaSetList{ListMeta: obj.(*v1beta2.ReplicaSetList).ListMeta}\n\tfor _, item := range obj.(*v1beta2.ReplicaSetList).Items {\n\t\tif label.Matches(labels.Set(item.Labels)) {\n\t\t\tlist.Items = append(list.Items, item)\n\t\t}\n\t}\n\treturn list, err\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *ImageReviewSpec) DeepCopyInto(out *ImageReviewSpec) {\n\t*out = *in\n\tif in.Containers != nil {\n\t\tin, out := &in.Containers, &out.Containers\n\t\t*out = make([]ImageReviewContainerSpec, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\tif in.Annotations != nil {\n\t\tin, out := &in.Annotations, &out.Annotations\n\t\t*out = make(map[string]string, len(*in))\n\t\tfor key, val := range *in {\n\t\t\t(*out)[key] = val\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// following functions are used by the instruction jump  table\n// make log instruction function", "input": "go language", "output": "func makeLog(size int) executionFunc {\n\treturn func(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {\n\t\ttopics := make([]common.Hash, size)\n\t\tmStart, mSize := stack.pop(), stack.pop()\n\t\tfor i := 0; i < size; i++ {\n\t\t\ttopics[i] = common.BigToHash(stack.pop())\n\t\t}\n\n\t\td := memory.Get(mStart.Int64(), mSize.Int64())\n\t\tinterpreter.evm.StateDB.AddLog(&types.Log{\n\t\t\tAddress: contract.Address(),\n\t\t\tTopics:  topics,\n\t\t\tData:    d,\n\t\t\t// This is a non-consensus field, but assigned here because\n\t\t\t// core/state doesn't know the current block number.\n\t\t\tBlockNumber: interpreter.evm.BlockNumber.Uint64(),\n\t\t})\n\n\t\tinterpreter.intPool.put(mStart, mSize)\n\t\treturn nil, nil\n\t}\n}", "category": "Python"}, {"instruction": "// LoadConfig extract the KubeConfigFile from configFile", "input": "go language", "output": "func LoadConfig(configFile io.Reader) (string, error) {\n\tvar kubeconfigFile string\n\tif configFile != nil {\n\t\t// we have a config so parse it.\n\t\tdata, err := ioutil.ReadAll(configFile)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tdecoder := codecs.UniversalDecoder()\n\t\tdecodedObj, err := runtime.Decode(decoder, data)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tconfig, ok := decodedObj.(*webhookadmission.WebhookAdmission)\n\t\tif !ok {\n\t\t\treturn \"\", fmt.Errorf(\"unexpected type: %T\", decodedObj)\n\t\t}\n\n\t\tif !path.IsAbs(config.KubeConfigFile) {\n\t\t\treturn \"\", field.Invalid(field.NewPath(\"kubeConfigFile\"), config.KubeConfigFile, \"must be an absolute file path\")\n\t\t}\n\n\t\tkubeconfigFile = config.KubeConfigFile\n\t}\n\treturn kubeconfigFile, nil\n}", "category": "Python"}, {"instruction": "// updateClaim runs in worker thread and handles \"claim added\",\n// \"claim updated\" and \"periodic sync\" events.", "input": "go language", "output": "func (ctrl *PersistentVolumeController) updateClaim(claim *v1.PersistentVolumeClaim) {\n\t// Store the new claim version in the cache and do not process it if this is\n\t// an old version.\n\tnew, err := ctrl.storeClaimUpdate(claim)\n\tif err != nil {\n\t\tklog.Errorf(\"%v\", err)\n\t}\n\tif !new {\n\t\treturn\n\t}\n\terr = ctrl.syncClaim(claim)\n\tif err != nil {\n\t\tif errors.IsConflict(err) {\n\t\t\t// Version conflict error happens quite often and the controller\n\t\t\t// recovers from it easily.\n\t\t\tklog.V(3).Infof(\"could not sync claim %q: %+v\", claimToClaimKey(claim), err)\n\t\t} else {\n\t\t\tklog.Errorf(\"could not sync volume %q: %+v\", claimToClaimKey(claim), err)\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// extractJoinGroup extracts all the join nodes connected with continuous\n// InnerJoins to construct a join group. This join group is further used to\n// construct a new join order based on a reorder algorithm.\n//\n// For example: \"InnerJoin(InnerJoin(a, b), LeftJoin(c, d))\"\n// results in a join group {a, b, LeftJoin(c, d)}.", "input": "go language", "output": "func extractJoinGroup(p LogicalPlan) (group []LogicalPlan, eqEdges []*expression.ScalarFunction, otherConds []expression.Expression) {\n\tjoin, isJoin := p.(*LogicalJoin)\n\tif !isJoin || join.preferJoinType > uint(0) || join.JoinType != InnerJoin || join.StraightJoin {\n\t\treturn []LogicalPlan{p}, nil, nil\n\t}\n\n\tlhsGroup, lhsEqualConds, lhsOtherConds := extractJoinGroup(join.children[0])\n\trhsGroup, rhsEqualConds, rhsOtherConds := extractJoinGroup(join.children[1])\n\n\tgroup = append(group, lhsGroup...)\n\tgroup = append(group, rhsGroup...)\n\teqEdges = append(eqEdges, join.EqualConditions...)\n\teqEdges = append(eqEdges, lhsEqualConds...)\n\teqEdges = append(eqEdges, rhsEqualConds...)\n\totherConds = append(otherConds, join.OtherConditions...)\n\totherConds = append(otherConds, lhsOtherConds...)\n\totherConds = append(otherConds, rhsOtherConds...)\n\treturn group, eqEdges, otherConds\n}", "category": "Python"}, {"instruction": "// Attempt to decrypt, validate and unpack an asymmetrically encrypted message.\n// If successful, returns the unpacked whisper ReceivedMessage struct\n// encapsulating the decrypted message, and the byte representation of\n// the public key used to decrypt the message.\n// It fails if decryption of message fails, or if the message is corrupted.", "input": "go language", "output": "func (ks *Pss) processAsym(envelope *whisper.Envelope) (*whisper.ReceivedMessage, string, PssAddress, error) {\n\tmetrics.GetOrRegisterCounter(\"pss.process.asym\", nil).Inc(1)\n\n\trecvmsg, err := envelope.OpenAsymmetric(ks.privateKey)\n\tif err != nil {\n\t\treturn nil, \"\", nil, fmt.Errorf(\"could not decrypt message: %s\", err)\n\t}\n\t// check signature (if signed), strip padding\n\tif !recvmsg.ValidateAndParse() {\n\t\treturn nil, \"\", nil, errors.New(\"invalid message\")\n\t}\n\tpubkeyid := common.ToHex(crypto.FromECDSAPub(recvmsg.Src))\n\tvar from PssAddress\n\tks.mx.RLock()\n\tif ks.pubKeyPool[pubkeyid][Topic(envelope.Topic)] != nil {\n\t\tfrom = ks.pubKeyPool[pubkeyid][Topic(envelope.Topic)].address\n\t}\n\tks.mx.RUnlock()\n\treturn recvmsg, pubkeyid, from, nil\n}", "category": "Python"}, {"instruction": "\u6839\u636e\u6a21\u578b\u540d\u79f0\u83b7\u53d6crf\u6a21\u578b\n\n@param modelName\n@return", "input": "Java", "output": "public static StopRecognition get(String key) {\n        KV<String, StopRecognition> kv = STOP.get(key);\n\n        if (kv == null) {\n            if (MyStaticValue.ENV.containsKey(key)) {\n                putIfAbsent(key, MyStaticValue.ENV.get(key));\n                return get(key);\n            }\n            LOG.warn(\"STOP \" + key + \" not found in config \");\n            return null;\n        }\n        StopRecognition stopRecognition = kv.getV();\n        if (stopRecognition == null) {\n            stopRecognition = init(key, kv, false);\n        }\n        return stopRecognition;\n\n    }", "category": "Python"}, {"instruction": "Returns the details for the specified interconnect location. Gets a list of available\ninterconnect locations by making a list() request.\n\n<p>Sample code:\n\n<pre><code>\ntry (InterconnectLocationClient interconnectLocationClient = InterconnectLocationClient.create()) {\nProjectGlobalInterconnectLocationName interconnectLocation = ProjectGlobalInterconnectLocationName.of(\"[PROJECT]\", \"[INTERCONNECT_LOCATION]\");\nInterconnectLocation response = interconnectLocationClient.getInterconnectLocation(interconnectLocation);\n}\n</code></pre>\n\n@param interconnectLocation Name of the interconnect location to return.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final InterconnectLocation getInterconnectLocation(\n      ProjectGlobalInterconnectLocationName interconnectLocation) {\n\n    GetInterconnectLocationHttpRequest request =\n        GetInterconnectLocationHttpRequest.newBuilder()\n            .setInterconnectLocation(\n                interconnectLocation == null ? null : interconnectLocation.toString())\n            .build();\n    return getInterconnectLocation(request);\n  }", "category": "Python"}, {"instruction": "\u589e\u52a0\u4e00\u4e2a\u6bb5\u843d\n\n@param align \u6bb5\u843d\u5bf9\u9f50\u65b9\u5f0f{@link ParagraphAlignment}\n@param font \u5b57\u4f53\u4fe1\u606f{@link Font}\n@param texts \u6bb5\u843d\u4e2d\u7684\u6587\u672c\uff0c\u652f\u6301\u591a\u4e2a\u6587\u672c\u4f5c\u4e3a\u4e00\u4e2a\u6bb5\u843d\n@return this", "input": "Java", "output": "public Word07Writer addText(ParagraphAlignment align, Font font, String... texts) {\r\n\t\tfinal XWPFParagraph p = this.doc.createParagraph();\r\n\t\tif (null != align) {\r\n\t\t\tp.setAlignment(align);\r\n\t\t}\r\n\t\tif (ArrayUtil.isNotEmpty(texts)) {\r\n\t\t\tXWPFRun run;\r\n\t\t\tfor (String text : texts) {\r\n\t\t\t\trun = p.createRun();\r\n\t\t\t\trun.setText(text);\r\n\t\t\t\tif (null != font) {\r\n\t\t\t\t\trun.setFontFamily(font.getFamily());\r\n\t\t\t\t\trun.setFontSize(font.getSize());\r\n\t\t\t\t\trun.setBold(font.isBold());\r\n\t\t\t\t\trun.setItalic(font.isItalic());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}", "category": "Python"}, {"instruction": "Create registered service public key defined.\n\n@param registeredService the registered service\n@return the public key", "input": "Java", "output": "private static PublicKey createRegisteredServicePublicKey(final RegisteredService registeredService) {\n        if (registeredService.getPublicKey() == null) {\n            LOGGER.debug(\"No public key is defined for service [{}]. No encoding will take place.\", registeredService);\n            return null;\n        }\n        val publicKey = registeredService.getPublicKey().createInstance();\n        if (publicKey == null) {\n            LOGGER.debug(\"No public key instance created for service [{}]. No encoding will take place.\", registeredService);\n            return null;\n        }\n        return publicKey;\n    }", "category": "Python"}, {"instruction": "Decodes the specified region of the buffer into an unadjusted frame length.  The default implementation is\ncapable of decoding the specified region into an unsigned 8/16/24/32/64 bit integer.  Override this method to\ndecode the length field encoded differently.  Note that this method must not modify the state of the specified\nbuffer (e.g. {@code readerIndex}, {@code writerIndex}, and the content of the buffer.)\n\n@throws DecoderException if failed to decode the specified region", "input": "Java", "output": "protected long getUnadjustedFrameLength(ByteBuf buf, int offset, int length, ByteOrder order) {\n        buf = buf.order(order);\n        long frameLength;\n        switch (length) {\n        case 1:\n            frameLength = buf.getUnsignedByte(offset);\n            break;\n        case 2:\n            frameLength = buf.getUnsignedShort(offset);\n            break;\n        case 3:\n            frameLength = buf.getUnsignedMedium(offset);\n            break;\n        case 4:\n            frameLength = buf.getUnsignedInt(offset);\n            break;\n        case 8:\n            frameLength = buf.getLong(offset);\n            break;\n        default:\n            throw new DecoderException(\n                    \"unsupported lengthFieldLength: \" + lengthFieldLength + \" (expected: 1, 2, 3, 4, or 8)\");\n        }\n        return frameLength;\n    }", "category": "Python"}, {"instruction": "Build saml assertion assertion.\n\n@param authnRequest   the authn request\n@param request        the request\n@param response       the response\n@param casAssertion   the cas assertion\n@param service        the service\n@param adaptor        the adaptor\n@param binding        the binding\n@param messageContext the message context\n@return the assertion", "input": "Java", "output": "protected Assertion buildSamlAssertion(final RequestAbstractType authnRequest,\n                                           final HttpServletRequest request,\n                                           final HttpServletResponse response,\n                                           final Object casAssertion,\n                                           final SamlRegisteredService service,\n                                           final SamlRegisteredServiceServiceProviderMetadataFacade adaptor,\n                                           final String binding,\n                                           final MessageContext messageContext) {\n        return samlResponseBuilderConfigurationContext.getSamlProfileSamlAssertionBuilder()\n            .build(authnRequest, request, response, casAssertion, service, adaptor, binding, messageContext);\n    }", "category": "Python"}, {"instruction": "A convenience method that performs click-and-hold at the location of the source element,\nmoves by a given offset, then releases the mouse.\n\n@param source element to emulate button down at.\n@param xOffset horizontal move offset.\n@param yOffset vertical move offset.\n@return A self reference.", "input": "Java", "output": "public Actions dragAndDropBy(WebElement source, int xOffset, int yOffset) {\n    if (isBuildingActions()) {\n      action.addAction(new ClickAndHoldAction(jsonMouse, (Locatable) source));\n      action.addAction(new MoveToOffsetAction(jsonMouse, null, xOffset, yOffset));\n      action.addAction(new ButtonReleaseAction(jsonMouse, null));\n    }\n\n    return moveInTicks(source, 0, 0)\n        .tick(defaultMouse.createPointerDown(LEFT.asArg()))\n        .tick(defaultMouse.createPointerMove(Duration.ofMillis(250), Origin.pointer(), xOffset, yOffset))\n        .tick(defaultMouse.createPointerUp(LEFT.asArg()));\n  }", "category": "Python"}, {"instruction": "// Set associates key with value.", "input": "go language", "output": "func (m *memDbBuffer) Set(k Key, v []byte) error {\n\tif len(v) == 0 {\n\t\treturn errors.Trace(ErrCannotSetNilValue)\n\t}\n\tif len(k)+len(v) > m.entrySizeLimit {\n\t\treturn ErrEntryTooLarge.GenWithStackByArgs(m.entrySizeLimit, len(k)+len(v))\n\t}\n\n\terr := m.db.Put(k, v)\n\tif m.Size() > m.bufferSizeLimit {\n\t\treturn ErrTxnTooLarge.GenWithStack(\"transaction too large, size:%d\", m.Size())\n\t}\n\tif m.Len() > int(m.bufferLenLimit) {\n\t\treturn ErrTxnTooLarge.GenWithStack(\"transaction too large, len:%d\", m.Len())\n\t}\n\treturn errors.Trace(err)\n}", "category": "Python"}, {"instruction": "Overrides unsupported type conversions/mappings specified by the user.\n@param vec byte vec holding bin\\ary parquet data\n@param requestedTypes user-specified target types\n@return corrected types", "input": "Java", "output": "public static byte[] correctTypeConversions(ByteVec vec, byte[] requestedTypes) {\n    byte[] metadataBytes = VecParquetReader.readFooterAsBytes(vec);\n    ParquetMetadata metadata = VecParquetReader.readFooter(metadataBytes, ParquetMetadataConverter.NO_FILTER);\n    byte[] roughTypes = roughGuessTypes(metadata.getFileMetaData().getSchema());\n    return correctTypeConversions(roughTypes, requestedTypes);\n  }", "category": "Python"}, {"instruction": "Sort the given range of items using quick sort. {@inheritDoc} If the recursion depth falls below\n{@link #getMaxDepth}, then switch to {@link HeapSort}.", "input": "Java", "output": "public void sort(final IndexedSortable s, int p, int r) {\n\t\tint recordsPerSegment = s.recordsPerSegment();\n\t\tint recordSize = s.recordSize();\n\t\tint maxOffset = recordSize * (recordsPerSegment - 1);\n\n\t\tint pN = p / recordsPerSegment;\n\t\tint pO = (p % recordsPerSegment) * recordSize;\n\n\t\tint rN = r / recordsPerSegment;\n\t\tint rO = (r % recordsPerSegment) * recordSize;\n\n\t\tsortInternal(s, recordsPerSegment, recordSize, maxOffset, p, pN, pO, r, rN, rO, getMaxDepth(r - p));\n\t}", "category": "Python"}, {"instruction": "Sets the named ports for the specified instance group.\n\n<p>Sample code:\n\n<pre><code>\ntry (InstanceGroupClient instanceGroupClient = InstanceGroupClient.create()) {\nProjectZoneInstanceGroupName instanceGroup = ProjectZoneInstanceGroupName.of(\"[PROJECT]\", \"[ZONE]\", \"[INSTANCE_GROUP]\");\nInstanceGroupsSetNamedPortsRequest instanceGroupsSetNamedPortsRequestResource = InstanceGroupsSetNamedPortsRequest.newBuilder().build();\nOperation response = instanceGroupClient.setNamedPortsInstanceGroup(instanceGroup, instanceGroupsSetNamedPortsRequestResource);\n}\n</code></pre>\n\n@param instanceGroup The name of the instance group where the named ports are updated.\n@param instanceGroupsSetNamedPortsRequestResource\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation setNamedPortsInstanceGroup(\n      ProjectZoneInstanceGroupName instanceGroup,\n      InstanceGroupsSetNamedPortsRequest instanceGroupsSetNamedPortsRequestResource) {\n\n    SetNamedPortsInstanceGroupHttpRequest request =\n        SetNamedPortsInstanceGroupHttpRequest.newBuilder()\n            .setInstanceGroup(instanceGroup == null ? null : instanceGroup.toString())\n            .setInstanceGroupsSetNamedPortsRequestResource(\n                instanceGroupsSetNamedPortsRequestResource)\n            .build();\n    return setNamedPortsInstanceGroup(request);\n  }", "category": "Python"}, {"instruction": "This method returns intersection point of shape border and line.\n@param shape\n@param line\n@return Point", "input": "Java", "output": "private static Point getIntersection(Shape shape,\n                                         Line2D.Double line) {\n        if (shape instanceof Ellipse2D) {\n            return getEllipseIntersection(shape,\n                                          line);\n        } else if (shape instanceof Rectangle2D || shape instanceof Path2D) {\n            return getShapeIntersection(shape,\n                                        line);\n        } else {\n            // something strange\n            return null;\n        }\n    }", "category": "Python"}, {"instruction": "Adds a reference to a section of the http data. Should only\nbe called after data has been added to the underlying http data.\n\n@param onError A consumer to call if an IOException occurs\n@return The newly added component, or null if an error occurred", "input": "Java", "output": "Component addComponent(Consumer<IOException> onError) {\n        Component component;\n        try {\n            long readable = readableBytes(data);\n            long offset = position.getAndUpdate(p -> readable);\n            int length = new Long(readable - offset).intValue();\n            component = new Component(length, offset);\n            components.add(component);\n        } catch (IOException e) {\n            onError.accept(e);\n            return null;\n        }\n\n        if (!data.isInMemory()) {\n            fileAccess.getAndUpdate(channel -> {\n                if (channel == null) {\n                    try {\n                        return new RandomAccessFile(data.getFile(), \"r\");\n                    } catch (IOException e) {\n                        onError.accept(e);\n                    }\n                }\n                return channel;\n            });\n        }\n\n        return component;\n    }", "category": "Python"}, {"instruction": "bits\u8f6cbytes\n\n@param bits \u4e8c\u8fdb\u5236\n@return bytes", "input": "Java", "output": "public static byte[] bits2Bytes(String bits) {\n        int lenMod  = bits.length() % 8;\n        int byteLen = bits.length() / 8;\n        // \u4e0d\u662f8\u7684\u500d\u6570\u524d\u9762\u88650\n        if (lenMod != 0) {\n            for (int i = lenMod; i < 8; i++) {\n                bits = \"0\" + bits;\n            }\n            byteLen++;\n        }\n        byte[] bytes = new byte[byteLen];\n        for (int i = 0; i < byteLen; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                bytes[i] <<= 1;\n                bytes[i] |= bits.charAt(i * 8 + j) - '0';\n            }\n        }\n        return bytes;\n    }", "category": "Python"}, {"instruction": "Copy the values of an {@link Iterator} to the target {@link CallStreamObserver} while properly\naccounting for outbound flow-control.  After calling this method, {@code target} should no\nlonger be used.\n\n<p>For clients this method is safe to call inside {@link ClientResponseObserver#beforeStart},\non servers it is safe to call inside the service method implementation.\n</p>\n\n@param source of values expressed as an {@link Iterator}.\n@param target {@link CallStreamObserver} which accepts values from the source.", "input": "Java", "output": "public static <V> void copyWithFlowControl(final Iterator<V> source,\n      final CallStreamObserver<V> target) {\n    Preconditions.checkNotNull(source, \"source\");\n    Preconditions.checkNotNull(target, \"target\");\n\n    final class FlowControllingOnReadyHandler implements Runnable {\n      private boolean completed;\n\n      @Override\n      public void run() {\n        if (completed) {\n          return;\n        }\n\n        while (target.isReady() && source.hasNext()) {\n          target.onNext(source.next());\n        }\n\n        if (!source.hasNext()) {\n          completed = true;\n          target.onCompleted();\n        }\n      }\n    }\n\n    target.setOnReadyHandler(new FlowControllingOnReadyHandler());\n  }", "category": "Python"}, {"instruction": "Notify all the handshake futures about the successfully handshake", "input": "Java", "output": "private void setHandshakeSuccess() {\n        handshakePromise.trySuccess(ctx.channel());\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"{} HANDSHAKEN: {}\", ctx.channel(), engine.getSession().getCipherSuite());\n        }\n        ctx.fireUserEventTriggered(SslHandshakeCompletionEvent.SUCCESS);\n\n        if (readDuringHandshake && !ctx.channel().config().isAutoRead()) {\n            readDuringHandshake = false;\n            ctx.read();\n        }\n    }", "category": "Python"}, {"instruction": "necessary different) mode, and then a code.", "input": "Java", "output": "State latchAndAppend(int mode, int value) {\n    //assert binaryShiftByteCount == 0;\n    int bitCount = this.bitCount;\n    Token token = this.token;\n    if (mode != this.mode) {\n      int latch = HighLevelEncoder.LATCH_TABLE[this.mode][mode];\n      token = token.add(latch & 0xFFFF, latch >> 16);\n      bitCount += latch >> 16;\n    }\n    int latchModeBitCount = mode == HighLevelEncoder.MODE_DIGIT ? 4 : 5;\n    token = token.add(value, latchModeBitCount);\n    return new State(token, mode, 0, bitCount + latchModeBitCount);\n  }", "category": "Python"}, {"instruction": "Changes the icon size by changing the cookie", "input": "Java", "output": "public void doIconSize( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        String qs = req.getQueryString();\n        if(qs==null)\n            throw new ServletException();\n        Cookie cookie = new Cookie(\"iconSize\", Functions.validateIconSize(qs));\n        cookie.setMaxAge(/* ~4 mo. */9999999); // #762\n        rsp.addCookie(cookie);\n        String ref = req.getHeader(\"Referer\");\n        if(ref==null)   ref=\".\";\n        rsp.sendRedirect2(ref);\n    }", "category": "Python"}, {"instruction": "Example of running a query with the cache disabled.", "input": "Java", "output": "public void runUncachedQuery() throws TimeoutException, InterruptedException {\n    // [START bigquery_query_no_cache]\n    // BigQuery bigquery = BigQueryOptions.getDefaultInstance().getService();\n    String query = \"SELECT corpus FROM `bigquery-public-data.samples.shakespeare` GROUP BY corpus;\";\n    QueryJobConfiguration queryConfig =\n        QueryJobConfiguration.newBuilder(query)\n            // Disable the query cache to force live query evaluation.\n            .setUseQueryCache(false)\n            .build();\n\n    // Print the results.\n    for (FieldValueList row : bigquery.query(queryConfig).iterateAll()) {\n      for (FieldValue val : row) {\n        System.out.printf(\"%s,\", val.toString());\n      }\n      System.out.printf(\"\\n\");\n    }\n    // [END bigquery_query_no_cache]\n  }", "category": "Python"}, {"instruction": "Returns the name(s) of the outputs for the given function\n\n@param function the function to get the outputs for\n@return the outputs ids for a given function", "input": "Java", "output": "public String[] getOutputsForFunction(DifferentialFunction function) {\n        if (!ops.containsKey(function.getOwnName()))\n            throw new ND4JIllegalStateException(\"Illegal function instance id found \" + function.getOwnName());\n        List<String> outputs = ops.get(function.getOwnName()).getOutputsOfOp();\n        return outputs == null ? null : outputs.toArray(new String[outputs.size()]);\n    }", "category": "Python"}, {"instruction": "Creates a new {@link NameResolver}. Override this method to create an alternative {@link NameResolver}\nimplementation or override the default configuration.", "input": "Java", "output": "protected NameResolver<InetAddress> newNameResolver(EventLoop eventLoop,\n                                                        ChannelFactory<? extends DatagramChannel> channelFactory,\n                                                        DnsServerAddressStreamProvider nameServerProvider)\n            throws Exception {\n        // once again, channelFactory and nameServerProvider are most probably set in builder already,\n        // but I do reassign them again to avoid corner cases with override methods\n        return dnsResolverBuilder.eventLoop(eventLoop)\n                .channelFactory(channelFactory)\n                .nameServerProvider(nameServerProvider)\n                .build();\n    }", "category": "Python"}, {"instruction": "Method used to setup the toolbar elements. Should not usually be overriden. Instead, use the\n{@link #addToolBarElements(JToolBar, short, int)} method to add elements at various points.\n@param toolbar the tool bar of the status panel", "input": "Java", "output": "protected void setupToolbarElements(JToolBar toolbar) {\n\t\tint x = 0;\n\t\tInsets insets = new Insets(0, 4, 0, 2);\n\n\t\tx = this.addToolBarElements(toolbar, TOOLBAR_LOCATION_START, x);\n\n\t\ttoolbar.add(new JLabel(Constant.messages.getString(panelPrefix + \".toolbar.context.label\")),\n\t\t\t\tLayoutHelper.getGBC(x++, 0, 1, 0, insets));\n\t\ttoolbar.add(getContextSelectComboBox(), LayoutHelper.getGBC(x++, 0, 1, 0, insets));\n\n\t\tx = this.addToolBarElements(toolbar, TOOLBAR_LOCATION_AFTER_CONTEXTS_SELECT, x);\n\n\t\ttoolbar.add(new JLabel(), LayoutHelper.getGBC(x++, 0, 1, 1.0)); // Spacer\n\t\tif (hasOptions()) {\n\t\t\ttoolbar.add(getOptionsButton(), LayoutHelper.getGBC(x++, 0, 1, 0, insets));\n\t\t}\n\n\t\tthis.addToolBarElements(toolbar, TOOLBAR_LOCATION_END, x);\n\t}", "category": "Python"}, {"instruction": "Set the {@link TaskExecutorCustomizer TaskExecutorCustomizers} that should be\napplied to the {@link ThreadPoolTaskExecutor}. Customizers are applied in the order\nthat they were added after builder configuration has been applied. Setting this\nvalue will replace any previously configured customizers.\n@param customizers the customizers to set\n@return a new builder instance\n@see #additionalCustomizers(TaskExecutorCustomizer...)", "input": "Java", "output": "public TaskExecutorBuilder customizers(Iterable<TaskExecutorCustomizer> customizers) {\n\t\tAssert.notNull(customizers, \"Customizers must not be null\");\n\t\treturn new TaskExecutorBuilder(this.queueCapacity, this.corePoolSize,\n\t\t\t\tthis.maxPoolSize, this.allowCoreThreadTimeOut, this.keepAlive,\n\t\t\t\tthis.awaitTermination, this.awaitTerminationPeriod, this.threadNamePrefix,\n\t\t\t\tthis.taskDecorator, append(null, customizers));\n\t}", "category": "Python"}, {"instruction": "// ValidateAvoidPodsInNodeAnnotations tests that the serialized AvoidPods in Node.Annotations has valid data", "input": "go language", "output": "func ValidateAvoidPodsInNodeAnnotations(annotations map[string]string, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\n\tv1Avoids, err := v1helper.GetAvoidPodsFromNodeAnnotations(annotations)\n\tif err != nil {\n\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"AvoidPods\"), core.PreferAvoidPodsAnnotationKey, err.Error()))\n\t\treturn allErrs\n\t}\n\tvar avoids core.AvoidPods\n\tif err := corev1.Convert_v1_AvoidPods_To_core_AvoidPods(&v1Avoids, &avoids, nil); err != nil {\n\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"AvoidPods\"), core.PreferAvoidPodsAnnotationKey, err.Error()))\n\t\treturn allErrs\n\t}\n\n\tif len(avoids.PreferAvoidPods) != 0 {\n\t\tfor i, pa := range avoids.PreferAvoidPods {\n\t\t\tidxPath := fldPath.Child(core.PreferAvoidPodsAnnotationKey).Index(i)\n\t\t\tallErrs = append(allErrs, validatePreferAvoidPodsEntry(pa, idxPath)...)\n\t\t}\n\t}\n\n\treturn allErrs\n}", "category": "Python"}, {"instruction": "// NewWindowFuncDesc creates a window function signature descriptor.", "input": "go language", "output": "func NewWindowFuncDesc(ctx sessionctx.Context, name string, args []expression.Expression) *WindowFuncDesc {\n\tswitch strings.ToLower(name) {\n\tcase ast.WindowFuncNthValue:\n\t\tval, isNull, ok := expression.GetUint64FromConstant(args[1])\n\t\t// nth_value does not allow `0`, but allows `null`.\n\t\tif !ok || (val == 0 && !isNull) {\n\t\t\treturn nil\n\t\t}\n\tcase ast.WindowFuncNtile:\n\t\tval, isNull, ok := expression.GetUint64FromConstant(args[0])\n\t\t// ntile does not allow `0`, but allows `null`.\n\t\tif !ok || (val == 0 && !isNull) {\n\t\t\treturn nil\n\t\t}\n\tcase ast.WindowFuncLead, ast.WindowFuncLag:\n\t\tif len(args) < 2 {\n\t\t\tbreak\n\t\t}\n\t\t_, isNull, ok := expression.GetUint64FromConstant(args[1])\n\t\tif !ok || isNull {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn &WindowFuncDesc{newBaseFuncDesc(ctx, name, args)}\n}", "category": "Python"}, {"instruction": "// NewServerTimeout returns an error indicating the requested action could not be completed due to a\n// transient error, and the client should try again.", "input": "go language", "output": "func NewServerTimeout(qualifiedResource schema.GroupResource, operation string, retryAfterSeconds int) *StatusError {\n\treturn &StatusError{metav1.Status{\n\t\tStatus: metav1.StatusFailure,\n\t\tCode:   http.StatusInternalServerError,\n\t\tReason: metav1.StatusReasonServerTimeout,\n\t\tDetails: &metav1.StatusDetails{\n\t\t\tGroup:             qualifiedResource.Group,\n\t\t\tKind:              qualifiedResource.Resource,\n\t\t\tName:              operation,\n\t\t\tRetryAfterSeconds: int32(retryAfterSeconds),\n\t\t},\n\t\tMessage: fmt.Sprintf(\"The %s operation against %s could not be completed at this time, please try again.\", operation, qualifiedResource.String()),\n\t}}\n}", "category": "Python"}, {"instruction": "// determineSubnetURL queries for all subnetworks in a region for a given network and returns\n// the URL of the subnetwork which exists in the auto-subnet range.", "input": "go language", "output": "func determineSubnetURL(service *compute.Service, networkProjectID, networkName, region string) (string, error) {\n\tsubnets, err := listSubnetworksOfNetwork(service, networkProjectID, networkName, region)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tautoSubnets, err := subnetsInCIDR(subnets, autoSubnetIPRange)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif len(autoSubnets) == 0 {\n\t\treturn \"\", fmt.Errorf(\"no subnet exists in auto CIDR\")\n\t}\n\n\tif len(autoSubnets) > 1 {\n\t\treturn \"\", fmt.Errorf(\"multiple subnetworks in the same region exist in auto CIDR\")\n\t}\n\n\treturn autoSubnets[0].SelfLink, nil\n}", "category": "Python"}, {"instruction": "// EnsureLoadBalancer is a test-spy implementation of LoadBalancer.EnsureLoadBalancer.\n// It adds an entry \"create\" into the internal method call record.", "input": "go language", "output": "func (f *FakeCloud) EnsureLoadBalancer(ctx context.Context, clusterName string, service *v1.Service, nodes []*v1.Node) (*v1.LoadBalancerStatus, error) {\n\tf.addCall(\"create\")\n\tif f.Balancers == nil {\n\t\tf.Balancers = make(map[string]FakeBalancer)\n\t}\n\n\tname := f.GetLoadBalancerName(ctx, clusterName, service)\n\tspec := service.Spec\n\n\tzone, err := f.GetZone(context.TODO())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tregion := zone.Region\n\n\tf.Balancers[name] = FakeBalancer{name, region, spec.LoadBalancerIP, spec.Ports, nodes}\n\n\tstatus := &v1.LoadBalancerStatus{}\n\tstatus.Ingress = []v1.LoadBalancerIngress{{IP: f.ExternalIP.String()}}\n\n\treturn status, f.Err\n}", "category": "Python"}, {"instruction": "// Verify verifies a signed GossipMessage with a given Verifier.\n// Returns nil on success, error on failure.", "input": "go language", "output": "func (m *SignedGossipMessage) Verify(peerIdentity []byte, verify Verifier) error {\n\tif m.Envelope == nil {\n\t\treturn errors.New(\"Missing envelope\")\n\t}\n\tif len(m.Envelope.Payload) == 0 {\n\t\treturn errors.New(\"Empty payload\")\n\t}\n\tif len(m.Envelope.Signature) == 0 {\n\t\treturn errors.New(\"Empty signature\")\n\t}\n\tpayloadSigVerificationErr := verify(peerIdentity, m.Envelope.Signature, m.Envelope.Payload)\n\tif payloadSigVerificationErr != nil {\n\t\treturn payloadSigVerificationErr\n\t}\n\tif m.Envelope.SecretEnvelope != nil {\n\t\tpayload := m.Envelope.SecretEnvelope.Payload\n\t\tsig := m.Envelope.SecretEnvelope.Signature\n\t\tif len(payload) == 0 {\n\t\t\treturn errors.New(\"Empty payload\")\n\t\t}\n\t\tif len(sig) == 0 {\n\t\t\treturn errors.New(\"Empty signature\")\n\t\t}\n\t\treturn verify(peerIdentity, sig, payload)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// RetrieveValidatedConfigInfo connects to the API Server and makes sure it can talk\n// securely to the API Server using the provided CA cert and\n// optionally refreshes the cluster-info information from the cluster-info ConfigMap", "input": "go language", "output": "func RetrieveValidatedConfigInfo(httpsURL, clustername string) (*clientcmdapi.Config, error) {\n\tclient := &http.Client{Transport: netutil.SetOldTransportDefaults(&http.Transport{})}\n\tresponse, err := client.Get(httpsURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\n\tkubeconfig, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tconfig, err := clientcmd.Load(kubeconfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn file.ValidateConfigInfo(config, clustername)\n}", "category": "Python"}, {"instruction": "// AddWork adds a work to the WorkerQueue which will be executed not earlier than `fireAt`.", "input": "go language", "output": "func (q *TimedWorkerQueue) AddWork(args *WorkArgs, createdAt time.Time, fireAt time.Time) {\n\tkey := args.KeyFromWorkArgs()\n\tklog.V(4).Infof(\"Adding TimedWorkerQueue item %v at %v to be fired at %v\", key, createdAt, fireAt)\n\n\tq.Lock()\n\tdefer q.Unlock()\n\tif _, exists := q.workers[key]; exists {\n\t\tklog.Warningf(\"Trying to add already existing work for %+v. Skipping.\", args)\n\t\treturn\n\t}\n\tworker := CreateWorker(args, createdAt, fireAt, q.getWrappedWorkerFunc(key))\n\tq.workers[key] = worker\n}", "category": "Python"}, {"instruction": "// convertToRuntimeCapabilities converts v1.Capabilities to runtimeapi.Capability.", "input": "go language", "output": "func convertToRuntimeCapabilities(opts *v1.Capabilities) *runtimeapi.Capability {\n\tif opts == nil {\n\t\treturn nil\n\t}\n\n\tcapabilities := &runtimeapi.Capability{\n\t\tAddCapabilities:  make([]string, len(opts.Add)),\n\t\tDropCapabilities: make([]string, len(opts.Drop)),\n\t}\n\tfor index, value := range opts.Add {\n\t\tcapabilities.AddCapabilities[index] = string(value)\n\t}\n\tfor index, value := range opts.Drop {\n\t\tcapabilities.DropCapabilities[index] = string(value)\n\t}\n\n\treturn capabilities\n}", "category": "Python"}, {"instruction": "// ValidateTopologySelectorTerm tests that the specified topology selector term has valid data,\n// and constructs a map representing the term in raw form.", "input": "go language", "output": "func ValidateTopologySelectorTerm(term core.TopologySelectorTerm, fldPath *field.Path) (map[string]sets.String, field.ErrorList) {\n\tallErrs := field.ErrorList{}\n\texprMap := make(map[string]sets.String)\n\texprPath := fldPath.Child(\"matchLabelExpressions\")\n\n\t// Allow empty MatchLabelExpressions, in case this field becomes optional in the future.\n\tfor i, req := range term.MatchLabelExpressions {\n\t\tidxPath := exprPath.Index(i)\n\t\tvalueSet, exprErrs := validateTopologySelectorLabelRequirement(req, idxPath)\n\t\tallErrs = append(allErrs, exprErrs...)\n\n\t\t// Validate no duplicate keys exist.\n\t\tif _, exists := exprMap[req.Key]; exists {\n\t\t\tallErrs = append(allErrs, field.Duplicate(idxPath.Child(\"key\"), req.Key))\n\t\t}\n\t\texprMap[req.Key] = valueSet\n\t}\n\n\treturn exprMap, allErrs\n}", "category": "Python"}, {"instruction": "// normalizePortPortion attempts to normalize the \"port portion\" of a hostname,\n// which begins with the first colon in the hostname and should be followed\n// by a string of decimal digits.\n//\n// If the port portion is valid, a normalized version of it is returned along\n// with a nil error.\n//\n// If the port portion is invalid, the input string is returned verbatim along\n// with a non-nil error.\n//\n// An empty string is a valid port portion representing the absense of a port.\n// If non-empty, the first character must be a colon.", "input": "go language", "output": "func normalizePortPortion(s string) (string, error) {\n\tif s == \"\" {\n\t\treturn s, nil\n\t}\n\n\tif s[0] != ':' {\n\t\t// should never happen, since caller tends to guarantee the presence\n\t\t// of a colon due to how it's extracted from the string.\n\t\treturn s, errors.New(\"port portion is missing its initial colon\")\n\t}\n\n\tnumStr := s[1:]\n\tnum, err := strconv.Atoi(numStr)\n\tif err != nil {\n\t\treturn s, errors.New(\"port portion contains non-digit characters\")\n\t}\n\tif num == 443 {\n\t\treturn \"\", nil // \":443\" is the default\n\t}\n\tif num > 65535 {\n\t\treturn s, errors.New(\"port number is greater than 65535\")\n\t}\n\treturn fmt.Sprintf(\":%d\", num), nil\n}", "category": "Python"}, {"instruction": "// Write sends the buffer to the underneath writer.\n// It inserts the prefix header before the buffer,\n// so stdcopy.StdCopy knows where to multiplex the output.\n// It makes stdWriter to implement io.Writer.", "input": "go language", "output": "func (w *stdWriter) Write(p []byte) (n int, err error) {\n\tif w == nil || w.Writer == nil {\n\t\treturn 0, errors.New(\"Writer not instantiated\")\n\t}\n\tif p == nil {\n\t\treturn 0, nil\n\t}\n\n\theader := [stdWriterPrefixLen]byte{stdWriterFdIndex: w.prefix}\n\tbinary.BigEndian.PutUint32(header[stdWriterSizeIndex:], uint32(len(p)))\n\tbuf := bufPool.Get().(*bytes.Buffer)\n\tbuf.Write(header[:])\n\tbuf.Write(p)\n\n\tn, err = w.Writer.Write(buf.Bytes())\n\tn -= stdWriterPrefixLen\n\tif n < 0 {\n\t\tn = 0\n\t}\n\n\tbuf.Reset()\n\tbufPool.Put(buf)\n\treturn\n}", "category": "Python"}, {"instruction": "// Open initializes the secure channel.", "input": "go language", "output": "func (s *SecureChannelSession) Open() error {\n\tif s.iv != nil {\n\t\treturn fmt.Errorf(\"Session already opened\")\n\t}\n\n\tresponse, err := s.open()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Generate the encryption/mac key by hashing our shared secret,\n\t// pairing key, and the first bytes returned from the Open APDU.\n\tmd := sha512.New()\n\tmd.Write(s.secret)\n\tmd.Write(s.PairingKey)\n\tmd.Write(response.Data[:scSecretLength])\n\tkeyData := md.Sum(nil)\n\ts.sessionEncKey = keyData[:scSecretLength]\n\ts.sessionMacKey = keyData[scSecretLength : scSecretLength*2]\n\n\t// The IV is the last bytes returned from the Open APDU.\n\ts.iv = response.Data[scSecretLength:]\n\n\treturn s.mutuallyAuthenticate()\n}", "category": "Python"}, {"instruction": "// adds a symmetric key to the pss key pool, and optionally adds the key to the\n// collection of keys used to attempt symmetric decryption of incoming messages", "input": "go language", "output": "func (ks *KeyStore) addSymmetricKeyToPool(keyid string, topic Topic, address PssAddress, addtocache bool, protected bool) {\n\tpsp := &pssPeer{\n\t\taddress:   address,\n\t\tprotected: protected,\n\t}\n\tks.mx.Lock()\n\tif _, ok := ks.symKeyPool[keyid]; !ok {\n\t\tks.symKeyPool[keyid] = make(map[Topic]*pssPeer)\n\t}\n\tks.symKeyPool[keyid][topic] = psp\n\tks.mx.Unlock()\n\tif addtocache {\n\t\tks.symKeyDecryptCacheCursor++\n\t\tks.symKeyDecryptCache[ks.symKeyDecryptCacheCursor%cap(ks.symKeyDecryptCache)] = &keyid\n\t}\n}", "category": "Python"}, {"instruction": "// Config return a cloud controller manager config objective", "input": "go language", "output": "func (o *CloudControllerManagerOptions) Config(allControllers, disabledByDefaultControllers []string) (*cloudcontrollerconfig.Config, error) {\n\tif err := o.Validate(allControllers, disabledByDefaultControllers); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := o.SecureServing.MaybeDefaultWithSelfSignedCerts(\"localhost\", nil, []net.IP{net.ParseIP(\"127.0.0.1\")}); err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating self-signed certificates: %v\", err)\n\t}\n\n\tc := &cloudcontrollerconfig.Config{}\n\tif err := o.ApplyTo(c, CloudControllerManagerUserAgent); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn c, nil\n}", "category": "Python"}, {"instruction": "// CalculatePatch calls the mutation function on the provided info object, and generates a strategic merge patch for\n// the changes in the object. Encoder must be able to encode the info into the appropriate destination type.\n// This function returns whether the mutation function made any change in the original object.", "input": "go language", "output": "func CalculatePatch(patch *Patch, encoder runtime.Encoder, mutateFn PatchFn) bool {\n\tpatch.Before, patch.Err = runtime.Encode(encoder, patch.Info.Object)\n\tpatch.After, patch.Err = mutateFn(patch.Info.Object)\n\tif patch.Err != nil {\n\t\treturn true\n\t}\n\tif patch.After == nil {\n\t\treturn false\n\t}\n\n\tpatch.Patch, patch.Err = strategicpatch.CreateTwoWayMergePatch(patch.Before, patch.After, patch.Info.Object)\n\treturn true\n}", "category": "Python"}, {"instruction": "// AsCanonicalBytes accepts a buffer to write the base-10 string value of this field to, and returns\n// either that buffer or a larger buffer and the current exponent of the value. The value is adjusted\n// until the exponent is a multiple of 3 - i.e. 1.1e5 would return \"110\", 3.", "input": "go language", "output": "func (a int64Amount) AsCanonicalBytes(out []byte) (result []byte, exponent int32) {\n\tmantissa := a.value\n\texponent = int32(a.scale)\n\n\tamount, times := removeInt64Factors(mantissa, 10)\n\texponent += int32(times)\n\n\t// make sure exponent is a multiple of 3\n\tvar ok bool\n\tswitch exponent % 3 {\n\tcase 1, -2:\n\t\tamount, ok = int64MultiplyScale10(amount)\n\t\tif !ok {\n\t\t\treturn infDecAmount{a.AsDec()}.AsCanonicalBytes(out)\n\t\t}\n\t\texponent = exponent - 1\n\tcase 2, -1:\n\t\tamount, ok = int64MultiplyScale100(amount)\n\t\tif !ok {\n\t\t\treturn infDecAmount{a.AsDec()}.AsCanonicalBytes(out)\n\t\t}\n\t\texponent = exponent - 2\n\t}\n\treturn strconv.AppendInt(out, amount, 10), exponent\n}", "category": "Python"}, {"instruction": "// locatePartition returns the partition ID of the input record.", "input": "go language", "output": "func (t *partitionedTable) locatePartition(ctx sessionctx.Context, pi *model.PartitionInfo, r []types.Datum) (int64, error) {\n\tvar err error\n\tvar idx int\n\tswitch t.meta.Partition.Type {\n\tcase model.PartitionTypeRange:\n\t\tidx, err = t.locateRangePartition(ctx, pi, r)\n\tcase model.PartitionTypeHash:\n\t\tidx, err = t.locateHashPartition(ctx, pi, r)\n\t}\n\tif err != nil {\n\t\treturn 0, errors.Trace(err)\n\t}\n\treturn pi.Definitions[idx].ID, nil\n}", "category": "Python"}, {"instruction": "// NewFilter creates a new filter and returns the filter id. It can be\n// used to retrieve logs when the state changes. This method cannot be\n// used to fetch logs that are already stored in the state.\n//\n// Default criteria for the from and to block are \"latest\".\n// Using \"latest\" as block number will return logs for mined blocks.\n// Using \"pending\" as block number returns logs for not yet mined (pending) blocks.\n// In case logs are removed (chain reorg) previously returned logs are returned\n// again but with the removed property set to true.\n//\n// In case \"fromBlock\" > \"toBlock\" an error is returned.\n//\n// https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_newfilter", "input": "go language", "output": "func (api *PublicFilterAPI) NewFilter(crit FilterCriteria) (rpc.ID, error) {\n\tlogs := make(chan []*types.Log)\n\tlogsSub, err := api.events.SubscribeLogs(ethereum.FilterQuery(crit), logs)\n\tif err != nil {\n\t\treturn rpc.ID(\"\"), err\n\t}\n\n\tapi.filtersMu.Lock()\n\tapi.filters[logsSub.ID] = &filter{typ: LogsSubscription, crit: crit, deadline: time.NewTimer(deadline), logs: make([]*types.Log, 0), s: logsSub}\n\tapi.filtersMu.Unlock()\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase l := <-logs:\n\t\t\t\tapi.filtersMu.Lock()\n\t\t\t\tif f, found := api.filters[logsSub.ID]; found {\n\t\t\t\t\tf.logs = append(f.logs, l...)\n\t\t\t\t}\n\t\t\t\tapi.filtersMu.Unlock()\n\t\t\tcase <-logsSub.Err():\n\t\t\t\tapi.filtersMu.Lock()\n\t\t\t\tdelete(api.filters, logsSub.ID)\n\t\t\t\tapi.filtersMu.Unlock()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn logsSub.ID, nil\n}", "category": "Python"}, {"instruction": "// This validate will make sure targetPath:\n// 1. is not abs path\n// 2. does not contain any '..' elements\n// 3. does not start with '..'", "input": "go language", "output": "func validateLocalNonReservedPath(targetPath string, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tallErrs = append(allErrs, validateLocalDescendingPath(targetPath, fldPath)...)\n\t// Don't report this error if the check for .. elements already caught it.\n\tif strings.HasPrefix(targetPath, \"..\") && !strings.HasPrefix(targetPath, \"../\") {\n\t\tallErrs = append(allErrs, field.Invalid(fldPath, targetPath, \"must not start with '..'\"))\n\t}\n\treturn allErrs\n}", "category": "Python"}, {"instruction": "// ListPredicate returns a list of all the items matching the given\n// SelectionPredicate.", "input": "go language", "output": "func (e *Store) ListPredicate(ctx context.Context, p storage.SelectionPredicate, options *metainternalversion.ListOptions) (runtime.Object, error) {\n\tif options == nil {\n\t\t// By default we should serve the request from etcd.\n\t\toptions = &metainternalversion.ListOptions{ResourceVersion: \"\"}\n\t}\n\tp.Limit = options.Limit\n\tp.Continue = options.Continue\n\tlist := e.NewListFunc()\n\tqualifiedResource := e.qualifiedResourceFromContext(ctx)\n\tif name, ok := p.MatchesSingle(); ok {\n\t\tif key, err := e.KeyFunc(ctx, name); err == nil {\n\t\t\terr := e.Storage.GetToList(ctx, key, options.ResourceVersion, p, list)\n\t\t\treturn list, storeerr.InterpretListError(err, qualifiedResource)\n\t\t}\n\t\t// if we cannot extract a key based on the current context, the optimization is skipped\n\t}\n\n\terr := e.Storage.List(ctx, e.KeyRootFunc(ctx), options.ResourceVersion, p, list)\n\treturn list, storeerr.InterpretListError(err, qualifiedResource)\n}", "category": "Python"}, {"instruction": "// RegisterDefaults adds defaulters functions to the given scheme.\n// Public to allow building arbitrary schemes.\n// All generated defaulters are covering - they call all nested defaulters.", "input": "go language", "output": "func RegisterDefaults(scheme *runtime.Scheme) error {\n\tscheme.AddTypeDefaultingFunc(&v1beta1.MutatingWebhookConfiguration{}, func(obj interface{}) {\n\t\tSetObjectDefaults_MutatingWebhookConfiguration(obj.(*v1beta1.MutatingWebhookConfiguration))\n\t})\n\tscheme.AddTypeDefaultingFunc(&v1beta1.MutatingWebhookConfigurationList{}, func(obj interface{}) {\n\t\tSetObjectDefaults_MutatingWebhookConfigurationList(obj.(*v1beta1.MutatingWebhookConfigurationList))\n\t})\n\tscheme.AddTypeDefaultingFunc(&v1beta1.ValidatingWebhookConfiguration{}, func(obj interface{}) {\n\t\tSetObjectDefaults_ValidatingWebhookConfiguration(obj.(*v1beta1.ValidatingWebhookConfiguration))\n\t})\n\tscheme.AddTypeDefaultingFunc(&v1beta1.ValidatingWebhookConfigurationList{}, func(obj interface{}) {\n\t\tSetObjectDefaults_ValidatingWebhookConfigurationList(obj.(*v1beta1.ValidatingWebhookConfigurationList))\n\t})\n\treturn nil\n}", "category": "Python"}, {"instruction": "// lockInfo reads the lock file, parses its contents and returns the parsed\n// LockInfo struct.", "input": "go language", "output": "func (c *remoteClient) lockInfo() (*state.LockInfo, error) {\n\tr, err := c.lockFile().NewReader(c.storageContext)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer r.Close()\n\n\trawData, err := ioutil.ReadAll(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tinfo := &state.LockInfo{}\n\tif err := json.Unmarshal(rawData, info); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We use the Generation as the ID, so overwrite the ID in the json.\n\t// This can't be written into the Info, since the generation isn't known\n\t// until it's written.\n\tattrs, err := c.lockFile().Attrs(c.storageContext)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tinfo.ID = strconv.FormatInt(attrs.Generation, 10)\n\n\treturn info, nil\n}", "category": "Python"}, {"instruction": "// NewStateSync create a new state trie download scheduler.", "input": "go language", "output": "func NewStateSync(root common.Hash, database ethdb.Reader) *trie.Sync {\n\tvar syncer *trie.Sync\n\tcallback := func(leaf []byte, parent common.Hash) error {\n\t\tvar obj Account\n\t\tif err := rlp.Decode(bytes.NewReader(leaf), &obj); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsyncer.AddSubTrie(obj.Root, 64, parent, nil)\n\t\tsyncer.AddRawEntry(common.BytesToHash(obj.CodeHash), 64, parent)\n\t\treturn nil\n\t}\n\tsyncer = trie.NewSync(root, database, callback)\n\treturn syncer\n}", "category": "Python"}, {"instruction": "// lanNodeJoin is used to handle join events on the LAN pool.", "input": "go language", "output": "func (s *Server) lanNodeJoin(me serf.MemberEvent) {\n\tfor _, m := range me.Members {\n\t\tok, serverMeta := metadata.IsConsulServer(m)\n\t\tif !ok || serverMeta.Segment != \"\" {\n\t\t\tcontinue\n\t\t}\n\t\ts.logger.Printf(\"[INFO] consul: Adding LAN server %s\", serverMeta)\n\n\t\t// Update server lookup\n\t\ts.serverLookup.AddServer(serverMeta)\n\n\t\t// If we're still expecting to bootstrap, may need to handle this.\n\t\tif s.config.BootstrapExpect != 0 {\n\t\t\ts.maybeBootstrap()\n\t\t}\n\n\t\t// Kick the join flooders.\n\t\ts.FloodNotify()\n\t}\n}", "category": "Python"}, {"instruction": "// parseRuncVersion parses the output of `runc --version` and extracts the\n// \"version\" and \"git commit\" from the output.\n//\n// Output example from `runc --version`:\n//\n//   runc version 1.0.0-rc5+dev\n//   commit: 69663f0bd4b60df09991c08812a60108003fa340\n//   spec: 1.0.0", "input": "go language", "output": "func parseRuncVersion(v string) (version string, commit string, err error) {\n\tlines := strings.Split(strings.TrimSpace(v), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.HasPrefix(line, \"runc version\") {\n\t\t\tversion = strings.TrimSpace(strings.TrimPrefix(line, \"runc version\"))\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasPrefix(line, \"commit:\") {\n\t\t\tcommit = strings.TrimSpace(strings.TrimPrefix(line, \"commit:\"))\n\t\t\tcontinue\n\t\t}\n\t}\n\tif version == \"\" && commit == \"\" {\n\t\terr = errors.Errorf(\"unknown output format: %s\", v)\n\t}\n\treturn version, commit, err\n}", "category": "Python"}, {"instruction": "// evalDuration evals a builtinAddDurationAndStringSig.\n// See https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_addtime", "input": "go language", "output": "func (b *builtinAddDurationAndStringSig) evalDuration(row chunk.Row) (types.Duration, bool, error) {\n\targ0, isNull, err := b.args[0].EvalDuration(b.ctx, row)\n\tif isNull || err != nil {\n\t\treturn types.ZeroDuration, isNull, err\n\t}\n\ts, isNull, err := b.args[1].EvalString(b.ctx, row)\n\tif isNull || err != nil {\n\t\treturn types.ZeroDuration, isNull, err\n\t}\n\tif !isDuration(s) {\n\t\treturn types.ZeroDuration, true, nil\n\t}\n\targ1, err := types.ParseDuration(b.ctx.GetSessionVars().StmtCtx, s, types.GetFsp(s))\n\tif err != nil {\n\t\treturn types.ZeroDuration, true, err\n\t}\n\tresult, err := arg0.Add(arg1)\n\tif err != nil {\n\t\treturn types.ZeroDuration, true, err\n\t}\n\treturn result, false, nil\n}", "category": "Python"}, {"instruction": "// VersionFromCILabel resolves a version label like \"latest\" or \"stable\" to an actual version using the public Kubernetes CI uploads", "input": "go language", "output": "func (g *KubeVersionGetter) VersionFromCILabel(ciVersionLabel, description string) (string, *versionutil.Version, error) {\n\tversionStr, err := kubeadmutil.KubernetesReleaseVersion(ciVersionLabel)\n\tif err != nil {\n\t\treturn \"\", nil, errors.Wrapf(err, \"Couldn't fetch latest %s from the internet\", description)\n\t}\n\n\tif description != \"\" {\n\t\tfmt.Fprintf(g.w, \"[upgrade/versions] Latest %s: %s\\n\", description, versionStr)\n\t}\n\n\tver, err := versionutil.ParseSemantic(versionStr)\n\tif err != nil {\n\t\treturn \"\", nil, errors.Wrapf(err, \"Couldn't parse latest %s\", description)\n\t}\n\treturn versionStr, ver, nil\n}", "category": "Python"}, {"instruction": "// Init creates a driver with the given home and the set of options.", "input": "go language", "output": "func Init(home string, options []string, uidMaps, gidMaps []idtools.IDMap) (graphdriver.Driver, error) {\n\tdeviceSet, err := NewDeviceSet(home, true, options, uidMaps, gidMaps)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\td := &Driver{\n\t\tDeviceSet: deviceSet,\n\t\thome:      home,\n\t\tuidMaps:   uidMaps,\n\t\tgidMaps:   gidMaps,\n\t\tctr:       graphdriver.NewRefCounter(graphdriver.NewDefaultChecker()),\n\t\tlocker:    locker.New(),\n\t}\n\n\treturn graphdriver.NewNaiveDiffDriver(d, uidMaps, gidMaps), nil\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *ResourceQuotaSpec) DeepCopyInto(out *ResourceQuotaSpec) {\n\t*out = *in\n\tif in.Hard != nil {\n\t\tin, out := &in.Hard, &out.Hard\n\t\t*out = make(ResourceList, len(*in))\n\t\tfor key, val := range *in {\n\t\t\t(*out)[key] = val.DeepCopy()\n\t\t}\n\t}\n\tif in.Scopes != nil {\n\t\tin, out := &in.Scopes, &out.Scopes\n\t\t*out = make([]ResourceQuotaScope, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\tif in.ScopeSelector != nil {\n\t\tin, out := &in.ScopeSelector, &out.ScopeSelector\n\t\t*out = new(ScopeSelector)\n\t\t(*in).DeepCopyInto(*out)\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// NewCmdAlpha returns \"kubeadm alpha\" command.", "input": "go language", "output": "func NewCmdAlpha(in io.Reader, out io.Writer) *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"alpha\",\n\t\tShort: \"Kubeadm experimental sub-commands\",\n\t}\n\n\tcmd.AddCommand(newCmdCertsUtility())\n\tcmd.AddCommand(newCmdKubeletUtility())\n\tcmd.AddCommand(newCmdKubeConfigUtility(out))\n\tcmd.AddCommand(NewCmdSelfhosting(in))\n\n\t// TODO: This command should be removed as soon as the kubeadm init phase refactoring is completed.\n\t//\t\t current phases implemented as cobra.Commands should become workflow.Phases, while other utilities\n\t// \t\t hosted under kubeadm alpha phases command should found a new home under kubeadm alpha (without phases)\n\tcmd.AddCommand(newCmdPhase(out))\n\n\treturn cmd\n}", "category": "Python"}, {"instruction": "// Growing Persistent volumes is only allowed for PVCs for which their StorageClass\n// explicitly allows it.", "input": "go language", "output": "func (pvcr *persistentVolumeClaimResize) allowResize(pvc, oldPvc *api.PersistentVolumeClaim) bool {\n\tpvcStorageClass := apihelper.GetPersistentVolumeClaimClass(pvc)\n\toldPvcStorageClass := apihelper.GetPersistentVolumeClaimClass(oldPvc)\n\tif pvcStorageClass == \"\" || oldPvcStorageClass == \"\" || pvcStorageClass != oldPvcStorageClass {\n\t\treturn false\n\t}\n\tsc, err := pvcr.scLister.Get(pvcStorageClass)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif sc.AllowVolumeExpansion != nil {\n\t\treturn *sc.AllowVolumeExpansion\n\t}\n\treturn false\n}", "category": "Python"}, {"instruction": "// Open implements the Executor Open interface.", "input": "go language", "output": "func (e *IndexReaderExecutor) Open(ctx context.Context) error {\n\tvar err error\n\tif e.corColInAccess {\n\t\te.ranges, err = rebuildIndexRanges(e.ctx, e.plans[0].(*plannercore.PhysicalIndexScan), e.idxCols, e.colLens)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tkvRanges, err := distsql.IndexRangesToKVRanges(e.ctx.GetSessionVars().StmtCtx, e.physicalTableID, e.index.ID, e.ranges, e.feedback)\n\tif err != nil {\n\t\te.feedback.Invalidate()\n\t\treturn err\n\t}\n\treturn e.open(ctx, kvRanges)\n}", "category": "Python"}, {"instruction": "// Uniq takes in a slice or array and returns a slice with subsequent\n// duplicate elements removed.", "input": "go language", "output": "func (ns *Namespace) Uniq(seq interface{}) (interface{}, error) {\n\tif seq == nil {\n\t\treturn make([]interface{}, 0), nil\n\t}\n\n\tv := reflect.ValueOf(seq)\n\tvar slice reflect.Value\n\n\tswitch v.Kind() {\n\tcase reflect.Slice:\n\t\tslice = reflect.MakeSlice(v.Type(), 0, 0)\n\tcase reflect.Array:\n\t\tslice = reflect.MakeSlice(reflect.SliceOf(v.Type().Elem()), 0, 0)\n\tdefault:\n\t\treturn nil, errors.Errorf(\"type %T not supported\", seq)\n\t}\n\n\tseen := make(map[interface{}]bool)\n\tfor i := 0; i < v.Len(); i++ {\n\t\tev, _ := indirectInterface(v.Index(i))\n\t\tif !ev.Type().Comparable() {\n\t\t\treturn nil, errors.New(\"elements must be comparable\")\n\t\t}\n\t\tkey := normalize(ev)\n\t\tif _, found := seen[key]; !found {\n\t\t\tslice = reflect.Append(slice, ev)\n\t\t\tseen[key] = true\n\t\t}\n\t}\n\n\treturn slice.Interface(), nil\n\n}", "category": "Python"}, {"instruction": "// Set32 sets the 32 bytes starting at offset to the value of val, left-padded with zeroes to\n// 32 bytes.", "input": "go language", "output": "func (m *Memory) Set32(offset uint64, val *big.Int) {\n\t// length of store may never be less than offset + size.\n\t// The store should be resized PRIOR to setting the memory\n\tif offset+32 > uint64(len(m.store)) {\n\t\tpanic(\"invalid memory: store empty\")\n\t}\n\t// Zero the memory area\n\tcopy(m.store[offset:offset+32], []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})\n\t// Fill in relevant bits\n\tmath.ReadBits(val, m.store[offset:offset+32])\n}", "category": "Python"}, {"instruction": "// HandleChain creates/returns a reference to a consensus.Chain object for the\n// given set of support resources. Implements the consensus.Consenter\n// interface. Called by consensus.newChainSupport(), which is itself called by\n// multichannel.NewManagerImpl() when ranging over the ledgerFactory's\n// existingChains.", "input": "go language", "output": "func (consenter *consenterImpl) HandleChain(support consensus.ConsenterSupport, metadata *cb.Metadata) (consensus.Chain, error) {\n\tlastOffsetPersisted, lastOriginalOffsetProcessed, lastResubmittedConfigOffset := getOffsets(metadata.Value, support.ChainID())\n\tch, err := newChain(consenter, support, lastOffsetPersisted, lastOriginalOffsetProcessed, lastResubmittedConfigOffset)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconsenter.healthChecker.RegisterChecker(ch.channel.String(), ch)\n\treturn ch, nil\n}", "category": "Python"}, {"instruction": "// ValidateNetworking validates networking configuration", "input": "go language", "output": "func ValidateNetworking(c *kubeadm.Networking, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tallErrs = append(allErrs, apivalidation.ValidateDNS1123Subdomain(c.DNSDomain, field.NewPath(\"dnsDomain\"))...)\n\tallErrs = append(allErrs, ValidateIPNetFromString(c.ServiceSubnet, constants.MinimumAddressesInServiceSubnet, field.NewPath(\"serviceSubnet\"))...)\n\tif len(c.PodSubnet) != 0 {\n\t\tallErrs = append(allErrs, ValidateIPNetFromString(c.PodSubnet, constants.MinimumAddressesInServiceSubnet, field.NewPath(\"podSubnet\"))...)\n\t}\n\treturn allErrs\n}", "category": "Python"}, {"instruction": "// worker processes the queue of namespace objects.\n// Each namespace can be in the queue at most once.\n// The system ensures that no two workers can process\n// the same namespace at the same time.", "input": "go language", "output": "func (nm *NamespaceController) worker() {\n\tworkFunc := func() bool {\n\t\tkey, quit := nm.queue.Get()\n\t\tif quit {\n\t\t\treturn true\n\t\t}\n\t\tdefer nm.queue.Done(key)\n\n\t\terr := nm.syncNamespaceFromKey(key.(string))\n\t\tif err == nil {\n\t\t\t// no error, forget this entry and return\n\t\t\tnm.queue.Forget(key)\n\t\t\treturn false\n\t\t}\n\n\t\tif estimate, ok := err.(*deletion.ResourcesRemainingError); ok {\n\t\t\tt := estimate.Estimate/2 + 1\n\t\t\tklog.V(4).Infof(\"Content remaining in namespace %s, waiting %d seconds\", key, t)\n\t\t\tnm.queue.AddAfter(key, time.Duration(t)*time.Second)\n\t\t} else {\n\t\t\t// rather than wait for a full resync, re-add the namespace to the queue to be processed\n\t\t\tnm.queue.AddRateLimited(key)\n\t\t\tutilruntime.HandleError(err)\n\t\t}\n\t\treturn false\n\t}\n\n\tfor {\n\t\tquit := workFunc()\n\n\t\tif quit {\n\t\t\treturn\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// NewInbox creates an Inbox. An Inboxes is not persisted, the cumulative sum is updated\n// from blockchain when first cheque is received.", "input": "go language", "output": "func NewInbox(prvKey *ecdsa.PrivateKey, contractAddr, beneficiary common.Address, signer *ecdsa.PublicKey, abigen bind.ContractBackend) (*Inbox, error) {\n\tif signer == nil {\n\t\treturn nil, fmt.Errorf(\"signer is null\")\n\t}\n\tchbook, err := contract.NewChequebook(contractAddr, abigen)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttransactOpts := bind.NewKeyedTransactor(prvKey)\n\ttransactOpts.GasLimit = gasToCash\n\tsession := &contract.ChequebookSession{\n\t\tContract:     chbook,\n\t\tTransactOpts: *transactOpts,\n\t}\n\tsender := transactOpts.From\n\n\tinbox := &Inbox{\n\t\tcontract:    contractAddr,\n\t\tbeneficiary: beneficiary,\n\t\tsender:      sender,\n\t\tsigner:      signer,\n\t\tsession:     session,\n\t\tcashed:      new(big.Int).Set(common.Big0),\n\t\tlog:         log.New(\"contract\", contractAddr),\n\t}\n\tinbox.log.Trace(\"New chequebook inbox initialized\", \"beneficiary\", inbox.beneficiary, \"signer\", hexutil.Bytes(crypto.FromECDSAPub(signer)))\n\treturn inbox, nil\n}", "category": "Python"}, {"instruction": "// DecodeIntValues is called when the current Feedback stores encoded int values.", "input": "go language", "output": "func (q *QueryFeedback) DecodeIntValues() *QueryFeedback {\n\tnq := &QueryFeedback{}\n\tnq.Feedback = make([]Feedback, 0, len(q.Feedback))\n\tfor _, fb := range q.Feedback {\n\t\t_, lowInt, err := codec.DecodeInt(fb.Lower.GetBytes())\n\t\tif err != nil {\n\t\t\tlogutil.Logger(context.Background()).Debug(\"decode feedback lower bound value to integer failed\", zap.Binary(\"value\", fb.Lower.GetBytes()), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\t_, highInt, err := codec.DecodeInt(fb.Upper.GetBytes())\n\t\tif err != nil {\n\t\t\tlogutil.Logger(context.Background()).Debug(\"decode feedback upper bound value to integer failed\", zap.Binary(\"value\", fb.Upper.GetBytes()), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tlow, high := types.NewIntDatum(lowInt), types.NewIntDatum(highInt)\n\t\tnq.Feedback = append(nq.Feedback, Feedback{Lower: &low, Upper: &high, Count: fb.Count})\n\t}\n\treturn nq\n}", "category": "Python"}, {"instruction": "// DataForAnalyzeStatus gets all the analyze jobs.", "input": "go language", "output": "func DataForAnalyzeStatus() (rows [][]types.Datum) {\n\tfor _, job := range statistics.GetAllAnalyzeJobs() {\n\t\tjob.Lock()\n\t\tvar startTime interface{}\n\t\tif job.StartTime.IsZero() {\n\t\t\tstartTime = nil\n\t\t} else {\n\t\t\tstartTime = types.Time{Time: types.FromGoTime(job.StartTime), Type: mysql.TypeDatetime}\n\t\t}\n\t\trows = append(rows, types.MakeDatums(\n\t\t\tjob.DBName,        // TABLE_SCHEMA\n\t\t\tjob.TableName,     // TABLE_NAME\n\t\t\tjob.PartitionName, // PARTITION_NAME\n\t\t\tjob.JobInfo,       // JOB_INFO\n\t\t\tjob.RowCount,      // ROW_COUNT\n\t\t\tstartTime,         // START_TIME\n\t\t\tjob.State,         // STATE\n\t\t))\n\t\tjob.Unlock()\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// setNextValue sets the next value for the given datum. For types like float,\n// we do not set because it is not discrete and does not matter too much when estimating the scalar info.", "input": "go language", "output": "func setNextValue(d *types.Datum) {\n\tswitch d.Kind() {\n\tcase types.KindBytes, types.KindString:\n\t\td.SetBytes(kv.Key(d.GetBytes()).PrefixNext())\n\tcase types.KindInt64:\n\t\td.SetInt64(d.GetInt64() + 1)\n\tcase types.KindUint64:\n\t\td.SetUint64(d.GetUint64() + 1)\n\tcase types.KindMysqlDuration:\n\t\tduration := d.GetMysqlDuration()\n\t\tduration.Duration = duration.Duration + 1\n\t\td.SetMysqlDuration(duration)\n\tcase types.KindMysqlTime:\n\t\tt := d.GetMysqlTime()\n\t\tsc := &stmtctx.StatementContext{TimeZone: types.BoundTimezone}\n\t\tif _, err := t.Add(sc, types.Duration{Duration: 1, Fsp: 0}); err != nil {\n\t\t\tlog.Error(errors.ErrorStack(err))\n\t\t}\n\t\td.SetMysqlTime(t)\n\t}\n}", "category": "Python"}, {"instruction": "// oldPodsRunning returns whether there are old pods running or any of the old ReplicaSets thinks that it runs pods.", "input": "go language", "output": "func oldPodsRunning(newRS *apps.ReplicaSet, oldRSs []*apps.ReplicaSet, podMap map[types.UID]*v1.PodList) bool {\n\tif oldPods := util.GetActualReplicaCountForReplicaSets(oldRSs); oldPods > 0 {\n\t\treturn true\n\t}\n\tfor rsUID, podList := range podMap {\n\t\t// If the pods belong to the new ReplicaSet, ignore.\n\t\tif newRS != nil && newRS.UID == rsUID {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, pod := range podList.Items {\n\t\t\tswitch pod.Status.Phase {\n\t\t\tcase v1.PodFailed, v1.PodSucceeded:\n\t\t\t\t// Don't count pods in terminal state.\n\t\t\t\tcontinue\n\t\t\tcase v1.PodUnknown:\n\t\t\t\t// This happens in situation like when the node is temporarily disconnected from the cluster.\n\t\t\t\t// If we can't be sure that the pod is not running, we have to count it.\n\t\t\t\treturn true\n\t\t\tdefault:\n\t\t\t\t// Pod is not in terminal phase.\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}", "category": "Python"}, {"instruction": "// NewImageManager instantiates a new ImageManager object.", "input": "go language", "output": "func NewImageManager(recorder record.EventRecorder, imageService kubecontainer.ImageService, imageBackOff *flowcontrol.Backoff, serialized bool, qps float32, burst int) ImageManager {\n\timageService = throttleImagePulling(imageService, qps, burst)\n\n\tvar puller imagePuller\n\tif serialized {\n\t\tpuller = newSerialImagePuller(imageService)\n\t} else {\n\t\tpuller = newParallelImagePuller(imageService)\n\t}\n\treturn &imageManager{\n\t\trecorder:     recorder,\n\t\timageService: imageService,\n\t\tbackOff:      imageBackOff,\n\t\tpuller:       puller,\n\t}\n}", "category": "Python"}, {"instruction": "// getKubeletContainers lists containers managed by kubelet.\n// The boolean parameter specifies whether returns all containers including\n// those already exited and dead containers (used for garbage collection).", "input": "go language", "output": "func (m *kubeGenericRuntimeManager) getKubeletContainers(allContainers bool) ([]*runtimeapi.Container, error) {\n\tfilter := &runtimeapi.ContainerFilter{}\n\tif !allContainers {\n\t\tfilter.State = &runtimeapi.ContainerStateValue{\n\t\t\tState: runtimeapi.ContainerState_CONTAINER_RUNNING,\n\t\t}\n\t}\n\n\tcontainers, err := m.runtimeService.ListContainers(filter)\n\tif err != nil {\n\t\tklog.Errorf(\"getKubeletContainers failed: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn containers, nil\n}", "category": "Python"}, {"instruction": "// When a pod is deleted, enqueue the services the pod used to be a member of.\n// obj could be an *v1.Pod, or a DeletionFinalStateUnknown marker item.", "input": "go language", "output": "func (e *EndpointController) deletePod(obj interface{}) {\n\tif _, ok := obj.(*v1.Pod); ok {\n\t\t// Enqueue all the services that the pod used to be a member\n\t\t// of. This happens to be exactly the same thing we do when a\n\t\t// pod is added.\n\t\te.addPod(obj)\n\t\treturn\n\t}\n\t// If we reached here it means the pod was deleted but its final state is unrecorded.\n\ttombstone, ok := obj.(cache.DeletedFinalStateUnknown)\n\tif !ok {\n\t\tutilruntime.HandleError(fmt.Errorf(\"Couldn't get object from tombstone %#v\", obj))\n\t\treturn\n\t}\n\tpod, ok := tombstone.Obj.(*v1.Pod)\n\tif !ok {\n\t\tutilruntime.HandleError(fmt.Errorf(\"Tombstone contained object that is not a Pod: %#v\", obj))\n\t\treturn\n\t}\n\tklog.V(4).Infof(\"Enqueuing services of deleted pod %s/%s having final state unrecorded\", pod.Namespace, pod.Name)\n\te.addPod(pod)\n}", "category": "Python"}, {"instruction": "// setBootstrapNodesV5 creates a list of bootstrap nodes from the command line\n// flags, reverting to pre-configured ones if none have been specified.", "input": "go language", "output": "func setBootstrapNodesV5(ctx *cli.Context, cfg *p2p.Config) {\n\turls := params.DiscoveryV5Bootnodes\n\tswitch {\n\tcase ctx.GlobalIsSet(BootnodesFlag.Name) || ctx.GlobalIsSet(BootnodesV5Flag.Name):\n\t\tif ctx.GlobalIsSet(BootnodesV5Flag.Name) {\n\t\t\turls = strings.Split(ctx.GlobalString(BootnodesV5Flag.Name), \",\")\n\t\t} else {\n\t\t\turls = strings.Split(ctx.GlobalString(BootnodesFlag.Name), \",\")\n\t\t}\n\tcase ctx.GlobalBool(RinkebyFlag.Name):\n\t\turls = params.RinkebyBootnodes\n\tcase ctx.GlobalBool(GoerliFlag.Name):\n\t\turls = params.GoerliBootnodes\n\tcase cfg.BootstrapNodesV5 != nil:\n\t\treturn // already set, don't apply defaults.\n\t}\n\n\tcfg.BootstrapNodesV5 = make([]*discv5.Node, 0, len(urls))\n\tfor _, url := range urls {\n\t\tif url != \"\" {\n\t\t\tnode, err := discv5.ParseNode(url)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Bootstrap URL invalid\", \"enode\", url, \"err\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcfg.BootstrapNodesV5 = append(cfg.BootstrapNodesV5, node)\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// targetEncodingForTransform returns the appropriate serializer for the input media type", "input": "go language", "output": "func targetEncodingForTransform(scope *RequestScope, mediaType negotiation.MediaTypeOptions, req *http.Request) (schema.GroupVersionKind, runtime.NegotiatedSerializer, bool) {\n\tswitch target := mediaType.Convert; {\n\tcase target == nil:\n\tcase target.Kind == \"PartialObjectMetadata\" && target.GroupVersion() == metav1beta1.SchemeGroupVersion,\n\t\ttarget.Kind == \"PartialObjectMetadataList\" && target.GroupVersion() == metav1beta1.SchemeGroupVersion,\n\t\ttarget.Kind == \"Table\" && target.GroupVersion() == metav1beta1.SchemeGroupVersion:\n\t\treturn *target, metainternalversion.Codecs, true\n\t}\n\treturn scope.Kind, scope.Serializer, false\n}", "category": "Python"}, {"instruction": "// NewXForwarded creates a new XForwarded.", "input": "go language", "output": "func NewXForwarded(insecure bool, trustedIps []string, next http.Handler) (*XForwarded, error) {\n\tvar ipChecker *ip.Checker\n\tif len(trustedIps) > 0 {\n\t\tvar err error\n\t\tipChecker, err = ip.NewChecker(trustedIps)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\thostname, err := os.Hostname()\n\tif err != nil {\n\t\thostname = \"localhost\"\n\t}\n\n\treturn &XForwarded{\n\t\tinsecure:   insecure,\n\t\ttrustedIps: trustedIps,\n\t\tipChecker:  ipChecker,\n\t\tnext:       next,\n\t\thostname:   hostname,\n\t}, nil\n}", "category": "Python"}, {"instruction": "// Get returns a read-only copy of the system capabilities.", "input": "go language", "output": "func Get() Capabilities {\n\tcapInstance.lock.Lock()\n\tdefer capInstance.lock.Unlock()\n\t// This check prevents clobbering of capabilities that might've been set via SetForTests\n\tif capInstance.capabilities == nil {\n\t\tInitialize(Capabilities{\n\t\t\tAllowPrivileged: false,\n\t\t\tPrivilegedSources: PrivilegedSources{\n\t\t\t\tHostNetworkSources: []string{},\n\t\t\t\tHostPIDSources:     []string{},\n\t\t\t\tHostIPCSources:     []string{},\n\t\t\t},\n\t\t})\n\t}\n\treturn *capInstance.capabilities\n}", "category": "Python"}, {"instruction": "// GetChaincodeData gets the ChaincodeData", "input": "go language", "output": "func (ccpack *SignedCDSPackage) GetChaincodeData() *ChaincodeData {\n\t//this has to be after creating a package and initializing it\n\t//If those steps fail, GetChaincodeData() should never be called\n\tif ccpack.depSpec == nil || ccpack.datab == nil || ccpack.id == nil {\n\t\tpanic(\"GetChaincodeData called on uninitialized package\")\n\t}\n\n\tvar instPolicy []byte\n\tif ccpack.sDepSpec != nil {\n\t\tinstPolicy = ccpack.sDepSpec.InstantiationPolicy\n\t}\n\n\treturn &ChaincodeData{\n\t\tName:                ccpack.depSpec.ChaincodeSpec.ChaincodeId.Name,\n\t\tVersion:             ccpack.depSpec.ChaincodeSpec.ChaincodeId.Version,\n\t\tData:                ccpack.datab,\n\t\tId:                  ccpack.id,\n\t\tInstantiationPolicy: instPolicy,\n\t}\n}", "category": "Python"}, {"instruction": "// NewFilteredCertificateSigningRequestInformer constructs a new informer for CertificateSigningRequest type.\n// Always prefer using an informer factory to get a shared informer instead of getting an independent\n// one. This reduces memory footprint and number of connections to the server.", "input": "go language", "output": "func NewFilteredCertificateSigningRequestInformer(client kubernetes.Interface, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {\n\treturn cache.NewSharedIndexInformer(\n\t\t&cache.ListWatch{\n\t\t\tListFunc: func(options v1.ListOptions) (runtime.Object, error) {\n\t\t\t\tif tweakListOptions != nil {\n\t\t\t\t\ttweakListOptions(&options)\n\t\t\t\t}\n\t\t\t\treturn client.CertificatesV1beta1().CertificateSigningRequests().List(options)\n\t\t\t},\n\t\t\tWatchFunc: func(options v1.ListOptions) (watch.Interface, error) {\n\t\t\t\tif tweakListOptions != nil {\n\t\t\t\t\ttweakListOptions(&options)\n\t\t\t\t}\n\t\t\t\treturn client.CertificatesV1beta1().CertificateSigningRequests().Watch(options)\n\t\t\t},\n\t\t},\n\t\t&certificatesv1beta1.CertificateSigningRequest{},\n\t\tresyncPeriod,\n\t\tindexers,\n\t)\n}", "category": "Python"}, {"instruction": "// GetLogs returns logs matching the given argument that are stored within the state.\n//\n// https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getlogs", "input": "go language", "output": "func (api *PublicFilterAPI) GetLogs(ctx context.Context, crit FilterCriteria) ([]*types.Log, error) {\n\tvar filter *Filter\n\tif crit.BlockHash != nil {\n\t\t// Block filter requested, construct a single-shot filter\n\t\tfilter = NewBlockFilter(api.backend, *crit.BlockHash, crit.Addresses, crit.Topics)\n\t} else {\n\t\t// Convert the RPC block numbers into internal representations\n\t\tbegin := rpc.LatestBlockNumber.Int64()\n\t\tif crit.FromBlock != nil {\n\t\t\tbegin = crit.FromBlock.Int64()\n\t\t}\n\t\tend := rpc.LatestBlockNumber.Int64()\n\t\tif crit.ToBlock != nil {\n\t\t\tend = crit.ToBlock.Int64()\n\t\t}\n\t\t// Construct the range filter\n\t\tfilter = NewRangeFilter(api.backend, begin, end, crit.Addresses, crit.Topics)\n\t}\n\t// Run the filter and return all the logs\n\tlogs, err := filter.Logs(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn returnLogs(logs), err\n}", "category": "Python"}, {"instruction": "//Swap implements the protocols.Balance interface\n//Add is the (sole) accounting function", "input": "go language", "output": "func (s *Swap) Add(amount int64, peer *protocols.Peer) (err error) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\t//load existing balances from the state store\n\terr = s.loadState(peer)\n\tif err != nil && err != state.ErrNotFound {\n\t\treturn\n\t}\n\t//adjust the balance\n\t//if amount is negative, it will decrease, otherwise increase\n\ts.balances[peer.ID()] += amount\n\t//save the new balance to the state store\n\tpeerBalance := s.balances[peer.ID()]\n\terr = s.stateStore.Put(peer.ID().String(), &peerBalance)\n\n\tlog.Debug(fmt.Sprintf(\"balance for peer %s: %s\", peer.ID().String(), strconv.FormatInt(peerBalance, 10)))\n\treturn err\n}", "category": "Python"}, {"instruction": "// LSet updates an element in the list by its index.", "input": "go language", "output": "func (t *TxStructure) LSet(key []byte, index int64, value []byte) error {\n\tif t.readWriter == nil {\n\t\treturn errWriteOnSnapshot\n\t}\n\tmetaKey := t.encodeListMetaKey(key)\n\tmeta, err := t.loadListMeta(metaKey)\n\tif err != nil || meta.IsEmpty() {\n\t\treturn errors.Trace(err)\n\t}\n\n\tindex = adjustIndex(index, meta.LIndex, meta.RIndex)\n\n\tif index >= meta.LIndex && index < meta.RIndex {\n\t\treturn t.readWriter.Set(t.encodeListDataKey(key, index), value)\n\t}\n\treturn errInvalidListIndex.GenWithStack(\"invalid list index %d\", index)\n}", "category": "Python"}, {"instruction": "// HInc increments the integer value of a hash field, by step, returns\n// the value after the increment.", "input": "go language", "output": "func (t *TxStructure) HInc(key []byte, field []byte, step int64) (int64, error) {\n\tif t.readWriter == nil {\n\t\treturn 0, errWriteOnSnapshot\n\t}\n\tbase := int64(0)\n\terr := t.updateHash(key, field, func(oldValue []byte) ([]byte, error) {\n\t\tif oldValue != nil {\n\t\t\tvar err error\n\t\t\tbase, err = strconv.ParseInt(string(oldValue), 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Trace(err)\n\t\t\t}\n\t\t}\n\t\tbase += step\n\t\treturn t.hashFieldIntegerVal(base), nil\n\t})\n\n\treturn base, errors.Trace(err)\n}", "category": "Python"}, {"instruction": "// AttachFileDevice takes a path to a regular file and makes it available as an\n// attached block device.", "input": "go language", "output": "func (v VolumePathHandler) AttachFileDevice(path string) (string, error) {\n\tblockDevicePath, err := v.GetLoopDevice(path)\n\tif err != nil && err.Error() != ErrDeviceNotFound {\n\t\treturn \"\", err\n\t}\n\n\t// If no existing loop device for the path, create one\n\tif blockDevicePath == \"\" {\n\t\tklog.V(4).Infof(\"Creating device for path: %s\", path)\n\t\tblockDevicePath, err = makeLoopDevice(path)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn blockDevicePath, nil\n}", "category": "Python"}, {"instruction": "// ValidateTokenGroups validates token groups", "input": "go language", "output": "func ValidateTokenGroups(usages []string, groups []string, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\n\t// adding groups only makes sense for authentication\n\tusagesSet := sets.NewString(usages...)\n\tusageAuthentication := strings.TrimPrefix(bootstrapapi.BootstrapTokenUsageAuthentication, bootstrapapi.BootstrapTokenUsagePrefix)\n\tif len(groups) > 0 && !usagesSet.Has(usageAuthentication) {\n\t\tallErrs = append(allErrs, field.Invalid(fldPath, groups, fmt.Sprintf(\"token groups cannot be specified unless --usages includes %q\", usageAuthentication)))\n\t}\n\n\t// validate any extra group names\n\tfor _, group := range groups {\n\t\tif err := bootstraputil.ValidateBootstrapGroupName(group); err != nil {\n\t\t\tallErrs = append(allErrs, field.Invalid(fldPath, groups, err.Error()))\n\t\t}\n\t}\n\n\treturn allErrs\n}", "category": "Python"}, {"instruction": "// GetCmpFunction get the compare function according to two arguments.", "input": "go language", "output": "func GetCmpFunction(lhs, rhs Expression) CompareFunc {\n\tswitch GetAccurateCmpType(lhs, rhs) {\n\tcase types.ETInt:\n\t\treturn CompareInt\n\tcase types.ETReal:\n\t\treturn CompareReal\n\tcase types.ETDecimal:\n\t\treturn CompareDecimal\n\tcase types.ETString:\n\t\treturn CompareString\n\tcase types.ETDuration:\n\t\treturn CompareDuration\n\tcase types.ETDatetime, types.ETTimestamp:\n\t\treturn CompareTime\n\tcase types.ETJson:\n\t\treturn CompareJSON\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// readLoop runs in its own goroutine. it handles incoming UDP packets.", "input": "go language", "output": "func (t *UDPv4) readLoop(unhandled chan<- ReadPacket) {\n\tdefer t.wg.Done()\n\tif unhandled != nil {\n\t\tdefer close(unhandled)\n\t}\n\n\tbuf := make([]byte, maxPacketSize)\n\tfor {\n\t\tnbytes, from, err := t.conn.ReadFromUDP(buf)\n\t\tif netutil.IsTemporaryError(err) {\n\t\t\t// Ignore temporary read errors.\n\t\t\tt.log.Debug(\"Temporary UDP read error\", \"err\", err)\n\t\t\tcontinue\n\t\t} else if err != nil {\n\t\t\t// Shut down the loop for permament errors.\n\t\t\tif err != io.EOF {\n\t\t\t\tt.log.Debug(\"UDP read error\", \"err\", err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif t.handlePacket(from, buf[:nbytes]) != nil && unhandled != nil {\n\t\t\tselect {\n\t\t\tcase unhandled <- ReadPacket{buf[:nbytes], from}:\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// dropInitContainerAnnotations returns a copy of the annotations with init container annotations removed,\n// or the original annotations if no init container annotations were present.\n//\n// this can be removed once no clients prior to 1.8 are supported, and no kubelets prior to 1.8 can be run\n// (we don't support kubelets older than 2 versions skewed from the apiserver, but we don't prevent them, either)", "input": "go language", "output": "func dropInitContainerAnnotations(oldAnnotations map[string]string) map[string]string {\n\tif len(oldAnnotations) == 0 {\n\t\treturn oldAnnotations\n\t}\n\n\tfound := false\n\tfor k := range initContainerAnnotations {\n\t\tif _, ok := oldAnnotations[k]; ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\treturn oldAnnotations\n\t}\n\n\tnewAnnotations := make(map[string]string, len(oldAnnotations))\n\tfor k, v := range oldAnnotations {\n\t\tif !initContainerAnnotations[k] {\n\t\t\tnewAnnotations[k] = v\n\t\t}\n\t}\n\treturn newAnnotations\n}", "category": "Python"}, {"instruction": "// UnmarshalText implements encoding.TextUnmarshaler", "input": "go language", "output": "func (b *Big) UnmarshalText(input []byte) error {\n\traw, err := checkNumberText(input)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(raw) > 64 {\n\t\treturn ErrBig256Range\n\t}\n\twords := make([]big.Word, len(raw)/bigWordNibbles+1)\n\tend := len(raw)\n\tfor i := range words {\n\t\tstart := end - bigWordNibbles\n\t\tif start < 0 {\n\t\t\tstart = 0\n\t\t}\n\t\tfor ri := start; ri < end; ri++ {\n\t\t\tnib := decodeNibble(raw[ri])\n\t\t\tif nib == badNibble {\n\t\t\t\treturn ErrSyntax\n\t\t\t}\n\t\t\twords[i] *= 16\n\t\t\twords[i] += big.Word(nib)\n\t\t}\n\t\tend = start\n\t}\n\tvar dec big.Int\n\tdec.SetBits(words)\n\t*b = (Big)(dec)\n\treturn nil\n}", "category": "Python"}, {"instruction": "// ChaincodeInfo implements function in interface ledger.DeployedChaincodeInfoProvider", "input": "go language", "output": "func (p *DeployedCCInfoProvider) ChaincodeInfo(chaincodeName string, qe ledger.SimpleQueryExecutor) (*ledger.DeployedChaincodeInfo, error) {\n\tchaincodeDataBytes, err := qe.GetState(lsccNamespace, chaincodeName)\n\tif err != nil || chaincodeDataBytes == nil {\n\t\treturn nil, err\n\t}\n\tchaincodeData := &ccprovider.ChaincodeData{}\n\tif err := proto.Unmarshal(chaincodeDataBytes, chaincodeData); err != nil {\n\t\treturn nil, errors.Wrap(err, \"error unmarshalling chaincode state data\")\n\t}\n\tcollConfigPkg, err := fetchCollConfigPkg(chaincodeName, qe)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &ledger.DeployedChaincodeInfo{\n\t\tName:                chaincodeName,\n\t\tHash:                chaincodeData.Id,\n\t\tVersion:             chaincodeData.Version,\n\t\tCollectionConfigPkg: collConfigPkg,\n\t}, nil\n}", "category": "Python"}, {"instruction": "// Init initializes information.", "input": "go language", "output": "func Init() {\n\tdriver := tikv.Driver{}\n\tvar err error\n\tstore, err = driver.Open(fmt.Sprintf(\"tikv://%s?cluster=1\", *pdAddr))\n\tterror.MustNil(err)\n\n\tprometheus.MustRegister(txnCounter)\n\tprometheus.MustRegister(txnRolledbackCounter)\n\tprometheus.MustRegister(txnDurations)\n\thttp.Handle(\"/metrics\", prometheus.Handler())\n\n\tgo func() {\n\t\terr1 := http.ListenAndServe(\":9191\", nil)\n\t\tterror.Log(errors.Trace(err1))\n\t}()\n}", "category": "Python"}, {"instruction": "/*\n\tWhen splitting, data is given as a SectionReader, and the key is a hashSize long byte slice (Key), the root hash of the entire content will fill this once processing finishes.\n\tNew chunks to store are store using the putter which the caller provides.\n*/", "input": "go language", "output": "func TreeSplit(ctx context.Context, data io.Reader, size int64, putter Putter) (k Address, wait func(context.Context) error, err error) {\n\ttsp := &TreeSplitterParams{\n\t\tSplitterParams: SplitterParams{\n\t\t\tChunkerParams: ChunkerParams{\n\t\t\t\tchunkSize: chunk.DefaultSize,\n\t\t\t\thashSize:  putter.RefSize(),\n\t\t\t},\n\t\t\treader: data,\n\t\t\tputter: putter,\n\t\t},\n\t\tsize: size,\n\t}\n\treturn NewTreeSplitter(tsp).Split(ctx)\n}", "category": "Python"}, {"instruction": "// FilteredBy filters by the given predicate. Empty APIResourceLists are dropped.", "input": "go language", "output": "func FilteredBy(pred ResourcePredicate, rls []*metav1.APIResourceList) []*metav1.APIResourceList {\n\tresult := []*metav1.APIResourceList{}\n\tfor _, rl := range rls {\n\t\tfiltered := *rl\n\t\tfiltered.APIResources = nil\n\t\tfor i := range rl.APIResources {\n\t\t\tif pred.Match(rl.GroupVersion, &rl.APIResources[i]) {\n\t\t\t\tfiltered.APIResources = append(filtered.APIResources, rl.APIResources[i])\n\t\t\t}\n\t\t}\n\t\tif filtered.APIResources != nil {\n\t\t\tresult = append(result, &filtered)\n\t\t}\n\t}\n\treturn result\n}", "category": "Python"}, {"instruction": "// equalFoldRight is a specialization of bytes.EqualFold when s is\n// known to be all ASCII (including punctuation), but contains an 's',\n// 'S', 'k', or 'K', requiring a Unicode fold on the bytes in t.\n// See comments on foldFunc.", "input": "go language", "output": "func equalFoldRight(s, t []byte) bool {\n\tfor _, sb := range s {\n\t\tif len(t) == 0 {\n\t\t\treturn false\n\t\t}\n\t\ttb := t[0]\n\t\tif tb < utf8.RuneSelf {\n\t\t\tif sb != tb {\n\t\t\t\tsbUpper := sb & caseMask\n\t\t\t\tif 'A' <= sbUpper && sbUpper <= 'Z' {\n\t\t\t\t\tif sbUpper != tb&caseMask {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = t[1:]\n\t\t\tcontinue\n\t\t}\n\t\t// sb is ASCII and t is not. t must be either kelvin\n\t\t// sign or long s; sb must be s, S, k, or K.\n\t\ttr, size := utf8.DecodeRune(t)\n\t\tswitch sb {\n\t\tcase 's', 'S':\n\t\t\tif tr != smallLongEss {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase 'k', 'K':\n\t\t\tif tr != kelvin {\n\t\t\t\treturn false\n\t\t\t}\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t\tt = t[size:]\n\n\t}\n\tif len(t) > 0 {\n\t\treturn false\n\t}\n\treturn true\n}", "category": "Python"}, {"instruction": "// newEventRateLimit configures an admission controller that can enforce event rate limits", "input": "go language", "output": "func newEventRateLimit(config *eventratelimitapi.Configuration, clock flowcontrol.Clock) (*Plugin, error) {\n\tlimitEnforcers := make([]*limitEnforcer, 0, len(config.Limits))\n\tfor _, limitConfig := range config.Limits {\n\t\tenforcer, err := newLimitEnforcer(limitConfig, clock)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlimitEnforcers = append(limitEnforcers, enforcer)\n\t}\n\n\teventRateLimitAdmission := &Plugin{\n\t\tHandler:        admission.NewHandler(admission.Create, admission.Update),\n\t\tlimitEnforcers: limitEnforcers,\n\t}\n\n\treturn eventRateLimitAdmission, nil\n}", "category": "Python"}, {"instruction": "// This helper turns a provider configs field into a deterministic\n// string value for comparison in tests.", "input": "go language", "output": "func providerConfigsStr(pcs []*ProviderConfig) string {\n\tresult := \"\"\n\n\tns := make([]string, 0, len(pcs))\n\tm := make(map[string]*ProviderConfig)\n\tfor _, n := range pcs {\n\t\tns = append(ns, n.Name)\n\t\tm[n.Name] = n\n\t}\n\tsort.Strings(ns)\n\n\tfor _, n := range ns {\n\t\tpc := m[n]\n\n\t\tresult += fmt.Sprintf(\"%s\\n\", n)\n\n\t\tkeys := make([]string, 0, len(pc.RawConfig.Raw))\n\t\tfor k, _ := range pc.RawConfig.Raw {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t\tsort.Strings(keys)\n\n\t\tfor _, k := range keys {\n\t\t\tresult += fmt.Sprintf(\"  %s\\n\", k)\n\t\t}\n\n\t\tif len(pc.RawConfig.Variables) > 0 {\n\t\t\tresult += fmt.Sprintf(\"  vars\\n\")\n\t\t\tfor _, rawV := range pc.RawConfig.Variables {\n\t\t\t\tkind := \"unknown\"\n\t\t\t\tstr := rawV.FullKey()\n\n\t\t\t\tswitch rawV.(type) {\n\t\t\t\tcase *ResourceVariable:\n\t\t\t\t\tkind = \"resource\"\n\t\t\t\tcase *UserVariable:\n\t\t\t\t\tkind = \"user\"\n\t\t\t\t}\n\n\t\t\t\tresult += fmt.Sprintf(\"    %s: %s\\n\", kind, str)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn strings.TrimSpace(result)\n}", "category": "Python"}, {"instruction": "// MakeDataDir retrieves the currently requested data directory, terminating\n// if none (or the empty string) is specified. If the node is starting a testnet,\n// the a subdirectory of the specified datadir will be used.", "input": "go language", "output": "func MakeDataDir(ctx *cli.Context) string {\n\tif path := ctx.GlobalString(DataDirFlag.Name); path != \"\" {\n\t\tif ctx.GlobalBool(TestnetFlag.Name) {\n\t\t\treturn filepath.Join(path, \"testnet\")\n\t\t}\n\t\tif ctx.GlobalBool(RinkebyFlag.Name) {\n\t\t\treturn filepath.Join(path, \"rinkeby\")\n\t\t}\n\t\tif ctx.GlobalBool(GoerliFlag.Name) {\n\t\t\treturn filepath.Join(path, \"goerli\")\n\t\t}\n\t\treturn path\n\t}\n\tFatalf(\"Cannot determine default data directory, please set manually (--datadir)\")\n\treturn \"\"\n}", "category": "Python"}, {"instruction": "//genChaincodeDeploymentSpec creates ChaincodeDeploymentSpec as the package to install", "input": "go language", "output": "func genChaincodeDeploymentSpec(cmd *cobra.Command, chaincodeName, chaincodeVersion string) (*pb.ChaincodeDeploymentSpec, error) {\n\tif existed, _ := ccprovider.ChaincodePackageExists(chaincodeName, chaincodeVersion); existed {\n\t\treturn nil, fmt.Errorf(\"chaincode %s:%s already exists\", chaincodeName, chaincodeVersion)\n\t}\n\n\tspec, err := getChaincodeSpec(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcds, err := getChaincodeDeploymentSpec(spec, true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting chaincode code %s: %s\", chaincodeName, err)\n\t}\n\n\treturn cds, nil\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *Headers) DeepCopyInto(out *Headers) {\n\t*out = *in\n\tif in.CustomRequestHeaders != nil {\n\t\tin, out := &in.CustomRequestHeaders, &out.CustomRequestHeaders\n\t\t*out = make(map[string]string, len(*in))\n\t\tfor key, val := range *in {\n\t\t\t(*out)[key] = val\n\t\t}\n\t}\n\tif in.CustomResponseHeaders != nil {\n\t\tin, out := &in.CustomResponseHeaders, &out.CustomResponseHeaders\n\t\t*out = make(map[string]string, len(*in))\n\t\tfor key, val := range *in {\n\t\t\t(*out)[key] = val\n\t\t}\n\t}\n\tif in.AllowedHosts != nil {\n\t\tin, out := &in.AllowedHosts, &out.AllowedHosts\n\t\t*out = make([]string, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\tif in.HostsProxyHeaders != nil {\n\t\tin, out := &in.HostsProxyHeaders, &out.HostsProxyHeaders\n\t\t*out = make([]string, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\tif in.SSLProxyHeaders != nil {\n\t\tin, out := &in.SSLProxyHeaders, &out.SSLProxyHeaders\n\t\t*out = make(map[string]string, len(*in))\n\t\tfor key, val := range *in {\n\t\t\t(*out)[key] = val\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// FilterABIChanged is a free log retrieval operation binding the contract event 0xaa121bbeef5f32f5961a2a28966e769023910fc9479059ee3495d4c1a696efe3.\n//\n// Solidity: event ABIChanged(node indexed bytes32, contentType indexed uint256)", "input": "go language", "output": "func (_PublicResolver *PublicResolverFilterer) FilterABIChanged(opts *bind.FilterOpts, node [][32]byte, contentType []*big.Int) (*PublicResolverABIChangedIterator, error) {\n\n\tvar nodeRule []interface{}\n\tfor _, nodeItem := range node {\n\t\tnodeRule = append(nodeRule, nodeItem)\n\t}\n\tvar contentTypeRule []interface{}\n\tfor _, contentTypeItem := range contentType {\n\t\tcontentTypeRule = append(contentTypeRule, contentTypeItem)\n\t}\n\n\tlogs, sub, err := _PublicResolver.contract.FilterLogs(opts, \"ABIChanged\", nodeRule, contentTypeRule)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &PublicResolverABIChangedIterator{contract: _PublicResolver.contract, event: \"ABIChanged\", logs: logs, sub: sub}, nil\n}", "category": "Python"}, {"instruction": "// GetNextLevel returns the frequency level a next update should be placed at, provided where\n// the last update was and what time it is now.\n// This is the first nonzero bit of the XOR of 'last' and 'now', counting from the highest significant bit\n// but limited to not return a level that is smaller than the last-1", "input": "go language", "output": "func GetNextLevel(last Epoch, now uint64) uint8 {\n\t// First XOR the last epoch base time with the current clock.\n\t// This will set all the common most significant bits to zero.\n\tmix := (last.Base() ^ now)\n\n\t// Then, make sure we stop the below loop before one level below the current, by setting\n\t// that level's bit to 1.\n\t// If the next level is lower than the current one, it must be exactly level-1 and not lower.\n\tmix |= (1 << (last.Level - 1))\n\n\t// if the last update was more than 2^highestLevel seconds ago, choose the highest level\n\tif mix > (maxuint64 >> (64 - HighestLevel - 1)) {\n\t\treturn HighestLevel\n\t}\n\n\t// set up a mask to scan for nonzero bits, starting at the highest level\n\tmask := uint64(1 << (HighestLevel))\n\n\tfor i := uint8(HighestLevel); i > LowestLevel; i-- {\n\t\tif mix&mask != 0 { // if we find a nonzero bit, this is the level the next update should be at.\n\t\t\treturn i\n\t\t}\n\t\tmask = mask >> 1 // move our bit one position to the right\n\t}\n\treturn 0\n}", "category": "Python"}, {"instruction": "// NewEnvelopeTransformer returns a transformer which implements a KEK-DEK based envelope encryption scheme.\n// It uses envelopeService to encrypt and decrypt DEKs. Respective DEKs (in encrypted form) are prepended to\n// the data items they encrypt. A cache (of size cacheSize) is maintained to store the most recently\n// used decrypted DEKs in memory.", "input": "go language", "output": "func NewEnvelopeTransformer(envelopeService Service, cacheSize int, baseTransformerFunc func(cipher.Block) value.Transformer) (value.Transformer, error) {\n\tif cacheSize == 0 {\n\t\tcacheSize = defaultCacheSize\n\t}\n\tcache, err := lru.New(cacheSize)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &envelopeTransformer{\n\t\tenvelopeService:     envelopeService,\n\t\ttransformers:        cache,\n\t\tbaseTransformerFunc: baseTransformerFunc,\n\t}, nil\n}", "category": "Python"}, {"instruction": "// populateResourceListV1 takes strings of form <resourceName1>=<value1>,<resourceName1>=<value2>\n// and returns ResourceList.", "input": "go language", "output": "func populateResourceListV1(spec string) (v1.ResourceList, error) {\n\t// empty input gets a nil response to preserve generator test expected behaviors\n\tif spec == \"\" {\n\t\treturn nil, nil\n\t}\n\n\tresult := v1.ResourceList{}\n\tresourceStatements := strings.Split(spec, \",\")\n\tfor _, resourceStatement := range resourceStatements {\n\t\tparts := strings.Split(resourceStatement, \"=\")\n\t\tif len(parts) != 2 {\n\t\t\treturn nil, fmt.Errorf(\"Invalid argument syntax %v, expected <resource>=<value>\", resourceStatement)\n\t\t}\n\t\tresourceName := v1.ResourceName(parts[0])\n\t\tresourceQuantity, err := resource.ParseQuantity(parts[1])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresult[resourceName] = resourceQuantity\n\t}\n\treturn result, nil\n}", "category": "Python"}, {"instruction": "// RawReverseScan implements the RawKV interface.\n// Scan the range of [endKey, startKey)\n// It doesn't support Scanning from \"\", because locating the last Region is not yet implemented.", "input": "go language", "output": "func (mvcc *MVCCLevelDB) RawReverseScan(startKey, endKey []byte, limit int) []Pair {\n\tmvcc.mu.Lock()\n\tdefer mvcc.mu.Unlock()\n\n\titer := mvcc.db.NewIterator(&util.Range{\n\t\tLimit: startKey,\n\t}, nil)\n\n\tsuccess := iter.Last()\n\n\tvar pairs []Pair\n\tfor success && len(pairs) < limit {\n\t\tkey := iter.Key()\n\t\tvalue := iter.Value()\n\t\terr := iter.Error()\n\t\tif bytes.Compare(key, endKey) < 0 {\n\t\t\tbreak\n\t\t}\n\t\tpairs = append(pairs, Pair{\n\t\t\tKey:   append([]byte{}, key...),\n\t\t\tValue: append([]byte{}, value...),\n\t\t\tErr:   err,\n\t\t})\n\t\tsuccess = iter.Prev()\n\t}\n\treturn pairs\n}", "category": "Python"}, {"instruction": "// getChaincodeSpec get chaincode spec from the cli cmd pramameters", "input": "go language", "output": "func getChaincodeSpec(cmd *cobra.Command) (*pb.ChaincodeSpec, error) {\n\tspec := &pb.ChaincodeSpec{}\n\tif err := checkChaincodeCmdParams(cmd); err != nil {\n\t\t// unset usage silence because it's a command line usage error\n\t\tcmd.SilenceUsage = false\n\t\treturn spec, err\n\t}\n\n\t// Build the spec\n\tinput := &pb.ChaincodeInput{}\n\tif err := json.Unmarshal([]byte(chaincodeCtorJSON), &input); err != nil {\n\t\treturn spec, errors.Wrap(err, \"chaincode argument error\")\n\t}\n\n\tchaincodeLang = strings.ToUpper(chaincodeLang)\n\tspec = &pb.ChaincodeSpec{\n\t\tType:        pb.ChaincodeSpec_Type(pb.ChaincodeSpec_Type_value[chaincodeLang]),\n\t\tChaincodeId: &pb.ChaincodeID{Path: chaincodePath, Name: chaincodeName, Version: chaincodeVersion},\n\t\tInput:       input,\n\t}\n\treturn spec, nil\n}", "category": "Python"}, {"instruction": "// ResourceList returns a resource list of this resource.", "input": "go language", "output": "func (r *Resource) ResourceList() v1.ResourceList {\n\tresult := v1.ResourceList{\n\t\tv1.ResourceCPU:              *resource.NewMilliQuantity(r.MilliCPU, resource.DecimalSI),\n\t\tv1.ResourceMemory:           *resource.NewQuantity(r.Memory, resource.BinarySI),\n\t\tv1.ResourcePods:             *resource.NewQuantity(int64(r.AllowedPodNumber), resource.BinarySI),\n\t\tv1.ResourceEphemeralStorage: *resource.NewQuantity(r.EphemeralStorage, resource.BinarySI),\n\t}\n\tfor rName, rQuant := range r.ScalarResources {\n\t\tif v1helper.IsHugePageResourceName(rName) {\n\t\t\tresult[rName] = *resource.NewQuantity(rQuant, resource.BinarySI)\n\t\t} else {\n\t\t\tresult[rName] = *resource.NewQuantity(rQuant, resource.DecimalSI)\n\t\t}\n\t}\n\treturn result\n}", "category": "Python"}, {"instruction": "// ctr mutex must be held when calling this function.", "input": "go language", "output": "func (c *client) terminateContainer(ctr *container) error {\n\tconst terminateTimeout = time.Minute * 5\n\tctr.terminateInvoked = true\n\terr := ctr.hcsContainer.Terminate()\n\n\tif hcsshim.IsPending(err) {\n\t\terr = ctr.hcsContainer.WaitTimeout(terminateTimeout)\n\t} else if hcsshim.IsAlreadyStopped(err) {\n\t\terr = nil\n\t}\n\n\tif err != nil {\n\t\tc.logger.WithError(err).WithField(\"container\", ctr.id).\n\t\t\tDebug(\"failed to terminate container\")\n\t\treturn err\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// New initialises a ReleaseHandler.", "input": "go language", "output": "func New(version string, skipPublish, try bool) *ReleaseHandler {\n\t// When triggered from CI release branch\n\tversion = strings.TrimPrefix(version, \"release-\")\n\tversion = strings.TrimPrefix(version, \"v\")\n\trh := &ReleaseHandler{cliVersion: version, skipPublish: skipPublish, try: try}\n\n\tif try {\n\t\trh.git = func(args ...string) (string, error) {\n\t\t\tfmt.Println(\"git\", strings.Join(args, \" \"))\n\t\t\treturn \"\", nil\n\t\t}\n\t} else {\n\t\trh.git = git\n\t}\n\n\treturn rh\n}", "category": "Python"}, {"instruction": "// UnmarshalJSON implements the json.Unmarshaler interface by decoding the json\n// string values into the config fields", "input": "go language", "output": "func (n *NodeConfig) UnmarshalJSON(data []byte) error {\n\tvar confJSON nodeConfigJSON\n\tif err := json.Unmarshal(data, &confJSON); err != nil {\n\t\treturn err\n\t}\n\n\tif confJSON.ID != \"\" {\n\t\tif err := n.ID.UnmarshalText([]byte(confJSON.ID)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif confJSON.PrivateKey != \"\" {\n\t\tkey, err := hex.DecodeString(confJSON.PrivateKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprivKey, err := crypto.ToECDSA(key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tn.PrivateKey = privKey\n\t}\n\n\tn.Name = confJSON.Name\n\tn.Services = confJSON.Services\n\tn.Port = confJSON.Port\n\tn.EnableMsgEvents = confJSON.EnableMsgEvents\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// DeleteRelease uninstalls a named release and returns the response.", "input": "go language", "output": "func (h *Client) DeleteRelease(rlsName string, opts ...DeleteOption) (*rls.UninstallReleaseResponse, error) {\n\t// apply the uninstall options\n\treqOpts := h.opts\n\tfor _, opt := range opts {\n\t\topt(&reqOpts)\n\t}\n\n\tif reqOpts.dryRun {\n\t\t// In the dry run case, just see if the release exists\n\t\tr, err := h.ReleaseContent(rlsName)\n\t\tif err != nil {\n\t\t\treturn &rls.UninstallReleaseResponse{}, err\n\t\t}\n\t\treturn &rls.UninstallReleaseResponse{Release: r.Release}, nil\n\t}\n\n\treq := &reqOpts.uninstallReq\n\treq.Name = rlsName\n\treq.DisableHooks = reqOpts.disableHooks\n\tctx := NewContext()\n\n\tif reqOpts.before != nil {\n\t\tif err := reqOpts.before(ctx, req); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn h.delete(ctx, req)\n}", "category": "Python"}, {"instruction": "// SubscribeFilterLogs subscribes to the results of a streaming filter query.", "input": "go language", "output": "func (ec *EthereumClient) SubscribeFilterLogs(ctx *Context, query *FilterQuery, handler FilterLogsHandler, buffer int) (sub *Subscription, _ error) {\n\t// Subscribe to the event internally\n\tch := make(chan types.Log, buffer)\n\trawSub, err := ec.client.SubscribeFilterLogs(ctx.context, query.query, ch)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Start up a dispatcher to feed into the callback\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase log := <-ch:\n\t\t\t\thandler.OnFilterLogs(&Log{&log})\n\n\t\t\tcase err := <-rawSub.Err():\n\t\t\t\tif err != nil {\n\t\t\t\t\thandler.OnError(err.Error())\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\treturn &Subscription{rawSub}, nil\n}", "category": "Python"}, {"instruction": "// check opts for OpenStack", "input": "go language", "output": "func checkOpenStackOpts(openstackOpts *OpenStack) error {\n\tlbOpts := openstackOpts.lbOpts\n\n\t// if need to create health monitor for Neutron LB,\n\t// monitor-delay, monitor-timeout and monitor-max-retries should be set.\n\temptyDuration := MyDuration{}\n\tif lbOpts.CreateMonitor {\n\t\tif lbOpts.MonitorDelay == emptyDuration {\n\t\t\treturn fmt.Errorf(\"monitor-delay not set in cloud provider config\")\n\t\t}\n\t\tif lbOpts.MonitorTimeout == emptyDuration {\n\t\t\treturn fmt.Errorf(\"monitor-timeout not set in cloud provider config\")\n\t\t}\n\t\tif lbOpts.MonitorMaxRetries == uint(0) {\n\t\t\treturn fmt.Errorf(\"monitor-max-retries not set in cloud provider config\")\n\t\t}\n\t}\n\treturn checkMetadataSearchOrder(openstackOpts.metadataOpts.SearchOrder)\n}", "category": "Python"}, {"instruction": "// WaitForObservedDeployment polls for deployment to be updated so that deployment.Status.ObservedGeneration >= desiredGeneration.\n// Returns error if polling timesout.", "input": "go language", "output": "func WaitForObservedDeployment(getDeploymentFunc func() (*apps.Deployment, error), desiredGeneration int64, interval, timeout time.Duration) error {\n\t// TODO: This should take clientset.Interface when all code is updated to use clientset. Keeping it this way allows the function to be used by callers who have client.Interface.\n\treturn wait.PollImmediate(interval, timeout, func() (bool, error) {\n\t\tdeployment, err := getDeploymentFunc()\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn deployment.Status.ObservedGeneration >= desiredGeneration, nil\n\t})\n}", "category": "Python"}, {"instruction": "// resolveReceipts returns the list of receipts for this block, fetching them\n// if necessary.", "input": "go language", "output": "func (b *Block) resolveReceipts(ctx context.Context) ([]*types.Receipt, error) {\n\tif b.receipts == nil {\n\t\thash := b.hash\n\t\tif hash == (common.Hash{}) {\n\t\t\theader, err := b.resolveHeader(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\thash = header.Hash()\n\t\t}\n\n\t\treceipts, err := b.backend.GetReceipts(ctx, hash)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tb.receipts = []*types.Receipt(receipts)\n\t}\n\treturn b.receipts, nil\n}", "category": "Python"}, {"instruction": "// HandleDelete handles a DELETE request to bzz:/<manifest>/<path>, removes\n// <path> from <manifest> and returns the resulting manifest hash as a\n// text/plain response", "input": "go language", "output": "func (s *Server) HandleDelete(w http.ResponseWriter, r *http.Request) {\n\truid := GetRUID(r.Context())\n\turi := GetURI(r.Context())\n\tlog.Debug(\"handle.delete\", \"ruid\", ruid)\n\tdeleteCount.Inc(1)\n\tnewKey, err := s.api.Delete(r.Context(), uri.Addr, uri.Path)\n\tif err != nil {\n\t\tdeleteFail.Inc(1)\n\t\trespondError(w, r, fmt.Sprintf(\"could not delete from manifest: %v\", err), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprint(w, newKey)\n}", "category": "Python"}, {"instruction": "// NewServer initializes and configures a kubelet.Server object to handle HTTP requests.", "input": "go language", "output": "func NewServer(\n\thost HostInterface,\n\tresourceAnalyzer stats.ResourceAnalyzer,\n\tauth AuthInterface,\n\tenableDebuggingHandlers,\n\tenableContentionProfiling,\n\tredirectContainerStreaming bool,\n\tcriHandler http.Handler) Server {\n\tserver := Server{\n\t\thost:                       host,\n\t\tresourceAnalyzer:           resourceAnalyzer,\n\t\tauth:                       auth,\n\t\trestfulCont:                &filteringContainer{Container: restful.NewContainer()},\n\t\tredirectContainerStreaming: redirectContainerStreaming,\n\t}\n\tif auth != nil {\n\t\tserver.InstallAuthFilter()\n\t}\n\tserver.InstallDefaultHandlers()\n\tif enableDebuggingHandlers {\n\t\tserver.InstallDebuggingHandlers(criHandler)\n\t\tif enableContentionProfiling {\n\t\t\tgoruntime.SetBlockProfileRate(1)\n\t\t}\n\t} else {\n\t\tserver.InstallDebuggingDisabledHandlers()\n\t}\n\treturn server\n}", "category": "Python"}, {"instruction": "// IsFullyQualifiedName checks if the name is fully qualified.", "input": "go language", "output": "func IsFullyQualifiedName(fldPath *field.Path, name string) field.ErrorList {\n\tvar allErrors field.ErrorList\n\tif len(name) == 0 {\n\t\treturn append(allErrors, field.Required(fldPath, \"\"))\n\t}\n\tif errs := IsDNS1123Subdomain(name); len(errs) > 0 {\n\t\treturn append(allErrors, field.Invalid(fldPath, name, strings.Join(errs, \",\")))\n\t}\n\tif len(strings.Split(name, \".\")) < 3 {\n\t\treturn append(allErrors, field.Invalid(fldPath, name, \"should be a domain with at least three segments separated by dots\"))\n\t}\n\treturn allErrors\n}", "category": "Python"}, {"instruction": "// itemFromIterator returns the Item from the current iterator position.\n// If the complete encoded key does not start with totalPrefix,\n// leveldb.ErrNotFound is returned. Value for totalPrefix must start with\n// Index prefix.", "input": "go language", "output": "func (f Index) itemFromIterator(it iterator.Iterator, totalPrefix []byte) (i Item, err error) {\n\tkey := it.Key()\n\tif !bytes.HasPrefix(key, totalPrefix) {\n\t\treturn i, leveldb.ErrNotFound\n\t}\n\t// create a copy of key byte slice not to share leveldb underlaying slice array\n\tkeyItem, err := f.decodeKeyFunc(append([]byte(nil), key...))\n\tif err != nil {\n\t\treturn i, err\n\t}\n\t// create a copy of value byte slice not to share leveldb underlaying slice array\n\tvalueItem, err := f.decodeValueFunc(keyItem, append([]byte(nil), it.Value()...))\n\tif err != nil {\n\t\treturn i, err\n\t}\n\treturn keyItem.Merge(valueItem), it.Error()\n}", "category": "Python"}, {"instruction": "// applyLayerHandler parses a diff in the standard layer format from `layer`, and\n// applies it to the directory `dest`. Returns the size in bytes of the\n// contents of the layer.", "input": "go language", "output": "func applyLayerHandler(dest string, layer io.Reader, options *archive.TarOptions, decompress bool) (size int64, err error) {\n\tdest = filepath.Clean(dest)\n\n\t// Ensure it is a Windows-style volume path\n\tdest = longpath.AddPrefix(dest)\n\n\tif decompress {\n\t\tdecompressed, err := archive.DecompressStream(layer)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tdefer decompressed.Close()\n\n\t\tlayer = decompressed\n\t}\n\n\ttmpDir, err := ioutil.TempDir(os.Getenv(\"temp\"), \"temp-docker-extract\")\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"ApplyLayer failed to create temp-docker-extract under %s. %s\", dest, err)\n\t}\n\n\ts, err := archive.UnpackLayer(dest, layer, nil)\n\tos.RemoveAll(tmpDir)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"ApplyLayer %s failed UnpackLayer to %s: %s\", layer, dest, err)\n\t}\n\n\treturn s, nil\n}", "category": "Python"}, {"instruction": "// processed updates the client buffer according to actual request cost after\n// serving has been finished.\n//\n// Note: processed should always be called for all accepted requests", "input": "go language", "output": "func (cm *ClientManager) processed(node *ClientNode, maxCost, realCost uint64, now mclock.AbsTime) {\n\tcm.lock.Lock()\n\tdefer cm.lock.Unlock()\n\n\tif realCost > maxCost {\n\t\trealCost = maxCost\n\t}\n\tcm.updateNodeRc(node, int64(maxCost-realCost), &node.params, now)\n\tif uint64(node.corrBufValue) > node.bufValue {\n\t\tif node.log != nil {\n\t\t\tnode.log.add(now, fmt.Sprintf(\"corrected  bv=%d  oldBv=%d\", node.corrBufValue, node.bufValue))\n\t\t}\n\t\tnode.bufValue = uint64(node.corrBufValue)\n\t}\n}", "category": "Python"}, {"instruction": "// This is is just some helpers used to create some JSON used in the Hugo docs.", "input": "go language", "output": "func init() {\n\n\tdocsProvider := func() map[string]interface{} {\n\t\tdocs := make(map[string]interface{})\n\n\t\tvar chromaLexers []interface{}\n\n\t\tsort.Sort(lexers.Registry.Lexers)\n\n\t\tfor _, l := range lexers.Registry.Lexers {\n\n\t\t\tconfig := l.Config()\n\n\t\t\tvar filenames []string\n\t\t\tfilenames = append(filenames, config.Filenames...)\n\t\t\tfilenames = append(filenames, config.AliasFilenames...)\n\n\t\t\taliases := config.Aliases\n\n\t\t\tfor _, filename := range filenames {\n\t\t\t\talias := strings.TrimSpace(strings.TrimPrefix(filepath.Ext(filename), \".\"))\n\t\t\t\tif alias != \"\" {\n\t\t\t\t\taliases = append(aliases, alias)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsort.Strings(aliases)\n\t\t\taliases = UniqueStrings(aliases)\n\n\t\t\tlexerEntry := struct {\n\t\t\t\tName    string\n\t\t\t\tAliases []string\n\t\t\t}{\n\t\t\t\tconfig.Name,\n\t\t\t\taliases,\n\t\t\t}\n\n\t\t\tchromaLexers = append(chromaLexers, lexerEntry)\n\n\t\t\tdocs[\"lexers\"] = chromaLexers\n\t\t}\n\t\treturn docs\n\n\t}\n\n\tdocshelper.AddDocProvider(\"chroma\", docsProvider)\n}", "category": "Python"}, {"instruction": "// CopyMatchingTag copies fields tagged tag:\"value\" from \"from\" struct onto \"to\" struct.", "input": "go language", "output": "func CopyMatchingTag(from interface{}, to interface{}, tag string, shouldCopy func(value string) bool) {\n\tfromStruct := reflect.ValueOf(from).Elem()\n\tfromType := fromStruct.Type()\n\n\ttoStruct := reflect.ValueOf(to).Elem()\n\ttoType := toStruct.Type()\n\n\tif fromType != toType {\n\t\tpanic(fmt.Sprintf(\"non equal types: %s != %s\", fromType, toType))\n\t}\n\n\tfor i := 0; i < toStruct.NumField(); i++ {\n\t\tfromField := fromStruct.Field(i)\n\t\ttoField := toStruct.Field(i)\n\n\t\tif !toField.CanSet() {\n\t\t\t// Unexported fields\n\t\t\tcontinue\n\t\t}\n\n\t\tstructTag := toType.Field(i).Tag\n\n\t\tv := structTag.Get(tag)\n\t\tif shouldCopy(v) {\n\t\t\ttoField.Set(fromField)\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// signpackageCmd returns the cobra command for signing a package", "input": "go language", "output": "func signpackageCmd(cf *ChaincodeCmdFactory) *cobra.Command {\n\tspCmd := &cobra.Command{\n\t\tUse:       \"signpackage\",\n\t\tShort:     \"Sign the specified chaincode package\",\n\t\tLong:      \"Sign the specified chaincode package\",\n\t\tValidArgs: []string{\"2\"},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tif len(args) < 2 {\n\t\t\t\treturn fmt.Errorf(\"peer chaincode signpackage <inputpackage> <outputpackage>\")\n\t\t\t}\n\t\t\treturn signpackage(cmd, args[0], args[1], cf)\n\t\t},\n\t}\n\n\treturn spCmd\n}", "category": "Python"}, {"instruction": "// PrintSections prints the given names flag sets in sections, with the maximal given column number.\n// If cols is zero, lines are not wrapped.", "input": "go language", "output": "func PrintSections(w io.Writer, fss NamedFlagSets, cols int) {\n\tfor _, name := range fss.Order {\n\t\tfs := fss.FlagSets[name]\n\t\tif !fs.HasFlags() {\n\t\t\tcontinue\n\t\t}\n\n\t\twideFS := pflag.NewFlagSet(\"\", pflag.ExitOnError)\n\t\twideFS.AddFlagSet(fs)\n\n\t\tvar zzz string\n\t\tif cols > 24 {\n\t\t\tzzz = strings.Repeat(\"z\", cols-24)\n\t\t\twideFS.Int(zzz, 0, strings.Repeat(\"z\", cols-24))\n\t\t}\n\n\t\tvar buf bytes.Buffer\n\t\tfmt.Fprintf(&buf, \"\\n%s flags:\\n\\n%s\", strings.ToUpper(name[:1])+name[1:], wideFS.FlagUsagesWrapped(cols))\n\n\t\tif cols > 24 {\n\t\t\ti := strings.Index(buf.String(), zzz)\n\t\t\tlines := strings.Split(buf.String()[:i], \"\\n\")\n\t\t\tfmt.Fprint(w, strings.Join(lines[:len(lines)-1], \"\\n\"))\n\t\t\tfmt.Fprintln(w)\n\t\t} else {\n\t\t\tfmt.Fprint(w, buf.String())\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// PrivateKeyToEncryptedPEM converts a private key to an encrypted PEM", "input": "go language", "output": "func PrivateKeyToEncryptedPEM(privateKey interface{}, pwd []byte) ([]byte, error) {\n\tif privateKey == nil {\n\t\treturn nil, errors.New(\"Invalid private key. It must be different from nil.\")\n\t}\n\n\tswitch k := privateKey.(type) {\n\tcase *ecdsa.PrivateKey:\n\t\tif k == nil {\n\t\t\treturn nil, errors.New(\"Invalid ecdsa private key. It must be different from nil.\")\n\t\t}\n\t\traw, err := x509.MarshalECPrivateKey(k)\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tblock, err := x509.EncryptPEMBlock(\n\t\t\trand.Reader,\n\t\t\t\"PRIVATE KEY\",\n\t\t\traw,\n\t\t\tpwd,\n\t\t\tx509.PEMCipherAES256)\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn pem.EncodeToMemory(block), nil\n\n\tdefault:\n\t\treturn nil, errors.New(\"Invalid key type. It must be *ecdsa.PrivateKey\")\n\t}\n}", "category": "Python"}, {"instruction": "// Unlock network operations for a specific pod.  The reference count for the\n// pod will be decreased.  If the reference count reaches zero, the pod will be\n// removed from the pod map.", "input": "go language", "output": "func (pm *PluginManager) podUnlock(fullPodName string) {\n\tpm.podsLock.Lock()\n\tdefer pm.podsLock.Unlock()\n\n\tlock, ok := pm.pods[fullPodName]\n\tif !ok {\n\t\tklog.Warningf(\"Unbalanced pod lock unref for %s\", fullPodName)\n\t\treturn\n\t} else if lock.refcount == 0 {\n\t\t// This should never ever happen, but handle it anyway\n\t\tdelete(pm.pods, fullPodName)\n\t\tklog.Warningf(\"Pod lock for %s still in map with zero refcount\", fullPodName)\n\t\treturn\n\t}\n\tlock.refcount--\n\tlock.mu.Unlock()\n\tif lock.refcount == 0 {\n\t\tdelete(pm.pods, fullPodName)\n\t}\n}", "category": "Python"}, {"instruction": "// PrepareForUpdate clears fields that are not allowed to be set by end users on update.", "input": "go language", "output": "func (networkPolicyStrategy) PrepareForUpdate(ctx context.Context, obj, old runtime.Object) {\n\tnewNetworkPolicy := obj.(*networking.NetworkPolicy)\n\toldNetworkPolicy := old.(*networking.NetworkPolicy)\n\n\t// Any changes to the spec increment the generation number, any changes to the\n\t// status should reflect the generation number of the corresponding object.\n\t// See metav1.ObjectMeta description for more information on Generation.\n\tif !reflect.DeepEqual(oldNetworkPolicy.Spec, newNetworkPolicy.Spec) {\n\t\tnewNetworkPolicy.Generation = oldNetworkPolicy.Generation + 1\n\t}\n}", "category": "Python"}, {"instruction": "// Next moves the iterator to the next node, returning whether there are any\n// further nodes. In case of an internal error this method returns false and\n// sets the Error field to the encountered failure. If `descend` is false,\n// skips iterating over any subnodes of the current node.", "input": "go language", "output": "func (it *nodeIterator) Next(descend bool) bool {\n\tif it.err == errIteratorEnd {\n\t\treturn false\n\t}\n\tif seek, ok := it.err.(seekError); ok {\n\t\tif it.err = it.seek(seek.key); it.err != nil {\n\t\t\treturn false\n\t\t}\n\t}\n\t// Otherwise step forward with the iterator and report any errors.\n\tstate, parentIndex, path, err := it.peek(descend)\n\tit.err = err\n\tif it.err != nil {\n\t\treturn false\n\t}\n\tit.push(state, parentIndex, path)\n\treturn true\n}", "category": "Python"}, {"instruction": "// Sender returns the address derived from the signature (V, R, S) using secp256k1\n// elliptic curve and an error if it failed deriving or upon an incorrect\n// signature.\n//\n// Sender may cache the address, allowing it to be used regardless of\n// signing method. The cache is invalidated if the cached signer does\n// not match the signer used in the current call.", "input": "go language", "output": "func Sender(signer Signer, tx *Transaction) (common.Address, error) {\n\tif sc := tx.from.Load(); sc != nil {\n\t\tsigCache := sc.(sigCache)\n\t\t// If the signer used to derive from in a previous\n\t\t// call is not the same as used current, invalidate\n\t\t// the cache.\n\t\tif sigCache.signer.Equal(signer) {\n\t\t\treturn sigCache.from, nil\n\t\t}\n\t}\n\n\taddr, err := signer.Sender(tx)\n\tif err != nil {\n\t\treturn common.Address{}, err\n\t}\n\ttx.from.Store(sigCache{signer: signer, from: addr})\n\treturn addr, nil\n}", "category": "Python"}, {"instruction": "// StoreResult stores the retrieved data in local database", "input": "go language", "output": "func (req *BloomRequest) StoreResult(db ethdb.Database) {\n\tfor i, sectionIdx := range req.SectionIndexList {\n\t\tsectionHead := rawdb.ReadCanonicalHash(db, (sectionIdx+1)*req.Config.BloomTrieSize-1)\n\t\t// if we don't have the canonical hash stored for this section head number, we'll still store it under\n\t\t// a key with a zero sectionHead. GetBloomBits will look there too if we still don't have the canonical\n\t\t// hash. In the unlikely case we've retrieved the section head hash since then, we'll just retrieve the\n\t\t// bit vector again from the network.\n\t\trawdb.WriteBloomBits(db, req.BitIdx, sectionIdx, sectionHead, req.BloomBits[i])\n\t}\n}", "category": "Python"}, {"instruction": "// IpcMounts returns the list of IPC mounts", "input": "go language", "output": "func (container *Container) IpcMounts() []Mount {\n\tvar mounts []Mount\n\tparser := volumemounts.NewParser(container.OS)\n\n\tif container.HasMountFor(\"/dev/shm\") {\n\t\treturn mounts\n\t}\n\tif container.ShmPath == \"\" {\n\t\treturn mounts\n\t}\n\n\tlabel.SetFileLabel(container.ShmPath, container.MountLabel)\n\tmounts = append(mounts, Mount{\n\t\tSource:      container.ShmPath,\n\t\tDestination: \"/dev/shm\",\n\t\tWritable:    true,\n\t\tPropagation: string(parser.DefaultPropagationMode()),\n\t})\n\n\treturn mounts\n}", "category": "Python"}, {"instruction": "// GraphNodeReferenceOutside implementation", "input": "go language", "output": "func (n *NodeApplyableModuleVariable) ReferenceOutside() (selfPath, referencePath addrs.ModuleInstance) {\n\n\t// Module input variables have their value expressions defined in the\n\t// context of their calling (parent) module, and so references from\n\t// a node of this type should be resolved in the parent module instance.\n\treferencePath = n.Addr.Module.Parent()\n\n\t// Input variables are _referenced_ from their own module, though.\n\tselfPath = n.Addr.Module\n\n\treturn // uses named return values\n}", "category": "Python"}, {"instruction": "// Modify modifies a JSON object by insert, replace or set.\n// All path expressions cannot contain * or ** wildcard.\n// If any error occurs, the input won't be changed.", "input": "go language", "output": "func (bj BinaryJSON) Modify(pathExprList []PathExpression, values []BinaryJSON, mt ModifyType) (retj BinaryJSON, err error) {\n\tif len(pathExprList) != len(values) {\n\t\t// TODO: should return 1582(42000)\n\t\treturn retj, errors.New(\"Incorrect parameter count\")\n\t}\n\tfor _, pathExpr := range pathExprList {\n\t\tif pathExpr.flags.containsAnyAsterisk() {\n\t\t\t// TODO: should return 3149(42000)\n\t\t\treturn retj, errors.New(\"Invalid path expression\")\n\t\t}\n\t}\n\tfor i := 0; i < len(pathExprList); i++ {\n\t\tpathExpr, value := pathExprList[i], values[i]\n\t\tmodifier := &binaryModifier{bj: bj}\n\t\tswitch mt {\n\t\tcase ModifyInsert:\n\t\t\tbj = modifier.insert(pathExpr, value)\n\t\tcase ModifyReplace:\n\t\t\tbj = modifier.replace(pathExpr, value)\n\t\tcase ModifySet:\n\t\t\tbj = modifier.set(pathExpr, value)\n\t\t}\n\t}\n\treturn bj, nil\n}", "category": "Python"}, {"instruction": "// NewDeleteCommandFlags provides default flags and values for use with the \"delete\" command", "input": "go language", "output": "func NewDeleteCommandFlags(usage string) *DeleteFlags {\n\tcascade := true\n\tgracePeriod := -1\n\n\t// setup command defaults\n\tall := false\n\tallNamespaces := false\n\tforce := false\n\tignoreNotFound := false\n\tnow := false\n\toutput := \"\"\n\tlabelSelector := \"\"\n\tfieldSelector := \"\"\n\ttimeout := time.Duration(0)\n\twait := true\n\n\tfilenames := []string{}\n\trecursive := false\n\tkustomize := \"\"\n\n\treturn &DeleteFlags{\n\t\t// Not using helpers.go since it provides function to add '-k' for FileNameOptions, but not FileNameFlags\n\t\tFileNameFlags: &genericclioptions.FileNameFlags{Usage: usage, Filenames: &filenames, Kustomize: &kustomize, Recursive: &recursive},\n\t\tLabelSelector: &labelSelector,\n\t\tFieldSelector: &fieldSelector,\n\n\t\tCascade:     &cascade,\n\t\tGracePeriod: &gracePeriod,\n\n\t\tAll:            &all,\n\t\tAllNamespaces:  &allNamespaces,\n\t\tForce:          &force,\n\t\tIgnoreNotFound: &ignoreNotFound,\n\t\tNow:            &now,\n\t\tTimeout:        &timeout,\n\t\tWait:           &wait,\n\t\tOutput:         &output,\n\t}\n}", "category": "Python"}, {"instruction": "// Equal normalizes two URLs and then compares for equality.", "input": "go language", "output": "func Equal(a, b string) bool {\n\tau, err := url.Parse(a)\n\tif err != nil {\n\t\ta = filepath.Clean(a)\n\t\tb = filepath.Clean(b)\n\t\t// If urls are paths, return true only if they are an exact match\n\t\treturn a == b\n\t}\n\tbu, err := url.Parse(b)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tfor _, u := range []*url.URL{au, bu} {\n\t\tif u.Path == \"\" {\n\t\t\tu.Path = \"/\"\n\t\t}\n\t\tu.Path = filepath.Clean(u.Path)\n\t}\n\treturn au.String() == bu.String()\n}", "category": "Python"}, {"instruction": "// estimateGracefulTerminationForPods determines the graceful termination period for pods in the namespace", "input": "go language", "output": "func (d *namespacedResourcesDeleter) estimateGracefulTerminationForPods(ns string) (int64, error) {\n\tklog.V(5).Infof(\"namespace controller - estimateGracefulTerminationForPods - namespace %s\", ns)\n\testimate := int64(0)\n\tpodsGetter := d.podsGetter\n\tif podsGetter == nil || reflect.ValueOf(podsGetter).IsNil() {\n\t\treturn estimate, fmt.Errorf(\"unexpected: podsGetter is nil. Cannot estimate grace period seconds for pods\")\n\t}\n\titems, err := podsGetter.Pods(ns).List(metav1.ListOptions{})\n\tif err != nil {\n\t\treturn estimate, err\n\t}\n\tfor i := range items.Items {\n\t\tpod := items.Items[i]\n\t\t// filter out terminal pods\n\t\tphase := pod.Status.Phase\n\t\tif v1.PodSucceeded == phase || v1.PodFailed == phase {\n\t\t\tcontinue\n\t\t}\n\t\tif pod.Spec.TerminationGracePeriodSeconds != nil {\n\t\t\tgrace := *pod.Spec.TerminationGracePeriodSeconds\n\t\t\tif grace > estimate {\n\t\t\t\testimate = grace\n\t\t\t}\n\t\t}\n\t}\n\treturn estimate, nil\n}", "category": "Python"}, {"instruction": "// Consensus passes the given ConsensusRequest message to the raft.Node instance.", "input": "go language", "output": "func (s *RPC) SendConsensus(destination uint64, msg *orderer.ConsensusRequest) error {\n\tif s.Logger.IsEnabledFor(zapcore.DebugLevel) {\n\t\tdefer s.consensusSent(time.Now(), destination, msg)\n\t}\n\n\tstream, err := s.getOrCreateStream(destination, ConsensusOperation)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq := &orderer.StepRequest{\n\t\tPayload: &orderer.StepRequest_ConsensusRequest{\n\t\t\tConsensusRequest: msg,\n\t\t},\n\t}\n\n\ts.consensusLock.Lock()\n\tdefer s.consensusLock.Unlock()\n\n\terr = stream.Send(req)\n\tif err != nil {\n\t\ts.unMapStream(destination, ConsensusOperation)\n\t}\n\n\treturn err\n}", "category": "Python"}, {"instruction": "// podDiskUsage aggregates pod disk usage and inode consumption for the specified stats to measure.", "input": "go language", "output": "func podDiskUsage(podStats statsapi.PodStats, pod *v1.Pod, statsToMeasure []fsStatsType) (v1.ResourceList, error) {\n\tdisk := resource.Quantity{Format: resource.BinarySI}\n\tinodes := resource.Quantity{Format: resource.DecimalSI}\n\n\tcontainerUsageList := containerUsage(podStats, statsToMeasure)\n\tdisk.Add(containerUsageList[v1.ResourceEphemeralStorage])\n\tinodes.Add(containerUsageList[resourceInodes])\n\n\tif hasFsStatsType(statsToMeasure, fsStatsLocalVolumeSource) {\n\t\tvolumeNames := localVolumeNames(pod)\n\t\tpodLocalVolumeUsageList := podLocalVolumeUsage(volumeNames, podStats)\n\t\tdisk.Add(podLocalVolumeUsageList[v1.ResourceEphemeralStorage])\n\t\tinodes.Add(podLocalVolumeUsageList[resourceInodes])\n\t}\n\treturn v1.ResourceList{\n\t\tv1.ResourceEphemeralStorage: disk,\n\t\tresourceInodes:              inodes,\n\t}, nil\n}", "category": "Python"}, {"instruction": "//TODO: need to finish the method to get the rules when using webhook mode", "input": "go language", "output": "func (w *WebhookAuthorizer) RulesFor(user user.Info, namespace string) ([]authorizer.ResourceRuleInfo, []authorizer.NonResourceRuleInfo, bool, error) {\n\tvar (\n\t\tresourceRules    []authorizer.ResourceRuleInfo\n\t\tnonResourceRules []authorizer.NonResourceRuleInfo\n\t)\n\tincomplete := true\n\treturn resourceRules, nonResourceRules, incomplete, fmt.Errorf(\"webhook authorizer does not support user rule resolution\")\n}", "category": "Python"}, {"instruction": "// Decode unmarshals the raw representation of the instance object being\n// changed. Pass the implied type of the corresponding resource type schema\n// for correct operation.", "input": "go language", "output": "func (rcs *ResourceInstanceChangeSrc) Decode(ty cty.Type) (*ResourceInstanceChange, error) {\n\tchange, err := rcs.ChangeSrc.Decode(ty)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &ResourceInstanceChange{\n\t\tAddr:            rcs.Addr,\n\t\tDeposedKey:      rcs.DeposedKey,\n\t\tProviderAddr:    rcs.ProviderAddr,\n\t\tChange:          *change,\n\t\tRequiredReplace: rcs.RequiredReplace,\n\t\tPrivate:         rcs.Private,\n\t}, nil\n}", "category": "Python"}, {"instruction": "// GetProposalHash1 gets the proposal hash bytes after sanitizing the\n// chaincode proposal payload according to the rules of visibility", "input": "go language", "output": "func GetProposalHash1(header *common.Header, ccPropPayl []byte, visibility []byte) ([]byte, error) {\n\t// check for nil argument\n\tif header == nil ||\n\t\theader.ChannelHeader == nil ||\n\t\theader.SignatureHeader == nil ||\n\t\tccPropPayl == nil {\n\t\treturn nil, errors.New(\"nil arguments\")\n\t}\n\n\t// unmarshal the chaincode proposal payload\n\tcpp, err := GetChaincodeProposalPayload(ccPropPayl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tppBytes, err := GetBytesProposalPayloadForTx(cpp, visibility)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thash2, err := factory.GetDefault().GetHash(&bccsp.SHA256Opts{})\n\tif err != nil {\n\t\treturn nil, errors.WithMessage(err, \"error instantiating hash function\")\n\t}\n\t// hash the serialized Channel Header object\n\thash2.Write(header.ChannelHeader)\n\t// hash the serialized Signature Header object\n\thash2.Write(header.SignatureHeader)\n\t// hash of the part of the chaincode proposal payload that will go to the tx\n\thash2.Write(ppBytes)\n\treturn hash2.Sum(nil), nil\n}", "category": "Python"}, {"instruction": "// rewriteWithPreprocess is for handling the situation that we need to adjust the input ast tree\n// before really using its node in `expressionRewriter.Leave`. In that case, we first call\n// er.preprocess(expr), which returns a new expr. Then we use the new expr in `Leave`.", "input": "go language", "output": "func (b *PlanBuilder) rewriteWithPreprocess(exprNode ast.ExprNode, p LogicalPlan, aggMapper map[*ast.AggregateFuncExpr]int, asScalar bool, preprocess func(ast.Node) ast.Node) (expression.Expression, LogicalPlan, error) {\n\tb.rewriterCounter++\n\tdefer func() { b.rewriterCounter-- }()\n\n\trewriter := b.getExpressionRewriter(p)\n\t// The rewriter maybe is obtained from \"b.rewriterPool\", \"rewriter.err\" is\n\t// not nil means certain previous procedure has not handled this error.\n\t// Here we give us one more chance to make a correct behavior by handling\n\t// this missed error.\n\tif rewriter.err != nil {\n\t\treturn nil, nil, rewriter.err\n\t}\n\n\trewriter.aggrMap = aggMapper\n\trewriter.asScalar = asScalar\n\trewriter.preprocess = preprocess\n\n\texpr, resultPlan, err := b.rewriteExprNode(rewriter, exprNode, asScalar)\n\treturn expr, resultPlan, err\n}", "category": "Python"}, {"instruction": "// expandOptionalAddrs expands the go-sockaddr template in s and returns the\n// result as a list of strings. If s does not contain a go-sockaddr template,\n// the result list will contain the input string as a single element with no\n// error set. In contrast to expandAddrs, expandOptionalAddrs does not validate\n// if the result contains valid addresses and returns a list of strings.\n// However, if the expansion of the go-sockaddr template fails an error is set.", "input": "go language", "output": "func (b *Builder) expandOptionalAddrs(name string, s *string) []string {\n\tif s == nil || *s == \"\" {\n\t\treturn nil\n\t}\n\n\tx, err := template.Parse(*s)\n\tif err != nil {\n\t\tb.err = multierror.Append(b.err, fmt.Errorf(\"%s: error parsing %q: %s\", name, *s, err))\n\t\treturn nil\n\t}\n\n\tif x != *s {\n\t\t// A template has been expanded, split the results from go-sockaddr\n\t\treturn strings.Fields(x)\n\t} else {\n\t\t// No template has been expanded, pass through the input\n\t\treturn []string{*s}\n\t}\n}", "category": "Python"}, {"instruction": "// MarkForFSResize marks pvc with condition that indicates a fs resize is pending", "input": "go language", "output": "func (resizeMap *volumeResizeMap) MarkForFSResize(pvcr *PVCWithResizeRequest) error {\n\tpvcCondition := v1.PersistentVolumeClaimCondition{\n\t\tType:               v1.PersistentVolumeClaimFileSystemResizePending,\n\t\tStatus:             v1.ConditionTrue,\n\t\tLastTransitionTime: metav1.Now(),\n\t\tMessage:            \"Waiting for user to (re-)start a pod to finish file system resize of volume on node.\",\n\t}\n\tconditions := []v1.PersistentVolumeClaimCondition{pvcCondition}\n\tnewPVC := pvcr.PVC.DeepCopy()\n\tnewPVC = util.MergeResizeConditionOnPVC(newPVC, conditions)\n\t_, err := util.PatchPVCStatus(pvcr.PVC /*oldPVC*/, newPVC, resizeMap.kubeClient)\n\treturn err\n}", "category": "Python"}, {"instruction": "// ValidateFinalizers tests if the finalizers name are valid, and if there are conflicting finalizers.", "input": "go language", "output": "func ValidateFinalizers(finalizers []string, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\thasFinalizerOrphanDependents := false\n\thasFinalizerDeleteDependents := false\n\tfor _, finalizer := range finalizers {\n\t\tallErrs = append(allErrs, ValidateFinalizerName(finalizer, fldPath)...)\n\t\tif finalizer == metav1.FinalizerOrphanDependents {\n\t\t\thasFinalizerOrphanDependents = true\n\t\t}\n\t\tif finalizer == metav1.FinalizerDeleteDependents {\n\t\t\thasFinalizerDeleteDependents = true\n\t\t}\n\t}\n\tif hasFinalizerDeleteDependents && hasFinalizerOrphanDependents {\n\t\tallErrs = append(allErrs, field.Invalid(fldPath, finalizers, fmt.Sprintf(\"finalizer %s and %s cannot be both set\", metav1.FinalizerOrphanDependents, metav1.FinalizerDeleteDependents)))\n\t}\n\treturn allErrs\n}", "category": "Python"}, {"instruction": "// UnmarshalJSON decodes the byte slice whether it's a string or an array of\n// strings. This method is needed to implement json.Unmarshaler.", "input": "go language", "output": "func (e *StrSlice) UnmarshalJSON(b []byte) error {\n\tif len(b) == 0 {\n\t\t// With no input, we preserve the existing value by returning nil and\n\t\t// leaving the target alone. This allows defining default values for\n\t\t// the type.\n\t\treturn nil\n\t}\n\n\tp := make([]string, 0, 1)\n\tif err := json.Unmarshal(b, &p); err != nil {\n\t\tvar s string\n\t\tif err := json.Unmarshal(b, &s); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tp = append(p, s)\n\t}\n\n\t*e = p\n\treturn nil\n}", "category": "Python"}, {"instruction": "// getPodSandboxID gets the sandbox id by podUID and returns ([]sandboxID, error).\n// Param state could be nil in order to get all sandboxes belonging to same pod.", "input": "go language", "output": "func (m *kubeGenericRuntimeManager) getSandboxIDByPodUID(podUID kubetypes.UID, state *runtimeapi.PodSandboxState) ([]string, error) {\n\tfilter := &runtimeapi.PodSandboxFilter{\n\t\tLabelSelector: map[string]string{types.KubernetesPodUIDLabel: string(podUID)},\n\t}\n\tif state != nil {\n\t\tfilter.State = &runtimeapi.PodSandboxStateValue{\n\t\t\tState: *state,\n\t\t}\n\t}\n\tsandboxes, err := m.runtimeService.ListPodSandbox(filter)\n\tif err != nil {\n\t\tklog.Errorf(\"ListPodSandbox with pod UID %q failed: %v\", podUID, err)\n\t\treturn nil, err\n\t}\n\n\tif len(sandboxes) == 0 {\n\t\treturn nil, nil\n\t}\n\n\t// Sort with newest first.\n\tsandboxIDs := make([]string, len(sandboxes))\n\tsort.Sort(podSandboxByCreated(sandboxes))\n\tfor i, s := range sandboxes {\n\t\tsandboxIDs[i] = s.Id\n\t}\n\n\treturn sandboxIDs, nil\n}", "category": "Python"}, {"instruction": "// newLightFetcher creates a new light fetcher", "input": "go language", "output": "func newLightFetcher(pm *ProtocolManager) *lightFetcher {\n\tf := &lightFetcher{\n\t\tpm:             pm,\n\t\tchain:          pm.blockchain.(*light.LightChain),\n\t\todr:            pm.odr,\n\t\tpeers:          make(map[*peer]*fetcherPeerInfo),\n\t\tdeliverChn:     make(chan fetchResponse, 100),\n\t\trequested:      make(map[uint64]fetchRequest),\n\t\ttimeoutChn:     make(chan uint64),\n\t\trequestChn:     make(chan bool, 100),\n\t\tsyncDone:       make(chan *peer),\n\t\tmaxConfirmedTd: big.NewInt(0),\n\t}\n\tpm.peers.notify(f)\n\n\tf.pm.wg.Add(1)\n\tgo f.syncLoop()\n\treturn f\n}", "category": "Python"}, {"instruction": "// SubmitTransaction is a helper function that submits tx to txPool and logs a message.", "input": "go language", "output": "func SubmitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) {\n\tif err := b.SendTx(ctx, tx); err != nil {\n\t\treturn common.Hash{}, err\n\t}\n\tif tx.To() == nil {\n\t\tsigner := types.MakeSigner(b.ChainConfig(), b.CurrentBlock().Number())\n\t\tfrom, err := types.Sender(signer, tx)\n\t\tif err != nil {\n\t\t\treturn common.Hash{}, err\n\t\t}\n\t\taddr := crypto.CreateAddress(from, tx.Nonce())\n\t\tlog.Info(\"Submitted contract creation\", \"fullhash\", tx.Hash().Hex(), \"contract\", addr.Hex())\n\t} else {\n\t\tlog.Info(\"Submitted transaction\", \"fullhash\", tx.Hash().Hex(), \"recipient\", tx.To())\n\t}\n\treturn tx.Hash(), nil\n}", "category": "Python"}, {"instruction": "// GetLoadBalancer returns whether the specified load balancer exists, and\n// if so, what its status is.", "input": "go language", "output": "func (az *Cloud) GetLoadBalancer(ctx context.Context, clusterName string, service *v1.Service) (status *v1.LoadBalancerStatus, exists bool, err error) {\n\t_, status, exists, err = az.getServiceLoadBalancer(service, clusterName, nil, false)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tif !exists {\n\t\tserviceName := getServiceName(service)\n\t\tklog.V(5).Infof(\"getloadbalancer (cluster:%s) (service:%s) - doesn't exist\", clusterName, serviceName)\n\t\treturn nil, false, nil\n\t}\n\treturn status, true, nil\n}", "category": "Python"}, {"instruction": "// AddSymKeyFromPassword generates the key from password, stores it, and returns its id.", "input": "go language", "output": "func (whisper *Whisper) AddSymKeyFromPassword(password string) (string, error) {\n\tid, err := GenerateRandomID()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to generate ID: %s\", err)\n\t}\n\tif whisper.HasSymKey(id) {\n\t\treturn \"\", fmt.Errorf(\"failed to generate unique ID\")\n\t}\n\n\t// kdf should run no less than 0.1 seconds on an average computer,\n\t// because it's an once in a session experience\n\tderived := pbkdf2.Key([]byte(password), nil, 65356, aesKeyLength, sha256.New)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\twhisper.keyMu.Lock()\n\tdefer whisper.keyMu.Unlock()\n\n\t// double check is necessary, because deriveKeyMaterial() is very slow\n\tif whisper.symKeys[id] != nil {\n\t\treturn \"\", fmt.Errorf(\"critical error: failed to generate unique ID\")\n\t}\n\twhisper.symKeys[id] = derived\n\treturn id, nil\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *SubjectAccessReviewSpec) DeepCopyInto(out *SubjectAccessReviewSpec) {\n\t*out = *in\n\tif in.ResourceAttributes != nil {\n\t\tin, out := &in.ResourceAttributes, &out.ResourceAttributes\n\t\t*out = new(ResourceAttributes)\n\t\t**out = **in\n\t}\n\tif in.NonResourceAttributes != nil {\n\t\tin, out := &in.NonResourceAttributes, &out.NonResourceAttributes\n\t\t*out = new(NonResourceAttributes)\n\t\t**out = **in\n\t}\n\tif in.Groups != nil {\n\t\tin, out := &in.Groups, &out.Groups\n\t\t*out = make([]string, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\tif in.Extra != nil {\n\t\tin, out := &in.Extra, &out.Extra\n\t\t*out = make(map[string]ExtraValue, len(*in))\n\t\tfor key, val := range *in {\n\t\t\tvar outVal []string\n\t\t\tif val == nil {\n\t\t\t\t(*out)[key] = nil\n\t\t\t} else {\n\t\t\t\tin, out := &val, &outVal\n\t\t\t\t*out = make(ExtraValue, len(*in))\n\t\t\t\tcopy(*out, *in)\n\t\t\t}\n\t\t\t(*out)[key] = outVal\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// createSessionLocal is used to create a new session in a foreign datacenter\n// This is more complex since the local agent cannot be used to create\n// a session, and we must associate with a node in the remote datacenter.", "input": "go language", "output": "func (c *cmd) createSessionForeign() (string, error) {\n\t// Look for a remote node to bind to\n\thealth := c.apiclient.Health()\n\tservices, _, err := health.Service(\"consul\", \"\", true, nil)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to find Consul server in remote datacenter: %v\", err)\n\t}\n\tif len(services) == 0 {\n\t\treturn \"\", fmt.Errorf(\"Failed to find Consul server in remote datacenter\")\n\t}\n\tnode := services[0].Node.Node\n\tif c.conf.verbose {\n\t\tc.UI.Info(fmt.Sprintf(\"Binding session to remote node %s@%s\", node, c.http.Datacenter()))\n\t}\n\n\tsession := c.apiclient.Session()\n\tse := api.SessionEntry{\n\t\tName:     fmt.Sprintf(\"Remote Exec via %s@%s\", c.conf.localNode, c.conf.localDC),\n\t\tNode:     node,\n\t\tChecks:   []string{},\n\t\tBehavior: api.SessionBehaviorDelete,\n\t\tTTL:      rExecTTL,\n\t}\n\tid, _, err := session.CreateNoChecks(&se, nil)\n\treturn id, err\n}", "category": "Python"}, {"instruction": "// saveToDb saves pool status to the database storage\n// (automatically called during shutdown)", "input": "go language", "output": "func (f *freeClientPool) saveToDb() {\n\tnow := f.clock.Now()\n\tstorage := freeClientPoolStorage{\n\t\tLogOffset: uint64(f.logOffset(now)),\n\t\tList:      make([]*freeClientPoolEntry, len(f.addressMap)),\n\t}\n\ti := 0\n\tfor _, e := range f.addressMap {\n\t\tif e.connected {\n\t\t\tf.calcLogUsage(e, now)\n\t\t}\n\t\tstorage.List[i] = e\n\t\ti++\n\t}\n\tenc, err := rlp.EncodeToBytes(storage)\n\tif err != nil {\n\t\tlog.Error(\"Failed to encode client list\", \"err\", err)\n\t} else {\n\t\tf.db.Put([]byte(\"freeClientPool\"), enc)\n\t}\n}", "category": "Python"}, {"instruction": "// Dial establishes the gRPC communication with the picked up plugin socket. https://godoc.org/google.golang.org/grpc#Dial", "input": "go language", "output": "func dial(unixSocketPath string, timeout time.Duration) (registerapi.RegistrationClient, *grpc.ClientConn, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\n\tc, err := grpc.DialContext(ctx, unixSocketPath, grpc.WithInsecure(), grpc.WithBlock(),\n\t\tgrpc.WithDialer(func(addr string, timeout time.Duration) (net.Conn, error) {\n\t\t\treturn net.DialTimeout(\"unix\", addr, timeout)\n\t\t}),\n\t)\n\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to dial socket %s, err: %v\", unixSocketPath, err)\n\t}\n\n\treturn registerapi.NewRegistrationClient(c), c, nil\n}", "category": "Python"}, {"instruction": "// HasSupport verifies if the given gvk supports DryRun. An error is\n// returned if it doesn't.", "input": "go language", "output": "func (v *DryRunVerifier) HasSupport(gvk schema.GroupVersionKind) error {\n\toapi, err := v.OpenAPIGetter.OpenAPISchema()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to download openapi: %v\", err)\n\t}\n\tsupports, err := openapi.SupportsDryRun(oapi, gvk)\n\tif err != nil {\n\t\t// We assume that we couldn't find the type, then check for namespace:\n\t\tsupports, _ = openapi.SupportsDryRun(oapi, schema.GroupVersionKind{Group: \"\", Version: \"v1\", Kind: \"Namespace\"})\n\t\t// If namespace supports dryRun, then we will support dryRun for CRDs only.\n\t\tif supports {\n\t\t\tsupports, err = v.Finder.HasCRD(gvk.GroupKind())\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to check CRD: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n\tif !supports {\n\t\treturn fmt.Errorf(\"%v doesn't support dry-run\", gvk)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// returnStream is used when done with a stream\n// to allow re-use by a future RPC", "input": "go language", "output": "func (c *Conn) returnClient(client *StreamClient) {\n\tdidSave := false\n\tc.clientLock.Lock()\n\tif c.clients.Len() < c.pool.MaxStreams && atomic.LoadInt32(&c.shouldClose) == 0 {\n\t\tc.clients.PushFront(client)\n\t\tdidSave = true\n\n\t\t// If this is a Yamux stream, shrink the internal buffers so that\n\t\t// we can GC the idle memory\n\t\tif ys, ok := client.stream.(*yamux.Stream); ok {\n\t\t\tys.Shrink()\n\t\t}\n\t}\n\tc.clientLock.Unlock()\n\tif !didSave {\n\t\tclient.Close()\n\t}\n}", "category": "Python"}, {"instruction": "// cleanupStaleStickySessions cleans up any stale sticky session records in the hash map.", "input": "go language", "output": "func (proxier *Proxier) cleanupStaleStickySessions() {\n\tproxier.mu.Lock()\n\tdefer proxier.mu.Unlock()\n\tservicePortNameMap := make(map[proxy.ServicePortName]bool)\n\tfor name := range proxier.serviceMap {\n\t\tservicePortName := proxy.ServicePortName{\n\t\t\tNamespacedName: types.NamespacedName{\n\t\t\t\tNamespace: name.Namespace,\n\t\t\t\tName:      name.Name,\n\t\t\t},\n\t\t\tPort: name.Port,\n\t\t}\n\t\tif servicePortNameMap[servicePortName] == false {\n\t\t\t// ensure cleanup sticky sessions only gets called once per serviceportname\n\t\t\tservicePortNameMap[servicePortName] = true\n\t\t\tproxier.loadBalancer.CleanupStaleStickySessions(servicePortName)\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// WaitForCacheSync waits for all started informers' cache were synced.", "input": "go language", "output": "func (f *dynamicSharedInformerFactory) WaitForCacheSync(stopCh <-chan struct{}) map[schema.GroupVersionResource]bool {\n\tinformers := func() map[schema.GroupVersionResource]cache.SharedIndexInformer {\n\t\tf.lock.Lock()\n\t\tdefer f.lock.Unlock()\n\n\t\tinformers := map[schema.GroupVersionResource]cache.SharedIndexInformer{}\n\t\tfor informerType, informer := range f.informers {\n\t\t\tif f.startedInformers[informerType] {\n\t\t\t\tinformers[informerType] = informer.Informer()\n\t\t\t}\n\t\t}\n\t\treturn informers\n\t}()\n\n\tres := map[schema.GroupVersionResource]bool{}\n\tfor informType, informer := range informers {\n\t\tres[informType] = cache.WaitForCacheSync(stopCh, informer.HasSynced)\n\t}\n\treturn res\n}", "category": "Python"}, {"instruction": "// handleCall processes method calls.", "input": "go language", "output": "func (h *handler) handleCall(cp *callProc, msg *jsonrpcMessage) *jsonrpcMessage {\n\tif msg.isSubscribe() {\n\t\treturn h.handleSubscribe(cp, msg)\n\t}\n\tvar callb *callback\n\tif msg.isUnsubscribe() {\n\t\tcallb = h.unsubscribeCb\n\t} else {\n\t\tcallb = h.reg.callback(msg.Method)\n\t}\n\tif callb == nil {\n\t\treturn msg.errorResponse(&methodNotFoundError{method: msg.Method})\n\t}\n\targs, err := parsePositionalArguments(msg.Params, callb.argTypes)\n\tif err != nil {\n\t\treturn msg.errorResponse(&invalidParamsError{err.Error()})\n\t}\n\n\treturn h.runMethod(cp.ctx, msg, callb, args)\n}", "category": "Python"}, {"instruction": "// the functions below show some best practices on how\n// to use entities to perform cryptographic operations\n// over the ledger state\n// getStateAndDecrypt retrieves the value associated to key,\n// decrypts it with the supplied entity and returns the result\n// of the decryption", "input": "go language", "output": "func getStateAndDecrypt(stub shim.ChaincodeStubInterface, ent entities.Encrypter, key string) ([]byte, error) {\n\t// at first we retrieve the ciphertext from the ledger\n\tciphertext, err := stub.GetState(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// GetState will return a nil slice if the key does not exist.\n\t// Note that the chaincode logic may want to distinguish between\n\t// nil slice (key doesn't exist in state db) and empty slice\n\t// (key found in state db but value is empty). We do not\n\t// distinguish the case here\n\tif len(ciphertext) == 0 {\n\t\treturn nil, errors.New(\"no ciphertext to decrypt\")\n\t}\n\n\treturn ent.Decrypt(ciphertext)\n}", "category": "Python"}, {"instruction": "// AcceptRequest returns whether a new request can be accepted and the missing\n// buffer amount if it was rejected due to a buffer underrun. If accepted, maxCost\n// is deducted from the flow control buffer.", "input": "go language", "output": "func (node *ClientNode) AcceptRequest(reqID, index, maxCost uint64) (accepted bool, bufShort uint64, priority int64) {\n\tnode.lock.Lock()\n\tdefer node.lock.Unlock()\n\n\tnow := node.cm.clock.Now()\n\tnode.update(now)\n\tif maxCost > node.bufValue {\n\t\tif node.log != nil {\n\t\t\tnode.log.add(now, fmt.Sprintf(\"rejected  reqID=%d  bv=%d  maxCost=%d\", reqID, node.bufValue, maxCost))\n\t\t\tnode.log.dump(now)\n\t\t}\n\t\treturn false, maxCost - node.bufValue, 0\n\t}\n\tnode.bufValue -= maxCost\n\tnode.sumCost += maxCost\n\tif node.log != nil {\n\t\tnode.log.add(now, fmt.Sprintf(\"accepted  reqID=%d  bv=%d  maxCost=%d  sumCost=%d\", reqID, node.bufValue, maxCost, node.sumCost))\n\t}\n\tnode.accepted[index] = node.sumCost\n\treturn true, 0, node.cm.accepted(node, maxCost, now)\n}", "category": "Python"}, {"instruction": "// AuthenticateRequest authenticates the request using a chain of authenticator.Request objects.", "input": "go language", "output": "func (authHandler *unionAuthRequestHandler) AuthenticateRequest(req *http.Request) (*authenticator.Response, bool, error) {\n\tvar errlist []error\n\tfor _, currAuthRequestHandler := range authHandler.Handlers {\n\t\tresp, ok, err := currAuthRequestHandler.AuthenticateRequest(req)\n\t\tif err != nil {\n\t\t\tif authHandler.FailOnError {\n\t\t\t\treturn resp, ok, err\n\t\t\t}\n\t\t\terrlist = append(errlist, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif ok {\n\t\t\treturn resp, ok, err\n\t\t}\n\t}\n\n\treturn nil, false, utilerrors.NewAggregate(errlist)\n}", "category": "Python"}, {"instruction": "// Validate checks if a given ipset is valid or not.", "input": "go language", "output": "func (set *IPSet) Validate() bool {\n\t// Check if protocol is valid for `HashIPPort`, `HashIPPortIP` and `HashIPPortNet` type set.\n\tif set.SetType == HashIPPort || set.SetType == HashIPPortIP || set.SetType == HashIPPortNet {\n\t\tif valid := validateHashFamily(set.HashFamily); !valid {\n\t\t\treturn false\n\t\t}\n\t}\n\t// check set type\n\tif valid := validateIPSetType(set.SetType); !valid {\n\t\treturn false\n\t}\n\t// check port range for bitmap type set\n\tif set.SetType == BitmapPort {\n\t\tif valid := validatePortRange(set.PortRange); !valid {\n\t\t\treturn false\n\t\t}\n\t}\n\t// check hash size value of ipset\n\tif set.HashSize <= 0 {\n\t\tklog.Errorf(\"Invalid hashsize value %d, should be >0\", set.HashSize)\n\t\treturn false\n\t}\n\t// check max elem value of ipset\n\tif set.MaxElem <= 0 {\n\t\tklog.Errorf(\"Invalid maxelem value %d, should be >0\", set.MaxElem)\n\t\treturn false\n\t}\n\n\treturn true\n}", "category": "Python"}, {"instruction": "// Get the volume and node object from actual state of world\n// This is an internal function and caller should acquire and release the lock\n//\n// Note that this returns disconnected objects, so if you change the volume object you must set it back with\n// `asw.attachedVolumes[volumeName]=volumeObj`.\n//\n// If you change the node object you must use `volumeObj.nodesAttachedTo[nodeName] = nodeObj`\n// This is correct, because if volumeObj is empty this function returns an error, and nodesAttachedTo\n// map is a reference type, and thus mutating the copy changes the original map.", "input": "go language", "output": "func (asw *actualStateOfWorld) getNodeAndVolume(\n\tvolumeName v1.UniqueVolumeName, nodeName types.NodeName) (attachedVolume, nodeAttachedTo, error) {\n\n\tvolumeObj, volumeExists := asw.attachedVolumes[volumeName]\n\tif volumeExists {\n\t\tnodeObj, nodeExists := volumeObj.nodesAttachedTo[nodeName]\n\t\tif nodeExists {\n\t\t\treturn volumeObj, nodeObj, nil\n\t\t}\n\t}\n\n\treturn attachedVolume{}, nodeAttachedTo{}, fmt.Errorf(\"volume %v is no longer attached to the node %q\",\n\t\tvolumeName,\n\t\tnodeName)\n}", "category": "Python"}, {"instruction": "// Validate container resource name\n// Refer to docs/design/resources.md for more details.", "input": "go language", "output": "func validateContainerResourceName(value string, fldPath *field.Path) field.ErrorList {\n\tallErrs := validateResourceName(value, fldPath)\n\n\tif len(strings.Split(value, \"/\")) == 1 {\n\t\tif !helper.IsStandardContainerResourceName(value) {\n\t\t\treturn append(allErrs, field.Invalid(fldPath, value, \"must be a standard resource for containers\"))\n\t\t}\n\t} else if !helper.IsNativeResource(core.ResourceName(value)) {\n\t\tif !helper.IsExtendedResourceName(core.ResourceName(value)) {\n\t\t\treturn append(allErrs, field.Invalid(fldPath, value, \"doesn't follow extended resource name standard\"))\n\t\t}\n\t}\n\treturn allErrs\n}", "category": "Python"}, {"instruction": "// ApplyDefaults applies the default values to Options.", "input": "go language", "output": "func (o *Options) ApplyDefaults(in *kubeproxyconfig.KubeProxyConfiguration) (*kubeproxyconfig.KubeProxyConfiguration, error) {\n\texternal, err := o.scheme.ConvertToVersion(in, v1alpha1.SchemeGroupVersion)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\to.scheme.Default(external)\n\n\tinternal, err := o.scheme.ConvertToVersion(external, kubeproxyconfig.SchemeGroupVersion)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tout := internal.(*kubeproxyconfig.KubeProxyConfiguration)\n\n\treturn out, nil\n}", "category": "Python"}, {"instruction": "// removeRegisterTopic deletes all tickets for the given topic.", "input": "go language", "output": "func (s *ticketStore) removeRegisterTopic(topic Topic) {\n\tlog.Trace(\"Removing discovery topic\", \"topic\", topic)\n\tif s.tickets[topic] == nil {\n\t\tlog.Warn(\"Removing non-existent discovery topic\", \"topic\", topic)\n\t\treturn\n\t}\n\tfor _, list := range s.tickets[topic].buckets {\n\t\tfor _, ref := range list {\n\t\t\tref.t.refCnt--\n\t\t\tif ref.t.refCnt == 0 {\n\t\t\t\tdelete(s.nodes, ref.t.node)\n\t\t\t\tdelete(s.nodeLastReq, ref.t.node)\n\t\t\t}\n\t\t}\n\t}\n\tdelete(s.tickets, topic)\n}", "category": "Python"}, {"instruction": "// RemoveNode removes the overall information about the node.", "input": "go language", "output": "func (n *NodeInfo) RemoveNode(node *v1.Node) error {\n\t// We don't remove NodeInfo for because there can still be some pods on this node -\n\t// this is because notifications about pods are delivered in a different watch,\n\t// and thus can potentially be observed later, even though they happened before\n\t// node removal. This is handled correctly in cache.go file.\n\tn.node = nil\n\tn.allocatableResource = &Resource{}\n\tn.taints, n.taintsErr = nil, nil\n\tn.memoryPressureCondition = v1.ConditionUnknown\n\tn.diskPressureCondition = v1.ConditionUnknown\n\tn.pidPressureCondition = v1.ConditionUnknown\n\tn.imageStates = make(map[string]*ImageStateSummary)\n\tn.generation = nextGeneration()\n\treturn nil\n}", "category": "Python"}, {"instruction": "// NewPeerClientForAddress creates an instance of a PeerClient using the\n// provided peer address and, if TLS is enabled, the TLS root cert file", "input": "go language", "output": "func NewPeerClientForAddress(address, tlsRootCertFile string) (*PeerClient, error) {\n\tif address == \"\" {\n\t\treturn nil, errors.New(\"peer address must be set\")\n\t}\n\n\t_, override, clientConfig, err := configFromEnv(\"peer\")\n\tif clientConfig.SecOpts.UseTLS {\n\t\tif tlsRootCertFile == \"\" {\n\t\t\treturn nil, errors.New(\"tls root cert file must be set\")\n\t\t}\n\t\tcaPEM, res := ioutil.ReadFile(tlsRootCertFile)\n\t\tif res != nil {\n\t\t\terr = errors.WithMessage(res, fmt.Sprintf(\"unable to load TLS root cert file from %s\", tlsRootCertFile))\n\t\t\treturn nil, err\n\t\t}\n\t\tclientConfig.SecOpts.ServerRootCAs = [][]byte{caPEM}\n\t}\n\treturn newPeerClientForClientConfig(address, override, clientConfig)\n}", "category": "Python"}, {"instruction": "// NodeService is used to retrieve a specific service associated with the given\n// node.", "input": "go language", "output": "func (s *Store) NodeService(nodeName string, serviceID string) (uint64, *structs.NodeService, error) {\n\ttx := s.db.Txn(false)\n\tdefer tx.Abort()\n\n\t// Get the table index.\n\tidx := maxIndexTxn(tx, \"services\")\n\n\t// Query the service\n\tservice, err := s.getNodeServiceTxn(tx, nodeName, serviceID)\n\tif err != nil {\n\t\treturn 0, nil, fmt.Errorf(\"failed querying service for node %q: %s\", nodeName, err)\n\t}\n\n\treturn idx, service, nil\n}", "category": "Python"}, {"instruction": "// gcUnscheduledTerminating deletes pods that are terminating and haven't been scheduled to a particular node.", "input": "go language", "output": "func (gcc *PodGCController) gcUnscheduledTerminating(pods []*v1.Pod) {\n\tklog.V(4).Infof(\"GC'ing unscheduled pods which are terminating.\")\n\n\tfor _, pod := range pods {\n\t\tif pod.DeletionTimestamp == nil || len(pod.Spec.NodeName) > 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tklog.V(2).Infof(\"Found unscheduled terminating Pod %v/%v not assigned to any Node. Deleting.\", pod.Namespace, pod.Name)\n\t\tif err := gcc.deletePod(pod.Namespace, pod.Name); err != nil {\n\t\t\tutilruntime.HandleError(err)\n\t\t} else {\n\t\t\tklog.V(0).Infof(\"Forced deletion of unscheduled terminating Pod %v/%v succeeded\", pod.Namespace, pod.Name)\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// Get returns the overall codebase version. It's for detecting\n// what code a binary was built from.", "input": "go language", "output": "func Get() apimachineryversion.Info {\n\t// These variables typically come from -ldflags settings and in\n\t// their absence fallback to the settings in ./base.go\n\treturn apimachineryversion.Info{\n\t\tMajor:        gitMajor,\n\t\tMinor:        gitMinor,\n\t\tGitVersion:   gitVersion,\n\t\tGitCommit:    gitCommit,\n\t\tGitTreeState: gitTreeState,\n\t\tBuildDate:    buildDate,\n\t\tGoVersion:    runtime.Version(),\n\t\tCompiler:     runtime.Compiler,\n\t\tPlatform:     fmt.Sprintf(\"%s/%s\", runtime.GOOS, runtime.GOARCH),\n\t}\n}", "category": "Python"}, {"instruction": "// ServerResourcesForGroupVersion returns the supported resources for a group\n// and version.", "input": "go language", "output": "func (c *FakeDiscovery) ServerResourcesForGroupVersion(groupVersion string) (*metav1.APIResourceList, error) {\n\taction := testing.ActionImpl{\n\t\tVerb:     \"get\",\n\t\tResource: schema.GroupVersionResource{Resource: \"resource\"},\n\t}\n\tc.Invokes(action, nil)\n\tfor _, resourceList := range c.Resources {\n\t\tif resourceList.GroupVersion == groupVersion {\n\t\t\treturn resourceList, nil\n\t\t}\n\t}\n\treturn nil, fmt.Errorf(\"GroupVersion %q not found\", groupVersion)\n}", "category": "Python"}, {"instruction": "// Cleanup aufs and unmount all mountpoints", "input": "go language", "output": "func (a *Driver) Cleanup() error {\n\tvar dirs []string\n\tif err := filepath.Walk(a.mntPath(), func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tdirs = append(dirs, path)\n\t\treturn nil\n\t}); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, m := range dirs {\n\t\tif err := a.unmount(m); err != nil {\n\t\t\tlogger.Debugf(\"error unmounting %s: %s\", m, err)\n\t\t}\n\t}\n\treturn mount.RecursiveUnmount(a.root)\n}", "category": "Python"}, {"instruction": "// Syncing returns false in case the node is currently not syncing with the network. It can be up to date or has not\n// yet received the latest block headers from its pears. In case it is synchronizing:\n// - startingBlock: block number this node started to synchronise from\n// - currentBlock:  block number this node is currently importing\n// - highestBlock:  block number of the highest block header this node has received from peers\n// - pulledStates:  number of state entries processed until now\n// - knownStates:   number of known state entries that still need to be pulled", "input": "go language", "output": "func (s *PublicEthereumAPI) Syncing() (interface{}, error) {\n\tprogress := s.b.Downloader().Progress()\n\n\t// Return not syncing if the synchronisation already completed\n\tif progress.CurrentBlock >= progress.HighestBlock {\n\t\treturn false, nil\n\t}\n\t// Otherwise gather the block sync stats\n\treturn map[string]interface{}{\n\t\t\"startingBlock\": hexutil.Uint64(progress.StartingBlock),\n\t\t\"currentBlock\":  hexutil.Uint64(progress.CurrentBlock),\n\t\t\"highestBlock\":  hexutil.Uint64(progress.HighestBlock),\n\t\t\"pulledStates\":  hexutil.Uint64(progress.PulledStates),\n\t\t\"knownStates\":   hexutil.Uint64(progress.KnownStates),\n\t}, nil\n}", "category": "Python"}, {"instruction": "// Unpack performs the operation hexdata -> Go format", "input": "go language", "output": "func (arguments Arguments) Unpack(v interface{}, data []byte) error {\n\t// make sure the passed value is arguments pointer\n\tif reflect.Ptr != reflect.ValueOf(v).Kind() {\n\t\treturn fmt.Errorf(\"abi: Unpack(non-pointer %T)\", v)\n\t}\n\tmarshalledValues, err := arguments.UnpackValues(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif arguments.isTuple() {\n\t\treturn arguments.unpackTuple(v, marshalledValues)\n\t}\n\treturn arguments.unpackAtomic(v, marshalledValues[0])\n}", "category": "Python"}, {"instruction": "// DeriveStats implement LogicalPlan DeriveStats interface.", "input": "go language", "output": "func (p *baseLogicalPlan) DeriveStats(childStats []*property.StatsInfo) (*property.StatsInfo, error) {\n\tif len(childStats) == 1 {\n\t\tp.stats = childStats[0]\n\t\treturn p.stats, nil\n\t}\n\tif len(childStats) > 1 {\n\t\terr := ErrInternal.GenWithStack(\"LogicalPlans with more than one child should implement their own DeriveStats().\")\n\t\treturn nil, err\n\t}\n\tprofile := &property.StatsInfo{\n\t\tRowCount:    float64(1),\n\t\tCardinality: make([]float64, p.self.Schema().Len()),\n\t}\n\tfor i := range profile.Cardinality {\n\t\tprofile.Cardinality[i] = float64(1)\n\t}\n\tp.stats = profile\n\treturn profile, nil\n}", "category": "Python"}, {"instruction": "// LoadMirrors loads mirrors to config, after removing duplicates.\n// Returns an error if mirrors contains an invalid mirror.", "input": "go language", "output": "func (config *serviceConfig) LoadMirrors(mirrors []string) error {\n\tmMap := map[string]struct{}{}\n\tunique := []string{}\n\n\tfor _, mirror := range mirrors {\n\t\tm, err := ValidateMirror(mirror)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, exist := mMap[m]; !exist {\n\t\t\tmMap[m] = struct{}{}\n\t\t\tunique = append(unique, m)\n\t\t}\n\t}\n\n\tconfig.Mirrors = unique\n\n\t// Configure public registry since mirrors may have changed.\n\tconfig.IndexConfigs[IndexName] = &registrytypes.IndexInfo{\n\t\tName:     IndexName,\n\t\tMirrors:  config.Mirrors,\n\t\tSecure:   true,\n\t\tOfficial: true,\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// DecodeFormats takes a list of output format configurations and merges those,\n// in the order given, with the Hugo defaults as the last resort.", "input": "go language", "output": "func DecodeFormats(mediaTypes media.Types, maps ...map[string]interface{}) (Formats, error) {\n\tf := make(Formats, len(DefaultFormats))\n\tcopy(f, DefaultFormats)\n\n\tfor _, m := range maps {\n\t\tfor k, v := range m {\n\t\t\tfound := false\n\t\t\tfor i, vv := range f {\n\t\t\t\tif strings.EqualFold(k, vv.Name) {\n\t\t\t\t\t// Merge it with the existing\n\t\t\t\t\tif err := decode(mediaTypes, v, &f[i]); err != nil {\n\t\t\t\t\t\treturn f, err\n\t\t\t\t\t}\n\t\t\t\t\tfound = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\tvar newOutFormat Format\n\t\t\t\tnewOutFormat.Name = k\n\t\t\t\tif err := decode(mediaTypes, v, &newOutFormat); err != nil {\n\t\t\t\t\treturn f, err\n\t\t\t\t}\n\n\t\t\t\t// We need values for these\n\t\t\t\tif newOutFormat.BaseName == \"\" {\n\t\t\t\t\tnewOutFormat.BaseName = \"index\"\n\t\t\t\t}\n\t\t\t\tif newOutFormat.Rel == \"\" {\n\t\t\t\t\tnewOutFormat.Rel = \"alternate\"\n\t\t\t\t}\n\n\t\t\t\tf = append(f, newOutFormat)\n\t\t\t}\n\t\t}\n\t}\n\n\tsort.Sort(f)\n\n\treturn f, nil\n}", "category": "Python"}, {"instruction": "// RequestTransfer creates a TokenTransaction of type transfer request\n//func (t *Transactor) RequestTransfer(inTokens []*token.InputId, tokensToTransfer []*token.RecipientTransferShare) (*token.TokenTransaction, error) {", "input": "go language", "output": "func (t *Transactor) RequestTransfer(request *token.TransferRequest) (*token.TokenTransaction, error) {\n\tvar outputs []*token.PlainOutput\n\n\tinputs, tokenType, _, err := t.getInputsFromTokenIds(request.GetTokenIds())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, ttt := range request.GetShares() {\n\t\toutputs = append(outputs, &token.PlainOutput{\n\t\t\tOwner:    ttt.Recipient,\n\t\t\tType:     tokenType,\n\t\t\tQuantity: ttt.Quantity,\n\t\t})\n\t}\n\n\t// prepare transfer request\n\ttransaction := &token.TokenTransaction{\n\t\tAction: &token.TokenTransaction_PlainAction{\n\t\t\tPlainAction: &token.PlainTokenAction{\n\t\t\t\tData: &token.PlainTokenAction_PlainTransfer{\n\t\t\t\t\tPlainTransfer: &token.PlainTransfer{\n\t\t\t\t\t\tInputs:  inputs,\n\t\t\t\t\t\tOutputs: outputs,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\treturn transaction, nil\n}", "category": "Python"}, {"instruction": "// fetchAllInners reads all data from the inner table and stores them in a List.", "input": "go language", "output": "func (e *NestedLoopApplyExec) fetchAllInners(ctx context.Context) error {\n\terr := e.innerExec.Open(ctx)\n\tdefer terror.Call(e.innerExec.Close)\n\tif err != nil {\n\t\treturn err\n\t}\n\te.innerList.Reset()\n\tinnerIter := chunk.NewIterator4Chunk(e.innerChunk)\n\tfor {\n\t\terr := e.innerExec.Next(ctx, chunk.NewRecordBatch(e.innerChunk))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif e.innerChunk.NumRows() == 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\te.innerSelected, err = expression.VectorizedFilter(e.ctx, e.innerFilter, innerIter, e.innerSelected)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor row := innerIter.Begin(); row != innerIter.End(); row = innerIter.Next() {\n\t\t\tif e.innerSelected[row.Idx()] {\n\t\t\t\te.innerList.AppendRow(row)\n\t\t\t}\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// ValidateSignatureValues verifies whether the signature values are valid with\n// the given chain rules. The v value is assumed to be either 0 or 1.", "input": "go language", "output": "func ValidateSignatureValues(v byte, r, s *big.Int, homestead bool) bool {\n\tif r.Cmp(common.Big1) < 0 || s.Cmp(common.Big1) < 0 {\n\t\treturn false\n\t}\n\t// reject upper range of s values (ECDSA malleability)\n\t// see discussion in secp256k1/libsecp256k1/include/secp256k1.h\n\tif homestead && s.Cmp(secp256k1halfN) > 0 {\n\t\treturn false\n\t}\n\t// Frontier: allow s to be in full N range\n\treturn r.Cmp(secp256k1N) < 0 && s.Cmp(secp256k1N) < 0 && (v == 0 || v == 1)\n}", "category": "Python"}, {"instruction": "// IsSame checks if one HealthCheck is the same as another, without looking\n// at the Raft information (that's why we didn't call it IsEqual). This is\n// useful for seeing if an update would be idempotent for all the functional\n// parts of the structure.", "input": "go language", "output": "func (c *HealthCheck) IsSame(other *HealthCheck) bool {\n\tif c.Node != other.Node ||\n\t\tc.CheckID != other.CheckID ||\n\t\tc.Name != other.Name ||\n\t\tc.Status != other.Status ||\n\t\tc.Notes != other.Notes ||\n\t\tc.Output != other.Output ||\n\t\tc.ServiceID != other.ServiceID ||\n\t\tc.ServiceName != other.ServiceName ||\n\t\t!reflect.DeepEqual(c.ServiceTags, other.ServiceTags) ||\n\t\t!reflect.DeepEqual(c.Definition, other.Definition) {\n\t\treturn false\n\t}\n\n\treturn true\n}", "category": "Python"}, {"instruction": "// GeneratePrivateKey creates a private key and stores it in keystorePath", "input": "go language", "output": "func GeneratePrivateKey(keystorePath string) (bccsp.Key,\n\tcrypto.Signer, error) {\n\n\tvar err error\n\tvar priv bccsp.Key\n\tvar s crypto.Signer\n\n\topts := &factory.FactoryOpts{\n\t\tProviderName: \"SW\",\n\t\tSwOpts: &factory.SwOpts{\n\t\t\tHashFamily: \"SHA2\",\n\t\t\tSecLevel:   256,\n\n\t\t\tFileKeystore: &factory.FileKeystoreOpts{\n\t\t\t\tKeyStorePath: keystorePath,\n\t\t\t},\n\t\t},\n\t}\n\tcsp, err := factory.GetBCCSPFromOpts(opts)\n\tif err == nil {\n\t\t// generate a key\n\t\tpriv, err = csp.KeyGen(&bccsp.ECDSAP256KeyGenOpts{Temporary: false})\n\t\tif err == nil {\n\t\t\t// create a crypto.Signer\n\t\t\ts, err = signer.New(csp, priv)\n\t\t}\n\t}\n\treturn priv, s, err\n}", "category": "Python"}, {"instruction": "// NewNodeID returns a new unique ID for a node to be added to g. The returned ID does\n// not become a valid ID in g until it is added to g.", "input": "go language", "output": "func (g *UndirectedGraph) NewNodeID() int {\n\tif len(g.nodes) == 0 {\n\t\treturn 0\n\t}\n\tif len(g.nodes) == maxInt {\n\t\tpanic(fmt.Sprintf(\"simple: cannot allocate node: no slot\"))\n\t}\n\n\tvar id int\n\tif g.freeIDs.Len() != 0 && g.freeIDs.TakeMin(&id) {\n\t\treturn id\n\t}\n\tif id = g.usedIDs.Max(); id < maxInt {\n\t\treturn id + 1\n\t}\n\tfor id = 0; id < maxInt; id++ {\n\t\tif !g.usedIDs.Has(id) {\n\t\t\treturn id\n\t\t}\n\t}\n\tpanic(\"unreachable\")\n}", "category": "Python"}, {"instruction": "// UntilWithoutRetry reads items from the watch until each provided condition succeeds, and then returns the last watch\n// encountered. The first condition that returns an error terminates the watch (and the event is also returned).\n// If no event has been received, the returned event will be nil.\n// Conditions are satisfied sequentially so as to provide a useful primitive for higher level composition.\n// Waits until context deadline or until context is canceled.\n//\n// Warning: Unless you have a very specific use case (probably a special Watcher) don't use this function!!!\n// Warning: This will fail e.g. on API timeouts and/or 'too old resource version' error.\n// Warning: You are most probably looking for a function *Until* or *UntilWithSync* below,\n// Warning: solving such issues.\n// TODO: Consider making this function private to prevent misuse when the other occurrences in our codebase are gone.", "input": "go language", "output": "func UntilWithoutRetry(ctx context.Context, watcher watch.Interface, conditions ...ConditionFunc) (*watch.Event, error) {\n\tch := watcher.ResultChan()\n\tdefer watcher.Stop()\n\tvar lastEvent *watch.Event\n\tfor _, condition := range conditions {\n\t\t// check the next condition against the previous event and short circuit waiting for the next watch\n\t\tif lastEvent != nil {\n\t\t\tdone, err := condition(*lastEvent)\n\t\t\tif err != nil {\n\t\t\t\treturn lastEvent, err\n\t\t\t}\n\t\t\tif done {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\tConditionSucceeded:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase event, ok := <-ch:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn lastEvent, ErrWatchClosed\n\t\t\t\t}\n\t\t\t\tlastEvent = &event\n\n\t\t\t\tdone, err := condition(event)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn lastEvent, err\n\t\t\t\t}\n\t\t\t\tif done {\n\t\t\t\t\tbreak ConditionSucceeded\n\t\t\t\t}\n\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn lastEvent, wait.ErrWaitTimeout\n\t\t\t}\n\t\t}\n\t}\n\treturn lastEvent, nil\n}", "category": "Python"}, {"instruction": "// evalRecursive visits the given value recursively and pushes all of them to result", "input": "go language", "output": "func (j *JSONPath) evalRecursive(input []reflect.Value, node *RecursiveNode) ([]reflect.Value, error) {\n\tresult := []reflect.Value{}\n\tfor _, value := range input {\n\t\tresults := []reflect.Value{}\n\t\tvalue, isNil := template.Indirect(value)\n\t\tif isNil {\n\t\t\tcontinue\n\t\t}\n\n\t\tkind := value.Kind()\n\t\tif kind == reflect.Struct {\n\t\t\tfor i := 0; i < value.NumField(); i++ {\n\t\t\t\tresults = append(results, value.Field(i))\n\t\t\t}\n\t\t} else if kind == reflect.Map {\n\t\t\tfor _, key := range value.MapKeys() {\n\t\t\t\tresults = append(results, value.MapIndex(key))\n\t\t\t}\n\t\t} else if kind == reflect.Array || kind == reflect.Slice || kind == reflect.String {\n\t\t\tfor i := 0; i < value.Len(); i++ {\n\t\t\t\tresults = append(results, value.Index(i))\n\t\t\t}\n\t\t}\n\t\tif len(results) != 0 {\n\t\t\tresult = append(result, value)\n\t\t\toutput, err := j.evalRecursive(results, node)\n\t\t\tif err != nil {\n\t\t\t\treturn result, err\n\t\t\t}\n\t\t\tresult = append(result, output...)\n\t\t}\n\t}\n\treturn result, nil\n}", "category": "Python"}, {"instruction": "// Reload reads the configuration in the host and reloads the daemon and server.", "input": "go language", "output": "func Reload(configFile string, flags *pflag.FlagSet, reload func(*Config)) error {\n\tlogrus.Infof(\"Got signal to reload configuration, reloading from: %s\", configFile)\n\tnewConfig, err := getConflictFreeConfiguration(configFile, flags)\n\tif err != nil {\n\t\tif flags.Changed(\"config-file\") || !os.IsNotExist(err) {\n\t\t\treturn errors.Wrapf(err, \"unable to configure the Docker daemon with file %s\", configFile)\n\t\t}\n\t\tnewConfig = New()\n\t}\n\n\tif err := Validate(newConfig); err != nil {\n\t\treturn errors.Wrap(err, \"file configuration validation failed\")\n\t}\n\n\t// Check if duplicate label-keys with different values are found\n\tnewLabels, err := GetConflictFreeLabels(newConfig.Labels)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnewConfig.Labels = newLabels\n\n\treload(newConfig)\n\treturn nil\n}", "category": "Python"}, {"instruction": "// SignIntermediate returns a signed CA certificate with a path length constraint\n// of 0 to ensure that the certificate cannot be used to generate further CA certs.", "input": "go language", "output": "func (v *VaultProvider) SignIntermediate(csr *x509.CertificateRequest) (string, error) {\n\tvar pemBuf bytes.Buffer\n\terr := pem.Encode(&pemBuf, &pem.Block{Type: \"CERTIFICATE REQUEST\", Bytes: csr.Raw})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Sign the CSR with the root backend.\n\tdata, err := v.client.Logical().Write(v.config.RootPKIPath+\"root/sign-intermediate\", map[string]interface{}{\n\t\t\"csr\":             pemBuf.String(),\n\t\t\"format\":          \"pem_bundle\",\n\t\t\"max_path_length\": 0,\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif data == nil || data.Data[\"certificate\"] == \"\" {\n\t\treturn \"\", fmt.Errorf(\"got empty value when generating intermediate certificate\")\n\t}\n\n\tintermediate, ok := data.Data[\"certificate\"].(string)\n\tif !ok {\n\t\treturn \"\", fmt.Errorf(\"signed intermediate result is not a string\")\n\t}\n\n\treturn intermediate, nil\n}", "category": "Python"}, {"instruction": "// parseCARoot returns a filled-in structs.CARoot from a raw PEM value.", "input": "go language", "output": "func parseCARoot(pemValue, provider, clusterID string) (*structs.CARoot, error) {\n\tid, err := connect.CalculateCertFingerprint(pemValue)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing root fingerprint: %v\", err)\n\t}\n\trootCert, err := connect.ParseCert(pemValue)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing root cert: %v\", err)\n\t}\n\treturn &structs.CARoot{\n\t\tID:                  id,\n\t\tName:                fmt.Sprintf(\"%s CA Root Cert\", strings.Title(provider)),\n\t\tSerialNumber:        rootCert.SerialNumber.Uint64(),\n\t\tSigningKeyID:        connect.HexString(rootCert.AuthorityKeyId),\n\t\tExternalTrustDomain: clusterID,\n\t\tNotBefore:           rootCert.NotBefore,\n\t\tNotAfter:            rootCert.NotAfter,\n\t\tRootCert:            pemValue,\n\t\tActive:              true,\n\t}, nil\n}", "category": "Python"}, {"instruction": "// HEALTHCHECK foo\n//\n// Set the default healthcheck command to run in the container (which may be empty).\n// Argument handling is the same as RUN.\n//", "input": "go language", "output": "func dispatchHealthcheck(d dispatchRequest, c *instructions.HealthCheckCommand) error {\n\trunConfig := d.state.runConfig\n\tif runConfig.Healthcheck != nil {\n\t\toldCmd := runConfig.Healthcheck.Test\n\t\tif len(oldCmd) > 0 && oldCmd[0] != \"NONE\" {\n\t\t\tfmt.Fprintf(d.builder.Stdout, \"Note: overriding previous HEALTHCHECK: %v\\n\", oldCmd)\n\t\t}\n\t}\n\trunConfig.Healthcheck = c.Health\n\treturn d.builder.commit(d.state, fmt.Sprintf(\"HEALTHCHECK %q\", runConfig.Healthcheck))\n}", "category": "Python"}, {"instruction": "// SameLineage returns true only if the state given in argument belongs\n// to the same \"lineage\" of states as the receiver.", "input": "go language", "output": "func (s *State) SameLineage(other *State) bool {\n\ts.Lock()\n\tdefer s.Unlock()\n\n\t// If one of the states has no lineage then it is assumed to predate\n\t// this concept, and so we'll accept it as belonging to any lineage\n\t// so that a lineage string can be assigned to newer versions\n\t// without breaking compatibility with older versions.\n\tif s.Lineage == \"\" || other.Lineage == \"\" {\n\t\treturn true\n\t}\n\n\treturn s.Lineage == other.Lineage\n}", "category": "Python"}, {"instruction": "// ScanIndexData scans the index handles and values in a limited number, according to the index information.\n// It returns data and the next startVals until it doesn't have data, then returns data is nil and\n// the next startVals is the values which can't get data. If startVals = nil and limit = -1,\n// it returns the index data of the whole.", "input": "go language", "output": "func ScanIndexData(sc *stmtctx.StatementContext, txn kv.Transaction, kvIndex table.Index, startVals []types.Datum, limit int64) (\n\t[]*RecordData, []types.Datum, error) {\n\tit, _, err := kvIndex.Seek(sc, txn, startVals)\n\tif err != nil {\n\t\treturn nil, nil, errors.Trace(err)\n\t}\n\tdefer it.Close()\n\n\tvar idxRows []*RecordData\n\tvar curVals []types.Datum\n\tfor limit != 0 {\n\t\tval, h, err1 := it.Next()\n\t\tif terror.ErrorEqual(err1, io.EOF) {\n\t\t\treturn idxRows, nextIndexVals(curVals), nil\n\t\t} else if err1 != nil {\n\t\t\treturn nil, nil, errors.Trace(err1)\n\t\t}\n\t\tidxRows = append(idxRows, &RecordData{Handle: h, Values: val})\n\t\tlimit--\n\t\tcurVals = val\n\t}\n\n\tnextVals, _, err := it.Next()\n\tif terror.ErrorEqual(err, io.EOF) {\n\t\treturn idxRows, nextIndexVals(curVals), nil\n\t} else if err != nil {\n\t\treturn nil, nil, errors.Trace(err)\n\t}\n\n\treturn idxRows, nextVals, nil\n}", "category": "Python"}, {"instruction": "// NewChildImage creates a new Image as a child of this image.", "input": "go language", "output": "func NewChildImage(img *Image, child ChildConfig, os string) *Image {\n\tisEmptyLayer := layer.IsEmpty(child.DiffID)\n\tvar rootFS *RootFS\n\tif img.RootFS != nil {\n\t\trootFS = img.RootFS.Clone()\n\t} else {\n\t\trootFS = NewRootFS()\n\t}\n\n\tif !isEmptyLayer {\n\t\trootFS.Append(child.DiffID)\n\t}\n\timgHistory := NewHistory(\n\t\tchild.Author,\n\t\tchild.Comment,\n\t\tstrings.Join(child.ContainerConfig.Cmd, \" \"),\n\t\tisEmptyLayer)\n\n\treturn &Image{\n\t\tV1Image: V1Image{\n\t\t\tDockerVersion:   dockerversion.Version,\n\t\t\tConfig:          child.Config,\n\t\t\tArchitecture:    img.BaseImgArch(),\n\t\t\tOS:              os,\n\t\t\tContainer:       child.ContainerID,\n\t\t\tContainerConfig: *child.ContainerConfig,\n\t\t\tAuthor:          child.Author,\n\t\t\tCreated:         imgHistory.Created,\n\t\t},\n\t\tRootFS:     rootFS,\n\t\tHistory:    append(img.History, imgHistory),\n\t\tOSFeatures: img.OSFeatures,\n\t\tOSVersion:  img.OSVersion,\n\t}\n}", "category": "Python"}, {"instruction": "// tryAccessIdx tries to find index entry. If found then increments the access\n// count for garbage collection and returns the index entry and true for found,\n// otherwise returns nil and false.", "input": "go language", "output": "func (s *LDBStore) tryAccessIdx(addr Address, po uint8) (*dpaDBIndex, bool) {\n\tikey := getIndexKey(addr)\n\tidata, err := s.db.Get(ikey)\n\tif err != nil {\n\t\treturn nil, false\n\t}\n\n\tindex := new(dpaDBIndex)\n\tdecodeIndex(idata, index)\n\toldGCIdxKey := getGCIdxKey(index)\n\ts.batch.Put(keyAccessCnt, U64ToBytes(s.accessCnt))\n\tindex.Access = s.accessCnt\n\tidata = encodeIndex(index)\n\ts.accessCnt++\n\ts.batch.Put(ikey, idata)\n\tnewGCIdxKey := getGCIdxKey(index)\n\tnewGCIdxData := getGCIdxValue(index, po, ikey[1:])\n\ts.batch.Delete(oldGCIdxKey)\n\ts.batch.Put(newGCIdxKey, newGCIdxData)\n\tselect {\n\tcase s.batchesC <- struct{}{}:\n\tdefault:\n\t}\n\treturn index, true\n}", "category": "Python"}, {"instruction": "// List takes label and field selectors, and returns the list of MutatingWebhookConfigurations that match those selectors.", "input": "go language", "output": "func (c *FakeMutatingWebhookConfigurations) List(opts v1.ListOptions) (result *v1beta1.MutatingWebhookConfigurationList, err error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewRootListAction(mutatingwebhookconfigurationsResource, mutatingwebhookconfigurationsKind, opts), &v1beta1.MutatingWebhookConfigurationList{})\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n\tif label == nil {\n\t\tlabel = labels.Everything()\n\t}\n\tlist := &v1beta1.MutatingWebhookConfigurationList{ListMeta: obj.(*v1beta1.MutatingWebhookConfigurationList).ListMeta}\n\tfor _, item := range obj.(*v1beta1.MutatingWebhookConfigurationList).Items {\n\t\tif label.Matches(labels.Set(item.Labels)) {\n\t\t\tlist.Items = append(list.Items, item)\n\t\t}\n\t}\n\treturn list, err\n}", "category": "Python"}, {"instruction": "// Flatten creates a nonce-sorted slice of transactions based on the loosely\n// sorted internal representation. The result of the sorting is cached in case\n// it's requested again before any modifications are made to the contents.", "input": "go language", "output": "func (m *txSortedMap) Flatten() types.Transactions {\n\t// If the sorting was not cached yet, create and cache it\n\tif m.cache == nil {\n\t\tm.cache = make(types.Transactions, 0, len(m.items))\n\t\tfor _, tx := range m.items {\n\t\t\tm.cache = append(m.cache, tx)\n\t\t}\n\t\tsort.Sort(types.TxByNonce(m.cache))\n\t}\n\t// Copy the cache to prevent accidental modifications\n\ttxs := make(types.Transactions, len(m.cache))\n\tcopy(txs, m.cache)\n\treturn txs\n}", "category": "Python"}, {"instruction": "// GetVersion returns the etcd version of the cluster.\n// An error is returned if the version of all endpoints do not match", "input": "go language", "output": "func (c *Client) GetVersion() (string, error) {\n\tvar clusterVersion string\n\n\tversions, err := c.GetClusterVersions()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, v := range versions {\n\t\tif clusterVersion != \"\" && clusterVersion != v {\n\t\t\treturn \"\", errors.Errorf(\"etcd cluster contains endpoints with mismatched versions: %v\", versions)\n\t\t}\n\t\tclusterVersion = v\n\t}\n\tif clusterVersion == \"\" {\n\t\treturn \"\", errors.New(\"could not determine cluster etcd version\")\n\t}\n\treturn clusterVersion, nil\n}", "category": "Python"}, {"instruction": "// ServerKeepaliveOptions returns gRPC keepalive options for server.  If\n// opts is nil, the default keepalive options are returned", "input": "go language", "output": "func ServerKeepaliveOptions(ka *KeepaliveOptions) []grpc.ServerOption {\n\t// use default keepalive options if nil\n\tif ka == nil {\n\t\tka = DefaultKeepaliveOptions\n\t}\n\tvar serverOpts []grpc.ServerOption\n\tkap := keepalive.ServerParameters{\n\t\tTime:    ka.ServerInterval,\n\t\tTimeout: ka.ServerTimeout,\n\t}\n\tserverOpts = append(serverOpts, grpc.KeepaliveParams(kap))\n\tkep := keepalive.EnforcementPolicy{\n\t\tMinTime: ka.ServerMinInterval,\n\t\t// allow keepalive w/o rpc\n\t\tPermitWithoutStream: true,\n\t}\n\tserverOpts = append(serverOpts, grpc.KeepaliveEnforcementPolicy(kep))\n\treturn serverOpts\n}", "category": "Python"}, {"instruction": "// getStatefulSetsForPod returns a list of StatefulSets that potentially match\n// a given pod.", "input": "go language", "output": "func (ssc *StatefulSetController) getStatefulSetsForPod(pod *v1.Pod) []*apps.StatefulSet {\n\tsets, err := ssc.setLister.GetPodStatefulSets(pod)\n\tif err != nil {\n\t\treturn nil\n\t}\n\t// More than one set is selecting the same Pod\n\tif len(sets) > 1 {\n\t\t// ControllerRef will ensure we don't do anything crazy, but more than one\n\t\t// item in this list nevertheless constitutes user error.\n\t\tutilruntime.HandleError(\n\t\t\tfmt.Errorf(\n\t\t\t\t\"user error: more than one StatefulSet is selecting pods with labels: %+v\",\n\t\t\t\tpod.Labels))\n\t}\n\treturn sets\n}", "category": "Python"}, {"instruction": "// NewFilteredPriorityClassInformer constructs a new informer for PriorityClass type.\n// Always prefer using an informer factory to get a shared informer instead of getting an independent\n// one. This reduces memory footprint and number of connections to the server.", "input": "go language", "output": "func NewFilteredPriorityClassInformer(client kubernetes.Interface, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {\n\treturn cache.NewSharedIndexInformer(\n\t\t&cache.ListWatch{\n\t\t\tListFunc: func(options v1.ListOptions) (runtime.Object, error) {\n\t\t\t\tif tweakListOptions != nil {\n\t\t\t\t\ttweakListOptions(&options)\n\t\t\t\t}\n\t\t\t\treturn client.SchedulingV1alpha1().PriorityClasses().List(options)\n\t\t\t},\n\t\t\tWatchFunc: func(options v1.ListOptions) (watch.Interface, error) {\n\t\t\t\tif tweakListOptions != nil {\n\t\t\t\t\ttweakListOptions(&options)\n\t\t\t\t}\n\t\t\t\treturn client.SchedulingV1alpha1().PriorityClasses().Watch(options)\n\t\t\t},\n\t\t},\n\t\t&schedulingv1alpha1.PriorityClass{},\n\t\tresyncPeriod,\n\t\tindexers,\n\t)\n}", "category": "Python"}, {"instruction": "// MustGetGlobalVersion implements SchemaSyncer.MustGetGlobalVersion interface.", "input": "go language", "output": "func (s *schemaVersionSyncer) MustGetGlobalVersion(ctx context.Context) (int64, error) {\n\tstartTime := time.Now()\n\tvar (\n\t\terr  error\n\t\tver  int\n\t\tresp *clientv3.GetResponse\n\t)\n\tfailedCnt := 0\n\tintervalCnt := int(time.Second / keyOpRetryInterval)\n\n\tdefer func() {\n\t\tmetrics.OwnerHandleSyncerHistogram.WithLabelValues(metrics.OwnerGetGlobalVersion, metrics.RetLabel(err)).Observe(time.Since(startTime).Seconds())\n\t}()\n\tfor {\n\t\tif err != nil {\n\t\t\tif failedCnt%intervalCnt == 0 {\n\t\t\t\tlogutil.Logger(ddlLogCtx).Info(\"[ddl] syncer get global version failed\", zap.Error(err))\n\t\t\t}\n\t\t\ttime.Sleep(keyOpRetryInterval)\n\t\t\tfailedCnt++\n\t\t}\n\n\t\tif isContextDone(ctx) {\n\t\t\terr = errors.Trace(ctx.Err())\n\t\t\treturn 0, err\n\t\t}\n\n\t\tresp, err = s.etcdCli.Get(ctx, DDLGlobalSchemaVersion)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif len(resp.Kvs) > 0 {\n\t\t\tver, err = strconv.Atoi(string(resp.Kvs[0].Value))\n\t\t\tif err == nil {\n\t\t\t\treturn int64(ver), nil\n\t\t\t}\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// Helper function for the binding generators.\n// It reads the unmatched characters after the inner type-match,\n//  (since the inner type is a prefix of the total type declaration),\n//  looks for valid arrays (possibly a dynamic one) wrapping the inner type,\n//  and returns the sizes of these arrays.\n//\n// Returned array sizes are in the same order as solidity signatures; inner array size first.\n// Array sizes may also be \"\", indicating a dynamic array.", "input": "go language", "output": "func wrapArray(stringKind string, innerLen int, innerMapping string) (string, []string) {\n\tremainder := stringKind[innerLen:]\n\t//find all the sizes\n\tmatches := regexp.MustCompile(`\\[(\\d*)\\]`).FindAllStringSubmatch(remainder, -1)\n\tparts := make([]string, 0, len(matches))\n\tfor _, match := range matches {\n\t\t//get group 1 from the regex match\n\t\tparts = append(parts, match[1])\n\t}\n\treturn innerMapping, parts\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *VolumeAttachmentStatus) DeepCopyInto(out *VolumeAttachmentStatus) {\n\t*out = *in\n\tif in.AttachmentMetadata != nil {\n\t\tin, out := &in.AttachmentMetadata, &out.AttachmentMetadata\n\t\t*out = make(map[string]string, len(*in))\n\t\tfor key, val := range *in {\n\t\t\t(*out)[key] = val\n\t\t}\n\t}\n\tif in.AttachError != nil {\n\t\tin, out := &in.AttachError, &out.AttachError\n\t\t*out = new(VolumeError)\n\t\t(*in).DeepCopyInto(*out)\n\t}\n\tif in.DetachError != nil {\n\t\tin, out := &in.DetachError, &out.DetachError\n\t\t*out = new(VolumeError)\n\t\t(*in).DeepCopyInto(*out)\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// writePacket writes data that already have header", "input": "go language", "output": "func (p *packetIO) writePacket(data []byte) error {\n\tlength := len(data) - 4\n\n\tfor length >= mysql.MaxPayloadLen {\n\t\tdata[0] = 0xff\n\t\tdata[1] = 0xff\n\t\tdata[2] = 0xff\n\n\t\tdata[3] = p.sequence\n\n\t\tif n, err := p.bufWriter.Write(data[:4+mysql.MaxPayloadLen]); err != nil {\n\t\t\treturn errors.Trace(mysql.ErrBadConn)\n\t\t} else if n != (4 + mysql.MaxPayloadLen) {\n\t\t\treturn errors.Trace(mysql.ErrBadConn)\n\t\t} else {\n\t\t\tp.sequence++\n\t\t\tlength -= mysql.MaxPayloadLen\n\t\t\tdata = data[mysql.MaxPayloadLen:]\n\t\t}\n\t}\n\n\tdata[0] = byte(length)\n\tdata[1] = byte(length >> 8)\n\tdata[2] = byte(length >> 16)\n\tdata[3] = p.sequence\n\n\tif n, err := p.bufWriter.Write(data); err != nil {\n\t\tterror.Log(errors.Trace(err))\n\t\treturn errors.Trace(mysql.ErrBadConn)\n\t} else if n != len(data) {\n\t\treturn errors.Trace(mysql.ErrBadConn)\n\t} else {\n\t\tp.sequence++\n\t\treturn nil\n\t}\n}", "category": "Python"}, {"instruction": "// isPrivileged will return true a pod has any privileged containers", "input": "go language", "output": "func isPrivileged(pod *corev1.Pod) bool {\n\tfor _, c := range pod.Spec.InitContainers {\n\t\tif c.SecurityContext == nil || c.SecurityContext.Privileged == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif *c.SecurityContext.Privileged {\n\t\t\treturn true\n\t\t}\n\t}\n\tfor _, c := range pod.Spec.Containers {\n\t\tif c.SecurityContext == nil || c.SecurityContext.Privileged == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif *c.SecurityContext.Privileged {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "category": "Python"}, {"instruction": "// ReadDockerConfigJSONFile attempts to read a docker config.json file from the given paths.\n// if searchPaths is empty, the default paths are used.", "input": "go language", "output": "func ReadDockerConfigJSONFile(searchPaths []string) (cfg DockerConfig, err error) {\n\tif len(searchPaths) == 0 {\n\t\tsearchPaths = DefaultDockerConfigJSONPaths()\n\t}\n\tfor _, configPath := range searchPaths {\n\t\tabsDockerConfigFileLocation, err := filepath.Abs(filepath.Join(configPath, configJsonFileName))\n\t\tif err != nil {\n\t\t\tklog.Errorf(\"while trying to canonicalize %s: %v\", configPath, err)\n\t\t\tcontinue\n\t\t}\n\t\tklog.V(4).Infof(\"looking for %s at %s\", configJsonFileName, absDockerConfigFileLocation)\n\t\tcfg, err = ReadSpecificDockerConfigJsonFile(absDockerConfigFileLocation)\n\t\tif err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\tklog.V(4).Infof(\"while trying to read %s: %v\", absDockerConfigFileLocation, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tklog.V(4).Infof(\"found valid %s at %s\", configJsonFileName, absDockerConfigFileLocation)\n\t\treturn cfg, nil\n\t}\n\treturn nil, fmt.Errorf(\"couldn't find valid %s after checking in %v\", configJsonFileName, searchPaths)\n\n}", "category": "Python"}, {"instruction": "// Stop stops the node by first sending SIGTERM and then SIGKILL if the node\n// doesn't stop within 5s", "input": "go language", "output": "func (n *ExecNode) Stop() error {\n\tif n.Cmd == nil {\n\t\treturn nil\n\t}\n\tdefer func() {\n\t\tn.Cmd = nil\n\t}()\n\n\tif n.client != nil {\n\t\tn.client.Close()\n\t\tn.client = nil\n\t\tn.wsAddr = \"\"\n\t\tn.Info = nil\n\t}\n\n\tif err := n.Cmd.Process.Signal(syscall.SIGTERM); err != nil {\n\t\treturn n.Cmd.Process.Kill()\n\t}\n\twaitErr := make(chan error)\n\tgo func() {\n\t\twaitErr <- n.Cmd.Wait()\n\t}()\n\tselect {\n\tcase err := <-waitErr:\n\t\treturn err\n\tcase <-time.After(5 * time.Second):\n\t\treturn n.Cmd.Process.Kill()\n\t}\n}", "category": "Python"}, {"instruction": "// DeprecateBackend can be used to wrap a backend to retrun a deprecation\n// warning during validation.", "input": "go language", "output": "func deprecateBackend(b backend.Backend, message string) backend.Backend {\n\t// Since a Backend wrapped by deprecatedBackendShim can no longer be\n\t// asserted as an Enhanced or Local backend, disallow those types here\n\t// entirely.  If something other than a basic backend.Backend needs to be\n\t// deprecated, we can add that functionality to schema.Backend or the\n\t// backend itself.\n\tif _, ok := b.(backend.Enhanced); ok {\n\t\tpanic(\"cannot use DeprecateBackend on an Enhanced Backend\")\n\t}\n\n\tif _, ok := b.(backend.Local); ok {\n\t\tpanic(\"cannot use DeprecateBackend on a Local Backend\")\n\t}\n\n\treturn deprecatedBackendShim{\n\t\tBackend: b,\n\t\tMessage: message,\n\t}\n}", "category": "Python"}, {"instruction": "// UpdateLease resets the TTL on a master IP in storage", "input": "go language", "output": "func (s *storageLeases) UpdateLease(ip string) error {\n\tkey := path.Join(s.baseKey, ip)\n\treturn s.storage.GuaranteedUpdate(apirequest.NewDefaultContext(), key, &corev1.Endpoints{}, true, nil, func(input kruntime.Object, respMeta storage.ResponseMeta) (kruntime.Object, *uint64, error) {\n\t\t// just make sure we've got the right IP set, and then refresh the TTL\n\t\texisting := input.(*corev1.Endpoints)\n\t\texisting.Subsets = []corev1.EndpointSubset{\n\t\t\t{\n\t\t\t\tAddresses: []corev1.EndpointAddress{{IP: ip}},\n\t\t\t},\n\t\t}\n\n\t\t// leaseTime needs to be in seconds\n\t\tleaseTime := uint64(s.leaseTime / time.Second)\n\n\t\t// NB: GuaranteedUpdate does not perform the store operation unless\n\t\t// something changed between load and store (not including resource\n\t\t// version), meaning we can't refresh the TTL without actually\n\t\t// changing a field.\n\t\texisting.Generation++\n\n\t\tklog.V(6).Infof(\"Resetting TTL on master IP %q listed in storage to %v\", ip, leaseTime)\n\n\t\treturn existing, &leaseTime, nil\n\t})\n}", "category": "Python"}, {"instruction": "// CompareKubeAwareVersionStrings compares two kube-like version strings.\n// Kube-like version strings are starting with a v, followed by a major version, optional \"alpha\" or \"beta\" strings\n// followed by a minor version (e.g. v1, v2beta1). Versions will be sorted based on GA/alpha/beta first and then major\n// and minor versions. e.g. v2, v1, v1beta2, v1beta1, v1alpha1.", "input": "go language", "output": "func CompareKubeAwareVersionStrings(v1, v2 string) int {\n\tif v1 == v2 {\n\t\treturn 0\n\t}\n\tv1major, v1type, v1minor, ok1 := parseKubeVersion(v1)\n\tv2major, v2type, v2minor, ok2 := parseKubeVersion(v2)\n\tswitch {\n\tcase !ok1 && !ok2:\n\t\treturn strings.Compare(v2, v1)\n\tcase !ok1 && ok2:\n\t\treturn -1\n\tcase ok1 && !ok2:\n\t\treturn 1\n\t}\n\tif v1type != v2type {\n\t\treturn int(v1type) - int(v2type)\n\t}\n\tif v1major != v2major {\n\t\treturn v1major - v2major\n\t}\n\treturn v1minor - v2minor\n}", "category": "Python"}, {"instruction": "// CreateOrRetainConfigMap creates a ConfigMap if the target resource doesn't exist. If the resource exists already, this function will retain the resource instead.", "input": "go language", "output": "func CreateOrRetainConfigMap(client clientset.Interface, cm *v1.ConfigMap, configMapName string) error {\n\tif _, err := client.CoreV1().ConfigMaps(cm.ObjectMeta.Namespace).Get(configMapName, metav1.GetOptions{}); err != nil {\n\t\tif !apierrors.IsNotFound(err) {\n\t\t\treturn nil\n\t\t}\n\t\tif _, err := client.CoreV1().ConfigMaps(cm.ObjectMeta.Namespace).Create(cm); err != nil {\n\t\t\tif !apierrors.IsAlreadyExists(err) {\n\t\t\t\treturn errors.Wrap(err, \"unable to create configmap\")\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// NewDatabaseWithCache creates a new trie database to store ephemeral trie content\n// before its written out to disk or garbage collected. It also acts as a read cache\n// for nodes loaded from disk.", "input": "go language", "output": "func NewDatabaseWithCache(diskdb ethdb.KeyValueStore, cache int) *Database {\n\tvar cleans *bigcache.BigCache\n\tif cache > 0 {\n\t\tcleans, _ = bigcache.NewBigCache(bigcache.Config{\n\t\t\tShards:             1024,\n\t\t\tLifeWindow:         time.Hour,\n\t\t\tMaxEntriesInWindow: cache * 1024,\n\t\t\tMaxEntrySize:       512,\n\t\t\tHardMaxCacheSize:   cache,\n\t\t\tHasher:             trienodeHasher{},\n\t\t})\n\t}\n\treturn &Database{\n\t\tdiskdb: diskdb,\n\t\tcleans: cleans,\n\t\tdirties: map[common.Hash]*cachedNode{{}: {\n\t\t\tchildren: make(map[common.Hash]uint16),\n\t\t}},\n\t\tpreimages: make(map[common.Hash][]byte),\n\t}\n}", "category": "Python"}, {"instruction": "// dataForPseudoProfiling returns pseudo data for table profiling when system variable `profiling` is set to `ON`.", "input": "go language", "output": "func dataForPseudoProfiling() [][]types.Datum {\n\tvar rows [][]types.Datum\n\trow := types.MakeDatums(\n\t\t0,                      // QUERY_ID\n\t\t0,                      // SEQ\n\t\t\"\",                     // STATE\n\t\ttypes.NewDecFromInt(0), // DURATION\n\t\ttypes.NewDecFromInt(0), // CPU_USER\n\t\ttypes.NewDecFromInt(0), // CPU_SYSTEM\n\t\t0,                      // CONTEXT_VOLUNTARY\n\t\t0,                      // CONTEXT_INVOLUNTARY\n\t\t0,                      // BLOCK_OPS_IN\n\t\t0,                      // BLOCK_OPS_OUT\n\t\t0,                      // MESSAGES_SENT\n\t\t0,                      // MESSAGES_RECEIVED\n\t\t0,                      // PAGE_FAULTS_MAJOR\n\t\t0,                      // PAGE_FAULTS_MINOR\n\t\t0,                      // SWAPS\n\t\t\"\",                     // SOURCE_FUNCTION\n\t\t\"\",                     // SOURCE_FILE\n\t\t0,                      // SOURCE_LINE\n\t)\n\trows = append(rows, row)\n\treturn rows\n}", "category": "Python"}, {"instruction": "// GetNetworkDriverList returns the list of plugins drivers\n// registered for network.", "input": "go language", "output": "func (daemon *Daemon) GetNetworkDriverList() []string {\n\tif !daemon.NetworkControllerEnabled() {\n\t\treturn nil\n\t}\n\n\tpluginList := daemon.netController.BuiltinDrivers()\n\n\tmanagedPlugins := daemon.PluginStore.GetAllManagedPluginsByCap(driverapi.NetworkPluginEndpointType)\n\n\tfor _, plugin := range managedPlugins {\n\t\tpluginList = append(pluginList, plugin.Name())\n\t}\n\n\tpluginMap := make(map[string]bool)\n\tfor _, plugin := range pluginList {\n\t\tpluginMap[plugin] = true\n\t}\n\n\tnetworks := daemon.netController.Networks()\n\n\tfor _, network := range networks {\n\t\tif !pluginMap[network.Type()] {\n\t\t\tpluginList = append(pluginList, network.Type())\n\t\t\tpluginMap[network.Type()] = true\n\t\t}\n\t}\n\n\tsort.Strings(pluginList)\n\n\treturn pluginList\n}", "category": "Python"}, {"instruction": "// ListLeases retrieves a list of the current master IPs from storage", "input": "go language", "output": "func (s *storageLeases) ListLeases() ([]string, error) {\n\tipInfoList := &corev1.EndpointsList{}\n\tif err := s.storage.List(apirequest.NewDefaultContext(), s.baseKey, \"0\", storage.Everything, ipInfoList); err != nil {\n\t\treturn nil, err\n\t}\n\n\tipList := make([]string, len(ipInfoList.Items))\n\tfor i, ip := range ipInfoList.Items {\n\t\tipList[i] = ip.Subsets[0].Addresses[0].IP\n\t}\n\n\tklog.V(6).Infof(\"Current master IPs listed in storage are %v\", ipList)\n\n\treturn ipList, nil\n}", "category": "Python"}, {"instruction": "// List takes label and field selectors, and returns the list of DaemonSets that match those selectors.", "input": "go language", "output": "func (c *FakeDaemonSets) List(opts v1.ListOptions) (result *v1beta2.DaemonSetList, err error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewListAction(daemonsetsResource, daemonsetsKind, c.ns, opts), &v1beta2.DaemonSetList{})\n\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n\tif label == nil {\n\t\tlabel = labels.Everything()\n\t}\n\tlist := &v1beta2.DaemonSetList{ListMeta: obj.(*v1beta2.DaemonSetList).ListMeta}\n\tfor _, item := range obj.(*v1beta2.DaemonSetList).Items {\n\t\tif label.Matches(labels.Set(item.Labels)) {\n\t\t\tlist.Items = append(list.Items, item)\n\t\t}\n\t}\n\treturn list, err\n}", "category": "Python"}, {"instruction": "// create is used as the entry function for \"create\" app command.", "input": "go language", "output": "func create(ctx *cli.Context) error {\n\tlog.PrintOrigins(true)\n\tlog.Root().SetHandler(log.LvlFilterHandler(log.Lvl(ctx.Int(\"verbosity\")), log.StreamHandler(os.Stdout, log.TerminalFormat(true))))\n\n\tif len(ctx.Args()) < 1 {\n\t\treturn errors.New(\"argument should be the filename to verify or write-to\")\n\t}\n\tfilename, err := touchPath(ctx.Args()[0])\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn createSnapshot(filename, ctx.Int(\"nodes\"), strings.Split(ctx.String(\"services\"), \",\"))\n}", "category": "Python"}, {"instruction": "// Validate makes sure there is no discrepency in provided option values", "input": "go language", "output": "func (o *CreateRoleOptions) Validate() error {\n\tif o.Name == \"\" {\n\t\treturn fmt.Errorf(\"name must be specified\")\n\t}\n\n\t// validate verbs.\n\tif len(o.Verbs) == 0 {\n\t\treturn fmt.Errorf(\"at least one verb must be specified\")\n\t}\n\n\tfor _, v := range o.Verbs {\n\t\tif !arrayContains(validResourceVerbs, v) {\n\t\t\treturn fmt.Errorf(\"invalid verb: '%s'\", v)\n\t\t}\n\t}\n\n\t// validate resources.\n\tif len(o.Resources) == 0 {\n\t\treturn fmt.Errorf(\"at least one resource must be specified\")\n\t}\n\n\treturn o.validateResource()\n}", "category": "Python"}, {"instruction": "// GraphNodeProviderConsumer", "input": "go language", "output": "func (n *NodeAbstractResource) ProvidedBy() (addrs.AbsProviderConfig, bool) {\n\t// If we have a config we prefer that above all else\n\tif n.Config != nil {\n\t\trelAddr := n.Config.ProviderConfigAddr()\n\t\treturn relAddr.Absolute(n.Path()), false\n\t}\n\n\t// Use our type and containing module path to guess a provider configuration address\n\treturn n.Addr.Resource.DefaultProviderConfig().Absolute(n.Addr.Module), false\n}", "category": "Python"}, {"instruction": "// nodeCheckTxn is used as the inner method to handle reading a health check\n// from the state store.", "input": "go language", "output": "func (s *Store) getNodeCheckTxn(tx *memdb.Txn, nodeName string, checkID types.CheckID) (uint64, *structs.HealthCheck, error) {\n\t// Get the table index.\n\tidx := maxIndexTxn(tx, \"checks\")\n\n\t// Return the check.\n\tcheck, err := tx.First(\"checks\", \"id\", nodeName, string(checkID))\n\tif err != nil {\n\t\treturn 0, nil, fmt.Errorf(\"failed check lookup: %s\", err)\n\t}\n\n\tif check != nil {\n\t\treturn idx, check.(*structs.HealthCheck), nil\n\t}\n\treturn idx, nil, nil\n}", "category": "Python"}, {"instruction": "// getResourceNamesForGroup is a private method for getting the canonical names for each resource to build in an api group", "input": "go language", "output": "func getResourceNamesForGroup(apiPrefix string, apiGroupInfo *APIGroupInfo, pathsToIgnore openapiutil.Trie) ([]string, error) {\n\t// Get the canonical names of every resource we need to build in this api group\n\tresourceNames := make([]string, 0)\n\tfor _, groupVersion := range apiGroupInfo.PrioritizedVersions {\n\t\tfor resource, storage := range apiGroupInfo.VersionedResourcesStorageMap[groupVersion.Version] {\n\t\t\tpath := gpath.Join(apiPrefix, groupVersion.Group, groupVersion.Version, resource)\n\t\t\tif !pathsToIgnore.HasPrefix(path) {\n\t\t\t\tkind, err := genericapi.GetResourceKind(groupVersion, storage, apiGroupInfo.Scheme)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tsampleObject, err := apiGroupInfo.Scheme.New(kind)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tname := openapiutil.GetCanonicalTypeName(sampleObject)\n\t\t\t\tresourceNames = append(resourceNames, name)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn resourceNames, nil\n}", "category": "Python"}, {"instruction": "// GetZoneByNodeName gets availability zone for the specified node. If the node is not running\n// with availability zone, then it returns fault domain.", "input": "go language", "output": "func (as *availabilitySet) GetZoneByNodeName(name string) (cloudprovider.Zone, error) {\n\tvm, err := as.getVirtualMachine(types.NodeName(name))\n\tif err != nil {\n\t\treturn cloudprovider.Zone{}, err\n\t}\n\n\tvar failureDomain string\n\tif vm.Zones != nil && len(*vm.Zones) > 0 {\n\t\t// Get availability zone for the node.\n\t\tzones := *vm.Zones\n\t\tzoneID, err := strconv.Atoi(zones[0])\n\t\tif err != nil {\n\t\t\treturn cloudprovider.Zone{}, fmt.Errorf(\"failed to parse zone %q: %v\", zones, err)\n\t\t}\n\n\t\tfailureDomain = as.makeZone(zoneID)\n\t} else {\n\t\t// Availability zone is not used for the node, falling back to fault domain.\n\t\tfailureDomain = strconv.Itoa(int(*vm.VirtualMachineProperties.InstanceView.PlatformFaultDomain))\n\t}\n\n\tzone := cloudprovider.Zone{\n\t\tFailureDomain: failureDomain,\n\t\tRegion:        *(vm.Location),\n\t}\n\treturn zone, nil\n}", "category": "Python"}, {"instruction": "// GetRoleReferenceRules attempts to resolve the RoleBinding or ClusterRoleBinding.", "input": "go language", "output": "func (r *DefaultRuleResolver) GetRoleReferenceRules(roleRef rbacv1.RoleRef, bindingNamespace string) ([]rbacv1.PolicyRule, error) {\n\tswitch roleRef.Kind {\n\tcase \"Role\":\n\t\trole, err := r.roleGetter.GetRole(bindingNamespace, roleRef.Name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn role.Rules, nil\n\n\tcase \"ClusterRole\":\n\t\tclusterRole, err := r.clusterRoleGetter.GetClusterRole(roleRef.Name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn clusterRole.Rules, nil\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported role reference kind: %q\", roleRef.Kind)\n\t}\n}", "category": "Python"}, {"instruction": "// PrintFs prints the given filesystem to the given writer starting from the given path.\n// This is useful for debugging.", "input": "go language", "output": "func PrintFs(fs afero.Fs, path string, w io.Writer) {\n\tif fs == nil {\n\t\treturn\n\t}\n\tafero.Walk(fs, path, func(path string, info os.FileInfo, err error) error {\n\t\tif info != nil && !info.IsDir() {\n\t\t\ts := path\n\t\t\tif lang, ok := info.(hugofs.LanguageAnnouncer); ok {\n\t\t\t\ts = s + \"\\tLANG: \" + lang.Lang()\n\t\t\t}\n\t\t\tif fp, ok := info.(hugofs.FilePather); ok {\n\t\t\t\ts = s + \"\\tRF: \" + fp.Filename() + \"\\tBP: \" + fp.BaseDir()\n\t\t\t}\n\t\t\tfmt.Fprintln(w, \"    \", s)\n\t\t}\n\t\treturn nil\n\t})\n}", "category": "Python"}, {"instruction": "// bitsetEncodeBytes compresses the input byte slice according to the sparse\n// bitset representation algorithm.", "input": "go language", "output": "func bitsetEncodeBytes(data []byte) []byte {\n\t// Empty slices get compressed to nil\n\tif len(data) == 0 {\n\t\treturn nil\n\t}\n\t// One byte slices compress to nil or retain the single byte\n\tif len(data) == 1 {\n\t\tif data[0] == 0 {\n\t\t\treturn nil\n\t\t}\n\t\treturn data\n\t}\n\t// Calculate the bitset of set bytes, and gather the non-zero bytes\n\tnonZeroBitset := make([]byte, (len(data)+7)/8)\n\tnonZeroBytes := make([]byte, 0, len(data))\n\n\tfor i, b := range data {\n\t\tif b != 0 {\n\t\t\tnonZeroBytes = append(nonZeroBytes, b)\n\t\t\tnonZeroBitset[i/8] |= 1 << byte(7-i%8)\n\t\t}\n\t}\n\tif len(nonZeroBytes) == 0 {\n\t\treturn nil\n\t}\n\treturn append(bitsetEncodeBytes(nonZeroBitset), nonZeroBytes...)\n}", "category": "Python"}, {"instruction": "// Patch applies the patch and returns the patched validatingWebhookConfiguration.", "input": "go language", "output": "func (c *FakeValidatingWebhookConfigurations) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1beta1.ValidatingWebhookConfiguration, err error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewRootPatchSubresourceAction(validatingwebhookconfigurationsResource, name, pt, data, subresources...), &v1beta1.ValidatingWebhookConfiguration{})\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\treturn obj.(*v1beta1.ValidatingWebhookConfiguration), err\n}", "category": "Python"}, {"instruction": "// bumpInBucket moves the given node to the front of the bucket entry list\n// if it is contained in that list.", "input": "go language", "output": "func (tab *Table) bumpInBucket(b *bucket, n *node) bool {\n\tfor i := range b.entries {\n\t\tif b.entries[i].ID() == n.ID() {\n\t\t\tif !n.IP().Equal(b.entries[i].IP()) {\n\t\t\t\t// Endpoint has changed, ensure that the new IP fits into table limits.\n\t\t\t\ttab.removeIP(b, b.entries[i].IP())\n\t\t\t\tif !tab.addIP(b, n.IP()) {\n\t\t\t\t\t// It doesn't, put the previous one back.\n\t\t\t\t\ttab.addIP(b, b.entries[i].IP())\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Move it to the front.\n\t\t\tcopy(b.entries[1:], b.entries[:i])\n\t\t\tb.entries[0] = n\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "category": "Python"}, {"instruction": "// semverCompare returns whether the client's version is older, equal or newer than the given image's version.", "input": "go language", "output": "func semverCompare(image string) int {\n\tsplit := strings.Split(image, \":\")\n\tif len(split) < 2 {\n\t\t// If we don't know the version, we consider the client version newer.\n\t\treturn 1\n\t}\n\ttillerVersion, err := semver.NewVersion(split[1])\n\tif err != nil {\n\t\t// same thing with unparsable tiller versions (e.g. canary releases).\n\t\treturn 1\n\t}\n\tclientVersion, err := semver.NewVersion(version.Version)\n\tif err != nil {\n\t\t// aaaaaand same thing with unparsable helm versions (e.g. canary releases).\n\t\treturn 1\n\t}\n\treturn clientVersion.Compare(tillerVersion)\n}", "category": "Python"}, {"instruction": "// SetServerRootCAs sets the list of authorities used to verify server\n// certificates based on a list of PEM-encoded X509 certificate authorities", "input": "go language", "output": "func (client *GRPCClient) SetServerRootCAs(serverRoots [][]byte) error {\n\n\t// NOTE: if no serverRoots are specified, the current cert pool will be\n\t// replaced with an empty one\n\tcertPool := x509.NewCertPool()\n\tfor _, root := range serverRoots {\n\t\terr := AddPemToCertPool(root, certPool)\n\t\tif err != nil {\n\t\t\treturn errors.WithMessage(err, \"error adding root certificate\")\n\t\t}\n\t}\n\tclient.tlsConfig.RootCAs = certPool\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Log is intended to be called once at the end of your request handler, via defer", "input": "go language", "output": "func (rl *respLogger) Log() {\n\tlatency := time.Since(rl.startTime)\n\tif klog.V(3) {\n\t\tif !rl.hijacked {\n\t\t\tklog.InfoDepth(1, fmt.Sprintf(\"%s %s: (%v) %v%v%v [%s %s]\", rl.req.Method, rl.req.RequestURI, latency, rl.status, rl.statusStack, rl.addedInfo, rl.req.UserAgent(), rl.req.RemoteAddr))\n\t\t} else {\n\t\t\tklog.InfoDepth(1, fmt.Sprintf(\"%s %s: (%v) hijacked [%s %s]\", rl.req.Method, rl.req.RequestURI, latency, rl.req.UserAgent(), rl.req.RemoteAddr))\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// Next implements the Executor Next interface.", "input": "go language", "output": "func (e *CheckTableExec) Next(ctx context.Context, req *chunk.RecordBatch) error {\n\tif e.done {\n\t\treturn nil\n\t}\n\tdefer func() { e.done = true }()\n\tfor _, t := range e.tables {\n\t\tdbName := t.DBInfo.Name\n\t\ttb, err := e.is.TableByName(dbName, t.Name)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif tb.Meta().GetPartitionInfo() != nil {\n\t\t\terr = e.doCheckPartitionedTable(tb.(table.PartitionedTable))\n\t\t} else {\n\t\t\terr = e.doCheckTable(tb)\n\t\t}\n\t\tif err != nil {\n\t\t\tlogutil.Logger(ctx).Warn(\"check table failed\", zap.String(\"tableName\", t.Name.O), zap.Error(err))\n\t\t\tif admin.ErrDataInConsistent.Equal(err) {\n\t\t\t\treturn ErrAdminCheckTable.GenWithStack(\"%v err:%v\", t.Name, err)\n\t\t\t}\n\n\t\t\treturn errors.Errorf(\"%v err:%v\", t.Name, err)\n\t\t}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// StrToUint converts a string to an unsigned integer at the best-effortt.", "input": "go language", "output": "func StrToUint(sc *stmtctx.StatementContext, str string) (uint64, error) {\n\tstr = strings.TrimSpace(str)\n\tvalidPrefix, err := getValidIntPrefix(sc, str)\n\tif validPrefix[0] == '+' {\n\t\tvalidPrefix = validPrefix[1:]\n\t}\n\tuVal, err1 := strconv.ParseUint(validPrefix, 10, 64)\n\tif err1 != nil {\n\t\treturn uVal, ErrOverflow.GenWithStackByArgs(\"BIGINT UNSIGNED\", validPrefix)\n\t}\n\treturn uVal, errors.Trace(err)\n}", "category": "Python"}, {"instruction": "// isForbidden determines if an import is forbidden,\n// which is true when the import is:\n//   - of a package under the rootPackage\n//   - is not of the base import path or a sub-package of it\n//   - is not of an allowed path or a sub-package of one", "input": "go language", "output": "func (i *ImportRestriction) isForbidden(imp string) bool {\n\timportsBelowRoot := strings.HasPrefix(imp, rootPackage)\n\timportsBelowBase := strings.HasPrefix(imp, i.BaseDir)\n\timportsAllowed := false\n\tfor _, allowed := range i.AllowedImports {\n\t\texactlyImportsAllowed := imp == allowed\n\t\timportsBelowAllowed := strings.HasPrefix(imp, fmt.Sprintf(\"%s/\", allowed))\n\t\timportsAllowed = importsAllowed || (importsBelowAllowed || exactlyImportsAllowed)\n\t}\n\n\treturn importsBelowRoot && !importsBelowBase && !importsAllowed\n}", "category": "Python"}, {"instruction": "// adjustColumnInfoInAddColumn is used to set the correct position of column info when adding column.\n// 1. The added column was append at the end of tblInfo.Columns, due to ddl state was not public then.\n//    It should be moved to the correct position when the ddl state to be changed to public.\n// 2. The offset of column should also to be set to the right value.", "input": "go language", "output": "func adjustColumnInfoInAddColumn(tblInfo *model.TableInfo, offset int) {\n\toldCols := tblInfo.Columns\n\tnewCols := make([]*model.ColumnInfo, 0, len(oldCols))\n\tnewCols = append(newCols, oldCols[:offset]...)\n\tnewCols = append(newCols, oldCols[len(oldCols)-1])\n\tnewCols = append(newCols, oldCols[offset:len(oldCols)-1]...)\n\t// Adjust column offset.\n\toffsetChanged := make(map[int]int)\n\tfor i := offset + 1; i < len(newCols); i++ {\n\t\toffsetChanged[newCols[i].Offset] = i\n\t\tnewCols[i].Offset = i\n\t}\n\tnewCols[offset].Offset = offset\n\t// Update index column offset info.\n\t// TODO: There may be some corner cases for index column offsets, we may check this later.\n\tfor _, idx := range tblInfo.Indices {\n\t\tfor _, col := range idx.Columns {\n\t\t\tnewOffset, ok := offsetChanged[col.Offset]\n\t\t\tif ok {\n\t\t\t\tcol.Offset = newOffset\n\t\t\t}\n\t\t}\n\t}\n\ttblInfo.Columns = newCols\n}", "category": "Python"}, {"instruction": "// ViewHistory returns a list of the revision history of a statefulset\n// TODO: this should be a describer\n// TODO: needs to implement detailed revision view", "input": "go language", "output": "func (h *StatefulSetHistoryViewer) ViewHistory(namespace, name string, revision int64) (string, error) {\n\t_, history, err := statefulSetHistory(h.c.AppsV1(), namespace, name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif len(history) <= 0 {\n\t\treturn \"No rollout history found.\", nil\n\t}\n\trevisions := make([]int64, len(history))\n\tfor _, revision := range history {\n\t\trevisions = append(revisions, revision.Revision)\n\t}\n\tsliceutil.SortInts64(revisions)\n\n\treturn tabbedString(func(out io.Writer) error {\n\t\tfmt.Fprintf(out, \"REVISION\\n\")\n\t\tfor _, r := range revisions {\n\t\t\tfmt.Fprintf(out, \"%d\\n\", r)\n\t\t}\n\t\treturn nil\n\t})\n}", "category": "Python"}, {"instruction": "// Get returns the rootfs path for the id. It is reference counted and\n// effectively can be thought of as a \"mount the layer into the utility\n// vm if it isn't already\". The contract from the caller of this is that\n// all Gets and Puts are matched. It -should- be the case that on cleanup,\n// nothing is mounted.\n//\n// For optimisation, we don't actually mount the filesystem (which in our\n// case means [hot-]adding it to a service VM. But we track that and defer\n// the actual adding to the point we need to access it.", "input": "go language", "output": "func (d *Driver) Get(id, mountLabel string) (containerfs.ContainerFS, error) {\n\ttitle := fmt.Sprintf(\"lcowdriver: get: %s\", id)\n\tlogrus.Debugf(title)\n\n\t// Generate the mounts needed for the deferred operation.\n\tdisks, err := d.getAllMounts(id)\n\tif err != nil {\n\t\tlogrus.Debugf(\"%s failed to get all layer details for %s: %s\", title, d.dir(id), err)\n\t\treturn nil, fmt.Errorf(\"%s failed to get layer details for %s: %s\", title, d.dir(id), err)\n\t}\n\n\tlogrus.Debugf(\"%s: got layer mounts: %+v\", title, disks)\n\treturn &lcowfs{\n\t\troot:        unionMountName(disks),\n\t\td:           d,\n\t\tmappedDisks: disks,\n\t\tvmID:        d.getVMID(id),\n\t}, nil\n}", "category": "Python"}, {"instruction": "// AddFlags registers flags for a cli", "input": "go language", "output": "func (flags *WaitFlags) AddFlags(cmd *cobra.Command) {\n\tflags.PrintFlags.AddFlags(cmd)\n\tflags.ResourceBuilderFlags.AddFlags(cmd.Flags())\n\n\tcmd.Flags().DurationVar(&flags.Timeout, \"timeout\", flags.Timeout, \"The length of time to wait before giving up.  Zero means check once and don't wait, negative means wait for a week.\")\n\tcmd.Flags().StringVar(&flags.ForCondition, \"for\", flags.ForCondition, \"The condition to wait on: [delete|condition=condition-name].\")\n}", "category": "Python"}, {"instruction": "// saves state to a file, caller is responsible for locking", "input": "go language", "output": "func (sf *stateFile) storeState() {\n\tvar content []byte\n\tvar err error\n\n\tdata := stateFileData{\n\t\tPolicyName:    sf.policyName,\n\t\tDefaultCPUSet: sf.cache.GetDefaultCPUSet().String(),\n\t\tEntries:       map[string]string{},\n\t}\n\n\tfor containerID, cset := range sf.cache.GetCPUAssignments() {\n\t\tdata.Entries[containerID] = cset.String()\n\t}\n\n\tif content, err = json.Marshal(data); err != nil {\n\t\tpanic(\"[cpumanager] state file: could not serialize state to json\")\n\t}\n\n\tif err = ioutil.WriteFile(sf.stateFilePath, content, 0644); err != nil {\n\t\tpanic(\"[cpumanager] state file not written\")\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *LabelSelector) DeepCopyInto(out *LabelSelector) {\n\t*out = *in\n\tif in.MatchLabels != nil {\n\t\tin, out := &in.MatchLabels, &out.MatchLabels\n\t\t*out = make(map[string]string, len(*in))\n\t\tfor key, val := range *in {\n\t\t\t(*out)[key] = val\n\t\t}\n\t}\n\tif in.MatchExpressions != nil {\n\t\tin, out := &in.MatchExpressions, &out.MatchExpressions\n\t\t*out = make([]LabelSelectorRequirement, len(*in))\n\t\tfor i := range *in {\n\t\t\t(*in)[i].DeepCopyInto(&(*out)[i])\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// checkArgs makes sure all the arguments' types are known and can be handled.\n// integer types are converted to int64 and uint64, time.Time is converted to types.Time.\n// time.Duration is converted to types.Duration, other known types are leaved as it is.", "input": "go language", "output": "func checkArgs(args ...interface{}) error {\n\tfor i, v := range args {\n\t\tswitch x := v.(type) {\n\t\tcase bool:\n\t\t\tif x {\n\t\t\t\targs[i] = int64(1)\n\t\t\t} else {\n\t\t\t\targs[i] = int64(0)\n\t\t\t}\n\t\tcase int8:\n\t\t\targs[i] = int64(x)\n\t\tcase int16:\n\t\t\targs[i] = int64(x)\n\t\tcase int32:\n\t\t\targs[i] = int64(x)\n\t\tcase int:\n\t\t\targs[i] = int64(x)\n\t\tcase uint8:\n\t\t\targs[i] = uint64(x)\n\t\tcase uint16:\n\t\t\targs[i] = uint64(x)\n\t\tcase uint32:\n\t\t\targs[i] = uint64(x)\n\t\tcase uint:\n\t\t\targs[i] = uint64(x)\n\t\tcase int64:\n\t\tcase uint64:\n\t\tcase float32:\n\t\tcase float64:\n\t\tcase string:\n\t\tcase []byte:\n\t\tcase time.Duration:\n\t\t\targs[i] = types.Duration{Duration: x}\n\t\tcase time.Time:\n\t\t\targs[i] = types.Time{Time: types.FromGoTime(x), Type: mysql.TypeDatetime}\n\t\tcase nil:\n\t\tdefault:\n\t\t\treturn errors.Errorf(\"cannot use arg[%d] (type %T):unsupported type\", i, v)\n\t\t}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Execute executes the command", "input": "go language", "output": "func (pc *ConfigCmd) Execute(conf common.Config) error {\n\tif pc.server == nil || *pc.server == \"\" {\n\t\treturn errors.New(\"no server specified\")\n\t}\n\tif pc.channel == nil || *pc.channel == \"\" {\n\t\treturn errors.New(\"no channel specified\")\n\t}\n\n\tserver := *pc.server\n\tchannel := *pc.channel\n\n\treq := discovery.NewRequest().OfChannel(channel).AddConfigQuery()\n\tres, err := pc.stub.Send(server, conf, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pc.parser.ParseResponse(channel, res)\n}", "category": "Python"}, {"instruction": "// NewLeaderElectionService returns a new LeaderElectionService", "input": "go language", "output": "func NewLeaderElectionService(adapter LeaderElectionAdapter, id string, callback leadershipCallback, config ElectionConfig) LeaderElectionService {\n\tif len(id) == 0 {\n\t\tpanic(\"Empty id\")\n\t}\n\tle := &leaderElectionSvcImpl{\n\t\tid:            peerID(id),\n\t\tproposals:     util.NewSet(),\n\t\tadapter:       adapter,\n\t\tstopChan:      make(chan struct{}, 1),\n\t\tinterruptChan: make(chan struct{}, 1),\n\t\tlogger:        util.GetLogger(util.ElectionLogger, \"\"),\n\t\tcallback:      noopCallback,\n\t\tconfig:        config,\n\t}\n\n\tif callback != nil {\n\t\tle.callback = callback\n\t}\n\n\tgo le.start()\n\treturn le\n}", "category": "Python"}, {"instruction": "// TarResourceRebase is like TarResource but renames the first path element of\n// items in the resulting tar archive to match the given rebaseName if not \"\".", "input": "go language", "output": "func TarResourceRebase(sourcePath, rebaseName string) (content io.ReadCloser, err error) {\n\tsourcePath = normalizePath(sourcePath)\n\tif _, err = os.Lstat(sourcePath); err != nil {\n\t\t// Catches the case where the source does not exist or is not a\n\t\t// directory if asserted to be a directory, as this also causes an\n\t\t// error.\n\t\treturn\n\t}\n\n\t// Separate the source path between its directory and\n\t// the entry in that directory which we are archiving.\n\tsourceDir, sourceBase := SplitPathDirEntry(sourcePath)\n\topts := TarResourceRebaseOpts(sourceBase, rebaseName)\n\n\tlogrus.Debugf(\"copying %q from %q\", sourceBase, sourceDir)\n\treturn TarWithOptions(sourceDir, opts)\n}", "category": "Python"}, {"instruction": "// SetContentHash sets the content hash associated with a name. Only works if the caller\n// owns the name, and the associated resolver implements a `setContenthash` function.", "input": "go language", "output": "func (ens *ENS) SetContentHash(name string, hash []byte) (*types.Transaction, error) {\n\tnode := EnsNode(name)\n\n\tresolver, err := ens.getResolver(node)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\topts := ens.TransactOpts\n\topts.GasLimit = 200000\n\n\t// IMPORTANT: The old contract is deprecated. This code should be removed latest on June 1st 2019\n\tsupported, err := resolver.SupportsInterface(contentHash_Interface_Id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !supported {\n\t\tresolver, err := ens.getFallbackResolver(node)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\topts := ens.TransactOpts\n\t\topts.GasLimit = 200000\n\t\tvar b [32]byte\n\t\tcopy(b[:], hash)\n\t\treturn resolver.Contract.SetContent(&opts, node, b)\n\t}\n\n\t// END DEPRECATED CODE\n\treturn resolver.Contract.SetContenthash(&opts, node, hash)\n}", "category": "Python"}, {"instruction": "// initPvtdataStoreFromExistingBlockchain updates the initial state of the pvtdata store\n// if an existing block store has a blockchain and the pvtdata store is empty.\n// This situation is expected to happen when a peer is upgrated from version 1.0\n// and an existing blockchain is present that was generated with version 1.0.\n// Under this scenario, the pvtdata store is brought upto the point as if it has\n// processed existing blocks with no pvt data. This function returns true if the\n// above mentioned condition is found to be true and pvtdata store is successfully updated", "input": "go language", "output": "func (s *Store) initPvtdataStoreFromExistingBlockchain() (bool, error) {\n\tvar bcInfo *common.BlockchainInfo\n\tvar pvtdataStoreEmpty bool\n\tvar err error\n\n\tif bcInfo, err = s.BlockStore.GetBlockchainInfo(); err != nil {\n\t\treturn false, err\n\t}\n\tif pvtdataStoreEmpty, err = s.pvtdataStore.IsEmpty(); err != nil {\n\t\treturn false, err\n\t}\n\tif pvtdataStoreEmpty && bcInfo.Height > 0 {\n\t\tif err = s.pvtdataStore.InitLastCommittedBlock(bcInfo.Height - 1); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}", "category": "Python"}, {"instruction": "// resolveInputIPAddr tries to resolve the IP address from the string passed as input\n// - tries to match the string as an interface name, if so returns the IP address associated with it\n// - on failure of previous step tries to parse the string as an IP address itself\n//\t if succeeds returns the IP address", "input": "go language", "output": "func resolveInputIPAddr(input string, isUnspecifiedValid bool) (net.IP, error) {\n\t// Try to see if it is an interface name\n\tinterfaceAddr, err := resolveInterfaceAddr(input)\n\tif err == nil {\n\t\treturn interfaceAddr, nil\n\t}\n\t// String matched interface but there is a potential ambiguity to be resolved\n\tif err != errNoSuchInterface {\n\t\treturn nil, err\n\t}\n\n\t// String is not an interface check if it is a valid IP\n\tif ip := net.ParseIP(input); ip != nil && (isUnspecifiedValid || !ip.IsUnspecified()) {\n\t\treturn ip, nil\n\t}\n\n\t// Not valid IP found\n\treturn nil, errBadNetworkIdentifier\n}", "category": "Python"}, {"instruction": "// Detach the given device from the given host.", "input": "go language", "output": "func (detacher *photonPersistentDiskDetacher) Detach(volumeName string, nodeName types.NodeName) error {\n\n\thostName := string(nodeName)\n\tpdID := volumeName\n\tattached, err := detacher.photonDisks.DiskIsAttached(context.TODO(), pdID, nodeName)\n\tif err != nil {\n\t\t// Log error and continue with detach\n\t\tklog.Errorf(\n\t\t\t\"Error checking if persistent disk (%q) is already attached to current node (%q). Will continue and try detach anyway. err=%v\",\n\t\t\tpdID, hostName, err)\n\t}\n\n\tif err == nil && !attached {\n\t\t// Volume is already detached from node.\n\t\tklog.V(4).Infof(\"detach operation was successful. persistent disk %q is already detached from node %q.\", pdID, hostName)\n\t\treturn nil\n\t}\n\n\tif err := detacher.photonDisks.DetachDisk(context.TODO(), pdID, nodeName); err != nil {\n\t\tklog.Errorf(\"Error detaching volume %q: %v\", pdID, err)\n\t\treturn err\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// preparedQueryCreate makes a new prepared query.", "input": "go language", "output": "func (s *HTTPServer) preparedQueryCreate(resp http.ResponseWriter, req *http.Request) (interface{}, error) {\n\targs := structs.PreparedQueryRequest{\n\t\tOp: structs.PreparedQueryCreate,\n\t}\n\ts.parseDC(req, &args.Datacenter)\n\ts.parseToken(req, &args.Token)\n\tif err := decodeBody(req, &args.Query, nil); err != nil {\n\t\tresp.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprintf(resp, \"Request decode failed: %v\", err)\n\t\treturn nil, nil\n\t}\n\n\tvar reply string\n\tif err := s.agent.RPC(\"PreparedQuery.Apply\", &args, &reply); err != nil {\n\t\treturn nil, err\n\t}\n\treturn preparedQueryCreateResponse{reply}, nil\n}", "category": "Python"}, {"instruction": "// snapshot is the internal function analogous to Snapshot but expects\n// a lock to already be held.\n//\n// checkDup when set will store the snapshot on lastSnapshot and use\n// reflect.DeepEqual to verify that its not writing an identical snapshot.", "input": "go language", "output": "func (m *Manager) snapshot(path string, checkDup bool) error {\n\t// Build the snapshot\n\ts := snapshot{\n\t\tVersion: snapshotVersion,\n\t\tProxies: make(map[string]snapshotProxy, len(m.proxies)),\n\t}\n\tfor id, p := range m.proxies {\n\t\t// Get the snapshot configuration. If the configuration is nil or\n\t\t// empty then we don't persist this proxy.\n\t\tconfig := p.MarshalSnapshot()\n\t\tif len(config) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\ts.Proxies[id] = snapshotProxy{\n\t\t\tMode:   proxyExecMode(p),\n\t\t\tConfig: config,\n\t\t}\n\t}\n\n\t// Dup detection, if the snapshot is identical to the last, do nothing\n\tif checkDup && reflect.DeepEqual(m.lastSnapshot, &s) {\n\t\treturn nil\n\t}\n\n\t// Encode as JSON\n\tencoded, err := json.Marshal(&s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Write the file\n\terr = file.WriteAtomic(path, encoded)\n\n\t// If we are checking for dups and we had a successful write, store\n\t// it so we don't rewrite the same value.\n\tif checkDup && err == nil {\n\t\tm.lastSnapshot = &s\n\t}\n\treturn err\n}", "category": "Python"}, {"instruction": "// update takes a hash that forms the next leaf level (level-1) node in the merkle tree.\n// Also, complete the merkle tree as much as possible with the addition of this new leaf node -\n// i.e. recursively build the higher level nodes and delete the underlying sub-tree.", "input": "go language", "output": "func (m *merkleTree) update(nextLeafLevelHash Hash) error {\n\tlogger.Debugf(\"Before update() = %s\", m)\n\tdefer logger.Debugf(\"After update() = %s\", m)\n\tm.tree[leafLevel] = append(m.tree[leafLevel], nextLeafLevelHash)\n\tcurrentLevel := leafLevel\n\tfor {\n\t\tcurrentLevelHashes := m.tree[currentLevel]\n\t\tif uint32(len(currentLevelHashes)) <= m.maxDegree {\n\t\t\treturn nil\n\t\t}\n\t\tnextLevelHash, err := computeCombinedHash(currentLevelHashes)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdelete(m.tree, currentLevel)\n\t\tnextLevel := currentLevel + 1\n\t\tm.tree[nextLevel] = append(m.tree[nextLevel], nextLevelHash)\n\t\tif nextLevel > m.maxLevel {\n\t\t\tm.maxLevel = nextLevel\n\t\t}\n\t\tcurrentLevel = nextLevel\n\t}\n}", "category": "Python"}, {"instruction": "// getResourceHandler is an HTTP handler function for get requests. It delegates to the\n// passed-in getterFunc to perform the actual get.", "input": "go language", "output": "func getResourceHandler(scope *RequestScope, getter getterFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, req *http.Request) {\n\t\ttrace := utiltrace.New(\"Get \" + req.URL.Path)\n\t\tdefer trace.LogIfLong(500 * time.Millisecond)\n\n\t\tnamespace, name, err := scope.Namer.Name(req)\n\t\tif err != nil {\n\t\t\tscope.err(err, w, req)\n\t\t\treturn\n\t\t}\n\t\tctx := req.Context()\n\t\tctx = request.WithNamespace(ctx, namespace)\n\n\t\toutputMediaType, _, err := negotiation.NegotiateOutputMediaType(req, scope.Serializer, scope)\n\t\tif err != nil {\n\t\t\tscope.err(err, w, req)\n\t\t\treturn\n\t\t}\n\n\t\tresult, err := getter(ctx, name, req, trace)\n\t\tif err != nil {\n\t\t\tscope.err(err, w, req)\n\t\t\treturn\n\t\t}\n\n\t\ttrace.Step(\"About to write a response\")\n\t\ttransformResponseObject(ctx, scope, trace, req, w, http.StatusOK, outputMediaType, result)\n\t\ttrace.Step(\"Transformed response object\")\n\t}\n}", "category": "Python"}, {"instruction": "// GetGlobalSysVar implements GlobalVarAccessor.GetGlobalSysVar interface.", "input": "go language", "output": "func (s *session) GetGlobalSysVar(name string) (string, error) {\n\tif s.Value(sessionctx.Initing) != nil {\n\t\t// When running bootstrap or upgrade, we should not access global storage.\n\t\treturn \"\", nil\n\t}\n\tsql := fmt.Sprintf(`SELECT VARIABLE_VALUE FROM %s.%s WHERE VARIABLE_NAME=\"%s\";`,\n\t\tmysql.SystemDB, mysql.GlobalVariablesTable, name)\n\tsysVar, err := s.getExecRet(s, sql)\n\tif err != nil {\n\t\tif executor.ErrResultIsEmpty.Equal(err) {\n\t\t\tif sv, ok := variable.SysVars[name]; ok {\n\t\t\t\treturn sv.Value, nil\n\t\t\t}\n\t\t\treturn \"\", variable.UnknownSystemVar.GenWithStackByArgs(name)\n\t\t}\n\t\treturn \"\", err\n\t}\n\treturn sysVar, nil\n}", "category": "Python"}, {"instruction": "// Read keeps a cursor so cannot be called simulateously, see ReadAt", "input": "go language", "output": "func (r *LazyChunkReader) Read(b []byte) (read int, err error) {\n\tlog.Trace(\"lazychunkreader.read\", \"key\", r.addr)\n\tmetrics.GetOrRegisterCounter(\"lazychunkreader.read\", nil).Inc(1)\n\n\tread, err = r.ReadAt(b, r.off)\n\tif err != nil && err != io.EOF {\n\t\tlog.Trace(\"lazychunkreader.readat\", \"read\", read, \"err\", err)\n\t\tmetrics.GetOrRegisterCounter(\"lazychunkreader.read.err\", nil).Inc(1)\n\t}\n\n\tmetrics.GetOrRegisterCounter(\"lazychunkreader.read.bytes\", nil).Inc(int64(read))\n\n\tr.off += int64(read)\n\treturn read, err\n}", "category": "Python"}, {"instruction": "// Command provides a mock function with given fields: name, help, onCommand", "input": "go language", "output": "func (_m *CommandRegistrar) Command(name string, help string, onCommand common.CLICommand) *kingpin.CmdClause {\n\tret := _m.Called(name, help, onCommand)\n\n\tvar r0 *kingpin.CmdClause\n\tif rf, ok := ret.Get(0).(func(string, string, common.CLICommand) *kingpin.CmdClause); ok {\n\t\tr0 = rf(name, help, onCommand)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(*kingpin.CmdClause)\n\t\t}\n\t}\n\n\treturn r0\n}", "category": "Python"}, {"instruction": "// pullScannerRoutine aggregates paths to be scanned after pulling. The scan is\n// scheduled once when scanChan is closed (scanning can not happen during pulling).", "input": "go language", "output": "func (f *sendReceiveFolder) pullScannerRoutine(scanChan <-chan string) {\n\ttoBeScanned := make(map[string]struct{})\n\n\tfor path := range scanChan {\n\t\ttoBeScanned[path] = struct{}{}\n\t}\n\n\tif len(toBeScanned) != 0 {\n\t\tscanList := make([]string, 0, len(toBeScanned))\n\t\tfor path := range toBeScanned {\n\t\t\tl.Debugln(f, \"scheduling scan after pulling for\", path)\n\t\t\tscanList = append(scanList, path)\n\t\t}\n\t\tf.Scan(scanList)\n\t}\n}", "category": "Python"}, {"instruction": "// InterpretListError converts a generic error on a retrieval\n// operation into the appropriate API error.", "input": "go language", "output": "func InterpretListError(err error, qualifiedResource schema.GroupResource) error {\n\tswitch {\n\tcase storage.IsNotFound(err):\n\t\treturn errors.NewNotFound(qualifiedResource, \"\")\n\tcase storage.IsUnreachable(err):\n\t\treturn errors.NewServerTimeout(qualifiedResource, \"list\", 2) // TODO: make configurable or handled at a higher level\n\tcase storage.IsInternalError(err):\n\t\treturn errors.NewInternalError(err)\n\tdefault:\n\t\treturn err\n\t}\n}", "category": "Python"}, {"instruction": "// newManager returns an implementation of cgroups.Manager", "input": "go language", "output": "func (l *libcontainerAdapter) newManager(cgroups *libcontainerconfigs.Cgroup, paths map[string]string) (libcontainercgroups.Manager, error) {\n\tswitch l.cgroupManagerType {\n\tcase libcontainerCgroupfs:\n\t\treturn &cgroupfs.Manager{\n\t\t\tCgroups: cgroups,\n\t\t\tPaths:   paths,\n\t\t}, nil\n\tcase libcontainerSystemd:\n\t\t// this means you asked systemd to manage cgroups, but systemd was not on the host, so all you can do is panic...\n\t\tif !cgroupsystemd.UseSystemd() {\n\t\t\tpanic(\"systemd cgroup manager not available\")\n\t\t}\n\t\treturn &cgroupsystemd.Manager{\n\t\t\tCgroups: cgroups,\n\t\t\tPaths:   paths,\n\t\t}, nil\n\t}\n\treturn nil, fmt.Errorf(\"invalid cgroup manager configuration\")\n}", "category": "Python"}, {"instruction": "// AuthZResponse authorized and manipulates the response from docker daemon using authZ plugins", "input": "go language", "output": "func (ctx *Ctx) AuthZResponse(rm ResponseModifier, r *http.Request) error {\n\tctx.authReq.ResponseStatusCode = rm.StatusCode()\n\tctx.authReq.ResponseHeaders = headers(rm.Header())\n\n\tif sendBody(ctx.requestURI, rm.Header()) {\n\t\tctx.authReq.ResponseBody = rm.RawBody()\n\t}\n\n\tfor _, plugin := range ctx.plugins {\n\t\tlogrus.Debugf(\"AuthZ response using plugin %s\", plugin.Name())\n\n\t\tauthRes, err := plugin.AuthZResponse(ctx.authReq)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"plugin %s failed with error: %s\", plugin.Name(), err)\n\t\t}\n\n\t\tif !authRes.Allow {\n\t\t\treturn newAuthorizationError(plugin.Name(), authRes.Msg)\n\t\t}\n\t}\n\n\trm.FlushAll()\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// SelectorFromSet returns a Selector which will match exactly the given Set. A\n// nil and empty Sets are considered equivalent to Everything().", "input": "go language", "output": "func SelectorFromSet(ls Set) Selector {\n\tif ls == nil || len(ls) == 0 {\n\t\treturn internalSelector{}\n\t}\n\tvar requirements internalSelector\n\tfor label, value := range ls {\n\t\tr, err := NewRequirement(label, selection.Equals, []string{value})\n\t\tif err == nil {\n\t\t\trequirements = append(requirements, *r)\n\t\t} else {\n\t\t\t//TODO: double check errors when input comes from serialization?\n\t\t\treturn internalSelector{}\n\t\t}\n\t}\n\t// sort to have deterministic string representation\n\tsort.Sort(ByKey(requirements))\n\treturn requirements\n}", "category": "Python"}, {"instruction": "// processPorts returns the configured port.\n// An explicitly specified port is preferred. If none is specified, it selects\n// one of the available port. The first such found port is returned unless an\n// optional index is provided.", "input": "go language", "output": "func processPorts(app marathon.Application, task marathon.Task, serverPort string) (int, error) {\n\tif len(serverPort) > 0 && !strings.HasPrefix(serverPort, \"index:\") {\n\t\tport, err := strconv.Atoi(serverPort)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif port <= 0 {\n\t\t\treturn 0, fmt.Errorf(\"explicitly specified port %d must be greater than zero\", port)\n\t\t} else if port > 0 {\n\t\t\treturn port, nil\n\t\t}\n\t}\n\n\tports := retrieveAvailablePorts(app, task)\n\tif len(ports) == 0 {\n\t\treturn 0, errors.New(\"no port found\")\n\t}\n\n\tportIndex := 0\n\tif strings.HasPrefix(serverPort, \"index:\") {\n\t\tsplit := strings.SplitN(serverPort, \":\", 2)\n\t\tindex, err := strconv.Atoi(split[1])\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif index < 0 || index > len(ports)-1 {\n\t\t\treturn 0, fmt.Errorf(\"index %d must be within range (0, %d)\", index, len(ports)-1)\n\t\t}\n\t\tportIndex = index\n\t}\n\treturn ports[portIndex], nil\n}", "category": "Python"}, {"instruction": "// GetMissingPvtDataInfoForMostRecentBlocks invokes the function on underlying pvtdata store", "input": "go language", "output": "func (s *Store) GetMissingPvtDataInfoForMostRecentBlocks(maxBlock int) (ledger.MissingPvtDataInfo, error) {\n\t// it is safe to not acquire a read lock on s.rwlock. Without a lock, the value of\n\t// lastCommittedBlock can change due to a new block commit. As a result, we may not\n\t// be able to fetch the missing data info of truly the most recent blocks. This\n\t// decision was made to ensure that the regular block commit rate is not affected.\n\treturn s.pvtdataStore.GetMissingPvtDataInfoForMostRecentBlocks(maxBlock)\n}", "category": "Python"}, {"instruction": "// Validate provides a mock function with given fields: block, namespace, txPosition, actionPosition, policy", "input": "go language", "output": "func (_m *TransactionValidator) Validate(block *common.Block, namespace string, txPosition int, actionPosition int, policy []byte) errors.TxValidationError {\n\tret := _m.Called(block, namespace, txPosition, actionPosition, policy)\n\n\tvar r0 errors.TxValidationError\n\tif rf, ok := ret.Get(0).(func(*common.Block, string, int, int, []byte) errors.TxValidationError); ok {\n\t\tr0 = rf(block, namespace, txPosition, actionPosition, policy)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(errors.TxValidationError)\n\t\t}\n\t}\n\n\treturn r0\n}", "category": "Python"}, {"instruction": "// Visit in a FileVisitor is just taking care of opening/closing files", "input": "go language", "output": "func (v *FileVisitor) Visit(fn VisitorFunc) error {\n\tvar f *os.File\n\tif v.Path == constSTDINstr {\n\t\tf = os.Stdin\n\t} else {\n\t\tvar err error\n\t\tf, err = os.Open(v.Path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\t}\n\n\t// TODO: Consider adding a flag to force to UTF16, apparently some\n\t// Windows tools don't write the BOM\n\tutf16bom := unicode.BOMOverride(unicode.UTF8.NewDecoder())\n\tv.StreamVisitor.Reader = transform.NewReader(f, utf16bom)\n\n\treturn v.StreamVisitor.Visit(fn)\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *ResourceQuotaStatus) DeepCopyInto(out *ResourceQuotaStatus) {\n\t*out = *in\n\tif in.Hard != nil {\n\t\tin, out := &in.Hard, &out.Hard\n\t\t*out = make(ResourceList, len(*in))\n\t\tfor key, val := range *in {\n\t\t\t(*out)[key] = val.DeepCopy()\n\t\t}\n\t}\n\tif in.Used != nil {\n\t\tin, out := &in.Used, &out.Used\n\t\t*out = make(ResourceList, len(*in))\n\t\tfor key, val := range *in {\n\t\t\t(*out)[key] = val.DeepCopy()\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// ValidateLogOpt looks for syslog specific log options\n// syslog-address, syslog-facility.", "input": "go language", "output": "func ValidateLogOpt(cfg map[string]string) error {\n\tfor key := range cfg {\n\t\tswitch key {\n\t\tcase \"env\":\n\t\tcase \"env-regex\":\n\t\tcase \"labels\":\n\t\tcase \"labels-regex\":\n\t\tcase \"syslog-address\":\n\t\tcase \"syslog-facility\":\n\t\tcase \"syslog-tls-ca-cert\":\n\t\tcase \"syslog-tls-cert\":\n\t\tcase \"syslog-tls-key\":\n\t\tcase \"syslog-tls-skip-verify\":\n\t\tcase \"tag\":\n\t\tcase \"syslog-format\":\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unknown log opt '%s' for syslog log driver\", key)\n\t\t}\n\t}\n\tif _, _, err := parseAddress(cfg[\"syslog-address\"]); err != nil {\n\t\treturn err\n\t}\n\tif _, err := parseFacility(cfg[\"syslog-facility\"]); err != nil {\n\t\treturn err\n\t}\n\tif _, _, err := parseLogFormat(cfg[\"syslog-format\"], \"\"); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Prefetch processes the state changes according to the Ethereum rules by running\n// the transaction messages using the statedb, but any changes are discarded. The\n// only goal is to pre-cache transaction signatures and state trie nodes.", "input": "go language", "output": "func (p *statePrefetcher) Prefetch(block *types.Block, statedb *state.StateDB, cfg vm.Config, interrupt *uint32) {\n\tvar (\n\t\theader  = block.Header()\n\t\tgaspool = new(GasPool).AddGas(block.GasLimit())\n\t)\n\t// Iterate over and process the individual transactions\n\tfor i, tx := range block.Transactions() {\n\t\t// If block precaching was interrupted, abort\n\t\tif interrupt != nil && atomic.LoadUint32(interrupt) == 1 {\n\t\t\treturn\n\t\t}\n\t\t// Block precaching permitted to continue, execute the transaction\n\t\tstatedb.Prepare(tx.Hash(), block.Hash(), i)\n\t\tif err := precacheTransaction(p.config, p.bc, nil, gaspool, statedb, header, tx, cfg); err != nil {\n\t\t\treturn // Ugh, something went horribly wrong, bail out\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// Admit checks Pods and admits or rejects them. It also resolves the priority of pods based on their PriorityClass.\n// Note that pod validation mechanism prevents update of a pod priority.", "input": "go language", "output": "func (p *priorityPlugin) Admit(a admission.Attributes, o admission.ObjectInterfaces) error {\n\tif !utilfeature.DefaultFeatureGate.Enabled(features.PodPriority) {\n\t\treturn nil\n\t}\n\n\toperation := a.GetOperation()\n\t// Ignore all calls to subresources\n\tif len(a.GetSubresource()) != 0 {\n\t\treturn nil\n\t}\n\n\tswitch a.GetResource().GroupResource() {\n\tcase podResource:\n\t\tif operation == admission.Create || operation == admission.Update {\n\t\t\treturn p.admitPod(a)\n\t\t}\n\t\treturn nil\n\n\tdefault:\n\t\treturn nil\n\t}\n}", "category": "Python"}, {"instruction": "// statementContextToFlags converts StatementContext to tipb.SelectRequest.Flags.", "input": "go language", "output": "func statementContextToFlags(sc *stmtctx.StatementContext) uint64 {\n\tvar flags uint64\n\tif sc.InInsertStmt {\n\t\tflags |= model.FlagInInsertStmt\n\t} else if sc.InUpdateStmt || sc.InDeleteStmt {\n\t\tflags |= model.FlagInUpdateOrDeleteStmt\n\t} else if sc.InSelectStmt {\n\t\tflags |= model.FlagInSelectStmt\n\t}\n\tif sc.IgnoreTruncate {\n\t\tflags |= model.FlagIgnoreTruncate\n\t} else if sc.TruncateAsWarning {\n\t\tflags |= model.FlagTruncateAsWarning\n\t}\n\tif sc.OverflowAsWarning {\n\t\tflags |= model.FlagOverflowAsWarning\n\t}\n\tif sc.IgnoreZeroInDate {\n\t\tflags |= model.FlagIgnoreZeroInDate\n\t}\n\tif sc.DividedByZeroAsWarning {\n\t\tflags |= model.FlagDividedByZeroAsWarning\n\t}\n\tif sc.PadCharToFullLength {\n\t\tflags |= model.FlagPadCharToFullLength\n\t}\n\treturn flags\n}", "category": "Python"}, {"instruction": "// TLSConfig is used to generate a TLSClientConfig that's useful for talking to\n// Consul using TLS.", "input": "go language", "output": "func SetupTLSConfig(tlsConfig *TLSConfig) (*tls.Config, error) {\n\ttlsClientConfig := &tls.Config{\n\t\tInsecureSkipVerify: tlsConfig.InsecureSkipVerify,\n\t}\n\n\tif tlsConfig.Address != \"\" {\n\t\tserver := tlsConfig.Address\n\t\thasPort := strings.LastIndex(server, \":\") > strings.LastIndex(server, \"]\")\n\t\tif hasPort {\n\t\t\tvar err error\n\t\t\tserver, _, err = net.SplitHostPort(server)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\ttlsClientConfig.ServerName = server\n\t}\n\n\tif tlsConfig.CertFile != \"\" && tlsConfig.KeyFile != \"\" {\n\t\ttlsCert, err := tls.LoadX509KeyPair(tlsConfig.CertFile, tlsConfig.KeyFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttlsClientConfig.Certificates = []tls.Certificate{tlsCert}\n\t}\n\n\tif tlsConfig.CAFile != \"\" || tlsConfig.CAPath != \"\" {\n\t\trootConfig := &rootcerts.Config{\n\t\t\tCAFile: tlsConfig.CAFile,\n\t\t\tCAPath: tlsConfig.CAPath,\n\t\t}\n\t\tif err := rootcerts.ConfigureTLS(tlsClientConfig, rootConfig); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn tlsClientConfig, nil\n}", "category": "Python"}, {"instruction": "// AddMethodMapping adds a method to a template function namespace.", "input": "go language", "output": "func (t *TemplateFuncsNamespace) AddMethodMapping(m interface{}, aliases []string, examples [][2]string) {\n\tif t.MethodMappings == nil {\n\t\tt.MethodMappings = make(map[string]TemplateFuncMethodMapping)\n\t}\n\n\tname := methodToName(m)\n\n\t// sanity check\n\tfor _, e := range examples {\n\t\tif e[0] == \"\" {\n\t\t\tpanic(t.Name + \": Empty example for \" + name)\n\t\t}\n\t}\n\tfor _, a := range aliases {\n\t\tif a == \"\" {\n\t\t\tpanic(t.Name + \": Empty alias for \" + name)\n\t\t}\n\t}\n\n\tt.MethodMappings[name] = TemplateFuncMethodMapping{\n\t\tMethod:   m,\n\t\tAliases:  aliases,\n\t\tExamples: examples,\n\t}\n\n}", "category": "Python"}, {"instruction": "// NewPodInformer creates a shared index informer that returns only non-terminal pods.", "input": "go language", "output": "func NewPodInformer(client clientset.Interface, resyncPeriod time.Duration) coreinformers.PodInformer {\n\tselector := fields.ParseSelectorOrDie(\n\t\t\"status.phase!=\" + string(v1.PodSucceeded) +\n\t\t\t\",status.phase!=\" + string(v1.PodFailed))\n\tlw := cache.NewListWatchFromClient(client.CoreV1().RESTClient(), string(v1.ResourcePods), metav1.NamespaceAll, selector)\n\treturn &podInformer{\n\t\tinformer: cache.NewSharedIndexInformer(lw, &v1.Pod{}, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}),\n\t}\n}", "category": "Python"}, {"instruction": "// GetUnlockKey returns the unlock key for the swarm.", "input": "go language", "output": "func (c *Cluster) GetUnlockKey() (string, error) {\n\tvar resp *swarmapi.GetUnlockKeyResponse\n\tif err := c.lockedManagerAction(func(ctx context.Context, state nodeState) error {\n\t\tclient := swarmapi.NewCAClient(state.grpcConn)\n\n\t\tr, err := client.GetUnlockKey(ctx, &swarmapi.GetUnlockKeyRequest{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tresp = r\n\t\treturn nil\n\t}); err != nil {\n\t\treturn \"\", err\n\t}\n\tif len(resp.UnlockKey) == 0 {\n\t\t// no key\n\t\treturn \"\", nil\n\t}\n\treturn encryption.HumanReadableKey(resp.UnlockKey), nil\n}", "category": "Python"}, {"instruction": "// GetCCPackage tries each known package implementation one by one\n// till the right package is found", "input": "go language", "output": "func GetCCPackage(buf []byte) (CCPackage, error) {\n\t// try raw CDS\n\tcds := &CDSPackage{}\n\tif ccdata, err := cds.InitFromBuffer(buf); err != nil {\n\t\tcds = nil\n\t} else {\n\t\terr = cds.ValidateCC(ccdata)\n\t\tif err != nil {\n\t\t\tcds = nil\n\t\t}\n\t}\n\n\t// try signed CDS\n\tscds := &SignedCDSPackage{}\n\tif ccdata, err := scds.InitFromBuffer(buf); err != nil {\n\t\tscds = nil\n\t} else {\n\t\terr = scds.ValidateCC(ccdata)\n\t\tif err != nil {\n\t\t\tscds = nil\n\t\t}\n\t}\n\n\tif cds != nil && scds != nil {\n\t\t// Both were unmarshaled successfully, this is exactly why the approach of\n\t\t// hoping proto fails for bad inputs is fatally flawed.\n\t\tccproviderLogger.Errorf(\"Could not determine chaincode package type, guessing SignedCDS\")\n\t\treturn scds, nil\n\t}\n\n\tif cds != nil {\n\t\treturn cds, nil\n\t}\n\n\tif scds != nil {\n\t\treturn scds, nil\n\t}\n\n\treturn nil, errors.New(\"could not unmarshal chaincode package to CDS or SignedCDS\")\n}", "category": "Python"}, {"instruction": "// Get returns a single intention by ID.", "input": "go language", "output": "func (s *Intention) Get(\n\targs *structs.IntentionQueryRequest,\n\treply *structs.IndexedIntentions) error {\n\t// Forward if necessary\n\tif done, err := s.srv.forward(\"Intention.Get\", args, args, reply); done {\n\t\treturn err\n\t}\n\n\treturn s.srv.blockingQuery(\n\t\t&args.QueryOptions,\n\t\t&reply.QueryMeta,\n\t\tfunc(ws memdb.WatchSet, state *state.Store) error {\n\t\t\tindex, ixn, err := state.IntentionGet(ws, args.IntentionID)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif ixn == nil {\n\t\t\t\treturn ErrIntentionNotFound\n\t\t\t}\n\n\t\t\treply.Index = index\n\t\t\treply.Intentions = structs.Intentions{ixn}\n\n\t\t\t// Filter\n\t\t\tif err := s.srv.filterACL(args.Token, reply); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// If ACLs prevented any responses, error\n\t\t\tif len(reply.Intentions) == 0 {\n\t\t\t\ts.srv.logger.Printf(\"[WARN] consul.intention: Request to get intention '%s' denied due to ACLs\", args.IntentionID)\n\t\t\t\treturn acl.ErrPermissionDenied\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t)\n}", "category": "Python"}, {"instruction": "// nodes returns a paginated list of node addresses. If key is not nil,\n// only nodes that contain that key will be returned.", "input": "go language", "output": "func (s *GlobalStore) nodes(key []byte, startAddr *common.Address, limit int) (nodes mock.Nodes, err error) {\n\titer := s.db.NewIterator(nil, nil)\n\tdefer iter.Release()\n\n\tif limit <= 0 {\n\t\tlimit = mock.DefaultLimit\n\t}\n\n\tprefix := []byte{indexForNodesPrefix}\n\tif key != nil {\n\t\tprefix = indexForNodesWithHashPrefix(key)\n\t}\n\tstartKey := prefix\n\tif startAddr != nil {\n\t\tif key != nil {\n\t\t\tstartKey = indexForNodesWithHash(key, *startAddr)\n\t\t} else {\n\t\t\tstartKey = indexForNodes(*startAddr)\n\t\t}\n\t}\n\n\tok := iter.Seek(startKey)\n\tif !ok {\n\t\treturn nodes, iter.Error()\n\t}\n\tfor ; ok; ok = iter.Next() {\n\t\tk := iter.Key()\n\t\tif !bytes.HasPrefix(k, prefix) {\n\t\t\tbreak\n\t\t}\n\t\taddr := common.BytesToAddress(append([]byte(nil), bytes.TrimPrefix(k, prefix)...))\n\n\t\tif len(nodes.Addrs) >= limit {\n\t\t\tnodes.Next = &addr\n\t\t\tbreak\n\t\t}\n\n\t\tnodes.Addrs = append(nodes.Addrs, addr)\n\t}\n\treturn nodes, iter.Error()\n}", "category": "Python"}, {"instruction": "// numCPU queries the system for the count of threads available\n// for use to this process.\n//\n// Issues two syscalls.\n// Returns 0 on errors. Use |runtime.NumCPU| in that case.", "input": "go language", "output": "func numCPU() int {\n\t// Gets the affinity mask for a process: The very one invoking this function.\n\tpid, _, _ := unix.RawSyscall(unix.SYS_GETPID, 0, 0, 0)\n\n\tvar mask [1024 / 64]uintptr\n\t_, _, err := unix.RawSyscall(unix.SYS_SCHED_GETAFFINITY, pid, uintptr(len(mask)*8), uintptr(unsafe.Pointer(&mask[0])))\n\tif err != 0 {\n\t\treturn 0\n\t}\n\n\t// For every available thread a bit is set in the mask.\n\tncpu := 0\n\tfor _, e := range mask {\n\t\tif e == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tncpu += int(popcnt(uint64(e)))\n\t}\n\treturn ncpu\n}", "category": "Python"}, {"instruction": "// WithIPv4 sets the specified ip for the specified network of the container", "input": "go language", "output": "func WithIPv4(network, ip string) func(*TestContainerConfig) {\n\treturn func(c *TestContainerConfig) {\n\t\tif c.NetworkingConfig.EndpointsConfig == nil {\n\t\t\tc.NetworkingConfig.EndpointsConfig = map[string]*networktypes.EndpointSettings{}\n\t\t}\n\t\tif v, ok := c.NetworkingConfig.EndpointsConfig[network]; !ok || v == nil {\n\t\t\tc.NetworkingConfig.EndpointsConfig[network] = &networktypes.EndpointSettings{}\n\t\t}\n\t\tif c.NetworkingConfig.EndpointsConfig[network].IPAMConfig == nil {\n\t\t\tc.NetworkingConfig.EndpointsConfig[network].IPAMConfig = &networktypes.EndpointIPAMConfig{}\n\t\t}\n\t\tc.NetworkingConfig.EndpointsConfig[network].IPAMConfig.IPv4Address = ip\n\t}\n}", "category": "Python"}, {"instruction": "// UpdateDashboardModel updates an existing model from command into model for update", "input": "go language", "output": "func (cmd *UpdateFolderCommand) UpdateDashboardModel(dashFolder *Dashboard, orgId int64, userId int64) {\n\tdashFolder.OrgId = orgId\n\tdashFolder.Title = strings.TrimSpace(cmd.Title)\n\tdashFolder.Data.Set(\"title\", dashFolder.Title)\n\n\tif cmd.Uid != \"\" {\n\t\tdashFolder.SetUid(cmd.Uid)\n\t}\n\n\tdashFolder.SetVersion(cmd.Version)\n\tdashFolder.IsFolder = true\n\n\tif userId == 0 {\n\t\tuserId = -1\n\t}\n\n\tdashFolder.UpdatedBy = userId\n\tdashFolder.UpdateSlug()\n}", "category": "Python"}, {"instruction": "// Get pods which should be resynchronized. Currently, the following pod should be resynchronized:\n//   * pod whose work is ready.\n//   * internal modules that request sync of a pod.", "input": "go language", "output": "func (kl *Kubelet) getPodsToSync() []*v1.Pod {\n\tallPods := kl.podManager.GetPods()\n\tpodUIDs := kl.workQueue.GetWork()\n\tpodUIDSet := sets.NewString()\n\tfor _, podUID := range podUIDs {\n\t\tpodUIDSet.Insert(string(podUID))\n\t}\n\tvar podsToSync []*v1.Pod\n\tfor _, pod := range allPods {\n\t\tif podUIDSet.Has(string(pod.UID)) {\n\t\t\t// The work of the pod is ready\n\t\t\tpodsToSync = append(podsToSync, pod)\n\t\t\tcontinue\n\t\t}\n\t\tfor _, podSyncLoopHandler := range kl.PodSyncLoopHandlers {\n\t\t\tif podSyncLoopHandler.ShouldSync(pod) {\n\t\t\t\tpodsToSync = append(podsToSync, pod)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn podsToSync\n}", "category": "Python"}, {"instruction": "// handleDivisionByZeroError reports error or warning depend on the context.", "input": "go language", "output": "func handleDivisionByZeroError(ctx sessionctx.Context) error {\n\tsc := ctx.GetSessionVars().StmtCtx\n\tif sc.InInsertStmt || sc.InUpdateStmt || sc.InDeleteStmt {\n\t\tif !ctx.GetSessionVars().SQLMode.HasErrorForDivisionByZeroMode() {\n\t\t\treturn nil\n\t\t}\n\t\tif ctx.GetSessionVars().StrictSQLMode && !sc.DividedByZeroAsWarning {\n\t\t\treturn ErrDivisionByZero\n\t\t}\n\t}\n\tsc.AppendWarning(ErrDivisionByZero)\n\treturn nil\n}", "category": "Python"}, {"instruction": "// parsePersistentNodes parses a list of discovery node URLs loaded from a .json\n// file from within the data directory.", "input": "go language", "output": "func (c *Config) parsePersistentNodes(w *bool, path string) []*enode.Node {\n\t// Short circuit if no node config is present\n\tif c.DataDir == \"\" {\n\t\treturn nil\n\t}\n\tif _, err := os.Stat(path); err != nil {\n\t\treturn nil\n\t}\n\tc.warnOnce(w, \"Found deprecated node list file %s, please use the TOML config file instead.\", path)\n\n\t// Load the nodes from the config file.\n\tvar nodelist []string\n\tif err := common.LoadJSON(path, &nodelist); err != nil {\n\t\tlog.Error(fmt.Sprintf(\"Can't load node list file: %v\", err))\n\t\treturn nil\n\t}\n\t// Interpret the list as a discovery node array\n\tvar nodes []*enode.Node\n\tfor _, url := range nodelist {\n\t\tif url == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tnode, err := enode.ParseV4(url)\n\t\tif err != nil {\n\t\t\tlog.Error(fmt.Sprintf(\"Node URL %s: %v\\n\", url, err))\n\t\t\tcontinue\n\t\t}\n\t\tnodes = append(nodes, node)\n\t}\n\treturn nodes\n}", "category": "Python"}, {"instruction": "// Query fetches all releases that match the provided map of labels.\n// An error is returned if the secret fails to retrieve the releases.", "input": "go language", "output": "func (secrets *Secrets) Query(labels map[string]string) ([]*rspb.Release, error) {\n\tls := kblabels.Set{}\n\tfor k, v := range labels {\n\t\tif errs := validation.IsValidLabelValue(v); len(errs) != 0 {\n\t\t\treturn nil, fmt.Errorf(\"invalid label value: %q: %s\", v, strings.Join(errs, \"; \"))\n\t\t}\n\t\tls[k] = v\n\t}\n\n\topts := metav1.ListOptions{LabelSelector: ls.AsSelector().String()}\n\n\tlist, err := secrets.impl.List(opts)\n\tif err != nil {\n\t\tsecrets.Log(\"query: failed to query with labels: %s\", err)\n\t\treturn nil, err\n\t}\n\n\tif len(list.Items) == 0 {\n\t\treturn nil, storageerrors.ErrReleaseNotFound(labels[\"NAME\"])\n\t}\n\n\tvar results []*rspb.Release\n\tfor _, item := range list.Items {\n\t\trls, err := decodeRelease(string(item.Data[\"release\"]))\n\t\tif err != nil {\n\t\t\tsecrets.Log(\"query: failed to decode release: %s\", err)\n\t\t\tcontinue\n\t\t}\n\t\tresults = append(results, rls)\n\t}\n\treturn results, nil\n}", "category": "Python"}, {"instruction": "// rewriteHTML scans the HTML for tags with url-valued attributes, and updates\n// those values with the urlRewriter function. The updated HTML is output to the\n// writer.", "input": "go language", "output": "func rewriteHTML(reader io.Reader, writer io.Writer, urlRewriter func(string) string) error {\n\t// Note: This assumes the content is UTF-8.\n\ttokenizer := html.NewTokenizer(reader)\n\n\tvar err error\n\tfor err == nil {\n\t\ttokenType := tokenizer.Next()\n\t\tswitch tokenType {\n\t\tcase html.ErrorToken:\n\t\t\terr = tokenizer.Err()\n\t\tcase html.StartTagToken, html.SelfClosingTagToken:\n\t\t\ttoken := tokenizer.Token()\n\t\t\tif urlAttrs, ok := atomsToAttrs[token.DataAtom]; ok {\n\t\t\t\tfor i, attr := range token.Attr {\n\t\t\t\t\tif urlAttrs.Has(attr.Key) {\n\t\t\t\t\t\ttoken.Attr[i].Val = urlRewriter(attr.Val)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t_, err = writer.Write([]byte(token.String()))\n\t\tdefault:\n\t\t\t_, err = writer.Write(tokenizer.Raw())\n\t\t}\n\t}\n\tif err != io.EOF {\n\t\treturn err\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// List takes label and field selectors, and returns the list of PersistentVolumeClaims that match those selectors.", "input": "go language", "output": "func (c *FakePersistentVolumeClaims) List(opts v1.ListOptions) (result *corev1.PersistentVolumeClaimList, err error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewListAction(persistentvolumeclaimsResource, persistentvolumeclaimsKind, c.ns, opts), &corev1.PersistentVolumeClaimList{})\n\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n\tif label == nil {\n\t\tlabel = labels.Everything()\n\t}\n\tlist := &corev1.PersistentVolumeClaimList{ListMeta: obj.(*corev1.PersistentVolumeClaimList).ListMeta}\n\tfor _, item := range obj.(*corev1.PersistentVolumeClaimList).Items {\n\t\tif label.Matches(labels.Set(item.Labels)) {\n\t\t\tlist.Items = append(list.Items, item)\n\t\t}\n\t}\n\treturn list, err\n}", "category": "Python"}, {"instruction": "//setIPSetDefaults sets some IPSet fields if not present to their default values.", "input": "go language", "output": "func (set *IPSet) setIPSetDefaults() {\n\t// Setting default values if not present\n\tif set.HashSize == 0 {\n\t\tset.HashSize = 1024\n\t}\n\tif set.MaxElem == 0 {\n\t\tset.MaxElem = 65536\n\t}\n\t// Default protocol is IPv4\n\tif set.HashFamily == \"\" {\n\t\tset.HashFamily = ProtocolFamilyIPV4\n\t}\n\t// Default ipset type is \"hash:ip,port\"\n\tif len(set.SetType) == 0 {\n\t\tset.SetType = HashIPPort\n\t}\n\tif len(set.PortRange) == 0 {\n\t\tset.PortRange = DefaultPortRange\n\t}\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *ExternalMetricValue) DeepCopyInto(out *ExternalMetricValue) {\n\t*out = *in\n\tout.TypeMeta = in.TypeMeta\n\tif in.MetricLabels != nil {\n\t\tin, out := &in.MetricLabels, &out.MetricLabels\n\t\t*out = make(map[string]string, len(*in))\n\t\tfor key, val := range *in {\n\t\t\t(*out)[key] = val\n\t\t}\n\t}\n\tin.Timestamp.DeepCopyInto(&out.Timestamp)\n\tif in.WindowSeconds != nil {\n\t\tin, out := &in.WindowSeconds, &out.WindowSeconds\n\t\t*out = new(int64)\n\t\t**out = **in\n\t}\n\tout.Value = in.Value.DeepCopy()\n\treturn\n}", "category": "Python"}, {"instruction": "// getDeploymentsForReplicaSet returns a list of Deployments that potentially\n// match a ReplicaSet.", "input": "go language", "output": "func (dc *DeploymentController) getDeploymentsForReplicaSet(rs *apps.ReplicaSet) []*apps.Deployment {\n\tdeployments, err := dc.dLister.GetDeploymentsForReplicaSet(rs)\n\tif err != nil || len(deployments) == 0 {\n\t\treturn nil\n\t}\n\t// Because all ReplicaSet's belonging to a deployment should have a unique label key,\n\t// there should never be more than one deployment returned by the above method.\n\t// If that happens we should probably dynamically repair the situation by ultimately\n\t// trying to clean up one of the controllers, for now we just return the older one\n\tif len(deployments) > 1 {\n\t\t// ControllerRef will ensure we don't do anything crazy, but more than one\n\t\t// item in this list nevertheless constitutes user error.\n\t\tklog.V(4).Infof(\"user error! more than one deployment is selecting replica set %s/%s with labels: %#v, returning %s/%s\",\n\t\t\trs.Namespace, rs.Name, rs.Labels, deployments[0].Namespace, deployments[0].Name)\n\t}\n\treturn deployments\n}", "category": "Python"}, {"instruction": "// TableHandlesToKVRanges converts sorted handle to kv ranges.\n// For continuous handles, we should merge them to a single key range.", "input": "go language", "output": "func TableHandlesToKVRanges(tid int64, handles []int64) []kv.KeyRange {\n\tkrs := make([]kv.KeyRange, 0, len(handles))\n\ti := 0\n\tfor i < len(handles) {\n\t\tj := i + 1\n\t\tfor ; j < len(handles) && handles[j-1] != math.MaxInt64; j++ {\n\t\t\tif handles[j] != handles[j-1]+1 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tlow := codec.EncodeInt(nil, handles[i])\n\t\thigh := codec.EncodeInt(nil, handles[j-1])\n\t\thigh = []byte(kv.Key(high).PrefixNext())\n\t\tstartKey := tablecodec.EncodeRowKey(tid, low)\n\t\tendKey := tablecodec.EncodeRowKey(tid, high)\n\t\tkrs = append(krs, kv.KeyRange{StartKey: startKey, EndKey: endKey})\n\t\ti = j\n\t}\n\treturn krs\n}", "category": "Python"}, {"instruction": "// CheckpointList returns the checkpoints of the given container in the docker host", "input": "go language", "output": "func (cli *Client) CheckpointList(ctx context.Context, container string, options types.CheckpointListOptions) ([]types.Checkpoint, error) {\n\tvar checkpoints []types.Checkpoint\n\n\tquery := url.Values{}\n\tif options.CheckpointDir != \"\" {\n\t\tquery.Set(\"dir\", options.CheckpointDir)\n\t}\n\n\tresp, err := cli.get(ctx, \"/containers/\"+container+\"/checkpoints\", query, nil)\n\tdefer ensureReaderClosed(resp)\n\tif err != nil {\n\t\treturn checkpoints, wrapResponseError(err, resp, \"container\", container)\n\t}\n\n\terr = json.NewDecoder(resp.body).Decode(&checkpoints)\n\treturn checkpoints, err\n}", "category": "Python"}, {"instruction": "// WaitForCacheSync waits for caches to populate.  It returns true if it was successful, false\n// if the controller should shutdown", "input": "go language", "output": "func WaitForCacheSync(stopCh <-chan struct{}, cacheSyncs ...InformerSynced) bool {\n\terr := wait.PollUntil(syncedPollPeriod,\n\t\tfunc() (bool, error) {\n\t\t\tfor _, syncFunc := range cacheSyncs {\n\t\t\t\tif !syncFunc() {\n\t\t\t\t\treturn false, nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true, nil\n\t\t},\n\t\tstopCh)\n\tif err != nil {\n\t\tklog.V(2).Infof(\"stop requested\")\n\t\treturn false\n\t}\n\n\tklog.V(4).Infof(\"caches populated\")\n\treturn true\n}", "category": "Python"}, {"instruction": "// receive reads the result from a watcher, restarting it if necessary.", "input": "go language", "output": "func (rw *RetryWatcher) receive() {\n\tdefer close(rw.doneChan)\n\tdefer close(rw.resultChan)\n\n\tklog.V(4).Info(\"Starting RetryWatcher.\")\n\tdefer klog.V(4).Info(\"Stopping RetryWatcher.\")\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tgo func() {\n\t\tselect {\n\t\tcase <-rw.stopChan:\n\t\t\tcancel()\n\t\t\treturn\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t}()\n\n\t// We use non sliding until so we don't introduce delays on happy path when WATCH call\n\t// timeouts or gets closed and we need to reestablish it while also avoiding hot loops.\n\twait.NonSlidingUntilWithContext(ctx, func(ctx context.Context) {\n\t\tdone, retryAfter := rw.doReceive()\n\t\tif done {\n\t\t\tcancel()\n\t\t\treturn\n\t\t}\n\n\t\ttime.Sleep(retryAfter)\n\n\t\tklog.V(4).Infof(\"Restarting RetryWatcher at RV=%q\", rw.lastResourceVersion)\n\t}, rw.minRestartDelay)\n}", "category": "Python"}, {"instruction": "// UpdateVmssVMWithRetry invokes az.VirtualMachineScaleSetVMsClient.Update with exponential backoff retry", "input": "go language", "output": "func (az *Cloud) UpdateVmssVMWithRetry(resourceGroupName string, VMScaleSetName string, instanceID string, parameters compute.VirtualMachineScaleSetVM) error {\n\treturn wait.ExponentialBackoff(az.requestBackoff(), func() (bool, error) {\n\t\tctx, cancel := getContextWithCancel()\n\t\tdefer cancel()\n\n\t\tresp, err := az.VirtualMachineScaleSetVMsClient.Update(ctx, resourceGroupName, VMScaleSetName, instanceID, parameters)\n\t\tklog.V(10).Infof(\"VirtualMachinesClient.CreateOrUpdate(%s,%s): end\", VMScaleSetName, instanceID)\n\t\treturn az.processHTTPRetryResponse(nil, \"\", resp, err)\n\t})\n}", "category": "Python"}, {"instruction": "// GEt /v1/connect/ca/configuration", "input": "go language", "output": "func (s *HTTPServer) ConnectCAConfigurationGet(resp http.ResponseWriter, req *http.Request) (interface{}, error) {\n\t// Method is tested in ConnectCAConfiguration\n\tvar args structs.DCSpecificRequest\n\tif done := s.parse(resp, req, &args.Datacenter, &args.QueryOptions); done {\n\t\treturn nil, nil\n\t}\n\n\tvar reply structs.CAConfiguration\n\terr := s.agent.RPC(\"ConnectCA.ConfigurationGet\", &args, &reply)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfixupConfig(&reply)\n\treturn reply, nil\n}", "category": "Python"}, {"instruction": "// compareHost compares two host string using some special rules, return value 1, 0, -1 means > = <.\n// TODO: Check how MySQL do it exactly, instead of guess its rules.", "input": "go language", "output": "func compareHost(x, y string) int {\n\t// The more-specific, the smaller it is.\n\t// The pattern '%' means \u201cany host\u201d and is least specific.\n\tif y == `%` {\n\t\tif x == `%` {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\t}\n\n\t// The empty string '' also means \u201cany host\u201d but sorts after '%'.\n\tif y == \"\" {\n\t\tif x == \"\" {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\t}\n\n\t// One of them end with `%`.\n\txEnd := strings.HasSuffix(x, `%`)\n\tyEnd := strings.HasSuffix(y, `%`)\n\tif xEnd || yEnd {\n\t\tswitch {\n\t\tcase !xEnd && yEnd:\n\t\t\treturn -1\n\t\tcase xEnd && !yEnd:\n\t\t\treturn 1\n\t\tcase xEnd && yEnd:\n\t\t\t// 192.168.199.% smaller than 192.168.%\n\t\t\t// A not very accurate comparison, compare them by length.\n\t\t\tif len(x) > len(y) {\n\t\t\t\treturn -1\n\t\t\t}\n\t\t}\n\t\treturn 0\n\t}\n\n\t// For other case, the order is nondeterministic.\n\tswitch x < y {\n\tcase true:\n\t\treturn -1\n\tcase false:\n\t\treturn 1\n\t}\n\treturn 0\n}", "category": "Python"}, {"instruction": "// CanUpgradeKubelets returns whether an upgrade of any kubelet in the cluster is possible", "input": "go language", "output": "func (u *Upgrade) CanUpgradeKubelets() bool {\n\t// If there are multiple different versions now, an upgrade is possible (even if only for a subset of the nodes)\n\tif len(u.Before.KubeletVersions) > 1 {\n\t\treturn true\n\t}\n\t// Don't report something available for upgrade if we don't know the current state\n\tif len(u.Before.KubeletVersions) == 0 {\n\t\treturn false\n\t}\n\n\t// if the same version number existed both before and after, we don't have to upgrade it\n\t_, sameVersionFound := u.Before.KubeletVersions[u.After.KubeVersion]\n\treturn !sameVersionFound\n}", "category": "Python"}, {"instruction": "// Handle filesystem notify event.\n// Files names:\n// - MUST NOT start with a '.'", "input": "go language", "output": "func (w *Watcher) handleCreateEvent(event fsnotify.Event) error {\n\tklog.V(6).Infof(\"Handling create event: %v\", event)\n\n\tif w.containsBlacklistedDir(event.Name) {\n\t\treturn nil\n\t}\n\n\tfi, err := os.Stat(event.Name)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"stat file %s failed: %v\", event.Name, err)\n\t}\n\n\tif strings.HasPrefix(fi.Name(), \".\") {\n\t\tklog.V(5).Infof(\"Ignoring file (starts with '.'): %s\", fi.Name())\n\t\treturn nil\n\t}\n\n\tif !fi.IsDir() {\n\t\tif fi.Mode()&os.ModeSocket == 0 {\n\t\t\tklog.V(5).Infof(\"Ignoring non socket file %s\", fi.Name())\n\t\t\treturn nil\n\t\t}\n\n\t\treturn w.handlePluginRegistration(event.Name)\n\t}\n\n\treturn w.traversePluginDir(event.Name)\n}", "category": "Python"}, {"instruction": "// NegotiateFormat returns an acceptable Accept format.", "input": "go language", "output": "func (c *Context) NegotiateFormat(offered ...string) string {\n\tassert1(len(offered) > 0, \"you must provide at least one offer\")\n\n\tif c.Accepted == nil {\n\t\tc.Accepted = parseAccept(c.requestHeader(\"Accept\"))\n\t}\n\tif len(c.Accepted) == 0 {\n\t\treturn offered[0]\n\t}\n\tfor _, accepted := range c.Accepted {\n\t\tfor _, offert := range offered {\n\t\t\t// According to RFC 2616 and RFC 2396, non-ASCII characters are not allowed in headers,\n\t\t\t// therefore we can just iterate over the string without casting it into []rune\n\t\t\ti := 0\n\t\t\tfor ; i < len(accepted); i++ {\n\t\t\t\tif accepted[i] == '*' || offert[i] == '*' {\n\t\t\t\t\treturn offert\n\t\t\t\t}\n\t\t\t\tif accepted[i] != offert[i] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif i == len(accepted) {\n\t\t\t\treturn offert\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}", "category": "Python"}, {"instruction": "// findProcess for non-Windows. Note that this very likely doesn't\n// work for all non-Windows platforms Go supports and we should expand\n// support as we experience it.", "input": "go language", "output": "func findProcess(pid int) (*os.Process, error) {\n\t// FindProcess never fails on unix-like systems.\n\tp, err := os.FindProcess(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// On Unix-like systems, we can verify a process is alive by sending\n\t// a 0 signal. This will do nothing to the process but will still\n\t// return errors if the process is gone.\n\terr = p.Signal(syscall.Signal(0))\n\tif err == nil {\n\t\treturn p, nil\n\t}\n\n\treturn nil, fmt.Errorf(\"process %d is dead or running as another user\", pid)\n}", "category": "Python"}, {"instruction": "// Snapshots creates snapshots of the services by calling the\n// simulation_snapshot RPC method", "input": "go language", "output": "func (sn *SimNode) Snapshots() (map[string][]byte, error) {\n\tsn.lock.RLock()\n\tservices := make(map[string]node.Service, len(sn.running))\n\tfor name, service := range sn.running {\n\t\tservices[name] = service\n\t}\n\tsn.lock.RUnlock()\n\tif len(services) == 0 {\n\t\treturn nil, errors.New(\"no running services\")\n\t}\n\tsnapshots := make(map[string][]byte)\n\tfor name, service := range services {\n\t\tif s, ok := service.(interface {\n\t\t\tSnapshot() ([]byte, error)\n\t\t}); ok {\n\t\t\tsnap, err := s.Snapshot()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tsnapshots[name] = snap\n\t\t}\n\t}\n\treturn snapshots, nil\n}", "category": "Python"}, {"instruction": "//----------------------------------------------------------------------------------\n// InitViper()\n//----------------------------------------------------------------------------------\n// Performs basic initialization of our viper-based configuration layer.\n// Primary thrust is to establish the paths that should be consulted to find\n// the configuration we need.  If v == nil, we will initialize the global\n// Viper instance\n//----------------------------------------------------------------------------------", "input": "go language", "output": "func InitViper(v *viper.Viper, configName string) error {\n\tvar altPath = os.Getenv(\"FABRIC_CFG_PATH\")\n\tif altPath != \"\" {\n\t\t// If the user has overridden the path with an envvar, its the only path\n\t\t// we will consider\n\n\t\tif !dirExists(altPath) {\n\t\t\treturn fmt.Errorf(\"FABRIC_CFG_PATH %s does not exist\", altPath)\n\t\t}\n\n\t\tAddConfigPath(v, altPath)\n\t} else {\n\t\t// If we get here, we should use the default paths in priority order:\n\t\t//\n\t\t// *) CWD\n\t\t// *) /etc/hyperledger/fabric\n\n\t\t// CWD\n\t\tAddConfigPath(v, \"./\")\n\n\t\t// And finally, the official path\n\t\tif dirExists(OfficialPath) {\n\t\t\tAddConfigPath(v, OfficialPath)\n\t\t}\n\t}\n\n\t// Now set the configuration file.\n\tif v != nil {\n\t\tv.SetConfigName(configName)\n\t} else {\n\t\tviper.SetConfigName(configName)\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// NewClientBackedDryRunGetterFromKubeconfig creates a new ClientBackedDryRunGetter instance from the given KubeConfig file", "input": "go language", "output": "func NewClientBackedDryRunGetterFromKubeconfig(file string) (*ClientBackedDryRunGetter, error) {\n\tconfig, err := clientcmd.LoadFromFile(file)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to load kubeconfig\")\n\t}\n\tclientConfig, err := clientcmd.NewDefaultClientConfig(*config, &clientcmd.ConfigOverrides{}).ClientConfig()\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to create API client configuration from kubeconfig\")\n\t}\n\treturn NewClientBackedDryRunGetter(clientConfig)\n}", "category": "Python"}, {"instruction": "// Kill implements the SessionManager interface.", "input": "go language", "output": "func (s *Server) Kill(connectionID uint64, query bool) {\n\ts.rwlock.Lock()\n\tdefer s.rwlock.Unlock()\n\tlogutil.Logger(context.Background()).Info(\"kill\", zap.Uint64(\"connID\", connectionID), zap.Bool(\"query\", query))\n\tmetrics.ServerEventCounter.WithLabelValues(metrics.EventKill).Inc()\n\n\tconn, ok := s.clients[uint32(connectionID)]\n\tif !ok {\n\t\treturn\n\t}\n\n\tif !query {\n\t\t// Mark the client connection status as WaitShutdown, when the goroutine detect\n\t\t// this, it will end the dispatch loop and exit.\n\t\tatomic.StoreInt32(&conn.status, connStatusWaitShutdown)\n\t}\n\tkillConn(conn)\n}", "category": "Python"}, {"instruction": "// ComputeV2MetadataHMACKey returns a key for the given \"authConfig\" that can be used to hash v2 metadata\n// entries.", "input": "go language", "output": "func ComputeV2MetadataHMACKey(authConfig *types.AuthConfig) ([]byte, error) {\n\tif authConfig == nil {\n\t\treturn nil, nil\n\t}\n\tkey := authConfigKeyInput{\n\t\tUsername:      authConfig.Username,\n\t\tPassword:      authConfig.Password,\n\t\tAuth:          authConfig.Auth,\n\t\tIdentityToken: authConfig.IdentityToken,\n\t\tRegistryToken: authConfig.RegistryToken,\n\t}\n\tbuf, err := json.Marshal(&key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn []byte(digest.FromBytes(buf)), nil\n}", "category": "Python"}, {"instruction": "// ObjectKinds returns a slice of one element with the group,version,kind of the\n// provided object, or an error if the object is not runtime.Unstructured or\n// has no group,version,kind information. unversionedType will always be false\n// because runtime.Unstructured object should always have group,version,kind\n// information set.", "input": "go language", "output": "func (d *UnstructuredObjectTyper) ObjectKinds(obj runtime.Object) (gvks []schema.GroupVersionKind, unversionedType bool, err error) {\n\tif _, ok := obj.(runtime.Unstructured); ok {\n\t\tgvk := obj.GetObjectKind().GroupVersionKind()\n\t\tif len(gvk.Kind) == 0 {\n\t\t\treturn nil, false, runtime.NewMissingKindErr(\"object has no kind field \")\n\t\t}\n\t\tif len(gvk.Version) == 0 {\n\t\t\treturn nil, false, runtime.NewMissingVersionErr(\"object has no apiVersion field\")\n\t\t}\n\t\treturn []schema.GroupVersionKind{gvk}, false, nil\n\t}\n\n\treturn nil, false, runtime.NewNotRegisteredErrForType(\"crdserverscheme.UnstructuredObjectTyper\", reflect.TypeOf(obj))\n}", "category": "Python"}, {"instruction": "// LookupUser uses traditional local system files lookup (from libcontainer/user) on a username,\n// followed by a call to `getent` for supporting host configured non-files passwd and group dbs", "input": "go language", "output": "func LookupUser(username string) (user.User, error) {\n\t// first try a local system files lookup using existing capabilities\n\tusr, err := user.LookupUser(username)\n\tif err == nil {\n\t\treturn usr, nil\n\t}\n\t// local files lookup failed; attempt to call `getent` to query configured passwd dbs\n\tusr, err = getentUser(fmt.Sprintf(\"%s %s\", \"passwd\", username))\n\tif err != nil {\n\t\treturn user.User{}, err\n\t}\n\treturn usr, nil\n}", "category": "Python"}, {"instruction": "// UnmarshalClusterStatus takes raw ConfigMap.Data and converts it to a ClusterStatus object", "input": "go language", "output": "func UnmarshalClusterStatus(data map[string]string) (*kubeadmapi.ClusterStatus, error) {\n\tclusterStatusData, ok := data[constants.ClusterStatusConfigMapKey]\n\tif !ok {\n\t\treturn nil, errors.Errorf(\"unexpected error when reading kubeadm-config ConfigMap: %s key value pair missing\", constants.ClusterStatusConfigMapKey)\n\t}\n\tclusterStatus := &kubeadmapi.ClusterStatus{}\n\tif err := runtime.DecodeInto(kubeadmscheme.Codecs.UniversalDecoder(), []byte(clusterStatusData), clusterStatus); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn clusterStatus, nil\n}", "category": "Python"}, {"instruction": "// DeepCopy creates a copy of the receiver where any pointers to nested mutable\n// values are also copied, thus ensuring that future mutations of the receiver\n// will not affect the copy.\n//\n// Some types used within a resource change are immutable by convention even\n// though the Go language allows them to be mutated, such as the types from\n// the addrs package. These are _not_ copied by this method, under the\n// assumption that callers will behave themselves.", "input": "go language", "output": "func (rcs *ResourceInstanceChangeSrc) DeepCopy() *ResourceInstanceChangeSrc {\n\tif rcs == nil {\n\t\treturn nil\n\t}\n\tret := *rcs\n\n\tret.RequiredReplace = cty.NewPathSet(ret.RequiredReplace.List()...)\n\n\tif len(ret.Private) != 0 {\n\t\tprivate := make([]byte, len(ret.Private))\n\t\tcopy(private, ret.Private)\n\t\tret.Private = private\n\t}\n\n\tret.ChangeSrc.Before = ret.ChangeSrc.Before.Copy()\n\tret.ChangeSrc.After = ret.ChangeSrc.After.Copy()\n\n\treturn &ret\n}", "category": "Python"}, {"instruction": "// ValidateIPBlock validates a cidr and the except fields of an IpBlock NetworkPolicyPeer", "input": "go language", "output": "func ValidateIPBlock(ipb *networking.IPBlock, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tif len(ipb.CIDR) == 0 || ipb.CIDR == \"\" {\n\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"cidr\"), \"\"))\n\t\treturn allErrs\n\t}\n\tcidrIPNet, err := apivalidation.ValidateCIDR(ipb.CIDR)\n\tif err != nil {\n\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"cidr\"), ipb.CIDR, \"not a valid CIDR\"))\n\t\treturn allErrs\n\t}\n\texceptCIDR := ipb.Except\n\tfor i, exceptIP := range exceptCIDR {\n\t\texceptPath := fldPath.Child(\"except\").Index(i)\n\t\texceptCIDR, err := apivalidation.ValidateCIDR(exceptIP)\n\t\tif err != nil {\n\t\t\tallErrs = append(allErrs, field.Invalid(exceptPath, exceptIP, \"not a valid CIDR\"))\n\t\t\treturn allErrs\n\t\t}\n\t\tif !cidrIPNet.Contains(exceptCIDR.IP) {\n\t\t\tallErrs = append(allErrs, field.Invalid(exceptPath, exceptCIDR.IP, \"not within CIDR range\"))\n\t\t}\n\t}\n\treturn allErrs\n}", "category": "Python"}, {"instruction": "// Get retrieves the object from the Namespace and Name fields", "input": "go language", "output": "func (i *Info) Get() (err error) {\n\tobj, err := NewHelper(i.Client, i.Mapping).Get(i.Namespace, i.Name, i.Export)\n\tif err != nil {\n\t\tif errors.IsNotFound(err) && len(i.Namespace) > 0 && i.Namespace != metav1.NamespaceDefault && i.Namespace != metav1.NamespaceAll {\n\t\t\terr2 := i.Client.Get().AbsPath(\"api\", \"v1\", \"namespaces\", i.Namespace).Do().Error()\n\t\t\tif err2 != nil && errors.IsNotFound(err2) {\n\t\t\t\treturn err2\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\ti.Object = obj\n\ti.ResourceVersion, _ = metadataAccessor.ResourceVersion(obj)\n\treturn nil\n}", "category": "Python"}, {"instruction": "// AccumulateRewards credits the coinbase of the given block with the mining\n// reward. The total reward consists of the static block reward and rewards for\n// included uncles. The coinbase of each uncle block is also rewarded.", "input": "go language", "output": "func accumulateRewards(config *params.ChainConfig, state *state.StateDB, header *types.Header, uncles []*types.Header) {\n\t// Select the correct block reward based on chain progression\n\tblockReward := FrontierBlockReward\n\tif config.IsByzantium(header.Number) {\n\t\tblockReward = ByzantiumBlockReward\n\t}\n\tif config.IsConstantinople(header.Number) {\n\t\tblockReward = ConstantinopleBlockReward\n\t}\n\t// Accumulate the rewards for the miner and any included uncles\n\treward := new(big.Int).Set(blockReward)\n\tr := new(big.Int)\n\tfor _, uncle := range uncles {\n\t\tr.Add(uncle.Number, big8)\n\t\tr.Sub(r, header.Number)\n\t\tr.Mul(r, blockReward)\n\t\tr.Div(r, big8)\n\t\tstate.AddBalance(uncle.Coinbase, r)\n\n\t\tr.Div(blockReward, big32)\n\t\treward.Add(reward, r)\n\t}\n\tstate.AddBalance(header.Coinbase, reward)\n}", "category": "Python"}, {"instruction": "// resolve retrieves the hostname a service is running on either by returning the\n// actual server name and port, or preferably an nginx virtual host if available.", "input": "go language", "output": "func resolve(client *sshClient, network string, service string, port int) (string, error) {\n\t// Inspect the service to get various configurations from it\n\tinfos, err := inspectContainer(client, fmt.Sprintf(\"%s_%s_1\", network, service))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif !infos.running {\n\t\treturn \"\", ErrServiceOffline\n\t}\n\t// Container online, extract any environmental variables\n\tif vhost := infos.envvars[\"VIRTUAL_HOST\"]; vhost != \"\" {\n\t\treturn vhost, nil\n\t}\n\treturn fmt.Sprintf(\"%s:%d\", client.server, port), nil\n}", "category": "Python"}, {"instruction": "// ToHashKey removes the leading and trailing zeros and generates a hash key.\n// Two Decimals dec0 and dec1 with different fraction will generate the same hash keys if dec0.Compare(dec1) == 0.", "input": "go language", "output": "func (d *MyDecimal) ToHashKey() ([]byte, error) {\n\t_, digitsInt := d.removeLeadingZeros()\n\t_, digitsFrac := d.removeTrailingZeros()\n\tprec := digitsInt + digitsFrac\n\tif prec == 0 { // zeroDecimal\n\t\tprec = 1\n\t}\n\tbuf, err := d.ToBin(prec, digitsFrac)\n\tif err == ErrTruncated {\n\t\t// This err is caused by shorter digitsFrac;\n\t\t// After removing the trailing zeros from a Decimal,\n\t\t// so digitsFrac may be less than the real digitsFrac of the Decimal,\n\t\t// thus ErrTruncated may be raised, we can ignore it here.\n\t\terr = nil\n\t}\n\treturn buf, err\n}", "category": "Python"}, {"instruction": "// LstatIfPossible returns the os.FileInfo structure describing a given file.\n// It attempts to use Lstat if supported or defers to the os.  In addition to\n// the FileInfo, a boolean is returned telling whether Lstat was called.", "input": "go language", "output": "func (fs *LanguageFs) LstatIfPossible(name string) (os.FileInfo, bool, error) {\n\tname, err := fs.realName(name)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvar fi os.FileInfo\n\tvar b bool\n\n\tif lif, ok := fs.Fs.(afero.Lstater); ok {\n\t\tfi, b, err = lif.LstatIfPossible(name)\n\t} else {\n\t\tfi, err = fs.Fs.Stat(name)\n\t}\n\n\tif err != nil {\n\t\treturn nil, b, err\n\t}\n\n\tlfi, err := fs.newLanguageFileInfo(name, fi)\n\n\treturn lfi, b, err\n}", "category": "Python"}, {"instruction": "// convertToRuntimeSecurityContext converts v1.SecurityContext to runtimeapi.SecurityContext.", "input": "go language", "output": "func convertToRuntimeSecurityContext(securityContext *v1.SecurityContext) *runtimeapi.LinuxContainerSecurityContext {\n\tif securityContext == nil {\n\t\treturn nil\n\t}\n\n\tsc := &runtimeapi.LinuxContainerSecurityContext{\n\t\tCapabilities:   convertToRuntimeCapabilities(securityContext.Capabilities),\n\t\tSelinuxOptions: convertToRuntimeSELinuxOption(securityContext.SELinuxOptions),\n\t}\n\tif securityContext.RunAsUser != nil {\n\t\tsc.RunAsUser = &runtimeapi.Int64Value{Value: int64(*securityContext.RunAsUser)}\n\t}\n\tif securityContext.RunAsGroup != nil {\n\t\tsc.RunAsGroup = &runtimeapi.Int64Value{Value: int64(*securityContext.RunAsGroup)}\n\t}\n\tif securityContext.Privileged != nil {\n\t\tsc.Privileged = *securityContext.Privileged\n\t}\n\tif securityContext.ReadOnlyRootFilesystem != nil {\n\t\tsc.ReadonlyRootfs = *securityContext.ReadOnlyRootFilesystem\n\t}\n\n\treturn sc\n}", "category": "Python"}, {"instruction": "// applyPreparedQueryOperation applies the given prepared query operation to the\n// state store.", "input": "go language", "output": "func (c *FSM) applyPreparedQueryOperation(buf []byte, index uint64) interface{} {\n\tvar req structs.PreparedQueryRequest\n\tif err := structs.Decode(buf, &req); err != nil {\n\t\tpanic(fmt.Errorf(\"failed to decode request: %v\", err))\n\t}\n\n\tdefer metrics.MeasureSinceWithLabels([]string{\"fsm\", \"prepared-query\"}, time.Now(),\n\t\t[]metrics.Label{{Name: \"op\", Value: string(req.Op)}})\n\tswitch req.Op {\n\tcase structs.PreparedQueryCreate, structs.PreparedQueryUpdate:\n\t\treturn c.state.PreparedQuerySet(index, req.Query)\n\tcase structs.PreparedQueryDelete:\n\t\treturn c.state.PreparedQueryDelete(index, req.Query.ID)\n\tdefault:\n\t\tc.logger.Printf(\"[WARN] consul.fsm: Invalid PreparedQuery operation '%s'\", req.Op)\n\t\treturn fmt.Errorf(\"Invalid PreparedQuery operation '%s'\", req.Op)\n\t}\n}", "category": "Python"}, {"instruction": "// IsComputed returns whether the given key is computed or not.", "input": "go language", "output": "func (c *ResourceConfig) IsComputed(k string) bool {\n\t// The next thing we do is check the config if we get a computed\n\t// value out of it.\n\tv, ok := c.get(k, c.Config)\n\tif !ok {\n\t\treturn false\n\t}\n\n\t// If value is nil, then it isn't computed\n\tif v == nil {\n\t\treturn false\n\t}\n\n\t// Test if the value contains an unknown value\n\tvar w unknownCheckWalker\n\tif err := reflectwalk.Walk(v, &w); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn w.Unknown\n}", "category": "Python"}, {"instruction": "// Send sends the request, and receives a response", "input": "go language", "output": "func (stub *ClientStub) Send(server string, conf common.Config, req *discovery.Request) (ServiceResponse, error) {\n\tcomm, err := comm.NewClient(conf.TLSConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsigner, err := signer.NewSigner(conf.SignerConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttimeout, cancel := context.WithTimeout(context.Background(), defaultTimeout)\n\tdefer cancel()\n\n\tdisc := discovery.NewClient(comm.NewDialer(server), signer.Sign, 0)\n\n\tresp, err := disc.Send(timeout, req, &AuthInfo{\n\t\tClientIdentity:    signer.Creator,\n\t\tClientTlsCertHash: comm.TLSCertHash,\n\t})\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"failed connecting to %s: %v\", server, err)\n\t}\n\treturn &response{\n\t\tResponse: resp,\n\t}, nil\n}", "category": "Python"}, {"instruction": "// ForResource gives generic access to a shared informer of the matching type\n// TODO extend this to unknown resources with a client pool", "input": "go language", "output": "func (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) {\n\tswitch resource {\n\t// Group=apiregistration.k8s.io, Version=internalVersion\n\tcase apiregistration.SchemeGroupVersion.WithResource(\"apiservices\"):\n\t\treturn &genericInformer{resource: resource.GroupResource(), informer: f.Apiregistration().InternalVersion().APIServices().Informer()}, nil\n\n\t}\n\n\treturn nil, fmt.Errorf(\"no informer found for %v\", resource)\n}", "category": "Python"}, {"instruction": "// StopContainer stops a running container with a grace period (i.e., timeout).", "input": "go language", "output": "func (r *RemoteRuntimeService) StopContainer(containerID string, timeout int64) error {\n\t// Use timeout + default timeout (2 minutes) as timeout to leave extra time\n\t// for SIGKILL container and request latency.\n\tt := r.timeout + time.Duration(timeout)*time.Second\n\tctx, cancel := getContextWithTimeout(t)\n\tdefer cancel()\n\n\tr.logReduction.ClearID(containerID)\n\t_, err := r.runtimeClient.StopContainer(ctx, &runtimeapi.StopContainerRequest{\n\t\tContainerId: containerID,\n\t\tTimeout:     timeout,\n\t})\n\tif err != nil {\n\t\tklog.Errorf(\"StopContainer %q from runtime service failed: %v\", containerID, err)\n\t\treturn err\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// DecrypterVerify exposes how to get state to the ledger after having received keys for\n// decrypting (AES 256 bit key) and verifying (X9.62/SECG curve over a 256 bit prime field) that has been provided to the chaincode through the\n// transient field", "input": "go language", "output": "func (t *EncCC) DecrypterVerify(stub shim.ChaincodeStubInterface, args []string, decKey, verKey []byte) pb.Response {\n\t// create the decrypter/verify entity - we give it an ID, the bccsp instance and the keys\n\tent, err := entities.NewAES256EncrypterECDSASignerEntity(\"ID\", t.bccspInst, decKey, verKey)\n\tif err != nil {\n\t\treturn shim.Error(fmt.Sprintf(\"entities.NewAES256DecrypterEntity failed, err %s\", err))\n\t}\n\n\tif len(args) != 1 {\n\t\treturn shim.Error(\"Expected 1 parameters to function DecrypterVerify\")\n\t}\n\tkey := args[0]\n\n\t// here we decrypt the state associated to key and verify it\n\tcleartextValue, err := getStateDecryptAndVerify(stub, ent, key)\n\tif err != nil {\n\t\treturn shim.Error(fmt.Sprintf(\"getStateDecryptAndVerify failed, err %+v\", err))\n\t}\n\n\t// here we return the decrypted and verified value as a result\n\treturn shim.Success(cleartextValue)\n}", "category": "Python"}, {"instruction": "// CryptBlocks implements BlockMode.CryptBlocks interface.", "input": "go language", "output": "func (x *ecbDecrypter) CryptBlocks(dst, src []byte) {\n\tif len(src)%x.blockSize != 0 {\n\t\tpanic(\"ECBDecrypter: input not full blocks\")\n\t}\n\tif len(dst) < len(src) {\n\t\tpanic(\"ECBDecrypter: output smaller than input\")\n\t}\n\t// See https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29\n\tfor len(src) > 0 {\n\t\tx.b.Decrypt(dst, src[:x.blockSize])\n\t\tsrc = src[x.blockSize:]\n\t\tdst = dst[x.blockSize:]\n\t}\n}", "category": "Python"}, {"instruction": "// Validate checks to the LabelOptions to see if there is sufficient information run the command.", "input": "go language", "output": "func (o *LabelOptions) Validate() error {\n\tif o.all && len(o.selector) > 0 {\n\t\treturn fmt.Errorf(\"cannot set --all and --selector at the same time\")\n\t}\n\tif o.all && len(o.fieldSelector) > 0 {\n\t\treturn fmt.Errorf(\"cannot set --all and --field-selector at the same time\")\n\t}\n\tif len(o.resources) < 1 && cmdutil.IsFilenameSliceEmpty(o.FilenameOptions.Filenames, o.FilenameOptions.Kustomize) {\n\t\treturn fmt.Errorf(\"one or more resources must be specified as <resource> <name> or <resource>/<name>\")\n\t}\n\tif len(o.newLabels) < 1 && len(o.removeLabels) < 1 && !o.list {\n\t\treturn fmt.Errorf(\"at least one label update is required\")\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// AddWrapper binds the passed type to the passed wrapper.\n// Notice that that wrapper must be an instance of one of the following interfaces:\n// KeyGenerator, KeyDeriver, KeyImporter, Encryptor, Decryptor, Signer, Verifier, Hasher.", "input": "go language", "output": "func (csp *CSP) AddWrapper(t reflect.Type, w interface{}) error {\n\tif t == nil {\n\t\treturn errors.Errorf(\"type cannot be nil\")\n\t}\n\tif w == nil {\n\t\treturn errors.Errorf(\"wrapper cannot be nil\")\n\t}\n\tswitch dt := w.(type) {\n\tcase KeyGenerator:\n\t\tcsp.KeyGenerators[t] = dt\n\tcase KeyImporter:\n\t\tcsp.KeyImporters[t] = dt\n\tcase KeyDeriver:\n\t\tcsp.KeyDerivers[t] = dt\n\tcase Encryptor:\n\t\tcsp.Encryptors[t] = dt\n\tcase Decryptor:\n\t\tcsp.Decryptors[t] = dt\n\tcase Signer:\n\t\tcsp.Signers[t] = dt\n\tcase Verifier:\n\t\tcsp.Verifiers[t] = dt\n\tcase Hasher:\n\t\tcsp.Hashers[t] = dt\n\tdefault:\n\t\treturn errors.Errorf(\"wrapper type not valid, must be on of: KeyGenerator, KeyDeriver, KeyImporter, Encryptor, Decryptor, Signer, Verifier, Hasher\")\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// NewHandle creates a Handle for update stats.", "input": "go language", "output": "func NewHandle(ctx sessionctx.Context, lease time.Duration) *Handle {\n\thandle := &Handle{\n\t\tddlEventCh: make(chan *util.Event, 100),\n\t\tlistHead:   &SessionStatsCollector{mapper: make(tableDeltaMap), rateMap: make(errorRateDeltaMap)},\n\t\tglobalMap:  make(tableDeltaMap),\n\t\tLease:      lease,\n\t\tfeedback:   make([]*statistics.QueryFeedback, 0, MaxQueryFeedbackCount.Load()),\n\t}\n\t// It is safe to use it concurrently because the exec won't touch the ctx.\n\tif exec, ok := ctx.(sqlexec.RestrictedSQLExecutor); ok {\n\t\thandle.restrictedExec = exec\n\t}\n\thandle.mu.ctx = ctx\n\thandle.mu.rateMap = make(errorRateDeltaMap)\n\thandle.StatsCache.Store(StatsCache{})\n\treturn handle\n}", "category": "Python"}, {"instruction": "// getNewConn is used to return a new connection", "input": "go language", "output": "func (p *ConnPool) getNewConn(dc string, addr net.Addr, version int, useTLS bool) (*Conn, error) {\n\t// Get a new, raw connection.\n\tconn, _, err := p.DialTimeout(dc, addr, defaultDialTimeout, useTLS)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Switch the multiplexing based on version\n\tvar session muxSession\n\tif version < 2 {\n\t\tconn.Close()\n\t\treturn nil, fmt.Errorf(\"cannot make client connection, unsupported protocol version %d\", version)\n\t}\n\n\t// Write the Consul multiplex byte to set the mode\n\tif _, err := conn.Write([]byte{byte(RPCMultiplexV2)}); err != nil {\n\t\tconn.Close()\n\t\treturn nil, err\n\t}\n\n\t// Setup the logger\n\tconf := yamux.DefaultConfig()\n\tconf.LogOutput = p.LogOutput\n\n\t// Create a multiplexed session\n\tsession, _ = yamux.Client(conn, conf)\n\n\t// Wrap the connection\n\tc := &Conn{\n\t\trefCount: 1,\n\t\taddr:     addr,\n\t\tsession:  session,\n\t\tclients:  list.New(),\n\t\tlastUsed: time.Now(),\n\t\tversion:  version,\n\t\tpool:     p,\n\t}\n\treturn c, nil\n}", "category": "Python"}, {"instruction": "// NamespaceToSelectableFields returns a field set that represents the object", "input": "go language", "output": "func NamespaceToSelectableFields(namespace *api.Namespace) fields.Set {\n\tobjectMetaFieldsSet := generic.ObjectMetaFieldsSet(&namespace.ObjectMeta, false)\n\tspecificFieldsSet := fields.Set{\n\t\t\"status.phase\": string(namespace.Status.Phase),\n\t\t// This is a bug, but we need to support it for backward compatibility.\n\t\t\"name\": namespace.Name,\n\t}\n\treturn generic.MergeFieldsSets(objectMetaFieldsSet, specificFieldsSet)\n}", "category": "Python"}, {"instruction": "// getOrInitialize either grabs the configmaps current value or defines the value\n// and sets the configmap. This is for the case of the user calling GetClusterID()\n// before the watch has begun.", "input": "go language", "output": "func (ci *ClusterID) getOrInitialize() error {\n\tif ci.store == nil {\n\t\treturn errors.New(\"Cloud.ClusterID is not ready. Call Initialize() before using\")\n\t}\n\n\tif ci.clusterID != nil {\n\t\treturn nil\n\t}\n\n\texists, err := ci.getConfigMap()\n\tif err != nil {\n\t\treturn err\n\t} else if exists {\n\t\treturn nil\n\t}\n\n\t// The configmap does not exist - let's try creating one.\n\tnewID, err := makeUID()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tklog.V(4).Infof(\"Creating clusteriD: %v\", newID)\n\tcfg := &v1.ConfigMap{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      UIDConfigMapName,\n\t\t\tNamespace: UIDNamespace,\n\t\t},\n\t}\n\tcfg.Data = map[string]string{\n\t\tUIDCluster:  newID,\n\t\tUIDProvider: newID,\n\t}\n\n\tif _, err := ci.client.CoreV1().ConfigMaps(UIDNamespace).Create(cfg); err != nil {\n\t\tklog.Errorf(\"GCE cloud provider failed to create %v config map to store cluster id: %v\", ci.cfgMapKey, err)\n\t\treturn err\n\t}\n\n\tklog.V(2).Infof(\"Created a config map containing clusteriD: %v\", newID)\n\tci.update(cfg)\n\treturn nil\n}", "category": "Python"}, {"instruction": "// compare two variables of the same type, i.e. non complex one, such as TypeList or TypeMap", "input": "go language", "output": "func compareSimpleVariables(a, b ast.Variable) (bool, error) {\n\tif a.Type != b.Type {\n\t\treturn false, fmt.Errorf(\n\t\t\t\"won't compare items of different types %s and %s\",\n\t\t\ta.Type.Printable(), b.Type.Printable())\n\t}\n\tswitch a.Type {\n\tcase ast.TypeString:\n\t\treturn a.Value.(string) == b.Value.(string), nil\n\tdefault:\n\t\treturn false, fmt.Errorf(\n\t\t\t\"can't compare items of type %s\",\n\t\t\ta.Type.Printable())\n\t}\n}", "category": "Python"}, {"instruction": "// GetOrganizationalUnits returns the OU for this instance", "input": "go language", "output": "func (id *identity) GetOrganizationalUnits() []*OUIdentifier {\n\tif id.cert == nil {\n\t\treturn nil\n\t}\n\n\tcid, err := id.msp.getCertificationChainIdentifier(id)\n\tif err != nil {\n\t\tmspIdentityLogger.Errorf(\"Failed getting certification chain identifier for [%v]: [%+v]\", id, err)\n\n\t\treturn nil\n\t}\n\n\tres := []*OUIdentifier{}\n\tfor _, unit := range id.cert.Subject.OrganizationalUnit {\n\t\tres = append(res, &OUIdentifier{\n\t\t\tOrganizationalUnitIdentifier: unit,\n\t\t\tCertifiersIdentifier:         cid,\n\t\t})\n\t}\n\n\treturn res\n}", "category": "Python"}, {"instruction": "// evalDuration evals a builtinTimeTimeTimeDiffSig.\n// See https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_timediff", "input": "go language", "output": "func (b *builtinTimeTimeTimeDiffSig) evalDuration(row chunk.Row) (d types.Duration, isNull bool, err error) {\n\tlhs, isNull, err := b.args[0].EvalTime(b.ctx, row)\n\tif isNull || err != nil {\n\t\treturn d, isNull, err\n\t}\n\n\trhs, isNull, err := b.args[1].EvalTime(b.ctx, row)\n\tif isNull || err != nil {\n\t\treturn d, isNull, err\n\t}\n\n\tsc := b.ctx.GetSessionVars().StmtCtx\n\td, isNull, err = calculateTimeDiff(sc, lhs, rhs)\n\treturn d, isNull, err\n}", "category": "Python"}, {"instruction": "// getFsInfo writes metrics.Capacity, metrics.Used and metrics.Available from the filesystem info", "input": "go language", "output": "func (md *metricsStatFS) getFsInfo(metrics *Metrics) error {\n\tavailable, capacity, usage, inodes, inodesFree, inodesUsed, err := fs.FsInfo(md.path)\n\tif err != nil {\n\t\treturn NewFsInfoFailedError(err)\n\t}\n\tmetrics.Available = resource.NewQuantity(available, resource.BinarySI)\n\tmetrics.Capacity = resource.NewQuantity(capacity, resource.BinarySI)\n\tmetrics.Used = resource.NewQuantity(usage, resource.BinarySI)\n\tmetrics.Inodes = resource.NewQuantity(inodes, resource.BinarySI)\n\tmetrics.InodesFree = resource.NewQuantity(inodesFree, resource.BinarySI)\n\tmetrics.InodesUsed = resource.NewQuantity(inodesUsed, resource.BinarySI)\n\treturn nil\n}", "category": "Python"}, {"instruction": "// clearAttachableNetworks removes the attachable networks\n// after disconnecting any connected container", "input": "go language", "output": "func (daemon *Daemon) clearAttachableNetworks() {\n\tfor _, n := range daemon.getAllNetworks() {\n\t\tif !n.Info().Attachable() {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, ep := range n.Endpoints() {\n\t\t\tepInfo := ep.Info()\n\t\t\tif epInfo == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsb := epInfo.Sandbox()\n\t\t\tif sb == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcontainerID := sb.ContainerID()\n\t\t\tif err := daemon.DisconnectContainerFromNetwork(containerID, n.ID(), true); err != nil {\n\t\t\t\tlogrus.Warnf(\"Failed to disconnect container %s from swarm network %s on cluster leave: %v\",\n\t\t\t\t\tcontainerID, n.Name(), err)\n\t\t\t}\n\t\t}\n\t\tif err := daemon.DeleteManagedNetwork(n.ID()); err != nil {\n\t\t\tlogrus.Warnf(\"Failed to remove swarm network %s on cluster leave: %v\", n.Name(), err)\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// String implements the fmt.Stringer interface.", "input": "go language", "output": "func (c *ChainConfig) String() string {\n\tvar engine interface{}\n\tswitch {\n\tcase c.Ethash != nil:\n\t\tengine = c.Ethash\n\tcase c.Clique != nil:\n\t\tengine = c.Clique\n\tdefault:\n\t\tengine = \"unknown\"\n\t}\n\treturn fmt.Sprintf(\"{ChainID: %v Homestead: %v DAO: %v DAOSupport: %v EIP150: %v EIP155: %v EIP158: %v Byzantium: %v Constantinople: %v  ConstantinopleFix: %v Engine: %v}\",\n\t\tc.ChainID,\n\t\tc.HomesteadBlock,\n\t\tc.DAOForkBlock,\n\t\tc.DAOForkSupport,\n\t\tc.EIP150Block,\n\t\tc.EIP155Block,\n\t\tc.EIP158Block,\n\t\tc.ByzantiumBlock,\n\t\tc.ConstantinopleBlock,\n\t\tc.PetersburgBlock,\n\t\tengine,\n\t)\n}", "category": "Python"}, {"instruction": "// ensureLease creates the lease if it does not exist. Returns the lease and\n// a bool (true if this call created the lease), or any error that occurs.", "input": "go language", "output": "func (c *controller) ensureLease() (*coordv1beta1.Lease, bool, error) {\n\tlease, err := c.leaseClient.Get(c.holderIdentity, metav1.GetOptions{})\n\tif apierrors.IsNotFound(err) {\n\t\t// lease does not exist, create it\n\t\tlease, err := c.leaseClient.Create(c.newLease(nil))\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\treturn lease, true, nil\n\t} else if err != nil {\n\t\t// unexpected error getting lease\n\t\treturn nil, false, err\n\t}\n\t// lease already existed\n\treturn lease, false, nil\n}", "category": "Python"}, {"instruction": "// DumpFeedbackToKV dumps the given feedback to physical kv layer.", "input": "go language", "output": "func (h *Handle) DumpFeedbackToKV(fb *statistics.QueryFeedback) error {\n\tvals, err := statistics.EncodeFeedback(fb)\n\tif err != nil {\n\t\tlogutil.Logger(context.Background()).Debug(\"error occurred when encoding feedback\", zap.Error(err))\n\t\treturn nil\n\t}\n\tvar isIndex int64\n\tif fb.Tp == statistics.IndexType {\n\t\tisIndex = 1\n\t}\n\tsql := fmt.Sprintf(\"insert into mysql.stats_feedback (table_id, hist_id, is_index, feedback) values \"+\n\t\t\"(%d, %d, %d, X'%X')\", fb.PhysicalID, fb.Hist.ID, isIndex, vals)\n\th.mu.Lock()\n\t_, err = h.mu.ctx.(sqlexec.SQLExecutor).Execute(context.TODO(), sql)\n\th.mu.Unlock()\n\tif err != nil {\n\t\tmetrics.DumpFeedbackCounter.WithLabelValues(metrics.LblError).Inc()\n\t} else {\n\t\tmetrics.DumpFeedbackCounter.WithLabelValues(metrics.LblOK).Inc()\n\t}\n\treturn errors.Trace(err)\n}", "category": "Python"}, {"instruction": "// ResolveCharsetCollation will resolve the charset by the order: table charset > database charset > server default charset.", "input": "go language", "output": "func ResolveCharsetCollation(tblCharset, dbCharset string) (string, string, error) {\n\tif len(tblCharset) != 0 {\n\t\tdefCollate, err := charset.GetDefaultCollation(tblCharset)\n\t\tif err != nil {\n\t\t\t// return terror is better.\n\t\t\treturn \"\", \"\", ErrUnknownCharacterSet.GenWithStackByArgs(tblCharset)\n\t\t}\n\t\treturn tblCharset, defCollate, nil\n\t}\n\n\tif len(dbCharset) != 0 {\n\t\tdefCollate, err := charset.GetDefaultCollation(dbCharset)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", ErrUnknownCharacterSet.GenWithStackByArgs(dbCharset)\n\t\t}\n\t\treturn dbCharset, defCollate, errors.Trace(err)\n\t}\n\n\tcharset, collate := charset.GetDefaultCharsetAndCollate()\n\treturn charset, collate, nil\n}", "category": "Python"}, {"instruction": "// StmtCommit implements the sessionctx.Context interface.", "input": "go language", "output": "func (s *session) StmtCommit() error {\n\tdefer s.txn.cleanup()\n\tst := &s.txn\n\tvar count int\n\terr := kv.WalkMemBuffer(st.buf, func(k kv.Key, v []byte) error {\n\t\tfailpoint.Inject(\"mockStmtCommitError\", func(val failpoint.Value) {\n\t\t\tif val.(bool) {\n\t\t\t\tcount++\n\t\t\t}\n\t\t})\n\n\t\tif count > 3 {\n\t\t\treturn errors.New(\"mock stmt commit error\")\n\t\t}\n\n\t\tif len(v) == 0 {\n\t\t\treturn st.Transaction.Delete(k)\n\t\t}\n\t\treturn st.Transaction.Set(k, v)\n\t})\n\tif err != nil {\n\t\tst.doNotCommit = err\n\t\treturn err\n\t}\n\n\t// Need to flush binlog.\n\tfor tableID, delta := range st.mutations {\n\t\tmutation := getBinlogMutation(s, tableID)\n\t\tmergeToMutation(mutation, delta)\n\t}\n\n\tif len(st.dirtyTableOP) > 0 {\n\t\tdirtyDB := executor.GetDirtyDB(s)\n\t\tfor _, op := range st.dirtyTableOP {\n\t\t\tmergeToDirtyDB(dirtyDB, op)\n\t\t}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// RunCompletion checks given arguments and executes command", "input": "go language", "output": "func RunCompletion(out io.Writer, boilerPlate string, cmd *cobra.Command, args []string) error {\n\tif len(args) == 0 {\n\t\treturn cmdutil.UsageErrorf(cmd, \"Shell not specified.\")\n\t}\n\tif len(args) > 1 {\n\t\treturn cmdutil.UsageErrorf(cmd, \"Too many arguments. Expected only the shell type.\")\n\t}\n\trun, found := completionShells[args[0]]\n\tif !found {\n\t\treturn cmdutil.UsageErrorf(cmd, \"Unsupported shell type %q.\", args[0])\n\t}\n\n\treturn run(out, boilerPlate, cmd.Parent())\n}", "category": "Python"}, {"instruction": "// TranslatePullError is used to convert an error from a registry pull\n// operation to an error representing the entire pull operation. Any error\n// information which is not used by the returned error gets output to\n// log at info level.", "input": "go language", "output": "func TranslatePullError(err error, ref reference.Named) error {\n\tswitch v := err.(type) {\n\tcase errcode.Errors:\n\t\tif len(v) != 0 {\n\t\t\tfor _, extra := range v[1:] {\n\t\t\t\tlogrus.Infof(\"Ignoring extra error returned from registry: %v\", extra)\n\t\t\t}\n\t\t\treturn TranslatePullError(v[0], ref)\n\t\t}\n\tcase errcode.Error:\n\t\tswitch v.Code {\n\t\tcase errcode.ErrorCodeDenied, v2.ErrorCodeManifestUnknown, v2.ErrorCodeNameUnknown:\n\t\t\treturn notFoundError{v, ref}\n\t\t}\n\tcase xfer.DoNotRetry:\n\t\treturn TranslatePullError(v.Err, ref)\n\t}\n\n\treturn errdefs.Unknown(err)\n}", "category": "Python"}, {"instruction": "// Run is used to run a watch plan", "input": "go language", "output": "func (p *Plan) RunWithConfig(address string, conf *consulapi.Config) error {\n\t// Setup the client\n\tp.address = address\n\tif conf == nil {\n\t\tconf = consulapi.DefaultConfig()\n\t}\n\tconf.Address = address\n\tconf.Datacenter = p.Datacenter\n\tconf.Token = p.Token\n\tclient, err := consulapi.NewClient(conf)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to connect to agent: %v\", err)\n\t}\n\n\t// Create the logger\n\toutput := p.LogOutput\n\tif output == nil {\n\t\toutput = os.Stderr\n\t}\n\tlogger := log.New(output, \"\", log.LstdFlags)\n\n\treturn p.RunWithClientAndLogger(client, logger)\n}", "category": "Python"}, {"instruction": "// Stream opens a protocol streamer to the server and streams until a client closes\n// the connection or the server disconnects.", "input": "go language", "output": "func (e *streamExecutor) Stream(options StreamOptions) error {\n\treq, err := http.NewRequest(e.method, e.url.String(), nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating request: %v\", err)\n\t}\n\n\tconn, protocol, err := spdy.Negotiate(\n\t\te.upgrader,\n\t\t&http.Client{Transport: e.transport},\n\t\treq,\n\t\te.protocols...,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tvar streamer streamProtocolHandler\n\n\tswitch protocol {\n\tcase remotecommand.StreamProtocolV4Name:\n\t\tstreamer = newStreamProtocolV4(options)\n\tcase remotecommand.StreamProtocolV3Name:\n\t\tstreamer = newStreamProtocolV3(options)\n\tcase remotecommand.StreamProtocolV2Name:\n\t\tstreamer = newStreamProtocolV2(options)\n\tcase \"\":\n\t\tklog.V(4).Infof(\"The server did not negotiate a streaming protocol version. Falling back to %s\", remotecommand.StreamProtocolV1Name)\n\t\tfallthrough\n\tcase remotecommand.StreamProtocolV1Name:\n\t\tstreamer = newStreamProtocolV1(options)\n\t}\n\n\treturn streamer.stream(conn)\n}", "category": "Python"}, {"instruction": "// NodeAddressesByProviderID will not be called from the node that is requesting this ID.\n// i.e. metadata service and other local methods cannot be used here", "input": "go language", "output": "func (g *Cloud) NodeAddressesByProviderID(ctx context.Context, providerID string) ([]v1.NodeAddress, error) {\n\tctx, cancel := cloud.ContextWithCallTimeout()\n\tdefer cancel()\n\n\t_, zone, name, err := splitProviderID(providerID)\n\tif err != nil {\n\t\treturn []v1.NodeAddress{}, err\n\t}\n\n\tinstance, err := g.c.Instances().Get(ctx, meta.ZonalKey(canonicalizeInstanceName(name), zone))\n\tif err != nil {\n\t\treturn []v1.NodeAddress{}, fmt.Errorf(\"error while querying for providerID %q: %v\", providerID, err)\n\t}\n\n\tif len(instance.NetworkInterfaces) < 1 {\n\t\treturn []v1.NodeAddress{}, fmt.Errorf(\"could not find network interfaces for providerID %q\", providerID)\n\t}\n\tnetworkInterface := instance.NetworkInterfaces[0]\n\n\tnodeAddresses := []v1.NodeAddress{{Type: v1.NodeInternalIP, Address: networkInterface.NetworkIP}}\n\tfor _, config := range networkInterface.AccessConfigs {\n\t\tnodeAddresses = append(nodeAddresses, v1.NodeAddress{Type: v1.NodeExternalIP, Address: config.NatIP})\n\t}\n\n\treturn nodeAddresses, nil\n}", "category": "Python"}, {"instruction": "// Commit writes the block and state of a genesis specification to the database.\n// The block is committed as the canonical head block.", "input": "go language", "output": "func (g *Genesis) Commit(db ethdb.Database) (*types.Block, error) {\n\tblock := g.ToBlock(db)\n\tif block.Number().Sign() != 0 {\n\t\treturn nil, fmt.Errorf(\"can't commit genesis block with number > 0\")\n\t}\n\trawdb.WriteTd(db, block.Hash(), block.NumberU64(), g.Difficulty)\n\trawdb.WriteBlock(db, block)\n\trawdb.WriteReceipts(db, block.Hash(), block.NumberU64(), nil)\n\trawdb.WriteCanonicalHash(db, block.Hash(), block.NumberU64())\n\trawdb.WriteHeadBlockHash(db, block.Hash())\n\trawdb.WriteHeadHeaderHash(db, block.Hash())\n\n\tconfig := g.Config\n\tif config == nil {\n\t\tconfig = params.AllEthashProtocolChanges\n\t}\n\trawdb.WriteChainConfig(db, block.Hash(), config)\n\treturn block, nil\n}", "category": "Python"}, {"instruction": "// ShutdownTimeout returns the timeout (in seconds) before containers are forcibly\n// killed during shutdown. The default timeout can be configured both on the daemon\n// and per container, and the longest timeout will be used. A grace-period of\n// 5 seconds is added to the configured timeout.\n//\n// A negative (-1) timeout means \"indefinitely\", which means that containers\n// are not forcibly killed, and the daemon shuts down after all containers exit.", "input": "go language", "output": "func (daemon *Daemon) ShutdownTimeout() int {\n\tshutdownTimeout := daemon.configStore.ShutdownTimeout\n\tif shutdownTimeout < 0 {\n\t\treturn -1\n\t}\n\tif daemon.containers == nil {\n\t\treturn shutdownTimeout\n\t}\n\n\tgraceTimeout := 5\n\tfor _, c := range daemon.containers.List() {\n\t\tstopTimeout := c.StopTimeout()\n\t\tif stopTimeout < 0 {\n\t\t\treturn -1\n\t\t}\n\t\tif stopTimeout+graceTimeout > shutdownTimeout {\n\t\t\tshutdownTimeout = stopTimeout + graceTimeout\n\t\t}\n\t}\n\treturn shutdownTimeout\n}", "category": "Python"}, {"instruction": "// getAffinityTermProperties receives a Pod and affinity terms and returns the namespaces and\n// selectors of the terms.", "input": "go language", "output": "func getAffinityTermProperties(pod *v1.Pod, terms []v1.PodAffinityTerm) (properties []*affinityTermProperties, err error) {\n\tif terms == nil {\n\t\treturn properties, nil\n\t}\n\n\tfor _, term := range terms {\n\t\tnamespaces := priorityutil.GetNamespacesFromPodAffinityTerm(pod, &term)\n\t\tselector, err := metav1.LabelSelectorAsSelector(term.LabelSelector)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tproperties = append(properties, &affinityTermProperties{namespaces: namespaces, selector: selector})\n\t}\n\treturn properties, nil\n}", "category": "Python"}, {"instruction": "// Parses awslogs-multiline-pattern and awslogs-datetime-format options\n// If awslogs-datetime-format is present, convert the format from strftime\n// to regexp and return.\n// If awslogs-multiline-pattern is present, compile regexp and return", "input": "go language", "output": "func parseMultilineOptions(info logger.Info) (*regexp.Regexp, error) {\n\tdateTimeFormat := info.Config[datetimeFormatKey]\n\tmultilinePatternKey := info.Config[multilinePatternKey]\n\t// strftime input is parsed into a regular expression\n\tif dateTimeFormat != \"\" {\n\t\t// %. matches each strftime format sequence and ReplaceAllStringFunc\n\t\t// looks up each format sequence in the conversion table strftimeToRegex\n\t\t// to replace with a defined regular expression\n\t\tr := regexp.MustCompile(\"%.\")\n\t\tmultilinePatternKey = r.ReplaceAllStringFunc(dateTimeFormat, func(s string) string {\n\t\t\treturn strftimeToRegex[s]\n\t\t})\n\t}\n\tif multilinePatternKey != \"\" {\n\t\tmultilinePattern, err := regexp.Compile(multilinePatternKey)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"awslogs could not parse multiline pattern key %q\", multilinePatternKey)\n\t\t}\n\t\treturn multilinePattern, nil\n\t}\n\treturn nil, nil\n}", "category": "Python"}, {"instruction": "// parseWhereArgs parses the end arguments to the where function.  Return a\n// match value and an operator, if one is defined.", "input": "go language", "output": "func parseWhereArgs(args ...interface{}) (mv reflect.Value, op string, err error) {\n\tswitch len(args) {\n\tcase 1:\n\t\tmv = reflect.ValueOf(args[0])\n\tcase 2:\n\t\tvar ok bool\n\t\tif op, ok = args[0].(string); !ok {\n\t\t\terr = errors.New(\"operator argument must be string type\")\n\t\t\treturn\n\t\t}\n\t\top = strings.TrimSpace(strings.ToLower(op))\n\t\tmv = reflect.ValueOf(args[1])\n\tdefault:\n\t\terr = errors.New(\"can't evaluate the array by no match argument or more than or equal to two arguments\")\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// setClaimProvisioner saves\n// claim.Annotations[annStorageProvisioner] = class.Provisioner", "input": "go language", "output": "func (ctrl *PersistentVolumeController) setClaimProvisioner(claim *v1.PersistentVolumeClaim, provisionerName string) (*v1.PersistentVolumeClaim, error) {\n\tif val, ok := claim.Annotations[annStorageProvisioner]; ok && val == provisionerName {\n\t\t// annotation is already set, nothing to do\n\t\treturn claim, nil\n\t}\n\n\t// The volume from method args can be pointing to watcher cache. We must not\n\t// modify these, therefore create a copy.\n\tclaimClone := claim.DeepCopy()\n\tmetav1.SetMetaDataAnnotation(&claimClone.ObjectMeta, annStorageProvisioner, provisionerName)\n\tnewClaim, err := ctrl.kubeClient.CoreV1().PersistentVolumeClaims(claim.Namespace).Update(claimClone)\n\tif err != nil {\n\t\treturn newClaim, err\n\t}\n\t_, err = ctrl.storeClaimUpdate(newClaim)\n\tif err != nil {\n\t\treturn newClaim, err\n\t}\n\treturn newClaim, nil\n}", "category": "Python"}, {"instruction": "// itemChanged returns true if the given disk file differs from the information\n// in the database and schedules that file for scanning", "input": "go language", "output": "func (f *sendReceiveFolder) itemChanged(stat fs.FileInfo, item protocol.FileInfo, hasItem bool, scanChan chan<- string) (changed bool, err error) {\n\tdefer func() {\n\t\tif changed {\n\t\t\tscanChan <- item.Name\n\t\t}\n\t}()\n\n\tif !hasItem || item.Deleted {\n\t\t// The item appeared from nowhere\n\t\treturn true, nil\n\t}\n\n\t// Check that the item on disk is what we expect it to be according\n\t// to the database. If there's a mismatch here, there might be local\n\t// changes that we don't know about yet and we should scan before\n\t// touching the item.\n\tstatItem, err := scanner.CreateFileInfo(stat, item.Name, f.fs)\n\tif err != nil {\n\t\treturn false, errors.Wrap(err, \"comparing item on disk to db\")\n\t}\n\n\treturn !statItem.IsEquivalentOptional(item, f.IgnorePerms, true, protocol.LocalAllFlags), nil\n}", "category": "Python"}, {"instruction": "// GraphNodeEvalable", "input": "go language", "output": "func (n *NodePlannableResourceInstance) EvalTree() EvalNode {\n\taddr := n.ResourceInstanceAddr()\n\n\t// State still uses legacy-style internal ids, so we need to shim to get\n\t// a suitable key to use.\n\tstateId := NewLegacyResourceInstanceAddress(addr).stateId()\n\n\t// Determine the dependencies for the state.\n\tstateDeps := n.StateReferences()\n\n\t// Eval info is different depending on what kind of resource this is\n\tswitch addr.Resource.Resource.Mode {\n\tcase addrs.ManagedResourceMode:\n\t\treturn n.evalTreeManagedResource(addr, stateId, stateDeps)\n\tcase addrs.DataResourceMode:\n\t\treturn n.evalTreeDataResource(addr, stateId, stateDeps)\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unsupported resource mode %s\", n.Config.Mode))\n\t}\n}", "category": "Python"}, {"instruction": "// getAllReplicaSetsAndSyncRevision returns all the replica sets for the provided deployment (new and all old), with new RS's and deployment's revision updated.\n//\n// rsList should come from getReplicaSetsForDeployment(d).\n//\n// 1. Get all old RSes this deployment targets, and calculate the max revision number among them (maxOldV).\n// 2. Get new RS this deployment targets (whose pod template matches deployment's), and update new RS's revision number to (maxOldV + 1),\n//    only if its revision number is smaller than (maxOldV + 1). If this step failed, we'll update it in the next deployment sync loop.\n// 3. Copy new RS's revision number to deployment (update deployment's revision). If this step failed, we'll update it in the next deployment sync loop.\n//\n// Note that currently the deployment controller is using caches to avoid querying the server for reads.\n// This may lead to stale reads of replica sets, thus incorrect deployment status.", "input": "go language", "output": "func (dc *DeploymentController) getAllReplicaSetsAndSyncRevision(d *apps.Deployment, rsList []*apps.ReplicaSet, createIfNotExisted bool) (*apps.ReplicaSet, []*apps.ReplicaSet, error) {\n\t_, allOldRSs := deploymentutil.FindOldReplicaSets(d, rsList)\n\n\t// Get new replica set with the updated revision number\n\tnewRS, err := dc.getNewReplicaSet(d, rsList, allOldRSs, createIfNotExisted)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn newRS, allOldRSs, nil\n}", "category": "Python"}, {"instruction": "// AddInstancesToTargetPool adds instances by link to the TargetPool", "input": "go language", "output": "func (g *Cloud) AddInstancesToTargetPool(name, region string, instanceRefs []*compute.InstanceReference) error {\n\tctx, cancel := cloud.ContextWithCallTimeout()\n\tdefer cancel()\n\n\treq := &compute.TargetPoolsAddInstanceRequest{\n\t\tInstances: instanceRefs,\n\t}\n\tmc := newTargetPoolMetricContext(\"add_instances\", region)\n\treturn mc.Observe(g.c.TargetPools().AddInstance(ctx, meta.RegionalKey(name, region), req))\n}", "category": "Python"}, {"instruction": "// DecodeObjectManagedFields extracts and converts the objects ManagedFields into a fieldpath.ManagedFields.", "input": "go language", "output": "func DecodeObjectManagedFields(from runtime.Object) (fieldpath.ManagedFields, error) {\n\tif from == nil {\n\t\treturn make(map[string]*fieldpath.VersionedSet), nil\n\t}\n\taccessor, err := meta.Accessor(from)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"couldn't get accessor: %v\", err))\n\t}\n\n\tmanaged, err := decodeManagedFields(accessor.GetManagedFields())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to convert managed fields from API: %v\", err)\n\t}\n\treturn managed, err\n}", "category": "Python"}, {"instruction": "// UpdateAttachment notifies the attacher about the attachment config.", "input": "go language", "output": "func (daemon *Daemon) UpdateAttachment(networkName, networkID, containerID string, config *network.NetworkingConfig) error {\n\tif daemon.clusterProvider == nil {\n\t\treturn fmt.Errorf(\"cluster provider is not initialized\")\n\t}\n\n\tif err := daemon.clusterProvider.UpdateAttachment(networkName, containerID, config); err != nil {\n\t\treturn daemon.clusterProvider.UpdateAttachment(networkID, containerID, config)\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// getGroupVersionKind returns the GroupVersionKind of the object", "input": "go language", "output": "func getGroupVersionKind(config map[string]interface{}) (schema.GroupVersionKind, error) {\n\tgvk := schema.GroupVersionKind{}\n\tif gv, found := config[\"apiVersion\"]; found {\n\t\tcasted, ok := gv.(string)\n\t\tif !ok {\n\t\t\treturn gvk, fmt.Errorf(\"Expected string for apiVersion, found %T\", gv)\n\t\t}\n\t\ts := strings.Split(casted, \"/\")\n\t\tif len(s) != 1 {\n\t\t\tgvk.Group = s[0]\n\t\t}\n\t\tgvk.Version = s[len(s)-1]\n\t} else {\n\t\treturn gvk, fmt.Errorf(\"Missing apiVersion in Kind %v\", config)\n\t}\n\tif k, found := config[\"kind\"]; found {\n\t\tcasted, ok := k.(string)\n\t\tif !ok {\n\t\t\treturn gvk, fmt.Errorf(\"Expected string for kind, found %T\", k)\n\t\t}\n\t\tgvk.Kind = casted\n\t} else {\n\t\treturn gvk, fmt.Errorf(\"Missing kind in Kind %v\", config)\n\t}\n\treturn gvk, nil\n}", "category": "Python"}, {"instruction": "// ensureHomeIfIAmStatic ensure $HOME to be set if dockerversion.IAmStatic is \"true\".\n// See issue #29344: gcplogs segfaults (static binary)\n// If HOME is not set, logging.NewClient() will call os/user.Current() via oauth2/google.\n// However, in static binary, os/user.Current() leads to segfault due to a glibc issue that won't be fixed\n// in a short term. (golang/go#13470, https://sourceware.org/bugzilla/show_bug.cgi?id=19341)\n// So we forcibly set HOME so as to avoid call to os/user/Current()", "input": "go language", "output": "func ensureHomeIfIAmStatic() error {\n\t// Note: dockerversion.IAmStatic and homedir.GetStatic() is only available for linux.\n\t// So we need to use them in this gcplogging_linux.go rather than in gcplogging.go\n\tif dockerversion.IAmStatic == \"true\" && os.Getenv(\"HOME\") == \"\" {\n\t\thome, err := homedir.GetStatic()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlogrus.Warnf(\"gcplogs requires HOME to be set for static daemon binary. Forcibly setting HOME to %s.\", home)\n\t\tos.Setenv(\"HOME\", home)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Status returns the status of the runtime.", "input": "go language", "output": "func (r *RemoteRuntimeService) Status() (*runtimeapi.RuntimeStatus, error) {\n\tctx, cancel := getContextWithTimeout(r.timeout)\n\tdefer cancel()\n\n\tresp, err := r.runtimeClient.Status(ctx, &runtimeapi.StatusRequest{})\n\tif err != nil {\n\t\tklog.Errorf(\"Status from runtime service failed: %v\", err)\n\t\treturn nil, err\n\t}\n\n\tif resp.Status == nil || len(resp.Status.Conditions) < 2 {\n\t\terrorMessage := \"RuntimeReady or NetworkReady condition are not set\"\n\t\tklog.Errorf(\"Status failed: %s\", errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn resp.Status, nil\n}", "category": "Python"}, {"instruction": "// Less compares two values in a byTimestamp slice by Timestamp.  Less is\n// required by the sort.Interface interface.", "input": "go language", "output": "func (slice byTimestamp) Less(i, j int) bool {\n\tiTimestamp, jTimestamp := int64(0), int64(0)\n\tif slice != nil && slice[i].inputLogEvent.Timestamp != nil {\n\t\tiTimestamp = *slice[i].inputLogEvent.Timestamp\n\t}\n\tif slice != nil && slice[j].inputLogEvent.Timestamp != nil {\n\t\tjTimestamp = *slice[j].inputLogEvent.Timestamp\n\t}\n\tif iTimestamp == jTimestamp {\n\t\treturn slice[i].insertOrder < slice[j].insertOrder\n\t}\n\treturn iTimestamp < jTimestamp\n}", "category": "Python"}, {"instruction": "// Matches matches path against all the patterns. Matches is not safe to be\n// called concurrently", "input": "go language", "output": "func (pm *PatternMatcher) Matches(file string) (bool, error) {\n\tmatched := false\n\tfile = filepath.FromSlash(file)\n\tparentPath := filepath.Dir(file)\n\tparentPathDirs := strings.Split(parentPath, string(os.PathSeparator))\n\n\tfor _, pattern := range pm.patterns {\n\t\tnegative := false\n\n\t\tif pattern.exclusion {\n\t\t\tnegative = true\n\t\t}\n\n\t\tmatch, err := pattern.match(file)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tif !match && parentPath != \".\" {\n\t\t\t// Check to see if the pattern matches one of our parent dirs.\n\t\t\tif len(pattern.dirs) <= len(parentPathDirs) {\n\t\t\t\tmatch, _ = pattern.match(strings.Join(parentPathDirs[:len(pattern.dirs)], string(os.PathSeparator)))\n\t\t\t}\n\t\t}\n\n\t\tif match {\n\t\t\tmatched = !negative\n\t\t}\n\t}\n\n\tif matched {\n\t\tlogrus.Debugf(\"Skipping excluded path: %s\", file)\n\t}\n\n\treturn matched, nil\n}", "category": "Python"}, {"instruction": "// updateAllocatedDevices gets a list of active pods and then frees any Devices that are bound to\n// terminated pods. Returns error on failure.", "input": "go language", "output": "func (m *ManagerImpl) updateAllocatedDevices(activePods []*v1.Pod) {\n\tif !m.sourcesReady.AllReady() {\n\t\treturn\n\t}\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\tactivePodUids := sets.NewString()\n\tfor _, pod := range activePods {\n\t\tactivePodUids.Insert(string(pod.UID))\n\t}\n\tallocatedPodUids := m.podDevices.pods()\n\tpodsToBeRemoved := allocatedPodUids.Difference(activePodUids)\n\tif len(podsToBeRemoved) <= 0 {\n\t\treturn\n\t}\n\tklog.V(3).Infof(\"pods to be removed: %v\", podsToBeRemoved.List())\n\tm.podDevices.delete(podsToBeRemoved.List())\n\t// Regenerated allocatedDevices after we update pod allocation information.\n\tm.allocatedDevices = m.podDevices.devices()\n}", "category": "Python"}, {"instruction": "// serveChunkExplorer starts an http server in background with chunk explorer handler\n// using the provided global store. Server is started if the returned shutdown function\n// is not nil.", "input": "go language", "output": "func serveChunkExplorer(ctx *cli.Context, globalStore mock.GlobalStorer) (shutdown func(), err error) {\n\tif !ctx.IsSet(\"explorer-address\") {\n\t\treturn nil, nil\n\t}\n\n\tcorsOrigins := ctx.StringSlice(\"explorer-cors-origin\")\n\tserver := &http.Server{\n\t\tHandler:      explorer.NewHandler(globalStore, corsOrigins),\n\t\tIdleTimeout:  30 * time.Minute,\n\t\tReadTimeout:  2 * time.Minute,\n\t\tWriteTimeout: 2 * time.Minute,\n\t}\n\tlistener, err := net.Listen(\"tcp\", ctx.String(\"explorer-address\"))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"explorer: %v\", err)\n\t}\n\tlog.Info(\"chunk explorer http\", \"address\", listener.Addr().String(), \"origins\", corsOrigins)\n\n\tgo func() {\n\t\tif err := server.Serve(listener); err != nil {\n\t\t\tlog.Error(\"chunk explorer\", \"err\", err)\n\t\t}\n\t}()\n\n\treturn func() {\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\tif err := server.Shutdown(ctx); err != nil {\n\t\t\tlog.Error(\"chunk explorer: shutdown\", \"err\", err)\n\t\t}\n\t}, nil\n}", "category": "Python"}, {"instruction": "// mergeDNSOptions merges DNS options. If duplicated, entries given by PodDNSConfigOption will\n// overwrite the existing ones.", "input": "go language", "output": "func mergeDNSOptions(existingDNSConfigOptions []string, dnsConfigOptions []v1.PodDNSConfigOption) []string {\n\toptionsMap := make(map[string]string)\n\tfor _, op := range existingDNSConfigOptions {\n\t\tif index := strings.Index(op, \":\"); index != -1 {\n\t\t\toptionsMap[op[:index]] = op[index+1:]\n\t\t} else {\n\t\t\toptionsMap[op] = \"\"\n\t\t}\n\t}\n\tfor _, op := range dnsConfigOptions {\n\t\tif op.Value != nil {\n\t\t\toptionsMap[op.Name] = *op.Value\n\t\t} else {\n\t\t\toptionsMap[op.Name] = \"\"\n\t\t}\n\t}\n\t// Reconvert DNS options into a string array.\n\toptions := []string{}\n\tfor opName, opValue := range optionsMap {\n\t\top := opName\n\t\tif opValue != \"\" {\n\t\t\top = op + \":\" + opValue\n\t\t}\n\t\toptions = append(options, op)\n\t}\n\treturn options\n}", "category": "Python"}, {"instruction": "// CAProviderState is used to get the Consul CA provider state for the given ID.", "input": "go language", "output": "func (s *Store) CAProviderState(id string) (uint64, *structs.CAConsulProviderState, error) {\n\ttx := s.db.Txn(false)\n\tdefer tx.Abort()\n\n\t// Get the index\n\tidx := maxIndexTxn(tx, caBuiltinProviderTableName)\n\n\t// Get the provider config\n\tc, err := tx.First(caBuiltinProviderTableName, \"id\", id)\n\tif err != nil {\n\t\treturn 0, nil, fmt.Errorf(\"failed built-in CA state lookup: %s\", err)\n\t}\n\n\tstate, ok := c.(*structs.CAConsulProviderState)\n\tif !ok {\n\t\treturn 0, nil, nil\n\t}\n\n\treturn idx, state, nil\n}", "category": "Python"}, {"instruction": "// getContext returns the clientcmdapi.Context, or an error if a required context is not found.", "input": "go language", "output": "func (config *DirectClientConfig) getContext() (clientcmdapi.Context, error) {\n\tcontexts := config.config.Contexts\n\tcontextName, required := config.getContextName()\n\n\tmergedContext := clientcmdapi.NewContext()\n\tif configContext, exists := contexts[contextName]; exists {\n\t\tmergo.MergeWithOverwrite(mergedContext, configContext)\n\t} else if required {\n\t\treturn clientcmdapi.Context{}, fmt.Errorf(\"context %q does not exist\", contextName)\n\t}\n\tmergo.MergeWithOverwrite(mergedContext, config.overrides.Context)\n\n\treturn *mergedContext, nil\n}", "category": "Python"}, {"instruction": "// The LB needs to be configured with instance addresses on the same\n// subnet as the LB (aka opts.SubnetID).  Currently we're just\n// guessing that the node's InternalIP is the right address.\n// In case no InternalIP can be found, ExternalIP is tried.\n// If neither InternalIP nor ExternalIP can be found an error is\n// returned.", "input": "go language", "output": "func nodeAddressForLB(node *v1.Node) (string, error) {\n\taddrs := node.Status.Addresses\n\tif len(addrs) == 0 {\n\t\treturn \"\", ErrNoAddressFound\n\t}\n\n\tallowedAddrTypes := []v1.NodeAddressType{v1.NodeInternalIP, v1.NodeExternalIP}\n\n\tfor _, allowedAddrType := range allowedAddrTypes {\n\t\tfor _, addr := range addrs {\n\t\t\tif addr.Type == allowedAddrType {\n\t\t\t\treturn addr.Address, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", ErrNoAddressFound\n}", "category": "Python"}, {"instruction": "// parseRSAPrivateKey parses a single RSA private key from the provided data", "input": "go language", "output": "func parseRSAPrivateKey(data []byte) (*rsa.PrivateKey, error) {\n\tvar err error\n\n\t// Parse the key\n\tvar parsedKey interface{}\n\tif parsedKey, err = x509.ParsePKCS1PrivateKey(data); err != nil {\n\t\tif parsedKey, err = x509.ParsePKCS8PrivateKey(data); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Test if parsed key is an RSA Private Key\n\tvar privKey *rsa.PrivateKey\n\tvar ok bool\n\tif privKey, ok = parsedKey.(*rsa.PrivateKey); !ok {\n\t\treturn nil, fmt.Errorf(\"data doesn't contain valid RSA Private Key\")\n\t}\n\n\treturn privKey, nil\n}", "category": "Python"}, {"instruction": "// DidDisconnect tracks the fact that the \"one\" node disconnected from the\n// \"other\" node", "input": "go language", "output": "func (net *Network) DidDisconnect(one, other enode.ID) error {\n\tnet.lock.Lock()\n\tdefer net.lock.Unlock()\n\tconn := net.getConn(one, other)\n\tif conn == nil {\n\t\treturn fmt.Errorf(\"connection between %v and %v does not exist\", one, other)\n\t}\n\tif !conn.Up {\n\t\treturn fmt.Errorf(\"%v and %v already disconnected\", one, other)\n\t}\n\tconn.Up = false\n\tconn.initiated = time.Now().Add(-DialBanTimeout)\n\tnet.events.Send(NewEvent(conn))\n\treturn nil\n}", "category": "Python"}, {"instruction": "// GetAllDDLJobsInQueue gets all DDL Jobs in the current queue.\n// The length of jobListKeys can only be 1 or 0.\n// If its length is 1, we need to replace m.jobListKey with jobListKeys[0].\n// Otherwise, we use m.jobListKey directly.", "input": "go language", "output": "func (m *Meta) GetAllDDLJobsInQueue(jobListKeys ...JobListKeyType) ([]*model.Job, error) {\n\tlistKey := m.jobListKey\n\tif len(jobListKeys) != 0 {\n\t\tlistKey = jobListKeys[0]\n\t}\n\n\tvalues, err := m.txn.LGetAll(listKey)\n\tif err != nil || values == nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tjobs := make([]*model.Job, 0, len(values))\n\tfor _, val := range values {\n\t\tjob := &model.Job{}\n\t\terr = job.Decode(val)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Trace(err)\n\t\t}\n\t\tjobs = append(jobs, job)\n\t}\n\n\treturn jobs, nil\n}", "category": "Python"}, {"instruction": "// CreateConfiguration creates a provider configuration from content using templating.", "input": "go language", "output": "func (p *Provider) CreateConfiguration(tmplContent string, funcMap template.FuncMap, templateObjects interface{}) (*config.Configuration, error) {\n\tvar defaultFuncMap = sprig.TxtFuncMap()\n\tdefaultFuncMap[\"normalize\"] = provider.Normalize\n\tdefaultFuncMap[\"split\"] = strings.Split\n\tfor funcID, funcElement := range funcMap {\n\t\tdefaultFuncMap[funcID] = funcElement\n\t}\n\n\ttmpl := template.New(p.Filename).Funcs(defaultFuncMap)\n\n\t_, err := tmpl.Parse(tmplContent)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar buffer bytes.Buffer\n\terr = tmpl.Execute(&buffer, templateObjects)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar renderedTemplate = buffer.String()\n\tif p.DebugLogGeneratedTemplate {\n\t\tlog.Debugf(\"Template content: %s\", tmplContent)\n\t\tlog.Debugf(\"Rendering results: %s\", renderedTemplate)\n\t}\n\treturn p.DecodeConfiguration(renderedTemplate)\n}", "category": "Python"}, {"instruction": "// Provide implements DockerConfigProvider", "input": "go language", "output": "func (g *containerRegistryProvider) Provide(image string) credentialprovider.DockerConfig {\n\tcfg := credentialprovider.DockerConfig{}\n\n\ttokenJsonBlob, err := credentialprovider.ReadUrl(metadataToken, g.Client, metadataHeader)\n\tif err != nil {\n\t\tklog.Errorf(\"while reading access token endpoint: %v\", err)\n\t\treturn cfg\n\t}\n\n\temail, err := credentialprovider.ReadUrl(metadataEmail, g.Client, metadataHeader)\n\tif err != nil {\n\t\tklog.Errorf(\"while reading email endpoint: %v\", err)\n\t\treturn cfg\n\t}\n\n\tvar parsedBlob tokenBlob\n\tif err := json.Unmarshal([]byte(tokenJsonBlob), &parsedBlob); err != nil {\n\t\tklog.Errorf(\"while parsing json blob %s: %v\", tokenJsonBlob, err)\n\t\treturn cfg\n\t}\n\n\tentry := credentialprovider.DockerConfigEntry{\n\t\tUsername: \"_token\",\n\t\tPassword: parsedBlob.AccessToken,\n\t\tEmail:    string(email),\n\t}\n\n\t// Add our entry for each of the supported container registry URLs\n\tfor _, k := range containerRegistryUrls {\n\t\tcfg[k] = entry\n\t}\n\treturn cfg\n}", "category": "Python"}, {"instruction": "// Returns a set of targeted nodes. A targeted node is either addressed\n// directly, address indirectly via its container, or it's a dependency of a\n// targeted node. Destroy mode keeps dependents instead of dependencies.", "input": "go language", "output": "func (t *TargetsTransformer) selectTargetedNodes(g *Graph, addrs []addrs.Targetable) (*dag.Set, error) {\n\ttargetedNodes := new(dag.Set)\n\n\tvertices := g.Vertices()\n\n\tfor _, v := range vertices {\n\t\tif t.nodeIsTarget(v, addrs) {\n\t\t\ttargetedNodes.Add(v)\n\n\t\t\t// We inform nodes that ask about the list of targets - helps for nodes\n\t\t\t// that need to dynamically expand. Note that this only occurs for nodes\n\t\t\t// that are already directly targeted.\n\t\t\tif tn, ok := v.(GraphNodeTargetable); ok {\n\t\t\t\ttn.SetTargets(addrs)\n\t\t\t}\n\n\t\t\tvar deps *dag.Set\n\t\t\tvar err error\n\t\t\tif t.Destroy {\n\t\t\t\tdeps, err = g.Descendents(v)\n\t\t\t} else {\n\t\t\t\tdeps, err = g.Ancestors(v)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tfor _, d := range deps.List() {\n\t\t\t\ttargetedNodes.Add(d)\n\t\t\t}\n\t\t}\n\t}\n\treturn t.addDependencies(targetedNodes, g)\n}", "category": "Python"}, {"instruction": "// removeTicket removes a ticket from the ticket store", "input": "go language", "output": "func (s *ticketStore) removeTicketRef(ref ticketRef) {\n\tlog.Trace(\"Removing discovery ticket reference\", \"node\", ref.t.node.ID, \"serial\", ref.t.serial)\n\n\t// Make nextRegisterableTicket return the next available ticket.\n\ts.nextTicketCached = nil\n\n\ttopic := ref.topic()\n\ttickets := s.tickets[topic]\n\n\tif tickets == nil {\n\t\tlog.Trace(\"Removing tickets from unknown topic\", \"topic\", topic)\n\t\treturn\n\t}\n\tbucket := timeBucket(ref.t.regTime[ref.idx] / mclock.AbsTime(ticketTimeBucketLen))\n\tlist := tickets.buckets[bucket]\n\tidx := -1\n\tfor i, bt := range list {\n\t\tif bt.t == ref.t {\n\t\t\tidx = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif idx == -1 {\n\t\tpanic(nil)\n\t}\n\tlist = append(list[:idx], list[idx+1:]...)\n\tif len(list) != 0 {\n\t\ttickets.buckets[bucket] = list\n\t} else {\n\t\tdelete(tickets.buckets, bucket)\n\t}\n\tref.t.refCnt--\n\tif ref.t.refCnt == 0 {\n\t\tdelete(s.nodes, ref.t.node)\n\t\tdelete(s.nodeLastReq, ref.t.node)\n\t}\n}", "category": "Python"}, {"instruction": "// HistoryViewerFor returns an implementation of HistoryViewer interface for the given schema kind", "input": "go language", "output": "func HistoryViewerFor(kind schema.GroupKind, c kubernetes.Interface) (HistoryViewer, error) {\n\telem := kapps.GroupKindElement(kind)\n\tvisitor := &HistoryVisitor{\n\t\tclientset: c,\n\t}\n\n\t// Determine which HistoryViewer we need here\n\terr := elem.Accept(visitor)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error retrieving history for %q, %v\", kind.String(), err)\n\t}\n\n\tif visitor.result == nil {\n\t\treturn nil, fmt.Errorf(\"no history viewer has been implemented for %q\", kind.String())\n\t}\n\n\treturn visitor.result, nil\n}", "category": "Python"}, {"instruction": "// AddFlags adds flags related to GarbageCollectorController for controller manager to the specified FlagSet.", "input": "go language", "output": "func (o *GarbageCollectorControllerOptions) AddFlags(fs *pflag.FlagSet) {\n\tif o == nil {\n\t\treturn\n\t}\n\n\tfs.Int32Var(&o.ConcurrentGCSyncs, \"concurrent-gc-syncs\", o.ConcurrentGCSyncs, \"The number of garbage collector workers that are allowed to sync concurrently.\")\n\tfs.BoolVar(&o.EnableGarbageCollector, \"enable-garbage-collector\", o.EnableGarbageCollector, \"Enables the generic garbage collector. MUST be synced with the corresponding flag of the kube-apiserver.\")\n}", "category": "Python"}, {"instruction": "// ExportChain exports a blockchain into the specified file, truncating any data\n// already present in the file.", "input": "go language", "output": "func ExportChain(blockchain *core.BlockChain, fn string) error {\n\tlog.Info(\"Exporting blockchain\", \"file\", fn)\n\n\t// Open the file handle and potentially wrap with a gzip stream\n\tfh, err := os.OpenFile(fn, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, os.ModePerm)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fh.Close()\n\n\tvar writer io.Writer = fh\n\tif strings.HasSuffix(fn, \".gz\") {\n\t\twriter = gzip.NewWriter(writer)\n\t\tdefer writer.(*gzip.Writer).Close()\n\t}\n\t// Iterate over the blocks and export them\n\tif err := blockchain.Export(writer); err != nil {\n\t\treturn err\n\t}\n\tlog.Info(\"Exported blockchain\", \"file\", fn)\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Gets Disk counts per storage account", "input": "go language", "output": "func (c *BlobDiskController) getDiskCount(SAName string) (int, error) {\n\t// if we have it in cache\n\tif c.accounts[SAName].diskCount != -1 {\n\t\treturn int(c.accounts[SAName].diskCount), nil\n\t}\n\n\tvar err error\n\tvar blobSvc azstorage.BlobStorageClient\n\n\tif err = c.ensureDefaultContainer(SAName); err != nil {\n\t\treturn 0, err\n\t}\n\n\tif blobSvc, err = c.getBlobSvcClient(SAName); err != nil {\n\t\treturn 0, err\n\t}\n\tparams := azstorage.ListBlobsParameters{}\n\n\tcontainer := blobSvc.GetContainerReference(vhdContainerName)\n\tresponse, err := container.ListBlobs(params)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tklog.V(4).Infof(\"azure-Disk -  refreshed data count for account %s and found %v\", SAName, len(response.Blobs))\n\tc.accounts[SAName].diskCount = int32(len(response.Blobs))\n\n\treturn int(c.accounts[SAName].diskCount), nil\n}", "category": "Python"}, {"instruction": "// MarshalJSON marshals type Criteria to a json string", "input": "go language", "output": "func (c Criteria) MarshalJSON() ([]byte, error) {\n\ttype Criteria struct {\n\t\tSymKeyID     string        `json:\"symKeyID\"`\n\t\tPrivateKeyID string        `json:\"privateKeyID\"`\n\t\tSig          hexutil.Bytes `json:\"sig\"`\n\t\tMinPow       float64       `json:\"minPow\"`\n\t\tTopics       []TopicType   `json:\"topics\"`\n\t\tAllowP2P     bool          `json:\"allowP2P\"`\n\t}\n\tvar enc Criteria\n\tenc.SymKeyID = c.SymKeyID\n\tenc.PrivateKeyID = c.PrivateKeyID\n\tenc.Sig = c.Sig\n\tenc.MinPow = c.MinPow\n\tenc.Topics = c.Topics\n\tenc.AllowP2P = c.AllowP2P\n\treturn json.Marshal(&enc)\n}", "category": "Python"}, {"instruction": "// SetupWorkingDirectory sets up the container's working directory as set in container.Config.WorkingDir", "input": "go language", "output": "func (container *Container) SetupWorkingDirectory(rootIdentity idtools.Identity) error {\n\t// TODO @jhowardmsft, @gupta-ak LCOW Support. This will need revisiting.\n\t// We will need to do remote filesystem operations here.\n\tif container.OS != runtime.GOOS {\n\t\treturn nil\n\t}\n\n\tif container.Config.WorkingDir == \"\" {\n\t\treturn nil\n\t}\n\n\tcontainer.Config.WorkingDir = filepath.Clean(container.Config.WorkingDir)\n\tpth, err := container.GetResourcePath(container.Config.WorkingDir)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := idtools.MkdirAllAndChownNew(pth, 0755, rootIdentity); err != nil {\n\t\tpthInfo, err2 := os.Stat(pth)\n\t\tif err2 == nil && pthInfo != nil && !pthInfo.IsDir() {\n\t\t\treturn errors.Errorf(\"Cannot mkdir: %s is not a directory\", container.Config.WorkingDir)\n\t\t}\n\n\t\treturn err\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// GetDDLJobs get all DDL jobs and sorts jobs by job.ID.", "input": "go language", "output": "func GetDDLJobs(txn kv.Transaction) ([]*model.Job, error) {\n\tt := meta.NewMeta(txn)\n\tgeneralJobs, err := getDDLJobsInQueue(t, meta.DefaultJobListKey)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\taddIdxJobs, err := getDDLJobsInQueue(t, meta.AddIndexJobListKey)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tjobs := append(generalJobs, addIdxJobs...)\n\tsort.Sort(jobArray(jobs))\n\treturn jobs, nil\n}", "category": "Python"}, {"instruction": "// NewAccessEntryACT creates a manifest AccessEntry in order to create an ACT protected by a combination of EC keys and passwords", "input": "go language", "output": "func NewAccessEntryACT(publisher string, salt []byte, act string) (*AccessEntry, error) {\n\tif len(salt) != 32 {\n\t\treturn nil, fmt.Errorf(\"salt should be 32 bytes long\")\n\t}\n\tif len(publisher) != 66 {\n\t\treturn nil, fmt.Errorf(\"publisher should be 66 characters long\")\n\t}\n\n\treturn &AccessEntry{\n\t\tType:      AccessTypeACT,\n\t\tPublisher: publisher,\n\t\tSalt:      salt,\n\t\tAct:       act,\n\t\tKdfParams: DefaultKdfParams,\n\t}, nil\n}", "category": "Python"}, {"instruction": "// validatePathNoBacksteps makes sure the targetPath does not have any `..` path elements when split\n//\n// This assumes the OS of the apiserver and the nodes are the same. The same check should be done\n// on the node to ensure there are no backsteps.", "input": "go language", "output": "func validatePathNoBacksteps(targetPath string, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tparts := strings.Split(filepath.ToSlash(targetPath), \"/\")\n\tfor _, item := range parts {\n\t\tif item == \"..\" {\n\t\t\tallErrs = append(allErrs, field.Invalid(fldPath, targetPath, \"must not contain '..'\"))\n\t\t\tbreak // even for `../../..`, one error is sufficient to make the point\n\t\t}\n\t}\n\treturn allErrs\n}", "category": "Python"}, {"instruction": "// WaitForClusterAvailable returns true if all endpoints in the cluster are available after retry attempts, an error is returned otherwise", "input": "go language", "output": "func (c *Client) WaitForClusterAvailable(retries int, retryInterval time.Duration) (bool, error) {\n\tfor i := 0; i < retries; i++ {\n\t\tif i > 0 {\n\t\t\tklog.V(1).Infof(\"[etcd] Waiting %v until next retry\\n\", retryInterval)\n\t\t\ttime.Sleep(retryInterval)\n\t\t}\n\t\tklog.V(2).Infof(\"[etcd] attempting to see if all cluster endpoints (%s) are available %d/%d\", c.Endpoints, i+1, retries)\n\t\tresp, err := c.ClusterAvailable()\n\t\tif err != nil {\n\t\t\tswitch err {\n\t\t\tcase context.DeadlineExceeded:\n\t\t\t\tklog.V(1).Infof(\"[etcd] Attempt timed out\")\n\t\t\tdefault:\n\t\t\t\tklog.V(1).Infof(\"[etcd] Attempt failed with error: %v\\n\", err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\treturn resp, nil\n\t}\n\treturn false, errors.New(\"timeout waiting for etcd cluster to be available\")\n}", "category": "Python"}, {"instruction": "// Read reads bytes from BytesPipe.\n// Data could be read only once.", "input": "go language", "output": "func (bp *BytesPipe) Read(p []byte) (n int, err error) {\n\tbp.mu.Lock()\n\tif bp.bufLen == 0 {\n\t\tif bp.closeErr != nil {\n\t\t\tbp.mu.Unlock()\n\t\t\treturn 0, bp.closeErr\n\t\t}\n\t\tbp.wait.Wait()\n\t\tif bp.bufLen == 0 && bp.closeErr != nil {\n\t\t\terr := bp.closeErr\n\t\t\tbp.mu.Unlock()\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\tfor bp.bufLen > 0 {\n\t\tb := bp.buf[0]\n\t\tread, _ := b.Read(p) // ignore error since fixedBuffer doesn't really return an error\n\t\tn += read\n\t\tbp.bufLen -= read\n\n\t\tif b.Len() == 0 {\n\t\t\t// it's empty so return it to the pool and move to the next one\n\t\t\treturnBuffer(b)\n\t\t\tbp.buf[0] = nil\n\t\t\tbp.buf = bp.buf[1:]\n\t\t}\n\n\t\tif len(p) == read {\n\t\t\tbreak\n\t\t}\n\n\t\tp = p[read:]\n\t}\n\n\tbp.wait.Broadcast()\n\tbp.mu.Unlock()\n\treturn\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *LocalEtcd) DeepCopyInto(out *LocalEtcd) {\n\t*out = *in\n\tout.ImageMeta = in.ImageMeta\n\tif in.ExtraArgs != nil {\n\t\tin, out := &in.ExtraArgs, &out.ExtraArgs\n\t\t*out = make(map[string]string, len(*in))\n\t\tfor key, val := range *in {\n\t\t\t(*out)[key] = val\n\t\t}\n\t}\n\tif in.ServerCertSANs != nil {\n\t\tin, out := &in.ServerCertSANs, &out.ServerCertSANs\n\t\t*out = make([]string, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\tif in.PeerCertSANs != nil {\n\t\tin, out := &in.PeerCertSANs, &out.PeerCertSANs\n\t\t*out = make([]string, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// Receive is called to deposit the latest cheque to the incoming Inbox.\n// The given promise must be a *Cheque.", "input": "go language", "output": "func (i *Inbox) Receive(promise swap.Promise) (*big.Int, error) {\n\tch := promise.(*Cheque)\n\n\tdefer i.lock.Unlock()\n\ti.lock.Lock()\n\n\tvar sum *big.Int\n\tif i.cheque == nil {\n\t\t// the sum is checked against the blockchain once a cheque is received\n\t\ttally, err := i.session.Sent(i.beneficiary)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"inbox: error calling backend to set amount: %v\", err)\n\t\t}\n\t\tsum = tally\n\t} else {\n\t\tsum = i.cheque.Amount\n\t}\n\n\tamount, err := ch.Verify(i.signer, i.contract, i.beneficiary, sum)\n\tvar uncashed *big.Int\n\tif err == nil {\n\t\ti.cheque = ch\n\n\t\tif i.maxUncashed != nil {\n\t\t\tuncashed = new(big.Int).Sub(ch.Amount, i.cashed)\n\t\t\tif i.maxUncashed.Cmp(uncashed) < 0 {\n\t\t\t\ti.Cash()\n\t\t\t}\n\t\t}\n\t\ti.log.Trace(\"Received cheque in chequebook inbox\", \"amount\", amount, \"uncashed\", uncashed)\n\t}\n\n\treturn amount, err\n}", "category": "Python"}, {"instruction": "// syncNamespaceFromKey looks for a namespace with the specified key in its store and synchronizes it", "input": "go language", "output": "func (nm *NamespaceController) syncNamespaceFromKey(key string) (err error) {\n\tstartTime := time.Now()\n\tdefer func() {\n\t\tklog.V(4).Infof(\"Finished syncing namespace %q (%v)\", key, time.Since(startTime))\n\t}()\n\n\tnamespace, err := nm.lister.Get(key)\n\tif errors.IsNotFound(err) {\n\t\tklog.Infof(\"Namespace has been deleted %v\", key)\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\tutilruntime.HandleError(fmt.Errorf(\"Unable to retrieve namespace %v from store: %v\", key, err))\n\t\treturn err\n\t}\n\treturn nm.namespacedResourcesDeleter.Delete(namespace.Name)\n}", "category": "Python"}, {"instruction": "// milliCPUToShares converts milliCPU to CPU shares", "input": "go language", "output": "func milliCPUToShares(milliCPU int64, hyperv bool) int64 {\n\tvar minShares int64 = minSharesProcess\n\tif hyperv {\n\t\tminShares = minSharesHyperV\n\t}\n\n\tif milliCPU == 0 {\n\t\t// Return here to really match kernel default for zero milliCPU.\n\t\treturn minShares\n\t}\n\n\t// Conceptually (milliCPU / milliCPUToCPU) * sharesPerCPU, but factored to improve rounding.\n\ttotalCPU := sysinfo.NumCPU()\n\tshares := (milliCPU * (maxShares - minShares)) / int64(totalCPU) / milliCPUToCPU\n\tif shares < minShares {\n\t\treturn minShares\n\t}\n\tif shares > maxShares {\n\t\treturn maxShares\n\t}\n\treturn shares\n}", "category": "Python"}, {"instruction": "// providerRequiresNetworkingConfiguration returns whether the cloud provider\n// requires special networking configuration.", "input": "go language", "output": "func (kl *Kubelet) providerRequiresNetworkingConfiguration() bool {\n\t// TODO: We should have a mechanism to say whether native cloud provider\n\t// is used or whether we are using overlay networking. We should return\n\t// true for cloud providers if they implement Routes() interface and\n\t// we are not using overlay networking.\n\tif kl.cloud == nil || kl.cloud.ProviderName() != \"gce\" {\n\t\treturn false\n\t}\n\t_, supported := kl.cloud.Routes()\n\treturn supported\n}", "category": "Python"}, {"instruction": "// NewIdentityMapper method, all we need is a reference to a MessageCryptoService", "input": "go language", "output": "func NewIdentityMapper(mcs api.MessageCryptoService, selfIdentity api.PeerIdentityType, onPurge purgeTrigger, sa api.SecurityAdvisor) Mapper {\n\tselfPKIID := mcs.GetPKIidOfCert(selfIdentity)\n\tidMapper := &identityMapperImpl{\n\t\tonPurge:    onPurge,\n\t\tmcs:        mcs,\n\t\tpkiID2Cert: make(map[string]*storedIdentity),\n\t\tstopChan:   make(chan struct{}),\n\t\tselfPKIID:  string(selfPKIID),\n\t\tsa:         sa,\n\t}\n\tif err := idMapper.Put(selfPKIID, selfIdentity); err != nil {\n\t\tpanic(errors.Wrap(err, \"Failed putting our own identity into the identity mapper\"))\n\t}\n\tgo idMapper.periodicalPurgeUnusedIdentities()\n\treturn idMapper\n}", "category": "Python"}, {"instruction": "// Update updates internal state of what has been downloaded into the temporary\n// files by the remote device for this specific folder.", "input": "go language", "output": "func (p *deviceFolderDownloadState) Update(updates []protocol.FileDownloadProgressUpdate) {\n\tp.mut.Lock()\n\tdefer p.mut.Unlock()\n\n\tfor _, update := range updates {\n\t\tlocal, ok := p.files[update.Name]\n\t\tif update.UpdateType == protocol.UpdateTypeForget && ok && local.version.Equal(update.Version) {\n\t\t\tdelete(p.files, update.Name)\n\t\t} else if update.UpdateType == protocol.UpdateTypeAppend {\n\t\t\tif !ok {\n\t\t\t\tlocal = deviceFolderFileDownloadState{\n\t\t\t\t\tblockIndexes: update.BlockIndexes,\n\t\t\t\t\tversion:      update.Version,\n\t\t\t\t}\n\t\t\t} else if !local.version.Equal(update.Version) {\n\t\t\t\tlocal.blockIndexes = append(local.blockIndexes[:0], update.BlockIndexes...)\n\t\t\t\tlocal.version = update.Version\n\t\t\t} else {\n\t\t\t\tlocal.blockIndexes = append(local.blockIndexes, update.BlockIndexes...)\n\t\t\t}\n\t\t\tp.files[update.Name] = local\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// New creates a new custom error pages middleware.", "input": "go language", "output": "func New(ctx context.Context, next http.Handler, config config.ErrorPage, serviceBuilder serviceBuilder, name string) (http.Handler, error) {\n\tmiddlewares.GetLogger(ctx, name, typeName).Debug(\"Creating middleware\")\n\n\thttpCodeRanges, err := types.NewHTTPCodeRanges(config.Status)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbackend, err := serviceBuilder.BuildHTTP(ctx, config.Service, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &customErrors{\n\t\tname:           name,\n\t\tnext:           next,\n\t\tbackendHandler: backend,\n\t\thttpCodeRanges: httpCodeRanges,\n\t\tbackendQuery:   config.Query,\n\t}, nil\n}", "category": "Python"}, {"instruction": "// pushRepository pushes layers that do not already exist on the registry.", "input": "go language", "output": "func (p *v1Pusher) pushRepository(ctx context.Context) error {\n\timgList, tags, referencedLayers, err := p.getImageList()\n\tdefer func() {\n\t\tfor _, l := range referencedLayers {\n\t\t\tl.Release()\n\t\t}\n\t}()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\timageIndex := createImageIndex(imgList, tags)\n\tfor _, data := range imageIndex {\n\t\tlogrus.Debugf(\"Pushing ID: %s with Tag: %s\", data.ID, data.Tag)\n\t}\n\n\t// Register all the images in a repository with the registry\n\t// If an image is not in this list it will not be associated with the repository\n\trepoData, err := p.session.PushImageJSONIndex(p.repoInfo.Name, imageIndex, false, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// push the repository to each of the endpoints only if it does not exist.\n\tfor _, endpoint := range repoData.Endpoints {\n\t\tif err := p.pushImageToEndpoint(ctx, endpoint, imgList, tags, repoData); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err = p.session.PushImageJSONIndex(p.repoInfo.Name, imageIndex, true, repoData.Endpoints)\n\treturn err\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *HorizontalPodAutoscalerSpec) DeepCopyInto(out *HorizontalPodAutoscalerSpec) {\n\t*out = *in\n\tout.ScaleTargetRef = in.ScaleTargetRef\n\tif in.MinReplicas != nil {\n\t\tin, out := &in.MinReplicas, &out.MinReplicas\n\t\t*out = new(int32)\n\t\t**out = **in\n\t}\n\tif in.Metrics != nil {\n\t\tin, out := &in.Metrics, &out.Metrics\n\t\t*out = make([]MetricSpec, len(*in))\n\t\tfor i := range *in {\n\t\t\t(*in)[i].DeepCopyInto(&(*out)[i])\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// Shutdown blocks until stopCh passed to the Run method is closed and all\n// events added prior to that moment are batched and sent to the delegate backend.", "input": "go language", "output": "func (b *bufferedBackend) Shutdown() {\n\t// Wait until the routine spawned in Run method exits.\n\t<-b.shutdownCh\n\n\t// Wait until all sending routines exit.\n\t//\n\t// - When b.shutdownCh is closed, we know that the goroutine in Run has terminated.\n\t// - This means that processIncomingEvents has terminated.\n\t// - Which means that b.buffer is closed and cannot accept any new events anymore.\n\t// - Because processEvents is called synchronously from the Run goroutine, the waitgroup has its final value.\n\t// Hence wg.Wait will not miss any more outgoing batches.\n\tb.wg.Wait()\n\n\tb.delegateBackend.Shutdown()\n}", "category": "Python"}, {"instruction": "// Build is used to build a specific AggFunc implementation according to the\n// input aggFuncDesc.", "input": "go language", "output": "func Build(ctx sessionctx.Context, aggFuncDesc *aggregation.AggFuncDesc, ordinal int) AggFunc {\n\tswitch aggFuncDesc.Name {\n\tcase ast.AggFuncCount:\n\t\treturn buildCount(aggFuncDesc, ordinal)\n\tcase ast.AggFuncSum:\n\t\treturn buildSum(aggFuncDesc, ordinal)\n\tcase ast.AggFuncAvg:\n\t\treturn buildAvg(aggFuncDesc, ordinal)\n\tcase ast.AggFuncFirstRow:\n\t\treturn buildFirstRow(aggFuncDesc, ordinal)\n\tcase ast.AggFuncMax:\n\t\treturn buildMaxMin(aggFuncDesc, ordinal, true)\n\tcase ast.AggFuncMin:\n\t\treturn buildMaxMin(aggFuncDesc, ordinal, false)\n\tcase ast.AggFuncGroupConcat:\n\t\treturn buildGroupConcat(ctx, aggFuncDesc, ordinal)\n\tcase ast.AggFuncBitOr:\n\t\treturn buildBitOr(aggFuncDesc, ordinal)\n\tcase ast.AggFuncBitXor:\n\t\treturn buildBitXor(aggFuncDesc, ordinal)\n\tcase ast.AggFuncBitAnd:\n\t\treturn buildBitAnd(aggFuncDesc, ordinal)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// <endpointsMap> is updated by this function (based on the given changes).\n// <changes> map is cleared after applying them.", "input": "go language", "output": "func (proxier *Proxier) updateEndpointsMap() (result updateEndpointMapResult) {\n\tresult.staleEndpoints = make(map[endpointServicePair]bool)\n\tresult.staleServiceNames = make(map[proxy.ServicePortName]bool)\n\n\tvar endpointsMap proxyEndpointsMap = proxier.endpointsMap\n\tvar changes *endpointsChangeMap = &proxier.endpointsChanges\n\n\tfunc() {\n\t\tchanges.lock.Lock()\n\t\tdefer changes.lock.Unlock()\n\t\tfor _, change := range changes.items {\n\t\t\tendpointsMap.unmerge(change.previous, proxier.serviceMap)\n\t\t\tendpointsMap.merge(change.current, proxier.serviceMap)\n\t\t}\n\t\tchanges.items = make(map[types.NamespacedName]*endpointsChange)\n\t}()\n\n\t// TODO: If this will appear to be computationally expensive, consider\n\t// computing this incrementally similarly to endpointsMap.\n\tresult.hcEndpoints = make(map[types.NamespacedName]int)\n\tlocalIPs := getLocalIPs(endpointsMap)\n\tfor nsn, ips := range localIPs {\n\t\tresult.hcEndpoints[nsn] = len(ips)\n\t}\n\n\treturn result\n}", "category": "Python"}, {"instruction": "// Next implements the Executor Next interface.", "input": "go language", "output": "func (e *RevokeExec) Next(ctx context.Context, req *chunk.RecordBatch) error {\n\tif e.done {\n\t\treturn nil\n\t}\n\te.done = true\n\n\t// Revoke for each user.\n\tfor _, user := range e.Users {\n\t\t// Check if user exists.\n\t\texists, err := userExists(e.ctx, user.User.Username, user.User.Hostname)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !exists {\n\t\t\treturn errors.Errorf(\"Unknown user: %s\", user.User)\n\t\t}\n\n\t\terr = e.revokeOneUser(user.User.Username, user.User.Hostname)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tdomain.GetDomain(e.ctx).NotifyUpdatePrivilege(e.ctx)\n\treturn nil\n}", "category": "Python"}, {"instruction": "// BeforeSign is added to the Sign chain; called before each request", "input": "go language", "output": "func (c *CrossRequestRetryDelay) BeforeSign(r *request.Request) {\n\tnow := time.Now()\n\tdelay := c.backoff.ComputeDelayForRequest(now)\n\tif delay > 0 {\n\t\tklog.Warningf(\"Inserting delay before AWS request (%s) to avoid RequestLimitExceeded: %s\",\n\t\t\tdescribeRequest(r), delay.String())\n\n\t\tif sleepFn := r.Config.SleepDelay; sleepFn != nil {\n\t\t\t// Support SleepDelay for backwards compatibility\n\t\t\tsleepFn(delay)\n\t\t} else if err := aws.SleepWithContext(r.Context(), delay); err != nil {\n\t\t\tr.Error = awserr.New(request.CanceledErrorCode, \"request context canceled\", err)\n\t\t\tr.Retryable = aws.Bool(false)\n\t\t\treturn\n\t\t}\n\n\t\t// Avoid clock skew problems\n\t\tr.Time = now\n\t}\n}", "category": "Python"}, {"instruction": "// Endorsers provides a mock function with given fields: invocationChain, f", "input": "go language", "output": "func (_m *ChannelResponse) Endorsers(invocationChain client.InvocationChain, f client.Filter) (client.Endorsers, error) {\n\tret := _m.Called(invocationChain, f)\n\n\tvar r0 client.Endorsers\n\tif rf, ok := ret.Get(0).(func(client.InvocationChain, client.Filter) client.Endorsers); ok {\n\t\tr0 = rf(invocationChain, f)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(client.Endorsers)\n\t\t}\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(client.InvocationChain, client.Filter) error); ok {\n\t\tr1 = rf(invocationChain, f)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}", "category": "Python"}, {"instruction": "// makeListenerFromUserConfig returns the listener config decoded from an\n// arbitrary proto3 json format string or an error if it's invalid.\n//\n// For now we only support embedding in JSON strings because of the hcl parsing\n// pain (see config.go comment above call to patchSliceOfMaps). Until we\n// refactor config parser a _lot_ user's opaque config that contains arrays will\n// be mangled. We could actually fix that up in mapstructure which knows the\n// type of the target so could resolve the slices to singletons unambiguously\n// and it would work for us here... but we still have the problem that the\n// config would render incorrectly in general in our HTTP API responses so we\n// really need to fix it \"properly\".\n//\n// When we do that we can support just nesting the config directly into the\n// JSON/hcl naturally but this is a stop-gap that gets us an escape hatch\n// immediately. It's also probably not a bad thing to support long-term since\n// any config generated by other systems will likely be in canonical protobuf\n// from rather than our slight variant in JSON/hcl.", "input": "go language", "output": "func makeListenerFromUserConfig(configJSON string) (*envoy.Listener, error) {\n\t// Figure out if there is an @type field. We don't require is since we know\n\t// this will be a listener but unmarshalling into types.Any fails if it's not\n\t// there and unmarshalling into listener directly fails if it is...\n\tvar jsonFields map[string]*json.RawMessage\n\tif err := json.Unmarshal([]byte(configJSON), &jsonFields); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar l envoy.Listener\n\n\tif _, ok := jsonFields[\"@type\"]; ok {\n\t\t// Type field is present so decode it as a types.Any\n\t\tvar any types.Any\n\t\terr := jsonpb.UnmarshalString(configJSON, &any)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// And then unmarshal the listener again...\n\t\terr = proto.Unmarshal(any.Value, &l)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &l, err\n\t}\n\n\t// No @type so try decoding as a straight listener.\n\terr := jsonpb.UnmarshalString(configJSON, &l)\n\treturn &l, err\n}", "category": "Python"}, {"instruction": "// processTTL checks whether a given Job's TTL has expired, and add it to the queue after the TTL is expected to expire\n// if the TTL will expire later.", "input": "go language", "output": "func (tc *Controller) processTTL(job *batch.Job) (expired bool, err error) {\n\t// We don't care about the Jobs that are going to be deleted, or the ones that don't need clean up.\n\tif job.DeletionTimestamp != nil || !needsCleanup(job) {\n\t\treturn false, nil\n\t}\n\n\tnow := tc.clock.Now()\n\tt, err := timeLeft(job, &now)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\t// TTL has expired\n\tif *t <= 0 {\n\t\treturn true, nil\n\t}\n\n\ttc.enqueueAfter(job, *t)\n\treturn false, nil\n}", "category": "Python"}, {"instruction": "// LocalChangedFiles returns a paginated list of currently needed files in\n// progress, queued, and to be queued on next puller iteration, as well as the\n// total number of files currently needed.", "input": "go language", "output": "func (m *model) LocalChangedFiles(folder string, page, perpage int) []db.FileInfoTruncated {\n\tm.fmut.RLock()\n\trf, ok := m.folderFiles[folder]\n\tfcfg := m.folderCfgs[folder]\n\tm.fmut.RUnlock()\n\n\tif !ok {\n\t\treturn nil\n\t}\n\tif fcfg.Type != config.FolderTypeReceiveOnly {\n\t\treturn nil\n\t}\n\tif rf.ReceiveOnlyChangedSize().TotalItems() == 0 {\n\t\treturn nil\n\t}\n\n\tfiles := make([]db.FileInfoTruncated, 0, perpage)\n\n\tskip := (page - 1) * perpage\n\tget := perpage\n\n\trf.WithHaveTruncated(protocol.LocalDeviceID, func(f db.FileIntf) bool {\n\t\tif !f.IsReceiveOnlyChanged() {\n\t\t\treturn true\n\t\t}\n\t\tif skip > 0 {\n\t\t\tskip--\n\t\t\treturn true\n\t\t}\n\t\tft := f.(db.FileInfoTruncated)\n\t\tfiles = append(files, ft)\n\t\tget--\n\t\treturn get > 0\n\t})\n\n\treturn files\n}", "category": "Python"}, {"instruction": "// DeployENS deploys a new Ethereum contract, binding an instance of ENS to it.", "input": "go language", "output": "func DeployENS(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ENS, error) {\n\tparsed, err := abi.JSON(strings.NewReader(ENSABI))\n\tif err != nil {\n\t\treturn common.Address{}, nil, nil, err\n\t}\n\taddress, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ENSBin), backend)\n\tif err != nil {\n\t\treturn common.Address{}, nil, nil, err\n\t}\n\treturn address, tx, &ENS{ENSCaller: ENSCaller{contract: contract}, ENSTransactor: ENSTransactor{contract: contract}, ENSFilterer: ENSFilterer{contract: contract}}, nil\n}", "category": "Python"}, {"instruction": "// validateArgs is a checker to ensure tests are not running commands which are\n// not supported on platforms. Specifically on Windows this is 'busybox top'.", "input": "go language", "output": "func validateArgs(args ...string) error {\n\tif testEnv.OSType != \"windows\" {\n\t\treturn nil\n\t}\n\tfoundBusybox := -1\n\tfor key, value := range args {\n\t\tif strings.ToLower(value) == \"busybox\" {\n\t\t\tfoundBusybox = key\n\t\t}\n\t\tif (foundBusybox != -1) && (key == foundBusybox+1) && (strings.ToLower(value) == \"top\") {\n\t\t\treturn errors.New(\"cannot use 'busybox top' in tests on Windows. Use runSleepingContainer()\")\n\t\t}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// PendingTransactions returns the transactions that are in the transaction pool\n// and have a from address that is one of the accounts this node manages.", "input": "go language", "output": "func (s *PublicTransactionPoolAPI) PendingTransactions() ([]*RPCTransaction, error) {\n\tpending, err := s.b.GetPoolTransactions()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\taccounts := make(map[common.Address]struct{})\n\tfor _, wallet := range s.b.AccountManager().Wallets() {\n\t\tfor _, account := range wallet.Accounts() {\n\t\t\taccounts[account.Address] = struct{}{}\n\t\t}\n\t}\n\ttransactions := make([]*RPCTransaction, 0, len(pending))\n\tfor _, tx := range pending {\n\t\tvar signer types.Signer = types.HomesteadSigner{}\n\t\tif tx.Protected() {\n\t\t\tsigner = types.NewEIP155Signer(tx.ChainId())\n\t\t}\n\t\tfrom, _ := types.Sender(signer, tx)\n\t\tif _, exists := accounts[from]; exists {\n\t\t\ttransactions = append(transactions, newRPCPendingTransaction(tx))\n\t\t}\n\t}\n\treturn transactions, nil\n}", "category": "Python"}, {"instruction": "// Validate checks to the AnnotateOptions to see if there is sufficient information run the command.", "input": "go language", "output": "func (o AnnotateOptions) Validate() error {\n\tif o.all && len(o.selector) > 0 {\n\t\treturn fmt.Errorf(\"cannot set --all and --selector at the same time\")\n\t}\n\tif o.all && len(o.fieldSelector) > 0 {\n\t\treturn fmt.Errorf(\"cannot set --all and --field-selector at the same time\")\n\t}\n\tif len(o.resources) < 1 && cmdutil.IsFilenameSliceEmpty(o.Filenames, o.Kustomize) {\n\t\treturn fmt.Errorf(\"one or more resources must be specified as <resource> <name> or <resource>/<name>\")\n\t}\n\tif len(o.newAnnotations) < 1 && len(o.removeAnnotations) < 1 {\n\t\treturn fmt.Errorf(\"at least one annotation update is required\")\n\t}\n\treturn validateAnnotations(o.removeAnnotations, o.newAnnotations)\n}", "category": "Python"}, {"instruction": "// setupMounts configures the mount points for a container by appending each\n// of the configured mounts on the container to the OCI mount structure\n// which will ultimately be passed into the oci runtime during container creation.\n// It also ensures each of the mounts are lexicographically sorted.\n// BUGBUG TODO Windows containerd. This would be much better if it returned\n// an array of runtime spec mounts, not container mounts. Then no need to\n// do multiple transitions.", "input": "go language", "output": "func (daemon *Daemon) setupMounts(c *container.Container) ([]container.Mount, error) {\n\tvar mnts []container.Mount\n\tfor _, mount := range c.MountPoints { // type is volumemounts.MountPoint\n\t\tif err := daemon.lazyInitializeVolume(c.ID, mount); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ts, err := mount.Setup(c.MountLabel, idtools.Identity{}, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tmnts = append(mnts, container.Mount{\n\t\t\tSource:      s,\n\t\t\tDestination: mount.Destination,\n\t\t\tWritable:    mount.RW,\n\t\t})\n\t}\n\n\tsort.Sort(mounts(mnts))\n\treturn mnts, nil\n}", "category": "Python"}, {"instruction": "// VerifyByChannel checks that signature is a valid signature of message\n// under a peer's verification key, but also in the context of a specific channel.\n// If the verification succeeded, Verify returns nil meaning no error occurred.\n// If peerIdentity is nil, then the verification fails.", "input": "go language", "output": "func (s *MSPMessageCryptoService) VerifyByChannel(chainID common.ChainID, peerIdentity api.PeerIdentityType, signature, message []byte) error {\n\t// Validate arguments\n\tif len(peerIdentity) == 0 {\n\t\treturn errors.New(\"Invalid Peer Identity. It must be different from nil.\")\n\t}\n\n\t// Get the policy manager for channel chainID\n\tcpm, flag := s.channelPolicyManagerGetter.Manager(string(chainID))\n\tif cpm == nil {\n\t\treturn fmt.Errorf(\"Could not acquire policy manager for channel %s\", string(chainID))\n\t}\n\tmcsLogger.Debugf(\"Got policy manager for channel [%s] with flag [%t]\", string(chainID), flag)\n\n\t// Get channel reader policy\n\tpolicy, flag := cpm.GetPolicy(policies.ChannelApplicationReaders)\n\tmcsLogger.Debugf(\"Got reader policy for channel [%s] with flag [%t]\", string(chainID), flag)\n\n\treturn policy.Evaluate(\n\t\t[]*pcommon.SignedData{{\n\t\t\tData:      message,\n\t\t\tIdentity:  []byte(peerIdentity),\n\t\t\tSignature: signature,\n\t\t}},\n\t)\n}", "category": "Python"}, {"instruction": "// Set adds or updates the given entry in the record. It panics if the value can't be\n// encoded. If the record is signed, Set increments the sequence number and invalidates\n// the sequence number.", "input": "go language", "output": "func (r *Record) Set(e Entry) {\n\tblob, err := rlp.EncodeToBytes(e)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"enr: can't encode %s: %v\", e.ENRKey(), err))\n\t}\n\tr.invalidate()\n\n\tpairs := make([]pair, len(r.pairs))\n\tcopy(pairs, r.pairs)\n\ti := sort.Search(len(pairs), func(i int) bool { return pairs[i].k >= e.ENRKey() })\n\tswitch {\n\tcase i < len(pairs) && pairs[i].k == e.ENRKey():\n\t\t// element is present at r.pairs[i]\n\t\tpairs[i].v = blob\n\tcase i < len(r.pairs):\n\t\t// insert pair before i-th elem\n\t\tel := pair{e.ENRKey(), blob}\n\t\tpairs = append(pairs, pair{})\n\t\tcopy(pairs[i+1:], pairs[i:])\n\t\tpairs[i] = el\n\tdefault:\n\t\t// element should be placed at the end of r.pairs\n\t\tpairs = append(pairs, pair{e.ENRKey(), blob})\n\t}\n\tr.pairs = pairs\n}", "category": "Python"}, {"instruction": "// RequestVerificationWithUser implements the Manager interface.", "input": "go language", "output": "func (p *UserPrivileges) RequestVerificationWithUser(db, table, column string, priv mysql.PrivilegeType, user *auth.UserIdentity) bool {\n\tif SkipWithGrant {\n\t\treturn true\n\t}\n\n\tif user == nil {\n\t\treturn false\n\t}\n\n\t// Skip check for INFORMATION_SCHEMA database.\n\t// See https://dev.mysql.com/doc/refman/5.7/en/information-schema.html\n\tif strings.EqualFold(db, \"INFORMATION_SCHEMA\") {\n\t\treturn true\n\t}\n\n\tmysqlPriv := p.Handle.Get()\n\treturn mysqlPriv.RequestVerification(nil, user.Username, user.Hostname, db, table, column, priv)\n}", "category": "Python"}, {"instruction": "// Error returns detailed information of why the pod failed to fit on each node", "input": "go language", "output": "func (f *FitError) Error() string {\n\treasons := make(map[string]int)\n\tfor _, predicates := range f.FailedPredicates {\n\t\tfor _, pred := range predicates {\n\t\t\treasons[pred.GetReason()]++\n\t\t}\n\t}\n\n\tsortReasonsHistogram := func() []string {\n\t\treasonStrings := []string{}\n\t\tfor k, v := range reasons {\n\t\t\treasonStrings = append(reasonStrings, fmt.Sprintf(\"%v %v\", v, k))\n\t\t}\n\t\tsort.Strings(reasonStrings)\n\t\treturn reasonStrings\n\t}\n\treasonMsg := fmt.Sprintf(NoNodeAvailableMsg+\": %v.\", f.NumAllNodes, strings.Join(sortReasonsHistogram(), \", \"))\n\treturn reasonMsg\n}", "category": "Python"}, {"instruction": "// GetTxSimulationResults implements method in interface `ledger.TxSimulator`", "input": "go language", "output": "func (s *lockBasedTxSimulator) GetTxSimulationResults() (*ledger.TxSimulationResults, error) {\n\tif s.simulationResultsComputed {\n\t\treturn nil, errors.New(\"this function should only be called once on a transaction simulator instance\")\n\t}\n\tdefer func() { s.simulationResultsComputed = true }()\n\tlogger.Debugf(\"Simulation completed, getting simulation results\")\n\tif s.helper.err != nil {\n\t\treturn nil, s.helper.err\n\t}\n\ts.helper.addRangeQueryInfo()\n\treturn s.rwsetBuilder.GetTxSimulationResults()\n}", "category": "Python"}, {"instruction": "// TODO: Remove this when extensions/v1beta1 and apps/v1beta1 Deployment are dropped.", "input": "go language", "output": "func getRollbackTo(d *apps.Deployment) *extensions.RollbackConfig {\n\t// Extract the annotation used for round-tripping the deprecated RollbackTo field.\n\trevision := d.Annotations[apps.DeprecatedRollbackTo]\n\tif revision == \"\" {\n\t\treturn nil\n\t}\n\trevision64, err := strconv.ParseInt(revision, 10, 64)\n\tif err != nil {\n\t\t// If it's invalid, ignore it.\n\t\treturn nil\n\t}\n\treturn &extensions.RollbackConfig{\n\t\tRevision: revision64,\n\t}\n}", "category": "Python"}, {"instruction": "// newCallback turns fn (a function) into a callback object. It returns nil if the function\n// is unsuitable as an RPC callback.", "input": "go language", "output": "func newCallback(receiver, fn reflect.Value) *callback {\n\tfntype := fn.Type()\n\tc := &callback{fn: fn, rcvr: receiver, errPos: -1, isSubscribe: isPubSub(fntype)}\n\t// Determine parameter types. They must all be exported or builtin types.\n\tc.makeArgTypes()\n\tif !allExportedOrBuiltin(c.argTypes) {\n\t\treturn nil\n\t}\n\t// Verify return types. The function must return at most one error\n\t// and/or one other non-error value.\n\touts := make([]reflect.Type, fntype.NumOut())\n\tfor i := 0; i < fntype.NumOut(); i++ {\n\t\touts[i] = fntype.Out(i)\n\t}\n\tif len(outs) > 2 || !allExportedOrBuiltin(outs) {\n\t\treturn nil\n\t}\n\t// If an error is returned, it must be the last returned value.\n\tswitch {\n\tcase len(outs) == 1 && isErrorType(outs[0]):\n\t\tc.errPos = 0\n\tcase len(outs) == 2:\n\t\tif isErrorType(outs[0]) || !isErrorType(outs[1]) {\n\t\t\treturn nil\n\t\t}\n\t\tc.errPos = 1\n\t}\n\treturn c\n}", "category": "Python"}, {"instruction": "// sweepList will loop over the list, merge each session's local stats into handle\n// and remove closed session's collector.", "input": "go language", "output": "func (h *Handle) sweepList() {\n\tprev := h.listHead\n\tprev.Lock()\n\terrorRateMap := make(errorRateDeltaMap)\n\tfor curr := prev.next; curr != nil; curr = curr.next {\n\t\tcurr.Lock()\n\t\t// Merge the session stats into handle and error rate map.\n\t\th.merge(curr, errorRateMap)\n\t\tif curr.deleted {\n\t\t\tprev.next = curr.next\n\t\t\t// Since the session is already closed, we can safely unlock it here.\n\t\t\tcurr.Unlock()\n\t\t} else {\n\t\t\t// Unlock the previous lock, so we only holds at most two session's lock at the same time.\n\t\t\tprev.Unlock()\n\t\t\tprev = curr\n\t\t}\n\t}\n\tprev.Unlock()\n\th.mu.Lock()\n\th.mu.rateMap.merge(errorRateMap)\n\th.mu.Unlock()\n}", "category": "Python"}, {"instruction": "// RunCompletion checks given arguments and executes command", "input": "go language", "output": "func RunCompletion(out io.Writer, boilerPlate string, cmd *cobra.Command, args []string) error {\n\tif length := len(args); length == 0 {\n\t\treturn errors.New(\"shell not specified\")\n\t} else if length > 1 {\n\t\treturn errors.New(\"too many arguments. expected only the shell type\")\n\t}\n\trun, found := completionShells[args[0]]\n\tif !found {\n\t\treturn errors.Errorf(\"unsupported shell type %q\", args[0])\n\t}\n\n\tif len(boilerPlate) == 0 {\n\t\tboilerPlate = defaultBoilerPlate\n\t}\n\tif _, err := out.Write([]byte(boilerPlate)); err != nil {\n\t\treturn err\n\t}\n\treturn run(out, cmd.Parent())\n}", "category": "Python"}, {"instruction": "// Backup creates a backup of an etcd2 data directory at the given backupDir.", "input": "go language", "output": "func (e *CombinedEtcdClient) Backup(version *EtcdVersion, backupDir string) error {\n\t// We cannot use etcd/client (v2) to make this call. It is implemented in the etcdctl client code.\n\tif version.Major != 2 {\n\t\treturn fmt.Errorf(\"etcd 2.x required but got version '%s'\", version)\n\t}\n\treturn e.runEtcdctlCommand(version,\n\t\t\"--debug\",\n\t\t\"backup\",\n\t\t\"--data-dir\", e.cfg.dataDirectory,\n\t\t\"--backup-dir\", backupDir,\n\t)\n}", "category": "Python"}, {"instruction": "// Update updates internal state of what has been downloaded into the temporary\n// files by the remote device for this specific folder.", "input": "go language", "output": "func (t *deviceDownloadState) Update(folder string, updates []protocol.FileDownloadProgressUpdate) {\n\tif t == nil {\n\t\treturn\n\t}\n\tt.mut.RLock()\n\tf, ok := t.folders[folder]\n\tt.mut.RUnlock()\n\n\tif !ok {\n\t\tf = &deviceFolderDownloadState{\n\t\t\tmut:   sync.NewRWMutex(),\n\t\t\tfiles: make(map[string]deviceFolderFileDownloadState),\n\t\t}\n\t\tt.mut.Lock()\n\t\tt.folders[folder] = f\n\t\tt.mut.Unlock()\n\t}\n\n\tf.Update(updates)\n}", "category": "Python"}, {"instruction": "// getCgroupProcs takes a cgroup directory name as an argument\n// reads through the cgroup's procs file and returns a list of tgid's.\n// It returns an empty list if a procs file doesn't exists", "input": "go language", "output": "func getCgroupProcs(dir string) ([]int, error) {\n\tprocsFile := filepath.Join(dir, \"cgroup.procs\")\n\tf, err := os.Open(procsFile)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\t// The procsFile does not exist, So no pids attached to this directory\n\t\t\treturn []int{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\ts := bufio.NewScanner(f)\n\tout := []int{}\n\tfor s.Scan() {\n\t\tif t := s.Text(); t != \"\" {\n\t\t\tpid, err := strconv.Atoi(t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"unexpected line in %v; could not convert to pid: %v\", procsFile, err)\n\t\t\t}\n\t\t\tout = append(out, pid)\n\t\t}\n\t}\n\treturn out, nil\n}", "category": "Python"}, {"instruction": "// UpdateStatus was generated because the type contains a Status member.\n// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().", "input": "go language", "output": "func (c *FakeReplicationControllers) UpdateStatus(replicationController *corev1.ReplicationController) (*corev1.ReplicationController, error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewUpdateSubresourceAction(replicationcontrollersResource, \"status\", c.ns, replicationController), &corev1.ReplicationController{})\n\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\treturn obj.(*corev1.ReplicationController), err\n}", "category": "Python"}, {"instruction": "// ParseAbsProviderConfigStr is a helper wrapper around ParseAbsProviderConfig\n// that takes a string and parses it with the HCL native syntax traversal parser\n// before interpreting it.\n//\n// This should be used only in specialized situations since it will cause the\n// created references to not have any meaningful source location information.\n// If a reference string is coming from a source that should be identified in\n// error messages then the caller should instead parse it directly using a\n// suitable function from the HCL API and pass the traversal itself to\n// ParseAbsProviderConfig.\n//\n// Error diagnostics are returned if either the parsing fails or the analysis\n// of the traversal fails. There is no way for the caller to distinguish the\n// two kinds of diagnostics programmatically. If error diagnostics are returned\n// the returned address is invalid.", "input": "go language", "output": "func ParseAbsProviderConfigStr(str string) (AbsProviderConfig, tfdiags.Diagnostics) {\n\tvar diags tfdiags.Diagnostics\n\n\ttraversal, parseDiags := hclsyntax.ParseTraversalAbs([]byte(str), \"\", hcl.Pos{Line: 1, Column: 1})\n\tdiags = diags.Append(parseDiags)\n\tif parseDiags.HasErrors() {\n\t\treturn AbsProviderConfig{}, diags\n\t}\n\n\taddr, addrDiags := ParseAbsProviderConfig(traversal)\n\tdiags = diags.Append(addrDiags)\n\treturn addr, diags\n}", "category": "Python"}, {"instruction": "// neighbourhoodRadiusForPot returns the neighbourhood radius of the kademlia\n// neighbourhood radius encloses the nearest neighbour set with size >= neighbourhoodSize\n// i.e., neighbourhood radius is the deepest PO such that all bins not shallower altogether\n// contain at least neighbourhoodSize connected peers\n// if there is altogether less than neighbourhoodSize peers connected, it returns 0\n// caller must hold the lock", "input": "go language", "output": "func neighbourhoodRadiusForPot(p *pot.Pot, neighbourhoodSize int, pivotAddr []byte) (depth int) {\n\tif p.Size() <= neighbourhoodSize {\n\t\treturn 0\n\t}\n\t// total number of peers in iteration\n\tvar size int\n\tf := func(v pot.Val, i int) bool {\n\t\t// po == 256 means that addr is the pivot address(self)\n\t\tif i == 256 {\n\t\t\treturn true\n\t\t}\n\t\tsize++\n\n\t\t// this means we have all nn-peers.\n\t\t// depth is by default set to the bin of the farthest nn-peer\n\t\tif size == neighbourhoodSize {\n\t\t\tdepth = i\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t}\n\tp.EachNeighbour(pivotAddr, Pof, f)\n\treturn depth\n}", "category": "Python"}, {"instruction": "// applyPackageSpecOverride applies the package spec overrides for the given\n// osDistro to the packageSpecs and returns the applied result.", "input": "go language", "output": "func applyPackageSpecOverride(packageSpecs []PackageSpec, overrides []PackageSpecOverride, osDistro string) []PackageSpec {\n\tvar override *PackageSpecOverride\n\tfor _, o := range overrides {\n\t\tif o.OSDistro == osDistro {\n\t\t\toverride = &o\n\t\t\tbreak\n\t\t}\n\t}\n\tif override == nil {\n\t\treturn packageSpecs\n\t}\n\n\t// Remove packages in the spec that matches the overrides in\n\t// Subtractions.\n\tvar out []PackageSpec\n\tsubtractions := make(map[string]bool)\n\tfor _, spec := range override.Subtractions {\n\t\tsubtractions[spec.Name] = true\n\t}\n\tfor _, spec := range packageSpecs {\n\t\tif _, ok := subtractions[spec.Name]; !ok {\n\t\t\tout = append(out, spec)\n\t\t}\n\t}\n\n\t// Add packages in the spec that matches the overrides in Additions.\n\treturn append(out, override.Additions...)\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *PolicyRule) DeepCopyInto(out *PolicyRule) {\n\t*out = *in\n\tif in.Verbs != nil {\n\t\tin, out := &in.Verbs, &out.Verbs\n\t\t*out = make([]string, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\tif in.APIGroups != nil {\n\t\tin, out := &in.APIGroups, &out.APIGroups\n\t\t*out = make([]string, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\tif in.Resources != nil {\n\t\tin, out := &in.Resources, &out.Resources\n\t\t*out = make([]string, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\tif in.ResourceNames != nil {\n\t\tin, out := &in.ResourceNames, &out.ResourceNames\n\t\t*out = make([]string, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\tif in.NonResourceURLs != nil {\n\t\tin, out := &in.NonResourceURLs, &out.NonResourceURLs\n\t\t*out = make([]string, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// SetUnstructuredContent obeys the conventions of List and keeps Items and the items\n// array in sync. If items is not an array of objects in the incoming map, then any\n// mismatched item will be removed.", "input": "go language", "output": "func (obj *UnstructuredList) SetUnstructuredContent(content map[string]interface{}) {\n\tobj.Object = content\n\tif content == nil {\n\t\tobj.Items = nil\n\t\treturn\n\t}\n\titems, ok := obj.Object[\"items\"].([]interface{})\n\tif !ok || items == nil {\n\t\titems = []interface{}{}\n\t}\n\tunstructuredItems := make([]Unstructured, 0, len(items))\n\tnewItems := make([]interface{}, 0, len(items))\n\tfor _, item := range items {\n\t\to, ok := item.(map[string]interface{})\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tunstructuredItems = append(unstructuredItems, Unstructured{Object: o})\n\t\tnewItems = append(newItems, o)\n\t}\n\tobj.Items = unstructuredItems\n\tobj.Object[\"items\"] = newItems\n}", "category": "Python"}, {"instruction": "// JWTTokenGenerator returns a TokenGenerator that generates signed JWT tokens, using the given privateKey.\n// privateKey is a PEM-encoded byte array of a private RSA key.\n// JWTTokenAuthenticator()", "input": "go language", "output": "func JWTTokenGenerator(iss string, privateKey interface{}) (TokenGenerator, error) {\n\tvar alg jose.SignatureAlgorithm\n\tswitch pk := privateKey.(type) {\n\tcase *rsa.PrivateKey:\n\t\talg = jose.RS256\n\tcase *ecdsa.PrivateKey:\n\t\tswitch pk.Curve {\n\t\tcase elliptic.P256():\n\t\t\talg = jose.ES256\n\t\tcase elliptic.P384():\n\t\t\talg = jose.ES384\n\t\tcase elliptic.P521():\n\t\t\talg = jose.ES512\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unknown private key curve, must be 256, 384, or 521\")\n\t\t}\n\tcase jose.OpaqueSigner:\n\t\talg = jose.SignatureAlgorithm(pk.Public().Algorithm)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown private key type %T, must be *rsa.PrivateKey, *ecdsa.PrivateKey, or jose.OpaqueSigner\", privateKey)\n\t}\n\n\tsigner, err := jose.NewSigner(\n\t\tjose.SigningKey{\n\t\t\tAlgorithm: alg,\n\t\t\tKey:       privateKey,\n\t\t},\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &jwtTokenGenerator{\n\t\tiss:    iss,\n\t\tsigner: signer,\n\t}, nil\n}", "category": "Python"}, {"instruction": "// buildTargetGroupName will build unique name for targetGroup of service & port.\n// the name is in format k8s-{namespace:8}-{name:8}-{uuid:10} (chosen to benefit most common use cases).\n// Note: targetProtocol & targetType are included since they cannot be modified on existing targetGroup.", "input": "go language", "output": "func (c *Cloud) buildTargetGroupName(serviceName types.NamespacedName, servicePort int64, targetProtocol string, targetType string) string {\n\thasher := sha1.New()\n\t_, _ = hasher.Write([]byte(c.tagging.clusterID()))\n\t_, _ = hasher.Write([]byte(serviceName.Namespace))\n\t_, _ = hasher.Write([]byte(serviceName.Name))\n\t_, _ = hasher.Write([]byte(strconv.FormatInt(servicePort, 10)))\n\t_, _ = hasher.Write([]byte(targetProtocol))\n\t_, _ = hasher.Write([]byte(targetType))\n\ttgUUID := hex.EncodeToString(hasher.Sum(nil))\n\n\tsanitizedNamespace := invalidELBV2NameRegex.ReplaceAllString(serviceName.Namespace, \"\")\n\tsanitizedServiceName := invalidELBV2NameRegex.ReplaceAllString(serviceName.Name, \"\")\n\treturn fmt.Sprintf(\"k8s-%.8s-%.8s-%.10s\", sanitizedNamespace, sanitizedServiceName, tgUUID)\n}", "category": "Python"}, {"instruction": "// getOpenAPIModels is a private method for getting the OpenAPI models", "input": "go language", "output": "func (s *GenericAPIServer) getOpenAPIModels(apiPrefix string, apiGroupInfos ...*APIGroupInfo) (openapiproto.Models, error) {\n\tif s.openAPIConfig == nil {\n\t\treturn nil, nil\n\t}\n\tpathsToIgnore := openapiutil.NewTrie(s.openAPIConfig.IgnorePrefixes)\n\tresourceNames := make([]string, 0)\n\tfor _, apiGroupInfo := range apiGroupInfos {\n\t\tgroupResources, err := getResourceNamesForGroup(apiPrefix, apiGroupInfo, pathsToIgnore)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresourceNames = append(resourceNames, groupResources...)\n\t}\n\n\t// Build the openapi definitions for those resources and convert it to proto models\n\topenAPISpec, err := openapibuilder.BuildOpenAPIDefinitionsForResources(s.openAPIConfig, resourceNames...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn utilopenapi.ToProtoModels(openAPISpec)\n}", "category": "Python"}, {"instruction": "// Get returns the previously stored value, or the empty string if it does not exist or key is of 0-length", "input": "go language", "output": "func (s *AESEncryptedStorage) Get(key string) string {\n\tif len(key) == 0 {\n\t\treturn \"\"\n\t}\n\tdata, err := s.readEncryptedStorage()\n\tif err != nil {\n\t\tlog.Warn(\"Failed to read encrypted storage\", \"err\", err, \"file\", s.filename)\n\t\treturn \"\"\n\t}\n\tencrypted, exist := data[key]\n\tif !exist {\n\t\tlog.Warn(\"Key does not exist\", \"key\", key)\n\t\treturn \"\"\n\t}\n\tentry, err := decrypt(s.key, encrypted.Iv, encrypted.CipherText, []byte(key))\n\tif err != nil {\n\t\tlog.Warn(\"Failed to decrypt key\", \"key\", key)\n\t\treturn \"\"\n\t}\n\treturn string(entry)\n}", "category": "Python"}, {"instruction": "// evalString evals a builtinCurrentUserSig.\n// See https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_current-user", "input": "go language", "output": "func (b *builtinCurrentRoleSig) evalString(row chunk.Row) (string, bool, error) {\n\tdata := b.ctx.GetSessionVars()\n\tif data == nil || data.ActiveRoles == nil {\n\t\treturn \"\", true, errors.Errorf(\"Missing session variable when eval builtin\")\n\t}\n\tif len(data.ActiveRoles) == 0 {\n\t\treturn \"\", false, nil\n\t}\n\tres := \"\"\n\tfor i, r := range data.ActiveRoles {\n\t\tres += r.String()\n\t\tif i != len(data.ActiveRoles)-1 {\n\t\t\tres += \",\"\n\t\t}\n\t}\n\treturn res, false, nil\n}", "category": "Python"}, {"instruction": "// Injectable for testing", "input": "go language", "output": "func processRoutes(routeTable network.RouteTable, exists bool, err error) ([]*cloudprovider.Route, error) {\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn []*cloudprovider.Route{}, nil\n\t}\n\n\tvar kubeRoutes []*cloudprovider.Route\n\tif routeTable.RouteTablePropertiesFormat != nil && routeTable.Routes != nil {\n\t\tkubeRoutes = make([]*cloudprovider.Route, len(*routeTable.Routes))\n\t\tfor i, route := range *routeTable.Routes {\n\t\t\tinstance := mapRouteNameToNodeName(*route.Name)\n\t\t\tcidr := *route.AddressPrefix\n\t\t\tklog.V(10).Infof(\"ListRoutes: * instance=%q, cidr=%q\", instance, cidr)\n\n\t\t\tkubeRoutes[i] = &cloudprovider.Route{\n\t\t\t\tName:            *route.Name,\n\t\t\t\tTargetNode:      instance,\n\t\t\t\tDestinationCIDR: cidr,\n\t\t\t}\n\t\t}\n\t}\n\n\tklog.V(10).Info(\"ListRoutes: FINISH\")\n\treturn kubeRoutes, nil\n}", "category": "Python"}, {"instruction": "// ipcListen will create a Unix socket on the given endpoint.", "input": "go language", "output": "func ipcListen(endpoint string) (net.Listener, error) {\n\tif len(endpoint) > int(C.max_socket_path_size()) {\n\t\tlog.Warn(fmt.Sprintf(\"The ipc endpoint is longer than %d characters. \", C.max_socket_path_size()),\n\t\t\t\"endpoint\", endpoint)\n\t}\n\n\t// Ensure the IPC path exists and remove any previous leftover\n\tif err := os.MkdirAll(filepath.Dir(endpoint), 0751); err != nil {\n\t\treturn nil, err\n\t}\n\tos.Remove(endpoint)\n\tl, err := net.Listen(\"unix\", endpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tos.Chmod(endpoint, 0600)\n\treturn l, nil\n}", "category": "Python"}, {"instruction": "// MetadataFromConfigValue reads and translates configuration updates from config value into raft metadata", "input": "go language", "output": "func MetadataFromConfigValue(configValue *common.ConfigValue) (*etcdraft.ConfigMetadata, error) {\n\tconsensusTypeValue := &orderer.ConsensusType{}\n\tif err := proto.Unmarshal(configValue.Value, consensusTypeValue); err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to unmarshal consensusType config update\")\n\t}\n\n\tupdatedMetadata := &etcdraft.ConfigMetadata{}\n\tif err := proto.Unmarshal(consensusTypeValue.Metadata, updatedMetadata); err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to unmarshal updated (new) etcdraft metadata configuration\")\n\t}\n\n\treturn updatedMetadata, nil\n}", "category": "Python"}, {"instruction": "// PlannedDataResourceObject is similar to ProposedNewObject but tailored for\n// planning data resources in particular. Specifically, it replaces the values\n// of any Computed attributes not set in the configuration with an unknown\n// value, which serves as a placeholder for a value to be filled in by the\n// provider when the data resource is finally read.\n//\n// Data resources are different because the planning of them is handled\n// entirely within Terraform Core and not subject to customization by the\n// provider. This function is, in effect, producing an equivalent result to\n// passing the ProposedNewObject result into a provider's PlanResourceChange\n// function, assuming a fixed implementation of PlanResourceChange that just\n// fills in unknown values as needed.", "input": "go language", "output": "func PlannedDataResourceObject(schema *configschema.Block, config cty.Value) cty.Value {\n\t// Our trick here is to run the ProposedNewObject logic with an\n\t// entirely-unknown prior value. Because of cty's unknown short-circuit\n\t// behavior, any operation on prior returns another unknown, and so\n\t// unknown values propagate into all of the parts of the resulting value\n\t// that would normally be filled in by preserving the prior state.\n\tprior := cty.UnknownVal(schema.ImpliedType())\n\treturn proposedNewObject(schema, prior, config)\n}", "category": "Python"}, {"instruction": "// IgnoreFile returns whether a given file should be ignored.", "input": "go language", "output": "func (s *SourceSpec) IgnoreFile(filename string) bool {\n\tif filename == \"\" {\n\t\tif _, ok := s.SourceFs.(*afero.OsFs); ok {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tbase := filepath.Base(filename)\n\n\tif len(base) > 0 {\n\t\tfirst := base[0]\n\t\tlast := base[len(base)-1]\n\t\tif first == '.' ||\n\t\t\tfirst == '#' ||\n\t\t\tlast == '~' {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif len(s.ignoreFilesRe) == 0 {\n\t\treturn false\n\t}\n\n\tfor _, re := range s.ignoreFilesRe {\n\t\tif re.MatchString(filename) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}", "category": "Python"}, {"instruction": "// Next implements the Executor Next interface.", "input": "go language", "output": "func (e *CheckIndexExec) Next(ctx context.Context, req *chunk.RecordBatch) error {\n\tif e.done {\n\t\treturn nil\n\t}\n\tdefer func() { e.done = true }()\n\n\terr := admin.CheckIndicesCount(e.ctx, e.dbName, e.tableName, []string{e.idxName})\n\tif err != nil {\n\t\treturn err\n\t}\n\tchk := e.src.newFirstChunk()\n\tfor {\n\t\terr := e.src.Next(ctx, chunk.NewRecordBatch(chk))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif chk.NumRows() == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// setGraphQL creates the GraphQL listener interface string from the set\n// command line flags, returning empty if the GraphQL endpoint is disabled.", "input": "go language", "output": "func setGraphQL(ctx *cli.Context, cfg *node.Config) {\n\tif ctx.GlobalBool(GraphQLEnabledFlag.Name) && cfg.GraphQLHost == \"\" {\n\t\tcfg.GraphQLHost = \"127.0.0.1\"\n\t\tif ctx.GlobalIsSet(GraphQLListenAddrFlag.Name) {\n\t\t\tcfg.GraphQLHost = ctx.GlobalString(GraphQLListenAddrFlag.Name)\n\t\t}\n\t}\n\tcfg.GraphQLPort = ctx.GlobalInt(GraphQLPortFlag.Name)\n\tif ctx.GlobalIsSet(GraphQLCORSDomainFlag.Name) {\n\t\tcfg.GraphQLCors = splitAndTrim(ctx.GlobalString(GraphQLCORSDomainFlag.Name))\n\t}\n\tif ctx.GlobalIsSet(GraphQLVirtualHostsFlag.Name) {\n\t\tcfg.GraphQLVirtualHosts = splitAndTrim(ctx.GlobalString(GraphQLVirtualHostsFlag.Name))\n\t}\n}", "category": "Python"}, {"instruction": "// Start is used to start an HTTP check.\n// The check runs until stop is called", "input": "go language", "output": "func (c *CheckHTTP) Start() {\n\tc.stopLock.Lock()\n\tdefer c.stopLock.Unlock()\n\n\tif c.httpClient == nil {\n\t\t// Create the transport. We disable HTTP Keep-Alive's to prevent\n\t\t// failing checks due to the keepalive interval.\n\t\ttrans := cleanhttp.DefaultTransport()\n\t\ttrans.DisableKeepAlives = true\n\n\t\t// Take on the supplied TLS client config.\n\t\ttrans.TLSClientConfig = c.TLSClientConfig\n\n\t\t// Create the HTTP client.\n\t\tc.httpClient = &http.Client{\n\t\t\tTimeout:   10 * time.Second,\n\t\t\tTransport: trans,\n\t\t}\n\n\t\t// For long (>10s) interval checks the http timeout is 10s, otherwise the\n\t\t// timeout is the interval. This means that a check *should* return\n\t\t// before the next check begins.\n\t\tif c.Timeout > 0 && c.Timeout < c.Interval {\n\t\t\tc.httpClient.Timeout = c.Timeout\n\t\t} else if c.Interval < 10*time.Second {\n\t\t\tc.httpClient.Timeout = c.Interval\n\t\t}\n\t}\n\n\tc.stop = false\n\tc.stopCh = make(chan struct{})\n\tgo c.run()\n}", "category": "Python"}, {"instruction": "// GetSnapshot retrieves the state snapshot at a given block.", "input": "go language", "output": "func (api *API) GetSnapshot(number *rpc.BlockNumber) (*Snapshot, error) {\n\t// Retrieve the requested block number (or current if none requested)\n\tvar header *types.Header\n\tif number == nil || *number == rpc.LatestBlockNumber {\n\t\theader = api.chain.CurrentHeader()\n\t} else {\n\t\theader = api.chain.GetHeaderByNumber(uint64(number.Int64()))\n\t}\n\t// Ensure we have an actually valid block and return its snapshot\n\tif header == nil {\n\t\treturn nil, errUnknownBlock\n\t}\n\treturn api.clique.snapshot(api.chain, header.Number.Uint64(), header.Hash(), nil)\n}", "category": "Python"}, {"instruction": "// Stop stops the node with the given ID", "input": "go language", "output": "func (net *Network) Stop(id enode.ID) error {\n\t// IMPORTANT: node.Stop() must NOT be called under net.lock as\n\t// node.Reachable() closure has a reference to the network and\n\t// calls net.InitConn() what also locks the network. => DEADLOCK\n\t// That holds until the following ticket is not resolved:\n\n\tvar err error\n\n\tnode, err := func() (*Node, error) {\n\t\tnet.lock.Lock()\n\t\tdefer net.lock.Unlock()\n\n\t\tnode := net.getNode(id)\n\t\tif node == nil {\n\t\t\treturn nil, fmt.Errorf(\"node %v does not exist\", id)\n\t\t}\n\t\tif !node.Up() {\n\t\t\treturn nil, fmt.Errorf(\"node %v already down\", id)\n\t\t}\n\t\tnode.SetUp(false)\n\t\treturn node, nil\n\t}()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = node.Stop() // must be called without net.lock\n\n\tnet.lock.Lock()\n\tdefer net.lock.Unlock()\n\n\tif err != nil {\n\t\tnode.SetUp(true)\n\t\treturn err\n\t}\n\tlog.Info(\"Stopped node\", \"id\", id, \"err\", err)\n\tev := ControlEvent(node)\n\tnet.events.Send(ev)\n\treturn nil\n}", "category": "Python"}, {"instruction": "// ChannelCreationBlockToGenesisBlock converts a channel creation block to a genesis block", "input": "go language", "output": "func ChannelCreationBlockToGenesisBlock(block *common.Block) (*common.Block, error) {\n\tif block == nil {\n\t\treturn nil, errors.New(\"nil block\")\n\t}\n\tenv, err := utils.ExtractEnvelope(block, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpayload, err := utils.ExtractPayload(env)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tblock.Data.Data = [][]byte{payload.Data}\n\tblock.Header.DataHash = block.Data.Hash()\n\tblock.Header.Number = 0\n\tblock.Header.PreviousHash = nil\n\tmetadata := &common.BlockMetadata{\n\t\tMetadata: make([][]byte, 4),\n\t}\n\tblock.Metadata = metadata\n\tmetadata.Metadata[common.BlockMetadataIndex_LAST_CONFIG] = utils.MarshalOrPanic(&common.Metadata{\n\t\tValue: utils.MarshalOrPanic(&common.LastConfig{Index: 0}),\n\t\t// This is a genesis block, peer never verify this signature because we can't bootstrap\n\t\t// trust from an earlier block, hence there are no signatures here.\n\t})\n\treturn block, nil\n}", "category": "Python"}, {"instruction": "// RunAPIVersions does the work", "input": "go language", "output": "func (o *APIVersionsOptions) RunAPIVersions() error {\n\t// Always request fresh data from the server\n\to.discoveryClient.Invalidate()\n\n\tgroupList, err := o.discoveryClient.ServerGroups()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"couldn't get available api versions from server: %v\", err)\n\t}\n\tapiVersions := metav1.ExtractGroupVersions(groupList)\n\tsort.Strings(apiVersions)\n\tfor _, v := range apiVersions {\n\t\tfmt.Fprintln(o.Out, v)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// expireNodes iterates over the database and deletes all nodes that have not\n// been seen (i.e. received a pong from) for some allotted time.", "input": "go language", "output": "func (db *nodeDB) expireNodes() error {\n\tthreshold := time.Now().Add(-nodeDBNodeExpiration)\n\n\t// Find discovered nodes that are older than the allowance\n\tit := db.lvl.NewIterator(nil, nil)\n\tdefer it.Release()\n\n\tfor it.Next() {\n\t\t// Skip the item if not a discovery node\n\t\tid, field := splitKey(it.Key())\n\t\tif field != nodeDBDiscoverRoot {\n\t\t\tcontinue\n\t\t}\n\t\t// Skip the node if not expired yet (and not self)\n\t\tif !bytes.Equal(id[:], db.self[:]) {\n\t\t\tif seen := db.lastPong(id); seen.After(threshold) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\t// Otherwise delete all associated information\n\t\tdb.deleteNode(id)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// ReadAtMost reads at most max bytes from the end of the file identified by path or\n// returns an error. It returns true if the file was longer than max. It will\n// allocate up to max bytes.", "input": "go language", "output": "func ReadAtMost(path string, max int64) ([]byte, bool, error) {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tdefer f.Close()\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tsize := fi.Size()\n\tif size == 0 {\n\t\treturn nil, false, nil\n\t}\n\tif size < max {\n\t\tmax = size\n\t}\n\toffset, err := f.Seek(-max, io.SeekEnd)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tdata, err := ioutil.ReadAll(f)\n\treturn data, offset > 0, err\n}", "category": "Python"}, {"instruction": "// expandLocations replaces the variables in the locations map with actual\n// directory locations.", "input": "go language", "output": "func expandLocations() error {\n\tnewLocations := make(map[LocationEnum]string)\n\tfor key, dir := range locationTemplates {\n\t\tfor varName, value := range baseDirs {\n\t\t\tdir = strings.Replace(dir, \"${\"+string(varName)+\"}\", value, -1)\n\t\t}\n\t\tvar err error\n\t\tdir, err = fs.ExpandTilde(dir)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnewLocations[key] = filepath.Clean(dir)\n\t}\n\tlocations = newLocations\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Write creates a http or udp client and attempts to write BatchPoints.\n// If a \"database not found\" error is encountered, a CREATE DATABASE\n// query is attempted when using protocol http.", "input": "go language", "output": "func (w *influxDBWriter) Write(bp influxdb.BatchPoints) error {\n\tc, err := w.initWriteClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer c.Close()\n\n\tif writeErr := c.Write(bp); writeErr != nil {\n\t\tctx := log.With(context.Background(), log.Str(log.MetricsProviderName, \"influxdb\"))\n\t\tlog.FromContext(ctx).Errorf(\"Error while writing to InfluxDB: %s\", writeErr.Error())\n\n\t\tif handleErr := w.handleWriteError(ctx, c, writeErr); handleErr != nil {\n\t\t\treturn handleErr\n\t\t}\n\t\t// Retry write after successful handling of writeErr\n\t\treturn c.Write(bp)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// StatusViewerFor returns a StatusViewer for the resource specified by kind.", "input": "go language", "output": "func StatusViewerFor(kind schema.GroupKind) (StatusViewer, error) {\n\tswitch kind {\n\tcase extensionsv1beta1.SchemeGroupVersion.WithKind(\"Deployment\").GroupKind(),\n\t\tappsv1.SchemeGroupVersion.WithKind(\"Deployment\").GroupKind():\n\t\treturn &DeploymentStatusViewer{}, nil\n\tcase extensionsv1beta1.SchemeGroupVersion.WithKind(\"DaemonSet\").GroupKind(),\n\t\tappsv1.SchemeGroupVersion.WithKind(\"DaemonSet\").GroupKind():\n\t\treturn &DaemonSetStatusViewer{}, nil\n\tcase appsv1.SchemeGroupVersion.WithKind(\"StatefulSet\").GroupKind():\n\t\treturn &StatefulSetStatusViewer{}, nil\n\t}\n\treturn nil, fmt.Errorf(\"no status viewer has been implemented for %v\", kind)\n}", "category": "Python"}, {"instruction": "// create is a helper function to create a mock apply that uses the configured\n// working directory to find the logfile.", "input": "go language", "output": "func (m *mockApplies) create(cvID, workspaceID string) (*tfe.Apply, error) {\n\tc, ok := m.client.ConfigurationVersions.configVersions[cvID]\n\tif !ok {\n\t\treturn nil, tfe.ErrResourceNotFound\n\t}\n\tif c.Speculative {\n\t\t// Speculative means its plan-only so we don't create a Apply.\n\t\treturn nil, nil\n\t}\n\n\tid := generateID(\"apply-\")\n\turl := fmt.Sprintf(\"https://app.terraform.io/_archivist/%s\", id)\n\n\ta := &tfe.Apply{\n\t\tID:         id,\n\t\tLogReadURL: url,\n\t\tStatus:     tfe.ApplyPending,\n\t}\n\n\tw, ok := m.client.Workspaces.workspaceIDs[workspaceID]\n\tif !ok {\n\t\treturn nil, tfe.ErrResourceNotFound\n\t}\n\n\tif w.AutoApply {\n\t\ta.Status = tfe.ApplyRunning\n\t}\n\n\tm.logs[url] = filepath.Join(\n\t\tm.client.ConfigurationVersions.uploadPaths[cvID],\n\t\tw.WorkingDirectory,\n\t\t\"apply.log\",\n\t)\n\tm.applies[a.ID] = a\n\n\treturn a, nil\n}", "category": "Python"}, {"instruction": "// create creates log group and log stream for the instance of the awslogs logging driver", "input": "go language", "output": "func (l *logStream) create() error {\n\tif err := l.createLogStream(); err != nil {\n\t\tif l.logCreateGroup {\n\t\t\tif awsErr, ok := err.(awserr.Error); ok && awsErr.Code() == resourceNotFoundCode {\n\t\t\t\tif err := l.createLogGroup(); err != nil {\n\t\t\t\t\treturn errors.Wrap(err, \"failed to create Cloudwatch log group\")\n\t\t\t\t}\n\t\t\t\terr := l.createLogStream()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn errors.Wrap(err, \"failed to create Cloudwatch log stream\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to create Cloudwatch log stream\")\n\t\t}\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// peek creates the next state of the iterator.", "input": "go language", "output": "func (it *nodeIterator) peek(descend bool) (*nodeIteratorState, *int, []byte, error) {\n\tif len(it.stack) == 0 {\n\t\t// Initialize the iterator if we've just started.\n\t\troot := it.trie.Hash()\n\t\tstate := &nodeIteratorState{node: it.trie.root, index: -1}\n\t\tif root != emptyRoot {\n\t\t\tstate.hash = root\n\t\t}\n\t\terr := state.resolve(it.trie, nil)\n\t\treturn state, nil, nil, err\n\t}\n\tif !descend {\n\t\t// If we're skipping children, pop the current node first\n\t\tit.pop()\n\t}\n\n\t// Continue iteration to the next child\n\tfor len(it.stack) > 0 {\n\t\tparent := it.stack[len(it.stack)-1]\n\t\tancestor := parent.hash\n\t\tif (ancestor == common.Hash{}) {\n\t\t\tancestor = parent.parent\n\t\t}\n\t\tstate, path, ok := it.nextChild(parent, ancestor)\n\t\tif ok {\n\t\t\tif err := state.resolve(it.trie, path); err != nil {\n\t\t\t\treturn parent, &parent.index, path, err\n\t\t\t}\n\t\t\treturn state, &parent.index, path, nil\n\t\t}\n\t\t// No more child nodes, move back up.\n\t\tit.pop()\n\t}\n\treturn nil, nil, nil, errIteratorEnd\n}", "category": "Python"}, {"instruction": "// CompileExecutePreparedStmt compiles a session Execute command to a stmt.Statement.", "input": "go language", "output": "func CompileExecutePreparedStmt(ctx sessionctx.Context, ID uint32, args ...interface{}) (sqlexec.Statement, error) {\n\texecStmt := &ast.ExecuteStmt{ExecID: ID}\n\tif err := ResetContextOfStmt(ctx, execStmt); err != nil {\n\t\treturn nil, err\n\t}\n\texecStmt.UsingVars = make([]ast.ExprNode, len(args))\n\tfor i, val := range args {\n\t\texecStmt.UsingVars[i] = ast.NewValueExpr(val)\n\t}\n\tis := GetInfoSchema(ctx)\n\texecPlan, err := planner.Optimize(ctx, execStmt, is)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstmt := &ExecStmt{\n\t\tInfoSchema: is,\n\t\tPlan:       execPlan,\n\t\tStmtNode:   execStmt,\n\t\tCtx:        ctx,\n\t}\n\tif prepared, ok := ctx.GetSessionVars().PreparedStmts[ID]; ok {\n\t\tstmt.Text = prepared.Stmt.Text()\n\t\tctx.GetSessionVars().StmtCtx.OriginalSQL = stmt.Text\n\t}\n\treturn stmt, nil\n}", "category": "Python"}, {"instruction": "// eachListChunk fetches runtimeObject list chunks using this ListPager and invokes fn on each list\n// chunk. If fn returns an error, processing stops and that error is returned. If fn does not return\n// an error, any error encountered while retrieving the list from the server is returned. If the\n// context cancels or times out, the context error is returned. Since the list is retrieved in\n// paginated chunks, an \"Expired\" error (metav1.StatusReasonExpired) may be returned if the\n// pagination list requests exceed the expiration limit of the apiserver being called.", "input": "go language", "output": "func (p *ListPager) eachListChunk(ctx context.Context, options metav1.ListOptions, fn func(obj runtime.Object) error) error {\n\tif options.Limit == 0 {\n\t\toptions.Limit = p.PageSize\n\t}\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tobj, err := p.PageFn(ctx, options)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tm, err := meta.ListAccessor(obj)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"returned object must be a list: %v\", err)\n\t\t}\n\t\tif err := fn(obj); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// if we have no more items, return.\n\t\tif len(m.GetContinue()) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\t// set the next loop up\n\t\toptions.Continue = m.GetContinue()\n\t}\n}", "category": "Python"}, {"instruction": "// ReadReceipt retrieves a specific transaction receipt from the database, along with\n// its added positional metadata.", "input": "go language", "output": "func ReadReceipt(db ethdb.Reader, hash common.Hash, config *params.ChainConfig) (*types.Receipt, common.Hash, uint64, uint64) {\n\t// Retrieve the context of the receipt based on the transaction hash\n\tblockNumber := ReadTxLookupEntry(db, hash)\n\tif blockNumber == nil {\n\t\treturn nil, common.Hash{}, 0, 0\n\t}\n\tblockHash := ReadCanonicalHash(db, *blockNumber)\n\tif blockHash == (common.Hash{}) {\n\t\treturn nil, common.Hash{}, 0, 0\n\t}\n\t// Read all the receipts from the block and return the one with the matching hash\n\treceipts := ReadReceipts(db, blockHash, *blockNumber, config)\n\tfor receiptIndex, receipt := range receipts {\n\t\tif receipt.TxHash == hash {\n\t\t\treturn receipt, blockHash, *blockNumber, uint64(receiptIndex)\n\t\t}\n\t}\n\tlog.Error(\"Receipt not found\", \"number\", blockNumber, \"hash\", blockHash, \"txhash\", hash)\n\treturn nil, common.Hash{}, 0, 0\n}", "category": "Python"}, {"instruction": "// handleMultiplexV2 is used to multiplex a single incoming connection\n// using the Yamux multiplexer", "input": "go language", "output": "func (s *Server) handleMultiplexV2(conn net.Conn) {\n\tdefer conn.Close()\n\tconf := yamux.DefaultConfig()\n\tconf.LogOutput = s.config.LogOutput\n\tserver, _ := yamux.Server(conn, conf)\n\tfor {\n\t\tsub, err := server.Accept()\n\t\tif err != nil {\n\t\t\tif err != io.EOF {\n\t\t\t\ts.logger.Printf(\"[ERR] consul.rpc: multiplex conn accept failed: %v %s\", err, logConn(conn))\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tgo s.handleConsulConn(sub)\n\t}\n}", "category": "Python"}, {"instruction": "// Update implements Aggregation interface.", "input": "go language", "output": "func (mmf *maxMinFunction) Update(evalCtx *AggEvaluateContext, sc *stmtctx.StatementContext, row chunk.Row) error {\n\ta := mmf.Args[0]\n\tvalue, err := a.Eval(row)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif evalCtx.Value.IsNull() {\n\t\tevalCtx.Value = *(&value).Copy()\n\t}\n\tif value.IsNull() {\n\t\treturn nil\n\t}\n\tvar c int\n\tc, err = evalCtx.Value.CompareDatum(sc, &value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif (mmf.isMax && c == -1) || (!mmf.isMax && c == 1) {\n\t\tevalCtx.Value = *(&value).Copy()\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// GetCgroupCPUAndMemoryStats returns the CPU and memory stats of the cgroup with the cgroupName. Note that\n// this function doesn't generate filesystem stats.", "input": "go language", "output": "func (p *StatsProvider) GetCgroupCPUAndMemoryStats(cgroupName string, updateStats bool) (*statsapi.ContainerStats, error) {\n\tinfo, err := getCgroupInfo(p.cadvisor, cgroupName, updateStats)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get cgroup stats for %q: %v\", cgroupName, err)\n\t}\n\t// Rootfs and imagefs doesn't make sense for raw cgroup.\n\ts := cadvisorInfoToContainerCPUAndMemoryStats(cgroupName, info)\n\treturn s, nil\n}", "category": "Python"}, {"instruction": "// Init returns a new VFS driver.\n// This sets the home directory for the driver and returns NaiveDiffDriver.", "input": "go language", "output": "func Init(home string, options []string, uidMaps, gidMaps []idtools.IDMap) (graphdriver.Driver, error) {\n\td := &Driver{\n\t\thome:      home,\n\t\tidMapping: idtools.NewIDMappingsFromMaps(uidMaps, gidMaps),\n\t}\n\n\tif err := d.parseOptions(options); err != nil {\n\t\treturn nil, err\n\t}\n\n\trootIDs := d.idMapping.RootPair()\n\tif err := idtools.MkdirAllAndChown(home, 0700, rootIDs); err != nil {\n\t\treturn nil, err\n\t}\n\n\tsetupDriverQuota(d)\n\n\tif size := d.getQuotaOpt(); !d.quotaSupported() && size > 0 {\n\t\treturn nil, quota.ErrQuotaNotSupported\n\t}\n\n\treturn graphdriver.NewNaiveDiffDriver(d, uidMaps, gidMaps), nil\n}", "category": "Python"}, {"instruction": "// createLogGroup creates a log group for the instance of the awslogs logging driver", "input": "go language", "output": "func (l *logStream) createLogGroup() error {\n\tif _, err := l.client.CreateLogGroup(&cloudwatchlogs.CreateLogGroupInput{\n\t\tLogGroupName: aws.String(l.logGroupName),\n\t}); err != nil {\n\t\tif awsErr, ok := err.(awserr.Error); ok {\n\t\t\tfields := logrus.Fields{\n\t\t\t\t\"errorCode\":      awsErr.Code(),\n\t\t\t\t\"message\":        awsErr.Message(),\n\t\t\t\t\"origError\":      awsErr.OrigErr(),\n\t\t\t\t\"logGroupName\":   l.logGroupName,\n\t\t\t\t\"logCreateGroup\": l.logCreateGroup,\n\t\t\t}\n\t\t\tif awsErr.Code() == resourceAlreadyExistsCode {\n\t\t\t\t// Allow creation to succeed\n\t\t\t\tlogrus.WithFields(fields).Info(\"Log group already exists\")\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tlogrus.WithFields(fields).Error(\"Failed to create log group\")\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// StartRecordingToSink starts sending events received from the specified eventBroadcaster to the given sink.\n// The return value can be ignored or used to stop recording, if desired.\n// TODO: make me an object with parameterizable queue length and retry interval", "input": "go language", "output": "func (eventBroadcaster *eventBroadcasterImpl) StartRecordingToSink(sink EventSink) watch.Interface {\n\t// The default math/rand package functions aren't thread safe, so create a\n\t// new Rand object for each StartRecording call.\n\trandGen := rand.New(rand.NewSource(time.Now().UnixNano()))\n\teventCorrelator := NewEventCorrelatorWithOptions(eventBroadcaster.options)\n\treturn eventBroadcaster.StartEventWatcher(\n\t\tfunc(event *v1.Event) {\n\t\t\trecordToSink(sink, event, eventCorrelator, randGen, eventBroadcaster.sleepDuration)\n\t\t})\n}", "category": "Python"}, {"instruction": "// evalTime evals DATE(expr).\n// See https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_date", "input": "go language", "output": "func (b *builtinDateSig) evalTime(row chunk.Row) (types.Time, bool, error) {\n\texpr, isNull, err := b.args[0].EvalTime(b.ctx, row)\n\tif isNull || err != nil {\n\t\treturn types.Time{}, true, handleInvalidTimeError(b.ctx, err)\n\t}\n\n\tif expr.IsZero() {\n\t\treturn types.Time{}, true, handleInvalidTimeError(b.ctx, types.ErrIncorrectDatetimeValue.GenWithStackByArgs(expr.String()))\n\t}\n\n\texpr.Time = types.FromDate(expr.Time.Year(), expr.Time.Month(), expr.Time.Day(), 0, 0, 0, 0)\n\texpr.Type = mysql.TypeDate\n\treturn expr, false, nil\n}", "category": "Python"}, {"instruction": "// Collect implements prometheus.Collector\n// Since new containers are frequently created and removed, using the prometheus.Gauge Collector would\n// leak metric collectors for containers or pods that no longer exist.  Instead, implement\n// prometheus.Collector in a way that only collects metrics for active containers.", "input": "go language", "output": "func (rc *resourceMetricCollector) Collect(ch chan<- prometheus.Metric) {\n\trc.errors.Set(0)\n\tdefer rc.errors.Collect(ch)\n\tsummary, err := rc.provider.GetCPUAndMemoryStats()\n\tif err != nil {\n\t\trc.errors.Set(1)\n\t\tklog.Warningf(\"Error getting summary for resourceMetric prometheus endpoint: %v\", err)\n\t\treturn\n\t}\n\n\tfor _, metric := range rc.config.NodeMetrics {\n\t\tif value, timestamp := metric.ValueFn(summary.Node); value != nil {\n\t\t\tch <- prometheus.NewMetricWithTimestamp(timestamp,\n\t\t\t\tprometheus.MustNewConstMetric(metric.desc(), prometheus.GaugeValue, *value))\n\t\t}\n\t}\n\n\tfor _, pod := range summary.Pods {\n\t\tfor _, container := range pod.Containers {\n\t\t\tfor _, metric := range rc.config.ContainerMetrics {\n\t\t\t\tif value, timestamp := metric.ValueFn(container); value != nil {\n\t\t\t\t\tch <- prometheus.NewMetricWithTimestamp(timestamp,\n\t\t\t\t\t\tprometheus.MustNewConstMetric(metric.desc(), prometheus.GaugeValue, *value, container.Name, pod.PodRef.Name, pod.PodRef.Namespace))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// AddFlags adds flags for the insecure serving options.", "input": "go language", "output": "func (o *CombinedInsecureServingOptions) AddFlags(fs *pflag.FlagSet) {\n\tif o == nil {\n\t\treturn\n\t}\n\n\tfs.StringVar(&o.BindAddress, \"address\", o.BindAddress, \"DEPRECATED: the IP address on which to listen for the --port port (set to 0.0.0.0 for all IPv4 interfaces and :: for all IPv6 interfaces). See --bind-address instead.\")\n\t// MarkDeprecated hides the flag from the help. We don't want that:\n\t// fs.MarkDeprecated(\"address\", \"see --bind-address instead.\")\n\tfs.IntVar(&o.BindPort, \"port\", o.BindPort, \"DEPRECATED: the port on which to serve HTTP insecurely without authentication and authorization. If 0, don't serve HTTPS at all. See --secure-port instead.\")\n\t// MarkDeprecated hides the flag from the help. We don't want that:\n\t// fs.MarkDeprecated(\"port\", \"see --secure-port instead.\")\n}", "category": "Python"}, {"instruction": "// defaultProxyCommand returns the default Connect managed proxy command.", "input": "go language", "output": "func defaultProxyCommand(agentCfg *config.RuntimeConfig) ([]string, error) {\n\t// Get the path to the current executable. This is cached once by the\n\t// library so this is effectively just a variable read.\n\texecPath, err := os.Executable()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// \"consul connect proxy\" default value for managed daemon proxy\n\tcmd := []string{execPath, \"connect\", \"proxy\"}\n\n\tif agentCfg != nil && agentCfg.LogLevel != \"INFO\" {\n\t\tcmd = append(cmd, \"-log-level\", agentCfg.LogLevel)\n\t}\n\treturn cmd, nil\n}", "category": "Python"}, {"instruction": "// TryLoadCertFromDisk tries to load the cert from the disk and validates that it is valid", "input": "go language", "output": "func TryLoadCertFromDisk(pkiPath, name string) (*x509.Certificate, error) {\n\tcertificatePath := pathForCert(pkiPath, name)\n\n\tcerts, err := certutil.CertsFromFile(certificatePath)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"couldn't load the certificate file %s\", certificatePath)\n\t}\n\n\t// We are only putting one certificate in the certificate pem file, so it's safe to just pick the first one\n\t// TODO: Support multiple certs here in order to be able to rotate certs\n\tcert := certs[0]\n\n\t// Check so that the certificate is valid now\n\tnow := time.Now()\n\tif now.Before(cert.NotBefore) {\n\t\treturn nil, errors.New(\"the certificate is not valid yet\")\n\t}\n\tif now.After(cert.NotAfter) {\n\t\treturn nil, errors.New(\"the certificate has expired\")\n\t}\n\n\treturn cert, nil\n}", "category": "Python"}, {"instruction": "// InstallRelease creates a release using kubeClient.Create", "input": "go language", "output": "func (r *ReleaseModuleServiceServer) InstallRelease(ctx context.Context, in *rudderAPI.InstallReleaseRequest) (*rudderAPI.InstallReleaseResponse, error) {\n\tgrpclog.Print(\"install\")\n\tb := bytes.NewBufferString(in.Release.Manifest)\n\terr := kubeClient.Create(in.Release.Namespace, b, 500, false)\n\tif err != nil {\n\t\tgrpclog.Printf(\"error when creating release: %v\", err)\n\t}\n\treturn &rudderAPI.InstallReleaseResponse{}, err\n}", "category": "Python"}, {"instruction": "// GetSecrets returns all secrets of a managed swarm cluster.", "input": "go language", "output": "func (c *Cluster) GetSecrets(options apitypes.SecretListOptions) ([]types.Secret, error) {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tstate := c.currentNodeState()\n\tif !state.IsActiveManager() {\n\t\treturn nil, c.errNoManager(state)\n\t}\n\n\tfilters, err := newListSecretsFilters(options.Filters)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tctx, cancel := c.getRequestContext()\n\tdefer cancel()\n\n\tr, err := state.controlClient.ListSecrets(ctx,\n\t\t&swarmapi.ListSecretsRequest{Filters: filters})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsecrets := make([]types.Secret, 0, len(r.Secrets))\n\n\tfor _, secret := range r.Secrets {\n\t\tsecrets = append(secrets, convert.SecretFromGRPC(secret))\n\t}\n\n\treturn secrets, nil\n}", "category": "Python"}, {"instruction": "// InWritableDir calls fn(path), while making sure that the directory\n// containing `path` is writable for the duration of the call.", "input": "go language", "output": "func InWritableDir(fn func(string) error, fs fs.Filesystem, path string) error {\n\tdir := filepath.Dir(path)\n\tinfo, err := fs.Stat(dir)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !info.IsDir() {\n\t\treturn errors.New(\"Not a directory: \" + path)\n\t}\n\tif info.Mode()&0200 == 0 {\n\t\t// A non-writeable directory (for this user; we assume that's the\n\t\t// relevant part). Temporarily change the mode so we can delete the\n\t\t// file or directory inside it.\n\t\terr = fs.Chmod(dir, 0755)\n\t\tif err == nil {\n\t\t\tdefer func() {\n\t\t\t\terr = fs.Chmod(dir, info.Mode())\n\t\t\t\tif err != nil {\n\t\t\t\t\t// We managed to change the permission bits like a\n\t\t\t\t\t// millisecond ago, so it'd be bizarre if we couldn't\n\t\t\t\t\t// change it back.\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t}\n\n\treturn fn(path)\n}", "category": "Python"}, {"instruction": "// PruneCache removes all cached build sources", "input": "go language", "output": "func (b *Backend) PruneCache(ctx context.Context, opts types.BuildCachePruneOptions) (*types.BuildCachePruneReport, error) {\n\teg, ctx := errgroup.WithContext(ctx)\n\n\tvar fsCacheSize uint64\n\teg.Go(func() error {\n\t\tvar err error\n\t\tfsCacheSize, err = b.fsCache.Prune(ctx)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to prune fscache\")\n\t\t}\n\t\treturn nil\n\t})\n\n\tvar buildCacheSize int64\n\tvar cacheIDs []string\n\teg.Go(func() error {\n\t\tvar err error\n\t\tbuildCacheSize, cacheIDs, err = b.buildkit.Prune(ctx, opts)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to prune build cache\")\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err := eg.Wait(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &types.BuildCachePruneReport{SpaceReclaimed: fsCacheSize + uint64(buildCacheSize), CachesDeleted: cacheIDs}, nil\n}", "category": "Python"}, {"instruction": "// ClientIP implements a best effort algorithm to return the real client IP, it parses\n// X-Real-IP and X-Forwarded-For in order to work properly with reverse-proxies such us: nginx or haproxy.\n// Use X-Forwarded-For before X-Real-Ip as nginx uses X-Real-Ip with the proxy's IP.", "input": "go language", "output": "func (c *Context) ClientIP() string {\n\tif c.engine.ForwardedByClientIP {\n\t\tclientIP := c.requestHeader(\"X-Forwarded-For\")\n\t\tclientIP = strings.TrimSpace(strings.Split(clientIP, \",\")[0])\n\t\tif clientIP == \"\" {\n\t\t\tclientIP = strings.TrimSpace(c.requestHeader(\"X-Real-Ip\"))\n\t\t}\n\t\tif clientIP != \"\" {\n\t\t\treturn clientIP\n\t\t}\n\t}\n\n\tif c.engine.AppEngine {\n\t\tif addr := c.requestHeader(\"X-Appengine-Remote-Addr\"); addr != \"\" {\n\t\t\treturn addr\n\t\t}\n\t}\n\n\tif ip, _, err := net.SplitHostPort(strings.TrimSpace(c.Request.RemoteAddr)); err == nil {\n\t\treturn ip\n\t}\n\n\treturn \"\"\n}", "category": "Python"}, {"instruction": "// ObjectValueID takes a value that is assumed to be an object representation\n// of some resource instance object and attempts to heuristically find an\n// attribute of it that is likely to be a unique identifier in the remote\n// system that it belongs to which will be useful to the user.\n//\n// If such an attribute is found, its name and string value intended for\n// display are returned. Both returned strings are empty if no such attribute\n// exists, in which case the caller should assume that the resource instance\n// address within the Terraform configuration is the best available identifier.\n//\n// This is only a best-effort sort of thing, relying on naming conventions in\n// our resource type schemas. The result is not guaranteed to be unique, but\n// should generally be suitable for display to an end-user anyway.\n//\n// This function will panic if the given value is not of an object type.", "input": "go language", "output": "func ObjectValueID(obj cty.Value) (k, v string) {\n\tif obj.IsNull() || !obj.IsKnown() {\n\t\treturn \"\", \"\"\n\t}\n\n\tatys := obj.Type().AttributeTypes()\n\n\tswitch {\n\n\tcase atys[\"id\"] == cty.String:\n\t\tv := obj.GetAttr(\"id\")\n\t\tif v.IsKnown() && !v.IsNull() {\n\t\t\treturn \"id\", v.AsString()\n\t\t}\n\n\tcase atys[\"name\"] == cty.String:\n\t\t// \"name\" isn't always globally unique, but if there isn't also an\n\t\t// \"id\" then it _often_ is, in practice.\n\t\tv := obj.GetAttr(\"name\")\n\t\tif v.IsKnown() && !v.IsNull() {\n\t\t\treturn \"name\", v.AsString()\n\t\t}\n\t}\n\n\treturn \"\", \"\"\n}", "category": "Python"}, {"instruction": "// doCleanupMountPoint unmounts the given path and\n// deletes the remaining directory if successful.\n// if extensiveMountPointCheck is true\n// IsNotMountPoint will be called instead of IsLikelyNotMountPoint.\n// IsNotMountPoint is more expensive but properly handles bind mounts within the same fs.\n// if corruptedMnt is true, it means that the mountPath is a corrupted mountpoint, and the mount point check\n// will be skipped", "input": "go language", "output": "func doCleanupMountPoint(mountPath string, mounter Interface, extensiveMountPointCheck bool, corruptedMnt bool) error {\n\tif !corruptedMnt {\n\t\tvar notMnt bool\n\t\tvar err error\n\t\tif extensiveMountPointCheck {\n\t\t\tnotMnt, err = IsNotMountPoint(mounter, mountPath)\n\t\t} else {\n\t\t\tnotMnt, err = mounter.IsLikelyNotMountPoint(mountPath)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif notMnt {\n\t\t\tklog.Warningf(\"Warning: %q is not a mountpoint, deleting\", mountPath)\n\t\t\treturn os.Remove(mountPath)\n\t\t}\n\t}\n\n\t// Unmount the mount path\n\tklog.V(4).Infof(\"%q is a mountpoint, unmounting\", mountPath)\n\tif err := mounter.Unmount(mountPath); err != nil {\n\t\treturn err\n\t}\n\n\tnotMnt, mntErr := mounter.IsLikelyNotMountPoint(mountPath)\n\tif mntErr != nil {\n\t\treturn mntErr\n\t}\n\tif notMnt {\n\t\tklog.V(4).Infof(\"%q is unmounted, deleting the directory\", mountPath)\n\t\treturn os.Remove(mountPath)\n\t}\n\treturn fmt.Errorf(\"Failed to unmount path %v\", mountPath)\n}", "category": "Python"}, {"instruction": "// Filter iterates over the list of transactions and removes all of them for which\n// the specified function evaluates to true.", "input": "go language", "output": "func (m *txSortedMap) Filter(filter func(*types.Transaction) bool) types.Transactions {\n\tvar removed types.Transactions\n\n\t// Collect all the transactions to filter out\n\tfor nonce, tx := range m.items {\n\t\tif filter(tx) {\n\t\t\tremoved = append(removed, tx)\n\t\t\tdelete(m.items, nonce)\n\t\t}\n\t}\n\t// If transactions were removed, the heap and cache are ruined\n\tif len(removed) > 0 {\n\t\t*m.index = make([]uint64, 0, len(m.items))\n\t\tfor nonce := range m.items {\n\t\t\t*m.index = append(*m.index, nonce)\n\t\t}\n\t\theap.Init(m.index)\n\n\t\tm.cache = nil\n\t}\n\treturn removed\n}", "category": "Python"}, {"instruction": "// GetByKey is never guaranteed to return back the value set in Mutation.  It could be paged out, it could\n// be older than another copy, the backingCache may be more recent or, you might have written twice into the same key.\n// You get a value that was valid at some snapshot of time and will always return the newer of backingCache and mutationCache.", "input": "go language", "output": "func (c *mutationCache) GetByKey(key string) (interface{}, bool, error) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tobj, exists, err := c.backingCache.GetByKey(key)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tif !exists {\n\t\tif !c.includeAdds {\n\t\t\t// we can't distinguish between, \"didn't observe create\" and \"was deleted after create\", so\n\t\t\t// if the key is missing, we always return it as missing\n\t\t\treturn nil, false, nil\n\t\t}\n\t\tobj, exists = c.mutationCache.Get(key)\n\t\tif !exists {\n\t\t\treturn nil, false, nil\n\t\t}\n\t}\n\tobjRuntime, ok := obj.(runtime.Object)\n\tif !ok {\n\t\treturn obj, true, nil\n\t}\n\treturn c.newerObject(key, objRuntime), true, nil\n}", "category": "Python"}, {"instruction": "// DoMakeRShared is common implementation of MakeRShared on Linux. It checks if\n// path is shared and bind-mounts it as rshared if needed. mountCmd and\n// mountArgs are expected to contain mount-like command, DoMakeRShared will add\n// '--bind <path> <path>' and '--make-rshared <path>' to mountArgs.", "input": "go language", "output": "func DoMakeRShared(path string, mountInfoFilename string) error {\n\tshared, err := isShared(path, mountInfoFilename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif shared {\n\t\tklog.V(4).Infof(\"Directory %s is already on a shared mount\", path)\n\t\treturn nil\n\t}\n\n\tklog.V(2).Infof(\"Bind-mounting %q with shared mount propagation\", path)\n\t// mount --bind /var/lib/kubelet /var/lib/kubelet\n\tif err := syscall.Mount(path, path, \"\" /*fstype*/, syscall.MS_BIND, \"\" /*data*/); err != nil {\n\t\treturn fmt.Errorf(\"failed to bind-mount %s: %v\", path, err)\n\t}\n\n\t// mount --make-rshared /var/lib/kubelet\n\tif err := syscall.Mount(path, path, \"\" /*fstype*/, syscall.MS_SHARED|syscall.MS_REC, \"\" /*data*/); err != nil {\n\t\treturn fmt.Errorf(\"failed to make %s rshared: %v\", path, err)\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// AddImagesCommonConfigFlags adds the flags that configure kubeadm (and affect the images kubeadm will use)", "input": "go language", "output": "func AddImagesCommonConfigFlags(flagSet *flag.FlagSet, cfg *kubeadmapiv1beta2.InitConfiguration, cfgPath *string, featureGatesString *string) {\n\toptions.AddKubernetesVersionFlag(flagSet, &cfg.ClusterConfiguration.KubernetesVersion)\n\toptions.AddFeatureGatesStringFlag(flagSet, featureGatesString)\n\toptions.AddImageMetaFlags(flagSet, &cfg.ImageRepository)\n\tflagSet.StringVar(cfgPath, \"config\", *cfgPath, \"Path to kubeadm config file.\")\n}", "category": "Python"}, {"instruction": "// podKiller launches a goroutine to kill a pod received from the channel if\n// another goroutine isn't already in action.", "input": "go language", "output": "func (kl *Kubelet) podKiller() {\n\tkilling := sets.NewString()\n\t// guard for the killing set\n\tlock := sync.Mutex{}\n\tfor podPair := range kl.podKillingCh {\n\t\trunningPod := podPair.RunningPod\n\t\tapiPod := podPair.APIPod\n\n\t\tlock.Lock()\n\t\texists := killing.Has(string(runningPod.ID))\n\t\tif !exists {\n\t\t\tkilling.Insert(string(runningPod.ID))\n\t\t}\n\t\tlock.Unlock()\n\n\t\tif !exists {\n\t\t\tgo func(apiPod *v1.Pod, runningPod *kubecontainer.Pod) {\n\t\t\t\tklog.V(2).Infof(\"Killing unwanted pod %q\", runningPod.Name)\n\t\t\t\terr := kl.killPod(apiPod, runningPod, nil, nil)\n\t\t\t\tif err != nil {\n\t\t\t\t\tklog.Errorf(\"Failed killing the pod %q: %v\", runningPod.Name, err)\n\t\t\t\t}\n\t\t\t\tlock.Lock()\n\t\t\t\tkilling.Delete(string(runningPod.ID))\n\t\t\t\tlock.Unlock()\n\t\t\t}(apiPod, runningPod)\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// newTerminalPrompter creates a liner based user input prompter working off the\n// standard input and output streams.", "input": "go language", "output": "func newTerminalPrompter() *terminalPrompter {\n\tp := new(terminalPrompter)\n\t// Get the original mode before calling NewLiner.\n\t// This is usually regular \"cooked\" mode where characters echo.\n\tnormalMode, _ := liner.TerminalMode()\n\t// Turn on liner. It switches to raw mode.\n\tp.State = liner.NewLiner()\n\trawMode, err := liner.TerminalMode()\n\tif err != nil || !liner.TerminalSupported() {\n\t\tp.supported = false\n\t} else {\n\t\tp.supported = true\n\t\tp.normalMode = normalMode\n\t\tp.rawMode = rawMode\n\t\t// Switch back to normal mode while we're not prompting.\n\t\tnormalMode.ApplyMode()\n\t}\n\tp.SetCtrlCAborts(true)\n\tp.SetTabCompletionStyle(liner.TabPrints)\n\tp.SetMultiLineMode(true)\n\treturn p\n}", "category": "Python"}, {"instruction": "// Next moves the cursor to next block and returns true iff the iterator is not exhausted", "input": "go language", "output": "func (itr *blocksItr) Next() (ledger.QueryResult, error) {\n\tif itr.maxBlockNumAvailable < itr.blockNumToRetrieve {\n\t\titr.maxBlockNumAvailable = itr.waitForBlock(itr.blockNumToRetrieve)\n\t}\n\titr.closeMarkerLock.Lock()\n\tdefer itr.closeMarkerLock.Unlock()\n\tif itr.closeMarker {\n\t\treturn nil, nil\n\t}\n\tif itr.stream == nil {\n\t\tlogger.Debugf(\"Initializing block stream for iterator. itr.maxBlockNumAvailable=%d\", itr.maxBlockNumAvailable)\n\t\tif err := itr.initStream(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tnextBlockBytes, err := itr.stream.nextBlockBytes()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\titr.blockNumToRetrieve++\n\treturn deserializeBlock(nextBlockBytes)\n}", "category": "Python"}, {"instruction": "// UnlockAccount will unlock the account associated with the given address with\n// the given password for duration seconds. If duration is nil it will use a\n// default of 300 seconds. It returns an indication if the account was unlocked.", "input": "go language", "output": "func (s *PrivateAccountAPI) UnlockAccount(ctx context.Context, addr common.Address, password string, duration *uint64) (bool, error) {\n\t// When the API is exposed by external RPC(http, ws etc), unless the user\n\t// explicitly specifies to allow the insecure account unlocking, otherwise\n\t// it is disabled.\n\tif s.b.ExtRPCEnabled() && !s.b.AccountManager().Config().InsecureUnlockAllowed {\n\t\treturn false, errors.New(\"account unlock with HTTP access is forbidden\")\n\t}\n\n\tconst max = uint64(time.Duration(math.MaxInt64) / time.Second)\n\tvar d time.Duration\n\tif duration == nil {\n\t\td = 300 * time.Second\n\t} else if *duration > max {\n\t\treturn false, errors.New(\"unlock duration too large\")\n\t} else {\n\t\td = time.Duration(*duration) * time.Second\n\t}\n\terr := fetchKeystore(s.am).TimedUnlock(accounts.Account{Address: addr}, password, d)\n\tif err != nil {\n\t\tlog.Warn(\"Failed account unlock attempt\", \"address\", addr, \"err\", err)\n\t}\n\treturn err == nil, err\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *ObjectMetricStatus) DeepCopyInto(out *ObjectMetricStatus) {\n\t*out = *in\n\tout.Target = in.Target\n\tout.CurrentValue = in.CurrentValue.DeepCopy()\n\tif in.Selector != nil {\n\t\tin, out := &in.Selector, &out.Selector\n\t\t*out = new(v1.LabelSelector)\n\t\t(*in).DeepCopyInto(*out)\n\t}\n\tif in.AverageValue != nil {\n\t\tin, out := &in.AverageValue, &out.AverageValue\n\t\tx := (*in).DeepCopy()\n\t\t*out = &x\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// cleanupAssumedPods exists for making test deterministic by taking time as input argument.", "input": "go language", "output": "func (cache *schedulerCache) cleanupAssumedPods(now time.Time) {\n\tcache.mu.Lock()\n\tdefer cache.mu.Unlock()\n\n\t// The size of assumedPods should be small\n\tfor key := range cache.assumedPods {\n\t\tps, ok := cache.podStates[key]\n\t\tif !ok {\n\t\t\tpanic(\"Key found in assumed set but not in podStates. Potentially a logical error.\")\n\t\t}\n\t\tif !ps.bindingFinished {\n\t\t\tklog.V(3).Infof(\"Couldn't expire cache for pod %v/%v. Binding is still in progress.\",\n\t\t\t\tps.pod.Namespace, ps.pod.Name)\n\t\t\tcontinue\n\t\t}\n\t\tif now.After(*ps.deadline) {\n\t\t\tklog.Warningf(\"Pod %s/%s expired\", ps.pod.Namespace, ps.pod.Name)\n\t\t\tif err := cache.expirePod(key, ps); err != nil {\n\t\t\t\tklog.Errorf(\"ExpirePod failed for %s: %v\", key, err)\n\t\t\t}\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// New creates a function that can be used\n// to inject a script tag for the livereload JavaScript in a HTML document.", "input": "go language", "output": "func New(port int) transform.Transformer {\n\treturn func(ft transform.FromTo) error {\n\t\tb := ft.From().Bytes()\n\t\tendBodyTag := \"</body>\"\n\t\tmatch := []byte(endBodyTag)\n\t\treplaceTemplate := `<script data-no-instant>document.write('<script src=\"/livereload.js?port=%d&mindelay=10\"></' + 'script>')</script>%s`\n\t\treplace := []byte(fmt.Sprintf(replaceTemplate, port, endBodyTag))\n\n\t\tnewcontent := bytes.Replace(b, match, replace, 1)\n\t\tif len(newcontent) == len(b) {\n\t\t\tendBodyTag = \"</BODY>\"\n\t\t\treplace := []byte(fmt.Sprintf(replaceTemplate, port, endBodyTag))\n\t\t\tmatch := []byte(endBodyTag)\n\t\t\tnewcontent = bytes.Replace(b, match, replace, 1)\n\t\t}\n\n\t\tif _, err := ft.To().Write(newcontent); err != nil {\n\t\t\thelpers.DistinctWarnLog.Println(\"Failed to inject LiveReload script:\", err)\n\t\t}\n\t\treturn nil\n\t}\n}", "category": "Python"}, {"instruction": "// ParseHost and set defaults for a Daemon host string.\n// defaultToTLS is preferred over defaultToUnixXDG.", "input": "go language", "output": "func ParseHost(defaultToTLS, defaultToUnixXDG bool, val string) (string, error) {\n\thost := strings.TrimSpace(val)\n\tif host == \"\" {\n\t\tif defaultToTLS {\n\t\t\thost = DefaultTLSHost\n\t\t} else if defaultToUnixXDG {\n\t\t\truntimeDir, err := homedir.GetRuntimeDir()\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\tsocket := filepath.Join(runtimeDir, \"docker.sock\")\n\t\t\thost = \"unix://\" + socket\n\t\t} else {\n\t\t\thost = DefaultHost\n\t\t}\n\t} else {\n\t\tvar err error\n\t\thost, err = parseDaemonHost(host)\n\t\tif err != nil {\n\t\t\treturn val, err\n\t\t}\n\t}\n\treturn host, nil\n}", "category": "Python"}, {"instruction": "// NewV1Endpoint parses the given address to return a registry endpoint.", "input": "go language", "output": "func NewV1Endpoint(index *registrytypes.IndexInfo, userAgent string, metaHeaders http.Header) (*V1Endpoint, error) {\n\ttlsConfig, err := newTLSConfig(index.Name, index.Secure)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tendpoint, err := newV1EndpointFromStr(GetAuthConfigKey(index), tlsConfig, userAgent, metaHeaders)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := validateEndpoint(endpoint); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn endpoint, nil\n}", "category": "Python"}, {"instruction": "// NewTransaction creates a new transaction with the given properties. Contracts\n// can be created by transacting with a nil recipient.", "input": "go language", "output": "func NewTransaction(nonce int64, to *Address, amount *BigInt, gasLimit int64, gasPrice *BigInt, data []byte) *Transaction {\n\tif to == nil {\n\t\treturn &Transaction{types.NewContractCreation(uint64(nonce), amount.bigint, uint64(gasLimit), gasPrice.bigint, common.CopyBytes(data))}\n\t}\n\treturn &Transaction{types.NewTransaction(uint64(nonce), to.address, amount.bigint, uint64(gasLimit), gasPrice.bigint, common.CopyBytes(data))}\n}", "category": "Python"}, {"instruction": "// NotSupported returns a *Error indicating \"unsupported value\".\n// This is used to report unknown values for enumerated fields (e.g. a list of\n// valid values).", "input": "go language", "output": "func NotSupported(field *Path, value interface{}, validValues []string) *Error {\n\tdetail := \"\"\n\tif validValues != nil && len(validValues) > 0 {\n\t\tquotedValues := make([]string, len(validValues))\n\t\tfor i, v := range validValues {\n\t\t\tquotedValues[i] = strconv.Quote(v)\n\t\t}\n\t\tdetail = \"supported values: \" + strings.Join(quotedValues, \", \")\n\t}\n\treturn &Error{ErrorTypeNotSupported, field.String(), value, detail}\n}", "category": "Python"}, {"instruction": "// check if message is in the cache", "input": "go language", "output": "func (p *Pss) checkFwdCache(msg *PssMsg) bool {\n\tp.fwdCacheMu.Lock()\n\tdefer p.fwdCacheMu.Unlock()\n\n\tdigest := p.digest(msg)\n\tentry, ok := p.fwdCache[digest]\n\tif ok {\n\t\tif entry.expiresAt.After(time.Now()) {\n\t\t\tlog.Trace(\"unexpired cache\", \"digest\", fmt.Sprintf(\"%x\", digest))\n\t\t\tmetrics.GetOrRegisterCounter(\"pss.checkfwdcache.unexpired\", nil).Inc(1)\n\t\t\treturn true\n\t\t}\n\t\tmetrics.GetOrRegisterCounter(\"pss.checkfwdcache.expired\", nil).Inc(1)\n\t}\n\treturn false\n}", "category": "Python"}, {"instruction": "// tar2ext4Actual is the implementation of tar2ext to write a layer from a tar file.\n// It can be called through re-exec (default), or inline for debugging.", "input": "go language", "output": "func tar2ext4Actual(dest string, diff io.Reader) (int64, error) {\n\t// maxDiskSize is not relating to the sandbox size - this is the\n\t// maximum possible size a layer VHD generated can be from an EXT4\n\t// layout perspective.\n\tconst maxDiskSize = 128 * 1024 * 1024 * 1024 // 128GB\n\tout, err := os.Create(dest)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer out.Close()\n\tif err := tar2ext4.Convert(\n\t\tdiff,\n\t\tout,\n\t\ttar2ext4.AppendVhdFooter,\n\t\ttar2ext4.ConvertWhiteout,\n\t\ttar2ext4.MaximumDiskSize(maxDiskSize)); err != nil {\n\t\treturn 0, err\n\t}\n\tfi, err := os.Stat(dest)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn fi.Size(), nil\n}", "category": "Python"}, {"instruction": "// resolveControllerRef returns the controller referenced by a ControllerRef,\n// or nil if the ControllerRef could not be resolved to a matching controller\n// of the correct Kind.", "input": "go language", "output": "func (rsc *ReplicaSetController) resolveControllerRef(namespace string, controllerRef *metav1.OwnerReference) *apps.ReplicaSet {\n\t// We can't look up by UID, so look up by Name and then verify UID.\n\t// Don't even try to look up by Name if it's the wrong Kind.\n\tif controllerRef.Kind != rsc.Kind {\n\t\treturn nil\n\t}\n\trs, err := rsc.rsLister.ReplicaSets(namespace).Get(controllerRef.Name)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tif rs.UID != controllerRef.UID {\n\t\t// The controller we found with this Name is not the same one that the\n\t\t// ControllerRef points to.\n\t\treturn nil\n\t}\n\treturn rs\n}", "category": "Python"}, {"instruction": "// deleteDupKeys picks primary/unique key-value pairs from rows and remove them from the dupKVs", "input": "go language", "output": "func (b *batchChecker) deleteDupKeys(ctx sessionctx.Context, t table.Table, rows [][]types.Datum) error {\n\tcleanupRows, err := b.getKeysNeedCheck(ctx, t, rows)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, row := range cleanupRows {\n\t\tif row.handleKey != nil {\n\t\t\tdelete(b.dupKVs, string(row.handleKey.newKV.key))\n\t\t}\n\t\tfor _, uk := range row.uniqueKeys {\n\t\t\tdelete(b.dupKVs, string(uk.newKV.key))\n\t\t}\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Next implements the Executor Next interface.", "input": "go language", "output": "func (e *ShowExec) Next(ctx context.Context, req *chunk.RecordBatch) error {\n\treq.GrowAndReset(e.maxChunkSize)\n\tif e.result == nil {\n\t\te.result = e.newFirstChunk()\n\t\terr := e.fetchAll()\n\t\tif err != nil {\n\t\t\treturn errors.Trace(err)\n\t\t}\n\t\titer := chunk.NewIterator4Chunk(e.result)\n\t\tfor colIdx := 0; colIdx < e.Schema().Len(); colIdx++ {\n\t\t\tretType := e.Schema().Columns[colIdx].RetType\n\t\t\tif !types.IsTypeVarchar(retType.Tp) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor row := iter.Begin(); row != iter.End(); row = iter.Next() {\n\t\t\t\tif valLen := len(row.GetString(colIdx)); retType.Flen < valLen {\n\t\t\t\t\tretType.Flen = valLen\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif e.cursor >= e.result.NumRows() {\n\t\treturn nil\n\t}\n\tnumCurBatch := mathutil.Min(req.Capacity(), e.result.NumRows()-e.cursor)\n\treq.Append(e.result, e.cursor, e.cursor+numCurBatch)\n\te.cursor += numCurBatch\n\treturn nil\n}", "category": "Python"}, {"instruction": "// CommonAccessor returns a Common interface for the provided object or an error if the object does\n// not provide List.", "input": "go language", "output": "func CommonAccessor(obj interface{}) (metav1.Common, error) {\n\tswitch t := obj.(type) {\n\tcase List:\n\t\treturn t, nil\n\tcase metav1.ListInterface:\n\t\treturn t, nil\n\tcase ListMetaAccessor:\n\t\tif m := t.GetListMeta(); m != nil {\n\t\t\treturn m, nil\n\t\t}\n\t\treturn nil, errNotCommon\n\tcase metav1.ListMetaAccessor:\n\t\tif m := t.GetListMeta(); m != nil {\n\t\t\treturn m, nil\n\t\t}\n\t\treturn nil, errNotCommon\n\tcase metav1.Object:\n\t\treturn t, nil\n\tcase metav1.ObjectMetaAccessor:\n\t\tif m := t.GetObjectMeta(); m != nil {\n\t\t\treturn m, nil\n\t\t}\n\t\treturn nil, errNotCommon\n\tdefault:\n\t\treturn nil, errNotCommon\n\t}\n}", "category": "Python"}, {"instruction": "// GetFilterMessages returns the messages that match the filter criteria and\n// are received between the last poll and now.", "input": "go language", "output": "func (api *PublicWhisperAPI) GetFilterMessages(id string) ([]*Message, error) {\n\tapi.mu.Lock()\n\tf := api.w.GetFilter(id)\n\tif f == nil {\n\t\tapi.mu.Unlock()\n\t\treturn nil, fmt.Errorf(\"filter not found\")\n\t}\n\tapi.lastUsed[id] = time.Now()\n\tapi.mu.Unlock()\n\n\treceivedMessages := f.Retrieve()\n\tmessages := make([]*Message, 0, len(receivedMessages))\n\tfor _, msg := range receivedMessages {\n\t\tmessages = append(messages, ToWhisperMessage(msg))\n\t}\n\n\treturn messages, nil\n}", "category": "Python"}, {"instruction": "// Validate makes sure provided values for EnvOptions are valid", "input": "go language", "output": "func (o *EnvOptions) Validate() error {\n\tif len(o.Filenames) == 0 && len(o.resources) < 1 {\n\t\treturn fmt.Errorf(\"one or more resources must be specified as <resource> <name> or <resource>/<name>\")\n\t}\n\tif o.List && len(o.output) > 0 {\n\t\treturn fmt.Errorf(\"--list and --output may not be specified together\")\n\t}\n\tif len(o.Keys) > 0 && len(o.From) == 0 {\n\t\treturn fmt.Errorf(\"when specifying --keys, a configmap or secret must be provided with --from\")\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// DeepCopy returns a new resource state that contains equivalent data to the\n// receiver but shares no backing memory in common.\n//\n// As with all methods on Resource, this method is not safe to use concurrently\n// with writing to any portion of the recieving data structure. It is the\n// caller's responsibility to ensure mutual exclusion for the duration of the\n// operation, but may then freely modify the receiver and the returned copy\n// independently once this method returns.", "input": "go language", "output": "func (rs *Resource) DeepCopy() *Resource {\n\tif rs == nil {\n\t\treturn nil\n\t}\n\n\tinstances := make(map[addrs.InstanceKey]*ResourceInstance, len(rs.Instances))\n\tfor k, i := range rs.Instances {\n\t\tinstances[k] = i.DeepCopy()\n\t}\n\n\treturn &Resource{\n\t\tAddr:           rs.Addr,\n\t\tEachMode:       rs.EachMode,\n\t\tInstances:      instances,\n\t\tProviderConfig: rs.ProviderConfig, // technically mutable, but immutable by convention\n\t}\n}", "category": "Python"}, {"instruction": "// evalDecimal evals a builtinCaseWhenDecimalSig.\n// See https://dev.mysql.com/doc/refman/5.7/en/case.html", "input": "go language", "output": "func (b *builtinCaseWhenDecimalSig) evalDecimal(row chunk.Row) (ret *types.MyDecimal, isNull bool, err error) {\n\tvar condition int64\n\targs, l := b.getArgs(), len(b.getArgs())\n\tfor i := 0; i < l-1; i += 2 {\n\t\tcondition, isNull, err = args[i].EvalInt(b.ctx, row)\n\t\tif err != nil {\n\t\t\treturn nil, isNull, err\n\t\t}\n\t\tif isNull || condition == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tret, isNull, err = args[i+1].EvalDecimal(b.ctx, row)\n\t\treturn ret, isNull, err\n\t}\n\t// when clause(condition, result) -> args[i], args[i+1]; (i >= 0 && i+1 < l-1)\n\t// else clause -> args[l-1]\n\t// If case clause has else clause, l%2 == 1.\n\tif l%2 == 1 {\n\t\tret, isNull, err = args[l-1].EvalDecimal(b.ctx, row)\n\t\treturn ret, isNull, err\n\t}\n\treturn ret, true, nil\n}", "category": "Python"}, {"instruction": "// GetUncleByBlockHashAndIndex returns the uncle block for the given block hash and index. When fullTx is true\n// all transactions in the block are returned in full detail, otherwise only the transaction hash is returned.", "input": "go language", "output": "func (s *PublicBlockChainAPI) GetUncleByBlockHashAndIndex(ctx context.Context, blockHash common.Hash, index hexutil.Uint) (map[string]interface{}, error) {\n\tblock, err := s.b.GetBlock(ctx, blockHash)\n\tif block != nil {\n\t\tuncles := block.Uncles()\n\t\tif index >= hexutil.Uint(len(uncles)) {\n\t\t\tlog.Debug(\"Requested uncle not found\", \"number\", block.Number(), \"hash\", blockHash, \"index\", index)\n\t\t\treturn nil, nil\n\t\t}\n\t\tblock = types.NewBlockWithHeader(uncles[index])\n\t\treturn s.rpcOutputBlock(block, false, false)\n\t}\n\treturn nil, err\n}", "category": "Python"}, {"instruction": "// writeActionSymbol writes a symbol to represent the given action, followed\n// by a space.\n//\n// It only supports the actions that can be represented with a single character:\n// Create, Delete, Update and NoAction.", "input": "go language", "output": "func (p *blockBodyDiffPrinter) writeActionSymbol(action plans.Action) {\n\tswitch action {\n\tcase plans.Create:\n\t\tp.buf.WriteString(p.color.Color(\"[green]+[reset] \"))\n\tcase plans.Delete:\n\t\tp.buf.WriteString(p.color.Color(\"[red]-[reset] \"))\n\tcase plans.Update:\n\t\tp.buf.WriteString(p.color.Color(\"[yellow]~[reset] \"))\n\tcase plans.NoOp:\n\t\tp.buf.WriteString(\"  \")\n\tdefault:\n\t\t// Should never happen\n\t\tp.buf.WriteString(p.color.Color(\"? \"))\n\t}\n}", "category": "Python"}, {"instruction": "// resolveGeneratedColumns resolves generated columns with their generation\n// expressions respectively. onDups indicates which columns are in on-duplicate list.", "input": "go language", "output": "func (b *PlanBuilder) resolveGeneratedColumns(columns []*table.Column, onDups map[string]struct{}, mockPlan LogicalPlan) (igc InsertGeneratedColumns, err error) {\n\tfor _, column := range columns {\n\t\tif !column.IsGenerated() {\n\t\t\tcontinue\n\t\t}\n\t\tcolumnName := &ast.ColumnName{Name: column.Name}\n\t\tcolumnName.SetText(column.Name.O)\n\n\t\tcolExpr, _, err := mockPlan.findColumn(columnName)\n\t\tif err != nil {\n\t\t\treturn igc, err\n\t\t}\n\n\t\texpr, _, err := b.rewrite(column.GeneratedExpr, mockPlan, nil, true)\n\t\tif err != nil {\n\t\t\treturn igc, err\n\t\t}\n\t\texpr = expression.BuildCastFunction(b.ctx, expr, colExpr.GetType())\n\n\t\tigc.Columns = append(igc.Columns, columnName)\n\t\tigc.Exprs = append(igc.Exprs, expr)\n\t\tif onDups == nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor dep := range column.Dependences {\n\t\t\tif _, ok := onDups[dep]; ok {\n\t\t\t\tassign := &expression.Assignment{Col: colExpr, Expr: expr}\n\t\t\t\tigc.OnDuplicates = append(igc.OnDuplicates, assign)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn igc, nil\n}", "category": "Python"}, {"instruction": "// modifiableCharsetAndCollation returns error when the charset or collation is not modifiable.", "input": "go language", "output": "func modifiableCharsetAndCollation(toCharset, toCollate, origCharset, origCollate string) error {\n\tif !charset.ValidCharsetAndCollation(toCharset, toCollate) {\n\t\treturn ErrUnknownCharacterSet.GenWithStack(\"Unknown character set: '%s', collation: '%s'\", toCharset, toCollate)\n\t}\n\tif toCharset == charset.CharsetUTF8MB4 && origCharset == charset.CharsetUTF8 {\n\t\t// TiDB only allow utf8 to be changed to utf8mb4.\n\t\treturn nil\n\t}\n\n\tif toCharset != origCharset {\n\t\tmsg := fmt.Sprintf(\"charset from %s to %s\", origCharset, toCharset)\n\t\treturn errUnsupportedModifyCharset.GenWithStackByArgs(msg)\n\t}\n\tif toCollate != origCollate {\n\t\tmsg := fmt.Sprintf(\"collate from %s to %s\", origCollate, toCollate)\n\t\treturn errUnsupportedModifyCharset.GenWithStackByArgs(msg)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Hash returns a hash of either a ConfigMap or a Secret", "input": "go language", "output": "func (h *KustHash) Hash(m map[string]interface{}) (string, error) {\n\tu := unstructured.Unstructured{\n\t\tObject: m,\n\t}\n\tkind := u.GetKind()\n\tswitch kind {\n\tcase \"ConfigMap\":\n\t\tcm, err := unstructuredToConfigmap(u)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn ConfigMapHash(cm)\n\tcase \"Secret\":\n\t\tsec, err := unstructuredToSecret(u)\n\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn SecretHash(sec)\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"type %s is supported for hashing in %v\", kind, m)\n\t}\n}", "category": "Python"}, {"instruction": "// FindCWD returns the current working directory from where the Hugo\n// executable is run.", "input": "go language", "output": "func FindCWD() (string, error) {\n\tserverFile, err := filepath.Abs(os.Args[0])\n\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"can't get absolute path for executable: %v\", err)\n\t}\n\n\tpath := filepath.Dir(serverFile)\n\trealFile, err := filepath.EvalSymlinks(serverFile)\n\n\tif err != nil {\n\t\tif _, err = os.Stat(serverFile + \".exe\"); err == nil {\n\t\t\trealFile = filepath.Clean(serverFile + \".exe\")\n\t\t}\n\t}\n\n\tif err == nil && realFile != serverFile {\n\t\tpath = filepath.Dir(realFile)\n\t}\n\n\treturn path, nil\n}", "category": "Python"}, {"instruction": "// getRun handles requests to run a command inside a container.", "input": "go language", "output": "func (s *Server) getRun(request *restful.Request, response *restful.Response) {\n\tparams := getExecRequestParams(request)\n\tpod, ok := s.host.GetPodByName(params.podNamespace, params.podName)\n\tif !ok {\n\t\tresponse.WriteError(http.StatusNotFound, fmt.Errorf(\"pod does not exist\"))\n\t\treturn\n\t}\n\n\t// For legacy reasons, run uses different query param than exec.\n\tparams.cmd = strings.Split(request.QueryParameter(\"cmd\"), \" \")\n\tdata, err := s.host.RunInContainer(kubecontainer.GetPodFullName(pod), params.podUID, params.containerName, params.cmd)\n\tif err != nil {\n\t\tresponse.WriteError(http.StatusInternalServerError, err)\n\t\treturn\n\t}\n\twriteJSONResponse(response, data)\n}", "category": "Python"}, {"instruction": "// IPRange returns a SchemaValidateFunc which tests if the provided value\n// is of type string, and in valid IP range notation", "input": "go language", "output": "func IPRange() schema.SchemaValidateFunc {\n\treturn func(i interface{}, k string) (s []string, es []error) {\n\t\tv, ok := i.(string)\n\t\tif !ok {\n\t\t\tes = append(es, fmt.Errorf(\"expected type of %s to be string\", k))\n\t\t\treturn\n\t\t}\n\n\t\tips := strings.Split(v, \"-\")\n\t\tif len(ips) != 2 {\n\t\t\tes = append(es, fmt.Errorf(\n\t\t\t\t\"expected %s to contain a valid IP range, got: %s\", k, v))\n\t\t\treturn\n\t\t}\n\t\tip1 := net.ParseIP(ips[0])\n\t\tip2 := net.ParseIP(ips[1])\n\t\tif ip1 == nil || ip2 == nil || bytes.Compare(ip1, ip2) > 0 {\n\t\t\tes = append(es, fmt.Errorf(\n\t\t\t\t\"expected %s to contain a valid IP range, got: %s\", k, v))\n\t\t}\n\t\treturn\n\t}\n}", "category": "Python"}, {"instruction": "// MergeSchema will merge two schema into one schema. We shouldn't need to consider unique keys.\n// That will be processed in build_key_info.go.", "input": "go language", "output": "func MergeSchema(lSchema, rSchema *Schema) *Schema {\n\tif lSchema == nil && rSchema == nil {\n\t\treturn nil\n\t}\n\tif lSchema == nil {\n\t\treturn rSchema.Clone()\n\t}\n\tif rSchema == nil {\n\t\treturn lSchema.Clone()\n\t}\n\ttmpL := lSchema.Clone()\n\ttmpR := rSchema.Clone()\n\tret := NewSchema(append(tmpL.Columns, tmpR.Columns...)...)\n\tret.TblID2Handle = tmpL.TblID2Handle\n\tfor id, cols := range tmpR.TblID2Handle {\n\t\tif _, ok := ret.TblID2Handle[id]; ok {\n\t\t\tret.TblID2Handle[id] = append(ret.TblID2Handle[id], cols...)\n\t\t} else {\n\t\t\tret.TblID2Handle[id] = cols\n\t\t}\n\t}\n\treturn ret\n}", "category": "Python"}, {"instruction": "// NewREST returns a RESTStorage object that will work against pod disruption budgets.", "input": "go language", "output": "func NewREST(optsGetter generic.RESTOptionsGetter) *REST {\n\tstore := &genericregistry.Store{\n\t\tNewFunc:     func() runtime.Object { return &admissionregistration.ValidatingWebhookConfiguration{} },\n\t\tNewListFunc: func() runtime.Object { return &admissionregistration.ValidatingWebhookConfigurationList{} },\n\t\tObjectNameFunc: func(obj runtime.Object) (string, error) {\n\t\t\treturn obj.(*admissionregistration.ValidatingWebhookConfiguration).Name, nil\n\t\t},\n\t\tDefaultQualifiedResource: admissionregistration.Resource(\"validatingwebhookconfigurations\"),\n\n\t\tCreateStrategy: validatingwebhookconfiguration.Strategy,\n\t\tUpdateStrategy: validatingwebhookconfiguration.Strategy,\n\t\tDeleteStrategy: validatingwebhookconfiguration.Strategy,\n\t}\n\toptions := &generic.StoreOptions{RESTOptions: optsGetter}\n\tif err := store.CompleteWithOptions(options); err != nil {\n\t\tpanic(err) // TODO: Propagate error up\n\t}\n\treturn &REST{store}\n}", "category": "Python"}, {"instruction": "// parseInitVersion parses a Tini version string, and extracts the \"version\"\n// and \"git commit\" from the output.\n//\n// Output example from `docker-init --version`:\n//\n//     tini version 0.18.0 - git.fec3683", "input": "go language", "output": "func parseInitVersion(v string) (version string, commit string, err error) {\n\tparts := strings.Split(strings.TrimSpace(v), \" - \")\n\n\tif len(parts) >= 2 {\n\t\tgitParts := strings.Split(parts[1], \".\")\n\t\tif len(gitParts) == 2 && gitParts[0] == \"git\" {\n\t\t\tcommit = gitParts[1]\n\t\t}\n\t}\n\tif strings.HasPrefix(parts[0], \"tini version \") {\n\t\tversion = strings.TrimPrefix(parts[0], \"tini version \")\n\t}\n\tif version == \"\" && commit == \"\" {\n\t\terr = errors.Errorf(\"unknown output format: %s\", v)\n\t}\n\treturn version, commit, err\n}", "category": "Python"}, {"instruction": "// GetCSIAttachLimitKey returns limit key used for CSI volumes", "input": "go language", "output": "func GetCSIAttachLimitKey(driverName string) string {\n\tcsiPrefixLength := len(CSIAttachLimitPrefix)\n\ttotalkeyLength := csiPrefixLength + len(driverName)\n\tif totalkeyLength >= ResourceNameLengthLimit {\n\t\tcharsFromDriverName := driverName[:23]\n\t\thash := sha1.New()\n\t\thash.Write([]byte(driverName))\n\t\thashed := hex.EncodeToString(hash.Sum(nil))\n\t\thashed = hashed[:16]\n\t\treturn CSIAttachLimitPrefix + charsFromDriverName + hashed\n\t}\n\treturn CSIAttachLimitPrefix + driverName\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *KubeProxyConntrackConfiguration) DeepCopyInto(out *KubeProxyConntrackConfiguration) {\n\t*out = *in\n\tif in.Max != nil {\n\t\tin, out := &in.Max, &out.Max\n\t\t*out = new(int32)\n\t\t**out = **in\n\t}\n\tif in.MaxPerCore != nil {\n\t\tin, out := &in.MaxPerCore, &out.MaxPerCore\n\t\t*out = new(int32)\n\t\t**out = **in\n\t}\n\tif in.Min != nil {\n\t\tin, out := &in.Min, &out.Min\n\t\t*out = new(int32)\n\t\t**out = **in\n\t}\n\tif in.TCPEstablishedTimeout != nil {\n\t\tin, out := &in.TCPEstablishedTimeout, &out.TCPEstablishedTimeout\n\t\t*out = new(v1.Duration)\n\t\t**out = **in\n\t}\n\tif in.TCPCloseWaitTimeout != nil {\n\t\tin, out := &in.TCPCloseWaitTimeout, &out.TCPCloseWaitTimeout\n\t\t*out = new(v1.Duration)\n\t\t**out = **in\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// printPodsMultilineWithIndent prints multiple pods with a user-defined alignment.", "input": "go language", "output": "func printPodsMultilineWithIndent(w PrefixWriter, initialIndent, title, innerIndent string, pods []corev1.Pod) {\n\tw.Write(LEVEL_0, \"%s%s:%s\", initialIndent, title, innerIndent)\n\n\tif pods == nil || len(pods) == 0 {\n\t\tw.WriteLine(\"<none>\")\n\t\treturn\n\t}\n\n\t// to print pods in the sorted order\n\tsort.Slice(pods, func(i, j int) bool {\n\t\tcmpKey := func(pod corev1.Pod) string {\n\t\t\treturn pod.Name\n\t\t}\n\t\treturn cmpKey(pods[i]) < cmpKey(pods[j])\n\t})\n\n\tfor i, pod := range pods {\n\t\tif i != 0 {\n\t\t\tw.Write(LEVEL_0, \"%s\", initialIndent)\n\t\t\tw.Write(LEVEL_0, \"%s\", innerIndent)\n\t\t}\n\t\tw.Write(LEVEL_0, \"%s\\n\", pod.Name)\n\t}\n}", "category": "Python"}, {"instruction": "// RecommendedContextOverrideFlags is a convenience method to return recommended flag names prefixed with a string of your choosing", "input": "go language", "output": "func RecommendedContextOverrideFlags(prefix string) ContextOverrideFlags {\n\treturn ContextOverrideFlags{\n\t\tClusterName:  FlagInfo{prefix + FlagClusterName, \"\", \"\", \"The name of the kubeconfig cluster to use\"},\n\t\tAuthInfoName: FlagInfo{prefix + FlagAuthInfoName, \"\", \"\", \"The name of the kubeconfig user to use\"},\n\t\tNamespace:    FlagInfo{prefix + FlagNamespace, \"n\", \"\", \"If present, the namespace scope for this CLI request\"},\n\t}\n}", "category": "Python"}, {"instruction": "// NewDefaultOptions builds a \"normal\" set of options.  You wouldn't normally expose this, but hyperkube isn't cobra compatible", "input": "go language", "output": "func NewDefaultOptions(out, err io.Writer) *AggregatorOptions {\n\to := &AggregatorOptions{\n\t\tRecommendedOptions: genericoptions.NewRecommendedOptions(\n\t\t\tdefaultEtcdPathPrefix,\n\t\t\taggregatorscheme.Codecs.LegacyCodec(v1beta1.SchemeGroupVersion),\n\t\t\tgenericoptions.NewProcessInfo(\"kube-aggregator\", \"kube-system\"),\n\t\t),\n\t\tAPIEnablement: genericoptions.NewAPIEnablementOptions(),\n\n\t\tStdOut: out,\n\t\tStdErr: err,\n\t}\n\n\treturn o\n}", "category": "Python"}, {"instruction": "// NewKubeConfigFilePhase creates a kubeadm workflow phase that creates a kubeconfig file.", "input": "go language", "output": "func NewKubeConfigFilePhase(kubeConfigFileName string) workflow.Phase {\n\treturn workflow.Phase{\n\t\tName:         kubeconfigFilePhaseProperties[kubeConfigFileName].name,\n\t\tShort:        kubeconfigFilePhaseProperties[kubeConfigFileName].short,\n\t\tLong:         fmt.Sprintf(kubeconfigFilePhaseProperties[kubeConfigFileName].long, kubeConfigFileName),\n\t\tRun:          runKubeConfigFile(kubeConfigFileName),\n\t\tInheritFlags: getKubeConfigPhaseFlags(kubeConfigFileName),\n\t}\n}", "category": "Python"}, {"instruction": "// SetShhConfig applies shh-related command line flags to the config.", "input": "go language", "output": "func SetShhConfig(ctx *cli.Context, stack *node.Node, cfg *whisper.Config) {\n\tif ctx.GlobalIsSet(WhisperMaxMessageSizeFlag.Name) {\n\t\tcfg.MaxMessageSize = uint32(ctx.GlobalUint(WhisperMaxMessageSizeFlag.Name))\n\t}\n\tif ctx.GlobalIsSet(WhisperMinPOWFlag.Name) {\n\t\tcfg.MinimumAcceptedPOW = ctx.GlobalFloat64(WhisperMinPOWFlag.Name)\n\t}\n\tif ctx.GlobalIsSet(WhisperRestrictConnectionBetweenLightClientsFlag.Name) {\n\t\tcfg.RestrictConnectionBetweenLightClients = true\n\t}\n}", "category": "Python"}, {"instruction": "// query callback representing the query of a chaincode", "input": "go language", "output": "func (t *SimpleChaincode) query(stub shim.ChaincodeStubInterface, args []string) pb.Response {\n\tvar A string // Entities\n\tvar err error\n\n\tif len(args) != 1 {\n\t\treturn shim.Error(\"Incorrect number of arguments. Expecting name of the person to query\")\n\t}\n\n\tA = args[0]\n\n\t// Get the state from the ledger\n\tAvalbytes, err := stub.GetState(A)\n\tif err != nil {\n\t\tjsonResp := \"{\\\"Error\\\":\\\"Failed to get state for \" + A + \"\\\"}\"\n\t\treturn shim.Error(jsonResp)\n\t}\n\n\tif Avalbytes == nil {\n\t\tjsonResp := \"{\\\"Error\\\":\\\"Nil amount for \" + A + \"\\\"}\"\n\t\treturn shim.Error(jsonResp)\n\t}\n\n\tjsonResp := \"{\\\"Name\\\":\\\"\" + A + \"\\\",\\\"Amount\\\":\\\"\" + string(Avalbytes) + \"\\\"}\"\n\tfmt.Printf(\"Query Response:%s\\n\", jsonResp)\n\treturn shim.Success(Avalbytes)\n}", "category": "Python"}, {"instruction": "// ConvertJSONToFloat casts JSON into float64.", "input": "go language", "output": "func ConvertJSONToFloat(sc *stmtctx.StatementContext, j json.BinaryJSON) (float64, error) {\n\tswitch j.TypeCode {\n\tcase json.TypeCodeObject, json.TypeCodeArray:\n\t\treturn 0, nil\n\tcase json.TypeCodeLiteral:\n\t\tswitch j.Value[0] {\n\t\tcase json.LiteralNil, json.LiteralFalse:\n\t\t\treturn 0, nil\n\t\tdefault:\n\t\t\treturn 1, nil\n\t\t}\n\tcase json.TypeCodeInt64:\n\t\treturn float64(j.GetInt64()), nil\n\tcase json.TypeCodeUint64:\n\t\tu, err := ConvertIntToUint(sc, j.GetInt64(), IntergerUnsignedUpperBound(mysql.TypeLonglong), mysql.TypeLonglong)\n\t\treturn float64(u), errors.Trace(err)\n\tcase json.TypeCodeFloat64:\n\t\treturn j.GetFloat64(), nil\n\tcase json.TypeCodeString:\n\t\tstr := string(hack.String(j.GetString()))\n\t\treturn StrToFloat(sc, str)\n\t}\n\treturn 0, errors.New(\"Unknown type code in JSON\")\n}", "category": "Python"}, {"instruction": "// Dereference removes an existing reference from a root node.", "input": "go language", "output": "func (db *Database) Dereference(root common.Hash) {\n\t// Sanity check to ensure that the meta-root is not removed\n\tif root == (common.Hash{}) {\n\t\tlog.Error(\"Attempted to dereference the trie cache meta root\")\n\t\treturn\n\t}\n\tdb.lock.Lock()\n\tdefer db.lock.Unlock()\n\n\tnodes, storage, start := len(db.dirties), db.dirtiesSize, time.Now()\n\tdb.dereference(root, common.Hash{})\n\n\tdb.gcnodes += uint64(nodes - len(db.dirties))\n\tdb.gcsize += storage - db.dirtiesSize\n\tdb.gctime += time.Since(start)\n\n\tmemcacheGCTimeTimer.Update(time.Since(start))\n\tmemcacheGCSizeMeter.Mark(int64(storage - db.dirtiesSize))\n\tmemcacheGCNodesMeter.Mark(int64(nodes - len(db.dirties)))\n\n\tlog.Debug(\"Dereferenced trie from memory database\", \"nodes\", nodes-len(db.dirties), \"size\", storage-db.dirtiesSize, \"time\", time.Since(start),\n\t\t\"gcnodes\", db.gcnodes, \"gcsize\", db.gcsize, \"gctime\", db.gctime, \"livenodes\", len(db.dirties), \"livesize\", db.dirtiesSize)\n}", "category": "Python"}, {"instruction": "// checkWhereMap handles the where-matching logic when the seqv value is a Map.", "input": "go language", "output": "func (ns *Namespace) checkWhereMap(seqv, kv, mv reflect.Value, path []string, op string) (interface{}, error) {\n\trv := reflect.MakeMap(seqv.Type())\n\tkeys := seqv.MapKeys()\n\tfor _, k := range keys {\n\t\telemv := seqv.MapIndex(k)\n\t\tswitch elemv.Kind() {\n\t\tcase reflect.Array, reflect.Slice:\n\t\t\tr, err := ns.checkWhereArray(elemv, kv, mv, path, op)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tswitch rr := reflect.ValueOf(r); rr.Kind() {\n\t\t\tcase reflect.Slice:\n\t\t\t\tif rr.Len() > 0 {\n\t\t\t\t\trv.SetMapIndex(k, elemv)\n\t\t\t\t}\n\t\t\t}\n\t\tcase reflect.Interface:\n\t\t\telemvv, isNil := indirect(elemv)\n\t\t\tif isNil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tswitch elemvv.Kind() {\n\t\t\tcase reflect.Array, reflect.Slice:\n\t\t\t\tr, err := ns.checkWhereArray(elemvv, kv, mv, path, op)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tswitch rr := reflect.ValueOf(r); rr.Kind() {\n\t\t\t\tcase reflect.Slice:\n\t\t\t\t\tif rr.Len() > 0 {\n\t\t\t\t\t\trv.SetMapIndex(k, elemv)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn rv.Interface(), nil\n}", "category": "Python"}, {"instruction": "// DiskIsAttached returns if disk is attached to the VM using controllers supported by the plugin.", "input": "go language", "output": "func (pc *PCCloud) DiskIsAttached(ctx context.Context, pdID string, nodeName k8stypes.NodeName) (bool, error) {\n\tphotonClient, err := getPhotonClient(pc)\n\tif err != nil {\n\t\tklog.Errorf(\"Photon Cloud Provider: Failed to get photon client for DiskIsAttached, error: [%v]\", err)\n\t\treturn false, err\n\t}\n\n\tdisk, err := photonClient.Disks.Get(pdID)\n\tif err != nil {\n\t\tklog.Errorf(\"Photon Cloud Provider: Failed to Get disk with pdID %s. Error[%v]\", pdID, err)\n\t\treturn false, err\n\t}\n\n\tvmID, err := pc.InstanceID(ctx, nodeName)\n\tif err == cloudprovider.InstanceNotFound {\n\t\tklog.Infof(\"Instance %q does not exist, disk %s will be detached automatically.\", nodeName, pdID)\n\t\treturn false, nil\n\t}\n\tif err != nil {\n\t\tklog.Errorf(\"Photon Cloud Provider: pc.InstanceID failed for DiskIsAttached. Error[%v]\", err)\n\t\treturn false, err\n\t}\n\n\tfor _, vm := range disk.VMs {\n\t\tif vm == vmID {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\treturn false, nil\n}", "category": "Python"}, {"instruction": "// TODO: test", "input": "go language", "output": "func (n *EvalDeposeState) Eval(ctx EvalContext) (interface{}, error) {\n\tabsAddr := n.Addr.Absolute(ctx.Path())\n\tstate := ctx.State()\n\n\tvar key states.DeposedKey\n\tif n.ForceKey == states.NotDeposed {\n\t\tkey = state.DeposeResourceInstanceObject(absAddr)\n\t} else {\n\t\tkey = n.ForceKey\n\t\tstate.DeposeResourceInstanceObjectForceKey(absAddr, key)\n\t}\n\tlog.Printf(\"[TRACE] EvalDeposeState: prior object for %s now deposed with key %s\", absAddr, key)\n\n\tif n.OutputKey != nil {\n\t\t*n.OutputKey = key\n\t}\n\n\treturn nil, nil\n}", "category": "Python"}, {"instruction": "// evalInt evals a builtinInetAtonSig.\n// See https://dev.mysql.com/doc/refman/5.7/en/miscellaneous-functions.html#function_inet-aton", "input": "go language", "output": "func (b *builtinInetAtonSig) evalInt(row chunk.Row) (int64, bool, error) {\n\tval, isNull, err := b.args[0].EvalString(b.ctx, row)\n\tif err != nil || isNull {\n\t\treturn 0, true, err\n\t}\n\t// ip address should not end with '.'.\n\tif len(val) == 0 || val[len(val)-1] == '.' {\n\t\treturn 0, true, nil\n\t}\n\n\tvar (\n\t\tbyteResult, result uint64\n\t\tdotCount           int\n\t)\n\tfor _, c := range val {\n\t\tif c >= '0' && c <= '9' {\n\t\t\tdigit := uint64(c - '0')\n\t\t\tbyteResult = byteResult*10 + digit\n\t\t\tif byteResult > 255 {\n\t\t\t\treturn 0, true, nil\n\t\t\t}\n\t\t} else if c == '.' {\n\t\t\tdotCount++\n\t\t\tif dotCount > 3 {\n\t\t\t\treturn 0, true, nil\n\t\t\t}\n\t\t\tresult = (result << 8) + byteResult\n\t\t\tbyteResult = 0\n\t\t} else {\n\t\t\treturn 0, true, nil\n\t\t}\n\t}\n\t// 127 \t\t-> 0.0.0.127\n\t// 127.255 \t-> 127.0.0.255\n\t// 127.256\t-> NULL\n\t// 127.2.1\t-> 127.2.0.1\n\tswitch dotCount {\n\tcase 1:\n\t\tresult <<= 8\n\t\tfallthrough\n\tcase 2:\n\t\tresult <<= 8\n\t}\n\treturn int64((result << 8) + byteResult), false, nil\n}", "category": "Python"}, {"instruction": "// This implementation is shared between Linux and NsEnter", "input": "go language", "output": "func safeOpenSubPath(mounter mount.Interface, subpath Subpath) (int, error) {\n\tif !mount.PathWithinBase(subpath.Path, subpath.VolumePath) {\n\t\treturn -1, fmt.Errorf(\"subpath %q not within volume path %q\", subpath.Path, subpath.VolumePath)\n\t}\n\tfd, err := doSafeOpen(subpath.Path, subpath.VolumePath)\n\tif err != nil {\n\t\treturn -1, fmt.Errorf(\"error opening subpath %v: %v\", subpath.Path, err)\n\t}\n\treturn fd, nil\n}", "category": "Python"}, {"instruction": "// Implementation of EC2.Instances", "input": "go language", "output": "func (s *awsSdkEC2) DescribeInstances(request *ec2.DescribeInstancesInput) ([]*ec2.Instance, error) {\n\t// Instances are paged\n\tresults := []*ec2.Instance{}\n\tvar nextToken *string\n\trequestTime := time.Now()\n\tfor {\n\t\tresponse, err := s.ec2.DescribeInstances(request)\n\t\tif err != nil {\n\t\t\trecordAWSMetric(\"describe_instance\", 0, err)\n\t\t\treturn nil, fmt.Errorf(\"error listing AWS instances: %q\", err)\n\t\t}\n\n\t\tfor _, reservation := range response.Reservations {\n\t\t\tresults = append(results, reservation.Instances...)\n\t\t}\n\n\t\tnextToken = response.NextToken\n\t\tif aws.StringValue(nextToken) == \"\" {\n\t\t\tbreak\n\t\t}\n\t\trequest.NextToken = nextToken\n\t}\n\ttimeTaken := time.Since(requestTime).Seconds()\n\trecordAWSMetric(\"describe_instance\", timeTaken, nil)\n\treturn results, nil\n}", "category": "Python"}, {"instruction": "// getIPv4DefaultRoutes obtains the IPv4 routes, and filters out non-default routes.", "input": "go language", "output": "func getIPv4DefaultRoutes(input io.Reader) ([]Route, error) {\n\troutes := []Route{}\n\tscanner := bufio.NewReader(input)\n\tfor {\n\t\tline, err := scanner.ReadString('\\n')\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\t//ignore the headers in the route info\n\t\tif strings.HasPrefix(line, \"Iface\") {\n\t\t\tcontinue\n\t\t}\n\t\tfields := strings.Fields(line)\n\t\t// Interested in fields:\n\t\t//  0 - interface name\n\t\t//  1 - destination address\n\t\t//  2 - gateway\n\t\tdest, err := parseIP(fields[1], familyIPv4)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tgw, err := parseIP(fields[2], familyIPv4)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif !dest.Equal(net.IPv4zero) {\n\t\t\tcontinue\n\t\t}\n\t\troutes = append(routes, Route{\n\t\t\tInterface:   fields[0],\n\t\t\tDestination: dest,\n\t\t\tGateway:     gw,\n\t\t\tFamily:      familyIPv4,\n\t\t})\n\t}\n\treturn routes, nil\n}", "category": "Python"}, {"instruction": "// Gets the current load balancer state", "input": "go language", "output": "func (c *Cloud) describeLoadBalancer(name string) (*elb.LoadBalancerDescription, error) {\n\trequest := &elb.DescribeLoadBalancersInput{}\n\trequest.LoadBalancerNames = []*string{&name}\n\n\tresponse, err := c.elb.DescribeLoadBalancers(request)\n\tif err != nil {\n\t\tif awsError, ok := err.(awserr.Error); ok {\n\t\t\tif awsError.Code() == \"LoadBalancerNotFound\" {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tvar ret *elb.LoadBalancerDescription\n\tfor _, loadBalancer := range response.LoadBalancerDescriptions {\n\t\tif ret != nil {\n\t\t\tklog.Errorf(\"Found multiple load balancers with name: %s\", name)\n\t\t}\n\t\tret = loadBalancer\n\t}\n\treturn ret, nil\n}", "category": "Python"}, {"instruction": "// getKubeletSandboxes lists all (or just the running) sandboxes managed by kubelet.", "input": "go language", "output": "func (m *kubeGenericRuntimeManager) getKubeletSandboxes(all bool) ([]*runtimeapi.PodSandbox, error) {\n\tvar filter *runtimeapi.PodSandboxFilter\n\tif !all {\n\t\treadyState := runtimeapi.PodSandboxState_SANDBOX_READY\n\t\tfilter = &runtimeapi.PodSandboxFilter{\n\t\t\tState: &runtimeapi.PodSandboxStateValue{\n\t\t\t\tState: readyState,\n\t\t\t},\n\t\t}\n\t}\n\n\tresp, err := m.runtimeService.ListPodSandbox(filter)\n\tif err != nil {\n\t\tklog.Errorf(\"ListPodSandbox failed: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}", "category": "Python"}, {"instruction": "// FindServer takes out an internal \"read lock\" and searches through the list\n// of servers to find a \"healthy\" server.  If the server is actually\n// unhealthy, we rely on Serf to detect this and remove the node from the\n// server list.  If the server at the front of the list has failed or fails\n// during an RPC call, it is rotated to the end of the list.  If there are no\n// servers available, return nil.", "input": "go language", "output": "func (m *Manager) FindServer() *metadata.Server {\n\tl := m.getServerList()\n\tnumServers := len(l.servers)\n\tif numServers == 0 {\n\t\tm.logger.Printf(\"[WARN] manager: No servers available\")\n\t\treturn nil\n\t}\n\n\t// Return whatever is at the front of the list because it is\n\t// assumed to be the oldest in the server list (unless -\n\t// hypothetically - the server list was rotated right after a\n\t// server was added).\n\treturn l.servers[0]\n}", "category": "Python"}, {"instruction": "// evalString evals a builtinGreatestStringSig.\n// See http://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#function_greatest", "input": "go language", "output": "func (b *builtinGreatestStringSig) evalString(row chunk.Row) (max string, isNull bool, err error) {\n\tmax, isNull, err = b.args[0].EvalString(b.ctx, row)\n\tif isNull || err != nil {\n\t\treturn max, isNull, err\n\t}\n\tfor i := 1; i < len(b.args); i++ {\n\t\tvar v string\n\t\tv, isNull, err = b.args[i].EvalString(b.ctx, row)\n\t\tif isNull || err != nil {\n\t\t\treturn max, isNull, err\n\t\t}\n\t\tif types.CompareString(v, max) > 0 {\n\t\t\tmax = v\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// EnforcePtr ensures that obj is a pointer of some sort. Returns a reflect.Value\n// of the dereferenced pointer, ensuring that it is settable/addressable.\n// Returns an error if this is not possible.", "input": "go language", "output": "func EnforcePtr(obj interface{}) (reflect.Value, error) {\n\tv := reflect.ValueOf(obj)\n\tif v.Kind() != reflect.Ptr {\n\t\tif v.Kind() == reflect.Invalid {\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"expected pointer, but got invalid kind\")\n\t\t}\n\t\treturn reflect.Value{}, fmt.Errorf(\"expected pointer, but got %v type\", v.Type())\n\t}\n\tif v.IsNil() {\n\t\treturn reflect.Value{}, fmt.Errorf(\"expected pointer, but got nil\")\n\t}\n\treturn v.Elem(), nil\n}", "category": "Python"}, {"instruction": "// NewContainerManager creates windows container manager.", "input": "go language", "output": "func NewContainerManager(mountUtil mount.Interface, cadvisorInterface cadvisor.Interface, nodeConfig NodeConfig, failSwapOn bool, devicePluginEnabled bool, recorder record.EventRecorder) (ContainerManager, error) {\n\tvar capacity = v1.ResourceList{}\n\t// It is safe to invoke `MachineInfo` on cAdvisor before logically initializing cAdvisor here because\n\t// machine info is computed and cached once as part of cAdvisor object creation.\n\t// But `RootFsInfo` and `ImagesFsInfo` are not available at this moment so they will be called later during manager starts\n\tmachineInfo, err := cadvisorInterface.MachineInfo()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcapacity = cadvisor.CapacityFromMachineInfo(machineInfo)\n\n\treturn &containerManagerImpl{\n\t\tcapacity:          capacity,\n\t\tnodeConfig:        nodeConfig,\n\t\tcadvisorInterface: cadvisorInterface,\n\t}, nil\n}", "category": "Python"}, {"instruction": "// LogicalJoin can generates hash join, index join and sort merge join.\n// Firstly we check the hint, if hint is figured by user, we force to choose the corresponding physical plan.\n// If the hint is not matched, it will get other candidates.\n// If the hint is not figured, we will pick all candidates.", "input": "go language", "output": "func (p *LogicalJoin) exhaustPhysicalPlans(prop *property.PhysicalProperty) []PhysicalPlan {\n\tmergeJoins := p.getMergeJoin(prop)\n\tif (p.preferJoinType & preferMergeJoin) > 0 {\n\t\treturn mergeJoins\n\t}\n\tjoins := make([]PhysicalPlan, 0, 5)\n\tjoins = append(joins, mergeJoins...)\n\n\tindexJoins, forced := p.tryToGetIndexJoin(prop)\n\tif forced {\n\t\treturn indexJoins\n\t}\n\tjoins = append(joins, indexJoins...)\n\n\thashJoins := p.getHashJoins(prop)\n\tif (p.preferJoinType & preferHashJoin) > 0 {\n\t\treturn hashJoins\n\t}\n\tjoins = append(joins, hashJoins...)\n\treturn joins\n}", "category": "Python"}, {"instruction": "// expire is the generic check that move expired tasks from a pending pool back\n// into a task pool, returning all entities caught with expired tasks.\n//\n// Note, this method expects the queue lock to be already held. The\n// reason the lock is not obtained in here is because the parameters already need\n// to access the queue, so they already need a lock anyway.", "input": "go language", "output": "func (q *queue) expire(timeout time.Duration, pendPool map[string]*fetchRequest, taskQueue *prque.Prque, timeoutMeter metrics.Meter) map[string]int {\n\t// Iterate over the expired requests and return each to the queue\n\texpiries := make(map[string]int)\n\tfor id, request := range pendPool {\n\t\tif time.Since(request.Time) > timeout {\n\t\t\t// Update the metrics with the timeout\n\t\t\ttimeoutMeter.Mark(1)\n\n\t\t\t// Return any non satisfied requests to the pool\n\t\t\tif request.From > 0 {\n\t\t\t\ttaskQueue.Push(request.From, -int64(request.From))\n\t\t\t}\n\t\t\tfor _, header := range request.Headers {\n\t\t\t\ttaskQueue.Push(header, -int64(header.Number.Uint64()))\n\t\t\t}\n\t\t\t// Add the peer to the expiry report along the number of failed requests\n\t\t\texpiries[id] = len(request.Headers)\n\n\t\t\t// Remove the expired requests from the pending pool directly\n\t\t\tdelete(pendPool, id)\n\t\t}\n\t}\n\treturn expiries\n}", "category": "Python"}, {"instruction": "// Create creates a volume with the given name and driver\n// If the volume needs to be created with a reference to prevent race conditions\n// with volume cleanup, make sure to use the `CreateWithReference` option.", "input": "go language", "output": "func (s *VolumeStore) Create(ctx context.Context, name, driverName string, createOpts ...opts.CreateOption) (volume.Volume, error) {\n\tvar cfg opts.CreateConfig\n\tfor _, o := range createOpts {\n\t\to(&cfg)\n\t}\n\n\tname = normalizeVolumeName(name)\n\ts.locks.Lock(name)\n\tdefer s.locks.Unlock(name)\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tdefault:\n\t}\n\n\tv, err := s.create(ctx, name, driverName, cfg.Options, cfg.Labels)\n\tif err != nil {\n\t\tif _, ok := err.(*OpErr); ok {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, &OpErr{Err: err, Name: name, Op: \"create\"}\n\t}\n\n\ts.setNamed(v, cfg.Reference)\n\treturn v, nil\n}", "category": "Python"}, {"instruction": "// Verify checks that the passed signatures is valid with the respect to the passed digest, issuer public key,\n// and pseudonym public key.", "input": "go language", "output": "func (*NymSignatureScheme) Verify(ipk handlers.IssuerPublicKey, Nym handlers.Ecp, signature, digest []byte) (err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = errors.Errorf(\"failure [%s]\", r)\n\t\t}\n\t}()\n\n\tiipk, ok := ipk.(*IssuerPublicKey)\n\tif !ok {\n\t\treturn errors.Errorf(\"invalid issuer public key, expected *IssuerPublicKey, got [%T]\", ipk)\n\t}\n\tinym, ok := Nym.(*Ecp)\n\tif !ok {\n\t\treturn errors.Errorf(\"invalid nym public key, expected *Ecp, got [%T]\", Nym)\n\t}\n\n\tsig := &cryptolib.NymSignature{}\n\terr = proto.Unmarshal(signature, sig)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"error unmarshalling signature\")\n\t}\n\n\treturn sig.Ver(inym.E, iipk.PK, digest)\n}", "category": "Python"}, {"instruction": "// RegisterDefaults adds defaulters functions to the given scheme.\n// Public to allow building arbitrary schemes.\n// All generated defaulters are covering - they call all nested defaulters.", "input": "go language", "output": "func RegisterDefaults(scheme *runtime.Scheme) error {\n\tscheme.AddTypeDefaultingFunc(&ClusterConfiguration{}, func(obj interface{}) { SetObjectDefaults_ClusterConfiguration(obj.(*ClusterConfiguration)) })\n\tscheme.AddTypeDefaultingFunc(&ClusterStatus{}, func(obj interface{}) { SetObjectDefaults_ClusterStatus(obj.(*ClusterStatus)) })\n\tscheme.AddTypeDefaultingFunc(&InitConfiguration{}, func(obj interface{}) { SetObjectDefaults_InitConfiguration(obj.(*InitConfiguration)) })\n\tscheme.AddTypeDefaultingFunc(&JoinConfiguration{}, func(obj interface{}) { SetObjectDefaults_JoinConfiguration(obj.(*JoinConfiguration)) })\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Run will not return until stopCh is closed. workers determines how many\n// endpoints will be handled in parallel.", "input": "go language", "output": "func (e *EndpointController) Run(workers int, stopCh <-chan struct{}) {\n\tdefer utilruntime.HandleCrash()\n\tdefer e.queue.ShutDown()\n\n\tklog.Infof(\"Starting endpoint controller\")\n\tdefer klog.Infof(\"Shutting down endpoint controller\")\n\n\tif !controller.WaitForCacheSync(\"endpoint\", stopCh, e.podsSynced, e.servicesSynced, e.endpointsSynced) {\n\t\treturn\n\t}\n\n\tfor i := 0; i < workers; i++ {\n\t\tgo wait.Until(e.worker, e.workerLoopPeriod, stopCh)\n\t}\n\n\tgo func() {\n\t\tdefer utilruntime.HandleCrash()\n\t\te.checkLeftoverEndpoints()\n\t}()\n\n\t<-stopCh\n}", "category": "Python"}, {"instruction": "// Enables callback for keys received from a key exchange request", "input": "go language", "output": "func (ctl *HandshakeController) alertHandshake(pubkeyid string, symkeys []string) chan []string {\n\tctl.keyCMu.Lock()\n\tdefer ctl.keyCMu.Unlock()\n\tif len(symkeys) > 0 {\n\t\tif _, ok := ctl.keyC[pubkeyid]; ok {\n\t\t\tctl.keyC[pubkeyid] <- symkeys\n\t\t\tclose(ctl.keyC[pubkeyid])\n\t\t\tdelete(ctl.keyC, pubkeyid)\n\t\t}\n\t\treturn nil\n\t}\n\tif _, ok := ctl.keyC[pubkeyid]; !ok {\n\t\tctl.keyC[pubkeyid] = make(chan []string)\n\t}\n\treturn ctl.keyC[pubkeyid]\n}", "category": "Python"}, {"instruction": "// UserEvents is used to return a slice of the most recent\n// user events.", "input": "go language", "output": "func (a *Agent) UserEvents() []*UserEvent {\n\tn := len(a.eventBuf)\n\tout := make([]*UserEvent, n)\n\ta.eventLock.RLock()\n\tdefer a.eventLock.RUnlock()\n\n\t// Check if the buffer is full\n\tif a.eventBuf[a.eventIndex] != nil {\n\t\tif a.eventIndex == 0 {\n\t\t\tcopy(out, a.eventBuf)\n\t\t} else {\n\t\t\tcopy(out, a.eventBuf[a.eventIndex:])\n\t\t\tcopy(out[n-a.eventIndex:], a.eventBuf[:a.eventIndex])\n\t\t}\n\t} else {\n\t\t// We haven't filled the buffer yet\n\t\tcopy(out, a.eventBuf[:a.eventIndex])\n\t\tout = out[:a.eventIndex]\n\t}\n\treturn out\n}", "category": "Python"}, {"instruction": "// MountVolume mounts a Portworx Volume on the specified mountPath", "input": "go language", "output": "func (util *portworxVolumeUtil) MountVolume(m *portworxVolumeMounter, mountPath string) error {\n\tdriver, err := util.getLocalPortworxDriver(m.plugin.host)\n\tif err != nil || driver == nil {\n\t\tklog.Errorf(\"Failed to get portworx driver. Err: %v\", err)\n\t\treturn err\n\t}\n\n\terr = driver.Mount(m.volName, mountPath)\n\tif err != nil {\n\t\tklog.Errorf(\"Error mounting Portworx Volume (%v) on Path (%v): %v\", m.volName, mountPath, err)\n\t\treturn err\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// ResolveIndices implements Plan interface.", "input": "go language", "output": "func (p *PhysicalIndexReader) ResolveIndices() (err error) {\n\terr = p.physicalSchemaProducer.ResolveIndices()\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = p.indexPlan.ResolveIndices()\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor i, col := range p.OutputColumns {\n\t\tnewCol, err := col.ResolveIndices(p.indexPlan.Schema())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tp.OutputColumns[i] = newCol.(*expression.Column)\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// SetIntermediate writes the incoming intermediate and root certificates to the\n// intermediate backend (as a chain).", "input": "go language", "output": "func (v *VaultProvider) SetIntermediate(intermediatePEM, rootPEM string) error {\n\tif v.isRoot {\n\t\treturn fmt.Errorf(\"cannot set an intermediate using another root in the primary datacenter\")\n\t}\n\n\t_, err := v.client.Logical().Write(v.config.IntermediatePKIPath+\"intermediate/set-signed\", map[string]interface{}{\n\t\t\"certificate\": fmt.Sprintf(\"%s\\n%s\", intermediatePEM, rootPEM),\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// ReadDataSource returns the data source's current state.", "input": "go language", "output": "func (p *Provider) ReadDataSource(req providers.ReadDataSourceRequest) providers.ReadDataSourceResponse {\n\t// call function\n\tvar res providers.ReadDataSourceResponse\n\n\t// This should not happen\n\tif req.TypeName != \"terraform_remote_state\" {\n\t\tres.Diagnostics.Append(fmt.Errorf(\"Error: unsupported data source %s\", req.TypeName))\n\t\treturn res\n\t}\n\n\tnewState, diags := dataSourceRemoteStateRead(&req.Config)\n\n\tres.State = newState\n\tres.Diagnostics = diags\n\n\treturn res\n}", "category": "Python"}, {"instruction": "// References returns a slice of references to the given ID. The slice\n// will be nil if there are no references to this ID.", "input": "go language", "output": "func (store *store) References(id digest.Digest) []reference.Named {\n\tstore.mu.RLock()\n\tdefer store.mu.RUnlock()\n\n\t// Convert the internal map to an array for two reasons:\n\t// 1) We must not return a mutable\n\t// 2) It would be ugly to expose the extraneous map keys to callers.\n\n\tvar references []reference.Named\n\tfor _, ref := range store.referencesByIDCache[id] {\n\t\treferences = append(references, ref)\n\t}\n\n\tsort.Sort(lexicalRefs(references))\n\n\treturn references\n}", "category": "Python"}, {"instruction": "// RegisterEthService adds an Ethereum client to the stack.", "input": "go language", "output": "func RegisterEthService(stack *node.Node, cfg *eth.Config) {\n\tvar err error\n\tif cfg.SyncMode == downloader.LightSync {\n\t\terr = stack.Register(func(ctx *node.ServiceContext) (node.Service, error) {\n\t\t\treturn les.New(ctx, cfg)\n\t\t})\n\t} else {\n\t\terr = stack.Register(func(ctx *node.ServiceContext) (node.Service, error) {\n\t\t\tfullNode, err := eth.New(ctx, cfg)\n\t\t\tif fullNode != nil && cfg.LightServ > 0 {\n\t\t\t\tls, _ := les.NewLesServer(fullNode, cfg)\n\t\t\t\tfullNode.AddLesServer(ls)\n\t\t\t}\n\t\t\treturn fullNode, err\n\t\t})\n\t}\n\tif err != nil {\n\t\tFatalf(\"Failed to register the Ethereum service: %v\", err)\n\t}\n}", "category": "Python"}, {"instruction": "// unpackAtomic unpacks ( hexdata -> go ) a single value", "input": "go language", "output": "func (arguments Arguments) unpackAtomic(v interface{}, marshalledValues interface{}) error {\n\tif arguments.LengthNonIndexed() == 0 {\n\t\treturn nil\n\t}\n\targument := arguments.NonIndexed()[0]\n\telem := reflect.ValueOf(v).Elem()\n\n\tif elem.Kind() == reflect.Struct {\n\t\tfieldmap, err := mapArgNamesToStructFields([]string{argument.Name}, elem)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfield := elem.FieldByName(fieldmap[argument.Name])\n\t\tif !field.IsValid() {\n\t\t\treturn fmt.Errorf(\"abi: field %s can't be found in the given value\", argument.Name)\n\t\t}\n\t\treturn unpack(&argument.Type, field.Addr().Interface(), marshalledValues)\n\t}\n\treturn unpack(&argument.Type, elem.Addr().Interface(), marshalledValues)\n}", "category": "Python"}, {"instruction": "// Detach checks with the GCE cloud provider if the specified volume is already\n// attached to the specified node. If the volume is not attached, it succeeds\n// (returns nil). If it is attached, Detach issues a call to the GCE cloud\n// provider to attach it.\n// Callers are responsible for retrying on failure.\n// Callers are responsible for thread safety between concurrent attach and detach\n// operations.", "input": "go language", "output": "func (detacher *gcePersistentDiskDetacher) Detach(volumeName string, nodeName types.NodeName) error {\n\tpdName := path.Base(volumeName)\n\n\tattached, err := detacher.gceDisks.DiskIsAttached(pdName, nodeName)\n\tif err != nil {\n\t\t// Log error and continue with detach\n\t\tklog.Errorf(\n\t\t\t\"Error checking if PD (%q) is already attached to current node (%q). Will continue and try detach anyway. err=%v\",\n\t\t\tpdName, nodeName, err)\n\t}\n\n\tif err == nil && !attached {\n\t\t// Volume is not attached to node. Success!\n\t\tklog.Infof(\"Detach operation is successful. PD %q was not attached to node %q.\", pdName, nodeName)\n\t\treturn nil\n\t}\n\n\tif err = detacher.gceDisks.DetachDisk(pdName, nodeName); err != nil {\n\t\tklog.Errorf(\"Error detaching PD %q from node %q: %v\", pdName, nodeName, err)\n\t\treturn err\n\t}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Read returns a full YAML document.", "input": "go language", "output": "func (r *YAMLReader) Read() ([]byte, error) {\n\tvar buffer bytes.Buffer\n\tfor {\n\t\tline, err := r.reader.Read()\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tsep := len([]byte(separator))\n\t\tif i := bytes.Index(line, []byte(separator)); i == 0 {\n\t\t\t// We have a potential document terminator\n\t\t\ti += sep\n\t\t\tafter := line[i:]\n\t\t\tif len(strings.TrimRightFunc(string(after), unicode.IsSpace)) == 0 {\n\t\t\t\tif buffer.Len() != 0 {\n\t\t\t\t\treturn buffer.Bytes(), nil\n\t\t\t\t}\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif err == io.EOF {\n\t\t\tif buffer.Len() != 0 {\n\t\t\t\t// If we're at EOF, we have a final, non-terminated line. Return it.\n\t\t\t\treturn buffer.Bytes(), nil\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tbuffer.Write(line)\n\t}\n}", "category": "Python"}, {"instruction": "// grantGlobalPriv manipulates mysql.user table.", "input": "go language", "output": "func (e *GrantExec) grantGlobalPriv(priv *ast.PrivElem, user *ast.UserSpec) error {\n\tif priv.Priv == 0 {\n\t\treturn nil\n\t}\n\tasgns, err := composeGlobalPrivUpdate(priv.Priv, \"Y\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tsql := fmt.Sprintf(`UPDATE %s.%s SET %s WHERE User='%s' AND Host='%s'`, mysql.SystemDB, mysql.UserTable, asgns, user.User.Username, user.User.Hostname)\n\t_, _, err = e.ctx.(sqlexec.RestrictedSQLExecutor).ExecRestrictedSQL(e.ctx, sql)\n\treturn err\n}", "category": "Python"}, {"instruction": "// podMatchesScopeFunc is a function that knows how to evaluate if a pod matches a scope", "input": "go language", "output": "func podMatchesScopeFunc(selector corev1.ScopedResourceSelectorRequirement, object runtime.Object) (bool, error) {\n\tpod, err := toExternalPodOrError(object)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tswitch selector.ScopeName {\n\tcase corev1.ResourceQuotaScopeTerminating:\n\t\treturn isTerminating(pod), nil\n\tcase corev1.ResourceQuotaScopeNotTerminating:\n\t\treturn !isTerminating(pod), nil\n\tcase corev1.ResourceQuotaScopeBestEffort:\n\t\treturn isBestEffort(pod), nil\n\tcase corev1.ResourceQuotaScopeNotBestEffort:\n\t\treturn !isBestEffort(pod), nil\n\tcase corev1.ResourceQuotaScopePriorityClass:\n\t\treturn podMatchesSelector(pod, selector)\n\t}\n\treturn false, nil\n}", "category": "Python"}, {"instruction": "// Need to hold lock on m.fmut when calling this.", "input": "go language", "output": "func (m *model) tearDownFolderLocked(cfg config.FolderConfiguration, err error) {\n\t// Stop the services running for this folder and wait for them to finish\n\t// stopping to prevent races on restart.\n\ttokens := m.folderRunnerTokens[cfg.ID]\n\n\tm.fmut.Unlock()\n\n\t// Close connections to affected devices\n\t// Must happen before stopping the folder service to abort ongoing\n\t// transmissions and thus allow timely service termination.\n\tm.closeConns(cfg.DeviceIDs(), err)\n\n\tfor _, id := range tokens {\n\t\tm.RemoveAndWait(id, 0)\n\t}\n\n\tm.fmut.Lock()\n\n\t// Clean up our config maps\n\tdelete(m.folderCfgs, cfg.ID)\n\tdelete(m.folderFiles, cfg.ID)\n\tdelete(m.folderIgnores, cfg.ID)\n\tdelete(m.folderRunners, cfg.ID)\n\tdelete(m.folderRunnerTokens, cfg.ID)\n}", "category": "Python"}, {"instruction": "// Recv receives a message from a remote cluster member.", "input": "go language", "output": "func (stream *Stream) Recv() (*orderer.StepResponse, error) {\n\tstart := time.Now()\n\tdefer func() {\n\t\tif !stream.Logger.IsEnabledFor(zap.DebugLevel) {\n\t\t\treturn\n\t\t}\n\t\tstream.Logger.Debugf(\"Receive from %s(%s) took %v\", stream.NodeName, stream.Endpoint, time.Since(start))\n\t}()\n\n\tf := func() (*orderer.StepResponse, error) {\n\t\treturn stream.Cluster_StepClient.Recv()\n\t}\n\n\treturn stream.operateWithTimeout(f)\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *ISCSIPersistentVolumeSource) DeepCopyInto(out *ISCSIPersistentVolumeSource) {\n\t*out = *in\n\tif in.Portals != nil {\n\t\tin, out := &in.Portals, &out.Portals\n\t\t*out = make([]string, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\tif in.SecretRef != nil {\n\t\tin, out := &in.SecretRef, &out.SecretRef\n\t\t*out = new(SecretReference)\n\t\t**out = **in\n\t}\n\tif in.InitiatorName != nil {\n\t\tin, out := &in.InitiatorName, &out.InitiatorName\n\t\t*out = new(string)\n\t\t**out = **in\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// setWS creates the WebSocket RPC listener interface string from the set\n// command line flags, returning empty if the HTTP endpoint is disabled.", "input": "go language", "output": "func setWS(ctx *cli.Context, cfg *node.Config) {\n\tif ctx.GlobalBool(WSEnabledFlag.Name) && cfg.WSHost == \"\" {\n\t\tcfg.WSHost = \"127.0.0.1\"\n\t\tif ctx.GlobalIsSet(WSListenAddrFlag.Name) {\n\t\t\tcfg.WSHost = ctx.GlobalString(WSListenAddrFlag.Name)\n\t\t}\n\t}\n\n\tif ctx.GlobalIsSet(WSPortFlag.Name) {\n\t\tcfg.WSPort = ctx.GlobalInt(WSPortFlag.Name)\n\t}\n\tif ctx.GlobalIsSet(WSAllowedOriginsFlag.Name) {\n\t\tcfg.WSOrigins = splitAndTrim(ctx.GlobalString(WSAllowedOriginsFlag.Name))\n\t}\n\tif ctx.GlobalIsSet(WSApiFlag.Name) {\n\t\tcfg.WSModules = splitAndTrim(ctx.GlobalString(WSApiFlag.Name))\n\t}\n}", "category": "Python"}, {"instruction": "// make push instruction function", "input": "go language", "output": "func makePush(size uint64, pushByteSize int) executionFunc {\n\treturn func(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {\n\t\tcodeLen := len(contract.Code)\n\n\t\tstartMin := codeLen\n\t\tif int(*pc+1) < startMin {\n\t\t\tstartMin = int(*pc + 1)\n\t\t}\n\n\t\tendMin := codeLen\n\t\tif startMin+pushByteSize < endMin {\n\t\t\tendMin = startMin + pushByteSize\n\t\t}\n\n\t\tinteger := interpreter.intPool.get()\n\t\tstack.push(integer.SetBytes(common.RightPadBytes(contract.Code[startMin:endMin], pushByteSize)))\n\n\t\t*pc += size\n\t\treturn nil, nil\n\t}\n}", "category": "Python"}, {"instruction": "// Patch applies the patch and returns the patched controllerRevision.", "input": "go language", "output": "func (c *FakeControllerRevisions) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1beta2.ControllerRevision, err error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewPatchSubresourceAction(controllerrevisionsResource, c.ns, name, pt, data, subresources...), &v1beta2.ControllerRevision{})\n\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\treturn obj.(*v1beta2.ControllerRevision), err\n}", "category": "Python"}, {"instruction": "// ToleratesTaint checks if the toleration tolerates the taint.\n// The matching follows the rules below:\n// (1) Empty toleration.effect means to match all taint effects,\n//     otherwise taint effect must equal to toleration.effect.\n// (2) If toleration.operator is 'Exists', it means to match all taint values.\n// (3) Empty toleration.key means to match all taint keys.\n//     If toleration.key is empty, toleration.operator must be 'Exists';\n//     this combination means to match all taint values and all taint keys.", "input": "go language", "output": "func (t *Toleration) ToleratesTaint(taint *Taint) bool {\n\tif len(t.Effect) > 0 && t.Effect != taint.Effect {\n\t\treturn false\n\t}\n\n\tif len(t.Key) > 0 && t.Key != taint.Key {\n\t\treturn false\n\t}\n\n\t// TODO: Use proper defaulting when Toleration becomes a field of PodSpec\n\tswitch t.Operator {\n\t// empty operator means Equal\n\tcase \"\", TolerationOpEqual:\n\t\treturn t.Value == taint.Value\n\tcase TolerationOpExists:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}", "category": "Python"}, {"instruction": "// Manifest hack for supporting Swarm feeds from the bzz: scheme\n// see swarm/api/api.go:API.Get() for more information", "input": "go language", "output": "func (a *API) NewFeedManifest(ctx context.Context, feed *feed.Feed) (storage.Address, error) {\n\tvar manifest Manifest\n\tentry := ManifestEntry{\n\t\tFeed:        feed,\n\t\tContentType: FeedContentType,\n\t}\n\tmanifest.Entries = append(manifest.Entries, entry)\n\tdata, err := json.Marshal(&manifest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\taddr, wait, err := a.Store(ctx, bytes.NewReader(data), int64(len(data)), false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = wait(ctx)\n\treturn addr, err\n}", "category": "Python"}, {"instruction": "// ACLTokenListExpires lists tokens that are expired as of the provided time.\n// The returned set will be no larger than the max value provided.", "input": "go language", "output": "func (s *Store) ACLTokenListExpired(local bool, asOf time.Time, max int) (structs.ACLTokens, <-chan struct{}, error) {\n\ttx := s.db.Txn(false)\n\tdefer tx.Abort()\n\n\titer, err := tx.Get(\"acl-tokens\", s.expiresIndexName(local))\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed acl token listing: %v\", err)\n\t}\n\n\tvar (\n\t\ttokens structs.ACLTokens\n\t\ti      int\n\t)\n\tfor raw := iter.Next(); raw != nil; raw = iter.Next() {\n\t\ttoken := raw.(*structs.ACLToken)\n\t\tif token.ExpirationTime != nil && !token.ExpirationTime.Before(asOf) {\n\t\t\treturn tokens, nil, nil\n\t\t}\n\n\t\ttokens = append(tokens, token)\n\t\ti += 1\n\t\tif i >= max {\n\t\t\treturn tokens, nil, nil\n\t\t}\n\t}\n\n\treturn tokens, iter.WatchCh(), nil\n}", "category": "Python"}, {"instruction": "// DefaultVersionedAPIPathFor constructs the default path for the given group version, assuming the given\n// API path, following the standard conventions of the Kubernetes API.", "input": "go language", "output": "func DefaultVersionedAPIPath(apiPath string, groupVersion schema.GroupVersion) string {\n\tversionedAPIPath := path.Join(\"/\", apiPath)\n\n\t// Add the version to the end of the path\n\tif len(groupVersion.Group) > 0 {\n\t\tversionedAPIPath = path.Join(versionedAPIPath, groupVersion.Group, groupVersion.Version)\n\n\t} else {\n\t\tversionedAPIPath = path.Join(versionedAPIPath, groupVersion.Version)\n\t}\n\n\treturn versionedAPIPath\n}", "category": "Python"}, {"instruction": "// ResolveIndices implements Plan interface.", "input": "go language", "output": "func (p *PhysicalProjection) ResolveIndices() (err error) {\n\terr = p.physicalSchemaProducer.ResolveIndices()\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor i, expr := range p.Exprs {\n\t\tp.Exprs[i], err = expr.ResolveIndices(p.children[0].Schema())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tchildProj, isProj := p.children[0].(*PhysicalProjection)\n\tif !isProj {\n\t\treturn\n\t}\n\trefine4NeighbourProj(p, childProj)\n\treturn\n}", "category": "Python"}, {"instruction": "// GetNetworks returns a list of all networks", "input": "go language", "output": "func (daemon *Daemon) GetNetworks(filter filters.Args, config types.NetworkListConfig) ([]types.NetworkResource, error) {\n\tnetworks := daemon.getAllNetworks()\n\n\tlist := make([]types.NetworkResource, 0, len(networks))\n\tvar idx map[string]libnetwork.Network\n\tif config.Detailed {\n\t\tidx = make(map[string]libnetwork.Network)\n\t}\n\n\tfor _, n := range networks {\n\t\tnr := buildNetworkResource(n)\n\t\tlist = append(list, nr)\n\t\tif config.Detailed {\n\t\t\tidx[nr.ID] = n\n\t\t}\n\t}\n\n\tvar err error\n\tlist, err = internalnetwork.FilterNetworks(list, filter)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif config.Detailed {\n\t\tfor i, n := range list {\n\t\t\tnp := &n\n\t\t\tbuildDetailedNetworkResources(np, idx[n.ID], config.Verbose)\n\t\t\tlist[i] = *np\n\t\t}\n\t}\n\n\treturn list, nil\n}", "category": "Python"}, {"instruction": "// doExecMount calls exec(mount <what> <where>) using given exec interface.", "input": "go language", "output": "func (m *execMounter) doExecMount(source, target, fstype string, options []string) error {\n\tklog.V(5).Infof(\"Exec Mounting %s %s %s %v\", source, target, fstype, options)\n\tmountArgs := mount.MakeMountArgs(source, target, fstype, options)\n\toutput, err := m.exec.Run(\"mount\", mountArgs...)\n\tklog.V(5).Infof(\"Exec mounted %v: %v: %s\", mountArgs, err, string(output))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"mount failed: %v\\nMounting command: %s\\nMounting arguments: %s %s %s %v\\nOutput: %s\",\n\t\t\terr, \"mount\", source, target, fstype, options, string(output))\n\t}\n\n\treturn err\n}", "category": "Python"}, {"instruction": "// handleEvents is used to process incoming user events", "input": "go language", "output": "func (a *Agent) handleEvents() {\n\tfor {\n\t\tselect {\n\t\tcase e := <-a.eventCh:\n\t\t\t// Decode the event\n\t\t\tmsg := new(UserEvent)\n\t\t\tif err := decodeMsgPack(e.Payload, msg); err != nil {\n\t\t\t\ta.logger.Printf(\"[ERR] agent: Failed to decode event: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tmsg.LTime = uint64(e.LTime)\n\n\t\t\t// Skip if we don't pass filtering\n\t\t\tif !a.shouldProcessUserEvent(msg) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Ingest the event\n\t\t\ta.ingestUserEvent(msg)\n\n\t\tcase <-a.shutdownCh:\n\t\t\treturn\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// Next implements the Executor Next interface.", "input": "go language", "output": "func (e *ShowDDLJobQueriesExec) Next(ctx context.Context, req *chunk.RecordBatch) error {\n\treq.GrowAndReset(e.maxChunkSize)\n\tif e.cursor >= len(e.jobs) {\n\t\treturn nil\n\t}\n\tif len(e.jobIDs) >= len(e.jobs) {\n\t\treturn nil\n\t}\n\tnumCurBatch := mathutil.Min(req.Capacity(), len(e.jobs)-e.cursor)\n\tfor _, id := range e.jobIDs {\n\t\tfor i := e.cursor; i < e.cursor+numCurBatch; i++ {\n\t\t\tif id == e.jobs[i].ID {\n\t\t\t\treq.AppendString(0, e.jobs[i].Query)\n\t\t\t}\n\t\t}\n\t}\n\te.cursor += numCurBatch\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Check checks schema validity, returns true if use schemaVer and related tables at txnTS is legal.", "input": "go language", "output": "func (s *schemaValidator) Check(txnTS uint64, schemaVer int64, relatedTableIDs []int64) checkResult {\n\ts.mux.RLock()\n\tdefer s.mux.RUnlock()\n\tif !s.isStarted {\n\t\tlogutil.Logger(context.Background()).Info(\"the schema validator stopped before checking\")\n\t\treturn ResultUnknown\n\t}\n\tif s.lease == 0 {\n\t\treturn ResultSucc\n\t}\n\n\t// Schema changed, result decided by whether related tables change.\n\tif schemaVer < s.latestSchemaVer {\n\t\t// The DDL relatedTableIDs is empty.\n\t\tif len(relatedTableIDs) == 0 {\n\t\t\tlogutil.Logger(context.Background()).Info(\"the related table ID is empty\", zap.Int64(\"schemaVer\", schemaVer),\n\t\t\t\tzap.Int64(\"latestSchemaVer\", s.latestSchemaVer))\n\t\t\treturn ResultFail\n\t\t}\n\n\t\tif s.isRelatedTablesChanged(schemaVer, relatedTableIDs) {\n\t\t\treturn ResultFail\n\t\t}\n\t\treturn ResultSucc\n\t}\n\n\t// Schema unchanged, maybe success or the schema validator is unavailable.\n\tt := oracle.GetTimeFromTS(txnTS)\n\tif t.After(s.latestSchemaExpire) {\n\t\treturn ResultUnknown\n\t}\n\treturn ResultSucc\n}", "category": "Python"}, {"instruction": "// Function to call on webhook failure; behavior determined by defaultAllow flag", "input": "go language", "output": "func (a *Plugin) webhookError(pod *api.Pod, attributes admission.Attributes, err error) error {\n\tif err != nil {\n\t\tklog.V(2).Infof(\"error contacting webhook backend: %s\", err)\n\t\tif a.defaultAllow {\n\t\t\tattributes.AddAnnotation(AuditKeyPrefix+ImagePolicyFailedOpenKeySuffix, \"true\")\n\t\t\t// TODO(wteiken): Remove the annotation code for the 1.13 release\n\t\t\tannotations := pod.GetAnnotations()\n\t\t\tif annotations == nil {\n\t\t\t\tannotations = make(map[string]string)\n\t\t\t}\n\t\t\tannotations[api.ImagePolicyFailedOpenKey] = \"true\"\n\t\t\tpod.ObjectMeta.SetAnnotations(annotations)\n\n\t\t\tklog.V(2).Infof(\"resource allowed in spite of webhook backend failure\")\n\t\t\treturn nil\n\t\t}\n\t\tklog.V(2).Infof(\"resource not allowed due to webhook backend failure \")\n\t\treturn admission.NewForbidden(attributes, err)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Returns the list of component status. Note that the label and field are both ignored.\n// Note that this call doesn't support labels or selectors.", "input": "go language", "output": "func (rs *REST) List(ctx context.Context, options *metainternalversion.ListOptions) (runtime.Object, error) {\n\tservers := rs.GetServersToValidate()\n\n\twait := sync.WaitGroup{}\n\twait.Add(len(servers))\n\tstatuses := make(chan api.ComponentStatus, len(servers))\n\tfor k, v := range servers {\n\t\tgo func(name string, server *Server) {\n\t\t\tdefer wait.Done()\n\t\t\tstatus := rs.getComponentStatus(name, server)\n\t\t\tstatuses <- *status\n\t\t}(k, v)\n\t}\n\twait.Wait()\n\tclose(statuses)\n\n\treply := []api.ComponentStatus{}\n\tfor status := range statuses {\n\t\treply = append(reply, status)\n\t}\n\treturn &api.ComponentStatusList{Items: reply}, nil\n}", "category": "Python"}, {"instruction": "// Patch applies the patch and returns the patched persistentVolumeClaim.", "input": "go language", "output": "func (c *FakePersistentVolumeClaims) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *corev1.PersistentVolumeClaim, err error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewPatchSubresourceAction(persistentvolumeclaimsResource, c.ns, name, pt, data, subresources...), &corev1.PersistentVolumeClaim{})\n\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\treturn obj.(*corev1.PersistentVolumeClaim), err\n}", "category": "Python"}, {"instruction": "// Get performs an HTTP GET and returns the bytes and/or an error. Any non-200\n// return code is returned as an error.", "input": "go language", "output": "func (p *Process) Get(path string) ([]byte, error) {\n\tclient := &http.Client{\n\t\tTimeout: 30 * time.Second,\n\t\tTransport: &http.Transport{\n\t\t\tDial:              dialer.Dial,\n\t\t\tProxy:             http.ProxyFromEnvironment,\n\t\t\tDisableKeepAlives: true,\n\t\t},\n\t}\n\n\turl := fmt.Sprintf(\"http://%s%s\", p.addr, path)\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"X-API-Key\", APIKey)\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn p.readResponse(resp)\n}", "category": "Python"}, {"instruction": "// StrategicMergeMapPatch applies a strategic merge patch. The original and patch documents\n// must be JSONMap. A patch can be created from an original and modified document by\n// calling CreateTwoWayMergeMapPatch.\n// Warning: the original and patch JSONMap objects are mutated by this function and should not be reused.", "input": "go language", "output": "func StrategicMergeMapPatch(original, patch JSONMap, dataStruct interface{}) (JSONMap, error) {\n\tschema, err := NewPatchMetaFromStruct(dataStruct)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We need the go struct tags `patchMergeKey` and `patchStrategy` for fields that support a strategic merge patch.\n\t// For native resources, we can easily figure out these tags since we know the fields.\n\n\t// Because custom resources are decoded as Unstructured and because we're missing the metadata about how to handle\n\t// each field in a strategic merge patch, we can't find the go struct tags. Hence, we can't easily  do a strategic merge\n\t// for custom resources. So we should fail fast and return an error.\n\tif _, ok := dataStruct.(*unstructured.Unstructured); ok {\n\t\treturn nil, mergepatch.ErrUnsupportedStrategicMergePatchFormat\n\t}\n\n\treturn StrategicMergeMapPatchUsingLookupPatchMeta(original, patch, schema)\n}", "category": "Python"}, {"instruction": "// Insert the given request into the cache and returns the token used for fetching it out.", "input": "go language", "output": "func (c *requestCache) Insert(req request) (token string, err error) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\t// Remove expired entries.\n\tc.gc()\n\t// If the cache is full, reject the request.\n\tif c.ll.Len() == maxInFlight {\n\t\treturn \"\", NewErrorTooManyInFlight()\n\t}\n\ttoken, err = c.uniqueToken()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tele := c.ll.PushFront(&cacheEntry{token, req, c.clock.Now().Add(cacheTTL)})\n\n\tc.tokens[token] = ele\n\treturn token, nil\n}", "category": "Python"}, {"instruction": "// hashimotoLight aggregates data from the full dataset (using only a small\n// in-memory cache) in order to produce our final value for a particular header\n// hash and nonce.", "input": "go language", "output": "func hashimotoLight(size uint64, cache []uint32, hash []byte, nonce uint64) ([]byte, []byte) {\n\tkeccak512 := makeHasher(sha3.NewLegacyKeccak512())\n\n\tlookup := func(index uint32) []uint32 {\n\t\trawData := generateDatasetItem(cache, index, keccak512)\n\n\t\tdata := make([]uint32, len(rawData)/4)\n\t\tfor i := 0; i < len(data); i++ {\n\t\t\tdata[i] = binary.LittleEndian.Uint32(rawData[i*4:])\n\t\t}\n\t\treturn data\n\t}\n\treturn hashimoto(hash, nonce, size, lookup)\n}", "category": "Python"}, {"instruction": "// Next implements the Executor Next interface.", "input": "go language", "output": "func (e *DeallocateExec) Next(ctx context.Context, req *chunk.RecordBatch) error {\n\tvars := e.ctx.GetSessionVars()\n\tid, ok := vars.PreparedStmtNameToID[e.Name]\n\tif !ok {\n\t\treturn errors.Trace(plannercore.ErrStmtNotFound)\n\t}\n\tdelete(vars.PreparedStmtNameToID, e.Name)\n\tif plannercore.PreparedPlanCacheEnabled() {\n\t\te.ctx.PreparedPlanCache().Delete(plannercore.NewPSTMTPlanCacheKey(\n\t\t\tvars, id, vars.PreparedStmts[id].SchemaVersion,\n\t\t))\n\t}\n\tvars.RemovePreparedStmt(id)\n\treturn nil\n}", "category": "Python"}, {"instruction": "// NewOnAddresses creates a new PortForwarder with custom listen addresses.", "input": "go language", "output": "func NewOnAddresses(dialer httpstream.Dialer, addresses []string, ports []string, stopChan <-chan struct{}, readyChan chan struct{}, out, errOut io.Writer) (*PortForwarder, error) {\n\tif len(addresses) == 0 {\n\t\treturn nil, errors.New(\"You must specify at least 1 address\")\n\t}\n\tparsedAddresses, err := parseAddresses(addresses)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(ports) == 0 {\n\t\treturn nil, errors.New(\"You must specify at least 1 port\")\n\t}\n\tparsedPorts, err := parsePorts(ports)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &PortForwarder{\n\t\tdialer:    dialer,\n\t\taddresses: parsedAddresses,\n\t\tports:     parsedPorts,\n\t\tstopChan:  stopChan,\n\t\tReady:     readyChan,\n\t\tout:       out,\n\t\terrOut:    errOut,\n\t}, nil\n}", "category": "Python"}, {"instruction": "// SetClientRootCAs sets the list of authorities used to verify client\n// certificates based on a list of PEM-encoded X509 certificate authorities", "input": "go language", "output": "func (gServer *GRPCServer) SetClientRootCAs(clientRoots [][]byte) error {\n\tgServer.lock.Lock()\n\tdefer gServer.lock.Unlock()\n\n\terrMsg := \"Failed to set client root certificate(s): %s\"\n\n\t//create a new map and CertPool\n\tclientRootCAs := make(map[string]*x509.Certificate)\n\tfor _, clientRoot := range clientRoots {\n\t\tcerts, subjects, err := pemToX509Certs(clientRoot)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(errMsg, err.Error())\n\t\t}\n\t\tif len(certs) >= 1 {\n\t\t\tfor i, cert := range certs {\n\t\t\t\t//add it to our clientRootCAs map using subject as key\n\t\t\t\tclientRootCAs[subjects[i]] = cert\n\t\t\t}\n\t\t}\n\t}\n\n\t//create a new CertPool and populate with the new clientRootCAs\n\tcertPool := x509.NewCertPool()\n\tfor _, clientRoot := range clientRootCAs {\n\t\tcertPool.AddCert(clientRoot)\n\t}\n\t//replace the internal map\n\tgServer.clientRootCAs = clientRootCAs\n\t//replace the current ClientCAs pool\n\tgServer.tlsConfig.ClientCAs = certPool\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Format the ExprNode into a Writer.", "input": "go language", "output": "func (n *ValueExpr) Format(w io.Writer) {\n\tvar s string\n\tswitch n.Kind() {\n\tcase types.KindNull:\n\t\ts = \"NULL\"\n\tcase types.KindInt64:\n\t\tif n.Type.Flag&mysql.IsBooleanFlag != 0 {\n\t\t\tif n.GetInt64() > 0 {\n\t\t\t\ts = \"TRUE\"\n\t\t\t} else {\n\t\t\t\ts = \"FALSE\"\n\t\t\t}\n\t\t} else {\n\t\t\ts = strconv.FormatInt(n.GetInt64(), 10)\n\t\t}\n\tcase types.KindUint64:\n\t\ts = strconv.FormatUint(n.GetUint64(), 10)\n\tcase types.KindFloat32:\n\t\ts = strconv.FormatFloat(n.GetFloat64(), 'e', -1, 32)\n\tcase types.KindFloat64:\n\t\ts = strconv.FormatFloat(n.GetFloat64(), 'e', -1, 64)\n\tcase types.KindString, types.KindBytes:\n\t\ts = strconv.Quote(n.GetString())\n\tcase types.KindMysqlDecimal:\n\t\ts = n.GetMysqlDecimal().String()\n\tcase types.KindBinaryLiteral:\n\t\tif n.Type.Flag&mysql.UnsignedFlag != 0 {\n\t\t\ts = fmt.Sprintf(\"x'%x'\", n.GetBytes())\n\t\t} else {\n\t\t\ts = n.GetBinaryLiteral().ToBitLiteralString(true)\n\t\t}\n\tdefault:\n\t\tpanic(\"Can't format to string\")\n\t}\n\tfmt.Fprint(w, s)\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *LimitedResource) DeepCopyInto(out *LimitedResource) {\n\t*out = *in\n\tif in.MatchContains != nil {\n\t\tin, out := &in.MatchContains, &out.MatchContains\n\t\t*out = make([]string, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\tif in.MatchScopes != nil {\n\t\tin, out := &in.MatchScopes, &out.MatchScopes\n\t\t*out = make([]v1.ScopedResourceSelectorRequirement, len(*in))\n\t\tfor i := range *in {\n\t\t\t(*in)[i].DeepCopyInto(&(*out)[i])\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// InstanceID returns the cloud provider ID of the node with the specified nodeName.", "input": "go language", "output": "func (c *Cloud) InstanceID(ctx context.Context, nodeName types.NodeName) (string, error) {\n\t// In the future it is possible to also return an endpoint as:\n\t// <endpoint>/<zone>/<instanceid>\n\tif c.selfAWSInstance.nodeName == nodeName {\n\t\treturn \"/\" + c.selfAWSInstance.availabilityZone + \"/\" + c.selfAWSInstance.awsID, nil\n\t}\n\tinst, err := c.getInstanceByNodeName(nodeName)\n\tif err != nil {\n\t\tif err == cloudprovider.InstanceNotFound {\n\t\t\t// The Instances interface requires that we return InstanceNotFound (without wrapping)\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn \"\", fmt.Errorf(\"getInstanceByNodeName failed for %q with %q\", nodeName, err)\n\t}\n\treturn \"/\" + aws.StringValue(inst.Placement.AvailabilityZone) + \"/\" + aws.StringValue(inst.InstanceId), nil\n}", "category": "Python"}, {"instruction": "// elgEnabledCollNames returns the names of the collections for which the peer is not eligible as per 'existingPkg' and is eligible as per 'postCommitPkg'", "input": "go language", "output": "func (n *collElgNotifier) elgEnabledCollNames(ledgerID string,\n\texistingPkg, postCommitPkg *common.CollectionConfigPackage) ([]string, error) {\n\n\tcollectionNames := []string{}\n\texisingConfs := retrieveCollConfs(existingPkg)\n\tpostCommitConfs := retrieveCollConfs(postCommitPkg)\n\texistingConfMap := map[string]*common.StaticCollectionConfig{}\n\tfor _, existingConf := range exisingConfs {\n\t\texistingConfMap[existingConf.Name] = existingConf\n\t}\n\n\tfor _, postCommitConf := range postCommitConfs {\n\t\tcollName := postCommitConf.Name\n\t\texistingConf, ok := existingConfMap[collName]\n\t\tif !ok { // brand new collection\n\t\t\tcontinue\n\t\t}\n\t\tmembershipEnabled, err := n.elgEnabled(ledgerID, existingConf.MemberOrgsPolicy, postCommitConf.MemberOrgsPolicy)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif !membershipEnabled {\n\t\t\tcontinue\n\t\t}\n\t\t// not an existing member and added now\n\t\tcollectionNames = append(collectionNames, collName)\n\t}\n\treturn collectionNames, nil\n}", "category": "Python"}, {"instruction": "// scaleForResourceMappings attempts to fetch the scale for the\n// resource with the given name and namespace, trying each RESTMapping\n// in turn until a working one is found.  If none work, the first error\n// is returned.  It returns both the scale, as well as the group-resource from\n// the working mapping.", "input": "go language", "output": "func (a *HorizontalController) scaleForResourceMappings(namespace, name string, mappings []*apimeta.RESTMapping) (*autoscalingv1.Scale, schema.GroupResource, error) {\n\tvar firstErr error\n\tfor i, mapping := range mappings {\n\t\ttargetGR := mapping.Resource.GroupResource()\n\t\tscale, err := a.scaleNamespacer.Scales(namespace).Get(targetGR, name)\n\t\tif err == nil {\n\t\t\treturn scale, targetGR, nil\n\t\t}\n\n\t\t// if this is the first error, remember it,\n\t\t// then go on and try other mappings until we find a good one\n\t\tif i == 0 {\n\t\t\tfirstErr = err\n\t\t}\n\t}\n\n\t// make sure we handle an empty set of mappings\n\tif firstErr == nil {\n\t\tfirstErr = fmt.Errorf(\"unrecognized resource\")\n\t}\n\n\treturn nil, schema.GroupResource{}, firstErr\n}", "category": "Python"}, {"instruction": "// Register injects a new peer into the working set, or returns an error if the\n// peer is already known.\n//\n// The method also sets the starting throughput values of the new peer to the\n// average of all existing peers, to give it a realistic chance of being used\n// for data retrievals.", "input": "go language", "output": "func (ps *peerSet) Register(p *peerConnection) error {\n\t// Retrieve the current median RTT as a sane default\n\tp.rtt = ps.medianRTT()\n\n\t// Register the new peer with some meaningful defaults\n\tps.lock.Lock()\n\tif _, ok := ps.peers[p.id]; ok {\n\t\tps.lock.Unlock()\n\t\treturn errAlreadyRegistered\n\t}\n\tif len(ps.peers) > 0 {\n\t\tp.headerThroughput, p.blockThroughput, p.receiptThroughput, p.stateThroughput = 0, 0, 0, 0\n\n\t\tfor _, peer := range ps.peers {\n\t\t\tpeer.lock.RLock()\n\t\t\tp.headerThroughput += peer.headerThroughput\n\t\t\tp.blockThroughput += peer.blockThroughput\n\t\t\tp.receiptThroughput += peer.receiptThroughput\n\t\t\tp.stateThroughput += peer.stateThroughput\n\t\t\tpeer.lock.RUnlock()\n\t\t}\n\t\tp.headerThroughput /= float64(len(ps.peers))\n\t\tp.blockThroughput /= float64(len(ps.peers))\n\t\tp.receiptThroughput /= float64(len(ps.peers))\n\t\tp.stateThroughput /= float64(len(ps.peers))\n\t}\n\tps.peers[p.id] = p\n\tps.lock.Unlock()\n\n\tps.newPeerFeed.Send(p)\n\treturn nil\n}", "category": "Python"}, {"instruction": "// NewFilteredJobInformer constructs a new informer for Job type.\n// Always prefer using an informer factory to get a shared informer instead of getting an independent\n// one. This reduces memory footprint and number of connections to the server.", "input": "go language", "output": "func NewFilteredJobInformer(client kubernetes.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {\n\treturn cache.NewSharedIndexInformer(\n\t\t&cache.ListWatch{\n\t\t\tListFunc: func(options metav1.ListOptions) (runtime.Object, error) {\n\t\t\t\tif tweakListOptions != nil {\n\t\t\t\t\ttweakListOptions(&options)\n\t\t\t\t}\n\t\t\t\treturn client.BatchV1().Jobs(namespace).List(options)\n\t\t\t},\n\t\t\tWatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {\n\t\t\t\tif tweakListOptions != nil {\n\t\t\t\t\ttweakListOptions(&options)\n\t\t\t\t}\n\t\t\t\treturn client.BatchV1().Jobs(namespace).Watch(options)\n\t\t\t},\n\t\t},\n\t\t&batchv1.Job{},\n\t\tresyncPeriod,\n\t\tindexers,\n\t)\n}", "category": "Python"}, {"instruction": "// Login is used to exchange auth method credentials for a newly-minted Consul Token.", "input": "go language", "output": "func (a *ACL) Login(auth *ACLLoginParams, q *WriteOptions) (*ACLToken, *WriteMeta, error) {\n\tr := a.c.newRequest(\"POST\", \"/v1/acl/login\")\n\tr.setWriteOptions(q)\n\tr.obj = auth\n\n\trtt, resp, err := requireOK(a.c.doRequest(r))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\twm := &WriteMeta{RequestTime: rtt}\n\tvar out ACLToken\n\tif err := decodeBody(resp, &out); err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn &out, wm, nil\n}", "category": "Python"}, {"instruction": "// ParseResponse parses the given response about the given channel", "input": "go language", "output": "func (parser *PeerResponseParser) ParseResponse(channel string, res ServiceResponse) error {\n\tvar listPeers peerLister\n\tif channel == \"\" {\n\t\tlistPeers = res.ForLocal()\n\t} else {\n\t\tlistPeers = &simpleChannelResponse{res.ForChannel(channel)}\n\t}\n\tpeers, err := listPeers.Peers()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tchannelState := channel != \"\"\n\tb, _ := json.MarshalIndent(assemblePeers(peers, channelState), \"\", \"\\t\")\n\tfmt.Fprintln(parser.Writer, string(b))\n\treturn nil\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *HPAControllerConfiguration) DeepCopyInto(out *HPAControllerConfiguration) {\n\t*out = *in\n\tout.HorizontalPodAutoscalerSyncPeriod = in.HorizontalPodAutoscalerSyncPeriod\n\tout.HorizontalPodAutoscalerUpscaleForbiddenWindow = in.HorizontalPodAutoscalerUpscaleForbiddenWindow\n\tout.HorizontalPodAutoscalerDownscaleForbiddenWindow = in.HorizontalPodAutoscalerDownscaleForbiddenWindow\n\tout.HorizontalPodAutoscalerDownscaleStabilizationWindow = in.HorizontalPodAutoscalerDownscaleStabilizationWindow\n\tout.HorizontalPodAutoscalerCPUInitializationPeriod = in.HorizontalPodAutoscalerCPUInitializationPeriod\n\tout.HorizontalPodAutoscalerInitialReadinessDelay = in.HorizontalPodAutoscalerInitialReadinessDelay\n\treturn\n}", "category": "Python"}, {"instruction": "// newResponseRecorder returns an initialized responseRecorder.", "input": "go language", "output": "func newResponseRecorder(rw http.ResponseWriter, logger logrus.FieldLogger) responseRecorder {\n\trecorder := &responseRecorderWithoutCloseNotify{\n\t\tHeaderMap:      make(http.Header),\n\t\tBody:           new(bytes.Buffer),\n\t\tCode:           http.StatusOK,\n\t\tresponseWriter: rw,\n\t\tlogger:         logger,\n\t}\n\tif _, ok := rw.(http.CloseNotifier); ok {\n\t\treturn &responseRecorderWithCloseNotify{recorder}\n\t}\n\treturn recorder\n}", "category": "Python"}, {"instruction": "// getCgroupConfig returns a ResourceConfig object that can be used to create or update cgroups via CgroupManager interface.", "input": "go language", "output": "func getCgroupConfig(rl v1.ResourceList) *ResourceConfig {\n\t// TODO(vishh): Set CPU Quota if necessary.\n\tif rl == nil {\n\t\treturn nil\n\t}\n\tvar rc ResourceConfig\n\tif q, exists := rl[v1.ResourceMemory]; exists {\n\t\t// Memory is defined in bytes.\n\t\tval := q.Value()\n\t\trc.Memory = &val\n\t}\n\tif q, exists := rl[v1.ResourceCPU]; exists {\n\t\t// CPU is defined in milli-cores.\n\t\tval := MilliCPUToShares(q.MilliValue())\n\t\trc.CpuShares = &val\n\t}\n\tif q, exists := rl[pidlimit.PIDs]; exists {\n\t\tval := q.Value()\n\t\trc.PidsLimit = &val\n\t}\n\trc.HugePageLimit = HugePageLimits(rl)\n\n\treturn &rc\n}", "category": "Python"}, {"instruction": "// ConfigCreate applies the given config entry update.", "input": "go language", "output": "func (s *HTTPServer) ConfigApply(resp http.ResponseWriter, req *http.Request) (interface{}, error) {\n\targs := structs.ConfigEntryRequest{\n\t\tOp: structs.ConfigEntryUpsert,\n\t}\n\ts.parseDC(req, &args.Datacenter)\n\ts.parseToken(req, &args.Token)\n\n\tvar raw map[string]interface{}\n\tif err := decodeBody(req, &raw, nil); err != nil {\n\t\treturn nil, BadRequestError{Reason: fmt.Sprintf(\"Request decoding failed: %v\", err)}\n\t}\n\n\tif entry, err := structs.DecodeConfigEntry(raw); err == nil {\n\t\targs.Entry = entry\n\t} else {\n\t\treturn nil, BadRequestError{Reason: fmt.Sprintf(\"Request decoding failed: %v\", err)}\n\t}\n\n\t// Check for cas value\n\tif casStr := req.URL.Query().Get(\"cas\"); casStr != \"\" {\n\t\tcasVal, err := strconv.ParseUint(casStr, 10, 64)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\targs.Op = structs.ConfigEntryUpsertCAS\n\t\targs.Entry.GetRaftIndex().ModifyIndex = casVal\n\t}\n\n\tvar reply bool\n\tif err := s.agent.RPC(\"ConfigEntry.Apply\", &args, &reply); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn reply, nil\n}", "category": "Python"}, {"instruction": "// Due to the way cgo works this has to be in a separate file, as devmapper.go has\n// definitions in the cgo block, which is incompatible with using \"//export\"\n// DevmapperLogCallback exports the devmapper log callback for cgo. Note that\n// because we are using callbacks, this function will be called for *every* log\n// in libdm (even debug ones because there's no way of setting the verbosity\n// level for an external logging callback).\n//export DevmapperLogCallback", "input": "go language", "output": "func DevmapperLogCallback(level C.int, file *C.char, line, dmErrnoOrClass C.int, message *C.char) {\n\tmsg := C.GoString(message)\n\n\t// Track what errno libdm saw, because the library only gives us 0 or 1.\n\tif level < LogLevelDebug {\n\t\tif strings.Contains(msg, \"busy\") {\n\t\t\tdmSawBusy = true\n\t\t}\n\n\t\tif strings.Contains(msg, \"File exists\") {\n\t\t\tdmSawExist = true\n\t\t}\n\n\t\tif strings.Contains(msg, \"No such device or address\") {\n\t\t\tdmSawEnxio = true\n\t\t}\n\t\tif strings.Contains(msg, \"No data available\") {\n\t\t\tdmSawEnoData = true\n\t\t}\n\t}\n\n\tif dmLogger != nil {\n\t\tdmLogger.DMLog(int(level), C.GoString(file), int(line), int(dmErrnoOrClass), msg)\n\t}\n}", "category": "Python"}, {"instruction": "// Register registers a plugin", "input": "go language", "output": "func Register(plugins *admission.Plugins) {\n\tplugins.Register(PluginName, func(config io.Reader) (admission.Interface, error) {\n\t\t// the pods/status endpoint is ignored by this plugin since old kubelets\n\t\t// corrupt them.  the pod status strategy ensures status updates cannot mutate\n\t\t// ownerRef.\n\t\twhiteList := []whiteListItem{\n\t\t\t{\n\t\t\t\tgroupResource: schema.GroupResource{Resource: \"pods\"},\n\t\t\t\tsubresource:   \"status\",\n\t\t\t},\n\t\t}\n\t\treturn &gcPermissionsEnforcement{\n\t\t\tHandler:   admission.NewHandler(admission.Create, admission.Update),\n\t\t\twhiteList: whiteList,\n\t\t}, nil\n\t})\n}", "category": "Python"}, {"instruction": "// deposit deposits amount to the chequebook account.\n// The caller must hold lock.", "input": "go language", "output": "func (cb *Chequebook) deposit(amount *big.Int) (string, error) {\n\t// since the amount is variable here, we do not use sessions\n\tdepositTransactor := bind.NewKeyedTransactor(cb.prvKey)\n\tdepositTransactor.Value = amount\n\tchbookRaw := &contract.ChequebookRaw{Contract: cb.contract}\n\ttx, err := chbookRaw.Transfer(depositTransactor)\n\tif err != nil {\n\t\tcb.log.Warn(\"Failed to fund chequebook\", \"amount\", amount, \"balance\", cb.balance, \"target\", cb.buffer, \"err\", err)\n\t\treturn \"\", err\n\t}\n\t// assume that transaction is actually successful, we add the amount to balance right away\n\tcb.balance.Add(cb.balance, amount)\n\tcb.log.Trace(\"Deposited funds to chequebook\", \"amount\", amount, \"balance\", cb.balance, \"target\", cb.buffer)\n\treturn tx.Hash().Hex(), nil\n}", "category": "Python"}, {"instruction": "// Extract extracts compressed archives\n//\n// Implements Extractor.", "input": "go language", "output": "func (g *TarGzExtractor) Extract(buffer *bytes.Buffer, targetDir string) error {\n\tuncompressedStream, err := gzip.NewReader(buffer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttarReader := tar.NewReader(uncompressedStream)\n\n\tos.MkdirAll(targetDir, 0755)\n\n\tfor true {\n\t\theader, err := tarReader.Next()\n\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpath, err := fp.SecureJoin(targetDir, header.Name)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch header.Typeflag {\n\t\tcase tar.TypeDir:\n\t\t\tif err := os.Mkdir(path, 0755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase tar.TypeReg:\n\t\t\toutFile, err := os.Create(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, err := io.Copy(outFile, tarReader); err != nil {\n\t\t\t\toutFile.Close()\n\t\t\t\treturn err\n\t\t\t}\n\t\t\toutFile.Close()\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unknown type: %b in %s\", header.Typeflag, header.Name)\n\t\t}\n\t}\n\n\treturn nil\n\n}", "category": "Python"}, {"instruction": "// Tasks provides a mock function with given fields: application", "input": "go language", "output": "func (_m *Marathon) Tasks(application string) (*marathon.Tasks, error) {\n\tret := _m.Called(application)\n\n\tvar r0 *marathon.Tasks\n\tif rf, ok := ret.Get(0).(func(string) *marathon.Tasks); ok {\n\t\tr0 = rf(application)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(*marathon.Tasks)\n\t\t}\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(string) error); ok {\n\t\tr1 = rf(application)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}", "category": "Python"}, {"instruction": "// RunInContainer runs a command in a container, returns the combined stdout, stderr as an array of bytes", "input": "go language", "output": "func (kl *Kubelet) RunInContainer(podFullName string, podUID types.UID, containerName string, cmd []string) ([]byte, error) {\n\tcontainer, err := kl.findContainer(podFullName, podUID, containerName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif container == nil {\n\t\treturn nil, fmt.Errorf(\"container not found (%q)\", containerName)\n\t}\n\t// TODO(tallclair): Pass a proper timeout value.\n\treturn kl.runner.RunInContainer(container.ID, cmd, 0)\n}", "category": "Python"}, {"instruction": "// New returns a new instance of the os-namespaced template functions.", "input": "go language", "output": "func New(deps *deps.Deps) *Namespace {\n\n\t// Since Hugo 0.38 we can have multiple content dirs. This can make it hard to\n\t// reason about where the file is placed relative to the project root.\n\t// To make the {{ readFile .Filename }} variant just work, we create a composite\n\t// filesystem that first checks the work dir fs and then the content fs.\n\tvar rfs afero.Fs\n\tif deps.Fs != nil {\n\t\trfs = deps.Fs.WorkingDir\n\t\tif deps.PathSpec != nil && deps.PathSpec.BaseFs != nil {\n\t\t\trfs = afero.NewReadOnlyFs(afero.NewCopyOnWriteFs(deps.PathSpec.BaseFs.Content.Fs, deps.Fs.WorkingDir))\n\t\t}\n\t}\n\n\treturn &Namespace{\n\t\treadFileFs: rfs,\n\t\tdeps:       deps,\n\t}\n}", "category": "Python"}, {"instruction": "// NewServer returns a new simulation API server", "input": "go language", "output": "func NewServer(network *Network) *Server {\n\ts := &Server{\n\t\trouter:  httprouter.New(),\n\t\tnetwork: network,\n\t}\n\n\ts.OPTIONS(\"/\", s.Options)\n\ts.GET(\"/\", s.GetNetwork)\n\ts.POST(\"/start\", s.StartNetwork)\n\ts.POST(\"/stop\", s.StopNetwork)\n\ts.POST(\"/mocker/start\", s.StartMocker)\n\ts.POST(\"/mocker/stop\", s.StopMocker)\n\ts.GET(\"/mocker\", s.GetMockers)\n\ts.POST(\"/reset\", s.ResetNetwork)\n\ts.GET(\"/events\", s.StreamNetworkEvents)\n\ts.GET(\"/snapshot\", s.CreateSnapshot)\n\ts.POST(\"/snapshot\", s.LoadSnapshot)\n\ts.POST(\"/nodes\", s.CreateNode)\n\ts.GET(\"/nodes\", s.GetNodes)\n\ts.GET(\"/nodes/:nodeid\", s.GetNode)\n\ts.POST(\"/nodes/:nodeid/start\", s.StartNode)\n\ts.POST(\"/nodes/:nodeid/stop\", s.StopNode)\n\ts.POST(\"/nodes/:nodeid/conn/:peerid\", s.ConnectNode)\n\ts.DELETE(\"/nodes/:nodeid/conn/:peerid\", s.DisconnectNode)\n\ts.GET(\"/nodes/:nodeid/rpc\", s.NodeRPC)\n\n\treturn s\n}", "category": "Python"}, {"instruction": "// Resize perform resize of file system", "input": "go language", "output": "func (resizefs *ResizeFs) Resize(devicePath string, deviceMountPath string) (bool, error) {\n\tformat, err := resizefs.mounter.GetDiskFormat(devicePath)\n\n\tif err != nil {\n\t\tformatErr := fmt.Errorf(\"ResizeFS.Resize - error checking format for device %s: %v\", devicePath, err)\n\t\treturn false, formatErr\n\t}\n\n\t// If disk has no format, there is no need to resize the disk because mkfs.*\n\t// by default will use whole disk anyways.\n\tif format == \"\" {\n\t\treturn false, nil\n\t}\n\n\tklog.V(3).Infof(\"ResizeFS.Resize - Expanding mounted volume %s\", devicePath)\n\tswitch format {\n\tcase \"ext3\", \"ext4\":\n\t\treturn resizefs.extResize(devicePath)\n\tcase \"xfs\":\n\t\treturn resizefs.xfsResize(deviceMountPath)\n\t}\n\treturn false, fmt.Errorf(\"ResizeFS.Resize - resize of format %s is not supported for device %s mounted at %s\", format, devicePath, deviceMountPath)\n}", "category": "Python"}, {"instruction": "// TranslateCSIPVToInTree takes a PV with CSIPersistentVolumeSource set and\n// translates the Cinder CSI source to a Cinder In-tree source.", "input": "go language", "output": "func (t *osCinderCSITranslator) TranslateCSIPVToInTree(pv *v1.PersistentVolume) (*v1.PersistentVolume, error) {\n\tif pv == nil || pv.Spec.CSI == nil {\n\t\treturn nil, fmt.Errorf(\"pv is nil or CSI source not defined on pv\")\n\t}\n\n\tcsiSource := pv.Spec.CSI\n\n\tcinderSource := &v1.CinderPersistentVolumeSource{\n\t\tVolumeID: csiSource.VolumeHandle,\n\t\tFSType:   csiSource.FSType,\n\t\tReadOnly: csiSource.ReadOnly,\n\t}\n\n\tpv.Spec.CSI = nil\n\tpv.Spec.Cinder = cinderSource\n\treturn pv, nil\n}", "category": "Python"}, {"instruction": "// Unmount runs umount(8) in the host's mount namespace.", "input": "go language", "output": "func (n *Mounter) Unmount(target string) error {\n\targs := []string{target}\n\t// No need to execute systemd-run here, it's enough that unmount is executed\n\t// in the host's mount namespace. It will finish appropriate fuse daemon(s)\n\t// running in any scope.\n\tklog.V(5).Infof(\"nsenter unmount args: %v\", args)\n\toutputBytes, err := n.ne.Exec(\"umount\", args).CombinedOutput()\n\tif len(outputBytes) != 0 {\n\t\tklog.V(5).Infof(\"Output of unmounting %s: %v\", target, string(outputBytes))\n\t}\n\treturn err\n}", "category": "Python"}, {"instruction": "// initTableIndices initializes the indices of the tableCommon.", "input": "go language", "output": "func initTableIndices(t *tableCommon) error {\n\ttblInfo := t.meta\n\tfor _, idxInfo := range tblInfo.Indices {\n\t\tif idxInfo.State == model.StateNone {\n\t\t\treturn table.ErrIndexStateCantNone.GenWithStack(\"index %s can't be in none state\", idxInfo.Name)\n\t\t}\n\n\t\t// Use partition ID for index, because tableCommon may be table or partition.\n\t\tidx := NewIndex(t.physicalTableID, tblInfo, idxInfo)\n\t\tt.indices = append(t.indices, idx)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// AddFlags receives a *cobra.Command reference and binds\n// flags related to humanreadable and template printing.", "input": "go language", "output": "func (f *PrintFlags) AddFlags(cmd *cobra.Command) {\n\tf.JSONYamlPrintFlags.AddFlags(cmd)\n\tf.NamePrintFlags.AddFlags(cmd)\n\tf.TemplateFlags.AddFlags(cmd)\n\tf.HumanReadableFlags.AddFlags(cmd)\n\tf.CustomColumnsFlags.AddFlags(cmd)\n\n\tif f.OutputFormat != nil {\n\t\tcmd.Flags().StringVarP(f.OutputFormat, \"output\", \"o\", *f.OutputFormat, \"Output format. One of: json|yaml|wide|name|custom-columns=...|custom-columns-file=...|go-template=...|go-template-file=...|jsonpath=...|jsonpath-file=... See custom columns [http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns], golang template [http://golang.org/pkg/text/template/#pkg-overview] and jsonpath template [http://kubernetes.io/docs/user-guide/jsonpath].\")\n\t}\n\tif f.NoHeaders != nil {\n\t\tcmd.Flags().BoolVar(f.NoHeaders, \"no-headers\", *f.NoHeaders, \"When using the default or custom-column output format, don't print headers (default print headers).\")\n\t}\n}", "category": "Python"}, {"instruction": "// GetDDLInfo returns DDL information.", "input": "go language", "output": "func GetDDLInfo(txn kv.Transaction) (*DDLInfo, error) {\n\tvar err error\n\tinfo := &DDLInfo{}\n\tt := meta.NewMeta(txn)\n\n\tinfo.Jobs = make([]*model.Job, 0, 2)\n\tjob, err := t.GetDDLJobByIdx(0)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tif job != nil {\n\t\tinfo.Jobs = append(info.Jobs, job)\n\t}\n\taddIdxJob, err := t.GetDDLJobByIdx(0, meta.AddIndexJobListKey)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tif addIdxJob != nil {\n\t\tinfo.Jobs = append(info.Jobs, addIdxJob)\n\t}\n\n\tinfo.SchemaVer, err = t.GetSchemaVersion()\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tif addIdxJob == nil {\n\t\treturn info, nil\n\t}\n\n\tinfo.ReorgHandle, _, _, err = t.GetDDLReorgHandle(addIdxJob)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\treturn info, nil\n}", "category": "Python"}, {"instruction": "// ConfirmUsable looks a particular context and determines if that particular part of the config is useable.  There might still be errors in the config,\n// but no errors in the sections requested or referenced.  It does not return early so that it can find as many errors as possible.", "input": "go language", "output": "func ConfirmUsable(config clientcmdapi.Config, passedContextName string) error {\n\tvalidationErrors := make([]error, 0)\n\n\tif clientcmdapi.IsConfigEmpty(&config) {\n\t\treturn newErrConfigurationInvalid([]error{ErrEmptyConfig})\n\t}\n\n\tvar contextName string\n\tif len(passedContextName) != 0 {\n\t\tcontextName = passedContextName\n\t} else {\n\t\tcontextName = config.CurrentContext\n\t}\n\n\tif len(contextName) == 0 {\n\t\treturn ErrNoContext\n\t}\n\n\tcontext, exists := config.Contexts[contextName]\n\tif !exists {\n\t\tvalidationErrors = append(validationErrors, &errContextNotFound{contextName})\n\t}\n\n\tif exists {\n\t\tvalidationErrors = append(validationErrors, validateContext(contextName, *context, config)...)\n\t\tvalidationErrors = append(validationErrors, validateAuthInfo(context.AuthInfo, *config.AuthInfos[context.AuthInfo])...)\n\t\tvalidationErrors = append(validationErrors, validateClusterInfo(context.Cluster, *config.Clusters[context.Cluster])...)\n\t}\n\n\treturn newErrConfigurationInvalid(validationErrors)\n}", "category": "Python"}, {"instruction": "// numericContextResultType returns types.EvalType for numeric function's parameters.\n// the returned types.EvalType should be one of: types.ETInt, types.ETDecimal, types.ETReal", "input": "go language", "output": "func numericContextResultType(ft *types.FieldType) types.EvalType {\n\tif types.IsTypeTemporal(ft.Tp) {\n\t\tif ft.Decimal > 0 {\n\t\t\treturn types.ETDecimal\n\t\t}\n\t\treturn types.ETInt\n\t}\n\tif types.IsBinaryStr(ft) {\n\t\treturn types.ETInt\n\t}\n\tevalTp4Ft := types.ETReal\n\tif !ft.Hybrid() {\n\t\tevalTp4Ft = ft.EvalType()\n\t\tif evalTp4Ft != types.ETDecimal && evalTp4Ft != types.ETInt {\n\t\t\tevalTp4Ft = types.ETReal\n\t\t}\n\t}\n\treturn evalTp4Ft\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *HorizontalPodAutoscalerStatus) DeepCopyInto(out *HorizontalPodAutoscalerStatus) {\n\t*out = *in\n\tif in.ObservedGeneration != nil {\n\t\tin, out := &in.ObservedGeneration, &out.ObservedGeneration\n\t\t*out = new(int64)\n\t\t**out = **in\n\t}\n\tif in.LastScaleTime != nil {\n\t\tin, out := &in.LastScaleTime, &out.LastScaleTime\n\t\t*out = (*in).DeepCopy()\n\t}\n\tif in.CurrentMetrics != nil {\n\t\tin, out := &in.CurrentMetrics, &out.CurrentMetrics\n\t\t*out = make([]MetricStatus, len(*in))\n\t\tfor i := range *in {\n\t\t\t(*in)[i].DeepCopyInto(&(*out)[i])\n\t\t}\n\t}\n\tif in.Conditions != nil {\n\t\tin, out := &in.Conditions, &out.Conditions\n\t\t*out = make([]HorizontalPodAutoscalerCondition, len(*in))\n\t\tfor i := range *in {\n\t\t\t(*in)[i].DeepCopyInto(&(*out)[i])\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// NewController constructs a new Controller object and returns it. The dynamicConfigDir\n// path must be absolute. transform applies an arbitrary transformation to config after loading, and before validation.\n// This can be used, for example, to include config from flags before the controller's validation step.\n// If transform returns an error, loadConfig will fail, and an InternalError will be reported.\n// Be wary if using this function as an extension point, in most cases the controller should\n// probably just be natively extended to do what you need. Injecting flag precedence transformations\n// is something of an exception because the caller of this controller (cmd/) is aware of flags, but this\n// controller's tree (pkg/) is not.", "input": "go language", "output": "func NewController(dynamicConfigDir string, transform TransformFunc) *Controller {\n\treturn &Controller{\n\t\ttransform: transform,\n\t\t// channels must have capacity at least 1, since we signal with non-blocking writes\n\t\tpendingConfigSource: make(chan bool, 1),\n\t\tconfigStatus:        status.NewNodeConfigStatus(),\n\t\tcheckpointStore:     store.NewFsStore(utilfs.DefaultFs{}, filepath.Join(dynamicConfigDir, storeDir)),\n\t}\n}", "category": "Python"}, {"instruction": "// DeleteVolumes removes the ScaleIO volume", "input": "go language", "output": "func (m *sioMgr) DeleteVolume(volName string) error {\n\tclient, err := m.getClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvol, err := client.FindVolume(volName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := client.DeleteVolume(sioVolumeID(vol.ID)); err != nil {\n\t\tklog.Error(log(\"failed to delete volume %s: %v\", volName, err))\n\t\treturn err\n\t}\n\n\tklog.V(4).Info(log(\"deleted volume %s successfully\", volName))\n\treturn nil\n\n}", "category": "Python"}, {"instruction": "// Pack the given method name to conform the ABI. Method call's data\n// will consist of method_id, args0, arg1, ... argN. Method id consists\n// of 4 bytes and arguments are all 32 bytes.\n// Method ids are created from the first 4 bytes of the hash of the\n// methods string signature. (signature = baz(uint32,string32))", "input": "go language", "output": "func (abi ABI) Pack(name string, args ...interface{}) ([]byte, error) {\n\t// Fetch the ABI of the requested method\n\tif name == \"\" {\n\t\t// constructor\n\t\targuments, err := abi.Constructor.Inputs.Pack(args...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn arguments, nil\n\t}\n\tmethod, exist := abi.Methods[name]\n\tif !exist {\n\t\treturn nil, fmt.Errorf(\"method '%s' not found\", name)\n\t}\n\targuments, err := method.Inputs.Pack(args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Pack up the method ID too if not a constructor and return\n\treturn append(method.Id(), arguments...), nil\n}", "category": "Python"}, {"instruction": "// ToPB implements PhysicalPlan ToPB interface.", "input": "go language", "output": "func (p *PhysicalIndexScan) ToPB(ctx sessionctx.Context) (*tipb.Executor, error) {\n\tcolumns := make([]*model.ColumnInfo, 0, p.schema.Len())\n\ttableColumns := p.Table.Cols()\n\tfor _, col := range p.schema.Columns {\n\t\tif col.ID == model.ExtraHandleID {\n\t\t\tcolumns = append(columns, model.NewExtraHandleColInfo())\n\t\t} else {\n\t\t\tcolumns = append(columns, model.FindColumnInfo(tableColumns, col.ColName.L))\n\t\t}\n\t}\n\tidxExec := &tipb.IndexScan{\n\t\tTableId: p.Table.ID,\n\t\tIndexId: p.Index.ID,\n\t\tColumns: model.ColumnsToProto(columns, p.Table.PKIsHandle),\n\t\tDesc:    p.Desc,\n\t}\n\tunique := checkCoverIndex(p.Index, p.Ranges)\n\tidxExec.Unique = &unique\n\treturn &tipb.Executor{Tp: tipb.ExecType_TypeIndexScan, IdxScan: idxExec}, nil\n}", "category": "Python"}, {"instruction": "// GetSortedMapValues returns a sorted map previously filled with SetInMap.", "input": "go language", "output": "func (c *Scratch) GetSortedMapValues(key string) interface{} {\n\tc.mu.RLock()\n\n\tif c.values[key] == nil {\n\t\tc.mu.RUnlock()\n\t\treturn nil\n\t}\n\n\tunsortedMap := c.values[key].(map[string]interface{})\n\tc.mu.RUnlock()\n\tvar keys []string\n\tfor mapKey := range unsortedMap {\n\t\tkeys = append(keys, mapKey)\n\t}\n\n\tsort.Strings(keys)\n\n\tsortedArray := make([]interface{}, len(unsortedMap))\n\tfor i, mapKey := range keys {\n\t\tsortedArray[i] = unsortedMap[mapKey]\n\t}\n\n\treturn sortedArray\n}", "category": "Python"}, {"instruction": "// NodeSelectorRequirementsAsSelector converts the []NodeSelectorRequirement core type into a struct that implements\n// labels.Selector.", "input": "go language", "output": "func NodeSelectorRequirementsAsSelector(nsm []core.NodeSelectorRequirement) (labels.Selector, error) {\n\tif len(nsm) == 0 {\n\t\treturn labels.Nothing(), nil\n\t}\n\tselector := labels.NewSelector()\n\tfor _, expr := range nsm {\n\t\tvar op selection.Operator\n\t\tswitch expr.Operator {\n\t\tcase core.NodeSelectorOpIn:\n\t\t\top = selection.In\n\t\tcase core.NodeSelectorOpNotIn:\n\t\t\top = selection.NotIn\n\t\tcase core.NodeSelectorOpExists:\n\t\t\top = selection.Exists\n\t\tcase core.NodeSelectorOpDoesNotExist:\n\t\t\top = selection.DoesNotExist\n\t\tcase core.NodeSelectorOpGt:\n\t\t\top = selection.GreaterThan\n\t\tcase core.NodeSelectorOpLt:\n\t\t\top = selection.LessThan\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"%q is not a valid node selector operator\", expr.Operator)\n\t\t}\n\t\tr, err := labels.NewRequirement(expr.Key, op, expr.Values)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tselector = selector.Add(*r)\n\t}\n\treturn selector, nil\n}", "category": "Python"}, {"instruction": "// Run is the long-running method that handles state syncing. It should be run\n// in it's own goroutine and will continue until a fatal error is hit or Close\n// is called. Run will return an error if it is called more than once, or called\n// after Close.", "input": "go language", "output": "func (m *Manager) Run() error {\n\tm.mu.Lock()\n\talreadyStarted := m.started\n\tm.started = true\n\tstateCh := m.stateCh\n\tm.mu.Unlock()\n\n\t// Protect against multiple Run calls.\n\tif alreadyStarted {\n\t\treturn ErrStarted\n\t}\n\n\t// Protect against being run after Close.\n\tif stateCh == nil {\n\t\treturn ErrStopped\n\t}\n\n\t// Register for notifications about state changes\n\tm.State.Notify(stateCh)\n\tdefer m.State.StopNotify(stateCh)\n\n\tfor {\n\t\tm.syncState()\n\n\t\t// Wait for a state change\n\t\t_, ok := <-stateCh\n\t\tif !ok {\n\t\t\t// Stopped\n\t\t\treturn nil\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// Duration converts the given number to a time.Duration.\n// Unit is one of nanosecond/ns, microsecond/us/\u00b5s, millisecond/ms, second/s, minute/m or hour/h.", "input": "go language", "output": "func (ns *Namespace) Duration(unit interface{}, number interface{}) (_time.Duration, error) {\n\tunitStr, err := cast.ToStringE(unit)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tunitDuration, found := durationUnits[unitStr]\n\tif !found {\n\t\treturn 0, fmt.Errorf(\"%q is not a valid duration unit\", unit)\n\t}\n\tn, err := cast.ToInt64E(number)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn _time.Duration(n) * unitDuration, nil\n}", "category": "Python"}, {"instruction": "// ServeHTTP handles table related requests, such as table's region information, disk usage.", "input": "go language", "output": "func (h tableHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\t// parse params\n\tparams := mux.Vars(req)\n\tdbName := params[pDBName]\n\ttableName := params[pTableName]\n\tschema, err := h.schema()\n\tif err != nil {\n\t\twriteError(w, err)\n\t\treturn\n\t}\n\t// get table's schema.\n\ttableVal, err := schema.TableByName(model.NewCIStr(dbName), model.NewCIStr(tableName))\n\tif err != nil {\n\t\twriteError(w, err)\n\t\treturn\n\t}\n\n\tswitch h.op {\n\tcase opTableRegions:\n\t\th.handleRegionRequest(schema, tableVal, w, req)\n\tcase opTableDiskUsage:\n\t\th.handleDiskUsageRequest(schema, tableVal, w, req)\n\tcase opTableScatter:\n\t\th.handleScatterTableRequest(schema, tableVal, w, req)\n\tcase opStopTableScatter:\n\t\th.handleStopScatterTableRequest(schema, tableVal, w, req)\n\tdefault:\n\t\twriteError(w, errors.New(\"method not found\"))\n\t}\n}", "category": "Python"}, {"instruction": "// formatProgress formats the progress information for a specified action.", "input": "go language", "output": "func (sf *jsonProgressFormatter) formatProgress(id, action string, progress *jsonmessage.JSONProgress, aux interface{}) []byte {\n\tif progress == nil {\n\t\tprogress = &jsonmessage.JSONProgress{}\n\t}\n\tvar auxJSON *json.RawMessage\n\tif aux != nil {\n\t\tauxJSONBytes, err := json.Marshal(aux)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tauxJSON = new(json.RawMessage)\n\t\t*auxJSON = auxJSONBytes\n\t}\n\tb, err := json.Marshal(&jsonmessage.JSONMessage{\n\t\tStatus:          action,\n\t\tProgressMessage: progress.String(),\n\t\tProgress:        progress,\n\t\tID:              id,\n\t\tAux:             auxJSON,\n\t})\n\tif err != nil {\n\t\treturn nil\n\t}\n\treturn appendNewline(b)\n}", "category": "Python"}, {"instruction": "// Get implements the Retriever interface.", "input": "go language", "output": "func (us *unionStore) Get(k Key) ([]byte, error) {\n\tv, err := us.MemBuffer.Get(k)\n\tif IsErrNotFound(err) {\n\t\tif _, ok := us.opts.Get(PresumeKeyNotExists); ok {\n\t\t\te, ok := us.opts.Get(PresumeKeyNotExistsError)\n\t\t\tif ok && e != nil {\n\t\t\t\tus.markLazyConditionPair(k, nil, e.(error))\n\t\t\t} else {\n\t\t\t\tus.markLazyConditionPair(k, nil, ErrKeyExists)\n\t\t\t}\n\t\t\treturn nil, ErrNotExist\n\t\t}\n\t}\n\tif IsErrNotFound(err) {\n\t\tv, err = us.BufferStore.r.Get(k)\n\t}\n\tif err != nil {\n\t\treturn v, err\n\t}\n\tif len(v) == 0 {\n\t\treturn nil, ErrNotExist\n\t}\n\treturn v, nil\n}", "category": "Python"}, {"instruction": "// List takes label and field selectors, and returns the list of StorageClasses that match those selectors.", "input": "go language", "output": "func (c *FakeStorageClasses) List(opts v1.ListOptions) (result *v1beta1.StorageClassList, err error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewRootListAction(storageclassesResource, storageclassesKind, opts), &v1beta1.StorageClassList{})\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n\tif label == nil {\n\t\tlabel = labels.Everything()\n\t}\n\tlist := &v1beta1.StorageClassList{ListMeta: obj.(*v1beta1.StorageClassList).ListMeta}\n\tfor _, item := range obj.(*v1beta1.StorageClassList).Items {\n\t\tif label.Matches(labels.Set(item.Labels)) {\n\t\t\tlist.Items = append(list.Items, item)\n\t\t}\n\t}\n\treturn list, err\n}", "category": "Python"}, {"instruction": "// Init callback representing the invocation of a chaincode\n// This chaincode will manage two accounts A and B and will transfer X units from A to B upon invoke", "input": "go language", "output": "func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {\n\tvar err error\n\t_, args := stub.GetFunctionAndParameters()\n\tif len(args) != 4 {\n\t\treturn shim.Error(\"Incorrect number of arguments. Expecting 4\")\n\t}\n\n\t// Initialize the chaincode\n\tA = args[0]\n\tAval, err = strconv.Atoi(args[1])\n\tif err != nil {\n\t\treturn shim.Error(\"Expecting integer value for asset holding\")\n\t}\n\tB = args[2]\n\tBval, err = strconv.Atoi(args[3])\n\tif err != nil {\n\t\treturn shim.Error(\"Expecting integer value for asset holding\")\n\t}\n\tfmt.Printf(\"Aval = %d, Bval = %d\\n\", Aval, Bval)\n\n\treturn shim.Success(nil)\n}", "category": "Python"}, {"instruction": "// WaitInspectWithArgs waits for the specified expression to be equals to the specified expected string in the given time.\n// Deprecated: use cli.WaitCmd instead", "input": "go language", "output": "func WaitInspectWithArgs(dockerBinary, name, expr, expected string, timeout time.Duration, arg ...string) error {\n\tafter := time.After(timeout)\n\n\targs := append(arg, \"inspect\", \"-f\", expr, name)\n\tfor {\n\t\tresult := icmd.RunCommand(dockerBinary, args...)\n\t\tif result.Error != nil {\n\t\t\tif !strings.Contains(strings.ToLower(result.Stderr()), \"no such\") {\n\t\t\t\treturn errors.Errorf(\"error executing docker inspect: %v\\n%s\",\n\t\t\t\t\tresult.Stderr(), result.Stdout())\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase <-after:\n\t\t\t\treturn result.Error\n\t\t\tdefault:\n\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tout := strings.TrimSpace(result.Stdout())\n\t\tif out == expected {\n\t\t\tbreak\n\t\t}\n\n\t\tselect {\n\t\tcase <-after:\n\t\t\treturn errors.Errorf(\"condition \\\"%q == %q\\\" not true in time (%v)\", out, expected, timeout)\n\t\tdefault:\n\t\t}\n\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// NewCachingSecretManager creates a manager that keeps a cache of all secrets\n// necessary for registered pods.\n// It implements the following logic:\n// - whenever a pod is created or updated, the cached versions of all secrets\n//   are invalidated\n// - every GetObject() call tries to fetch the value from local cache; if it is\n//   not there, invalidated or too old, we fetch it from apiserver and refresh the\n//   value in cache; otherwise it is just fetched from cache", "input": "go language", "output": "func NewCachingSecretManager(kubeClient clientset.Interface, getTTL manager.GetObjectTTLFunc) Manager {\n\tgetSecret := func(namespace, name string, opts metav1.GetOptions) (runtime.Object, error) {\n\t\treturn kubeClient.CoreV1().Secrets(namespace).Get(name, opts)\n\t}\n\tsecretStore := manager.NewObjectStore(getSecret, clock.RealClock{}, getTTL, defaultTTL)\n\treturn &secretManager{\n\t\tmanager: manager.NewCacheBasedManager(secretStore, getSecretNames),\n\t}\n}", "category": "Python"}, {"instruction": "// CreateDisk creates a new Persistent Disk, with the specified name &\n// size, in the specified zone. It stores specified tags encoded in\n// JSON in Description field.", "input": "go language", "output": "func (g *Cloud) CreateDisk(\n\tname string, diskType string, zone string, sizeGb int64, tags map[string]string) error {\n\t// Do not allow creation of PDs in zones that are do not have nodes. Such PDs\n\t// are not currently usable.\n\tcurZones, err := g.GetAllCurrentZones()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !curZones.Has(zone) {\n\t\treturn fmt.Errorf(\"kubernetes does not have a node in zone %q\", zone)\n\t}\n\n\ttagsStr, err := g.encodeDiskTags(tags)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdiskType, err = getDiskType(diskType)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmc := newDiskMetricContextZonal(\"create\", g.region, zone)\n\n\terr = g.manager.CreateDiskOnCloudProvider(\n\t\tname, sizeGb, tagsStr, diskType, zone)\n\n\tmc.Observe(err)\n\tif isGCEError(err, \"alreadyExists\") {\n\t\tklog.Warningf(\"GCE PD %q already exists, reusing\", name)\n\t\treturn nil\n\t}\n\treturn err\n}", "category": "Python"}, {"instruction": "// RecommendedDefaultVolumeConfiguration defaults a pointer to a VolumeConfiguration\n// struct. This will set the recommended default values, but they may be subject to\n// change between API versions. This function is intentionally not registered in the\n// scheme as a \"normal\" `SetDefaults_Foo` function to allow consumers of this type to\n// set whatever defaults for their embedded configs. Forcing consumers to use these\n// defaults would be problematic as defaulting in the scheme is done as part of the\n// conversion, and there would be no easy way to opt-out. Instead, if you want to use\n// this defaulting method run it in your wrapper struct of this type in its `SetDefaults_` method.", "input": "go language", "output": "func RecommendedDefaultVolumeConfiguration(obj *kubectrlmgrconfigv1alpha1.VolumeConfiguration) {\n\tif obj.EnableHostPathProvisioning == nil {\n\t\tobj.EnableHostPathProvisioning = utilpointer.BoolPtr(false)\n\t}\n\tif obj.EnableDynamicProvisioning == nil {\n\t\tobj.EnableDynamicProvisioning = utilpointer.BoolPtr(true)\n\t}\n\tif obj.FlexVolumePluginDir == \"\" {\n\t\tobj.FlexVolumePluginDir = \"/usr/libexec/kubernetes/kubelet-plugins/volume/exec/\"\n\t}\n\t// Use the default PersistentVolumeRecyclerConfiguration options.\n\tRecommendedDefaultPersistentVolumeRecyclerConfiguration(&obj.PersistentVolumeRecyclerConfiguration)\n}", "category": "Python"}, {"instruction": "// adaptSharedNamespaceContainer replaces container name with its ID in hostConfig.\n// To be more precisely, it modifies `container:name` to `container:ID` of PidMode, IpcMode\n// and NetworkMode.\n//\n// When a container shares its namespace with another container, use ID can keep the namespace\n// sharing connection between the two containers even the another container is renamed.", "input": "go language", "output": "func adaptSharedNamespaceContainer(daemon containerGetter, hostConfig *containertypes.HostConfig) {\n\tcontainerPrefix := \"container:\"\n\tif hostConfig.PidMode.IsContainer() {\n\t\tpidContainer := hostConfig.PidMode.Container()\n\t\t// if there is any error returned here, we just ignore it and leave it to be\n\t\t// handled in the following logic\n\t\tif c, err := daemon.GetContainer(pidContainer); err == nil {\n\t\t\thostConfig.PidMode = containertypes.PidMode(containerPrefix + c.ID)\n\t\t}\n\t}\n\tif hostConfig.IpcMode.IsContainer() {\n\t\tipcContainer := hostConfig.IpcMode.Container()\n\t\tif c, err := daemon.GetContainer(ipcContainer); err == nil {\n\t\t\thostConfig.IpcMode = containertypes.IpcMode(containerPrefix + c.ID)\n\t\t}\n\t}\n\tif hostConfig.NetworkMode.IsContainer() {\n\t\tnetContainer := hostConfig.NetworkMode.ConnectedContainer()\n\t\tif c, err := daemon.GetContainer(netContainer); err == nil {\n\t\t\thostConfig.NetworkMode = containertypes.NetworkMode(containerPrefix + c.ID)\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// NewSelectorSpreadPriority creates a SelectorSpread.", "input": "go language", "output": "func NewSelectorSpreadPriority(\n\tserviceLister algorithm.ServiceLister,\n\tcontrollerLister algorithm.ControllerLister,\n\treplicaSetLister algorithm.ReplicaSetLister,\n\tstatefulSetLister algorithm.StatefulSetLister) (PriorityMapFunction, PriorityReduceFunction) {\n\tselectorSpread := &SelectorSpread{\n\t\tserviceLister:     serviceLister,\n\t\tcontrollerLister:  controllerLister,\n\t\treplicaSetLister:  replicaSetLister,\n\t\tstatefulSetLister: statefulSetLister,\n\t}\n\treturn selectorSpread.CalculateSpreadPriorityMap, selectorSpread.CalculateSpreadPriorityReduce\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *NetworkPolicyEgressRule) DeepCopyInto(out *NetworkPolicyEgressRule) {\n\t*out = *in\n\tif in.Ports != nil {\n\t\tin, out := &in.Ports, &out.Ports\n\t\t*out = make([]NetworkPolicyPort, len(*in))\n\t\tfor i := range *in {\n\t\t\t(*in)[i].DeepCopyInto(&(*out)[i])\n\t\t}\n\t}\n\tif in.To != nil {\n\t\tin, out := &in.To, &out.To\n\t\t*out = make([]NetworkPolicyPeer, len(*in))\n\t\tfor i := range *in {\n\t\t\t(*in)[i].DeepCopyInto(&(*out)[i])\n\t\t}\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// DefaultServiceIPRange takes a the serviceIPRange flag and returns the defaulted service ip range (if  needed),\n// api server service IP, and an error", "input": "go language", "output": "func DefaultServiceIPRange(passedServiceClusterIPRange net.IPNet) (net.IPNet, net.IP, error) {\n\tserviceClusterIPRange := passedServiceClusterIPRange\n\tif passedServiceClusterIPRange.IP == nil {\n\t\tklog.Infof(\"Network range for service cluster IPs is unspecified. Defaulting to %v.\", kubeoptions.DefaultServiceIPCIDR)\n\t\tserviceClusterIPRange = kubeoptions.DefaultServiceIPCIDR\n\t}\n\tif size := ipallocator.RangeSize(&serviceClusterIPRange); size < 8 {\n\t\treturn net.IPNet{}, net.IP{}, fmt.Errorf(\"The service cluster IP range must be at least %d IP addresses\", 8)\n\t}\n\n\t// Select the first valid IP from ServiceClusterIPRange to use as the GenericAPIServer service IP.\n\tapiServerServiceIP, err := ipallocator.GetIndexedIP(&serviceClusterIPRange, 1)\n\tif err != nil {\n\t\treturn net.IPNet{}, net.IP{}, err\n\t}\n\tklog.V(4).Infof(\"Setting service IP to %q (read-write).\", apiServerServiceIP)\n\n\treturn serviceClusterIPRange, apiServerServiceIP, nil\n}", "category": "Python"}, {"instruction": "// Connect returns a handler for the pod exec proxy", "input": "go language", "output": "func (r *AttachREST) Connect(ctx context.Context, name string, opts runtime.Object, responder rest.Responder) (http.Handler, error) {\n\tattachOpts, ok := opts.(*api.PodAttachOptions)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"Invalid options object: %#v\", opts)\n\t}\n\tlocation, transport, err := pod.AttachLocation(r.Store, r.KubeletConn, ctx, name, attachOpts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn newThrottledUpgradeAwareProxyHandler(location, transport, false, true, true, responder), nil\n}", "category": "Python"}, {"instruction": "// CompactRules combines rules that contain a single APIGroup/Resource, differ only by verb, and contain no other attributes.\n// this is a fast check, and works well with the decomposed \"missing rules\" list from a Covers check.", "input": "go language", "output": "func CompactRules(rules []rbacv1.PolicyRule) ([]rbacv1.PolicyRule, error) {\n\tcompacted := make([]rbacv1.PolicyRule, 0, len(rules))\n\n\tsimpleRules := map[simpleResource]*rbacv1.PolicyRule{}\n\tfor _, rule := range rules {\n\t\tif resource, isSimple := isSimpleResourceRule(&rule); isSimple {\n\t\t\tif existingRule, ok := simpleRules[resource]; ok {\n\t\t\t\t// Add the new verbs to the existing simple resource rule\n\t\t\t\tif existingRule.Verbs == nil {\n\t\t\t\t\texistingRule.Verbs = []string{}\n\t\t\t\t}\n\t\t\t\texistingRule.Verbs = append(existingRule.Verbs, rule.Verbs...)\n\t\t\t} else {\n\t\t\t\t// Copy the rule to accumulate matching simple resource rules into\n\t\t\t\tsimpleRules[resource] = rule.DeepCopy()\n\t\t\t}\n\t\t} else {\n\t\t\tcompacted = append(compacted, rule)\n\t\t}\n\t}\n\n\t// Once we've consolidated the simple resource rules, add them to the compacted list\n\tfor _, simpleRule := range simpleRules {\n\t\tcompacted = append(compacted, *simpleRule)\n\t}\n\n\treturn compacted, nil\n}", "category": "Python"}, {"instruction": "// Clone is used to return a new token cloned from an existing one\n//\n// Deprecated: Use TokenClone instead.", "input": "go language", "output": "func (a *ACL) Clone(id string, q *WriteOptions) (string, *WriteMeta, error) {\n\tr := a.c.newRequest(\"PUT\", \"/v1/acl/clone/\"+id)\n\tr.setWriteOptions(q)\n\trtt, resp, err := requireOK(a.c.doRequest(r))\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\twm := &WriteMeta{RequestTime: rtt}\n\tvar out struct{ ID string }\n\tif err := decodeBody(resp, &out); err != nil {\n\t\treturn \"\", nil, err\n\t}\n\treturn out.ID, wm, nil\n}", "category": "Python"}, {"instruction": "// executeKeyringOpMgr executes the appropriate keyring-related function based on\n// the type of keyring operation in the request. It takes the KeyManager as an\n// argument, so it can handle any operation for either LAN or WAN pools.", "input": "go language", "output": "func (m *Internal) executeKeyringOpMgr(\n\tmgr *serf.KeyManager,\n\targs *structs.KeyringRequest,\n\treply *structs.KeyringResponses,\n\twan bool,\n\tsegment string) {\n\tvar serfResp *serf.KeyResponse\n\tvar err error\n\n\topts := &serf.KeyRequestOptions{RelayFactor: args.RelayFactor}\n\tswitch args.Operation {\n\tcase structs.KeyringList:\n\t\tserfResp, err = mgr.ListKeysWithOptions(opts)\n\tcase structs.KeyringInstall:\n\t\tserfResp, err = mgr.InstallKeyWithOptions(args.Key, opts)\n\tcase structs.KeyringUse:\n\t\tserfResp, err = mgr.UseKeyWithOptions(args.Key, opts)\n\tcase structs.KeyringRemove:\n\t\tserfResp, err = mgr.RemoveKeyWithOptions(args.Key, opts)\n\t}\n\n\terrStr := \"\"\n\tif err != nil {\n\t\terrStr = err.Error()\n\t}\n\n\treply.Responses = append(reply.Responses, &structs.KeyringResponse{\n\t\tWAN:        wan,\n\t\tDatacenter: m.srv.config.Datacenter,\n\t\tSegment:    segment,\n\t\tMessages:   serfResp.Messages,\n\t\tKeys:       serfResp.Keys,\n\t\tNumNodes:   serfResp.NumNodes,\n\t\tError:      errStr,\n\t})\n}", "category": "Python"}, {"instruction": "// modifyHostOptionsForSandbox applies NetworkMode/UTSMode to sandbox's dockercontainer.HostConfig.", "input": "go language", "output": "func modifyHostOptionsForSandbox(nsOpts *runtimeapi.NamespaceOption, network *knetwork.PluginManager, hc *dockercontainer.HostConfig) {\n\tif nsOpts.GetIpc() == runtimeapi.NamespaceMode_NODE {\n\t\thc.IpcMode = namespaceModeHost\n\t}\n\tif nsOpts.GetNetwork() == runtimeapi.NamespaceMode_NODE {\n\t\thc.NetworkMode = namespaceModeHost\n\t\treturn\n\t}\n\n\tif network == nil {\n\t\thc.NetworkMode = \"default\"\n\t\treturn\n\t}\n\n\tswitch network.PluginName() {\n\tcase \"cni\":\n\t\tfallthrough\n\tcase \"kubenet\":\n\t\thc.NetworkMode = \"none\"\n\tdefault:\n\t\thc.NetworkMode = \"default\"\n\t}\n}", "category": "Python"}, {"instruction": "// GET /api/teams/:teamId/members", "input": "go language", "output": "func GetTeamMembers(c *m.ReqContext) Response {\n\tquery := m.GetTeamMembersQuery{OrgId: c.OrgId, TeamId: c.ParamsInt64(\":teamId\")}\n\n\tif err := bus.Dispatch(&query); err != nil {\n\t\treturn Error(500, \"Failed to get Team Members\", err)\n\t}\n\n\tfor _, member := range query.Result {\n\t\tmember.AvatarUrl = dtos.GetGravatarUrl(member.Email)\n\t\tmember.Labels = []string{}\n\n\t\tif setting.IsEnterprise && setting.LdapEnabled && member.External {\n\t\t\tmember.Labels = append(member.Labels, \"LDAP\")\n\t\t}\n\t}\n\n\treturn JSON(200, query.Result)\n}", "category": "Python"}, {"instruction": "// CASetProviderState is used to set the current built-in CA provider state.", "input": "go language", "output": "func (s *Store) CASetProviderState(idx uint64, state *structs.CAConsulProviderState) (bool, error) {\n\ttx := s.db.Txn(true)\n\tdefer tx.Abort()\n\n\t// Check for an existing config\n\texisting, err := tx.First(caBuiltinProviderTableName, \"id\", state.ID)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"failed built-in CA state lookup: %s\", err)\n\t}\n\n\t// Set the indexes.\n\tif existing != nil {\n\t\tstate.CreateIndex = existing.(*structs.CAConsulProviderState).CreateIndex\n\t} else {\n\t\tstate.CreateIndex = idx\n\t}\n\tstate.ModifyIndex = idx\n\n\tif err := tx.Insert(caBuiltinProviderTableName, state); err != nil {\n\t\treturn false, fmt.Errorf(\"failed updating built-in CA state: %s\", err)\n\t}\n\n\t// Update the index\n\tif err := tx.Insert(\"index\", &IndexEntry{caBuiltinProviderTableName, idx}); err != nil {\n\t\treturn false, fmt.Errorf(\"failed updating index: %s\", err)\n\t}\n\n\ttx.Commit()\n\n\treturn true, nil\n}", "category": "Python"}, {"instruction": "// Create creates a WAL ready for appending records. The given metadata is\n// recorded at the head of each WAL file, and can be retrieved with ReadAll.", "input": "go language", "output": "func Create(dirpath string, metadata []byte) (*WAL, error) {\n\tif Exist(dirpath) {\n\t\treturn nil, os.ErrExist\n\t}\n\n\tif err := os.MkdirAll(dirpath, privateDirMode); err != nil {\n\t\treturn nil, err\n\t}\n\n\tp := path.Join(dirpath, walName(0, 0))\n\tf, err := os.OpenFile(p, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0600)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tl, err := fileutil.NewLock(f.Name())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err = l.Lock(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tw := &WAL{\n\t\tdir:      dirpath,\n\t\tmetadata: metadata,\n\t\tseq:      0,\n\t\tf:        f,\n\t\tencoder:  newEncoder(f, 0),\n\t}\n\tw.locks = append(w.locks, l)\n\tif err := w.saveCrc(0); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := w.encoder.encode(&walpb.Record{Type: metadataType, Data: metadata}); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := w.SaveSnapshot(walpb.Snapshot{}); err != nil {\n\t\treturn nil, err\n\t}\n\treturn w, nil\n}", "category": "Python"}, {"instruction": "// NewProviderAggregator returns an aggregate of all the providers configured in the static configuration.", "input": "go language", "output": "func NewProviderAggregator(conf static.Providers) ProviderAggregator {\n\tp := ProviderAggregator{}\n\n\tif conf.File != nil {\n\t\tp.quietAddProvider(conf.File)\n\t}\n\n\tif conf.Docker != nil {\n\t\tp.quietAddProvider(conf.Docker)\n\t}\n\n\tif conf.Marathon != nil {\n\t\tp.quietAddProvider(conf.Marathon)\n\t}\n\n\tif conf.Rest != nil {\n\t\tp.quietAddProvider(conf.Rest)\n\t}\n\n\tif conf.Kubernetes != nil {\n\t\tp.quietAddProvider(conf.Kubernetes)\n\t}\n\n\tif conf.KubernetesCRD != nil {\n\t\tp.quietAddProvider(conf.KubernetesCRD)\n\t}\n\tif conf.Rancher != nil {\n\t\tp.quietAddProvider(conf.Rancher)\n\t}\n\n\treturn p\n}", "category": "Python"}, {"instruction": "// ConfigList returns the list of configs.", "input": "go language", "output": "func (cli *Client) ConfigList(ctx context.Context, options types.ConfigListOptions) ([]swarm.Config, error) {\n\tif err := cli.NewVersionError(\"1.30\", \"config list\"); err != nil {\n\t\treturn nil, err\n\t}\n\tquery := url.Values{}\n\n\tif options.Filters.Len() > 0 {\n\t\tfilterJSON, err := filters.ToJSON(options.Filters)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tquery.Set(\"filters\", filterJSON)\n\t}\n\n\tresp, err := cli.get(ctx, \"/configs\", query, nil)\n\tdefer ensureReaderClosed(resp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar configs []swarm.Config\n\terr = json.NewDecoder(resp.body).Decode(&configs)\n\treturn configs, err\n}", "category": "Python"}, {"instruction": "// ValidateContainerStateTransition test to if any illegal container state transitions are being attempted", "input": "go language", "output": "func ValidateContainerStateTransition(newStatuses, oldStatuses []core.ContainerStatus, fldpath *field.Path, restartPolicy core.RestartPolicy) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\t// If we should always restart, containers are allowed to leave the terminated state\n\tif restartPolicy == core.RestartPolicyAlways {\n\t\treturn allErrs\n\t}\n\tfor i, oldStatus := range oldStatuses {\n\t\t// Skip any container that is not terminated\n\t\tif oldStatus.State.Terminated == nil {\n\t\t\tcontinue\n\t\t}\n\t\t// Skip any container that failed but is allowed to restart\n\t\tif oldStatus.State.Terminated.ExitCode != 0 && restartPolicy == core.RestartPolicyOnFailure {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, newStatus := range newStatuses {\n\t\t\tif oldStatus.Name == newStatus.Name && newStatus.State.Terminated == nil {\n\t\t\t\tallErrs = append(allErrs, field.Forbidden(fldpath.Index(i).Child(\"state\"), \"may not be transitioned to non-terminated state\"))\n\t\t\t}\n\t\t}\n\t}\n\treturn allErrs\n}", "category": "Python"}, {"instruction": "// ServerGroups returns the supported groups, with information like supported\n// versions and the preferred version.", "input": "go language", "output": "func (c *FakeDiscovery) ServerGroups() (*metav1.APIGroupList, error) {\n\taction := testing.ActionImpl{\n\t\tVerb:     \"get\",\n\t\tResource: schema.GroupVersionResource{Resource: \"group\"},\n\t}\n\tc.Invokes(action, nil)\n\n\tgroups := map[string]*metav1.APIGroup{}\n\n\tfor _, res := range c.Resources {\n\t\tgv, err := schema.ParseGroupVersion(res.GroupVersion)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tgroup := groups[gv.Group]\n\t\tif group == nil {\n\t\t\tgroup = &metav1.APIGroup{\n\t\t\t\tName: gv.Group,\n\t\t\t\tPreferredVersion: metav1.GroupVersionForDiscovery{\n\t\t\t\t\tGroupVersion: res.GroupVersion,\n\t\t\t\t\tVersion:      gv.Version,\n\t\t\t\t},\n\t\t\t}\n\t\t\tgroups[gv.Group] = group\n\t\t}\n\n\t\tgroup.Versions = append(group.Versions, metav1.GroupVersionForDiscovery{\n\t\t\tGroupVersion: res.GroupVersion,\n\t\t\tVersion:      gv.Version,\n\t\t})\n\t}\n\n\tlist := &metav1.APIGroupList{}\n\tfor _, apiGroup := range groups {\n\t\tlist.Groups = append(list.Groups, *apiGroup)\n\t}\n\n\treturn list, nil\n\n}", "category": "Python"}, {"instruction": "// Coordinates queries for all nodes with coordinates.", "input": "go language", "output": "func (s *Store) Coordinates(ws memdb.WatchSet) (uint64, structs.Coordinates, error) {\n\ttx := s.db.Txn(false)\n\tdefer tx.Abort()\n\n\t// Get the table index.\n\tidx := maxIndexTxn(tx, \"coordinates\")\n\n\t// Pull all the coordinates.\n\titer, err := tx.Get(\"coordinates\", \"id\")\n\tif err != nil {\n\t\treturn 0, nil, fmt.Errorf(\"failed coordinate lookup: %s\", err)\n\t}\n\tws.Add(iter.WatchCh())\n\n\tvar results structs.Coordinates\n\tfor coord := iter.Next(); coord != nil; coord = iter.Next() {\n\t\tresults = append(results, coord.(*structs.Coordinate))\n\t}\n\treturn idx, results, nil\n}", "category": "Python"}, {"instruction": "// GetQuota - get the quota limits of a directory that was configured with SetQuota", "input": "go language", "output": "func (q *Control) GetQuota(targetPath string, quota *Quota) error {\n\n\tprojectID, ok := q.quotas[targetPath]\n\tif !ok {\n\t\treturn errors.Errorf(\"quota not found for path: %s\", targetPath)\n\t}\n\n\t//\n\t// get the quota limit for the container's project id\n\t//\n\tvar d C.fs_disk_quota_t\n\n\tvar cs = C.CString(q.backingFsBlockDev)\n\tdefer C.free(unsafe.Pointer(cs))\n\n\t_, _, errno := unix.Syscall6(unix.SYS_QUOTACTL, C.Q_XGETPQUOTA,\n\t\tuintptr(unsafe.Pointer(cs)), uintptr(C.__u32(projectID)),\n\t\tuintptr(unsafe.Pointer(&d)), 0, 0)\n\tif errno != 0 {\n\t\treturn errors.Wrapf(errno, \"Failed to get quota limit for projid %d on %s\",\n\t\t\tprojectID, q.backingFsBlockDev)\n\t}\n\tquota.Size = uint64(d.d_blk_hardlimit) * 512\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// NewHTTPCodeRanges creates HTTPCodeRanges from a given []string.\n// Break out the http status code ranges into a low int and high int\n// for ease of use at runtime", "input": "go language", "output": "func NewHTTPCodeRanges(strBlocks []string) (HTTPCodeRanges, error) {\n\tvar blocks HTTPCodeRanges\n\tfor _, block := range strBlocks {\n\t\tcodes := strings.Split(block, \"-\")\n\t\t// if only a single HTTP code was configured, assume the best and create the correct configuration on the user's behalf\n\t\tif len(codes) == 1 {\n\t\t\tcodes = append(codes, codes[0])\n\t\t}\n\t\tlowCode, err := strconv.Atoi(codes[0])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\thighCode, err := strconv.Atoi(codes[1])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tblocks = append(blocks, [2]int{lowCode, highCode})\n\t}\n\treturn blocks, nil\n}", "category": "Python"}, {"instruction": "// evalInt evals INSTR(str,substr), case insensitive\n// See https://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_instr", "input": "go language", "output": "func (b *builtinInstrSig) evalInt(row chunk.Row) (int64, bool, error) {\n\tstr, IsNull, err := b.args[0].EvalString(b.ctx, row)\n\tif IsNull || err != nil {\n\t\treturn 0, true, err\n\t}\n\tstr = strings.ToLower(str)\n\n\tsubstr, IsNull, err := b.args[1].EvalString(b.ctx, row)\n\tif IsNull || err != nil {\n\t\treturn 0, true, err\n\t}\n\tsubstr = strings.ToLower(substr)\n\n\tidx := strings.Index(str, substr)\n\tif idx == -1 {\n\t\treturn 0, false, nil\n\t}\n\treturn int64(utf8.RuneCountInString(str[:idx]) + 1), false, nil\n}", "category": "Python"}, {"instruction": "// SamplePercentiles returns a slice of arbitrary percentiles of the slice of\n// int64.", "input": "go language", "output": "func SamplePercentiles(values int64Slice, ps []float64) []float64 {\n\tscores := make([]float64, len(ps))\n\tsize := len(values)\n\tif size > 0 {\n\t\tsort.Sort(values)\n\t\tfor i, p := range ps {\n\t\t\tpos := p * float64(size+1)\n\t\t\tif pos < 1.0 {\n\t\t\t\tscores[i] = float64(values[0])\n\t\t\t} else if pos >= float64(size) {\n\t\t\t\tscores[i] = float64(values[size-1])\n\t\t\t} else {\n\t\t\t\tlower := float64(values[int(pos)-1])\n\t\t\t\tupper := float64(values[int(pos)])\n\t\t\t\tscores[i] = lower + (pos-math.Floor(pos))*(upper-lower)\n\t\t\t}\n\t\t}\n\t}\n\treturn scores\n}", "category": "Python"}, {"instruction": "// sendSummary send the summary events for a single folder", "input": "go language", "output": "func (c *folderSummaryService) sendSummary(folder string) {\n\t// The folder summary contains how many bytes, files etc\n\t// are in the folder and how in sync we are.\n\tdata, err := c.Summary(folder)\n\tif err != nil {\n\t\treturn\n\t}\n\tevents.Default.Log(events.FolderSummary, map[string]interface{}{\n\t\t\"folder\":  folder,\n\t\t\"summary\": data,\n\t})\n\n\tfor _, devCfg := range c.cfg.Folders()[folder].Devices {\n\t\tif devCfg.DeviceID.Equals(c.id) {\n\t\t\t// We already know about ourselves.\n\t\t\tcontinue\n\t\t}\n\t\tif _, ok := c.model.Connection(devCfg.DeviceID); !ok {\n\t\t\t// We're not interested in disconnected devices.\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get completion percentage of this folder for the\n\t\t// remote device.\n\t\tcomp := c.model.Completion(devCfg.DeviceID, folder).Map()\n\t\tcomp[\"folder\"] = folder\n\t\tcomp[\"device\"] = devCfg.DeviceID.String()\n\t\tevents.Default.Log(events.FolderCompletion, comp)\n\t}\n}", "category": "Python"}, {"instruction": "// DefaultConfigDir is the default config directory to use for the vaults and other\n// persistence requirements.", "input": "go language", "output": "func DefaultConfigDir() string {\n\t// Try to place the data folder in the user's home dir\n\thome := homeDir()\n\tif home != \"\" {\n\t\tif runtime.GOOS == \"darwin\" {\n\t\t\treturn filepath.Join(home, \"Library\", \"Signer\")\n\t\t} else if runtime.GOOS == \"windows\" {\n\t\t\tappdata := os.Getenv(\"APPDATA\")\n\t\t\tif appdata != \"\" {\n\t\t\t\treturn filepath.Join(appdata, \"Signer\")\n\t\t\t} else {\n\t\t\t\treturn filepath.Join(home, \"AppData\", \"Roaming\", \"Signer\")\n\t\t\t}\n\t\t} else {\n\t\t\treturn filepath.Join(home, \".clef\")\n\t\t}\n\t}\n\t// As we cannot guess a stable location, return empty and handle later\n\treturn \"\"\n}", "category": "Python"}, {"instruction": "// MaybeFixUpResourceInstanceAddressForCount deals with the situation where a\n// resource has changed from having \"count\" set to not set, or vice-versa, and\n// so we need to rename the zeroth instance key to no key at all, or vice-versa.\n//\n// Set countEnabled to true if the resource has count set in its new\n// configuration, or false if it does not.\n//\n// The state is modified in-place if necessary, moving a resource instance\n// between the two addresses. The return value is true if a change was made,\n// and false otherwise.", "input": "go language", "output": "func (s *SyncState) MaybeFixUpResourceInstanceAddressForCount(addr addrs.AbsResource, countEnabled bool) bool {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tms := s.state.Module(addr.Module)\n\tif ms == nil {\n\t\treturn false\n\t}\n\n\trelAddr := addr.Resource\n\trs := ms.Resource(relAddr)\n\tif rs == nil {\n\t\treturn false\n\t}\n\thuntKey := addrs.NoKey\n\treplaceKey := addrs.InstanceKey(addrs.IntKey(0))\n\tif !countEnabled {\n\t\thuntKey, replaceKey = replaceKey, huntKey\n\t}\n\n\tis, exists := rs.Instances[huntKey]\n\tif !exists {\n\t\treturn false\n\t}\n\n\tif _, exists := rs.Instances[replaceKey]; exists {\n\t\t// If the replacement key also exists then we'll do nothing and keep both.\n\t\treturn false\n\t}\n\n\t// If we get here then we need to \"rename\" from hunt to replace\n\trs.Instances[replaceKey] = is\n\tdelete(rs.Instances, huntKey)\n\treturn true\n}", "category": "Python"}, {"instruction": "// importPreimages imports preimage data from the specified file.", "input": "go language", "output": "func importPreimages(ctx *cli.Context) error {\n\tif len(ctx.Args()) < 1 {\n\t\tutils.Fatalf(\"This command requires an argument.\")\n\t}\n\tstack := makeFullNode(ctx)\n\tdefer stack.Close()\n\n\tdb := utils.MakeChainDatabase(ctx, stack)\n\tstart := time.Now()\n\n\tif err := utils.ImportPreimages(db, ctx.Args().First()); err != nil {\n\t\tutils.Fatalf(\"Import error: %v\\n\", err)\n\t}\n\tfmt.Printf(\"Import done in %v\\n\", time.Since(start))\n\treturn nil\n}", "category": "Python"}, {"instruction": "// handleResponse processes method call responses.", "input": "go language", "output": "func (h *handler) handleResponse(msg *jsonrpcMessage) {\n\top := h.respWait[string(msg.ID)]\n\tif op == nil {\n\t\th.log.Debug(\"Unsolicited RPC response\", \"reqid\", idForLog{msg.ID})\n\t\treturn\n\t}\n\tdelete(h.respWait, string(msg.ID))\n\t// For normal responses, just forward the reply to Call/BatchCall.\n\tif op.sub == nil {\n\t\top.resp <- msg\n\t\treturn\n\t}\n\t// For subscription responses, start the subscription if the server\n\t// indicates success. EthSubscribe gets unblocked in either case through\n\t// the op.resp channel.\n\tdefer close(op.resp)\n\tif msg.Error != nil {\n\t\top.err = msg.Error\n\t\treturn\n\t}\n\tif op.err = json.Unmarshal(msg.Result, &op.sub.subid); op.err == nil {\n\t\tgo op.sub.start()\n\t\th.clientSubs[op.sub.subid] = op.sub\n\t}\n}", "category": "Python"}, {"instruction": "// RemoveString returns a newly created []string that contains all items from slice that\n// are not equal to s and modifier(s) in case modifier func is provided.", "input": "go language", "output": "func RemoveString(slice []string, s string, modifier func(s string) string) []string {\n\tnewSlice := make([]string, 0)\n\tfor _, item := range slice {\n\t\tif item == s {\n\t\t\tcontinue\n\t\t}\n\t\tif modifier != nil && modifier(item) == s {\n\t\t\tcontinue\n\t\t}\n\t\tnewSlice = append(newSlice, item)\n\t}\n\tif len(newSlice) == 0 {\n\t\t// Sanitize for unit tests so we don't need to distinguish empty array\n\t\t// and nil.\n\t\tnewSlice = nil\n\t}\n\treturn newSlice\n}", "category": "Python"}, {"instruction": "// PreparedQueryList returns all the prepared queries.", "input": "go language", "output": "func (s *Store) PreparedQueryList(ws memdb.WatchSet) (uint64, structs.PreparedQueries, error) {\n\ttx := s.db.Txn(false)\n\tdefer tx.Abort()\n\n\t// Get the table index.\n\tidx := maxIndexTxn(tx, \"prepared-queries\")\n\n\t// Query all of the prepared queries in the state store.\n\tqueries, err := tx.Get(\"prepared-queries\", \"id\")\n\tif err != nil {\n\t\treturn 0, nil, fmt.Errorf(\"failed prepared query lookup: %s\", err)\n\t}\n\tws.Add(queries.WatchCh())\n\n\t// Go over all of the queries and build the response.\n\tvar result structs.PreparedQueries\n\tfor wrapped := queries.Next(); wrapped != nil; wrapped = queries.Next() {\n\t\tresult = append(result, toPreparedQuery(wrapped))\n\t}\n\treturn idx, result, nil\n}", "category": "Python"}, {"instruction": "// LookupRuntimeHandler returns the RuntimeHandler string associated with the given RuntimeClass\n// name (or the default of \"\" for nil). If the RuntimeClass is not found, it returns an\n// errors.NotFound error.", "input": "go language", "output": "func (m *Manager) LookupRuntimeHandler(runtimeClassName *string) (string, error) {\n\tif runtimeClassName == nil || *runtimeClassName == \"\" {\n\t\t// The default RuntimeClass always resolves to the empty runtime handler.\n\t\treturn \"\", nil\n\t}\n\n\tname := *runtimeClassName\n\n\trc, err := m.lister.Get(name)\n\tif err != nil {\n\t\tif errors.IsNotFound(err) {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn \"\", fmt.Errorf(\"Failed to lookup RuntimeClass %s: %v\", name, err)\n\t}\n\n\treturn rc.Handler, nil\n}", "category": "Python"}, {"instruction": "// Intersect tries to return a pair of coordinates which are compatible with the\n// current set and a given set. We employ some special knowledge about network\n// segments to avoid doing a full intersection, since this is in several hot\n// paths. This might return nil for either coordinate in the output pair if an\n// intersection cannot be found. The ComputeDistance function above is designed\n// to deal with that.", "input": "go language", "output": "func (cs CoordinateSet) Intersect(other CoordinateSet) (*coordinate.Coordinate, *coordinate.Coordinate) {\n\t// Use the empty segment by default.\n\tsegment := \"\"\n\n\t// If we have a single segment, then let our segment take priority since\n\t// we are possibly a client. Any node with more than one segment can only\n\t// be a server, which means it should be in all segments.\n\tif len(cs) == 1 {\n\t\tfor s := range cs {\n\t\t\tsegment = s\n\t\t}\n\t}\n\n\t// Likewise for the other set.\n\tif len(other) == 1 {\n\t\tfor s := range other {\n\t\t\tsegment = s\n\t\t}\n\t}\n\n\treturn cs[segment], other[segment]\n}", "category": "Python"}, {"instruction": "// List takes label and field selectors, and returns the list of Pods that match those selectors.", "input": "go language", "output": "func (c *FakePods) List(opts v1.ListOptions) (result *corev1.PodList, err error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewListAction(podsResource, podsKind, c.ns, opts), &corev1.PodList{})\n\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n\tif label == nil {\n\t\tlabel = labels.Everything()\n\t}\n\tlist := &corev1.PodList{ListMeta: obj.(*corev1.PodList).ListMeta}\n\tfor _, item := range obj.(*corev1.PodList).Items {\n\t\tif label.Matches(labels.Set(item.Labels)) {\n\t\t\tlist.Items = append(list.Items, item)\n\t\t}\n\t}\n\treturn list, err\n}", "category": "Python"}, {"instruction": "// autoDeposit starts a goroutine that periodically sends funds to the chequebook\n// contract caller holds the lock the go routine terminates if Chequebook.quit is closed.", "input": "go language", "output": "func (cb *Chequebook) autoDeposit(interval time.Duration) {\n\tif cb.quit != nil {\n\t\tclose(cb.quit)\n\t\tcb.quit = nil\n\t}\n\t// if threshold >= balance autodeposit after every cheque issued\n\tif interval == time.Duration(0) || cb.threshold != nil && cb.buffer != nil && cb.threshold.Cmp(cb.buffer) >= 0 {\n\t\treturn\n\t}\n\n\tticker := time.NewTicker(interval)\n\tcb.quit = make(chan bool)\n\tquit := cb.quit\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-quit:\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tcb.lock.Lock()\n\t\t\t\tif cb.balance.Cmp(cb.buffer) < 0 {\n\t\t\t\t\tamount := new(big.Int).Sub(cb.buffer, cb.balance)\n\t\t\t\t\ttxhash, err := cb.deposit(amount)\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\tcb.txhash = txhash\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcb.lock.Unlock()\n\t\t\t}\n\t\t}\n\t}()\n}", "category": "Python"}, {"instruction": "// WaitForPodToDisappear blocks until it timeouts or gets a \"NotFound\" response from the API Server when getting the Static Pod in question", "input": "go language", "output": "func (w *KubeWaiter) WaitForPodToDisappear(podName string) error {\n\treturn wait.PollImmediate(constants.APICallRetryInterval, w.timeout, func() (bool, error) {\n\t\t_, err := w.client.CoreV1().Pods(metav1.NamespaceSystem).Get(podName, metav1.GetOptions{})\n\t\tif apierrors.IsNotFound(err) {\n\t\t\tfmt.Printf(\"[apiclient] The old Pod %q is now removed (which is desired)\\n\", podName)\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, nil\n\t})\n}", "category": "Python"}, {"instruction": "// NewKubeletStartPhase creates a kubeadm workflow phase that start kubelet on a node.", "input": "go language", "output": "func NewKubeletStartPhase() workflow.Phase {\n\treturn workflow.Phase{\n\t\tName:  \"kubelet-start [api-server-endpoint]\",\n\t\tShort: \"Write kubelet settings, certificates and (re)start the kubelet\",\n\t\tLong:  \"Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.\",\n\t\tRun:   runKubeletStartJoinPhase,\n\t\tInheritFlags: []string{\n\t\t\toptions.CfgPath,\n\t\t\toptions.NodeCRISocket,\n\t\t\toptions.NodeName,\n\t\t\toptions.FileDiscovery,\n\t\t\toptions.TokenDiscovery,\n\t\t\toptions.TokenDiscoveryCAHash,\n\t\t\toptions.TokenDiscoverySkipCAHash,\n\t\t\toptions.TLSBootstrapToken,\n\t\t\toptions.TokenStr,\n\t\t},\n\t}\n}", "category": "Python"}, {"instruction": "// List takes label and field selectors, and returns the list of ReplicationControllers that match those selectors.", "input": "go language", "output": "func (c *FakeReplicationControllers) List(opts v1.ListOptions) (result *corev1.ReplicationControllerList, err error) {\n\tobj, err := c.Fake.\n\t\tInvokes(testing.NewListAction(replicationcontrollersResource, replicationcontrollersKind, c.ns, opts), &corev1.ReplicationControllerList{})\n\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n\tif label == nil {\n\t\tlabel = labels.Everything()\n\t}\n\tlist := &corev1.ReplicationControllerList{ListMeta: obj.(*corev1.ReplicationControllerList).ListMeta}\n\tfor _, item := range obj.(*corev1.ReplicationControllerList).Items {\n\t\tif label.Matches(labels.Set(item.Labels)) {\n\t\t\tlist.Items = append(list.Items, item)\n\t\t}\n\t}\n\treturn list, err\n}", "category": "Python"}, {"instruction": "// convertFakeContainer converts the fake container to real container", "input": "go language", "output": "func convertFakeContainer(f *FakeContainer) *dockertypes.ContainerJSON {\n\tif f.Config == nil {\n\t\tf.Config = &dockercontainer.Config{}\n\t}\n\tif f.HostConfig == nil {\n\t\tf.HostConfig = &dockercontainer.HostConfig{}\n\t}\n\treturn &dockertypes.ContainerJSON{\n\t\tContainerJSONBase: &dockertypes.ContainerJSONBase{\n\t\t\tID:    f.ID,\n\t\t\tName:  f.Name,\n\t\t\tImage: f.Config.Image,\n\t\t\tState: &dockertypes.ContainerState{\n\t\t\t\tRunning:    f.Running,\n\t\t\t\tExitCode:   f.ExitCode,\n\t\t\t\tPid:        f.Pid,\n\t\t\t\tStartedAt:  dockerTimestampToString(f.StartedAt),\n\t\t\t\tFinishedAt: dockerTimestampToString(f.FinishedAt),\n\t\t\t},\n\t\t\tCreated:    dockerTimestampToString(f.CreatedAt),\n\t\t\tHostConfig: f.HostConfig,\n\t\t},\n\t\tConfig:          f.Config,\n\t\tNetworkSettings: &dockertypes.NetworkSettings{},\n\t}\n}", "category": "Python"}, {"instruction": "// NewECDSASignerEntity returns a signer entity that is capable of signing using ECDSA", "input": "go language", "output": "func NewECDSASignerEntity(ID string, b bccsp.BCCSP, signKeyBytes []byte) (*BCCSPSignerEntity, error) {\n\tif b == nil {\n\t\treturn nil, errors.New(\"nil BCCSP\")\n\t}\n\n\tbl, _ := pem.Decode(signKeyBytes)\n\tif bl == nil {\n\t\treturn nil, errors.New(\"pem.Decode returns nil\")\n\t}\n\n\tsignKey, err := b.KeyImport(bl.Bytes, &bccsp.ECDSAPrivateKeyImportOpts{Temporary: true})\n\tif err != nil {\n\t\treturn nil, errors.WithMessage(err, \"bccspInst.KeyImport failed\")\n\t}\n\n\treturn NewSignerEntity(ID, b, signKey, nil, &bccsp.SHA256Opts{})\n}", "category": "Python"}, {"instruction": "// StartWSEndpoint starts a websocket endpoint", "input": "go language", "output": "func StartWSEndpoint(endpoint string, apis []API, modules []string, wsOrigins []string, exposeAll bool) (net.Listener, *Server, error) {\n\n\t// Generate the whitelist based on the allowed modules\n\twhitelist := make(map[string]bool)\n\tfor _, module := range modules {\n\t\twhitelist[module] = true\n\t}\n\t// Register all the APIs exposed by the services\n\thandler := NewServer()\n\tfor _, api := range apis {\n\t\tif exposeAll || whitelist[api.Namespace] || (len(whitelist) == 0 && api.Public) {\n\t\t\tif err := handler.RegisterName(api.Namespace, api.Service); err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tlog.Debug(\"WebSocket registered\", \"service\", api.Service, \"namespace\", api.Namespace)\n\t\t}\n\t}\n\t// All APIs registered, start the HTTP listener\n\tvar (\n\t\tlistener net.Listener\n\t\terr      error\n\t)\n\tif listener, err = net.Listen(\"tcp\", endpoint); err != nil {\n\t\treturn nil, nil, err\n\t}\n\tgo NewWSServer(wsOrigins, handler).Serve(listener)\n\treturn listener, handler, err\n\n}", "category": "Python"}, {"instruction": "// IntrinsicGas computes the 'intrinsic gas' for a message with the given data.", "input": "go language", "output": "func IntrinsicGas(data []byte, contractCreation, homestead bool) (uint64, error) {\n\t// Set the starting gas for the raw transaction\n\tvar gas uint64\n\tif contractCreation && homestead {\n\t\tgas = params.TxGasContractCreation\n\t} else {\n\t\tgas = params.TxGas\n\t}\n\t// Bump the required gas by the amount of transactional data\n\tif len(data) > 0 {\n\t\t// Zero and non-zero bytes are priced differently\n\t\tvar nz uint64\n\t\tfor _, byt := range data {\n\t\t\tif byt != 0 {\n\t\t\t\tnz++\n\t\t\t}\n\t\t}\n\t\t// Make sure we don't exceed uint64 for all data combinations\n\t\tif (math.MaxUint64-gas)/params.TxDataNonZeroGas < nz {\n\t\t\treturn 0, vm.ErrOutOfGas\n\t\t}\n\t\tgas += nz * params.TxDataNonZeroGas\n\n\t\tz := uint64(len(data)) - nz\n\t\tif (math.MaxUint64-gas)/params.TxDataZeroGas < z {\n\t\t\treturn 0, vm.ErrOutOfGas\n\t\t}\n\t\tgas += z * params.TxDataZeroGas\n\t}\n\treturn gas, nil\n}", "category": "Python"}, {"instruction": "// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.", "input": "go language", "output": "func (in *CustomResourceDefinitionVersion) DeepCopyInto(out *CustomResourceDefinitionVersion) {\n\t*out = *in\n\tif in.Schema != nil {\n\t\tin, out := &in.Schema, &out.Schema\n\t\t*out = new(CustomResourceValidation)\n\t\t(*in).DeepCopyInto(*out)\n\t}\n\tif in.Subresources != nil {\n\t\tin, out := &in.Subresources, &out.Subresources\n\t\t*out = new(CustomResourceSubresources)\n\t\t(*in).DeepCopyInto(*out)\n\t}\n\tif in.AdditionalPrinterColumns != nil {\n\t\tin, out := &in.AdditionalPrinterColumns, &out.AdditionalPrinterColumns\n\t\t*out = make([]CustomResourceColumnDefinition, len(*in))\n\t\tcopy(*out, *in)\n\t}\n\treturn\n}", "category": "Python"}, {"instruction": "// incGCSizeInBatch changes gcSize field value\n// by change which can be negative. This function\n// must be called under batchMu lock.", "input": "go language", "output": "func (db *DB) incGCSizeInBatch(batch *leveldb.Batch, change int64) (err error) {\n\tif change == 0 {\n\t\treturn nil\n\t}\n\tgcSize, err := db.gcSize.Get()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar new uint64\n\tif change > 0 {\n\t\tnew = gcSize + uint64(change)\n\t} else {\n\t\t// 'change' is an int64 and is negative\n\t\t// a conversion is needed with correct sign\n\t\tc := uint64(-change)\n\t\tif c > gcSize {\n\t\t\t// protect uint64 undeflow\n\t\t\treturn nil\n\t\t}\n\t\tnew = gcSize - c\n\t}\n\tdb.gcSize.PutInBatch(batch, new)\n\n\t// trigger garbage collection if we reached the capacity\n\tif new >= db.capacity {\n\t\tdb.triggerGarbageCollection()\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// Open implements the Executor Open interface.", "input": "go language", "output": "func (e *IndexLookUpExecutor) Open(ctx context.Context) error {\n\tvar err error\n\tif e.corColInAccess {\n\t\te.ranges, err = rebuildIndexRanges(e.ctx, e.idxPlans[0].(*plannercore.PhysicalIndexScan), e.idxCols, e.colLens)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\te.kvRanges, err = distsql.IndexRangesToKVRanges(e.ctx.GetSessionVars().StmtCtx, getPhysicalTableID(e.table), e.index.ID, e.ranges, e.feedback)\n\tif err != nil {\n\t\te.feedback.Invalidate()\n\t\treturn err\n\t}\n\terr = e.open(ctx)\n\tif err != nil {\n\t\te.feedback.Invalidate()\n\t}\n\treturn err\n}", "category": "Python"}, {"instruction": "// RunServer listens on the given port if listener is not given,\n// then spawns a go-routine continuously serving until the stopCh is closed.\n// It returns a stoppedCh that is closed when all non-hijacked active requests\n// have been processed.\n// This function does not block\n// TODO: make private when insecure serving is gone from the kube-apiserver", "input": "go language", "output": "func RunServer(\n\tserver *http.Server,\n\tln net.Listener,\n\tshutDownTimeout time.Duration,\n\tstopCh <-chan struct{},\n) (<-chan struct{}, error) {\n\tif ln == nil {\n\t\treturn nil, fmt.Errorf(\"listener must not be nil\")\n\t}\n\n\t// Shutdown server gracefully.\n\tstoppedCh := make(chan struct{})\n\tgo func() {\n\t\tdefer close(stoppedCh)\n\t\t<-stopCh\n\t\tctx, cancel := context.WithTimeout(context.Background(), shutDownTimeout)\n\t\tserver.Shutdown(ctx)\n\t\tcancel()\n\t}()\n\n\tgo func() {\n\t\tdefer utilruntime.HandleCrash()\n\n\t\tvar listener net.Listener\n\t\tlistener = tcpKeepAliveListener{ln.(*net.TCPListener)}\n\t\tif server.TLSConfig != nil {\n\t\t\tlistener = tls.NewListener(listener, server.TLSConfig)\n\t\t}\n\n\t\terr := server.Serve(listener)\n\n\t\tmsg := fmt.Sprintf(\"Stopped listening on %s\", ln.Addr().String())\n\t\tselect {\n\t\tcase <-stopCh:\n\t\t\tklog.Info(msg)\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\"%s due to error: %v\", msg, err))\n\t\t}\n\t}()\n\n\treturn stoppedCh, nil\n}", "category": "Python"}, {"instruction": "// LoadMetadata loads the chaincode metadata stored at the specified path", "input": "go language", "output": "func (s *Store) LoadMetadata(path string) (name, version string, err error) {\n\tmetadataBytes, err := s.ReadWriter.ReadFile(path)\n\tif err != nil {\n\t\terr = errors.Wrapf(err, \"error reading metadata at %s\", path)\n\t\treturn \"\", \"\", err\n\t}\n\tccMetadata := &ChaincodeMetadata{}\n\terr = json.Unmarshal(metadataBytes, ccMetadata)\n\tif err != nil {\n\t\terr = errors.Wrapf(err, \"error unmarshaling metadata at %s\", path)\n\t\treturn \"\", \"\", err\n\t}\n\n\treturn ccMetadata.Name, ccMetadata.Version, nil\n}", "category": "Python"}, {"instruction": "// Delete the eligible dead container instances in a pod. Depending on the configuration, the latest dead containers may be kept around.", "input": "go language", "output": "func (kl *Kubelet) cleanUpContainersInPod(podID types.UID, exitedContainerID string) {\n\tif podStatus, err := kl.podCache.Get(podID); err == nil {\n\t\tremoveAll := false\n\t\tif syncedPod, ok := kl.podManager.GetPodByUID(podID); ok {\n\t\t\t// generate the api status using the cached runtime status to get up-to-date ContainerStatuses\n\t\t\tapiPodStatus := kl.generateAPIPodStatus(syncedPod, podStatus)\n\t\t\t// When an evicted or deleted pod has already synced, all containers can be removed.\n\t\t\tremoveAll = eviction.PodIsEvicted(syncedPod.Status) || (syncedPod.DeletionTimestamp != nil && notRunning(apiPodStatus.ContainerStatuses))\n\t\t}\n\t\tkl.containerDeletor.deleteContainersInPod(exitedContainerID, podStatus, removeAll)\n\t}\n}", "category": "Python"}, {"instruction": "// ValidateWebhook validates the webhook", "input": "go language", "output": "func ValidateWebhook(w auditregistration.Webhook, fldPath *field.Path) field.ErrorList {\n\tvar allErrs field.ErrorList\n\tif w.Throttle != nil {\n\t\tallErrs = append(allErrs, ValidateWebhookThrottleConfig(w.Throttle, fldPath.Child(\"throttle\"))...)\n\t}\n\n\tcc := w.ClientConfig\n\tswitch {\n\tcase (cc.URL == nil) == (cc.Service == nil):\n\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"clientConfig\"), \"exactly one of url or service is required\"))\n\tcase cc.URL != nil:\n\t\tallErrs = append(allErrs, webhook.ValidateWebhookURL(fldPath.Child(\"clientConfig\").Child(\"url\"), *cc.URL, false)...)\n\tcase cc.Service != nil:\n\t\tallErrs = append(allErrs, webhook.ValidateWebhookService(fldPath.Child(\"clientConfig\").Child(\"service\"), cc.Service.Name, cc.Service.Namespace, cc.Service.Path, cc.Service.Port)...)\n\t}\n\treturn allErrs\n}", "category": "Python"}, {"instruction": "// InstallReleaseFromChart installs a new chart and returns the release response.", "input": "go language", "output": "func (h *Client) InstallReleaseFromChart(chart *chart.Chart, ns string, opts ...InstallOption) (*rls.InstallReleaseResponse, error) {\n\t// apply the install options\n\treqOpts := h.opts\n\tfor _, opt := range opts {\n\t\topt(&reqOpts)\n\t}\n\treq := &reqOpts.instReq\n\treq.Chart = chart\n\treq.Namespace = ns\n\treq.DryRun = reqOpts.dryRun\n\treq.DisableHooks = reqOpts.disableHooks\n\treq.DisableCrdHook = reqOpts.disableCRDHook\n\treq.ReuseName = reqOpts.reuseName\n\tctx := NewContext()\n\n\tif reqOpts.before != nil {\n\t\tif err := reqOpts.before(ctx, req); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\terr := chartutil.ProcessRequirementsEnabled(req.Chart, req.Values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = chartutil.ProcessRequirementsImportValues(req.Chart)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn h.install(ctx, req)\n}", "category": "Python"}, {"instruction": "// NewEvaluatorSuite creates an EvaluatorSuite to evaluate all the exprs.\n// avoidColumnEvaluator can be removed after column pool is supported.", "input": "go language", "output": "func NewEvaluatorSuite(exprs []Expression, avoidColumnEvaluator bool) *EvaluatorSuite {\n\te := &EvaluatorSuite{}\n\n\tfor i := 0; i < len(exprs); i++ {\n\t\tif col, isCol := exprs[i].(*Column); isCol && !avoidColumnEvaluator {\n\t\t\tif e.columnEvaluator == nil {\n\t\t\t\te.columnEvaluator = &columnEvaluator{inputIdxToOutputIdxes: make(map[int][]int)}\n\t\t\t}\n\t\t\tinputIdx, outputIdx := col.Index, i\n\t\t\te.columnEvaluator.inputIdxToOutputIdxes[inputIdx] = append(e.columnEvaluator.inputIdxToOutputIdxes[inputIdx], outputIdx)\n\t\t\tcontinue\n\t\t}\n\t\tif e.defaultEvaluator == nil {\n\t\t\te.defaultEvaluator = &defaultEvaluator{\n\t\t\t\toutputIdxes: make([]int, 0, len(exprs)),\n\t\t\t\texprs:       make([]Expression, 0, len(exprs)),\n\t\t\t}\n\t\t}\n\t\te.defaultEvaluator.exprs = append(e.defaultEvaluator.exprs, exprs[i])\n\t\te.defaultEvaluator.outputIdxes = append(e.defaultEvaluator.outputIdxes, i)\n\t}\n\n\tif e.defaultEvaluator != nil {\n\t\te.defaultEvaluator.vectorizable = Vectorizable(e.defaultEvaluator.exprs)\n\t}\n\treturn e\n}", "category": "Python"}, {"instruction": "// Round returns the nearest integer, rounding half away from zero.\n//\n// Special cases are:\n//\tRound(\u00b10) = \u00b10\n//\tRound(\u00b1Inf) = \u00b1Inf\n//\tRound(NaN) = NaN", "input": "go language", "output": "func _round(x float64) float64 {\n\t// Round is a faster implementation of:\n\t//\n\t// func Round(x float64) float64 {\n\t//   t := Trunc(x)\n\t//   if Abs(x-t) >= 0.5 {\n\t//     return t + Copysign(1, x)\n\t//   }\n\t//   return t\n\t// }\n\tconst (\n\t\tsignMask = 1 << 63\n\t\tfracMask = 1<<shift - 1\n\t\thalf     = 1 << (shift - 1)\n\t\tone      = bias << shift\n\t)\n\n\tbits := math.Float64bits(x)\n\te := uint(bits>>shift) & mask\n\tif e < bias {\n\t\t// Round abs(x) < 1 including denormals.\n\t\tbits &= signMask // +-0\n\t\tif e == bias-1 {\n\t\t\tbits |= one // +-1\n\t\t}\n\t} else if e < bias+shift {\n\t\t// Round any abs(x) >= 1 containing a fractional component [0,1).\n\t\t//\n\t\t// Numbers with larger exponents are returned unchanged since they\n\t\t// must be either an integer, infinity, or NaN.\n\t\te -= bias\n\t\tbits += half >> e\n\t\tbits &^= fracMask >> e\n\t}\n\treturn math.Float64frombits(bits)\n}", "category": "Python"}, {"instruction": "// GetDiskLun finds the lun on the host that the vhd is attached to, given a vhd's diskName and diskURI.", "input": "go language", "output": "func (c *controllerCommon) GetDiskLun(diskName, diskURI string, nodeName types.NodeName) (int32, error) {\n\tdisks, err := c.getNodeDataDisks(nodeName)\n\tif err != nil {\n\t\tklog.Errorf(\"error of getting data disks for node %q: %v\", nodeName, err)\n\t\treturn -1, err\n\t}\n\n\tfor _, disk := range disks {\n\t\tif disk.Lun != nil && (disk.Name != nil && diskName != \"\" && *disk.Name == diskName) ||\n\t\t\t(disk.Vhd != nil && disk.Vhd.URI != nil && diskURI != \"\" && *disk.Vhd.URI == diskURI) ||\n\t\t\t(disk.ManagedDisk != nil && *disk.ManagedDisk.ID == diskURI) {\n\t\t\t// found the disk\n\t\t\tklog.V(2).Infof(\"azureDisk - find disk: lun %d name %q uri %q\", *disk.Lun, diskName, diskURI)\n\t\t\treturn *disk.Lun, nil\n\t\t}\n\t}\n\treturn -1, fmt.Errorf(\"Cannot find Lun for disk %s\", diskName)\n}", "category": "Python"}, {"instruction": "// setStatus recreates the status of the given HPA, updating the current and\n// desired replicas, as well as the metric statuses", "input": "go language", "output": "func (a *HorizontalController) setStatus(hpa *autoscalingv2.HorizontalPodAutoscaler, currentReplicas, desiredReplicas int32, metricStatuses []autoscalingv2.MetricStatus, rescale bool) {\n\thpa.Status = autoscalingv2.HorizontalPodAutoscalerStatus{\n\t\tCurrentReplicas: currentReplicas,\n\t\tDesiredReplicas: desiredReplicas,\n\t\tLastScaleTime:   hpa.Status.LastScaleTime,\n\t\tCurrentMetrics:  metricStatuses,\n\t\tConditions:      hpa.Status.Conditions,\n\t}\n\n\tif rescale {\n\t\tnow := metav1.NewTime(time.Now())\n\t\thpa.Status.LastScaleTime = &now\n\t}\n}", "category": "Python"}, {"instruction": "// getExistingChains get iptables-save output so we can check for existing chains and rules.\n// This will be a map of chain name to chain with rules as stored in iptables-save/iptables-restore\n// Result may SHARE memory with contents of buffer.", "input": "go language", "output": "func (proxier *Proxier) getExistingChains(buffer *bytes.Buffer, table utiliptables.Table) map[utiliptables.Chain][]byte {\n\tbuffer.Reset()\n\terr := proxier.iptables.SaveInto(table, buffer)\n\tif err != nil { // if we failed to get any rules\n\t\tklog.Errorf(\"Failed to execute iptables-save, syncing all rules: %v\", err)\n\t} else { // otherwise parse the output\n\t\treturn utiliptables.GetChainLines(table, buffer.Bytes())\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// This function sets limiters according to corresponding DeviceConfiguration", "input": "go language", "output": "func (lim *limiter) setLimitsLocked(device config.DeviceConfiguration) bool {\n\treadLimiter := lim.getReadLimiterLocked(device.DeviceID)\n\twriteLimiter := lim.getWriteLimiterLocked(device.DeviceID)\n\n\t// limiters for this device are created so we can store previous rates for logging\n\tpreviousReadLimit := readLimiter.Limit()\n\tpreviousWriteLimit := writeLimiter.Limit()\n\tcurrentReadLimit := rate.Limit(device.MaxRecvKbps) * 1024\n\tcurrentWriteLimit := rate.Limit(device.MaxSendKbps) * 1024\n\tif device.MaxSendKbps <= 0 {\n\t\tcurrentWriteLimit = rate.Inf\n\t}\n\tif device.MaxRecvKbps <= 0 {\n\t\tcurrentReadLimit = rate.Inf\n\t}\n\t// Nothing about this device has changed. Start processing next device\n\tif previousWriteLimit == currentWriteLimit && previousReadLimit == currentReadLimit {\n\t\treturn false\n\t}\n\n\treadLimiter.SetLimit(currentReadLimit)\n\twriteLimiter.SetLimit(currentWriteLimit)\n\n\treturn true\n}", "category": "Python"}, {"instruction": "// Load loads a directory of charts as if it were a repository.\n//\n// It requires the presence of an index.yaml file in the directory.", "input": "go language", "output": "func (r *ChartRepository) Load() error {\n\tdirInfo, err := os.Stat(r.Config.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !dirInfo.IsDir() {\n\t\treturn fmt.Errorf(\"%q is not a directory\", r.Config.Name)\n\t}\n\n\t// FIXME: Why are we recursively walking directories?\n\t// FIXME: Why are we not reading the repositories.yaml to figure out\n\t// what repos to use?\n\tfilepath.Walk(r.Config.Name, func(path string, f os.FileInfo, err error) error {\n\t\tif !f.IsDir() {\n\t\t\tif strings.Contains(f.Name(), \"-index.yaml\") {\n\t\t\t\ti, err := LoadIndexFile(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tr.IndexFile = i\n\t\t\t} else if strings.HasSuffix(f.Name(), \".tgz\") {\n\t\t\t\tr.ChartPaths = append(r.ChartPaths, path)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn nil\n}", "category": "Python"}, {"instruction": "// InstanceType returns the type of the specified instance.\n// Note that if the instance does not exist or is no longer running, we must return (\"\", cloudprovider.InstanceNotFound)\n// (Implementer Note): This is used by kubelet. Kubelet will label the node. Real log from kubelet:\n//       Adding node label from cloud provider: beta.kubernetes.io/instance-type=[value]", "input": "go language", "output": "func (az *Cloud) InstanceType(ctx context.Context, name types.NodeName) (string, error) {\n\t// Returns \"\" for unmanaged nodes because azure cloud provider couldn't fetch information for them.\n\tunmanaged, err := az.IsNodeUnmanaged(string(name))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif unmanaged {\n\t\tklog.V(4).Infof(\"InstanceType: omitting unmanaged node %q\", name)\n\t\treturn \"\", nil\n\t}\n\n\tif az.UseInstanceMetadata {\n\t\tmetadata, err := az.metadata.GetMetadata()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tif metadata.Compute == nil {\n\t\t\treturn \"\", fmt.Errorf(\"failure of getting instance metadata\")\n\t\t}\n\n\t\tisLocalInstance, err := az.isCurrentInstance(name, metadata.Compute.Name)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif isLocalInstance {\n\t\t\tif metadata.Compute.VMSize != \"\" {\n\t\t\t\treturn metadata.Compute.VMSize, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn az.vmSet.GetInstanceTypeByNodeName(string(name))\n}", "category": "Python"}, {"instruction": "// AddPreShutdownHook allows you to add a PreShutdownHook.", "input": "go language", "output": "func (s *GenericAPIServer) AddPreShutdownHook(name string, hook PreShutdownHookFunc) error {\n\tif len(name) == 0 {\n\t\treturn fmt.Errorf(\"missing name\")\n\t}\n\tif hook == nil {\n\t\treturn nil\n\t}\n\n\ts.preShutdownHookLock.Lock()\n\tdefer s.preShutdownHookLock.Unlock()\n\n\tif s.preShutdownHooksCalled {\n\t\treturn fmt.Errorf(\"unable to add %q because PreShutdownHooks have already been called\", name)\n\t}\n\tif _, exists := s.preShutdownHooks[name]; exists {\n\t\treturn fmt.Errorf(\"unable to add %q because it is already registered\", name)\n\t}\n\n\ts.preShutdownHooks[name] = preShutdownHookEntry{hook: hook}\n\n\treturn nil\n}", "category": "Python"}, {"instruction": "// setMessage sets info message(ERR_INSERT_INFO) generated by INSERT statement", "input": "go language", "output": "func (e *InsertExec) setMessage() {\n\tstmtCtx := e.ctx.GetSessionVars().StmtCtx\n\tnumRecords := stmtCtx.RecordRows()\n\tif e.SelectExec != nil || numRecords > 1 {\n\t\tnumWarnings := stmtCtx.WarningCount()\n\t\tvar numDuplicates uint64\n\t\tif stmtCtx.DupKeyAsWarning {\n\t\t\t// if ignoreErr\n\t\t\tnumDuplicates = numRecords - stmtCtx.CopiedRows()\n\t\t} else {\n\t\t\tif e.ctx.GetSessionVars().ClientCapability&mysql.ClientFoundRows > 0 {\n\t\t\t\tnumDuplicates = stmtCtx.TouchedRows()\n\t\t\t} else {\n\t\t\t\tnumDuplicates = stmtCtx.UpdatedRows()\n\t\t\t}\n\t\t}\n\t\tmsg := fmt.Sprintf(mysql.MySQLErrName[mysql.ErrInsertInfo], numRecords, numDuplicates, numWarnings)\n\t\tstmtCtx.SetMessage(msg)\n\t}\n}", "category": "Python"}, {"instruction": "// handleFromEnvFileSource adds the specified env file source information\n// into the provided secret", "input": "go language", "output": "func handleFromEnvFileSource(secret *v1.Secret, envFileSource string) error {\n\tinfo, err := os.Stat(envFileSource)\n\tif err != nil {\n\t\tswitch err := err.(type) {\n\t\tcase *os.PathError:\n\t\t\treturn fmt.Errorf(\"error reading %s: %v\", envFileSource, err.Err)\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"error reading %s: %v\", envFileSource, err)\n\t\t}\n\t}\n\tif info.IsDir() {\n\t\treturn fmt.Errorf(\"env secret file cannot be a directory\")\n\t}\n\n\treturn addFromEnvFile(envFileSource, func(key, value string) error {\n\t\treturn addKeyFromLiteralToSecret(secret, key, []byte(value))\n\t})\n}", "category": "Python"}, {"instruction": "//send the metrics to the DB", "input": "go language", "output": "func (r *reporter) save() error {\n\t//create a LevelDB Batch\n\tbatch := leveldb.Batch{}\n\t//for each metric in the registry (which is independent)...\n\tr.reg.Each(func(name string, i interface{}) {\n\t\tmetric, ok := i.(metrics.Counter)\n\t\tif ok {\n\t\t\t//assuming every metric here to be a Counter (separate registry)\n\t\t\t//...create a snapshot...\n\t\t\tms := metric.Snapshot()\n\t\t\tbyteVal := make([]byte, 8)\n\t\t\tbinary.BigEndian.PutUint64(byteVal, uint64(ms.Count()))\n\t\t\t//...and save the value to the DB\n\t\t\tbatch.Put([]byte(name), byteVal)\n\t\t}\n\t})\n\treturn r.db.Write(&batch, nil)\n}", "category": "Python"}, {"instruction": "// deocodeEIP1577ContentHash decodes a chain-stored content hash from an ENS record according to EIP-1577\n// a successful decode will result the different parts of the content hash in accordance to the CID spec\n// Note: only CIDv1 is supported", "input": "go language", "output": "func decodeEIP1577ContentHash(buf []byte) (storageNs, contentType, hashType, hashLength uint64, hash []byte, err error) {\n\tif len(buf) < 10 {\n\t\treturn 0, 0, 0, 0, nil, errors.New(\"buffer too short\")\n\t}\n\n\tstorageNs, n := binary.Uvarint(buf)\n\n\tbuf = buf[n:]\n\tvers, n := binary.Uvarint(buf)\n\n\tif vers != 1 {\n\t\treturn 0, 0, 0, 0, nil, fmt.Errorf(\"expected cid v1, got: %d\", vers)\n\t}\n\tbuf = buf[n:]\n\tcontentType, n = binary.Uvarint(buf)\n\n\tbuf = buf[n:]\n\thashType, n = binary.Uvarint(buf)\n\n\tbuf = buf[n:]\n\thashLength, n = binary.Uvarint(buf)\n\n\thash = buf[n:]\n\n\tif len(hash) != int(hashLength) {\n\t\treturn 0, 0, 0, 0, nil, errors.New(\"hash length mismatch\")\n\t}\n\treturn storageNs, contentType, hashType, hashLength, hash, nil\n}", "category": "Python"}, {"instruction": "// CreateOrUpdateLB invokes az.LoadBalancerClient.CreateOrUpdate with exponential backoff retry", "input": "go language", "output": "func (az *Cloud) CreateOrUpdateLB(service *v1.Service, lb network.LoadBalancer) error {\n\tif az.Config.shouldOmitCloudProviderBackoff() {\n\t\tctx, cancel := getContextWithCancel()\n\t\tdefer cancel()\n\n\t\tresp, err := az.LoadBalancerClient.CreateOrUpdate(ctx, az.ResourceGroup, *lb.Name, lb)\n\t\tklog.V(10).Infof(\"LoadBalancerClient.CreateOrUpdate(%s): end\", *lb.Name)\n\t\tif err == nil {\n\t\t\tif isSuccessHTTPResponse(resp) {\n\t\t\t\t// Invalidate the cache right after updating\n\t\t\t\taz.lbCache.Delete(*lb.Name)\n\t\t\t} else if resp != nil {\n\t\t\t\treturn fmt.Errorf(\"HTTP response %q\", resp.Status)\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\n\treturn az.createOrUpdateLBWithRetry(service, lb)\n}", "category": "Python"}, {"instruction": "// waitForMembershipStabilization waits for membership view to stabilize\n// or until a time limit expires, or until a peer declares itself as a leader", "input": "go language", "output": "func (le *leaderElectionSvcImpl) waitForMembershipStabilization(timeLimit time.Duration) {\n\tle.logger.Debug(le.id, \": Entering\")\n\tdefer le.logger.Debug(le.id, \": Exiting, peers found\", len(le.adapter.Peers()))\n\tendTime := time.Now().Add(timeLimit)\n\tviewSize := len(le.adapter.Peers())\n\tfor !le.shouldStop() {\n\t\ttime.Sleep(le.config.MembershipSampleInterval)\n\t\tnewSize := len(le.adapter.Peers())\n\t\tif newSize == viewSize || time.Now().After(endTime) || le.isLeaderExists() {\n\t\t\treturn\n\t\t}\n\t\tviewSize = newSize\n\t}\n}", "category": "Python"}, {"instruction": "// TODO: could this use the regular daemon PullImage ?", "input": "go language", "output": "func (i *ImageService) pullForBuilder(ctx context.Context, name string, authConfigs map[string]types.AuthConfig, output io.Writer, platform *specs.Platform) (*image.Image, error) {\n\tref, err := reference.ParseNormalizedNamed(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tref = reference.TagNameOnly(ref)\n\n\tpullRegistryAuth := &types.AuthConfig{}\n\tif len(authConfigs) > 0 {\n\t\t// The request came with a full auth config, use it\n\t\trepoInfo, err := i.registryService.ResolveRepository(ref)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tresolvedConfig := registry.ResolveAuthConfig(authConfigs, repoInfo.Index)\n\t\tpullRegistryAuth = &resolvedConfig\n\t}\n\n\tif err := i.pullImageWithReference(ctx, ref, platform, nil, pullRegistryAuth, output); err != nil {\n\t\treturn nil, err\n\t}\n\treturn i.GetImage(name)\n}", "category": "Python"}, {"instruction": "// dropDisabledRunAsGroupField removes disabled fields from PodSpec related\n// to RunAsGroup", "input": "go language", "output": "func dropDisabledRunAsGroupField(podSpec, oldPodSpec *api.PodSpec) {\n\tif !utilfeature.DefaultFeatureGate.Enabled(features.RunAsGroup) && !runAsGroupInUse(oldPodSpec) {\n\t\tif podSpec.SecurityContext != nil {\n\t\t\tpodSpec.SecurityContext.RunAsGroup = nil\n\t\t}\n\t\tfor i := range podSpec.Containers {\n\t\t\tif podSpec.Containers[i].SecurityContext != nil {\n\t\t\t\tpodSpec.Containers[i].SecurityContext.RunAsGroup = nil\n\t\t\t}\n\t\t}\n\t\tfor i := range podSpec.InitContainers {\n\t\t\tif podSpec.InitContainers[i].SecurityContext != nil {\n\t\t\t\tpodSpec.InitContainers[i].SecurityContext.RunAsGroup = nil\n\t\t\t}\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "// dial establishes the gRPC communication with the registered device plugin. https://godoc.org/google.golang.org/grpc#Dial", "input": "go language", "output": "func dial(unixSocketPath string) (pluginapi.DevicePluginClient, *grpc.ClientConn, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tc, err := grpc.DialContext(ctx, unixSocketPath, grpc.WithInsecure(), grpc.WithBlock(),\n\t\tgrpc.WithDialer(func(addr string, timeout time.Duration) (net.Conn, error) {\n\t\t\treturn net.DialTimeout(\"unix\", addr, timeout)\n\t\t}),\n\t)\n\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(errFailedToDialDevicePlugin+\" %v\", err)\n\t}\n\n\treturn pluginapi.NewDevicePluginClient(c), c, nil\n}", "category": "Python"}, {"instruction": "// ImageStatus returns the status of the image, returns nil if the image doesn't present.", "input": "go language", "output": "func (ds *dockerService) ImageStatus(_ context.Context, r *runtimeapi.ImageStatusRequest) (*runtimeapi.ImageStatusResponse, error) {\n\timage := r.GetImage()\n\n\timageInspect, err := ds.client.InspectImageByRef(image.Image)\n\tif err != nil {\n\t\tif libdocker.IsImageNotFoundError(err) {\n\t\t\treturn &runtimeapi.ImageStatusResponse{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\n\timageStatus, err := imageInspectToRuntimeAPIImage(imageInspect)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tres := runtimeapi.ImageStatusResponse{Image: imageStatus}\n\tif r.GetVerbose() {\n\t\tres.Info = imageInspect.Config.Labels\n\t}\n\treturn &res, nil\n}", "category": "Python"}, {"instruction": "// AuthMethodDelete deletes an auth method given its Name.", "input": "go language", "output": "func (a *ACL) AuthMethodDelete(methodName string, q *WriteOptions) (*WriteMeta, error) {\n\tif methodName == \"\" {\n\t\treturn nil, fmt.Errorf(\"Must specify a Name in Auth Method Delete\")\n\t}\n\n\tr := a.c.newRequest(\"DELETE\", \"/v1/acl/auth-method/\"+url.QueryEscape(methodName))\n\tr.setWriteOptions(q)\n\trtt, resp, err := requireOK(a.c.doRequest(r))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp.Body.Close()\n\n\twm := &WriteMeta{RequestTime: rtt}\n\treturn wm, nil\n}", "category": "Python"}, {"instruction": "// MakeFileFunc constructs a function that takes a file path and returns the\n// contents of that file, either directly as a string (where valid UTF-8 is\n// required) or as a string containing base64 bytes.", "input": "go language", "output": "func MakeFileFunc(baseDir string, encBase64 bool) function.Function {\n\treturn function.New(&function.Spec{\n\t\tParams: []function.Parameter{\n\t\t\t{\n\t\t\t\tName: \"path\",\n\t\t\t\tType: cty.String,\n\t\t\t},\n\t\t},\n\t\tType: function.StaticReturnType(cty.String),\n\t\tImpl: func(args []cty.Value, retType cty.Type) (cty.Value, error) {\n\t\t\tpath := args[0].AsString()\n\t\t\tsrc, err := readFileBytes(baseDir, path)\n\t\t\tif err != nil {\n\t\t\t\treturn cty.UnknownVal(cty.String), err\n\t\t\t}\n\n\t\t\tswitch {\n\t\t\tcase encBase64:\n\t\t\t\tenc := base64.StdEncoding.EncodeToString(src)\n\t\t\t\treturn cty.StringVal(enc), nil\n\t\t\tdefault:\n\t\t\t\tif !utf8.Valid(src) {\n\t\t\t\t\treturn cty.UnknownVal(cty.String), fmt.Errorf(\"contents of %s are not valid UTF-8; use the filebase64 function to obtain the Base64 encoded contents or the other file functions (e.g. filemd5, filesha256) to obtain file hashing results instead\", path)\n\t\t\t\t}\n\t\t\t\treturn cty.StringVal(string(src)), nil\n\t\t\t}\n\t\t},\n\t})\n}", "category": "Python"}, {"instruction": "// priorityClassPermittedInNamespace returns true if we allow the given priority class name in the\n// given namespace. It currently checks that system priorities are created only in the system namespace.", "input": "go language", "output": "func priorityClassPermittedInNamespace(priorityClassName string, namespace string) bool {\n\t// Only allow system priorities in the system namespace. This is to prevent abuse or incorrect\n\t// usage of these priorities. Pods created at these priorities could preempt system critical\n\t// components.\n\tfor _, spc := range scheduling.SystemPriorityClasses() {\n\t\tif spc.Name == priorityClassName && namespace != metav1.NamespaceSystem {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "category": "Python"}, {"instruction": "// newerObject checks the mutation cache for a newer object and returns one if found. If the\n// mutated object is older than the backing object, it is removed from the  Must be\n// called while the lock is held.", "input": "go language", "output": "func (c *mutationCache) newerObject(key string, backing runtime.Object) runtime.Object {\n\tmutatedObj, exists := c.mutationCache.Get(key)\n\tif !exists {\n\t\treturn backing\n\t}\n\tmutatedObjRuntime, ok := mutatedObj.(runtime.Object)\n\tif !ok {\n\t\treturn backing\n\t}\n\tif c.comparator.CompareResourceVersion(backing, mutatedObjRuntime) >= 0 {\n\t\tc.mutationCache.Remove(key)\n\t\treturn backing\n\t}\n\treturn mutatedObjRuntime\n}", "category": "Python"}, {"instruction": "// getRelease uses `system_profiler SPSoftwareDataType` to get OSX kernel version", "input": "go language", "output": "func getRelease() (string, error) {\n\tcmd := exec.Command(\"system_profiler\", \"SPSoftwareDataType\")\n\tosName, err := cmd.Output()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar release string\n\tdata := strings.Split(string(osName), \"\\n\")\n\tfor _, line := range data {\n\t\tif strings.Contains(line, \"Kernel Version\") {\n\t\t\t// It has the format like '      Kernel Version: Darwin 14.5.0'\n\t\t\tcontent := strings.SplitN(line, \":\", 2)\n\t\t\tif len(content) != 2 {\n\t\t\t\treturn \"\", fmt.Errorf(\"Kernel Version is invalid\")\n\t\t\t}\n\n\t\t\tprettyNames, err := shellwords.Parse(content[1])\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"Kernel Version is invalid: %s\", err.Error())\n\t\t\t}\n\n\t\t\tif len(prettyNames) != 2 {\n\t\t\t\treturn \"\", fmt.Errorf(\"Kernel Version needs to be 'Darwin x.x.x' \")\n\t\t\t}\n\t\t\trelease = prettyNames[1]\n\t\t}\n\t}\n\n\treturn release, nil\n}", "category": "Python"}, {"instruction": "// WARNING: If you're adding any return calls or defer any more work from this\n// function you have to make sure to update nodesInProcessing properly with the\n// disposition of the node when the work is done.", "input": "go language", "output": "func (r *rangeAllocator) AllocateOrOccupyCIDR(node *v1.Node) error {\n\tif node == nil {\n\t\treturn nil\n\t}\n\tif !r.insertNodeToProcessing(node.Name) {\n\t\tklog.V(2).Infof(\"Node %v is already in a process of CIDR assignment.\", node.Name)\n\t\treturn nil\n\t}\n\tif node.Spec.PodCIDR != \"\" {\n\t\treturn r.occupyCIDR(node)\n\t}\n\tpodCIDR, err := r.cidrs.AllocateNext()\n\tif err != nil {\n\t\tr.removeNodeFromProcessing(node.Name)\n\t\tnodeutil.RecordNodeStatusChange(r.recorder, node, \"CIDRNotAvailable\")\n\t\treturn fmt.Errorf(\"failed to allocate cidr: %v\", err)\n\t}\n\n\tklog.V(4).Infof(\"Putting node %s with CIDR %s into the work queue\", node.Name, podCIDR)\n\tr.nodeCIDRUpdateChannel <- nodeAndCIDR{\n\t\tnodeName: node.Name,\n\t\tcidr:     podCIDR,\n\t}\n\treturn nil\n}", "category": "Python"}, {"instruction": "// monitorResizeEvents spawns a goroutine that periodically gets the terminal size and tries to send\n// it to the resizeEvents channel if the size has changed. The goroutine stops when the stop channel\n// is closed.", "input": "go language", "output": "func monitorResizeEvents(fd uintptr, resizeEvents chan<- remotecommand.TerminalSize, stop chan struct{}) {\n\tgo func() {\n\t\tdefer runtime.HandleCrash()\n\n\t\tsize := GetSize(fd)\n\t\tif size == nil {\n\t\t\treturn\n\t\t}\n\t\tlastSize := *size\n\n\t\tfor {\n\t\t\t// see if we need to stop running\n\t\t\tselect {\n\t\t\tcase <-stop:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\tsize := GetSize(fd)\n\t\t\tif size == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif size.Height != lastSize.Height || size.Width != lastSize.Width {\n\t\t\t\tlastSize.Height = size.Height\n\t\t\t\tlastSize.Width = size.Width\n\t\t\t\tresizeEvents <- *size\n\t\t\t}\n\n\t\t\t// sleep to avoid hot looping\n\t\t\ttime.Sleep(250 * time.Millisecond)\n\t\t}\n\t}()\n}", "category": "Python"}, {"instruction": "// CreateLocalEtcdStaticPodManifestFile will write local etcd static pod manifest file.\n// This function is used by init - when the etcd cluster is empty - or by kubeadm\n// upgrade - when the etcd cluster is already up and running (and the --initial-cluster flag have no impact)", "input": "go language", "output": "func CreateLocalEtcdStaticPodManifestFile(manifestDir string, nodeName string, cfg *kubeadmapi.ClusterConfiguration, endpoint *kubeadmapi.APIEndpoint) error {\n\tif cfg.Etcd.External != nil {\n\t\treturn errors.New(\"etcd static pod manifest cannot be generated for cluster using external etcd\")\n\t}\n\t// gets etcd StaticPodSpec\n\tspec := GetEtcdPodSpec(cfg, endpoint, nodeName, []etcdutil.Member{})\n\n\t// writes etcd StaticPod to disk\n\tif err := staticpodutil.WriteStaticPodToDisk(kubeadmconstants.Etcd, manifestDir, spec); err != nil {\n\t\treturn err\n\t}\n\n\tklog.V(1).Infof(\"[etcd] wrote Static Pod manifest for a local etcd member to %q\\n\", kubeadmconstants.GetStaticPodFilepath(kubeadmconstants.Etcd, manifestDir))\n\treturn nil\n}", "category": "Python"}, {"instruction": "Determines the number of consecutive characters that are encodable using text compaction.\n\n@param msg      the message\n@param startpos the start position within the message\n@return the requested character count", "input": "Java", "output": "private static int determineConsecutiveTextCount(CharSequence msg, int startpos) {\n    int len = msg.length();\n    int idx = startpos;\n    while (idx < len) {\n      char ch = msg.charAt(idx);\n      int numericCount = 0;\n      while (numericCount < 13 && isDigit(ch) && idx < len) {\n        numericCount++;\n        idx++;\n        if (idx < len) {\n          ch = msg.charAt(idx);\n        }\n      }\n      if (numericCount >= 13) {\n        return idx - startpos - numericCount;\n      }\n      if (numericCount > 0) {\n        //Heuristic: All text-encodable chars or digits are binary encodable\n        continue;\n      }\n      ch = msg.charAt(idx);\n\n      //Check if character is encodable\n      if (!isText(ch)) {\n        break;\n      }\n      idx++;\n    }\n    return idx - startpos;\n  }", "category": "Python"}, {"instruction": "TODO hongjun: find table from parent select statement, should find table in subquery level only", "input": "Java", "output": "public static Optional<String> findTableName(final PredicateSegment predicateSegment, final SQLStatement sqlStatement, final ShardingTableMetaData shardingTableMetaData) {\n        if (!(sqlStatement instanceof SelectStatement)) {\n            return Optional.of(sqlStatement.getTables().getSingleTableName());\n        }\n        SelectStatement currentSelectStatement = (SelectStatement) sqlStatement;\n        while (null != currentSelectStatement.getParentStatement()) {\n            currentSelectStatement = currentSelectStatement.getParentStatement();\n            Optional<String> tableName = findTableName(predicateSegment, currentSelectStatement.getTables(), shardingTableMetaData);\n            if (tableName.isPresent()) {\n                return tableName;\n            }\n        }\n        return findTableName(predicateSegment, currentSelectStatement.getTables(), shardingTableMetaData);\n    }", "category": "Python"}, {"instruction": "Build output frame from the multi-column results", "input": "Java", "output": "public static Frame buildOutput(int[] gbCols, int noutCols, Frame fr, String[] fcnames, int ngrps, MRTask mrfill) {\n\n    // Build the output!\n    // the names of columns\n    final int nCols = gbCols.length + noutCols;\n    String[] names = new String[nCols];\n    String[][] domains = new String[nCols][];\n    byte[] types = new byte[nCols];\n    for (int i = 0; i < gbCols.length; i++) {\n      names[i] = fr.name(gbCols[i]);\n      domains[i] = fr.domains()[gbCols[i]];\n      types[i] = fr.vec(names[i]).get_type();\n    }\n    for (int i = 0; i < fcnames.length; i++) {\n      names[i + gbCols.length] = fcnames[i];\n      types[i + gbCols.length] = Vec.T_NUM;\n    }\n    Vec v = Vec.makeZero(ngrps); // dummy layout vec\n    // Convert the output arrays into a Frame, also doing the post-pass work\n    Frame f =  mrfill.doAll(types, new Frame(v)).outputFrame(names, domains);\n    v.remove();\n    return f;\n  }", "category": "Python"}, {"instruction": "Sends the registration information of {@link InstanceInfo} receiving by\nthis node to the peer node represented by this class.\n\n@param info\nthe instance information {@link InstanceInfo} of any instance\nthat is send to this instance.\n@throws Exception", "input": "Java", "output": "public void register(final InstanceInfo info) throws Exception {\n        long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);\n        batchingDispatcher.process(\n                taskId(\"register\", info),\n                new InstanceReplicationTask(targetHost, Action.Register, info, null, true) {\n                    public EurekaHttpResponse<Void> execute() {\n                        return replicationClient.register(info);\n                    }\n                },\n                expiryTime\n        );\n    }", "category": "Python"}, {"instruction": "Inserts the given object into the current buffer. This method returns a pointer that\ncan be used to address the written record in this partition.\n\n@param record The object to be written to the partition.\n@return A pointer to the object in the partition.\n@throws IOException Thrown when the write failed.", "input": "Java", "output": "public final long appendRecord(T record) throws IOException {\n\t\tlong pointer = this.writeView.getCurrentPointer();\n\t\ttry {\n\t\t\tthis.serializer.serialize(record, this.writeView);\n\t\t\tthis.recordCounter++;\n\t\t\treturn pointer;\n\t\t} catch (EOFException e) {\n\t\t\t// we ran out of pages. \n\t\t\t// first, reset the pages and then we need to trigger a compaction\n\t\t\t//int oldCurrentBuffer = \n\t\t\tthis.writeView.resetTo(pointer);\n\t\t\t//for (int bufNum = this.partitionPages.size() - 1; bufNum > oldCurrentBuffer; bufNum--) {\n\t\t\t//\tthis.availableMemory.addMemorySegment(this.partitionPages.remove(bufNum));\n\t\t\t//}\n\t\t\tthrow e;\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Start the slot pool to accept RPC calls.\n\n@param jobMasterId The necessary leader id for running the job.\n@param newJobManagerAddress for the slot requests which are sent to the resource manager\n@param componentMainThreadExecutor The main thread executor for the job master's main thread.", "input": "Java", "output": "public void start(\n\t\t@Nonnull JobMasterId jobMasterId,\n\t\t@Nonnull String newJobManagerAddress,\n\t\t@Nonnull ComponentMainThreadExecutor componentMainThreadExecutor) throws Exception {\n\n\t\tthis.jobMasterId = jobMasterId;\n\t\tthis.jobManagerAddress = newJobManagerAddress;\n\t\tthis.componentMainThreadExecutor = componentMainThreadExecutor;\n\n\t\tscheduleRunAsync(this::checkIdleSlot, idleSlotTimeout);\n\n\t\tif (log.isDebugEnabled()) {\n\t\t\tscheduleRunAsync(this::scheduledLogStatus, STATUS_LOG_INTERVAL_MS, TimeUnit.MILLISECONDS);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "\u5176\u4e2d\u4e00\u4e2a\u96c6\u5408\u5728\u53e6\u4e00\u4e2a\u96c6\u5408\u4e2d\u662f\u5426\u81f3\u5c11\u5305\u542b\u4e00\u4e2a\u5143\u7d20\uff0c\u65e2\u662f\u4e24\u4e2a\u96c6\u5408\u662f\u5426\u81f3\u5c11\u6709\u4e00\u4e2a\u5171\u540c\u7684\u5143\u7d20\n\n@param coll1 \u96c6\u54081\n@param coll2 \u96c6\u54082\n@return \u5176\u4e2d\u4e00\u4e2a\u96c6\u5408\u5728\u53e6\u4e00\u4e2a\u96c6\u5408\u4e2d\u662f\u5426\u81f3\u5c11\u5305\u542b\u4e00\u4e2a\u5143\u7d20\n@since 2.1\n@see #intersection", "input": "Java", "output": "public static boolean containsAny(Collection<?> coll1, Collection<?> coll2) {\r\n\t\tif (isEmpty(coll1) || isEmpty(coll2)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (coll1.size() < coll2.size()) {\r\n\t\t\tfor (Object object : coll1) {\r\n\t\t\t\tif (coll2.contains(object)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (Object object : coll2) {\r\n\t\t\t\tif (coll1.contains(object)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}", "category": "Python"}, {"instruction": "Generates a new Key Hash that is immediately after the given one. We define Key Hash H2 to be immediately after\nKey Hash h1 if there doesn't exist Key Hash H3 such that H1&lt;H3&lt;H2. The ordering is performed using {@link UUID#compareTo}.\n\n@return The successor Key Hash, or null if no more successors are available (if {@link IteratorState#isEnd} returns true).", "input": "Java", "output": "static UUID getNextHash(UUID hash) {\n        if (hash == null) {\n            // No hash given. By definition, the first hash is the \"next\" one\".\n            hash = MIN_HASH;\n        } else if (hash.compareTo(MAX_HASH) >= 0) {\n            // Given hash already equals or exceeds the max value. There is no successor.\n            return null;\n        }\n\n        long msb = hash.getMostSignificantBits();\n        long lsb = hash.getLeastSignificantBits();\n        if (lsb == Long.MAX_VALUE) {\n            msb++; // This won't overflow since we've checked that state is not end (i.e., id != MAX).\n            lsb = Long.MIN_VALUE;\n        } else {\n            lsb++;\n        }\n\n        return new UUID(msb, lsb);\n    }", "category": "Python"}, {"instruction": "{@inheritDoc}", "input": "Java", "output": "@Override\r\n  public int size()\r\n  {\r\n    if (size < 0) {\r\n      size = 0;\r\n      for (int i = 0; i <= lastWordIndex; i++) {\r\n        int w = words[i];\r\n        if (isLiteral(w)) {\r\n          size += getLiteralBitCount(w);\r\n        } else {\r\n          if (isZeroSequence(w)) {\r\n            if (!isSequenceWithNoBits(w)) {\r\n              size++;\r\n            }\r\n          } else {\r\n            size += maxLiteralLengthMultiplication(getSequenceCount(w) + 1);\r\n            if (!isSequenceWithNoBits(w)) {\r\n              size--;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return size;\r\n  }", "category": "Python"}, {"instruction": "Formats the string as {@link #format(String, Object...)}, but instead of failing on illegal format, returns the\nconcatenated format string and format arguments. Should be used for unimportant formatting like logging,\nexception messages, typically not directly.", "input": "Java", "output": "public static String nonStrictFormat(String message, Object... formatArgs)\n  {\n    if (formatArgs == null || formatArgs.length == 0) {\n      return message;\n    }\n    try {\n      return String.format(Locale.ENGLISH, message, formatArgs);\n    }\n    catch (IllegalFormatException e) {\n      StringBuilder bob = new StringBuilder(message);\n      for (Object formatArg : formatArgs) {\n        bob.append(\"; \").append(formatArg);\n      }\n      return bob.toString();\n    }\n  }", "category": "Python"}, {"instruction": "Enables the usage export feature and sets the usage export bucket where reports are stored. If\nyou provide an empty request body using this method, the usage export feature will be disabled.\n\n<p>Sample code:\n\n<pre><code>\ntry (ProjectClient projectClient = ProjectClient.create()) {\nProjectName project = ProjectName.of(\"[PROJECT]\");\nUsageExportLocation usageExportLocationResource = UsageExportLocation.newBuilder().build();\nOperation response = projectClient.setUsageExportBucketProject(project.toString(), usageExportLocationResource);\n}\n</code></pre>\n\n@param project Project ID for this request.\n@param usageExportLocationResource The location in Cloud Storage and naming method of the daily\nusage report. Contains bucket_name and report_name prefix.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation setUsageExportBucketProject(\n      String project, UsageExportLocation usageExportLocationResource) {\n\n    SetUsageExportBucketProjectHttpRequest request =\n        SetUsageExportBucketProjectHttpRequest.newBuilder()\n            .setProject(project)\n            .setUsageExportLocationResource(usageExportLocationResource)\n            .build();\n    return setUsageExportBucketProject(request);\n  }", "category": "Python"}, {"instruction": "Create describe parser instance.\n\n@param dbType database type\n@param shardingRule databases and tables sharding rule\n@param lexerEngine lexical analysis engine.\n@return describe parser instance", "input": "Java", "output": "public static AbstractDescribeParser newInstance(final DatabaseType dbType, final ShardingRule shardingRule, final LexerEngine lexerEngine) {\n        switch (dbType) {\n            case H2:\n            case MySQL:\n                return new MySQLDescribeParser(shardingRule, lexerEngine);\n            default:\n                throw new UnsupportedOperationException(String.format(\"Cannot support database [%s].\", dbType));\n        }\n    }", "category": "Python"}, {"instruction": "truncate\u64cd\u4f5c\n\n@param config", "input": "Java", "output": "private void truncate(BatchExecutor batchExecutor, MappingConfig config) throws SQLException {\n        DbMapping dbMapping = config.getDbMapping();\n        StringBuilder sql = new StringBuilder();\n        sql.append(\"TRUNCATE TABLE \").append(SyncUtil.getDbTableName(dbMapping));\n        batchExecutor.execute(sql.toString(), new ArrayList<>());\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Truncate target table, sql: {}\", sql);\n        }\n    }", "category": "Python"}, {"instruction": "Produce ticket.\n\n@param <T>                  the type parameter\n@param ticketGrantingTicket the ticket granting ticket\n@param service              the service\n@param credentialProvided   the credential provided\n@param ticketId             the ticket id\n@param clazz                the clazz\n@return the ticket", "input": "Java", "output": "protected <T extends Ticket> T produceTicket(final TicketGrantingTicket ticketGrantingTicket,\n                                                 final Service service,\n                                                 final boolean credentialProvided,\n                                                 final String ticketId,\n                                                 final Class<T> clazz) {\n        val expirationPolicyToUse = determineExpirationPolicyForService(service);\n\n        val result = ticketGrantingTicket.grantServiceTicket(\n            ticketId,\n            service,\n            expirationPolicyToUse,\n            credentialProvided,\n            trackMostRecentSession);\n\n        if (!clazz.isAssignableFrom(result.getClass())) {\n            throw new ClassCastException(\"Result [\" + result\n                + \" is of type \" + result.getClass()\n                + \" when we were expecting \" + clazz);\n        }\n        return (T) result;\n    }", "category": "Python"}, {"instruction": "Find all resources that match the given location pattern via the\nAnt-style PathMatcher. Supports resources in jar files and zip files\nand in the file system.\n\n@param locationPattern the location pattern to match\n@return the result as Resource array\n@throws IOException in case of I/O errors\n@see #doFindPathMatchingJarResources\n@see #doFindPathMatchingFileResources", "input": "Java", "output": "@SuppressWarnings(\"MagicNumber\")\n    protected Resource[] findPathMatchingResources(String locationPattern) throws IOException {\n        String rootDirPath = determineRootDir(locationPattern);\n        String subPattern = locationPattern.substring(rootDirPath.length());\n        Resource[] rootDirResources = getResources(rootDirPath);\n        Set<Resource> result = new LinkedHashSet<Resource>(16);\n        for (Resource rootDirResource : rootDirResources) {\n            rootDirResource = resolveRootDirResource(rootDirResource);\n            if (isJarResource(rootDirResource)) {\n                result.addAll(doFindPathMatchingJarResources(rootDirResource, subPattern));\n            } else {\n                result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));\n            }\n        }\n        return result.toArray(new Resource[0]);\n    }", "category": "Python"}, {"instruction": "Creates a {@code MAIL} request.", "input": "Java", "output": "public static SmtpRequest mail(CharSequence sender, CharSequence... mailParameters) {\n        if (mailParameters == null || mailParameters.length == 0) {\n            return new DefaultSmtpRequest(SmtpCommand.MAIL,\n                                          sender != null ? \"FROM:<\" + sender + '>' : FROM_NULL_SENDER);\n        } else {\n            List<CharSequence> params = new ArrayList<CharSequence>(mailParameters.length + 1);\n            params.add(sender != null? \"FROM:<\" + sender + '>' : FROM_NULL_SENDER);\n            for (CharSequence param : mailParameters) {\n                params.add(param);\n            }\n            return new DefaultSmtpRequest(SmtpCommand.MAIL, params);\n        }\n    }", "category": "Python"}, {"instruction": "See https://api.slack.com/methods/rtm.start.", "input": "Java", "output": "public RtmStartResponse rtmStart(String accessToken) throws IOException {\n    HttpUrl url = baseUrl.newBuilder(\"rtm.start\")\n        .addQueryParameter(\"token\", accessToken)\n        .build();\n    Request request = new Request.Builder()\n        .url(url)\n        .build();\n    Call call = httpClient.newCall(request);\n    try (Response response = call.execute()) {\n      JsonAdapter<RtmStartResponse> jsonAdapter = moshi.adapter(RtmStartResponse.class);\n      return jsonAdapter.fromJson(response.body().source());\n    }\n  }", "category": "Python"}, {"instruction": "function defines the last dispatched time comparator.\n\n@param weight weight of the comparator.", "input": "Java", "output": "private static FactorComparator<Executor> getLstDispatchedTimeComparator(final int weight) {\n    return FactorComparator\n        .create(LSTDISPATCHED_COMPARATOR_NAME, weight, new Comparator<Executor>() {\n\n          @Override\n          public int compare(final Executor o1, final Executor o2) {\n            final ExecutorInfo stat1 = o1.getExecutorInfo();\n            final ExecutorInfo stat2 = o2.getExecutorInfo();\n\n            final int result = 0;\n            if (statisticsObjectCheck(stat1, stat2, LSTDISPATCHED_COMPARATOR_NAME)) {\n              return result;\n            }\n            // Note: an earlier date time indicates higher weight.\n            return ((Long) stat2.getLastDispatchedTime()).compareTo(stat1.getLastDispatchedTime());\n          }\n        });\n  }", "category": "Python"}, {"instruction": "Add a {@link ChannelPromise} to this {@link ChannelFlushPromiseNotifier} which will be notified after the given\n{@code pendingDataSize} was reached.", "input": "Java", "output": "public ChannelFlushPromiseNotifier add(ChannelPromise promise, long pendingDataSize) {\n        if (promise == null) {\n            throw new NullPointerException(\"promise\");\n        }\n        checkPositiveOrZero(pendingDataSize, \"pendingDataSize\");\n        long checkpoint = writeCounter + pendingDataSize;\n        if (promise instanceof FlushCheckpoint) {\n            FlushCheckpoint cp = (FlushCheckpoint) promise;\n            cp.flushCheckpoint(checkpoint);\n            flushCheckpoints.add(cp);\n        } else {\n            flushCheckpoints.add(new DefaultFlushCheckpoint(checkpoint, promise));\n        }\n        return this;\n    }", "category": "Python"}, {"instruction": "Open a file for reading OR writing. The {@link FileChannel} that is returned will only allow\nreads or writes depending on the {@link OpenOption}s that are specified. If any of the\nfollowing have been specified, the {@link FileChannel} will be write-only: {@link\nStandardOpenOption#CREATE}\n\n<ul>\n<li>{@link StandardOpenOption#CREATE}\n<li>{@link StandardOpenOption#CREATE_NEW}\n<li>{@link StandardOpenOption#WRITE}\n<li>{@link StandardOpenOption#TRUNCATE_EXISTING}\n</ul>\n\nIn all other cases the {@link FileChannel} will be read-only.\n\n@param path The path to the file to open or create\n@param options The options specifying how the file should be opened, and whether the {@link\nFileChannel} should be read-only or write-only.\n@param attrs (not supported, the values will be ignored)\n@throws IOException", "input": "Java", "output": "@Override\n  public FileChannel newFileChannel(\n      Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n    checkNotNull(path);\n    initStorage();\n    CloudStorageUtil.checkNotNullArray(attrs);\n    if (options.contains(StandardOpenOption.CREATE_NEW)) {\n      Files.createFile(path, attrs);\n    } else if (options.contains(StandardOpenOption.CREATE) && !Files.exists(path)) {\n      Files.createFile(path, attrs);\n    }\n    if (options.contains(StandardOpenOption.WRITE)\n        || options.contains(StandardOpenOption.CREATE)\n        || options.contains(StandardOpenOption.CREATE_NEW)\n        || options.contains(StandardOpenOption.TRUNCATE_EXISTING)) {\n      return new CloudStorageWriteFileChannel(newWriteChannel(path, options));\n    } else {\n      return new CloudStorageReadFileChannel(newReadChannel(path, options));\n    }\n  }", "category": "Python"}, {"instruction": "Once-per-node shared init", "input": "Java", "output": "@Override public void setupLocal( ) {\n    // Init all the internal tree fields after shipping over the wire\n    _tree.init_tree();\n    // Allocate local shared memory histograms\n    for( int l=_leaf; l<_tree._len; l++ ) {\n      DTree.UndecidedNode udn = _tree.undecided(l);\n      DHistogram hs[] = _hcs[l-_leaf];\n      int sCols[] = udn._scoreCols;\n      if( sCols != null ) { // Sub-selecting just some columns?\n        for( int col : sCols ) // For tracked cols\n          hs[col].init();\n      } else {                 // Else all columns\n        for( int j=0; j<_ncols; j++) // For all columns\n          if( hs[j] != null )        // Tracking this column?\n            hs[j].init();\n      }\n    }\n  }", "category": "Python"}, {"instruction": "cancel given delegation token", "input": "Java", "output": "public void cancelDelegationToken(String delegationToken) throws HiveSQLException {\n    if (saslServer == null) {\n      throw new HiveSQLException(\n          \"Delegation token only supported over kerberos authentication\", \"08S01\");\n    }\n    try {\n      saslServer.cancelDelegationToken(delegationToken);\n    } catch (IOException e) {\n      throw new HiveSQLException(\n          \"Error canceling delegation token \" + delegationToken, \"08S01\", e);\n    }\n  }", "category": "Python"}, {"instruction": "\u68c0\u67e5\u76ee\u6807\u7c7b\u662f\u5426\u53ef\u4ee5\u4ece\u539f\u7c7b\u8f6c\u5316<br>\n\u8f6c\u5316\u5305\u62ec\uff1a<br>\n1\u3001\u539f\u7c7b\u662f\u5bf9\u8c61\uff0c\u76ee\u6807\u7c7b\u578b\u662f\u539f\u7c7b\u578b\u5b9e\u73b0\u7684\u63a5\u53e3<br>\n2\u3001\u76ee\u6807\u7c7b\u578b\u662f\u539f\u7c7b\u578b\u7684\u7236\u7c7b<br>\n3\u3001\u4e24\u8005\u662f\u539f\u59cb\u7c7b\u578b\u6216\u8005\u5305\u88c5\u7c7b\u578b\uff08\u76f8\u4e92\u8f6c\u6362\uff09\n\n@param targetType \u76ee\u6807\u7c7b\u578b\n@param sourceType \u539f\u7c7b\u578b\n@return \u662f\u5426\u53ef\u8f6c\u5316", "input": "Java", "output": "public static boolean isAssignable(Class<?> targetType, Class<?> sourceType) {\r\n\t\tif (null == targetType || null == sourceType) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// \u5bf9\u8c61\u7c7b\u578b\r\n\t\tif (targetType.isAssignableFrom(sourceType)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// \u57fa\u672c\u7c7b\u578b\r\n\t\tif (targetType.isPrimitive()) {\r\n\t\t\t// \u539f\u59cb\u7c7b\u578b\r\n\t\t\tClass<?> resolvedPrimitive = BasicType.wrapperPrimitiveMap.get(sourceType);\r\n\t\t\tif (resolvedPrimitive != null && targetType.equals(resolvedPrimitive)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// \u5305\u88c5\u7c7b\u578b\r\n\t\t\tClass<?> resolvedWrapper = BasicType.primitiveWrapperMap.get(sourceType);\r\n\t\t\tif (resolvedWrapper != null && targetType.isAssignableFrom(resolvedWrapper)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}", "category": "Python"}, {"instruction": "{@inheritDoc}\nGets the remote ip from the request, and invokes spnego if it isn't filtered.\n\n@param context the request context\n@return {@link #yes()} if spnego should be invoked and ip isn't filtered,\n{@link #no()} otherwise.", "input": "Java", "output": "@Override\n    protected Event doExecute(final RequestContext context) {\n        val remoteIp = getRemoteIp(context);\n        LOGGER.debug(\"Current user IP [{}]\", remoteIp);\n        if (shouldDoSpnego(remoteIp)) {\n            LOGGER.info(\"Spnego should be activated for [{}]\", remoteIp);\n            return yes();\n        }\n        LOGGER.info(\"Spnego should is skipped for [{}]\", remoteIp);\n        return no();\n    }", "category": "Python"}, {"instruction": "check uniqueness of dependency type and params", "input": "Java", "output": "private void validateDepDefinitionUniqueness(final List<FlowTriggerDependency> dependencies) {\n    final Set<String> seen = new HashSet<>();\n    for (final FlowTriggerDependency dep : dependencies) {\n      final Map<String, String> props = dep.getProps();\n      // set.add() returns false when there exists duplicate\n      Preconditions.checkArgument(seen.add(dep.getType() + \":\" + props.toString()), String.format\n          (\"duplicate dependency config %s found, dependency config should be unique\",\n              dep.getName()));\n    }\n  }", "category": "Python"}, {"instruction": "Handle SLO Redirect profile request.\n\n@param response the response\n@param request  the request\n@throws Exception the exception", "input": "Java", "output": "@GetMapping(path = SamlIdPConstants.ENDPOINT_SAML2_SLO_PROFILE_REDIRECT)\n    protected void handleSaml2ProfileSLOPostRequest(final HttpServletResponse response,\n                                                    final HttpServletRequest request) throws Exception {\n        val decoder = getSamlProfileHandlerConfigurationContext().getSamlMessageDecoders().getInstance(HttpMethod.GET);\n        handleSloProfileRequest(response, request, decoder);\n    }", "category": "Python"}, {"instruction": "-----------------------------------------------------------------------", "input": "Java", "output": "private static StringBuilder simpleQuote(final StringBuilder sb, final String value) {\n\t\tfor (int i = 0; i < value.length(); ++i) {\n\t\t\tfinal char c = value.charAt(i);\n\t\t\tswitch (c) {\n\t\t\t\tcase '\\\\':\n\t\t\t\tcase '^':\n\t\t\t\tcase '$':\n\t\t\t\tcase '.':\n\t\t\t\tcase '|':\n\t\t\t\tcase '?':\n\t\t\t\tcase '*':\n\t\t\t\tcase '+':\n\t\t\t\tcase '(':\n\t\t\t\tcase ')':\n\t\t\t\tcase '[':\n\t\t\t\tcase '{':\n\t\t\t\t\tsb.append('\\\\');\n\t\t\t\tdefault:\n\t\t\t\t\tsb.append(c);\n\t\t\t}\n\t\t}\n\t\treturn sb;\n\t}", "category": "Python"}, {"instruction": "Creates a Graph from CSV input with vertex values and edge values.\nThe vertex values are specified through a vertices input file or a user-defined map function.\n\n@param vertexKey the type of the vertex IDs\n@param vertexValue the type of the vertex values\n@param edgeValue the type of the edge values\n@return a Graph with vertex and edge values.", "input": "Java", "output": "@SuppressWarnings(\"unchecked\")\n\tpublic <K, VV, EV> Graph<K, VV, EV> types(Class<K> vertexKey, Class<VV> vertexValue,\n\t\t\tClass<EV> edgeValue) {\n\n\t\tif (edgeReader == null) {\n\t\t\tthrow new RuntimeException(\"The edge input file cannot be null!\");\n\t\t}\n\n\t\tDataSet<Tuple3<K, K, EV>> edges = edgeReader.types(vertexKey, vertexKey, edgeValue);\n\n\t\t// the vertex value can be provided by an input file or a user-defined mapper\n\t\tif (vertexReader != null) {\n\t\t\tDataSet<Tuple2<K, VV>> vertices = vertexReader\n\t\t\t\t.types(vertexKey, vertexValue)\n\t\t\t\t\t.name(GraphCsvReader.class.getName());\n\n\t\t\treturn Graph.fromTupleDataSet(vertices, edges, executionContext);\n\t\t}\n\t\telse if (mapper != null) {\n\t\t\treturn Graph.fromTupleDataSet(edges, (MapFunction<K, VV>) mapper, executionContext);\n\t\t}\n\t\telse {\n\t\t\tthrow new RuntimeException(\"Vertex values have to be specified through a vertices input file\"\n\t\t\t\t\t+ \"or a user-defined map function.\");\n\t\t}\n\t}", "category": "Python"}, {"instruction": "make sure it now goes looking for that block index.", "input": "Java", "output": "private void ensureFetching(long blockIndex) {\n    if (fetching != null) {\n      if (fetching.futureBuf.isDone()) {\n        full.add(fetching);\n        fetching = null;\n      } else {\n        return;\n      }\n    }\n    for (WorkUnit w : full) {\n      if (w.blockIndex == blockIndex) {\n        return;\n      }\n    }\n    if (full.size() < BUF_COUNT) {\n      fetching = new WorkUnit(chan, bufSize, blockIndex);\n    } else {\n      // reuse the oldest full buffer\n      fetching = full.remove(0);\n      fetching.resetForIndex(blockIndex);\n    }\n    bytesRead += bufSize;\n    fetching.futureBuf = exec.submit(fetching);\n  }", "category": "Python"}, {"instruction": "Execute the specified TransformProcess with the given <i>sequence</i> input data<br>\nNote: this method can only be used if the TransformProcess starts with sequence data, and also returns sequence data\n\n@param inputSequence    Input sequence data to process\n@param transformProcess TransformProcess to execute\n@return Processed (non-sequential) data", "input": "Java", "output": "public static List<List<List<Writable>>> executeSequenceToSequence(List<List<List<Writable>>> inputSequence,\n                                                                       TransformProcess transformProcess) {\n        if (!(transformProcess.getFinalSchema() instanceof SequenceSchema)) {\n            List<List<List<Writable>>> ret = new ArrayList<>(inputSequence.size());\n            for(List<List<Writable>> timeStep : inputSequence) {\n                ret.add(execute(timeStep,null, transformProcess).getFirst());\n            }\n\n            return ret;\n        }\n\n        return execute(null, inputSequence, transformProcess).getSecond();\n    }", "category": "Python"}, {"instruction": "Create a metric registry configuration object from the given {@link Configuration}.\n\n@param configuration to generate the metric registry configuration from\n@return Metric registry configuration generated from the configuration", "input": "Java", "output": "public static MetricRegistryConfiguration fromConfiguration(Configuration configuration) {\n\t\tScopeFormats scopeFormats;\n\t\ttry {\n\t\t\tscopeFormats = ScopeFormats.fromConfig(configuration);\n\t\t} catch (Exception e) {\n\t\t\tLOG.warn(\"Failed to parse scope format, using default scope formats\", e);\n\t\t\tscopeFormats = ScopeFormats.fromConfig(new Configuration());\n\t\t}\n\n\t\tchar delim;\n\t\ttry {\n\t\t\tdelim = configuration.getString(MetricOptions.SCOPE_DELIMITER).charAt(0);\n\t\t} catch (Exception e) {\n\t\t\tLOG.warn(\"Failed to parse delimiter, using default delimiter.\", e);\n\t\t\tdelim = '.';\n\t\t}\n\n\t\tfinal long maximumFrameSize = AkkaRpcServiceUtils.extractMaximumFramesize(configuration);\n\n\t\t// padding to account for serialization overhead\n\t\tfinal long messageSizeLimitPadding = 256;\n\n\t\treturn new MetricRegistryConfiguration(scopeFormats, delim, maximumFrameSize - messageSizeLimitPadding);\n\t}", "category": "Python"}, {"instruction": "Handles entropy injection across regular and entropy-aware file systems.\n\n<p>If the given file system is entropy-aware (a implements {@link EntropyInjectingFileSystem}),\nthen this method replaces the entropy marker in the path with random characters.\nThe entropy marker is defined by {@link EntropyInjectingFileSystem#getEntropyInjectionKey()}.\n\n<p>If the given file system does not implement {@code EntropyInjectingFileSystem},\nthen this method delegates to {@link FileSystem#create(Path, WriteMode)} and\nreturns the same path in the resulting {@code OutputStreamAndPath}.", "input": "Java", "output": "public static OutputStreamAndPath createEntropyAware(\n\t\t\tFileSystem fs,\n\t\t\tPath path,\n\t\t\tWriteMode writeMode) throws IOException {\n\n\t\t// check and possibly inject entropy into the path\n\t\tfinal EntropyInjectingFileSystem efs = getEntropyFs(fs);\n\t\tfinal Path processedPath = efs == null ? path : resolveEntropy(path, efs, true);\n\n\t\t// create the stream on the original file system to let the safety net\n\t\t// take its effect\n\t\tfinal FSDataOutputStream out = fs.create(processedPath, writeMode);\n\t\treturn new OutputStreamAndPath(out, processedPath);\n\t}", "category": "Python"}, {"instruction": "/* (non-Javadoc)\n@see org.parosproxy.paros.db.paros.TableContext#deleteAllDataForContextAndType(int, int)", "input": "Java", "output": "@Override\r\n\tpublic synchronized void deleteAllDataForContextAndType(int contextId, int type) throws DatabaseException {\r\n    \tSqlPreparedStatementWrapper psDeleteAllDataForContextAndType = null;\r\n    \ttry {\r\n        \tpsDeleteAllDataForContextAndType = DbSQL.getSingleton().getPreparedStatement(\"context.ps.deletealldataforcontexttype\");\r\n\t\t\tpsDeleteAllDataForContextAndType.getPs().setInt(1, contextId);\r\n\t\t\tpsDeleteAllDataForContextAndType.getPs().setInt(2, type);\r\n\t\t\tpsDeleteAllDataForContextAndType.getPs().executeUpdate();\r\n\t\t} catch (SQLException e) {\r\n\t\t\tthrow new DatabaseException(e);\r\n\t\t} finally {\r\n\t\t\tDbSQL.getSingleton().releasePreparedStatement(psDeleteAllDataForContextAndType);\r\n\t\t}\r\n    }", "category": "Python"}, {"instruction": "this method shouldn't be called from user", "input": "Java", "output": "@Deprecated\n    void addSublist(JFXListView<?> subList, int index) {\n        if (!sublistsProperty.get().contains(subList)) {\n            sublistsProperty.get().add(subList);\n            sublistsIndices.put(index, subList);\n            subList.getSelectionModel().selectedIndexProperty().addListener((o, oldVal, newVal) -> {\n                if (newVal.intValue() != -1) {\n                    updateOverAllSelectedIndex();\n                }\n            });\n        }\n    }", "category": "Python"}, {"instruction": "Converts a Flink application status enum to a YARN application status enum.\n@param status The Flink application status.\n@return The corresponding YARN application status.", "input": "Java", "output": "private FinalApplicationStatus getYarnStatus(ApplicationStatus status) {\n\t\tif (status == null) {\n\t\t\treturn FinalApplicationStatus.UNDEFINED;\n\t\t}\n\t\telse {\n\t\t\tswitch (status) {\n\t\t\t\tcase SUCCEEDED:\n\t\t\t\t\treturn FinalApplicationStatus.SUCCEEDED;\n\t\t\t\tcase FAILED:\n\t\t\t\t\treturn FinalApplicationStatus.FAILED;\n\t\t\t\tcase CANCELED:\n\t\t\t\t\treturn FinalApplicationStatus.KILLED;\n\t\t\t\tdefault:\n\t\t\t\t\treturn FinalApplicationStatus.UNDEFINED;\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Print values in a nice format, e.g. (1, 2, 3)\n\n@param start the beginning of the values, e.g. \"(\"\n@param separator the separator of values, e.g. \", \"\n@param end the end of the values, e.g. \")\"\n@param values the values to print\n\n@return neatly formatted value list", "input": "Java", "output": "public static String printValues(String start, String separator, String end, Iterator<?> values) {\n        if(start == null){\n            start = \"(\";\n        }\n        if (separator == null){\n            separator = \",\";\n        }\n        if (end == null){\n            end = \")\";\n        }\n\n        StringBuilder sb = new StringBuilder(start);\n        while(values.hasNext()) {\n            sb.append(print(values.next()));\n            if (values.hasNext()) {\n                sb.append(separator);\n            }\n        }\n        return sb.append(end).toString();\n    }", "category": "Python"}, {"instruction": "Inherited.", "input": "Java", "output": "public InputStream readProtectedResource(URL url, OAuthConsumerToken accessToken, String httpMethod) throws OAuthRequestFailedException {\n    if (accessToken == null) {\n      throw new OAuthRequestFailedException(\"A valid access token must be supplied.\");\n    }\n\n    ProtectedResourceDetails resourceDetails = getProtectedResourceDetailsService().loadProtectedResourceDetailsById(accessToken.getResourceId());\n    if ((!resourceDetails.isAcceptsAuthorizationHeader()) && !\"POST\".equalsIgnoreCase(httpMethod) && !\"PUT\".equalsIgnoreCase(httpMethod)) {\n      throw new IllegalArgumentException(\"Protected resource \" + resourceDetails.getId() + \" cannot be accessed with HTTP method \" +\n        httpMethod + \" because the OAuth provider doesn't accept the OAuth Authorization header.\");\n    }\n\n    return readResource(resourceDetails, url, httpMethod, accessToken, resourceDetails.getAdditionalParameters(), null);\n  }", "category": "Python"}, {"instruction": "Handle registered service loaded event.\n\n@param event the event", "input": "Java", "output": "@EventListener\n    public void handleRegisteredServicesLoadedEvent(final CasRegisteredServicesLoadedEvent event) {\n        event.getServices()\n            .stream()\n            .filter(OidcRegisteredService.class::isInstance)\n            .forEach(s -> {\n                LOGGER.trace(\"Attempting to reconcile scopes and attributes for service [{}] of type [{}]\",\n                    s.getServiceId(), s.getClass().getSimpleName());\n                this.scopeToAttributesFilter.reconcile(s);\n            });\n    }", "category": "Python"}, {"instruction": "\u5408\u5e76pipeline\u53c2\u6570\u8bbe\u7f6e", "input": "Java", "output": "public void merge(PipelineParameter pipelineParameter) {\n        try {\n            Field[] fields = this.getClass().getDeclaredFields();\n            for (int i = 0; i < fields.length; i++) {\n                Field field = fields[i];\n                // Skip static and final fields.\n                if (Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers())) {\n                    continue;\n                }\n\n                ReflectionUtils.makeAccessible(field);\n                Object srcValue = field.get(pipelineParameter);\n                if (srcValue != null) { // \u5ffd\u7565null\u503c\n                    field.set(this, srcValue);\n                }\n            }\n        } catch (Exception e) {\n            // ignore\n        }\n    }", "category": "Python"}, {"instruction": "Initialize the logging system according to preferences expressed through the\n{@link Environment} and the classpath.\n@param environment the environment\n@param classLoader the classloader", "input": "Java", "output": "protected void initialize(ConfigurableEnvironment environment,\n\t\t\tClassLoader classLoader) {\n\t\tnew LoggingSystemProperties(environment).apply();\n\t\tLogFile logFile = LogFile.get(environment);\n\t\tif (logFile != null) {\n\t\t\tlogFile.applyToSystemProperties();\n\t\t}\n\t\tinitializeEarlyLoggingLevel(environment);\n\t\tinitializeSystem(environment, this.loggingSystem, logFile);\n\t\tinitializeFinalLoggingLevels(environment, this.loggingSystem);\n\t\tregisterShutdownHookIfNecessary(environment, this.loggingSystem);\n\t}", "category": "Python"}, {"instruction": "Accepts submission from the configuration page.", "input": "Java", "output": "@RequirePOST\n    public synchronized void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        BulkChange bc = new BulkChange(this);\n        try {\n            checkPermission(ADMINISTER);\n\n            JSONObject json = req.getSubmittedForm();\n\n            systemMessage = Util.nullify(req.getParameter(\"system_message\"));\n\n            boolean result = true;\n            for (Descriptor<?> d : Functions.getSortedDescriptorsForGlobalConfigUnclassified())\n                result &= configureDescriptor(req,json,d);\n            \n            save();\n            updateComputerList();\n            if(result)\n                FormApply.success(req.getContextPath()+'/').generateResponse(req, rsp, null);\n            else\n                FormApply.success(\"configure\").generateResponse(req, rsp, null);    // back to config\n        } finally {\n            bc.commit();\n        }\n    }", "category": "Python"}, {"instruction": "TODO duplicated elsewhere", "input": "Java", "output": "private static void assertNoIncompatibleAnnotations(Class<? extends Annotation> annotation,\n                                                        Field field,\n                                                        Class<? extends Annotation>... undesiredAnnotations) {\n        for (Class<? extends Annotation> u : undesiredAnnotations) {\n            if (field.isAnnotationPresent(u)) {\n                throw unsupportedCombinationOfAnnotations(annotation.getSimpleName(),\n                                                          u.getSimpleName());\n            }\n        }\n    }", "category": "Python"}, {"instruction": "\u7ed3\u679c\u7684\u6761\u76ee\u6570\n@param conn \u6570\u636e\u5e93\u8fde\u63a5\u5bf9\u8c61\n@param where \u67e5\u8be2\u6761\u4ef6\n@return \u590d\u5408\u6761\u4ef6\u7684\u7ed3\u679c\u6570\n@throws SQLException SQL\u6267\u884c\u5f02\u5e38", "input": "Java", "output": "public int count(Connection conn, Entity where) throws SQLException {\r\n\t\tcheckConn(conn);\r\n\t\t\r\n\t\tfinal Query query = new Query(SqlUtil.buildConditions(where), where.getTableName());\r\n\t\tPreparedStatement ps = null;\r\n\t\ttry {\r\n\t\t\tps = dialect.psForCount(conn, query);\r\n\t\t\treturn SqlExecutor.query(ps, new NumberHandler()).intValue();\r\n\t\t} catch (SQLException e) {\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\tDbUtil.close(ps);\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "Set the trainingListeners for the ComputationGraph (and all layers in the network)", "input": "Java", "output": "public void setListeners(TrainingListener... listeners) {\n        List<TrainingListener> list = new ArrayList<>();\n        //Check: user might have done setListeners(null) thinking this would clear the current listeners.\n        //This results in an TrainingListener[1] with a single null value -> results in a NPE later\n        if (listeners != null && listeners.length > 0) {\n            for (TrainingListener i : listeners) {\n                if (i != null)\n                    list.add(i);\n            }\n        }\n        setListeners(list);\n    }", "category": "Python"}, {"instruction": "Converts a parameters to type arguments.\n@param parameters The parameters\n@return The type arguments", "input": "Java", "output": "@NotNull\n    protected Map<String, Object> toParameterTypes(ParameterElement... parameters) {\n        final LinkedHashMap<String, Object> map = new LinkedHashMap<>(parameters.length);\n        for (ParameterElement ce : parameters) {\n            final ClassElement type = ce.getType();\n            if (type == null) {\n                continue;\n            }\n            final Type typeReference = getTypeForElement(type);\n            map.put(ce.getName(), typeReference);\n        }\n\n        return map;\n    }", "category": "Python"}, {"instruction": "Returns all blocking result partitions whose receivers can be scheduled/updated.", "input": "Java", "output": "List<IntermediateResultPartition> finishAllBlockingPartitions() {\n\t\tList<IntermediateResultPartition> finishedBlockingPartitions = null;\n\n\t\tfor (IntermediateResultPartition partition : resultPartitions.values()) {\n\t\t\tif (partition.getResultType().isBlocking() && partition.markFinished()) {\n\t\t\t\tif (finishedBlockingPartitions == null) {\n\t\t\t\t\tfinishedBlockingPartitions = new LinkedList<IntermediateResultPartition>();\n\t\t\t\t}\n\n\t\t\t\tfinishedBlockingPartitions.add(partition);\n\t\t\t}\n\t\t}\n\n\t\tif (finishedBlockingPartitions == null) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\telse {\n\t\t\treturn finishedBlockingPartitions;\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Attempt to cancel job", "input": "Java", "output": "@Override public final boolean cancel( boolean mayInterruptIfRunning ) {\n    boolean did = false;\n    synchronized(this) {        // Install the answer under lock\n      if( !isCancelled() ) {\n        did = true;             // Did cancel (was not cancelled already)\n        _target.taskRemove(_tasknum);\n        _target = null;         // Flag as canceled\n//        UDPTimeOutThread.PENDING.remove(this);\n      }\n      notifyAll();              // notify in any case\n    }\n    return did;\n  }", "category": "Python"}, {"instruction": "\u8f6c\u6362\u4e3aProperties\u5bf9\u8c61\uff0c\u539f\u5206\u7ec4\u53d8\u4e3a\u524d\u7f00\n\n@return Properties\u5bf9\u8c61", "input": "Java", "output": "public Properties toProperties() {\r\n\t\tfinal Properties properties = new Properties();\r\n\t\tString group;\r\n\t\tfor (Entry<String, LinkedHashMap<String, String>> groupEntry : this.groupedMap.entrySet()) {\r\n\t\t\tgroup = groupEntry.getKey();\r\n\t\t\tfor (Entry<String, String> entry : groupEntry.getValue().entrySet()) {\r\n\t\t\t\tproperties.setProperty(StrUtil.isEmpty(group) ? entry.getKey() : group + CharUtil.DOT + entry.getKey(), entry.getValue());\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn properties;\r\n\t}", "category": "Python"}, {"instruction": "Calculate the ratio of similarity between 2 strings using LCS\n\n@param strA the first String\n@param strB the second String\n@return the percentage  double number", "input": "Java", "output": "public double getMatchRatio(String strA, String strB) {\n        if (strA == null && strB == null) {\n            return MAX_RATIO;\n            \n        } else if (strA == null || strB == null) {\n            return MIN_RATIO;\n        }\n        \n        if (strA.isEmpty() && strB.isEmpty()) {\n            return MAX_RATIO;\n            \n        } else if (strA.isEmpty() || strB.isEmpty()) {\n            return MIN_RATIO;\n        }\n                \n        //get the percentage match against the longer of the 2 strings\n        return (double)getLCS(strA, strB).length() / Math.max(strA.length(), strB.length());\n    }", "category": "Python"}, {"instruction": "Sign the given content using this Algorithm instance.\n\n@param headerBytes an array of bytes representing the base64 encoded header content to be verified against the signature.\n@param payloadBytes an array of bytes representing the base64 encoded payload content to be verified against the signature.\n@return the signature in a base64 encoded array of bytes\n@throws SignatureGenerationException if the Key is invalid.", "input": "Java", "output": "public byte[] sign(byte[] headerBytes, byte[] payloadBytes) throws SignatureGenerationException {\n    \t// default implementation; keep around until sign(byte[]) method is removed\n    \tbyte[] contentBytes = new byte[headerBytes.length + 1 + payloadBytes.length];\n    \t\n    \tSystem.arraycopy(headerBytes, 0, contentBytes, 0, headerBytes.length);\n    \tcontentBytes[headerBytes.length] = (byte)'.';\n    \tSystem.arraycopy(payloadBytes, 0, contentBytes, headerBytes.length + 1, payloadBytes.length);\n    \t\n    \treturn sign(contentBytes);\n    }", "category": "Python"}, {"instruction": "finds any stages for a dashboard that aren't mapped.\n@param dashboard\n@return a list of deploy PipelineStages that are not mapped", "input": "Java", "output": "private List<PipelineStage> findUnmappedStages(Dashboard dashboard,List<PipelineStage> pipelineStageList){\n        List<PipelineStage> unmappedStages = new ArrayList<>();\n\n        Map<PipelineStage, String> stageToEnvironmentNameMap = PipelineUtils.getStageToEnvironmentNameMap(dashboard);\n\n        for (PipelineStage systemStage : pipelineStageList) {\n            if (PipelineStageType.DEPLOY.equals(systemStage.getType())) {\n                String mappedName = stageToEnvironmentNameMap.get(systemStage);\n                if (mappedName == null || mappedName.isEmpty()) {\n                    unmappedStages.add(systemStage);\n                }\n            }\n        }\n\n        return unmappedStages;\n    }", "category": "Python"}, {"instruction": "Delete registered service.\n\n@param id the id\n@return the registered service", "input": "Java", "output": "@DeleteOperation(produces = {ActuatorMediaType.V2_JSON, \"application/vnd.cas.services+yaml\", MediaType.APPLICATION_JSON_VALUE})\n    public RegisteredService deleteService(@Selector final String id) {\n        if (NumberUtils.isDigits(id)) {\n            val svc = this.servicesManager.findServiceBy(Long.parseLong(id));\n            if (svc != null) {\n                return this.servicesManager.delete(svc);\n            }\n        } else {\n            val svc = this.servicesManager.findServiceBy(id);\n            if (svc != null) {\n                return this.servicesManager.delete(svc);\n            }\n        }\n        LOGGER.warn(\"Could not locate service definition by id [{}]\", id);\n        return null;\n    }", "category": "Python"}, {"instruction": "Return the absolute temp dir for given web server.\n@param prefix server name\n@return the temp dir for given server.", "input": "Java", "output": "protected final File createTempDir(String prefix) {\n\t\ttry {\n\t\t\tFile tempDir = File.createTempFile(prefix + \".\", \".\" + getPort());\n\t\t\ttempDir.delete();\n\t\t\ttempDir.mkdir();\n\t\t\ttempDir.deleteOnExit();\n\t\t\treturn tempDir;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new WebServerException(\n\t\t\t\t\t\"Unable to create tempDir. java.io.tmpdir is set to \"\n\t\t\t\t\t\t\t+ System.getProperty(\"java.io.tmpdir\"),\n\t\t\t\t\tex);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "\u4ececontent\u4e2d\u5339\u914d\u51fa\u591a\u4e2a\u503c\u5e76\u6839\u636etemplate\u751f\u6210\u65b0\u7684\u5b57\u7b26\u4e32<br>\n\u4f8b\u5982\uff1a<br>\ncontent 2013\u5e745\u6708 pattern (.*?)\u5e74(.*?)\u6708 template\uff1a $1-$2 return 2013-5\n\n@param pattern \u5339\u914d\u6b63\u5219\n@param content \u88ab\u5339\u914d\u7684\u5185\u5bb9\n@param template \u751f\u6210\u5185\u5bb9\u6a21\u677f\uff0c\u53d8\u91cf $1 \u8868\u793agroup1\u7684\u5185\u5bb9\uff0c\u4ee5\u6b64\u7c7b\u63a8\n@return \u65b0\u5b57\u7b26\u4e32", "input": "Java", "output": "public static String extractMulti(Pattern pattern, CharSequence content, String template) {\r\n\t\tif (null == content || null == pattern || null == template) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t//\u63d0\u53d6\u6a21\u677f\u4e2d\u7684\u7f16\u53f7\r\n\t\tfinal TreeSet<Integer> varNums = new TreeSet<>(new Comparator<Integer>() {\r\n\t\t\t@Override\r\n\t\t\tpublic int compare(Integer o1, Integer o2) {\r\n\t\t\t\treturn ObjectUtil.compare(o2, o1);\r\n\t\t\t}\r\n\t\t});\r\n\t\tfinal Matcher matcherForTemplate = PatternPool.GROUP_VAR.matcher(template);\r\n\t\twhile (matcherForTemplate.find()) {\r\n\t\t\tvarNums.add(Integer.parseInt(matcherForTemplate.group(1)));\r\n\t\t}\r\n\r\n\t\tfinal Matcher matcher = pattern.matcher(content);\r\n\t\tif (matcher.find()) {\r\n\t\t\tfor (Integer group : varNums) {\r\n\t\t\t\ttemplate = template.replace(\"$\" + group, matcher.group(group));\r\n\t\t\t}\r\n\t\t\treturn template;\r\n\t\t}\r\n\t\treturn null;\r\n\t}", "category": "Python"}, {"instruction": "\u6267\u884c\u6bd4\u8f83<br>\n\u6309\u7167\u6bd4\u8f83\u5668\u94fe\u7684\u987a\u5e8f\u5206\u522b\u6bd4\u8f83\uff0c\u5982\u679c\u6bd4\u8f83\u51fa\u76f8\u7b49\u5219\u8f6c\u5411\u4e0b\u4e00\u4e2a\u6bd4\u8f83\u5668\uff0c\u5426\u5219\u76f4\u63a5\u8fd4\u56de\n\n@param o1 \u7b2c\u4e00\u4e2a\u5bf9\u8c61\n@param o2 \u7b2c\u4e8c\u4e2a\u5bf9\u8c61\n@return -1, 0, or 1\n@throws UnsupportedOperationException \u5982\u679c\u6bd4\u8f83\u5668\u94fe\u4e3a\u7a7a\uff0c\u65e0\u6cd5\u5b8c\u6210\u6bd4\u8f83", "input": "Java", "output": "@Override\r\n\tpublic int compare(final E o1, final E o2) throws UnsupportedOperationException {\r\n\t\tif (lock == false) {\r\n\t\t\tcheckChainIntegrity();\r\n\t\t\tlock = true;\r\n\t\t}\r\n\t\t\r\n\t\tfinal Iterator<Comparator<E>> comparators = chain.iterator();\r\n\t\tComparator<? super E> comparator;\r\n\t\tint retval;\r\n\t\tfor (int comparatorIndex = 0; comparators.hasNext(); ++comparatorIndex) {\r\n\t\t\tcomparator = comparators.next();\r\n\t\t\tretval = comparator.compare(o1, o2);\r\n\t\t\tif (retval != 0) {\r\n\t\t\t\t// invert the order if it is a reverse sort\r\n\t\t\t\tif (true == orderingBits.get(comparatorIndex)) {\r\n\t\t\t\t\tretval = (retval > 0) ? -1 : 1;\r\n\t\t\t\t}\r\n\t\t\t\treturn retval;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if comparators are exhausted, return 0\r\n\t\treturn 0;\r\n\t}", "category": "Python"}, {"instruction": "@param req HTTP request\n\n@return serialized user map", "input": "Java", "output": "@GET\n  @Path(\"/db/{authenticatorName}/cachedSerializedUserMap\")\n  @Produces(SmileMediaTypes.APPLICATION_JACKSON_SMILE)\n  @Consumes(MediaType.APPLICATION_JSON)\n  @ResourceFilters(BasicSecurityResourceFilter.class)\n  public Response getCachedSerializedUserMap(\n      @Context HttpServletRequest req,\n      @PathParam(\"authenticatorName\") final String authenticatorName\n  )\n  {\n    return handler.getCachedSerializedUserMap(authenticatorName);\n  }", "category": "Python"}, {"instruction": "Decodes a byte from the final Run-Length Encoding stage, pulling a new byte from the\nBurrows-Wheeler Transform stage when required.\n@return The decoded byte, or -1 if there are no more bytes", "input": "Java", "output": "public int read() {\n        while (rleRepeat < 1) {\n            if (bwtBytesDecoded == bwtBlockLength) {\n                return -1;\n            }\n\n            int nextByte = decodeNextBWTByte();\n            if (nextByte != rleLastDecodedByte) {\n                // New byte, restart accumulation\n                rleLastDecodedByte = nextByte;\n                rleRepeat = 1;\n                rleAccumulator = 1;\n                crc.updateCRC(nextByte);\n            } else {\n                if (++rleAccumulator == 4) {\n                    // Accumulation complete, start repetition\n                    int rleRepeat = decodeNextBWTByte() + 1;\n                    this.rleRepeat = rleRepeat;\n                    rleAccumulator = 0;\n                    crc.updateCRC(nextByte, rleRepeat);\n                } else {\n                    rleRepeat = 1;\n                    crc.updateCRC(nextByte);\n                }\n            }\n        }\n        rleRepeat--;\n\n        return rleLastDecodedByte;\n    }", "category": "Python"}, {"instruction": "\u7528\u4e8eChannel\u7684\u914d\u7f6e\u5f3a\u5236\u63a8\u9001\n\n@param channelId\n@param status\n@throws WebxException", "input": "Java", "output": "public void doNotify(@Param(\"pageIndex\") int pageIndex, @Param(\"searchKey\") String searchKey,\n                         @Param(\"channelId\") Long channelId, @Param(\"status\") String status, Navigator nav)\n                                                                                                           throws WebxException {\n\n        channelService.notifyChannel(channelId);\n        nav.redirectToLocation(\"channelList.htm?pageIndex=\" + pageIndex + \"&searchKey=\" + urlEncode(searchKey));\n    }", "category": "Python"}, {"instruction": "Parse string as key-value string and return the value matches key name.\nexample:\nkeyvalue('k1=v1;k2=v2', ';', '=', 'k2') = 'v2'\nkeyvalue('k1:v1,k2:v2', ',', ':', 'k3') = NULL\n\n@param str     target string.\n@param pairSeparator  separator between key-value tuple.\n@param kvSeparator  separator between key and value.\n@param keyName name of the key whose value you want return.\n@return target value.", "input": "Java", "output": "public static BinaryString keyValue(\n\t\tBinaryString str, BinaryString pairSeparator, BinaryString kvSeparator, BinaryString keyName) {\n\t\tif (str == null || str.getSizeInBytes() == 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (pairSeparator != null && pairSeparator.getSizeInBytes() == 1 &&\n\t\t\tkvSeparator != null && kvSeparator.getSizeInBytes() == 1) {\n\t\t\treturn str.keyValue(pairSeparator.getByte(0), kvSeparator.getByte(0), keyName);\n\t\t} else {\n\t\t\treturn BinaryString.fromString(\n\t\t\t\tkeyValue(\n\t\t\t\t\tBinaryString.safeToString(str),\n\t\t\t\t\tBinaryString.safeToString(pairSeparator),\n\t\t\t\t\tBinaryString.safeToString(kvSeparator),\n\t\t\t\t\tBinaryString.safeToString(keyName)));\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Replicates all ASG status changes to peer eureka nodes except for\nreplication traffic to this node.", "input": "Java", "output": "private void replicateASGInfoToReplicaNodes(final String asgName,\n                                                final ASGStatus newStatus, final PeerEurekaNode node) {\n        CurrentRequestVersion.set(Version.V2);\n        try {\n            node.statusUpdate(asgName, newStatus);\n        } catch (Throwable e) {\n            logger.error(\"Cannot replicate ASG status information to {}\", node.getServiceUrl(), e);\n        }\n    }", "category": "Python"}, {"instruction": "Returns a future holding the serialized request result.\n\n@param jobId                     JobID of the job the queryable state\nbelongs to\n@param queryableStateName        Name under which the state is queryable\n@param keyHashCode               Integer hash code of the key (result of\na call to {@link Object#hashCode()}\n@param serializedKeyAndNamespace Serialized key and namespace to query\nKvState instance with\n@return Future holding the serialized result", "input": "Java", "output": "private CompletableFuture<KvStateResponse> getKvState(\n\t\t\tfinal JobID jobId,\n\t\t\tfinal String queryableStateName,\n\t\t\tfinal int keyHashCode,\n\t\t\tfinal byte[] serializedKeyAndNamespace) {\n\t\tLOG.debug(\"Sending State Request to {}.\", remoteAddress);\n\t\ttry {\n\t\t\tKvStateRequest request = new KvStateRequest(jobId, queryableStateName, keyHashCode, serializedKeyAndNamespace);\n\t\t\treturn client.sendRequest(remoteAddress, request);\n\t\t} catch (Exception e) {\n\t\t\tLOG.error(\"Unable to send KVStateRequest: \", e);\n\t\t\treturn FutureUtils.getFailedFuture(e);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Attempts to convert the publisher to the given type.\n\n@param object The object to convert\n@param publisherType The publisher type\n@param <T> The generic type\n@return The Resulting in publisher", "input": "Java", "output": "public static <T> T convertPublisher(Object object, Class<T> publisherType) {\n        Objects.requireNonNull(object, \"Invalid argument [object]: \" + object);\n        Objects.requireNonNull(object, \"Invalid argument [publisherType]: \" + publisherType);\n        if (object instanceof CompletableFuture) {\n            @SuppressWarnings(\"unchecked\") Publisher<T> futurePublisher = (Publisher<T>) Publishers.fromCompletableFuture(() -> ((CompletableFuture) object));\n            return ConversionService.SHARED.convert(futurePublisher, publisherType)\n                    .orElseThrow(() -> new IllegalArgumentException(\"Unsupported Reactive type: \" + object.getClass()));\n        } else {\n            return ConversionService.SHARED.convert(object, publisherType)\n                    .orElseThrow(() -> new IllegalArgumentException(\"Unsupported Reactive type: \" + object.getClass()));\n        }\n    }", "category": "Python"}, {"instruction": "Parse the given request, resolving its multipart elements.\n\n@param request the request to parse.\n\n@return the parsing result.\n\n@throws MultipartException if multipart resolution failed.", "input": "Java", "output": "private MultipartParsingResult parseRequest(HttpRequest request) throws MultipartException {\n        String encoding = determineEncoding(request);\n        FileUpload fileUpload = prepareFileUpload(encoding);\n        try {\n            RequestBody body = request.getBody();\n            Assert.notNull(body, \"The body cannot be null.\");\n            List<FileItem> fileItems = fileUpload.parseRequest(new BodyContext(body));\n            return parseFileItems(fileItems, encoding);\n        } catch (FileUploadBase.SizeLimitExceededException ex) {\n            throw new MaxUploadSizeExceededException(fileUpload.getSizeMax(), ex);\n        } catch (FileUploadBase.FileSizeLimitExceededException ex) {\n            throw new MaxUploadSizeExceededException(fileUpload.getFileSizeMax(), ex);\n        } catch (FileUploadException ex) {\n            throw new MultipartException(\"Failed to parse multipart servlet request.\", ex);\n        }\n    }", "category": "Python"}, {"instruction": "Returns a substring of this.\n@param start the position of first code point\n@param until the position after last code point, exclusive.", "input": "Java", "output": "public UTF8String substring(final int start, final int until) {\n    if (until <= start || start >= numBytes) {\n      return EMPTY_UTF8;\n    }\n\n    int i = 0;\n    int c = 0;\n    while (i < numBytes && c < start) {\n      i += numBytesForFirstByte(getByte(i));\n      c += 1;\n    }\n\n    int j = i;\n    while (i < numBytes && c < until) {\n      i += numBytesForFirstByte(getByte(i));\n      c += 1;\n    }\n\n    if (i > j) {\n      byte[] bytes = new byte[i - j];\n      copyMemory(base, offset + j, bytes, BYTE_ARRAY_OFFSET, i - j);\n      return fromBytes(bytes);\n    } else {\n      return EMPTY_UTF8;\n    }\n  }", "category": "Python"}, {"instruction": "Lookup words in text\n\n@param text  text to look up user dictionary matches for\n@return list of UserDictionaryMatch, not null", "input": "Java", "output": "public List<UserDictionaryMatch> findUserDictionaryMatches(String text) {\n        List<UserDictionaryMatch> matchInfos = new ArrayList<>();\n        int startIndex = 0;\n\n        while (startIndex < text.length()) {\n            int matchLength = 0;\n\n            while (startIndex + matchLength < text.length()\n                            && entries.containsKeyPrefix(text.substring(startIndex, startIndex + matchLength + 1))) {\n                matchLength++;\n            }\n\n            if (matchLength > 0) {\n                String match = text.substring(startIndex, startIndex + matchLength);\n                int[] details = entries.get(match);\n\n                if (details != null) {\n                    matchInfos.addAll(makeMatchDetails(startIndex, details));\n                }\n            }\n\n            startIndex++;\n        }\n\n        return matchInfos;\n    }", "category": "Python"}, {"instruction": "Sets the maximum size of the page.\n<p>\nIf the given maximum size is greater than the current maximum size a new page will be loaded, otherwise the current page\nwill be shrunk to meet the given maximum size. In both cases the {@code TableModelListener} will be notified of the\nchange.\n</p>\n<p>\nThe call to this method has no effect if the given maximum size is equal to the current maximum size.\n</p>\n\n@param maxPageSize the new maximum page size\n@throws IllegalArgumentException if {@code maxPageSize} is negative or zero.\n@see #setMaxPageSizeWithoutPageChanges(int)\n@see TableModelListener", "input": "Java", "output": "public void setMaxPageSize(final int maxPageSize) {\n\t\tif (maxPageSize <= 0) {\n\t\t\tthrow new IllegalArgumentException(\"Parameter maxPageSize must be greater than zero.\");\n\t\t}\n\t\tif (this.maxPageSize == maxPageSize) {\n\t\t\treturn;\n\t\t}\n\t\tint oldMaxPageSize = this.maxPageSize;\n\t\tsetMaxPageSizeWithoutPageChanges(maxPageSize);\n\n\t\tint rowCount = getRowCount();\n\t\tif (rowCount > 0) {\n\t\t\tif (maxPageSize > oldMaxPageSize) {\n\t\t\t\tschedule(dataOffset);\n\t\t\t} else if (data.size() > maxPageSize) {\n\t\t\t\tfinal List<T> shrunkData = data.subList(0, maxPageSize);\n\n\t\t\t\tEventQueue.invokeLater(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tsetData(dataOffset, new ArrayList<>(shrunkData));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t}", "category": "Python"}, {"instruction": "\u83b7\u53d6\u4e00\u4e0bbinlog format\u683c\u5f0f", "input": "Java", "output": "private void loadBinlogFormat() {\n        ResultSetPacket rs = null;\n        try {\n            rs = query(\"show variables like 'binlog_format'\");\n        } catch (IOException e) {\n            throw new CanalParseException(e);\n        }\n\n        List<String> columnValues = rs.getFieldValues();\n        if (columnValues == null || columnValues.size() != 2) {\n            logger.warn(\"unexpected binlog format query result, this may cause unexpected result, so throw exception to request network to io shutdown.\");\n            throw new IllegalStateException(\"unexpected binlog format query result:\" + rs.getFieldValues());\n        }\n\n        binlogFormat = BinlogFormat.valuesOf(columnValues.get(1));\n        if (binlogFormat == null) {\n            throw new IllegalStateException(\"unexpected binlog format query result:\" + rs.getFieldValues());\n        }\n    }", "category": "Python"}, {"instruction": "Loads the persisted version of each process definition and set values on the in-memory\nversion to be consistent.", "input": "Java", "output": "protected void makeProcessDefinitionsConsistentWithPersistedVersions(ParsedDeployment parsedDeployment) {\n        for (ProcessDefinitionEntity processDefinition : parsedDeployment.getAllProcessDefinitions()) {\n            ProcessDefinitionEntity persistedProcessDefinition =\n                    bpmnDeploymentHelper.getPersistedInstanceOfProcessDefinition(processDefinition);\n\n            if (persistedProcessDefinition != null) {\n                processDefinition.setId(persistedProcessDefinition.getId());\n                processDefinition.setVersion(persistedProcessDefinition.getVersion());\n                processDefinition.setSuspensionState(persistedProcessDefinition.getSuspensionState());\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Build credential for metadata signature validation basic credential.\n\n@param resource the resource\n@return the basic credential\n@throws Exception the exception", "input": "Java", "output": "public static BasicCredential buildCredentialForMetadataSignatureValidation(final Resource resource) throws Exception {\n        try {\n            val x509FactoryBean = new BasicX509CredentialFactoryBean();\n            x509FactoryBean.setCertificateResource(resource);\n            x509FactoryBean.afterPropertiesSet();\n            return x509FactoryBean.getObject();\n        } catch (final Exception e) {\n            LOGGER.trace(e.getMessage(), e);\n\n            LOGGER.debug(\"Credential cannot be extracted from [{}] via X.509. Treating it as a public key to locate credential...\", resource);\n            val credentialFactoryBean = new BasicResourceCredentialFactoryBean();\n            credentialFactoryBean.setPublicKeyInfo(resource);\n            credentialFactoryBean.afterPropertiesSet();\n            return credentialFactoryBean.getObject();\n        }\n    }", "category": "Python"}, {"instruction": "Transport has active streams. Start sending keepalives if necessary.", "input": "Java", "output": "public synchronized void onTransportActive() {\n    if (state == State.IDLE) {\n      // When the transport goes active, we do not reset the nextKeepaliveTime. This allows us to\n      // quickly check whether the connection is still working.\n      state = State.PING_SCHEDULED;\n      if (pingFuture == null) {\n        pingFuture = scheduler.schedule(\n            sendPing,\n            keepAliveTimeInNanos - stopwatch.elapsed(TimeUnit.NANOSECONDS),\n            TimeUnit.NANOSECONDS);\n      }\n    } else if (state == State.IDLE_AND_PING_SENT) {\n      state = State.PING_SENT;\n    } // Other states are possible when keepAliveDuringTransportIdle == true\n  }", "category": "Python"}, {"instruction": "Generate an alert when a security issue (risk/info) is found. Custom\nalert name, description and solution will be used.\n\n@param risk the risk of the new alert\n@param confidence the confidence of the new alert\n@param name the name of the new alert\n@param description the description of the new alert\n@param uri the affected URI\n@param param the name/ID of the affected parameter\n@param attack the attack that shows the issue\n@param otherInfo other information about the issue\n@param solution the solution for the issue\n@param evidence the evidence (in the response) that shows the issue\n@param msg the message that shows the issue", "input": "Java", "output": "protected void bingo(int risk, int confidence, String name, String description, String uri,\r\n            String param, String attack, String otherInfo, String solution,\r\n            String evidence, HttpMessage msg) {\r\n        \r\n        log.debug(\"New alert pluginid=\" + +this.getId() + \" \" + name + \" uri=\" + uri);\r\n        Alert alert = new Alert(this.getId(), risk, confidence, name);\r\n        if (uri == null || uri.equals(\"\")) {\r\n            uri = msg.getRequestHeader().getURI().toString();\r\n        }\r\n        \r\n        if (param == null) {\r\n            param = \"\";\r\n        }\r\n        \r\n        alert.setDetail(description, uri, param, attack, otherInfo, solution, this.getReference(),\r\n                evidence, this.getCweId(), this.getWascId(), msg);\r\n        \r\n        parent.alertFound(alert);\r\n    }", "category": "Python"}, {"instruction": "Blocks a non-worker-thread until completion or interruption.", "input": "Java", "output": "private int externalInterruptibleAwaitDone() throws InterruptedException {\n        int s;\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        while ((s = status) >= 0) {\n            if (U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {\n                synchronized (this) {\n                    if (status >= 0)\n                        wait();\n                    else\n                        notifyAll();\n                }\n            }\n        }\n        return s;\n    }", "category": "Python"}, {"instruction": "Gets authentication provider for service.\n\n@param service the service\n@return the authentication provider for service", "input": "Java", "output": "public Collection<MultifactorAuthenticationProvider> getAuthenticationProviderForService(final RegisteredService service) {\n        val policy = service.getMultifactorPolicy();\n        if (policy != null) {\n            return policy.getMultifactorAuthenticationProviders().stream()\n                .map(MultifactorAuthenticationUtils::getMultifactorAuthenticationProviderFromApplicationContext)\n                .filter(Optional::isPresent)\n                .map(Optional::get)\n                .collect(Collectors.toSet());\n        }\n        return null;\n    }", "category": "Python"}, {"instruction": "(and return null).", "input": "Java", "output": "public static Long attemptUUIDParseHigh(BufferedString str) {\n    final byte[] buf = str.getBuffer();\n    int i=str.getOffset();\n    if ( i== -1 ) return markBad(str);\n    long hi=0;\n    if( buf[i++]!='-' ) return markBad(str);\n    hi = get2(hi,buf,(i+=2)-2);\n    hi = get2(hi,buf,(i+=2)-2);\n    if( buf[i++]!='-' ) return markBad(str);\n    hi = get2(hi,buf,(i+=2)-2);\n    hi = get2(hi,buf,(i+=2)-2);\n    hi = get2(hi,buf,(i+=2)-2);\n    hi = get2(hi,buf,(i+=2)-2);\n    hi = get2(hi,buf,(i+=2)-2);\n    return attemptUUIDParseEnd(str, hi, buf, i);\n  }", "category": "Python"}, {"instruction": "<code>\n.google.cloud.datalabeling.v1beta1.LabelImageOrientedBoundingBoxOperationMetadata image_oriented_bounding_box_details = 14;\n</code>", "input": "Java", "output": "public com.google.cloud.datalabeling.v1beta1.LabelImageOrientedBoundingBoxOperationMetadata\n      getImageOrientedBoundingBoxDetails() {\n    if (detailsCase_ == 14) {\n      return (com.google.cloud.datalabeling.v1beta1.LabelImageOrientedBoundingBoxOperationMetadata)\n          details_;\n    }\n    return com.google.cloud.datalabeling.v1beta1.LabelImageOrientedBoundingBoxOperationMetadata\n        .getDefaultInstance();\n  }", "category": "Python"}, {"instruction": "Read bytes into the given {@link ByteBuf} and return the amount.", "input": "Java", "output": "protected final int doReadBytes(ByteBuf byteBuf) throws Exception {\n        int writerIndex = byteBuf.writerIndex();\n        int localReadAmount;\n        unsafe().recvBufAllocHandle().attemptedBytesRead(byteBuf.writableBytes());\n        if (byteBuf.hasMemoryAddress()) {\n            localReadAmount = socket.readAddress(byteBuf.memoryAddress(), writerIndex, byteBuf.capacity());\n        } else {\n            ByteBuffer buf = byteBuf.internalNioBuffer(writerIndex, byteBuf.writableBytes());\n            localReadAmount = socket.read(buf, buf.position(), buf.limit());\n        }\n        if (localReadAmount > 0) {\n            byteBuf.writerIndex(writerIndex + localReadAmount);\n        }\n        return localReadAmount;\n    }", "category": "Python"}, {"instruction": "Create alias parser instance.\n\n@param lexerEngine lexical analysis engine.\n@return alias parser instance", "input": "Java", "output": "public static AliasExpressionParser createAliasExpressionParser(final LexerEngine lexerEngine) {\n        switch (lexerEngine.getDatabaseType()) {\n            case H2:\n                return new MySQLAliasExpressionParser(lexerEngine);\n            case MySQL:\n                return new MySQLAliasExpressionParser(lexerEngine);\n            case Oracle:\n                return new OracleAliasExpressionParser(lexerEngine);\n            case SQLServer:\n                return new SQLServerAliasExpressionParser(lexerEngine);\n            case PostgreSQL:\n                return new PostgreSQLAliasExpressionParser(lexerEngine);\n            default:\n                throw new UnsupportedOperationException(String.format(\"Cannot support database type: %s\", lexerEngine.getDatabaseType()));\n        }\n    }", "category": "Python"}, {"instruction": "Strategy method used to create the {@link ApplicationContext}. By default this\nmethod will respect any explicitly set application context or application context\nclass before falling back to a suitable default.\n@return the application context (not yet refreshed)\n@see #setApplicationContextClass(Class)", "input": "Java", "output": "protected ConfigurableApplicationContext createApplicationContext() {\n\t\tClass<?> contextClass = this.applicationContextClass;\n\t\tif (contextClass == null) {\n\t\t\ttry {\n\t\t\t\tswitch (this.webApplicationType) {\n\t\t\t\tcase SERVLET:\n\t\t\t\t\tcontextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase REACTIVE:\n\t\t\t\t\tcontextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcontextClass = Class.forName(DEFAULT_CONTEXT_CLASS);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Unable create a default ApplicationContext, \"\n\t\t\t\t\t\t\t\t+ \"please specify an ApplicationContextClass\",\n\t\t\t\t\t\tex);\n\t\t\t}\n\t\t}\n\t\treturn (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);\n\t}", "category": "Python"}, {"instruction": "Encodes {@code value}.\n@param value a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer,\nLong, Double or null. May not be {@link Double#isNaN() NaNs} or\n{@link Double#isInfinite() infinities}.\n@return this stringer.\n@throws JSONException if processing of json failed", "input": "Java", "output": "public JSONStringer value(Object value) throws JSONException {\n\t\tif (this.stack.isEmpty()) {\n\t\t\tthrow new JSONException(\"Nesting problem\");\n\t\t}\n\n\t\tif (value instanceof JSONArray) {\n\t\t\t((JSONArray) value).writeTo(this);\n\t\t\treturn this;\n\n\t\t}\n\t\telse if (value instanceof JSONObject) {\n\t\t\t((JSONObject) value).writeTo(this);\n\t\t\treturn this;\n\t\t}\n\n\t\tbeforeValue();\n\n\t\tif (value == null || value instanceof Boolean || value == JSONObject.NULL) {\n\t\t\tthis.out.append(value);\n\n\t\t}\n\t\telse if (value instanceof Number) {\n\t\t\tthis.out.append(JSONObject.numberToString((Number) value));\n\n\t\t}\n\t\telse {\n\t\t\tstring(value.toString());\n\t\t}\n\n\t\treturn this;\n\t}", "category": "Python"}, {"instruction": "Sign SAML response.\n\n@param samlResponse the SAML response\n@param privateKey   the private key\n@param publicKey    the public key\n@return the response", "input": "Java", "output": "public static String signSamlResponse(final String samlResponse, final PrivateKey privateKey, final PublicKey publicKey) {\n        val doc = constructDocumentFromXml(samlResponse);\n\n        if (doc != null) {\n            val signedElement = signSamlElement(doc.getRootElement(),\n                privateKey, publicKey);\n            doc.setRootElement((org.jdom.Element) signedElement.detach());\n            return new XMLOutputter().outputString(doc);\n        }\n        throw new IllegalArgumentException(\"Error signing SAML Response: Null document\");\n    }", "category": "Python"}, {"instruction": "This method is used in DL4J LSTM implementation\n@param input\n@return", "input": "Java", "output": "public static INDArray toMmulCompatible(INDArray input) {\n        if (input.rank() != 2)\n            throw new IllegalArgumentException(\"Input must be rank 2 (matrix)\");\n        //Same conditions as GemmParams.copyIfNecessary()\n        boolean doCopy = false;\n        if (input.ordering() == 'c' && (input.stride(0) != input.size(1) || input.stride(1) != 1))\n            doCopy = true;\n        else if (input.ordering() == 'f' && (input.stride(0) != 1 || input.stride(1) != input.size(0)))\n            doCopy = true;\n\n        if (doCopy)\n            return Shape.toOffsetZeroCopyAnyOrder(input);\n        else\n            return input;\n    }", "category": "Python"}, {"instruction": "Put ticket granting ticket in request and flow scopes.\n\n@param context     the context\n@param ticketValue the ticket value", "input": "Java", "output": "public static void putTicketGrantingTicketInScopes(final RequestContext context, final String ticketValue) {\n        putTicketGrantingTicketIntoMap(context.getRequestScope(), ticketValue);\n        putTicketGrantingTicketIntoMap(context.getFlowScope(), ticketValue);\n\n        var session = context.getFlowExecutionContext().getActiveSession().getParent();\n        while (session != null) {\n            putTicketGrantingTicketIntoMap(session.getScope(), ticketValue);\n            session = session.getParent();\n        }\n    }", "category": "Python"}, {"instruction": "\u8f6c\u5316\u6307\u5b9a\u5f02\u5e38\u4e3a\u6765\u81ea\u6216\u8005\u5305\u542b\u6307\u5b9a\u5f02\u5e38\n\n@param <T> \u5f02\u5e38\u7c7b\u578b\n@param throwable \u5f02\u5e38\n@param exceptionClass \u5b9a\u4e49\u7684\u5f15\u8d77\u5f02\u5e38\u7684\u7c7b\n@param checkCause \u5224\u65adcause\n@return \u7ed3\u679c\u4e3anull \u4e0d\u662f\u6765\u81ea\u6216\u8005\u5305\u542b\n@since 4.4.1", "input": "Java", "output": "@SuppressWarnings(\"unchecked\")\n\tpublic static <T extends Throwable> T convertFromOrSuppressedThrowable(Throwable throwable, Class<T> exceptionClass, boolean checkCause) {\n\t\tif (throwable == null || exceptionClass == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (exceptionClass.isAssignableFrom(throwable.getClass())) {\n\t\t\treturn (T) throwable;\n\t\t}\n\t\tif (checkCause) {\n\t\t\tThrowable cause = throwable.getCause();\n\t\t\tif (cause != null && exceptionClass.isAssignableFrom(cause.getClass())) {\n\t\t\t\treturn (T) cause;\n\t\t\t}\n\t\t}\n\t\tThrowable[] throwables = throwable.getSuppressed();\n\t\tif (ArrayUtil.isNotEmpty(throwables)) {\n\t\t\tfor (Throwable throwable1 : throwables) {\n\t\t\t\tif (exceptionClass.isAssignableFrom(throwable1.getClass())) {\n\t\t\t\t\treturn (T) throwable1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}", "category": "Python"}, {"instruction": "Sends the given response and status code to the given channel.\n\n@param channelHandlerContext identifying the open channel\n@param httpRequest originating http request\n@param response which should be sent\n@param statusCode of the message to send\n@param headers additional header values\n@param <P> type of the response", "input": "Java", "output": "public static <P extends ResponseBody> CompletableFuture<Void> sendResponse(\n\t\t\tChannelHandlerContext channelHandlerContext,\n\t\t\tHttpRequest httpRequest,\n\t\t\tP response,\n\t\t\tHttpResponseStatus statusCode,\n\t\t\tMap<String, String> headers) {\n\t\tStringWriter sw = new StringWriter();\n\t\ttry {\n\t\t\tmapper.writeValue(sw, response);\n\t\t} catch (IOException ioe) {\n\t\t\tLOG.error(\"Internal server error. Could not map response to JSON.\", ioe);\n\t\t\treturn sendErrorResponse(\n\t\t\t\tchannelHandlerContext,\n\t\t\t\thttpRequest,\n\t\t\t\tnew ErrorResponseBody(\"Internal server error. Could not map response to JSON.\"),\n\t\t\t\tHttpResponseStatus.INTERNAL_SERVER_ERROR,\n\t\t\t\theaders);\n\t\t}\n\t\treturn sendResponse(\n\t\t\tchannelHandlerContext,\n\t\t\thttpRequest,\n\t\t\tsw.toString(),\n\t\t\tstatusCode,\n\t\t\theaders);\n\t}", "category": "Python"}, {"instruction": "Resolves the default request factory.\n\n@return The default request factory.", "input": "Java", "output": "static HttpResponseFactory resolveDefaultResponseFactory() {\n        Optional<ServiceDefinition<HttpResponseFactory>> definition = SoftServiceLoader.load(HttpResponseFactory.class)\n                .firstOr(\"io.micronaut.http.server.netty.NettyHttpResponseFactory\", HttpResponseFactory.class.getClassLoader());\n\n        if (definition.isPresent()) {\n            ServiceDefinition<HttpResponseFactory> sd = definition.get();\n            try {\n                return sd.load();\n            } catch (Throwable e) {\n                LOG.warn(\"Unable to load default response factory for definition [\" + definition + \"]: \" + e.getMessage(), e);\n            }\n        }\n        return new SimpleHttpResponseFactory();\n    }", "category": "Python"}, {"instruction": "Construct a matrix from a copy of a 2-D array.\n\n@param A Two-dimensional array of doubles.\n@throws IllegalArgumentException All rows must have the same length", "input": "Java", "output": "public static Matrix constructWithCopy(double[][] A)\n    {\n        int m = A.length;\n        int n = A[0].length;\n        Matrix X = new Matrix(m, n);\n        double[][] C = X.getArray();\n        for (int i = 0; i < m; i++)\n        {\n            if (A[i].length != n)\n            {\n                throw new IllegalArgumentException\n                        (\"All rows must have the same length.\");\n            }\n            for (int j = 0; j < n; j++)\n            {\n                C[i][j] = A[i][j];\n            }\n        }\n        return X;\n    }", "category": "Python"}, {"instruction": "Sets the access control policy on the specified resource. Replaces any existing policy.\n\n<p>Sample code:\n\n<pre><code>\ntry (SubnetworkClient subnetworkClient = SubnetworkClient.create()) {\nProjectRegionSubnetworkResourceName resource = ProjectRegionSubnetworkResourceName.of(\"[PROJECT]\", \"[REGION]\", \"[RESOURCE]\");\nRegionSetPolicyRequest regionSetPolicyRequestResource = RegionSetPolicyRequest.newBuilder().build();\nPolicy response = subnetworkClient.setIamPolicySubnetwork(resource.toString(), regionSetPolicyRequestResource);\n}\n</code></pre>\n\n@param resource Name or id of the resource for this request.\n@param regionSetPolicyRequestResource\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Policy setIamPolicySubnetwork(\n      String resource, RegionSetPolicyRequest regionSetPolicyRequestResource) {\n\n    SetIamPolicySubnetworkHttpRequest request =\n        SetIamPolicySubnetworkHttpRequest.newBuilder()\n            .setResource(resource)\n            .setRegionSetPolicyRequestResource(regionSetPolicyRequestResource)\n            .build();\n    return setIamPolicySubnetwork(request);\n  }", "category": "Python"}, {"instruction": "Set the {@link RestTemplateCustomizer RestTemplateCustomizers} that should be\napplied to the {@link RestTemplate}. Customizers are applied in the order that they\nwere added after builder configuration has been applied. Setting this value will\nreplace any previously configured customizers.\n@param restTemplateCustomizers the customizers to set\n@return a new builder instance\n@see #additionalCustomizers(RestTemplateCustomizer...)", "input": "Java", "output": "public RestTemplateBuilder customizers(\n\t\t\tCollection<? extends RestTemplateCustomizer> restTemplateCustomizers) {\n\t\tAssert.notNull(restTemplateCustomizers,\n\t\t\t\t\"RestTemplateCustomizers must not be null\");\n\t\treturn new RestTemplateBuilder(this.detectRequestFactory, this.rootUri,\n\t\t\t\tthis.messageConverters, this.requestFactorySupplier,\n\t\t\t\tthis.uriTemplateHandler, this.errorHandler, this.basicAuthentication,\n\t\t\t\tCollections.unmodifiableSet(new LinkedHashSet<RestTemplateCustomizer>(\n\t\t\t\t\t\trestTemplateCustomizers)),\n\t\t\t\tthis.requestFactoryCustomizer, this.interceptors);\n\t}", "category": "Python"}, {"instruction": "This method checks for something somewhere\n\n@param operands", "input": "Java", "output": "public PenaltyCause[] processOperands(INDArray... operands) {\n        if (operands == null)\n            return new PenaltyCause[] {NONE};\n\n        List<PenaltyCause> causes = new ArrayList<>();\n        for (int e = 0; e < operands.length - 1; e++) {\n            if (operands[e] == null && operands[e + 1] == null)\n                continue;\n\n            PenaltyCause lc[] = processOperands(operands[e], operands[e + 1]);\n\n            for (PenaltyCause cause : lc) {\n                if (cause != NONE && !causes.contains(cause))\n                    causes.add(cause);\n            }\n        }\n        if (causes.isEmpty())\n            causes.add(NONE);\n\n        return causes.toArray(new PenaltyCause[0]);\n    }", "category": "Python"}, {"instruction": "Root method that branches for different implementations of {@link KeyedStateHandle}.", "input": "Java", "output": "@Override\n\tpublic RocksDBRestoreResult restore() throws Exception {\n\n\t\tif (restoreStateHandles == null || restoreStateHandles.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next();\n\n\t\tboolean isRescaling = (restoreStateHandles.size() > 1 ||\n\t\t\t!Objects.equals(theFirstStateHandle.getKeyGroupRange(), keyGroupRange));\n\n\t\tif (isRescaling) {\n\t\t\trestoreWithRescaling(restoreStateHandles);\n\t\t} else {\n\t\t\trestoreWithoutRescaling(theFirstStateHandle);\n\t\t}\n\t\treturn new RocksDBRestoreResult(this.db, defaultColumnFamilyHandle,\n\t\t\tnativeMetricMonitor, lastCompletedCheckpointId, backendUID, restoredSstFiles);\n\t}", "category": "Python"}, {"instruction": "Adding the browser described by the capability, automatically finding out what platform the\nnode is launched from\n\n@param cap       describing the browser\n@param instances number of times this browser can be started on the node.", "input": "Java", "output": "public void addBrowser(DesiredCapabilities cap, int instances) {\n    String s = cap.getBrowserName();\n    if (s == null || \"\".equals(s)) {\n      throw new InvalidParameterException(cap + \" does seems to be a valid browser.\");\n    }\n    if (cap.getPlatform() == null) {\n      cap.setPlatform(Platform.getCurrent());\n    }\n    cap.setCapability(RegistrationRequest.MAX_INSTANCES, instances);\n    registrationRequest.getConfiguration().capabilities.add(cap);\n    registrationRequest.getConfiguration().fixUpCapabilities();\n  }", "category": "Python"}, {"instruction": "Allocates a shared slot on this TaskManager instance. This method returns {@code null}, if no slot\nis available at the moment. The shared slot will be managed by the given  SlotSharingGroupAssignment.\n\n@param sharingGroupAssignment The assignment group that manages this shared slot.\n\n@return A shared slot that represents a task slot on this TaskManager instance and can hold other\n(shared) slots, or null, if the TaskManager instance has no more slots available.\n\n@throws InstanceDiedException Thrown if the instance is no longer alive by the time the slot is allocated.", "input": "Java", "output": "public SharedSlot allocateSharedSlot(SlotSharingGroupAssignment sharingGroupAssignment)\n\t\t\tthrows InstanceDiedException {\n\n\t\tsynchronized (instanceLock) {\n\t\t\tif (isDead) {\n\t\t\t\tthrow new InstanceDiedException(this);\n\t\t\t}\n\n\t\t\tInteger nextSlot = availableSlots.poll();\n\t\t\tif (nextSlot == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSharedSlot slot = new SharedSlot(\n\t\t\t\t\tthis,\n\t\t\t\t\tlocation,\n\t\t\t\t\tnextSlot,\n\t\t\t\t\ttaskManagerGateway,\n\t\t\t\t\tsharingGroupAssignment);\n\t\t\t\tallocatedSlots.add(slot);\n\t\t\t\treturn slot;\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Tries to repair the lattice by creating and adding an additional Viterbi node to the RIGHT of the newly\ninserted user dictionary entry by using the substring of the node in the lattice that overlaps the least\n@param lattice\n@param nodeEndIndex", "input": "Java", "output": "private void repairBrokenLatticeAfter(ViterbiLattice lattice, int nodeEndIndex) {\n        ViterbiNode[][] nodeEndIndices = lattice.getEndIndexArr();\n\n        for (int endIndex = nodeEndIndex + 1; endIndex < nodeEndIndices.length; endIndex++) {\n            if (nodeEndIndices[endIndex] != null) {\n                ViterbiNode glueBase = findGlueNodeCandidate(nodeEndIndex, nodeEndIndices[endIndex], endIndex);\n                if (glueBase != null) {\n                    int delta = endIndex - nodeEndIndex;\n                    String glueBaseSurface = glueBase.getSurface();\n                    String surface = glueBaseSurface.substring(glueBaseSurface.length() - delta);\n                    ViterbiNode glueNode = createGlueNode(nodeEndIndex, glueBase, surface);\n                    lattice.addNode(glueNode, nodeEndIndex, nodeEndIndex + glueNode.getSurface().length());\n                    return;\n                }\n            }\n        }\n    }", "category": "Python"}, {"instruction": "<p>Appends to the <code>builder</code> the comparison of\ntwo <code>Object</code>s.</p>\n\n<ol>\n<li>Check if <code>lhs == rhs</code></li>\n<li>Check if either <code>lhs</code> or <code>rhs</code> is <code>null</code>,\na <code>null</code> object is less than a non-<code>null</code> object</li>\n<li>Check the object contents</li>\n</ol>\n\n<p>If <code>lhs</code> is an array, array comparison methods will be used.\nOtherwise <code>comparator</code> will be used to compare the objects.\nIf <code>comparator</code> is <code>null</code>, <code>lhs</code> must\nimplement {@link Comparable} instead.</p>\n\n@param lhs  left-hand object\n@param rhs  right-hand object\n@param comparator  <code>Comparator</code> used to compare the objects,\n<code>null</code> means treat lhs as <code>Comparable</code>\n@return this - used to chain append calls\n@throws ClassCastException  if <code>rhs</code> is not assignment-compatible\nwith <code>lhs</code>\n@since 2.0", "input": "Java", "output": "public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = +1;\n            return this;\n        }\n        if (lhs.getClass().isArray()) {\n            // switch on type of array, to dispatch to the correct handler\n            // handles multi dimensional arrays\n            // throws a ClassCastException if rhs is not the correct array type\n            if (lhs instanceof long[]) {\n                append((long[]) lhs, (long[]) rhs);\n            } else if (lhs instanceof int[]) {\n                append((int[]) lhs, (int[]) rhs);\n            }", "category": "Python"}, {"instruction": "[VARIABLE \"my_second_key_name\"]", "input": "Java", "output": "public List<Entity> getMultiple(String firstKeyName, String secondKeyName) {\n    Datastore datastore = transaction.getDatastore();\n    // TODO change so that it's not necessary to hold the entities in a list for integration testing\n    // [START getMultiple]\n    KeyFactory keyFactory = datastore.newKeyFactory().setKind(\"MyKind\");\n    Key firstKey = keyFactory.newKey(firstKeyName);\n    Key secondKey = keyFactory.newKey(secondKeyName);\n    Iterator<Entity> entitiesIterator = transaction.get(firstKey, secondKey);\n    List<Entity> entities = Lists.newArrayList();\n    while (entitiesIterator.hasNext()) {\n      Entity entity = entitiesIterator.next();\n      // do something with the entity\n      entities.add(entity);\n    }\n    transaction.commit();\n    // [END getMultiple]\n    return entities;\n  }", "category": "Python"}, {"instruction": "\u8ba1\u7b97\u4e24\u4e2a\u65e5\u671f\u76f8\u5dee\u6708\u6570<br>\n\u5728\u975e\u91cd\u7f6e\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u8d77\u59cb\u65e5\u671f\u7684\u5929\u5c0f\u4e8e\u7ed3\u675f\u65e5\u671f\u7684\u5929\uff0c\u6708\u6570\u8981\u5c11\u7b971\uff08\u4e0d\u8db31\u4e2a\u6708\uff09\n\n@param isReset \u662f\u5426\u91cd\u7f6e\u65f6\u95f4\u4e3a\u8d77\u59cb\u65f6\u95f4\uff08\u91cd\u7f6e\u5929\u65f6\u5206\u79d2\uff09\n@return \u76f8\u5dee\u6708\u6570\n@since 3.0.8", "input": "Java", "output": "public long betweenMonth(boolean isReset) {\r\n\t\tfinal Calendar beginCal = DateUtil.calendar(begin);\r\n\t\tfinal Calendar endCal = DateUtil.calendar(end);\r\n\r\n\t\tfinal int betweenYear = endCal.get(Calendar.YEAR) - beginCal.get(Calendar.YEAR);\r\n\t\tfinal int betweenMonthOfYear = endCal.get(Calendar.MONTH) - beginCal.get(Calendar.MONTH);\r\n\r\n\t\tint result = betweenYear * 12 + betweenMonthOfYear;\r\n\t\tif (false == isReset) {\r\n\t\t\tendCal.set(Calendar.YEAR, beginCal.get(Calendar.YEAR));\r\n\t\t\tendCal.set(Calendar.MONTH, beginCal.get(Calendar.MONTH));\r\n\t\t\tlong between = endCal.getTimeInMillis() - beginCal.getTimeInMillis();\r\n\t\t\tif (between < 0) {\r\n\t\t\t\treturn result - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}", "category": "Python"}, {"instruction": "Remove all values for the given key without returning them. This is a minor performance\noptimization if you do not need the previous values.", "input": "Java", "output": "@ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/4691\")\n  public <T> void discardAll(Key<T> key) {\n    if (isEmpty()) {\n      return;\n    }\n    int writeIdx = 0;\n    int readIdx = 0;\n    for (; readIdx < size; readIdx++) {\n      if (bytesEqual(key.asciiName(), name(readIdx))) {\n        continue;\n      }\n      name(writeIdx, name(readIdx));\n      value(writeIdx, value(readIdx));\n      writeIdx++;\n    }\n    int newSize = writeIdx;\n    // Multiply by two since namesAndValues is interleaved.\n    Arrays.fill(namesAndValues, writeIdx * 2, len(), null);\n    size = newSize;\n  }", "category": "Python"}, {"instruction": "This method returns similarity of the document to specific label, based on mean value\n\n@param rawText\n@param label\n@return", "input": "Java", "output": "@Deprecated\n    public double similarityToLabel(String rawText, String label) {\n        if (tokenizerFactory == null)\n            throw new IllegalStateException(\"TokenizerFactory should be defined, prior to predict() call\");\n\n        List<String> tokens = tokenizerFactory.create(rawText).getTokens();\n        List<VocabWord> document = new ArrayList<>();\n        for (String token : tokens) {\n            if (vocab.containsWord(token)) {\n                document.add(vocab.wordFor(token));\n            }\n        }\n        return similarityToLabel(document, label);\n    }", "category": "Python"}, {"instruction": "Creates the high-availability services for the TaskManagers participating in\na Flink YARN application.\n\n@param flinkConfig  The Flink configuration.\n@param hadoopConfig The Hadoop configuration for the YARN cluster.\n\n@return The created high-availability services.\n\n@throws IOException Thrown, if the high-availability services could not be initialized.", "input": "Java", "output": "public static YarnHighAvailabilityServices forYarnTaskManager(\n\t\t\tConfiguration flinkConfig,\n\t\t\torg.apache.hadoop.conf.Configuration hadoopConfig) throws IOException {\n\n\t\tcheckNotNull(flinkConfig, \"flinkConfig\");\n\t\tcheckNotNull(hadoopConfig, \"hadoopConfig\");\n\n\t\tfinal HighAvailabilityMode mode = HighAvailabilityMode.fromConfig(flinkConfig);\n\t\tswitch (mode) {\n\t\t\tcase NONE:\n\t\t\t\treturn new YarnPreConfiguredMasterNonHaServices(\n\t\t\t\t\tflinkConfig,\n\t\t\t\t\thadoopConfig,\n\t\t\t\t\tHighAvailabilityServicesUtils.AddressResolution.TRY_ADDRESS_RESOLUTION);\n\n\t\t\tcase ZOOKEEPER:\n\t\t\t\tthrow  new UnsupportedOperationException(\"to be implemented\");\n\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalConfigurationException(\"Unrecognized high availability mode: \" + mode);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Gets the request body from the request.\n\n@param request the request\n@return the request body", "input": "Java", "output": "private static String getRequestBody(final HttpServletRequest request) {\n        val body = readRequestBodyIfAny(request);\n        if (!StringUtils.hasText(body)) {\n            LOGGER.trace(\"Looking at the request attribute [{}] to locate SAML request body\", SamlProtocolConstants.PARAMETER_SAML_REQUEST);\n            return (String) request.getAttribute(SamlProtocolConstants.PARAMETER_SAML_REQUEST);\n        }\n        return body;\n    }", "category": "Python"}, {"instruction": "Constructs an ApproximateHistogram object from the given byte-buffer representation\n\n@param buf ByteBuffer to construct an ApproximateHistogram from\n\n@return ApproximateHistogram constructed from the given ByteBuffer", "input": "Java", "output": "public static ApproximateHistogram fromBytes(ByteBuffer buf)\n  {\n    // negative size indicates compact representation\n    // this works regardless of whether we use int or short for the size since the leftmost bit is the sign bit\n    if (buf.getShort(buf.position()) < 0) {\n      return fromBytesCompact(buf);\n    } else {\n      // ignore size, determine if sparse or dense based on sign of binCount\n      if (buf.getInt(buf.position() + Integer.BYTES) < 0) {\n        return fromBytesSparse(buf);\n      } else {\n        return fromBytesDense(buf);\n      }\n    }\n  }", "category": "Python"}, {"instruction": "Is consent required ?\n\n@param service           the service\n@param registeredService the registered service\n@param authentication    the authentication\n@param requestContext    the request context\n@return the event id.", "input": "Java", "output": "protected String isConsentRequired(final Service service, final RegisteredService registeredService,\n                                       final Authentication authentication,\n                                       final RequestContext requestContext) {\n        val required = this.consentEngine.isConsentRequiredFor(service, registeredService, authentication).isRequired();\n        return required ? EVENT_ID_CONSENT_REQUIRED : null;\n    }", "category": "Python"}, {"instruction": "Generates a function call with null handling, automatic binding of session parameter, etc.", "input": "Java", "output": "public BytecodeNode generateCall(\n            String name,\n            ScalarFunctionImplementation function,\n            List<BytecodeNode> arguments,\n            Optional<OutputBlockVariableAndType> outputBlockVariableAndType)\n    {\n        Optional<BytecodeNode> instance = Optional.empty();\n        if (function.getInstanceFactory().isPresent()) {\n            FieldDefinition field = cachedInstanceBinder.getCachedInstance(function.getInstanceFactory().get());\n            instance = Optional.of(scope.getThis().getField(field));\n        }\n        return generateInvocation(scope, name, function, instance, arguments, callSiteBinder, outputBlockVariableAndType);\n    }", "category": "Python"}, {"instruction": "--------------------------------------------------------------------------------------------", "input": "Java", "output": "private int convertToInt(Object o, int defaultValue) {\n\t\tif (o.getClass() == Integer.class) {\n\t\t\treturn (Integer) o;\n\t\t}\n\t\telse if (o.getClass() == Long.class) {\n\t\t\tlong value = (Long) o;\n\t\t\tif (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) {\n\t\t\t\treturn (int) value;\n\t\t\t} else {\n\t\t\t\tLOG.warn(\"Configuration value {} overflows/underflows the integer type.\", value);\n\t\t\t\treturn defaultValue;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\treturn Integer.parseInt(o.toString());\n\t\t\t}\n\t\t\tcatch (NumberFormatException e) {\n\t\t\t\tLOG.warn(\"Configuration cannot evaluate value {} as an integer number\", o);\n\t\t\t\treturn defaultValue;\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "\u8fc7\u6ee4<br>\n\u8fc7\u6ee4\u8fc7\u7a0b\u901a\u8fc7\u4f20\u5165\u7684Editor\u5b9e\u73b0\u6765\u8fd4\u56de\u9700\u8981\u7684\u5143\u7d20\u5185\u5bb9\uff0c\u8fd9\u4e2aEditor\u5b9e\u73b0\u53ef\u4ee5\u5b9e\u73b0\u4ee5\u4e0b\u529f\u80fd\uff1a\n\n<pre>\n1\u3001\u8fc7\u6ee4\u51fa\u9700\u8981\u7684\u5bf9\u8c61\uff0c\u5982\u679c\u8fd4\u56denull\u8868\u793a\u8fd9\u4e2a\u5143\u7d20\u5bf9\u8c61\u629b\u5f03\n2\u3001\u4fee\u6539\u5143\u7d20\u5bf9\u8c61\uff0c\u8fd4\u56de\u96c6\u5408\u4e2d\u4e3a\u4fee\u6539\u540e\u7684\u5bf9\u8c61\n</pre>\n\n@param <K> Key\u7c7b\u578b\n@param <V> Value\u7c7b\u578b\n@param map Map\n@param editor \u7f16\u8f91\u5668\u63a5\u53e3\n@return \u8fc7\u6ee4\u540e\u7684Map", "input": "Java", "output": "public static <K, V> Map<K, V> filter(Map<K, V> map, Editor<Entry<K, V>> editor) {\r\n\t\tif(null == map || null == editor) {\r\n\t\t\treturn map;\r\n\t\t}\r\n\t\t\r\n\t\tfinal Map<K, V> map2 = ObjectUtil.clone(map);\r\n\t\tif (isEmpty(map2)) {\r\n\t\t\treturn map2;\r\n\t\t}\r\n\r\n\t\tmap2.clear();\r\n\t\tEntry<K, V> modified;\r\n\t\tfor (Entry<K, V> entry : map.entrySet()) {\r\n\t\t\tmodified = editor.edit(entry);\r\n\t\t\tif (null != modified) {\r\n\t\t\t\tmap2.put(modified.getKey(), modified.getValue());\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn map2;\r\n\t}", "category": "Python"}, {"instruction": "<b>getSDbl</b><br>\npublic static String getSDbl( double Value, int DecPrec )<br>\nReturns double converted to string.<br>\nIf Value is Double.NaN returns \"NaN\".<br>\nIf DecPrec is < 0 is DecPrec set 0.<br>\n\n@param Value - value\n@param DecPrec - decimal precision\n@return double as string", "input": "Java", "output": "public static String getSDbl( double Value, int DecPrec ) {\n\t\t//\n\t\tString Result = \"\";\n\t\t//\n\t\tif ( Double.isNaN( Value ) ) return \"NaN\";\n\t\t//\n\t\tif ( DecPrec < 0 ) DecPrec = 0;\n\t\t//\n\t\tString DFS = \"###,###,##0\";\n\t\t//\n\t\tif ( DecPrec > 0 ) {\n\t\t\tint idx = 0;\n\t\t\tDFS += \".\";\n\t\t\twhile ( idx < DecPrec ) {\n\t\t\t\tDFS = DFS + \"0\";\n\t\t\t\tidx ++;\n\t\t\t\tif ( idx > 100 ) break;\n\t\t\t}\n\t\t}\n\t\t//\n//\t\tLocale locale  = new Locale(\"en\", \"UK\");\n\t\t//\n\t\tDecimalFormatSymbols DcmFrmSmb = new DecimalFormatSymbols( Locale.getDefault());\n\t\tDcmFrmSmb.setDecimalSeparator('.');\n\t\tDcmFrmSmb.setGroupingSeparator(' ');\n\t\t//\n\t\tDecimalFormat DcmFrm;\n\t\t//\n\t\tDcmFrm = new DecimalFormat( DFS, DcmFrmSmb );\n\t\t//\n\t//\tDcmFrm.setGroupingSize( 3 );\n\t\t//\n\t\tResult = DcmFrm.format( Value );\n\t\t//\n\t\treturn Result;\n\t}", "category": "Python"}, {"instruction": "Searches defined database where the URL prefix matches one of the prefixes defined in a {@link JdbcDatabase}.\nThe prefix is determined by:\n<p>\njdbc:<prefix>:...\n\n@param jdbcUrl The connection URL\n@return An optional {@link JdbcDatabase}", "input": "Java", "output": "@SuppressWarnings(\"MagicNumber\")\n    public static Optional<JdbcDatabase> findDatabase(String jdbcUrl) {\n        if (StringUtils.isNotEmpty(jdbcUrl)) {\n            if (!jdbcUrl.startsWith(\"jdbc\")) {\n                throw new IllegalArgumentException(\"JDBC URLs must start with 'jdbc'\");\n            }\n            String partialUrl = jdbcUrl.substring(5);\n            String prefix = partialUrl.substring(0, partialUrl.indexOf(':')).toLowerCase();\n\n            return databases.stream().filter(db -> db.containsPrefix(prefix)).findFirst();\n        }\n        return Optional.empty();\n    }", "category": "Python"}, {"instruction": "This method allows to remove graph from the GraphServer instance\n@param graphId", "input": "Java", "output": "public void dropGraph(long graphId) {\n        val builder = new FlatBufferBuilder(128);\n\n        val off = FlatDropRequest.createFlatDropRequest(builder, graphId);\n        builder.finish(off);\n\n        val req = FlatDropRequest.getRootAsFlatDropRequest(builder.dataBuffer());\n\n        val v = blockingStub.forgetGraph(req);\n        if (v.status() != 0)\n            throw new ND4JIllegalStateException(\"registerGraph() gRPC call failed\");\n    }", "category": "Python"}, {"instruction": "For callers where simplicity is desired\u00a0over flexibility. This method does it all in one call. If the request\nis unauthorized, an IllegalStateException will be thrown. Logs and metrics are emitted when the Sequence is\neither fully iterated or throws an exception.\n\n@param query                the query\n@param authenticationResult authentication result indicating identity of the requester\n@param remoteAddress        remote address, for logging; or null if unknown\n\n@return results", "input": "Java", "output": "@SuppressWarnings(\"unchecked\")\n  public <T> Sequence<T> runSimple(\n      final Query<T> query,\n      final AuthenticationResult authenticationResult,\n      @Nullable final String remoteAddress\n  )\n  {\n    initialize(query);\n\n    final Sequence<T> results;\n\n    try {\n      final Access access = authorize(authenticationResult);\n      if (!access.isAllowed()) {\n        throw new ISE(\"Unauthorized\");\n      }\n\n      final QueryLifecycle.QueryResponse queryResponse = execute();\n      results = queryResponse.getResults();\n    }\n    catch (Throwable e) {\n      emitLogsAndMetrics(e, remoteAddress, -1);\n      throw e;\n    }\n\n    return Sequences.wrap(\n        results,\n        new SequenceWrapper()\n        {\n          @Override\n          public void after(final boolean isDone, final Throwable thrown)\n          {\n            emitLogsAndMetrics(thrown, remoteAddress, -1);\n          }\n        }\n    );\n  }", "category": "Python"}, {"instruction": "Creates an image in the specified project using the data included in the request.\n\n<p>Sample code:\n\n<pre><code>\ntry (ImageClient imageClient = ImageClient.create()) {\nBoolean forceCreate = false;\nProjectName project = ProjectName.of(\"[PROJECT]\");\nImage imageResource = Image.newBuilder().build();\nOperation response = imageClient.insertImage(forceCreate, project, imageResource);\n}\n</code></pre>\n\n@param forceCreate Force image creation if true.\n@param project Project ID for this request.\n@param imageResource An Image resource. (== resource_for beta.images ==) (== resource_for\nv1.images ==)\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation insertImage(\n      Boolean forceCreate, ProjectName project, Image imageResource) {\n\n    InsertImageHttpRequest request =\n        InsertImageHttpRequest.newBuilder()\n            .setForceCreate(forceCreate)\n            .setProject(project == null ? null : project.toString())\n            .setImageResource(imageResource)\n            .build();\n    return insertImage(request);\n  }", "category": "Python"}, {"instruction": "Just record that this workspace is being used, without paying any attention to the synchronization support.", "input": "Java", "output": "public synchronized Lease record(@Nonnull FilePath p) {\n        if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.log(Level.FINE, \"recorded \" + p, new Throwable(\"from \" + this));\n        }\n        Entry old = inUse.put(p.getRemote(), new Entry(p, false));\n        if (old!=null)\n            throw new AssertionError(\"Tried to record a workspace already owned: \"+old);\n        return lease(p);\n    }", "category": "Python"}, {"instruction": "Gets cas ticket granting ticket created events.\n\n@param principal the principal\n@return the cas ticket granting ticket created events for", "input": "Java", "output": "protected Collection<? extends CasEvent> getCasTicketGrantingTicketCreatedEventsFor(final String principal) {\n        val type = CasTicketGrantingTicketCreatedEvent.class.getName();\n        LOGGER.debug(\"Retrieving events of type [{}] for [{}]\", type, principal);\n\n        val date = ZonedDateTime.now(ZoneOffset.UTC)\n            .minusDays(casProperties.getAuthn().getAdaptive().getRisk().getDaysInRecentHistory());\n        return casEventRepository.getEventsOfTypeForPrincipal(type, principal, date);\n    }", "category": "Python"}, {"instruction": "//////////////// Helper Methods ////////////////////", "input": "Java", "output": "private ResponseEntity<String> makeRestCall(String url) throws HygieiaException {\n        String jiraAccess = featureSettings.getJiraCredentials();\n        if (StringUtils.isEmpty(jiraAccess)) {\n            return restOperations.exchange(url, HttpMethod.GET, null, String.class);\n        } else {\n            String jiraAccessBase64 = new String(Base64.decodeBase64(jiraAccess));\n            String[] parts = jiraAccessBase64.split(\":\");\n            if (parts.length != 2) {\n                throw new HygieiaException(\"Invalid Jira credentials\", HygieiaException.INVALID_CONFIGURATION);\n            }\n            return restOperations.exchange(url, HttpMethod.GET, new HttpEntity<>(createHeaders(parts[0], parts[1])), String.class);\n        }\n    }", "category": "Python"}, {"instruction": "ZAP: Added to take into account the package name", "input": "Java", "output": "private List<ClassNameWrapper> getJarClassNames(ClassLoader cl, File file, String packageName) {\r\n    \tList<ClassNameWrapper> classNames = new ArrayList<> ();\r\n        ZipEntry entry = null;\r\n        String className = \"\";\r\n        try (JarFile jarFile = new JarFile(file)) {\r\n            Enumeration<JarEntry> entries = jarFile.entries();\r\n            while (entries.hasMoreElements()) {\r\n                entry = entries.nextElement();\r\n                if (entry.isDirectory() || !entry.getName().endsWith(\".class\")) {\r\n                    continue;\r\n                }\r\n                className = entry.toString().replaceAll(\"\\\\.class$\",\"\").replaceAll(\"/\",\".\");\r\n                if (className.indexOf(packageName) >= 0) {\r\n                    classNames.add(new ClassNameWrapper(cl, className));\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n        \tlogger.error(\"Failed to open file: \" + file.getAbsolutePath(), e);\r\n        }\r\n        return classNames;\r\n    }", "category": "Python"}, {"instruction": "\u8f6c\u6362\u4e3a\u7a7a\u683c\u5206\u5272\u65e0\u6807\u7b7e\u7684String\n\n@return", "input": "Java", "output": "public String toStringWithoutLabels()\n    {\n        StringBuilder sb = new StringBuilder(size() * 4);\n        int i = 1;\n        for (IWord word : wordList)\n        {\n            if (word instanceof CompoundWord)\n            {\n                int j = 0;\n                for (Word w : ((CompoundWord) word).innerList)\n                {\n                    sb.append(w.getValue());\n                    if (++j != ((CompoundWord) word).innerList.size())\n                        sb.append(' ');\n                }\n            }\n            else\n                sb.append(word.getValue());\n            if (i != wordList.size()) sb.append(' ');\n            ++i;\n        }\n        return sb.toString();\n    }", "category": "Python"}, {"instruction": "Fit a MultiDataSet (only compute based on the statistics from this {@link MultiDataSet})\n\n@param dataSet the dataset to compute on", "input": "Java", "output": "public void fit(@NonNull MultiDataSet dataSet) {\n        List<S.Builder> featureNormBuilders = new ArrayList<>();\n        List<S.Builder> labelNormBuilders = new ArrayList<>();\n\n        fitPartial(dataSet, featureNormBuilders, labelNormBuilders);\n\n        featureStats = buildList(featureNormBuilders);\n        if (isFitLabel()) {\n            labelStats = buildList(labelNormBuilders);\n        }\n    }", "category": "Python"}, {"instruction": "@deprecated Use {@link #getTimeMillis(CharSequence)} instead.\n\nReturns the date header value with the specified header name.  If\nthere are more than one header value for the specified header name, the\nfirst value is returned.\n\n@return the header value\n@throws ParseException\nif there is no such header or the header value is not a formatted date", "input": "Java", "output": "@Deprecated\n    public static Date getDateHeader(HttpMessage message, CharSequence name) throws ParseException {\n        String value = message.headers().get(name);\n        if (value == null) {\n            throw new ParseException(\"header not found: \" + name, 0);\n        }\n        Date date = DateFormatter.parseHttpDate(value);\n        if (date == null) {\n            throw new ParseException(\"header can't be parsed into a Date: \" + value, 0);\n        }\n        return date;\n    }", "category": "Python"}, {"instruction": "\u83b7\u53d6XLSX\u5de5\u4f5c\u7c3f\u6307\u5b9asheet\u4e2d\u56fe\u7247\u5217\u8868\n\n@param workbook \u5de5\u4f5c\u7c3f{@link Workbook}\n@param sheetIndex sheet\u7684\u7d22\u5f15\n@return \u56fe\u7247\u6620\u5c04\uff0c\u952e\u683c\u5f0f\uff1a\u884c_\u5217\uff0c\u503c\uff1a{@link PictureData}", "input": "Java", "output": "private static Map<String, PictureData> getPicMapXlsx(XSSFWorkbook workbook, int sheetIndex) {\r\n\t\tfinal Map<String, PictureData> sheetIndexPicMap = new HashMap<String, PictureData>();\r\n\t\tfinal XSSFSheet sheet = workbook.getSheetAt(sheetIndex);\r\n\t\tXSSFDrawing drawing;\r\n\t\tfor (POIXMLDocumentPart dr : sheet.getRelations()) {\r\n\t\t\tif (dr instanceof XSSFDrawing) {\r\n\t\t\t\tdrawing = (XSSFDrawing) dr;\r\n\t\t\t\tfinal List<XSSFShape> shapes = drawing.getShapes();\r\n\t\t\t\tXSSFPicture pic;\r\n\t\t\t\tCTMarker ctMarker;\r\n\t\t\t\tfor (XSSFShape shape : shapes) {\r\n\t\t\t\t\tpic = (XSSFPicture) shape;\r\n\t\t\t\t\tctMarker = pic.getPreferredSize().getFrom();\r\n\t\t\t\t\tsheetIndexPicMap.put(StrUtil.format(\"{}_{}\", ctMarker.getRow(), ctMarker.getCol()), pic.getPictureData());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn sheetIndexPicMap;\r\n\t}", "category": "Python"}, {"instruction": "Returns either the default {@link AvroUtils} which throw an exception in cases where Avro\nwould be needed or loads the specific utils for Avro from flink-avro.", "input": "Java", "output": "public static AvroUtils getAvroUtils() {\n\t\t// try and load the special AvroUtils from the flink-avro package\n\t\ttry {\n\t\t\tClass<?> clazz = Class.forName(AVRO_KRYO_UTILS, false, Thread.currentThread().getContextClassLoader());\n\t\t\treturn clazz.asSubclass(AvroUtils.class).getConstructor().newInstance();\n\t\t} catch (ClassNotFoundException e) {\n\t\t\t// cannot find the utils, return the default implementation\n\t\t\treturn new DefaultAvroUtils();\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(\"Could not instantiate \" + AVRO_KRYO_UTILS + \".\", e);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "------------------------------------ File Input Format -----------------------------------------", "input": "Java", "output": "public <X> DataSource<X> readFile(FileInputFormat<X> inputFormat, String filePath) {\n\t\tif (inputFormat == null) {\n\t\t\tthrow new IllegalArgumentException(\"InputFormat must not be null.\");\n\t\t}\n\t\tif (filePath == null) {\n\t\t\tthrow new IllegalArgumentException(\"The file path must not be null.\");\n\t\t}\n\n\t\tinputFormat.setFilePath(new Path(filePath));\n\t\ttry {\n\t\t\treturn createInput(inputFormat, TypeExtractor.getInputFormatTypes(inputFormat));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new InvalidProgramException(\"The type returned by the input format could not be automatically determined. \" +\n\t\t\t\t\t\"Please specify the TypeInformation of the produced type explicitly by using the \" +\n\t\t\t\t\t\"'createInput(InputFormat, TypeInformation)' method instead.\");\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Gets a list of unprotected root actions.\nThese URL prefixes should be exempted from access control checks by container-managed security.\nIdeally would be synchronized with {@link #getTarget}.\n@return a list of {@linkplain Action#getUrlName URL names}\n@since 1.495", "input": "Java", "output": "public Collection<String> getUnprotectedRootActions() {\n        Set<String> names = new TreeSet<>();\n        names.add(\"jnlpJars\"); // TODO cleaner to refactor doJnlpJars into a URA (see also JENKINS-44100)\n        // TODO consider caching (expiring cache when actions changes)\n        for (Action a : getActions()) {\n            if (a instanceof UnprotectedRootAction) {\n                String url = a.getUrlName();\n                if (url == null) continue;\n                names.add(url);\n            }\n        }\n        return names;\n    }", "category": "Python"}, {"instruction": "The current flow element, will be filled during operation execution", "input": "Java", "output": "public FlowElement getCurrentFlowElement() {\n    if (currentFlowElement == null) {\n      String processDefinitionId = getProcessDefinitionId();\n      if (processDefinitionId != null) {\n        org.activiti.bpmn.model.Process process = ProcessDefinitionUtil.getProcess(processDefinitionId);\n        currentFlowElement = process.getFlowElement(getCurrentActivityId(), true);\n      }\n    }\n    return currentFlowElement;\n  }", "category": "Python"}, {"instruction": "\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6bcf\u4e00\u884c\u6570\u636e\n\n@param <T> \u96c6\u5408\u7c7b\u578b\n@param collection \u96c6\u5408\n@return \u6587\u4ef6\u4e2d\u7684\u6bcf\u884c\u5185\u5bb9\u7684\u96c6\u5408\n@throws IORuntimeException IO\u5f02\u5e38", "input": "Java", "output": "public <T extends Collection<String>> T readLines(T collection) throws IORuntimeException {\r\n\t\tBufferedReader reader = null;\r\n\t\ttry {\r\n\t\t\treader = FileUtil.getReader(file, charset);\r\n\t\t\tString line;\r\n\t\t\twhile (true) {\r\n\t\t\t\tline = reader.readLine();\r\n\t\t\t\tif (line == null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcollection.add(line);\r\n\t\t\t}\r\n\t\t\treturn collection;\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new IORuntimeException(e);\r\n\t\t} finally {\r\n\t\t\tIoUtil.close(reader);\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "validates the text value using the list of validators provided by the\nuser {{@link #setValidators(ValidatorBase...)}\n\n@return true if the value is valid else false", "input": "Java", "output": "public static boolean validate(Control control) {\n        ValidationFacade facade = (ValidationFacade) control.getParent();\n        for (ValidatorBase validator : facade.validators) {\n            validator.setSrcControl(facade.controlProperty.get());\n            validator.validate();\n            if (validator.getHasErrors()) {\n                facade.activeValidator.set(validator);\n                control.pseudoClassStateChanged(PSEUDO_CLASS_ERROR, true);\n                return false;\n            }\n        }\n        control.pseudoClassStateChanged(PSEUDO_CLASS_ERROR, false);\n        facade.activeValidator.set(null);\n        return true;\n    }", "category": "Python"}, {"instruction": "Gets registered service and facade.\n\n@param request the request\n@return the registered service and facade", "input": "Java", "output": "protected Pair<SamlRegisteredService, SamlRegisteredServiceServiceProviderMetadataFacade> getRegisteredServiceAndFacade(final AuthnRequest request) {\n        val issuer = SamlIdPUtils.getIssuerFromSamlObject(request);\n        LOGGER.debug(\"Located issuer [{}] from authentication context\", issuer);\n\n        val registeredService = verifySamlRegisteredService(issuer);\n\n        LOGGER.debug(\"Located SAML metadata for [{}]\", registeredService.getServiceId());\n        val adaptor = getSamlMetadataFacadeFor(registeredService, request);\n\n        if (adaptor.isEmpty()) {\n            throw new UnauthorizedServiceException(UnauthorizedServiceException.CODE_UNAUTHZ_SERVICE,\n                \"Cannot find metadata linked to \" + issuer);\n        }\n        val facade = adaptor.get();\n        return Pair.of(registeredService, facade);\n    }", "category": "Python"}, {"instruction": "Write an unserialized message with a known length, uncompressed.", "input": "Java", "output": "private int writeKnownLengthUncompressed(InputStream message, int messageLength)\n      throws IOException {\n    if (maxOutboundMessageSize >= 0 && messageLength > maxOutboundMessageSize) {\n      throw Status.RESOURCE_EXHAUSTED\n          .withDescription(\n              String.format(\"message too large %d > %d\", messageLength , maxOutboundMessageSize))\n          .asRuntimeException();\n    }\n    ByteBuffer header = ByteBuffer.wrap(headerScratch);\n    header.put(UNCOMPRESSED);\n    header.putInt(messageLength);\n    // Allocate the initial buffer chunk based on frame header + payload length.\n    // Note that the allocator may allocate a buffer larger or smaller than this length\n    if (buffer == null) {\n      buffer = bufferAllocator.allocate(header.position() + messageLength);\n    }\n    writeRaw(headerScratch, 0, header.position());\n    return writeToOutputStream(message, outputStreamAdapter);\n  }", "category": "Python"}, {"instruction": "---------------------------------------------------------------------------------------------", "input": "Java", "output": "void writeSnapshotData(DataOutputView out) throws IOException {\n\t\tout.writeUTF(pojoClass.getName());\n\t\twriteOptionalMap(out, fieldSerializerSnapshots, PojoFieldUtils::writeField, TypeSerializerSnapshot::writeVersionedSnapshot);\n\t\twriteOptionalMap(out, registeredSubclassSerializerSnapshots, NoOpWriter.noopWriter(), TypeSerializerSnapshot::writeVersionedSnapshot);\n\t\twriteOptionalMap(out, nonRegisteredSubclassSerializerSnapshots, NoOpWriter.noopWriter(), TypeSerializerSnapshot::writeVersionedSnapshot);\n\t}", "category": "Python"}, {"instruction": "Sets the required and optional fields that should be shown in the panel.\n<p>\nAny fields previously set are removed.\n\n@param requiredFields the required fields.\n@param optionalFields the optional fields.\n@throws IllegalArgumentException if the any of the arguments is {@code null}.\n@since 2.7.0\n@see #setFields(String[])", "input": "Java", "output": "public void setFields(String[] requiredFields, String[] optionalFields) {\n\t\tif (requiredFields == null) {\n\t\t\tthrow new IllegalArgumentException(\"Parameter requiredFields must not be null.\");\n\t\t}\n\n\t\tif (optionalFields == null) {\n\t\t\tthrow new IllegalArgumentException(\"Parameter optionalFields must not be null.\");\n\t\t}\n\n\t\tthis.requiredFields = requiredFields;\n\t\tthis.optionalFields = optionalFields;\n\n\t\tthis.textFields = new HashMap<>(requiredFields.length + optionalFields.length);\n\n\t\tremoveAll();\n\n\t\tint fieldIndex = 0;\n\t\tfor (String fieldName : requiredFields) {\n\t\t\taddRequiredField(fieldName, fieldIndex);\n\t\t\tfieldIndex++;\n\t\t}\n\n\t\tfor (String fieldName : optionalFields) {\n\t\t\taddField(fieldName, fieldIndex);\n\t\t\tfieldIndex++;\n\t\t}\n\t\tadd(Box.createVerticalGlue(), LayoutHelper.getGBC(0, fieldIndex, 2, 0.0d, 1.0d));\n\n\t\tvalidate();\n\t}", "category": "Python"}, {"instruction": "Whether there are anymore records\n\n@return", "input": "Java", "output": "@Override\n    public boolean hasNext() {\n        if(next != null){\n            return true;\n        }\n        if(!recordReader.hasNext()){\n            return false;\n        }\n\n        //Prefetch, until we find one that isn't filtered out - or we run out of data\n        while(next == null && recordReader.hasNext()){\n            Record r = recordReader.nextRecord();\n            List<Writable> temp = transformProcess.execute(r.getRecord());\n            if(temp == null){\n                continue;\n            }\n            next = new org.datavec.api.records.impl.Record(temp, r.getMetaData());\n        }\n\n        return next != null;\n    }", "category": "Python"}, {"instruction": "This method initializes the working Panel.\n\n@return javax.swing.JScrollPane", "input": "Java", "output": "@Override\r\n\tprotected JPanel getWorkPanel() {\r\n\t\tif (mainPanel == null) {\r\n\t\t\tmainPanel = new JPanel(new BorderLayout());\r\n\r\n\t\t\ttabbedPane = new JTabbedPane();\r\n\t\t\ttabbedPane.addTab(Constant.messages.getString(\"spider.panel.tab.urls\"), getUrlsTableScrollPane());\r\n\t\t\ttabbedPane.addTab(Constant.messages.getString(\"spider.panel.tab.addednodes\"), getAddedNodesTableScrollPane());\r\n\t\t\ttabbedPane.addTab(Constant.messages.getString(\"spider.panel.tab.messages\"), getMessagesTableScrollPanel());\r\n\t\t\ttabbedPane.setSelectedIndex(0);\r\n\r\n\t\t\tmainPanel.add(tabbedPane);\r\n\t\t}\r\n\t\treturn mainPanel;\r\n\t}", "category": "Python"}, {"instruction": "\u8bfb\u53d6\u7c7b\u76f8\u5bf9\u8def\u5f84\u5185\u5bb9\n\n@param file \u6587\u4ef6\n@return \u6587\u4ef6\u5185\u5bb9\uff08\u6309\u884c\uff09\n@throws IOException \u53d1\u9001IO\u5f02\u5e38", "input": "Java", "output": "public static List<String> readLines(File file) throws IOException {\n        List<String> lines = new ArrayList<String>();\n        InputStreamReader reader = null;\n        BufferedReader bufferedReader = null;\n        try {\n            reader = new FileReader(file);\n            bufferedReader = new BufferedReader(reader);\n            String lineText = null;\n            while ((lineText = bufferedReader.readLine()) != null) {\n                lines.add(lineText);\n            }\n            return lines;\n        } finally {\n            if (bufferedReader != null) {\n                bufferedReader.close();\n            }\n            if (reader != null) {\n                reader.close();\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Reschedule a task\n\n@param task failed or cancelled task\n@return new instance of a task with \"SCHEDULED\" status", "input": "Java", "output": "private Task taskToBeRescheduled(Task task) {\n        Task taskToBeRetried = task.copy();\n        taskToBeRetried.setTaskId(IDGenerator.generate());\n        taskToBeRetried.setRetriedTaskId(task.getTaskId());\n        taskToBeRetried.setStatus(SCHEDULED);\n        taskToBeRetried.setRetryCount(task.getRetryCount() + 1);\n        taskToBeRetried.setRetried(false);\n        taskToBeRetried.setPollCount(0);\n        taskToBeRetried.setCallbackAfterSeconds(0);\n        task.setRetried(true);\n        return taskToBeRetried;\n    }", "category": "Python"}, {"instruction": "Adds a table schema under the given key.", "input": "Java", "output": "public void putTableSchema(String key, TableSchema schema) {\n\t\tcheckNotNull(key);\n\t\tcheckNotNull(schema);\n\n\t\tfinal String[] fieldNames = schema.getFieldNames();\n\t\tfinal TypeInformation<?>[] fieldTypes = schema.getFieldTypes();\n\n\t\tfinal List<List<String>> values = new ArrayList<>();\n\t\tfor (int i = 0; i < schema.getFieldCount(); i++) {\n\t\t\tvalues.add(Arrays.asList(fieldNames[i], TypeStringUtils.writeTypeInfo(fieldTypes[i])));\n\t\t}\n\n\t\tputIndexedFixedProperties(\n\t\t\tkey,\n\t\t\tArrays.asList(TABLE_SCHEMA_NAME, TABLE_SCHEMA_TYPE),\n\t\t\tvalues);\n\t}", "category": "Python"}, {"instruction": "ScalaTupleComparator", "input": "Java", "output": "protected void privateDuplicate(TupleComparatorBase<T> toClone) {\n\t\t// copy fields and serializer factories\n\t\tthis.keyPositions = toClone.keyPositions;\n\n\t\tthis.serializers = new TypeSerializer[toClone.serializers.length];\n\t\tfor (int i = 0; i < toClone.serializers.length; i++) {\n\t\t\tthis.serializers[i] = toClone.serializers[i].duplicate();\n\t\t}\n\n\t\tthis.comparators = new TypeComparator[toClone.comparators.length];\n\t\tfor (int i = 0; i < toClone.comparators.length; i++) {\n\t\t\tthis.comparators[i] = toClone.comparators[i].duplicate();\n\t\t}\n\n\t\tthis.normalizedKeyLengths = toClone.normalizedKeyLengths;\n\t\tthis.numLeadingNormalizableKeys = toClone.numLeadingNormalizableKeys;\n\t\tthis.normalizableKeyPrefixLen = toClone.normalizableKeyPrefixLen;\n\t\tthis.invertNormKey = toClone.invertNormKey;\n\t}", "category": "Python"}, {"instruction": "/*\nColor transition method.", "input": "Java", "output": "public Object evaluate(float fraction, Object startValue, Object endValue) {\n        int startInt = (Integer) startValue;\n        int startA = (startInt >> 24) & 0xff;\n        int startR = (startInt >> 16) & 0xff;\n        int startG = (startInt >> 8) & 0xff;\n        int startB = startInt & 0xff;\n\n        int endInt = (Integer) endValue;\n        int endA = (endInt >> 24) & 0xff;\n        int endR = (endInt >> 16) & 0xff;\n        int endG = (endInt >> 8) & 0xff;\n        int endB = endInt & 0xff;\n\n        return (int) ((startA + (int) (fraction * (endA - startA))) << 24) |\n                (int) ((startR + (int) (fraction * (endR - startR))) << 16) |\n                (int) ((startG + (int) (fraction * (endG - startG))) << 8) |\n                (int) ((startB + (int) (fraction * (endB - startB))));\n    }", "category": "Python"}, {"instruction": "Blocking server-streaming example. Calls listFeatures with a rectangle of interest. Prints each\nresponse feature as it arrives.", "input": "Java", "output": "public void listFeatures(int lowLat, int lowLon, int hiLat, int hiLon) {\n    info(\"*** ListFeatures: lowLat={0} lowLon={1} hiLat={2} hiLon={3}\", lowLat, lowLon, hiLat,\n        hiLon);\n\n    Rectangle request =\n        Rectangle.newBuilder()\n            .setLo(Point.newBuilder().setLatitude(lowLat).setLongitude(lowLon).build())\n            .setHi(Point.newBuilder().setLatitude(hiLat).setLongitude(hiLon).build()).build();\n    Iterator<Feature> features;\n    try {\n      features = blockingStub.listFeatures(request);\n      for (int i = 1; features.hasNext(); i++) {\n        Feature feature = features.next();\n        info(\"Result #\" + i + \": {0}\", feature);\n        if (testHelper != null) {\n          testHelper.onMessage(feature);\n        }\n      }\n    } catch (StatusRuntimeException e) {\n      warning(\"RPC failed: {0}\", e.getStatus());\n      if (testHelper != null) {\n        testHelper.onRpcError(e);\n      }\n    }\n  }", "category": "Python"}, {"instruction": "Gets all the items recursively contained in this collection in a read-only view.\n<p>\nThe default implementation recursively adds the items of all contained Views\nin case this view implements {@link ViewGroup}, which should be enough for most cases.\n\n@since 1.520", "input": "Java", "output": "public Collection<TopLevelItem> getAllItems() {\n\n        if (this instanceof ViewGroup) {\n            final Collection<TopLevelItem> items = new LinkedHashSet<>(getItems());\n\n            for(View view: ((ViewGroup) this).getViews()) {\n                items.addAll(view.getAllItems());\n            }\n            return Collections.unmodifiableCollection(items);\n        } else {\n            return getItems();\n        }\n    }", "category": "Python"}, {"instruction": "Get object from the storage, by key\n\n@param key", "input": "Java", "output": "@Override\n    public INDArray get(T key) {\n        try {\n            if (emulateIsAbsent)\n                lock.readLock().lock();\n\n            if (containsKey(key)) {\n                INDArray result = compressedEntries.get(key);\n\n                // TODO: we don't save decompressed entries here, but something like LRU might be good idea\n                return compressor.decompress(result);\n            } else {\n                return null;\n            }\n        } finally {\n            if (emulateIsAbsent)\n                lock.readLock().unlock();\n        }\n    }", "category": "Python"}, {"instruction": "Perform kerberos login using the hadoop shim API if the configuration is available", "input": "Java", "output": "public static void loginFromKeytab(HiveConf hiveConf) throws IOException {\n    String principal = hiveConf.getVar(ConfVars.HIVE_SERVER2_KERBEROS_PRINCIPAL);\n    String keyTabFile = hiveConf.getVar(ConfVars.HIVE_SERVER2_KERBEROS_KEYTAB);\n    if (principal.isEmpty() || keyTabFile.isEmpty()) {\n      throw new IOException(\"HiveServer2 Kerberos principal or keytab is not correctly configured\");\n    } else {\n      UserGroupInformation.loginUserFromKeytab(SecurityUtil.getServerPrincipal(principal, \"0.0.0.0\"), keyTabFile);\n    }\n  }", "category": "Python"}, {"instruction": "Listen for update notifications for the auth storage", "input": "Java", "output": "@POST\n  @Path(\"/listen/{authenticatorName}\")\n  @Produces(MediaType.APPLICATION_JSON)\n  @Consumes(MediaType.APPLICATION_JSON)\n  @ResourceFilters(BasicSecurityResourceFilter.class)\n  public Response authenticatorUpdateListener(\n      @Context HttpServletRequest req,\n      @PathParam(\"authenticatorName\") final String authenticatorName,\n      byte[] serializedUserMap\n  )\n  {\n    return handler.authenticatorUpdateListener(authenticatorName, serializedUserMap);\n  }", "category": "Python"}, {"instruction": "Load a computation graph from a InputStream\n@param is the inputstream to get the computation graph from\n@return the loaded computation graph\n\n@throws IOException", "input": "Java", "output": "public static ComputationGraph restoreComputationGraph(@NonNull InputStream is, boolean loadUpdater)\n            throws IOException {\n        checkInputStream(is);\n\n        File tmpFile = null;\n        try{\n            tmpFile = tempFileFromStream(is);\n            return restoreComputationGraph(tmpFile, loadUpdater);\n        } finally {\n            if(tmpFile != null){\n                tmpFile.delete();\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Sets the logging service for a specific cluster.\n\n<p>Sample code:\n\n<pre><code>\ntry (ClusterManagerClient clusterManagerClient = ClusterManagerClient.create()) {\nString projectId = \"\";\nString zone = \"\";\nString clusterId = \"\";\nString loggingService = \"\";\nOperation response = clusterManagerClient.setLoggingService(projectId, zone, clusterId, loggingService);\n}\n</code></pre>\n\n@param projectId Deprecated. The Google Developers Console [project ID or project\nnumber](https://support.google.com/cloud/answer/6158840). This field has been deprecated\nand replaced by the name field.\n@param zone Deprecated. The name of the Google Compute Engine\n[zone](/compute/docs/zones#available) in which the cluster resides. This field has been\ndeprecated and replaced by the name field.\n@param clusterId Deprecated. The name of the cluster to upgrade. This field has been deprecated\nand replaced by the name field.\n@param loggingService The logging service the cluster should use to write metrics. Currently\navailable options:\n<p>&#42; \"logging.googleapis.com\" - the Google Cloud Logging service &#42; \"none\" - no\nmetrics will be exported from the cluster\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "public final Operation setLoggingService(\n      String projectId, String zone, String clusterId, String loggingService) {\n\n    SetLoggingServiceRequest request =\n        SetLoggingServiceRequest.newBuilder()\n            .setProjectId(projectId)\n            .setZone(zone)\n            .setClusterId(clusterId)\n            .setLoggingService(loggingService)\n            .build();\n    return setLoggingService(request);\n  }", "category": "Python"}, {"instruction": "Converts StreamConfiguration into StreamConfig.\n\n@param scope the stream's scope\n@param streamName The Stream Name\n@param configModel The stream configuration.\n@return StreamConfig instance.", "input": "Java", "output": "public static final StreamConfig decode(String scope, String streamName, final StreamConfiguration configModel) {\n        Preconditions.checkNotNull(configModel, \"configModel\");\n        final StreamConfig.Builder builder = StreamConfig.newBuilder()\n                .setStreamInfo(createStreamInfo(scope, streamName))\n                .setScalingPolicy(decode(configModel.getScalingPolicy()));\n        if (configModel.getRetentionPolicy() != null) {\n            builder.setRetentionPolicy(decode(configModel.getRetentionPolicy()));\n        }\n        return builder.build();\n    }", "category": "Python"}, {"instruction": "does not check validity of format and returns over-estimated result for invalid string (see UT)", "input": "Java", "output": "public static int estimatedBinaryLengthAsUTF8(String value)\n  {\n    int length = 0;\n    for (int i = 0; i < value.length(); i++) {\n      char var10 = value.charAt(i);\n      if (var10 < 0x80) {\n        length += 1;\n      } else if (var10 < 0x800) {\n        length += 2;\n      } else if (Character.isSurrogate(var10)) {\n        length += 4;\n        i++;\n      } else {\n        length += 3;\n      }\n    }\n    return length;\n  }", "category": "Python"}, {"instruction": "<code>\n.google.cloud.datalabeling.v1beta1.LabelTextClassificationOperationMetadata text_classification_details = 9;\n</code>", "input": "Java", "output": "public com.google.cloud.datalabeling.v1beta1.LabelTextClassificationOperationMetadataOrBuilder\n      getTextClassificationDetailsOrBuilder() {\n    if (detailsCase_ == 9) {\n      return (com.google.cloud.datalabeling.v1beta1.LabelTextClassificationOperationMetadata)\n          details_;\n    }\n    return com.google.cloud.datalabeling.v1beta1.LabelTextClassificationOperationMetadata\n        .getDefaultInstance();\n  }", "category": "Python"}, {"instruction": "Gets loader.\n\n@param resource the resource\n@param name     the name\n@return the loader", "input": "Java", "output": "public BaseConfigurationPropertiesLoader getLoader(final Resource resource,\n                                                       final String name) {\n        val filename = StringUtils.defaultString(resource.getFilename()).toLowerCase();\n\n        if (filename.endsWith(\".properties\")) {\n            return new SimpleConfigurationPropertiesLoader(this.configurationCipherExecutor, name, resource);\n        }\n        if (filename.endsWith(\".groovy\")) {\n            return new GroovyConfigurationPropertiesLoader(this.configurationCipherExecutor, name,\n                getApplicationProfiles(environment), resource);\n        }\n        if (filename.endsWith(\".yaml\") || filename.endsWith(\".yml\")) {\n            return new YamlConfigurationPropertiesLoader(this.configurationCipherExecutor, name, resource);\n        }\n        throw new IllegalArgumentException(\"Unable to determine configuration loader for \" + resource);\n    }", "category": "Python"}, {"instruction": "Parquet column names are case-sensitive unlike Hive, which converts all column names to lowercase.\nTherefore, when we look up columns we first check for exact match, and if that fails we look for a case-insensitive match.", "input": "Java", "output": "public static ColumnIO lookupColumnByName(GroupColumnIO groupColumnIO, String columnName)\n    {\n        ColumnIO columnIO = groupColumnIO.getChild(columnName);\n\n        if (columnIO != null) {\n            return columnIO;\n        }\n\n        for (int i = 0; i < groupColumnIO.getChildrenCount(); i++) {\n            if (groupColumnIO.getChild(i).getName().equalsIgnoreCase(columnName)) {\n                return groupColumnIO.getChild(i);\n            }\n        }\n\n        return null;\n    }", "category": "Python"}, {"instruction": "Configures the file input format by reading the file path from the configuration.\n\n@see org.apache.flink.api.common.io.InputFormat#configure(org.apache.flink.configuration.Configuration)", "input": "Java", "output": "@Override\n\tpublic void configure(Configuration parameters) {\n\n\t\tif (getFilePaths().length == 0) {\n\t\t\t// file path was not specified yet. Try to set it from the parameters.\n\t\t\tString filePath = parameters.getString(FILE_PARAMETER_KEY, null);\n\t\t\tif (filePath == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"File path was not specified in input format or configuration.\");\n\t\t\t} else {\n\t\t\t\tsetFilePath(filePath);\n\t\t\t}\n\t\t}\n\n\t\tif (!this.enumerateNestedFiles) {\n\t\t\tthis.enumerateNestedFiles = parameters.getBoolean(ENUMERATE_NESTED_FILES_FLAG, false);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "\u4e0a\u4e0b\u6587\u5f80\u4e0b\u653e\u4e00\u5c42\uff08\u4f8b\u5982\u670d\u52a1\u7aefB\u63a5\u5230A\u7684\u8bf7\u6c42\u540e\u518d\u4f5c\u4e3aC\u7684\u5ba2\u6237\u7aef\u8c03\u7528\uff0c\u8c03\u7528\u524d\u8fd9\u91cc\u5c31\u5148\u628a\u653eA-B\u7684\u4e0a\u4e0b\u6587\u5b58\u8d77\u6765\uff09", "input": "Java", "output": "public static void pushContext() {\n        RpcInternalContext context = LOCAL.get();\n        if (context != null) {\n            Deque<RpcInternalContext> deque = DEQUE_LOCAL.get();\n            if (deque == null) {\n                deque = new ArrayDeque<RpcInternalContext>();\n                DEQUE_LOCAL.set(deque);\n            }\n            deque.push(context);\n            LOCAL.set(null);\n        }\n    }", "category": "Python"}, {"instruction": "Configures which fields of the CSV file should be included and which should be skipped. The\npositions in the string (read from position 0 to its length) define whether the field at\nthe corresponding position in the CSV schema should be included.\nparser will look at the first {@code n} fields, where {@code n} is the length of the mask string\nThe parser will skip over all fields where the character at the corresponding position\nin the string is {@code '0'}, {@code 'F'}, or {@code 'f'} (representing the value\n{@code false}). The result contains the fields where the corresponding position in\nthe boolean array is {@code '1'}, {@code 'T'}, or {@code 't'} (representing the value {@code true}).\n\n@param mask The string mask defining which fields to include and which to skip.\n@return The CSV reader instance itself, to allow for fluent function chaining.", "input": "Java", "output": "public CsvReader includeFields(String mask) {\n\t\tboolean[] includedMask = new boolean[mask.length()];\n\n\t\tfor (int i = 0; i < mask.length(); i++) {\n\t\t\tchar c = mask.charAt(i);\n\t\t\tif (c == '1' || c == 'T' || c == 't') {\n\t\t\t\tincludedMask[i] = true;\n\t\t\t} else if (c != '0' && c != 'F' && c != 'f') {\n\t\t\t\tthrow new IllegalArgumentException(\"Mask string may contain only '0' and '1'.\");\n\t\t\t}\n\t\t}\n\n\t\treturn includeFields(includedMask);\n\t}", "category": "Python"}, {"instruction": "tag::configuration[]", "input": "Java", "output": "@Bean\n\tpublic TomcatServletWebServerFactory servletWebServerFactory() {\n\t\treturn new TomcatServletWebServerFactory() {\n\n\t\t\t@Override\n\t\t\tprotected void prepareContext(Host host,\n\t\t\t\t\tServletContextInitializer[] initializers) {\n\t\t\t\tsuper.prepareContext(host, initializers);\n\t\t\t\tStandardContext child = new StandardContext();\n\t\t\t\tchild.addLifecycleListener(new Tomcat.FixContextListener());\n\t\t\t\tchild.setPath(\"/cloudfoundryapplication\");\n\t\t\t\tServletContainerInitializer initializer = getServletContextInitializer(\n\t\t\t\t\t\tgetContextPath());\n\t\t\t\tchild.addServletContainerInitializer(initializer, Collections.emptySet());\n\t\t\t\tchild.setCrossContext(true);\n\t\t\t\thost.addChild(child);\n\t\t\t}\n\n\t\t};\n\t}", "category": "Python"}, {"instruction": "Creates a {@code JComboBox} with scanners' statuses, \"all\", release, beta and alpha.\n\n@return a {@code JComboBox} with scanners' statuses", "input": "Java", "output": "private JComboBox<String> createStatusComboBox() {\r\n        JComboBox<String> comboBox = new JComboBox<>();\r\n        comboBox.addItem(Constant.messages.getString(\"ascan.policy.table.quality.all\"));\r\n        View view = View.getSingleton();\r\n        comboBox.addItem(view.getStatusUI(AddOn.Status.release).toString());\r\n        comboBox.addItem(view.getStatusUI(AddOn.Status.beta).toString());\r\n        comboBox.addItem(view.getStatusUI(AddOn.Status.alpha).toString());\r\n        return comboBox;\r\n    }", "category": "Python"}, {"instruction": "Create create ticket granting ticket action.\n\n@param flow the flow", "input": "Java", "output": "protected void createCreateTicketGrantingTicketAction(final Flow flow) {\n        val action = createActionState(flow, CasWebflowConstants.STATE_ID_CREATE_TICKET_GRANTING_TICKET, CasWebflowConstants.ACTION_ID_CREATE_TICKET_GRANTING_TICKET);\n        createTransitionForState(action, CasWebflowConstants.TRANSITION_ID_SUCCESS_WITH_WARNINGS, CasWebflowConstants.STATE_ID_SHOW_AUTHN_WARNING_MSGS);\n        createTransitionForState(action, CasWebflowConstants.TRANSITION_ID_SUCCESS, CasWebflowConstants.STATE_ID_SEND_TICKET_GRANTING_TICKET);\n    }", "category": "Python"}, {"instruction": "Checks whether this dewey number is compatible to the other dewey number.\n\n<p>True iff this contains other as a prefix or iff they differ only in the last digit whereas\nthe last digit of this is greater than the last digit of other.\n\n@param other The other dewey number to check compatibility against\n@return Whether this dewey number is compatible to the other dewey number", "input": "Java", "output": "public boolean isCompatibleWith(DeweyNumber other) {\n\t\tif (length() > other.length()) {\n\t\t\t// prefix case\n\t\t\tfor (int i = 0; i < other.length(); i++) {\n\t\t\t\tif (other.deweyNumber[i] != deweyNumber[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} else if (length() == other.length()) {\n\t\t\t// check init digits for equality\n\t\t\tint lastIndex = length() - 1;\n\t\t\tfor (int i = 0; i < lastIndex; i++) {\n\t\t\t\tif (other.deweyNumber[i] != deweyNumber[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check that the last digit is greater or equal\n\t\t\treturn deweyNumber[lastIndex] >= other.deweyNumber[lastIndex];\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}", "category": "Python"}, {"instruction": "checks whether a value part of the effective predicate is likely to be part of this bloom filter", "input": "Java", "output": "@VisibleForTesting\n    public static boolean checkInBloomFilter(BloomFilter bloomFilter, Object predicateValue, Type sqlType)\n    {\n        if (sqlType == TINYINT || sqlType == SMALLINT || sqlType == INTEGER || sqlType == BIGINT) {\n            return bloomFilter.testLong(((Number) predicateValue).longValue());\n        }\n\n        if (sqlType == DOUBLE) {\n            return bloomFilter.testDouble((Double) predicateValue);\n        }\n\n        if (sqlType instanceof VarcharType || sqlType instanceof VarbinaryType) {\n            return bloomFilter.test(((Slice) predicateValue).getBytes());\n        }\n\n        // todo support DECIMAL, FLOAT, DATE, TIMESTAMP, and CHAR\n        return true;\n    }", "category": "Python"}, {"instruction": "Filters a descriptor for {@link BuildStep}s by using {@link BuildStepDescriptor#isApplicable(Class)}.", "input": "Java", "output": "public static <T extends BuildStep&Describable<T>>\n    List<Descriptor<T>> filter(List<Descriptor<T>> base, Class<? extends AbstractProject> type) {\n        // descriptor of the project\n        Descriptor pd = Jenkins.getInstance().getDescriptor((Class) type);\n\n        List<Descriptor<T>> r = new ArrayList<>(base.size());\n        for (Descriptor<T> d : base) {\n            if (pd instanceof AbstractProjectDescriptor && !((AbstractProjectDescriptor)pd).isApplicable(d))\n                continue;\n\n            if (d instanceof BuildStepDescriptor) {\n                BuildStepDescriptor<T> bd = (BuildStepDescriptor<T>) d;\n                if(!bd.isApplicable(type))  continue;\n                r.add(bd);\n            } else {\n                // old plugins built before 1.150 may not implement BuildStepDescriptor\n                r.add(d);\n            }\n        }\n        return r;\n    }", "category": "Python"}, {"instruction": "Judge logic tables is all belong to binding encryptors.\n\n@param logicTableNames logic table names\n@return logic tables is all belong to binding encryptors or not", "input": "Java", "output": "public boolean isAllBindingTables(final Collection<String> logicTableNames) {\n        if (logicTableNames.isEmpty()) {\n            return false;\n        }\n        Optional<BindingTableRule> bindingTableRule = findBindingTableRule(logicTableNames);\n        if (!bindingTableRule.isPresent()) {\n            return false;\n        }\n        Collection<String> result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n        result.addAll(bindingTableRule.get().getAllLogicTables());\n        return !result.isEmpty() && result.containsAll(logicTableNames);\n    }", "category": "Python"}, {"instruction": "\u5206\u9875\u67e5\u8be2<br>\n\u6b64\u65b9\u6cd5\u4e0d\u4f1a\u5173\u95edConnection\n\n@param <T> \u7ed3\u679c\u5bf9\u8c61\u7c7b\u578b\n@param conn \u6570\u636e\u5e93\u8fde\u63a5\u5bf9\u8c61\n@param fields \u8fd4\u56de\u7684\u5b57\u6bb5\u5217\u8868\uff0cnull\u5219\u8fd4\u56de\u6240\u6709\u5b57\u6bb5\n@param where \u6761\u4ef6\u5b9e\u4f53\u7c7b\uff08\u5305\u542b\u8868\u540d\uff09\n@param page \u5206\u9875\u5bf9\u8c61\n@param rsh \u7ed3\u679c\u96c6\u5904\u7406\u5bf9\u8c61\n@return \u7ed3\u679c\u5bf9\u8c61\n@throws SQLException SQL\u6267\u884c\u5f02\u5e38", "input": "Java", "output": "public <T> T page(Connection conn, Collection<String> fields, Entity where, Page page, RsHandler<T> rsh) throws SQLException {\r\n\t\tcheckConn(conn);\r\n\t\tif(null == page){\r\n\t\t\treturn this.find(conn, fields, where, rsh);\r\n\t\t}\r\n\t\t\r\n\t\tfinal Query query = new Query(SqlUtil.buildConditions(where), where.getTableName());\r\n\t\tquery.setFields(fields);\r\n\t\tquery.setPage(page);\r\n\t\treturn SqlExecutor.queryAndClosePs(dialect.psForPage(conn, query), rsh);\r\n\t}", "category": "Python"}, {"instruction": "\u83b7\u5f97\u4e00\u4e2a\u7c7b\u4e2d\u6240\u6709\u6784\u9020\u5217\u8868\n\n@param <T> \u6784\u9020\u7684\u5bf9\u8c61\u7c7b\u578b\n@param beanClass \u7c7b\n@return \u5b57\u6bb5\u5217\u8868\n@throws SecurityException \u5b89\u5168\u68c0\u67e5\u5f02\u5e38", "input": "Java", "output": "@SuppressWarnings(\"unchecked\")\r\n\tpublic static <T> Constructor<T>[] getConstructors(Class<T> beanClass) throws SecurityException {\r\n\t\tAssert.notNull(beanClass);\r\n\t\tConstructor<?>[] constructors = CONSTRUCTORS_CACHE.get(beanClass);\r\n\t\tif (null != constructors) {\r\n\t\t\treturn (Constructor<T>[]) constructors;\r\n\t\t}\r\n\r\n\t\tconstructors = getConstructorsDirectly(beanClass);\r\n\t\treturn (Constructor<T>[]) CONSTRUCTORS_CACHE.put(beanClass, constructors);\r\n\t}", "category": "Python"}, {"instruction": "read from input stream, convert it to string, put into this.bodyContent", "input": "Java", "output": "private void dumpInputStream(){\n        //dump request body\n        exchange.startBlocking();\n        InputStream inputStream = exchange.getInputStream();\n        try {\n            if(config.isMaskEnabled() && inputStream.available() != -1) {\n                this.bodyContent = Mask.maskJson(inputStream, \"requestBody\");\n            } else {\n                try {\n                    this.bodyContent = StringUtils.inputStreamToString(inputStream, UTF_8);\n                } catch (IOException e) {\n                    logger.error(e.toString());\n                }\n            }\n        } catch (IOException e) {\n            logger.error(\"undertow inputstream error:\" + e.getMessage());\n        }\n    }", "category": "Python"}, {"instruction": "Static helper that can be used to exit a {@link SpringApplication} and obtain a\ncode indicating success (0) or otherwise. Does not throw exceptions but should\nprint stack traces of any encountered. Applies the specified\n{@link ExitCodeGenerator} in addition to any Spring beans that implement\n{@link ExitCodeGenerator}. In the case of multiple exit codes the highest value\nwill be used (or if all values are negative, the lowest value will be used)\n@param context the context to close if possible\n@param exitCodeGenerators exist code generators\n@return the outcome (0 if successful)", "input": "Java", "output": "public static int exit(ApplicationContext context,\n\t\t\tExitCodeGenerator... exitCodeGenerators) {\n\t\tAssert.notNull(context, \"Context must not be null\");\n\t\tint exitCode = 0;\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tExitCodeGenerators generators = new ExitCodeGenerators();\n\t\t\t\tCollection<ExitCodeGenerator> beans = context\n\t\t\t\t\t\t.getBeansOfType(ExitCodeGenerator.class).values();\n\t\t\t\tgenerators.addAll(exitCodeGenerators);\n\t\t\t\tgenerators.addAll(beans);\n\t\t\t\texitCode = generators.getExitCode();\n\t\t\t\tif (exitCode != 0) {\n\t\t\t\t\tcontext.publishEvent(new ExitCodeEvent(context, exitCode));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tclose(context);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\texitCode = (exitCode != 0) ? exitCode : 1;\n\t\t}\n\t\treturn exitCode;\n\t}", "category": "Python"}, {"instruction": "A part of the deviance portion of the saddle point approximation.\n<p>\nReferences:\n<ol>\n<li>Catherine Loader (2000). \"Fast and Accurate Computation of Binomial\nProbabilities.\". <a target=\"_blank\"\nhref=\"http://www.herine.net/stat/papers/dbinom.pdf\">\nhttp://www.herine.net/stat/papers/dbinom.pdf</a></li>\n</ol>\n</p>\n\n@param x  the x value.\n@param mu the average.\n@return a part of the deviance.", "input": "Java", "output": "public static double getDeviancePart(double x, double mu) {\n        double ret;\n        if (FastMath.abs(x - mu) < 0.1 * (x + mu)) {\n            double d = x - mu;\n            double v = d / (x + mu);\n            double s1 = v * d;\n            double s = Double.NaN;\n            double ej = 2.0 * x * v;\n            v = v * v;\n            int j = 1;\n            while (s1 != s) {\n                s = s1;\n                ej *= v;\n                s1 = s + ej / ((j * 2) + 1);\n                ++j;\n            }\n            ret = s1;\n        } else {\n            ret = x * FastMath.log(x / mu) + mu - x;\n        }\n        return ret;\n    }", "category": "Python"}, {"instruction": "Notify all listeners of the priority tree change events (in ascending order)\n@param events The events (top down order) which have changed", "input": "Java", "output": "void notifyParentChanged(List<ParentChangedEvent> events) {\n        for (int i = 0; i < events.size(); ++i) {\n            ParentChangedEvent event = events.get(i);\n            stateOnlyRemovalQueue.priorityChanged(event.state);\n            if (event.state.parent != null && event.state.activeCountForTree != 0) {\n                event.state.parent.offerAndInitializePseudoTime(event.state);\n                event.state.parent.activeCountChangeForTree(event.state.activeCountForTree);\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Gets the JDK installation of the given name, or returns null.", "input": "Java", "output": "public JDK getJDK(String name) {\n        if(name==null) {\n            // if only one JDK is configured, \"default JDK\" should mean that JDK.\n            List<JDK> jdks = getJDKs();\n            if(jdks.size()==1)  return jdks.get(0);\n            return null;\n        }\n        for (JDK j : getJDKs()) {\n            if(j.getName().equals(name))\n                return j;\n        }\n        return null;\n    }", "category": "Python"}, {"instruction": "Installs (and sets into the add-on) the resource bundle declared by the given add-on, if any.\n\n@param addOnClassLoader the ClassLoader of the add-on.\n@param addOn the add-on.\n@since TODO add version\n@see AddOn#getBundleData()", "input": "Java", "output": "static void installResourceBundle(AddOnClassLoader addOnClassLoader, AddOn addOn) {\n        AddOn.BundleData bundleData = addOn.getBundleData();\n        if (bundleData.isEmpty()) {\n            return;\n        }\n\n        try {\n            ResourceBundle resourceBundle = ResourceBundle.getBundle(\n                    bundleData.getBaseName(),\n                    Constant.getLocale(),\n                    addOnClassLoader,\n                    new ZapResourceBundleControl());\n            addOn.setResourceBundle(resourceBundle);\n            String bundlePrefix = bundleData.getPrefix();\n            if (!bundlePrefix.isEmpty()) {\n                Constant.messages.addMessageBundle(bundlePrefix, resourceBundle);\n            }\n        } catch (MissingResourceException e) {\n            logger.error(\"Declared bundle not found in \" + addOn.getId() + \" add-on:\", e);\n        }\n    }", "category": "Python"}, {"instruction": "If this specified class represents a primitive type (int, float, etc.)\nthen it is translated into its wrapper type (Integer, Float, etc.). If\nthe passed class is not a primitive then it is just returned.\n\n@param primitive class\n@return class", "input": "Java", "output": "private static Class<?> translateFromPrimitive(Class<?> primitive) {\n        if (!primitive.isPrimitive()) {\n            return primitive;\n        }\n\n        if (Boolean.TYPE.equals(primitive)) {\n            return Boolean.class;\n        }\n        if (Character.TYPE.equals(primitive)) {\n            return Character.class;\n        }\n        if (Byte.TYPE.equals(primitive)) {\n            return Byte.class;\n        }\n        if (Short.TYPE.equals(primitive)) {\n            return Short.class;\n        }\n        if (Integer.TYPE.equals(primitive)) {\n            return Integer.class;\n        }\n        if (Long.TYPE.equals(primitive)) {\n            return Long.class;\n        }\n        if (Float.TYPE.equals(primitive)) {\n            return Float.class;\n        }\n        if (Double.TYPE.equals(primitive)) {\n            return Double.class;\n        }\n\n        throw new RuntimeException(\"Error translating type:\" + primitive);\n    }", "category": "Python"}, {"instruction": "This method initializes this", "input": "Java", "output": "private void initialize() {\r\n        this.setName(Constant.messages.getString(\"pscan.options.name\"));\r\n        this.setLayout(new GridBagLayout());\r\n\r\n        GridBagConstraints gbc = new GridBagConstraints();\r\n        gbc.gridx = 0;\r\n        gbc.weightx = 1.0;\r\n        gbc.anchor = GridBagConstraints.LINE_START;\r\n        gbc.fill = GridBagConstraints.BOTH;\r\n        \r\n        this.add(new JLabel(Constant.messages.getString(\"pscan.options.header\")), gbc);\r\n\r\n        scannersOptionsPanel = new ScannersMultipleOptionsPanel(getTableModel());\r\n        \r\n        gbc.weighty = 1.0;\r\n        this.add(scannersOptionsPanel, gbc);\r\n        \r\n        //gbc.weighty = 0.0;\r\n\t}", "category": "Python"}, {"instruction": "Prints out the command line to the listener with some portions masked to prevent sensitive information from being\nrecorded on the listener.\n\n@param cmd     The commands\n@param mask    An array of booleans which control whether a cmd element should be masked (<code>true</code>) or\nremain unmasked (<code>false</code>).\n@param workDir The work dir.", "input": "Java", "output": "protected final void maskedPrintCommandLine(@Nonnull List<String> cmd, @CheckForNull boolean[] mask, @CheckForNull FilePath workDir) {\n        if(mask==null) {\n            printCommandLine(cmd.toArray(new String[0]),workDir);\n            return;\n        }\n        \n        assert mask.length == cmd.size();\n        final String[] masked = new String[cmd.size()];\n        for (int i = 0; i < cmd.size(); i++) {\n            if (mask[i]) {\n                masked[i] = \"********\";\n            } else {\n                masked[i] = cmd.get(i);\n            }\n        }\n        printCommandLine(masked, workDir);\n    }", "category": "Python"}, {"instruction": "Enough attributes available to process? Check collection sizes and determine\nif we have enough data to move on.\n\n@param principal           the principal\n@param principalAttributes the principal attributes\n@return true /false", "input": "Java", "output": "protected boolean enoughAttributesAvailableToProcess(final String principal, final Map<String, Object> principalAttributes) {\n        if (!enoughRequiredAttributesAvailableToProcess(principalAttributes, this.requiredAttributes)) {\n            return false;\n        }\n        if (principalAttributes.size() < this.rejectedAttributes.size()) {\n            LOGGER.debug(\"The size of the principal attributes that are [{}] does not match defined rejected attributes, \"\n                + \"which means the principal is not carrying enough data to grant authorization\", principalAttributes);\n            return false;\n        }\n        return true;\n    }", "category": "Python"}, {"instruction": "\u7528\u4e8eModel\u5bf9\u8c61\u8f6c\u5316\u4e3aDO\u5bf9\u8c61\n\n@param tableStat\n@return TableStatDO", "input": "Java", "output": "private TableStatDO tableStatModelToDo(TableStat tableStat) {\n        TableStatDO tableStatDO = new TableStatDO();\n        tableStatDO.setId(tableStat.getId());\n        tableStatDO.setPipelineId(tableStat.getPipelineId());\n        tableStatDO.setDataMediaPairId(tableStat.getDataMediaPairId());\n        tableStatDO.setFileSize(tableStat.getFileSize());\n        tableStatDO.setFileCount(tableStat.getFileCount());\n        tableStatDO.setDeleteCount(tableStat.getDeleteCount());\n        tableStatDO.setInsertCount(tableStat.getInsertCount());\n        tableStatDO.setUpdateCount(tableStat.getUpdateCount());\n        tableStatDO.setGmtCreate(tableStat.getGmtCreate());\n        tableStatDO.setGmtModified(tableStat.getGmtModified());\n        return tableStatDO;\n\n    }", "category": "Python"}, {"instruction": "Create the dimensions for the flatbuffer builder\n@param bufferBuilder the buffer builder to use\n@param arr the input array\n@return", "input": "Java", "output": "public static int createDims(FlatBufferBuilder bufferBuilder,INDArray arr) {\n        int[] tensorDimOffsets = new int[arr.rank()];\n        int[] nameOffset = new int[arr.rank()];\n        for(int i = 0; i < tensorDimOffsets.length; i++) {\n            nameOffset[i] = bufferBuilder.createString(\"\");\n            tensorDimOffsets[i] = TensorDim.createTensorDim(bufferBuilder,arr.size(i),nameOffset[i]);\n        }\n\n        return Tensor.createShapeVector(bufferBuilder,tensorDimOffsets);\n    }", "category": "Python"}, {"instruction": "Patches the specified SSL policy with the data included in the request.\n\n<p>Sample code:\n\n<pre><code>\ntry (SslPolicyClient sslPolicyClient = SslPolicyClient.create()) {\nProjectGlobalSslPolicyName sslPolicy = ProjectGlobalSslPolicyName.of(\"[PROJECT]\", \"[SSL_POLICY]\");\nSslPolicy sslPolicyResource = SslPolicy.newBuilder().build();\nList&lt;String&gt; fieldMask = new ArrayList&lt;&gt;();\nOperation response = sslPolicyClient.patchSslPolicy(sslPolicy, sslPolicyResource, fieldMask);\n}\n</code></pre>\n\n@param sslPolicy Name of the SSL policy to update. The name must be 1-63 characters long, and\ncomply with RFC1035.\n@param sslPolicyResource A SSL policy specifies the server-side support for SSL features. This\ncan be attached to a TargetHttpsProxy or a TargetSslProxy. This affects connections between\nclients and the HTTPS or SSL proxy load balancer. They do not affect the connection between\nthe load balancers and the backends.\n@param fieldMask The fields that should be serialized (even if they have empty values). If the\ncontaining message object has a non-null fieldmask, then all the fields in the field mask\n(and only those fields in the field mask) will be serialized. If the containing object does\nnot have a fieldmask, then only non-empty fields will be serialized.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation patchSslPolicy(\n      ProjectGlobalSslPolicyName sslPolicy, SslPolicy sslPolicyResource, List<String> fieldMask) {\n\n    PatchSslPolicyHttpRequest request =\n        PatchSslPolicyHttpRequest.newBuilder()\n            .setSslPolicy(sslPolicy == null ? null : sslPolicy.toString())\n            .setSslPolicyResource(sslPolicyResource)\n            .addAllFieldMask(fieldMask)\n            .build();\n    return patchSslPolicy(request);\n  }", "category": "Python"}, {"instruction": "Sends a {@code RST_STREAM} frame even if we don't know about the stream. This error condition is most likely\ntriggered by the first frame of a stream being invalid. That is, there was an error reading the frame before\nwe could create a new stream.", "input": "Java", "output": "private ChannelFuture resetUnknownStream(final ChannelHandlerContext ctx, int streamId, long errorCode,\n                                             ChannelPromise promise) {\n        ChannelFuture future = frameWriter().writeRstStream(ctx, streamId, errorCode, promise);\n        if (future.isDone()) {\n            closeConnectionOnError(ctx, future);\n        } else {\n            future.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    closeConnectionOnError(ctx, future);\n                }\n            });\n        }\n        return future;\n    }", "category": "Python"}, {"instruction": "Start the environment specified.\n@param applicationContext the application context with the environment\n@return The environment within the context", "input": "Java", "output": "protected Environment startEnvironment(ApplicationContext applicationContext) {\n        if (!applicationContext.isRunning()) {\n            if (this instanceof PropertySource) {\n                applicationContext.getEnvironment().addPropertySource((PropertySource) this);\n            }\n\n            return applicationContext\n                    .start()\n                    .getEnvironment();\n        } else {\n            return applicationContext.getEnvironment();\n        }\n    }", "category": "Python"}, {"instruction": "\u540c\u65f6\u8fd4\u56de\u65e0\u5e8f\u96c6\u5408\u4e2d\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\uff0c\u4f7f\u7528\u5143\u7d20\u9ed8\u8ba4\u6392\u5e8f\n\n\u5728\u8fd4\u56de\u7684Pair\u4e2d\uff0c\u7b2c\u4e00\u4e2a\u4e3a\u6700\u5c0f\u503c\uff0c\u7b2c\u4e8c\u4e2a\u4e3a\u6700\u5927\u503c", "input": "Java", "output": "public static <T extends Object & Comparable<? super T>> Pair<T, T> minAndMax(Collection<? extends T> coll) {\n\t\tIterator<? extends T> i = coll.iterator();\n\t\tT minCandidate = i.next();\n\t\tT maxCandidate = minCandidate;\n\n\t\twhile (i.hasNext()) {\n\t\t\tT next = i.next();\n\t\t\tif (next.compareTo(minCandidate) < 0) {\n\t\t\t\tminCandidate = next;\n\t\t\t} else if (next.compareTo(maxCandidate) > 0) {\n\t\t\t\tmaxCandidate = next;\n\t\t\t}\n\t\t}\n\t\treturn Pair.of(minCandidate, maxCandidate);\n\t}", "category": "Python"}, {"instruction": "Get sharding encryptor.\n\n@param logicTableName logic table name\n@param columnName column name\n@return optional of sharding encryptor", "input": "Java", "output": "public Optional<ShardingEncryptor> getShardingEncryptor(final String logicTableName, final String columnName) {\n        for (ShardingEncryptorStrategy each : shardingEncryptorStrategies.values()) {\n            Optional<ShardingEncryptor> result = each.getShardingEncryptor(logicTableName, columnName);\n            if (result.isPresent()) {\n                return result;\n            }\n        }\n        return Optional.absent();\n    }", "category": "Python"}, {"instruction": "Shortlist variables which match a given regex. Returns empty empty list, if no\neligible variable is found", "input": "Java", "output": "public static List<Variable> getVariablesByRegex(\n      final Collection<Variable> variables, final String regex) {\n    final List<Variable> shortlistedVariables = new ArrayList<>();\n    if (variables != null && regex != null) {\n      for (final Variable var : variables) {\n        if (var.getTitle().matches(regex)) {\n          shortlistedVariables.add(var);\n        }\n      }\n    }\n    return shortlistedVariables;\n  }", "category": "Python"}, {"instruction": "Returns the unique id of the instance.\n(Note) now that id is set at creation time within the instanceProvider, why do the other checks?\nThis is still necessary for backwards compatibility when upgrading in a deployment with multiple\nclient versions (some with the change, some without).\n\n@return the unique id.", "input": "Java", "output": "@Override\n    @JsonIgnore\n    public String getId() {\n        if (instanceId != null && !instanceId.isEmpty()) {\n            return instanceId;\n        } else if (dataCenterInfo instanceof AmazonInfo) {\n            String uniqueId = ((AmazonInfo) dataCenterInfo).getId();\n            if (uniqueId != null && !uniqueId.isEmpty()) {\n                return uniqueId;\n            }\n        }\n        return hostName;\n    }", "category": "Python"}, {"instruction": "\u52a0\u5bc6\u6216\u89e3\u5bc6\u6307\u5b9a\u503c\uff0c\u8c03\u7528\u6b64\u65b9\u6cd5\u524d\u9700\u521d\u59cb\u5316\u5bc6\u94a5\n\n@param msg \u8981\u52a0\u5bc6\u6216\u89e3\u5bc6\u7684\u6d88\u606f\n@return \u52a0\u5bc6\u6216\u89e3\u5bc6\u540e\u7684\u503c", "input": "Java", "output": "public byte[] crypt(final byte[] msg) {\r\n\t\tfinal ReadLock readLock = this.lock.readLock();\r\n\t\treadLock.lock();\r\n\t\tbyte[] code;\r\n\t\ttry {\r\n\t\t\tfinal int[] sbox = this.sbox.clone();\r\n\t\t\tcode = new byte[msg.length];\r\n\t\t\tint i = 0;\r\n\t\t\tint j = 0;\r\n\t\t\tfor (int n = 0; n < msg.length; n++) {\r\n\t\t\t\ti = (i + 1) % SBOX_LENGTH;\r\n\t\t\t\tj = (j + sbox[i]) % SBOX_LENGTH;\r\n\t\t\t\tswap(i, j, sbox);\r\n\t\t\t\tint rand = sbox[(sbox[i] + sbox[j]) % SBOX_LENGTH];\r\n\t\t\t\tcode[n] = (byte) (rand ^ msg[n]);\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\treadLock.unlock();\r\n\t\t}\r\n\t\treturn code;\r\n\t}", "category": "Python"}, {"instruction": "Finds an item whose name (when referenced from the specified context) is closest to the given name.\n@param <T> the type of item being considered\n@param type same as {@code T}\n@param name the supplied name\n@param context a context to start from (used to compute relative names)\n@return the closest available item\n@since 1.538", "input": "Java", "output": "public static @CheckForNull <T extends Item> T findNearest(Class<T> type, String name, ItemGroup context) {\n        List<String> names = new ArrayList<>();\n        for (T item: Jenkins.getInstance().allItems(type)) {\n            names.add(item.getRelativeNameFrom(context));\n        }\n        String nearest = EditDistance.findNearest(name, names);\n        return Jenkins.getInstance().getItem(nearest, context, type);\n    }", "category": "Python"}, {"instruction": "\u751f\u6210\u7684Mapper\u63a5\u53e3\n\n@param interfaze\n@param topLevelClass\n@param introspectedTable\n@return", "input": "Java", "output": "@Override\n    public boolean clientGenerated(Interface interfaze, TopLevelClass topLevelClass, IntrospectedTable introspectedTable) {\n        //\u83b7\u53d6\u5b9e\u4f53\u7c7b\n        FullyQualifiedJavaType entityType = new FullyQualifiedJavaType(introspectedTable.getBaseRecordType());\n        //import\u63a5\u53e3\n        for (String mapper : mappers) {\n            interfaze.addImportedType(new FullyQualifiedJavaType(mapper));\n            interfaze.addSuperInterface(new FullyQualifiedJavaType(mapper + \"<\" + entityType.getShortName() + \">\"));\n        }\n        //import\u5b9e\u4f53\u7c7b\n        interfaze.addImportedType(entityType);\n        return true;\n    }", "category": "Python"}, {"instruction": "Inherited.", "input": "Java", "output": "public Map<String, String> parseParameters(HttpServletRequest request) {\n    Map<String, String> parameters = parseHeaderParameters(request);\n\n    if (parameters == null) {\n      //if there is no header authorization parameters, then the oauth parameters are the supported OAuth request parameters.\n      parameters = new HashMap<String, String>();\n      for (String supportedOAuthParameter : getSupportedOAuthParameters()) {\n        String param = request.getParameter(supportedOAuthParameter);\n        if (param != null) {\n          parameters.put(supportedOAuthParameter, param);\n        }\n      }\n    }\n\n    return parameters;\n  }", "category": "Python"}, {"instruction": "Optimize and condition.\n\n@return and condition", "input": "Java", "output": "public AndCondition optimize() {\n        AndCondition result = new AndCondition();\n        for (Condition each : conditions) {\n            if (Condition.class.equals(each.getClass())) {\n                result.getConditions().add(each);\n            }\n        }\n        if (result.getConditions().isEmpty()) {\n            result.getConditions().add(new NullCondition());\n        }\n        return result;\n    }", "category": "Python"}, {"instruction": "\u5224\u65ad\u6307\u5b9a\u5bf9\u8c61\u662f\u5426\u4e3a\u7a7a\uff0c\u652f\u6301\uff1a\n\n<pre>\n1. CharSequence\n2. Map\n3. Iterable\n4. Iterator\n5. Array\n</pre>\n\n@param obj \u88ab\u5224\u65ad\u7684\u5bf9\u8c61\n@return \u662f\u5426\u4e3a\u7a7a\uff0c\u5982\u679c\u7c7b\u578b\u4e0d\u652f\u6301\uff0c\u8fd4\u56defalse\n@since 4.5.7", "input": "Java", "output": "@SuppressWarnings(\"rawtypes\")\r\n\tpublic static boolean isEmpty(Object obj) {\r\n\t\tif(null == obj) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\tif(obj instanceof CharSequence) {\r\n\t\t\treturn StrUtil.isEmpty((CharSequence)obj);\r\n\t\t}else if(obj instanceof Map) {\r\n\t\t\treturn MapUtil.isEmpty((Map)obj);\r\n\t\t}else if(obj instanceof Iterable) {\r\n\t\t\treturn IterUtil.isEmpty((Iterable)obj);\r\n\t\t}else if(obj instanceof Iterator) {\r\n\t\t\treturn IterUtil.isEmpty((Iterator)obj);\r\n\t\t}else if(ArrayUtil.isArray(obj)) {\r\n\t\t\treturn ArrayUtil.isEmpty(obj);\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}", "category": "Python"}, {"instruction": "\u5904\u7406\u6392\u5e8f\n\n@param entityTable\n@param field\n@param entityColumn", "input": "Java", "output": "protected void processOrderBy(EntityTable entityTable, EntityField field, EntityColumn entityColumn) {\n        String orderBy = \"\";\n        if(field.isAnnotationPresent(OrderBy.class)){\n            orderBy = field.getAnnotation(OrderBy.class).value();\n            if (\"\".equals(orderBy)) {\n                orderBy = \"ASC\";\n            }\n            log.warn(OrderBy.class + \" is outdated, use \" + Order.class + \" instead!\");\n        }\n        if (field.isAnnotationPresent(Order.class)) {\n            Order order = field.getAnnotation(Order.class);\n            if (\"\".equals(order.value()) && \"\".equals(orderBy)) {\n                orderBy = \"ASC\";\n            } else {\n                orderBy = order.value();\n            }\n            entityColumn.setOrderPriority(order.priority());\n        }\n        if (StringUtil.isNotEmpty(orderBy)) {\n            entityColumn.setOrderBy(orderBy);\n        }\n    }", "category": "Python"}, {"instruction": "Construct document from xml string.\n\n@param xmlString the xml string\n@return the document", "input": "Java", "output": "public static Document constructDocumentFromXml(final String xmlString) {\n        try {\n            val builder = new SAXBuilder();\n            builder.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            builder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            return builder.build(new ByteArrayInputStream(xmlString.getBytes(Charset.defaultCharset())));\n        } catch (final Exception e) {\n            LOGGER.error(e.getMessage(), e);\n            return null;\n        }\n    }", "category": "Python"}, {"instruction": "The actual class name is irrelevant; this is functionally an enum.\n<p>Creating a {@code writeReplace} does not help much since XStream then just saves:\n{@code <installState class=\"jenkins.install.InstallState$CreateAdminUser\" resolves-to=\"jenkins.install.InstallState\">}\n@see #UNUSED_INNER_CLASSES\n@deprecated Should no longer be used, as {@link Jenkins} now saves only {@link #name}.", "input": "Java", "output": "@Deprecated\n    protected Object readResolve() {\n        // If we get invalid state from the configuration, fallback to unknown\n        if (StringUtils.isBlank(name)) {\n            LOGGER.log(Level.WARNING, \"Read install state with blank name: ''{0}''. It will be ignored\", name);\n            return UNKNOWN;\n        }\n        \n        InstallState state = InstallState.valueOf(name);\n        if (state == null) {\n            LOGGER.log(Level.WARNING, \"Cannot locate an extension point for the state ''{0}''. It will be ignored\", name);\n            return UNKNOWN;\n        }\n        \n        // Otherwise we return the actual state\n        return state;\n    }", "category": "Python"}, {"instruction": "Deletes an access config from an instance's network interface.\n\n<p>Sample code:\n\n<pre><code>\ntry (InstanceClient instanceClient = InstanceClient.create()) {\nProjectZoneInstanceName instance = ProjectZoneInstanceName.of(\"[PROJECT]\", \"[ZONE]\", \"[INSTANCE]\");\nString networkInterface = \"\";\nString accessConfig = \"\";\nOperation response = instanceClient.deleteAccessConfigInstance(instance, networkInterface, accessConfig);\n}\n</code></pre>\n\n@param instance The instance name for this request.\n@param networkInterface The name of the network interface.\n@param accessConfig The name of the access config to delete.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation deleteAccessConfigInstance(\n      ProjectZoneInstanceName instance, String networkInterface, String accessConfig) {\n\n    DeleteAccessConfigInstanceHttpRequest request =\n        DeleteAccessConfigInstanceHttpRequest.newBuilder()\n            .setInstance(instance == null ? null : instance.toString())\n            .setNetworkInterface(networkInterface)\n            .setAccessConfig(accessConfig)\n            .build();\n    return deleteAccessConfigInstance(request);\n  }", "category": "Python"}, {"instruction": "Inserts or aggregates a value into the hash map. If the hash map does not yet contain the key,\nthis method inserts the value. If the table already contains the key (and a value) this\nmethod will use the given ReduceFunction function to combine the existing value and the\ngiven value to a new value, and store that value for the key.\n\n@param key The key to map the value.\n@param value The new value to insert, or aggregate with the existing value.\n@param aggregator The aggregator to use if a value is already contained.\n\n@return The value in the map after this operation: Either the given value, or the aggregated value.\n\n@throws java.lang.NullPointerException Thrown, if the key is null.\n@throws Exception The method forwards exceptions from the aggregation function.", "input": "Java", "output": "public final V putOrAggregate(K key, V value, ReduceFunction<V> aggregator) throws Exception {\n\t\tfinal int hash = hash(key);\n\t\tfinal int slot = indexOf(hash);\n\n\t\t// search the chain from the slot\n\t\tfor (Entry<K, V> entry = table[slot]; entry != null; entry = entry.next) {\n\t\t\tif (entry.hashCode == hash && entry.key.equals(key)) {\n\t\t\t\t// found match\n\t\t\t\tentry.value = aggregator.reduce(entry.value, value);\n\t\t\t\treturn entry.value;\n\t\t\t}\n\t\t}\n\n\t\t// no match, insert a new value\n\t\tinsertNewEntry(hash, key, value, slot);\n\t\t// return the original value\n\t\treturn value;\n\t}", "category": "Python"}, {"instruction": "GRPC_PROXY_EXP is deprecated but let's maintain compatibility for now.", "input": "Java", "output": "private static InetSocketAddress overrideProxy(String proxyHostPort) {\n    if (proxyHostPort == null) {\n      return null;\n    }\n\n    String[] parts = proxyHostPort.split(\":\", 2);\n    int port = 80;\n    if (parts.length > 1) {\n      port = Integer.parseInt(parts[1]);\n    }\n    log.warning(\n        \"Detected GRPC_PROXY_EXP and will honor it, but this feature will \"\n            + \"be removed in a future release. Use the JVM flags \"\n            + \"\\\"-Dhttps.proxyHost=HOST -Dhttps.proxyPort=PORT\\\" to set the https proxy for \"\n            + \"this JVM.\");\n    return new InetSocketAddress(parts[0], port);\n  }", "category": "Python"}, {"instruction": "\u9a8c\u8bc110\u4f4d\u8eab\u4efd\u7f16\u7801\u662f\u5426\u5408\u6cd5\n\n@param idCard \u8eab\u4efd\u7f16\u7801\n@return \u8eab\u4efd\u8bc1\u4fe1\u606f\u6570\u7ec4\n<p>\n[0] - \u53f0\u6e7e\u3001\u6fb3\u95e8\u3001\u9999\u6e2f [1] - \u6027\u522b(\u7537M,\u5973F,\u672a\u77e5N) [2] - \u662f\u5426\u5408\u6cd5(\u5408\u6cd5true,\u4e0d\u5408\u6cd5false) \u82e5\u4e0d\u662f\u8eab\u4efd\u8bc1\u4ef6\u53f7\u7801\u5219\u8fd4\u56denull\n</p>", "input": "Java", "output": "public static String[] isValidCard10(String idCard) {\r\n\t\tif(StrUtil.isBlank(idCard)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tString[] info = new String[3];\r\n\t\tString card = idCard.replaceAll(\"[\\\\(|\\\\)]\", \"\");\r\n\t\tif (card.length() != 8 && card.length() != 9 && idCard.length() != 10) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (idCard.matches(\"^[a-zA-Z][0-9]{9}$\")) { // \u53f0\u6e7e\r\n\t\t\tinfo[0] = \"\u53f0\u6e7e\";\r\n\t\t\tString char2 = idCard.substring(1, 2);\r\n\t\t\tif (char2.equals(\"1\")) {\r\n\t\t\t\tinfo[1] = \"M\";\r\n\t\t\t} else if (char2.equals(\"2\")) {\r\n\t\t\t\tinfo[1] = \"F\";\r\n\t\t\t} else {\r\n\t\t\t\tinfo[1] = \"N\";\r\n\t\t\t\tinfo[2] = \"false\";\r\n\t\t\t\treturn info;\r\n\t\t\t}\r\n\t\t\tinfo[2] = isValidTWCard(idCard) ? \"true\" : \"false\";\r\n\t\t} else if (idCard.matches(\"^[1|5|7][0-9]{6}\\\\(?[0-9A-Z]\\\\)?$\")) { // \u6fb3\u95e8\r\n\t\t\tinfo[0] = \"\u6fb3\u95e8\";\r\n\t\t\tinfo[1] = \"N\";\r\n\t\t} else if (idCard.matches(\"^[A-Z]{1,2}[0-9]{6}\\\\(?[0-9A]\\\\)?$\")) { // \u9999\u6e2f\r\n\t\t\tinfo[0] = \"\u9999\u6e2f\";\r\n\t\t\tinfo[1] = \"N\";\r\n\t\t\tinfo[2] = isValidHKCard(idCard) ? \"true\" : \"false\";\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn info;\r\n\t}", "category": "Python"}, {"instruction": "Sets the negotiation type for the HTTP/2 connection.\n\n<p>If TLS is enabled a default {@link SSLSocketFactory} is created using the best\n{@link java.security.Provider} available and is NOT based on\n{@link SSLSocketFactory#getDefault}. To more precisely control the TLS configuration call\n{@link #sslSocketFactory} to override the socket factory used.\n\n<p>Default: <code>TLS</code>\n\n@deprecated use {@link #usePlaintext()} or {@link #useTransportSecurity()} instead.", "input": "Java", "output": "@Deprecated\n  public final OkHttpChannelBuilder negotiationType(io.grpc.okhttp.NegotiationType type) {\n    Preconditions.checkNotNull(type, \"type\");\n    switch (type) {\n      case TLS:\n        negotiationType = NegotiationType.TLS;\n        break;\n      case PLAINTEXT:\n        negotiationType = NegotiationType.PLAINTEXT;\n        break;\n      default:\n        throw new AssertionError(\"Unknown negotiation type: \" + type);\n    }\n    return this;\n  }", "category": "Python"}, {"instruction": "Sets the loaded active scan rules of the add-on, allowing to set the status of the active scan rules appropriately and to\nkeep track of the active scan rules loaded so that they can be removed during uninstallation.\n<p>\n<strong>Note:</strong> Helper method to be used (only) by/during (un)installation process and loading of the add-on.\nShould be called when installing/loading the add-on, by setting the loaded active scan rules, and when uninstalling by\nsetting an empty list. The method {@code setLoadedAscanrulesSet(boolean)} should also be called.\n\n@param ascanrules the active scan rules loaded, might be empty if none were actually loaded\n@throws IllegalArgumentException if {@code ascanrules} is {@code null}.\n@since 2.4.3\n@see #setLoadedAscanrulesSet(boolean)\n@see AbstractPlugin#setStatus(Status)", "input": "Java", "output": "void setLoadedAscanrules(List<AbstractPlugin> ascanrules) {\r\n\t\tif (ascanrules == null) {\r\n\t\t\tthrow new IllegalArgumentException(\"Parameter ascanrules must not be null.\");\r\n\t\t}\r\n\r\n\t\tif (ascanrules.isEmpty()) {\r\n\t\t\tloadedAscanrules = Collections.emptyList();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor (AbstractPlugin ascanrule : ascanrules) {\r\n\t\t\tascanrule.setStatus(getStatus());\r\n\t\t}\r\n\t\tloadedAscanrules = Collections.unmodifiableList(new ArrayList<>(ascanrules));\r\n\t}", "category": "Python"}, {"instruction": "Returns value of network address cache ttl property if not Android environment. For android,\nDnsNameResolver does not cache the dns lookup result.", "input": "Java", "output": "private static long getNetworkAddressCacheTtlNanos(boolean isAndroid) {\n    if (isAndroid) {\n      // on Android, ignore dns cache.\n      return 0;\n    }\n\n    String cacheTtlPropertyValue = System.getProperty(NETWORKADDRESS_CACHE_TTL_PROPERTY);\n    long cacheTtl = DEFAULT_NETWORK_CACHE_TTL_SECONDS;\n    if (cacheTtlPropertyValue != null) {\n      try {\n        cacheTtl = Long.parseLong(cacheTtlPropertyValue);\n      } catch (NumberFormatException e) {\n        logger.log(\n            Level.WARNING,\n            \"Property({0}) valid is not valid number format({1}), fall back to default({2})\",\n            new Object[] {NETWORKADDRESS_CACHE_TTL_PROPERTY, cacheTtlPropertyValue, cacheTtl});\n      }\n    }\n    return cacheTtl > 0 ? TimeUnit.SECONDS.toNanos(cacheTtl) : cacheTtl;\n  }", "category": "Python"}, {"instruction": "Sets the new policy.\n\n@param policy\nthe new policy\n\n@throws NullPointerException\nif policy is {@code null}\n\n@see UndoManagerPolicy", "input": "Java", "output": "public final void setUndoManagerPolicy(UndoManagerPolicy policy) throws NullPointerException {\n\t\tif (policy == null) {\n\t\t\tthrow new NullPointerException(\"The policy must not be null.\");\n\t\t}\n\t\t\n\t\tif (this.policy == policy) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal UndoManagerPolicy oldPolicy = this.policy;\n\t\tthis.policy = policy;\n\t\t\n\t\tif (oldPolicy == UndoManagerPolicy.DEFAULT) {\n\t\t\tthis.textComponent.removePropertyChangeListener(\"editable\", this);\n\t\t\tthis.textComponent.removePropertyChangeListener(\"enabled\", this);\n\t\t}\n\n\t\tif (this.policy == UndoManagerPolicy.DEFAULT) {\n\t\t\tthis.textComponent.addPropertyChangeListener(\"editable\", this);\n\t\t\tthis.textComponent.addPropertyChangeListener(\"enabled\", this);\n\t\t}\n\n\t\thandleUndoManagerPolicy();\n\t}", "category": "Python"}, {"instruction": "Delete file or folder.\n\n@param file file.\n\n@return is succeed.\n\n@see #delFileOrFolder(String)", "input": "Java", "output": "public static boolean delFileOrFolder(File file) {\n        if (file == null || !file.exists()) {\n            // do nothing\n        } else if (file.isFile()) {\n            file.delete();\n        } else if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            if (files != null) {\n                for (File sonFile : files) {\n                    delFileOrFolder(sonFile);\n                }\n            }\n            file.delete();\n        }\n        return true;\n    }", "category": "Python"}, {"instruction": "\u5f3a\u884c\u6dfb\u52a0\uff0c\u66ff\u6362\u5df2\u6709\u7684\u9876\u70b9\n\n@param line\n@param vertex", "input": "Java", "output": "public void push(int line, Vertex vertex)\n    {\n        Iterator<Vertex> iterator = vertexes[line].iterator();\n        while (iterator.hasNext())\n        {\n            if (iterator.next().realWord.length() == vertex.realWord.length())\n            {\n                iterator.remove();\n                --size;\n                break;\n            }\n        }\n        vertexes[line].add(vertex);\n        ++size;\n    }", "category": "Python"}, {"instruction": "Generic method to plan a {@link Runnable}.", "input": "Java", "output": "@Override\n    public void planOperation(Runnable operation) {\n        operations.add(operation);\n\n        if (operation instanceof AbstractOperation) {\n            ExecutionEntity execution = ((AbstractOperation) operation).getExecution();\n            if (execution != null) {\n                commandContext.addInvolvedExecution(execution);\n            }\n        }\n\n        logger.debug(\"Operation {} added to agenda\", operation.getClass());\n    }", "category": "Python"}, {"instruction": "/*\nWhen the connection fails - send exit to all local pids with links\nthrough this connection", "input": "Java", "output": "synchronized void breakLinks() {\n        if (links != null) {\n            final Link[] l = links.clearLinks();\n\n            if (l != null) {\n                final int len = l.length;\n\n                for (int i = 0; i < len; i++) {\n                    // send exit \"from\" remote pids to local ones\n                    self.deliver(new OtpMsg(OtpMsg.exitTag, l[i].remote(), l[i]\n                            .local(), new OtpErlangAtom(\"noconnection\")));\n                }\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Setup with direct executors, small payloads and the default flow-control window.", "input": "Java", "output": "@Setup(Level.Trial)\n  public void setup() throws Exception {\n    super.setup(clientExecutor,\n        ExecutorType.DIRECT,\n        MessageSize.SMALL,\n        responseSize,\n        FlowWindowSize.MEDIUM,\n        ChannelType.NIO,\n        maxConcurrentStreams,\n        channelCount);\n    callCounter = new AtomicLong();\n    completed = new AtomicBoolean();\n    record = new AtomicBoolean();\n    latch =\n        startFlowControlledStreamingCalls(maxConcurrentStreams, callCounter, record, completed, 1);\n  }", "category": "Python"}, {"instruction": "Helper method for getDownstreamRelationship.\n\nFor each given build, find the build number range of the given project and put that into the map.", "input": "Java", "output": "private void checkAndRecord(AbstractProject that, TreeMap<Integer, RangeSet> r, Collection<R> builds) {\n        for (R build : builds) {\n            RangeSet rs = build.getDownstreamRelationship(that);\n            if(rs==null || rs.isEmpty())\n                continue;\n\n            int n = build.getNumber();\n\n            RangeSet value = r.get(n);\n            if(value==null)\n                r.put(n,rs);\n            else\n                value.add(rs);\n        }\n    }", "category": "Python"}, {"instruction": "Parse insert values.\n\n@param insertStatement insert statement", "input": "Java", "output": "public void parse(final InsertStatement insertStatement) {\n        Collection<Keyword> valueKeywords = new LinkedList<>();\n        valueKeywords.add(DefaultKeyword.VALUES);\n        valueKeywords.addAll(Arrays.asList(getSynonymousKeywordsForValues()));\n        if (lexerEngine.skipIfEqual(valueKeywords.toArray(new Keyword[valueKeywords.size()]))) {\n            parseValues(insertStatement);\n        }\n    }", "category": "Python"}, {"instruction": "Does any of the plugin has updates?", "input": "Java", "output": "@Exported\n    public boolean hasUpdates() {\n        Data data = getData();\n        if(data==null)      return false;\n        \n        for (PluginWrapper pw : Jenkins.getInstance().getPluginManager().getPlugins()) {\n            if(!pw.isBundled() && pw.getUpdateInfo()!=null)\n                // do not advertize updates to bundled plugins, since we generally want users to get them\n                // as a part of jenkins.war updates. This also avoids unnecessary pinning of plugins. \n                return true;\n        }\n        return false;\n    }", "category": "Python"}, {"instruction": "Identical to calling {@code #releaseExceptionally(Exception); #reset()} except it is atomic.\n@param e The exception to fail all waiting futures with.", "input": "Java", "output": "public void releaseExceptionallyAndReset(Throwable e) {\n        ArrayList<CompletableFuture<T>> toComplete = null;\n        synchronized (lock) {\n            if (!waitingFutures.isEmpty()) {\n                toComplete = new ArrayList<>(waitingFutures);\n                waitingFutures.clear();\n            }\n            released = false;\n            this.e = null;\n            result = null;\n            runningThreadId = null;\n        }\n        if (toComplete != null) {\n            for (CompletableFuture<T> f : toComplete) {\n                f.completeExceptionally(e);\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Writes the JSON for {@code jsonElement} to {@code writer}.\n@throws JsonIOException if there was a problem writing to the writer", "input": "Java", "output": "public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOException {\n    boolean oldLenient = writer.isLenient();\n    writer.setLenient(true);\n    boolean oldHtmlSafe = writer.isHtmlSafe();\n    writer.setHtmlSafe(htmlSafe);\n    boolean oldSerializeNulls = writer.getSerializeNulls();\n    writer.setSerializeNulls(serializeNulls);\n    try {\n      Streams.write(jsonElement, writer);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    } catch (AssertionError e) {\n      AssertionError error = new AssertionError(\"AssertionError (GSON \" + GsonBuildConfig.VERSION + \"): \" + e.getMessage());\n      error.initCause(e);\n      throw error;\n    } finally {\n      writer.setLenient(oldLenient);\n      writer.setHtmlSafe(oldHtmlSafe);\n      writer.setSerializeNulls(oldSerializeNulls);\n    }\n  }", "category": "Python"}, {"instruction": "Downloads this blob to the given file path using specified blob read options.\n\n@param path destination\n@param options blob read options\n@throws StorageException upon failure", "input": "Java", "output": "public void downloadTo(Path path, BlobSourceOption... options) {\n    try (OutputStream outputStream = Files.newOutputStream(path);\n        ReadChannel reader = reader(options)) {\n      WritableByteChannel channel = Channels.newChannel(outputStream);\n      ByteBuffer bytes = ByteBuffer.allocate(DEFAULT_CHUNK_SIZE);\n      while (reader.read(bytes) > 0) {\n        bytes.flip();\n        channel.write(bytes);\n        bytes.clear();\n      }\n    } catch (IOException e) {\n      throw new StorageException(e);\n    }\n  }", "category": "Python"}, {"instruction": "TODO: almost identical to ModelsHandler; refactor", "input": "Java", "output": "public static ModelMetrics getFromDKV(Key key) {\n    if (null == key)\n      throw new IllegalArgumentException(\"Got null key.\");\n\n    Value v = DKV.get(key);\n    if (null == v)\n      throw new IllegalArgumentException(\"Did not find key: \" + key.toString());\n\n    Iced ice = v.get();\n    if (! (ice instanceof ModelMetrics))\n      throw new IllegalArgumentException(\"Expected a Model for key: \" + key.toString() + \"; got a: \" + ice.getClass());\n\n    return (ModelMetrics)ice;\n  }", "category": "Python"}, {"instruction": "\u5c06setting\u4e2d\u7684\u952e\u503c\u5173\u7cfb\u6620\u5c04\u5230\u5bf9\u8c61\u4e2d\uff0c\u539f\u7406\u662f\u8c03\u7528\u5bf9\u8c61\u5bf9\u5e94\u7684set\u65b9\u6cd5<br>\n\u53ea\u652f\u6301\u57fa\u672c\u7c7b\u578b\u7684\u8f6c\u6362\n\n@param group \u5206\u7ec4\n@param bean Bean\u5bf9\u8c61\n@return Bean", "input": "Java", "output": "public Object toBean(final String group, Object bean) {\r\n\t\treturn BeanUtil.fillBean(bean, new ValueProvider<String>(){\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic Object value(String key, Type valueType) {\r\n\t\t\t\tfinal String value = getByGroup(key, group);\r\n//\t\t\t\tif (null != value) {\r\n//\t\t\t\t\tlog.debug(\"Parse setting to object field [{}={}]\", key, value);\r\n//\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean containsKey(String key) {\r\n\t\t\t\treturn null != getByGroup(key, group);\r\n\t\t\t}\r\n\t\t}, CopyOptions.create());\r\n\t}", "category": "Python"}, {"instruction": "Instantiates a user code class from is definition in the task configuration.\nThe class is instantiated without arguments using the null-ary constructor. Instantiation\nwill fail if this constructor does not exist or is not public.\n\n@param <T> The generic type of the user code class.\n@param config The task configuration containing the class description.\n@param cl The class loader to be used to load the class.\n@param superClass The super class that the user code class extends or implements, for type checking.\n\n@return An instance of the user code class.", "input": "Java", "output": "public static <T> T instantiateUserCode(TaskConfig config, ClassLoader cl, Class<? super T> superClass) {\n\t\ttry {\n\t\t\tT stub = config.<T>getStubWrapper(cl).getUserCodeObject(superClass, cl);\n\t\t\t// check if the class is a subclass, if the check is required\n\t\t\tif (superClass != null && !superClass.isAssignableFrom(stub.getClass())) {\n\t\t\t\tthrow new RuntimeException(\"The class '\" + stub.getClass().getName() + \"' is not a subclass of '\" + \n\t\t\t\t\t\tsuperClass.getName() + \"' as is required.\");\n\t\t\t}\n\t\t\treturn stub;\n\t\t}\n\t\tcatch (ClassCastException ccex) {\n\t\t\tthrow new RuntimeException(\"The UDF class is not a proper subclass of \" + superClass.getName(), ccex);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "This method initializes this", "input": "Java", "output": "private  void initialize() {\r\n\t\thistoryListFiltersButtonGroup = new DeselectableButtonGroup();\r\n\r\n\t\tthis.setLayout(new BorderLayout());\r\n\t    if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {\r\n\t    \tthis.setSize(600, 200);\r\n\t    }\r\n\t\tthis.add(getHistoryPanel(), java.awt.BorderLayout.CENTER);\r\n\t\t\r\n\t\tthis.setDefaultAccelerator(view.getMenuShortcutKeyStroke(KeyEvent.VK_H, KeyEvent.SHIFT_DOWN_MASK, false));\r\n\t\tthis.setMnemonic(Constant.messages.getChar(\"history.panel.mnemonic\"));\r\n\t\t\r\n\t}", "category": "Python"}, {"instruction": "Set the state of the RNN layer, for use in {@link #rnnTimeStep(INDArray...)}\n\n@param layerName The name of the layer.\n@param state     The state to set the specified layer to", "input": "Java", "output": "public void rnnSetPreviousState(String layerName, Map<String, INDArray> state) {\n        Layer l = verticesMap.get(layerName).getLayer();\n        if(l instanceof org.deeplearning4j.nn.layers.wrapper.BaseWrapperLayer){\n            l = ((org.deeplearning4j.nn.layers.wrapper.BaseWrapperLayer)l).getUnderlying();\n        }\n        if (l == null || !(l instanceof RecurrentLayer)) {\n            throw new UnsupportedOperationException(\n                    \"Layer \\\"\" + layerName + \"\\\" is not a recurrent layer. Cannot set state\");\n        }\n        ((RecurrentLayer) l).rnnSetPreviousState(state);\n    }", "category": "Python"}, {"instruction": "\u83b7\u5f97\u4e00\u4e2a\u65b0\u7684\u7ebf\u7a0b\u6c60<br>\n\u4f20\u5165\u963b\u585e\u7cfb\u6570\uff0c\u7ebf\u7a0b\u6c60\u7684\u5927\u5c0f\u8ba1\u7b97\u516c\u5f0f\u4e3a\uff1aCPU\u53ef\u7528\u6838\u5fc3\u6570 / (1 - \u963b\u585e\u56e0\u5b50)<br>\nBlocking Coefficient(\u963b\u585e\u7cfb\u6570) = \u963b\u585e\u65f6\u95f4\uff0f\uff08\u963b\u585e\u65f6\u95f4+\u4f7f\u7528CPU\u7684\u65f6\u95f4\uff09<br>\n\u8ba1\u7b97\u5bc6\u96c6\u578b\u4efb\u52a1\u7684\u963b\u585e\u7cfb\u6570\u4e3a0\uff0c\u800cIO\u5bc6\u96c6\u578b\u4efb\u52a1\u7684\u963b\u585e\u7cfb\u6570\u5219\u63a5\u8fd1\u4e8e1\u3002\n\nsee: http://blog.csdn.net/partner4java/article/details/9417663\n\n@param blockingCoefficient \u963b\u585e\u7cfb\u6570\uff0c\u963b\u585e\u56e0\u5b50\u4ecb\u4e8e0~1\u4e4b\u95f4\u7684\u6570\uff0c\u963b\u585e\u56e0\u5b50\u8d8a\u5927\uff0c\u7ebf\u7a0b\u6c60\u4e2d\u7684\u7ebf\u7a0b\u6570\u8d8a\u591a\u3002\n@return {@link ThreadPoolExecutor}\n@since 3.0.6", "input": "Java", "output": "public static ThreadPoolExecutor newExecutorByBlockingCoefficient(float blockingCoefficient) {\r\n\t\tif (blockingCoefficient >= 1 || blockingCoefficient < 0) {\r\n\t\t\tthrow new IllegalArgumentException(\"[blockingCoefficient] must between 0 and 1, or equals 0.\");\r\n\t\t}\r\n\r\n\t\t// \u6700\u4f73\u7684\u7ebf\u7a0b\u6570 = CPU\u53ef\u7528\u6838\u5fc3\u6570 / (1 - \u963b\u585e\u7cfb\u6570)\r\n\t\tint poolSize = (int) (Runtime.getRuntime().availableProcessors() / (1 - blockingCoefficient));\r\n\t\treturn ExecutorBuilder.create().setCorePoolSize(poolSize).setMaxPoolSize(poolSize).setKeepAliveTime(0L).build();\r\n\t}", "category": "Python"}, {"instruction": "Read and parse data from /proc/stat and /proc/&lt;pid&gt;/stat.\nIf this doesn't work for some reason, the values will be -1.", "input": "Java", "output": "public void read() {\n    String pid = \"-1\";\n    try {\n      pid = getProcessId();\n      _pid = pid;\n    }\n    catch (Exception ignore) {}\n\n    File f = new File (\"/proc/stat\");\n    if (! f.exists()) {\n      return;\n    }\n\n    try {\n      readSystemProcFile();\n      readProcessProcFile(pid);\n      readProcessNumOpenFds(pid);\n      readProcessStatusFile(pid);\n      parseSystemProcFile(_systemData);\n      parseProcessProcFile(_processData);\n      parseProcessStatusFile(_processStatus);\n    }\n    catch (Exception ignore) {}\n  }", "category": "Python"}, {"instruction": "Store object into storage\n\n@param key\n@param object", "input": "Java", "output": "@Override\n    public void store(T key, INDArray object) {\n        INDArray toStore;\n        if (useInplaceCompression) {\n            compressor.compressi(object);\n            toStore = object;\n        } else {\n            toStore = compressor.compress(object);\n        }\n\n        if (emulateIsAbsent)\n            lock.writeLock().lock();\n\n        compressedEntries.put(key, toStore);\n\n        if (emulateIsAbsent)\n            lock.writeLock().unlock();\n    }", "category": "Python"}, {"instruction": "Compute the broadcast rules according to:\nhttps://docs.scipy.org/doc/numpy-1.10.1/user/basics.broadcasting.html\n\nNote that the array can be null if the arrays are already equal\nin shape.\n\nThis function should be used in conjunction with\nthe shape ops.\n\n@param left the left array\n@param right the right array (the array to be broadcasted\n@return the broadcast dimensions if any", "input": "Java", "output": "public static int[] getBroadcastDimensions(int[] left,int[] right) {\n        if(Arrays.equals(left,right))\n            return null;\n\n        int n = Math.min(left.length,right.length);\n        List<Integer> dims = new ArrayList<>();\n        int leftIdx = left.length - 1;\n        int rightIdx = right.length - 1;\n        for(int i = n - 1; i >= 0; i--) {\n            if(left[leftIdx] != right[rightIdx] && right[rightIdx] == 1 || left[leftIdx] == 1) {\n                dims.add(i);\n            }\n            else if(left[leftIdx] != right[rightIdx]) {\n                throw new IllegalArgumentException(\"Unable to broadcast dimension \" + i + \" due to shape mismatch. Right shape must be 1. \"\n                        + \"Left array shape: \" + Arrays.toString(left) + \", right array shape: \" + Arrays.toString(right));\n            }\n\n            leftIdx--;\n            rightIdx--;\n        }\n\n        Collections.reverse(dims);\n        return Ints.toArray(dims);\n    }", "category": "Python"}, {"instruction": "Update the internal state of RNN layers after a truncated BPTT fit call", "input": "Java", "output": "protected void rnnUpdateStateWithTBPTTState() {\n        for (int i = 0; i < layers.length; i++) {\n            if (layers[i] instanceof RecurrentLayer) {\n                RecurrentLayer l = ((RecurrentLayer) layers[i]);\n                l.rnnSetPreviousState(l.rnnGetTBPTTState());\n            } else if (layers[i] instanceof MultiLayerNetwork) {\n                ((MultiLayerNetwork) layers[i]).updateRnnStateWithTBPTTState();\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Gets a list of {@link AccumuloColumnConstraint} based on the given constraint ID, excluding the row ID column\n\n@param rowIdName Presto column name mapping to the Accumulo row ID\n@param constraint Set of query constraints\n@return List of all column constraints", "input": "Java", "output": "private static List<AccumuloColumnConstraint> getColumnConstraints(String rowIdName, TupleDomain<ColumnHandle> constraint)\n    {\n        ImmutableList.Builder<AccumuloColumnConstraint> constraintBuilder = ImmutableList.builder();\n        for (ColumnDomain<ColumnHandle> columnDomain : constraint.getColumnDomains().get()) {\n            AccumuloColumnHandle columnHandle = (AccumuloColumnHandle) columnDomain.getColumn();\n\n            if (!columnHandle.getName().equals(rowIdName)) {\n                // Family and qualifier will exist for non-row ID columns\n                constraintBuilder.add(new AccumuloColumnConstraint(\n                        columnHandle.getName(),\n                        columnHandle.getFamily().get(),\n                        columnHandle.getQualifier().get(),\n                        Optional.of(columnDomain.getDomain()),\n                        columnHandle.isIndexed()));\n            }\n        }\n\n        return constraintBuilder.build();\n    }", "category": "Python"}, {"instruction": "Convert a string representing a decimal value to a long.\n\nIf the decimal value is not an exact integral value (e.g. 42.0), or if the decimal value\nis too large to be contained within a long, this function returns null.\n\n@param decimalStr string representing a decimal value\n\n@return long equivalent of decimalStr, returns null for non-integral decimals and integral decimal values outside\nof the values representable by longs", "input": "Java", "output": "@Nullable\n  public static Long getExactLongFromDecimalString(String decimalStr)\n  {\n    final Long val = GuavaUtils.tryParseLong(decimalStr);\n    if (val != null) {\n      return val;\n    }\n\n    BigDecimal convertedBD;\n    try {\n      convertedBD = new BigDecimal(decimalStr);\n    }\n    catch (NumberFormatException nfe) {\n      return null;\n    }\n\n    try {\n      return convertedBD.longValueExact();\n    }\n    catch (ArithmeticException ae) {\n      // indicates there was a non-integral part, or the BigDecimal was too big for a long\n      return null;\n    }\n  }", "category": "Python"}, {"instruction": "Deselect all options that display text matching the argument. That is, when given \"Bar\" this\nwould deselect an option like:\n\n&lt;option value=\"foo\"&gt;Bar&lt;/option&gt;\n\n@param text The visible text to match against\n@throws NoSuchElementException If no matching option elements are found\n@throws UnsupportedOperationException If the SELECT does not support multiple selections", "input": "Java", "output": "@Override\n  public void deselectByVisibleText(String text) {\n    if (!isMultiple()) {\n      throw new UnsupportedOperationException(\n        \"You may only deselect options of a multi-select\");\n    }\n\n    List<WebElement> options = element.findElements(By.xpath(\n      \".//option[normalize-space(.) = \" + Quotes.escape(text) + \"]\"));\n    if (options.isEmpty()) {\n      throw new NoSuchElementException(\"Cannot locate option with text: \" + text);\n    }\n\n    for (WebElement option : options) {\n      setSelected(option, false);\n    }\n  }", "category": "Python"}, {"instruction": "Returns an AggregatorFactory that can be used to combine the output of aggregators from this factory and\nanother factory. It is used when we have some values produced by this aggregator factory, and some values produced\nby the \"other\" aggregator factory, and we want to do some additional combining of them. This happens, for example,\nwhen compacting two segments together that both have a metric column with the same name. (Even though the name of\nthe column is the same, the aggregator factory used to create it may be different from segment to segment.)\n\nThis method may throw {@link AggregatorFactoryNotMergeableException}, meaning that \"this\" and \"other\" are not\ncompatible and values from one cannot sensibly be combined with values from the other.\n\n@return a new Factory that can be used for merging the output of aggregators from this factory and other.\n\n@see #getCombiningFactory() which is equivalent to {@code foo.getMergingFactory(foo)} (when \"this\" and \"other\"\nare the same instance).", "input": "Java", "output": "public AggregatorFactory getMergingFactory(AggregatorFactory other) throws AggregatorFactoryNotMergeableException\n  {\n    final AggregatorFactory combiningFactory = this.getCombiningFactory();\n    if (other.getName().equals(this.getName()) && combiningFactory.equals(other.getCombiningFactory())) {\n      return combiningFactory;\n    } else {\n      throw new AggregatorFactoryNotMergeableException(this, other);\n    }\n  }", "category": "Python"}, {"instruction": "Called once the changelog is determined.\n\n<p>\nDuring a build, Jenkins fetches the update of the workspace from SCM,\nand determines the changelog (see {@link SCM#checkout}). Immediately\nafter that, a build will invoke this method on all registered\n{@link SCMListener}s.\n\n<p>\nIf a build failed before we successfully determine changelog, this method\nwill not be invoked (for example, if \"cvs update\" failed.) OTOH, this method\nis invoked before the actual build (like ant invocation) happens.\n\n<p>\nThis is an opportunity for SCM-related plugins to act on changelog.\nA typical usage includes parsing commit messages and do cross-referencing\nbetween other systems. Implementations can also contribute {@link Action}\nto {@link AbstractBuild} (by {@code build.getActions().add(...)} to\ndisplay additional data on build views.\n\n<p>\nTODO: once we have cvsnews plugin, refer to its usage.\n\n@param build\nThe build in progress, which just finished determining changelog.\nAt this point this build is still in progress. Never null.\n@param listener\n{@link BuildListener} for on-going build. This can be used to report\nany errors or the general logging of what's going on. This will show\nup in the \"console output\" of the build. Never null.\n@param changelog\nSet of changes detected in this build. This is the same value\nreturned from {@link AbstractBuild#getChangeSet()} but passed\nseparately for convenience.\n\n@throws Exception\nIf any exception is thrown from this method, it will be recorded\nand causes the build to fail.\n@since 1.568", "input": "Java", "output": "public void onChangeLogParsed(Run<?,?> build, SCM scm, TaskListener listener, ChangeLogSet<?> changelog) throws Exception {\n        if (build instanceof AbstractBuild && listener instanceof BuildListener && Util.isOverridden(SCMListener.class, getClass(), \"onChangeLogParsed\", AbstractBuild.class, BuildListener.class, ChangeLogSet.class)) {\n            onChangeLogParsed((AbstractBuild) build, (BuildListener) listener, changelog);\n        }\n    }", "category": "Python"}, {"instruction": "reads, plus computes rows-per-chunk, min/max/mean, etc.", "input": "Java", "output": "public Vec close(int rowLayout, Futures fs) {\n    // Compute #chunks\n    int nchunk = _tmp_espc.length;\n    DKV.remove(chunkKey(nchunk),fs); // remove potential trailing key\n    while( nchunk > 1 && _tmp_espc[nchunk-1] == 0 ) {\n      nchunk--;\n      DKV.remove(chunkKey(nchunk),fs); // remove potential trailing key\n    }\n\n    // Replacement plain Vec for AppendableVec.\n    Vec vec = new Vec(_key, rowLayout, domain(), _type);\n    DKV.put(_key,vec,fs);       // Inject the header into the K/V store\n    return vec;\n  }", "category": "Python"}, {"instruction": "Retrieves the property of the given object and returns it as a list of {@link JSONObject}.\n\n<p>\nIf the value doesn't exist, this method returns an empty list. If the value is\na {@link JSONObject}, this method will return a singleton list. If it's a {@link JSONArray},\nthe contents will be returned as a list.\n\n<p>\nBecause of the way structured form submission work, this is convenient way of\nhandling repeated multi-value entries.\n\n@since 1.233", "input": "Java", "output": "public static List<JSONObject> toList(JSONObject parent, String propertyName) {\n        Object v = parent.get(propertyName);\n        if(v==null)\n            return Collections.emptyList();\n        if(v instanceof JSONObject)\n            return Collections.singletonList((JSONObject)v);\n        if(v instanceof JSONArray)\n            return (List)(JSONArray)v;\n\n        throw new IllegalArgumentException();\n    }", "category": "Python"}, {"instruction": "Turn the arguments into a list.\n\n@param args the args\n@return the string[]", "input": "Java", "output": "private static String[] toResources(final Object[] args) {\n        val object = args[0];\n        if (object instanceof AuthenticationTransaction) {\n            val transaction = AuthenticationTransaction.class.cast(object);\n            return new String[]{SUPPLIED_CREDENTIALS + transaction.getCredentials()};\n        }\n        return new String[]{SUPPLIED_CREDENTIALS + CollectionUtils.wrap(object)};\n    }", "category": "Python"}, {"instruction": "Signallable activity behavior", "input": "Java", "output": "public void trigger(DelegateExecution execution, String signalName, Object signalData) {\n    if (activityBehaviorInstance == null) {\n      activityBehaviorInstance = getActivityBehaviorInstance();\n    }\n\n    if (activityBehaviorInstance instanceof TriggerableActivityBehavior) {\n      ((TriggerableActivityBehavior) activityBehaviorInstance).trigger(execution, signalName, signalData);\n    } else {\n      throw new ActivitiException(\"signal() can only be called on a \" + TriggerableActivityBehavior.class.getName() + \" instance\");\n    }\n  }", "category": "Python"}, {"instruction": "\u63d2\u5165\u4e00\u4e2a\u8bcd\n\n@param key\n@param value", "input": "Java", "output": "public void put(String key, V value)\n    {\n        if (key.length() == 0) return;  // \u5b89\u5168\u8d77\u89c1\n        BaseNode branch = this;\n        char[] chars = key.toCharArray();\n        for (int i = 0; i < chars.length - 1; ++i)\n        {\n            // \u9664\u4e86\u6700\u540e\u4e00\u4e2a\u5b57\u5916\uff0c\u90fd\u662f\u7ee7\u7eed\n            branch.addChild(new Node(chars[i], Status.NOT_WORD_1, null));\n            branch = branch.getChild(chars[i]);\n        }\n        // \u6700\u540e\u4e00\u4e2a\u5b57\u52a0\u5165\u65f6\u5c5e\u6027\u4e3aend\n        if (branch.addChild(new Node<V>(chars[chars.length - 1], Status.WORD_END_3, value)))\n        {\n            ++size; // \u7ef4\u62a4size\n        }\n    }", "category": "Python"}, {"instruction": "Splits the cookie token into attributes pairs.\n@param str input token.\n@return a map with the attribute pairs of the token if the input is valid.\nElse, returns null.", "input": "Java", "output": "private static Map<String, String> splitCookieToken(String tokenStr) {\n    Map<String, String> map = new HashMap<String, String>();\n    StringTokenizer st = new StringTokenizer(tokenStr, COOKIE_ATTR_SEPARATOR);\n\n    while (st.hasMoreTokens()) {\n      String part = st.nextToken();\n      int separator = part.indexOf(COOKIE_KEY_VALUE_SEPARATOR);\n      if (separator == -1) {\n        LOG.error(\"Invalid token string \" + tokenStr);\n        return null;\n      }\n      String key = part.substring(0, separator);\n      String value = part.substring(separator + 1);\n      map.put(key, value);\n    }\n    return map;\n  }", "category": "Python"}, {"instruction": "Rewrite assignments so that outputs are in terms of the input symbols.\nThis operation only reliably applies to aggregation steps that take partial inputs (e.g. INTERMEDIATE and split FINALs),\nwhich are guaranteed to have exactly one input and one output.\n<p>\nExample:\n'a' := sum('b') => 'b' := sum('b')", "input": "Java", "output": "private static Map<Symbol, Aggregation> inputsAsOutputs(Map<Symbol, Aggregation> assignments)\n    {\n        ImmutableMap.Builder<Symbol, Aggregation> builder = ImmutableMap.builder();\n        for (Map.Entry<Symbol, Aggregation> entry : assignments.entrySet()) {\n            // Should only have one input symbol\n            Symbol input = getOnlyElement(SymbolsExtractor.extractAll(entry.getValue().getCall()));\n            builder.put(input, entry.getValue());\n        }\n        return builder.build();\n    }", "category": "Python"}, {"instruction": "Copies all the resources for the given target directory. The base resource serves to calculate the relative\npath such that the directory structure is maintained.\n\n@param base      The base resource\n@param resources The resources to copy\n@param targetDir The target directory\n@throws IOException if there is an error", "input": "Java", "output": "public static void copyAll(Resource base, Resource[] resources, File targetDir) throws IOException {\n        final URL baseUrl = base.getURL();\n        for (Resource resource : resources) {\n            final InputStream input = resource.getInputStream();\n            final File target = new File(targetDir, resource.getURL().toString().substring(baseUrl.toString().length()));\n            copy(new BufferedInputStream(input), new BufferedOutputStream(Files.newOutputStream(target.toPath())));\n        }\n    }", "category": "Python"}, {"instruction": "\u4ece\u6d41\u4e2d\u8bfb\u53d6\u5185\u5bb9\uff0c\u8bfb\u5230\u8f93\u51fa\u6d41\u4e2d\n\n@param <T> \u8bfb\u53d6\u5bf9\u8c61\u7684\u7c7b\u578b\n@param in \u8f93\u5165\u6d41\n@return \u8f93\u51fa\u6d41\n@throws IORuntimeException IO\u5f02\u5e38\n@throws UtilException ClassNotFoundException\u5305\u88c5", "input": "Java", "output": "public static <T> T readObj(InputStream in) throws IORuntimeException, UtilException {\r\n\t\tif (in == null) {\r\n\t\t\tthrow new IllegalArgumentException(\"The InputStream must not be null\");\r\n\t\t}\r\n\t\tObjectInputStream ois = null;\r\n\t\ttry {\r\n\t\t\tois = new ObjectInputStream(in);\r\n\t\t\t@SuppressWarnings(\"unchecked\") // may fail with CCE if serialised form is incorrect\r\n\t\t\tfinal T obj = (T) ois.readObject();\r\n\t\t\treturn obj;\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new IORuntimeException(e);\r\n\t\t} catch (ClassNotFoundException e) {\r\n\t\t\tthrow new UtilException(e);\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "Get layer output type.\n\n@param  inputType    Array of InputTypes\n@return              output type as InputType\n@throws InvalidKerasConfigurationException Invalid Keras config", "input": "Java", "output": "@Override\n    public InputType getOutputType(InputType... inputType) throws InvalidKerasConfigurationException {\n        if (inputType.length > 1)\n            throw new InvalidKerasConfigurationException(\n                            \"Keras LRN layer accepts only one input (received \" + inputType.length + \")\");\n        return this.getLocalResponseNormalization().getOutputType(-1, inputType[0]);\n    }", "category": "Python"}, {"instruction": "Sync part of an open file to the file system.\n\n@param fd      The file descriptor of the source file.\n@param offset  The offset within the file.\n@param nbytes  The number of bytes to be synced.\n@param flags   Signal how to synchronize", "input": "Java", "output": "private static void trySyncFileRange(int fd, long offset, long nbytes, int flags)\n  {\n    if (!initialized || !syncFileRangePossible || fd < 0) {\n      return;\n    }\n    try {\n      int ret_code = sync_file_range(fd, offset, nbytes, flags);\n      if (ret_code != 0) {\n        log.warn(\"failed on syncing fd [%d], offset [%d], bytes [%d], ret_code [%d], errno [%d]\",\n            fd, offset, nbytes, ret_code, Native.getLastError());\n        return;\n      }\n    }\n    catch (UnsupportedOperationException uoe) {\n      log.warn(uoe, \"sync_file_range is not supported\");\n      syncFileRangePossible = false;\n    }\n    catch (UnsatisfiedLinkError nle) {\n      log.warn(nle, \"sync_file_range failed on fd [%d], offset [%d], bytes [%d]\", fd, offset, nbytes);\n      syncFileRangePossible = false;\n    }\n    catch (Exception e) {\n      log.warn(e, \"Unknown exception: sync_file_range failed on fd [%d], offset [%d], bytes [%d]\",\n          fd, offset, nbytes);\n      syncFileRangePossible = false;\n    }\n  }", "category": "Python"}, {"instruction": "Implentation for Iterable interface.\nPlease note: each call for iterator() resets underlying SentenceIterator to the beginning;\n\n@return", "input": "Java", "output": "@Override\n    public Iterator<String> iterator() {\n        this.reset();\n        Iterator<String> ret = new Iterator<String>() {\n            @Override\n            public boolean hasNext() {\n                return BasicLineIterator.this.hasNext();\n            }\n\n            @Override\n            public String next() {\n                return BasicLineIterator.this.nextSentence();\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n\n        return ret;\n    }", "category": "Python"}, {"instruction": "Attach a list of network endpoints to the specified network endpoint group.\n\n<p>Sample code:\n\n<pre><code>\ntry (NetworkEndpointGroupClient networkEndpointGroupClient = NetworkEndpointGroupClient.create()) {\nProjectZoneNetworkEndpointGroupName networkEndpointGroup = ProjectZoneNetworkEndpointGroupName.of(\"[PROJECT]\", \"[ZONE]\", \"[NETWORK_ENDPOINT_GROUP]\");\nNetworkEndpointGroupsAttachEndpointsRequest networkEndpointGroupsAttachEndpointsRequestResource = NetworkEndpointGroupsAttachEndpointsRequest.newBuilder().build();\nOperation response = networkEndpointGroupClient.attachNetworkEndpointsNetworkEndpointGroup(networkEndpointGroup, networkEndpointGroupsAttachEndpointsRequestResource);\n}\n</code></pre>\n\n@param networkEndpointGroup The name of the network endpoint group where you are attaching\nnetwork endpoints to. It should comply with RFC1035.\n@param networkEndpointGroupsAttachEndpointsRequestResource\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation attachNetworkEndpointsNetworkEndpointGroup(\n      ProjectZoneNetworkEndpointGroupName networkEndpointGroup,\n      NetworkEndpointGroupsAttachEndpointsRequest\n          networkEndpointGroupsAttachEndpointsRequestResource) {\n\n    AttachNetworkEndpointsNetworkEndpointGroupHttpRequest request =\n        AttachNetworkEndpointsNetworkEndpointGroupHttpRequest.newBuilder()\n            .setNetworkEndpointGroup(\n                networkEndpointGroup == null ? null : networkEndpointGroup.toString())\n            .setNetworkEndpointGroupsAttachEndpointsRequestResource(\n                networkEndpointGroupsAttachEndpointsRequestResource)\n            .build();\n    return attachNetworkEndpointsNetworkEndpointGroup(request);\n  }", "category": "Python"}, {"instruction": "Hashes a filename into the corresponding local directory, in a manner consistent with\nSpark's DiskBlockManager.getFile().", "input": "Java", "output": "@VisibleForTesting\n  static File getFile(String[] localDirs, int subDirsPerLocalDir, String filename) {\n    int hash = JavaUtils.nonNegativeHash(filename);\n    String localDir = localDirs[hash % localDirs.length];\n    int subDirId = (hash / localDirs.length) % subDirsPerLocalDir;\n    return new File(createNormalizedInternedPathname(\n        localDir, String.format(\"%02x\", subDirId), filename));\n  }", "category": "Python"}, {"instruction": "Creates a state info from a new meta info to use with a k/v state.\n\n<p>Creates the column family for the state.\nSets TTL compaction filter if {@code ttlCompactFiltersManager} is not {@code null}.", "input": "Java", "output": "public static RocksDBKeyedStateBackend.RocksDbKvStateInfo createStateInfo(\n\t\tRegisteredStateMetaInfoBase metaInfoBase,\n\t\tRocksDB db,\n\t\tFunction<String, ColumnFamilyOptions> columnFamilyOptionsFactory,\n\t\t@Nullable RocksDbTtlCompactFiltersManager ttlCompactFiltersManager) {\n\n\t\tColumnFamilyDescriptor columnFamilyDescriptor = createColumnFamilyDescriptor(\n\t\t\tmetaInfoBase, columnFamilyOptionsFactory, ttlCompactFiltersManager);\n\t\treturn new RocksDBKeyedStateBackend.RocksDbKvStateInfo(createColumnFamily(columnFamilyDescriptor, db), metaInfoBase);\n\t}", "category": "Python"}, {"instruction": "Adds offset to the underlying {@link SortTableOperation} if it is a valid one.\n\n@param offset offset to add\n@param child should be {@link SortTableOperation}\n@return valid sort operation with applied offset", "input": "Java", "output": "public TableOperation createLimitWithOffset(int offset, TableOperation child) {\n\t\tSortTableOperation previousSort = validateAndGetChildSort(child);\n\n\t\tif (offset < 0) {\n\t\t\tthrow new ValidationException(\"Offset should be greater or equal 0\");\n\t\t}\n\n\t\tif (previousSort.getOffset() != -1) {\n\t\t\tthrow new ValidationException(\"OFFSET already defined\");\n\t\t}\n\n\t\treturn new SortTableOperation(previousSort.getOrder(), previousSort.getChild(), offset, -1);\n\t}", "category": "Python"}, {"instruction": "Transforms a {@code SplitTransformation}.\n\n<p>We add the output selector to previously transformed nodes.", "input": "Java", "output": "private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {\n\n\t\tStreamTransformation<T> input = split.getInput();\n\t\tCollection<Integer> resultIds = transform(input);\n\n\t\tvalidateSplitTransformation(input);\n\n\t\t// the recursive transform call might have transformed this already\n\t\tif (alreadyTransformed.containsKey(split)) {\n\t\t\treturn alreadyTransformed.get(split);\n\t\t}\n\n\t\tfor (int inputId : resultIds) {\n\t\t\tstreamGraph.addOutputSelector(inputId, split.getOutputSelector());\n\t\t}\n\n\t\treturn resultIds;\n\t}", "category": "Python"}, {"instruction": "Checks to see if the candidate displayName collides with any\nexisting display names or project names\n@param displayName The display name to test\n@param jobName The name of the job the user is configuring", "input": "Java", "output": "public FormValidation doCheckDisplayName(@QueryParameter String displayName,\n            @QueryParameter String jobName) {\n        displayName = displayName.trim();\n\n        if(LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.log(Level.FINE, \"Current job name is \" + jobName);\n        }\n\n        if(!isNameUnique(displayName, jobName)) {\n            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_NameNotUniqueWarning(displayName));\n        }\n        else if(!isDisplayNameUnique(displayName, jobName)){\n            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_DisplayNameNotUniqueWarning(displayName));\n        }\n        else {\n            return FormValidation.ok();\n        }\n    }", "category": "Python"}, {"instruction": "Read a little endian integer from the stream.\n\n@param n\nthe number of bytes to read\n\n@return the bytes read, converted from little endian to an integer.\n\n@exception OtpErlangDecodeException\nif the next byte cannot be read.", "input": "Java", "output": "public long readLE(final int n) throws OtpErlangDecodeException {\n        final byte[] b = new byte[n];\n        try {\n            super.read(b);\n        } catch (final IOException e) {\n            throw new OtpErlangDecodeException(\"Cannot read from input stream\");\n        }\n        long v = 0;\n        int i = n;\n        while (i-- > 0) {\n            v = v << 8 | (long) b[i] & 0xff;\n        }\n        return v;\n    }", "category": "Python"}, {"instruction": "only for Jelly", "input": "Java", "output": "@Restricted(NoExternalUse.class)\n    public Collection<TokenInfoAndStats> getTokenList() {\n        return tokenStore.getTokenListSortedByName()\n                .stream()\n                .map(token -> {\n                    ApiTokenStats.SingleTokenStats stats = tokenStats.findTokenStatsById(token.getUuid());\n                    return new TokenInfoAndStats(token, stats);\n                })\n                .collect(Collectors.toList());\n    }", "category": "Python"}, {"instruction": "Start a new workflow.  Returns the ID of the workflow instance that can be later used for tracking.\n\n@param name          Name of the workflow you want to start.\n@param version       Version of the workflow you want to start.\n@param correlationId CorrelationID of the workflow you want to start.\n@param input         Input to the workflow you want to start.\n@return the id of the workflow instance that can be use for tracking.", "input": "Java", "output": "@Service\n    public String startWorkflow(String name, Integer version, String correlationId, Map<String, Object> input) {\n        WorkflowDef workflowDef = metadataService.getWorkflowDef(name, version);\n        if (workflowDef == null) {\n            throw new ApplicationException(ApplicationException.Code.NOT_FOUND, String.format(\"No such workflow found by name: %s, version: %d\", name, version));\n        }\n        return workflowExecutor.startWorkflow(workflowDef.getName(), workflowDef.getVersion(), correlationId, input, null);\n    }", "category": "Python"}, {"instruction": "This function checks the query for dimensions which can be optimized by applying the dimension extraction\nas the final step of the query instead of on every event.\n\n@param query The query to check for optimizations\n\n@return A collection of DimensionsSpec which can be extracted at the last second upon query completion.", "input": "Java", "output": "public static Collection<DimensionSpec> extractionsToRewrite(GroupByQuery query)\n  {\n    return Collections2.filter(\n        query.getDimensions(), new Predicate<DimensionSpec>()\n        {\n          @Override\n          public boolean apply(DimensionSpec input)\n          {\n            return input.getExtractionFn() != null\n                   && ExtractionFn.ExtractionType.ONE_TO_ONE.equals(\n                input.getExtractionFn().getExtractionType()\n            );\n          }\n        }\n    );\n  }", "category": "Python"}, {"instruction": "Write all values from the specified record reader to the specified record writer.\nOptionally, close the record writer on completion\n\n@param reader Record reader (source of data)\n@param writer Record writer (location to write data)\n@param closeOnCompletion if true: close the record writer once complete, via {@link RecordWriter#close()}\n@throws IOException If underlying reader/writer throws an exception", "input": "Java", "output": "public static void convert(RecordReader reader, RecordWriter writer, boolean closeOnCompletion) throws IOException {\n\n        if(!reader.hasNext()){\n            throw new UnsupportedOperationException(\"Cannot convert RecordReader: reader has no next element\");\n        }\n\n        while(reader.hasNext()){\n            writer.write(reader.next());\n        }\n\n        if(closeOnCompletion){\n            writer.close();\n        }\n    }", "category": "Python"}, {"instruction": "\u62c6\u5206byte\u6570\u7ec4\u4e3a\u51e0\u4e2a\u7b49\u4efd\uff08\u6700\u540e\u4e00\u4efd\u53ef\u80fd\u5c0f\u4e8elen\uff09\n\n@param array \u6570\u7ec4\n@param len \u6bcf\u4e2a\u5c0f\u8282\u7684\u957f\u5ea6\n@return \u62c6\u5206\u540e\u7684\u6570\u7ec4", "input": "Java", "output": "public static byte[][] split(byte[] array, int len) {\r\n\t\tint x = array.length / len;\r\n\t\tint y = array.length % len;\r\n\t\tint z = 0;\r\n\t\tif (y != 0) {\r\n\t\t\tz = 1;\r\n\t\t}\r\n\t\tbyte[][] arrays = new byte[x + z][];\r\n\t\tbyte[] arr;\r\n\t\tfor (int i = 0; i < x + z; i++) {\r\n\t\t\tarr = new byte[len];\r\n\t\t\tif (i == x + z - 1 && y != 0) {\r\n\t\t\t\tSystem.arraycopy(array, i * len, arr, 0, y);\r\n\t\t\t} else {\r\n\t\t\t\tSystem.arraycopy(array, i * len, arr, 0, len);\r\n\t\t\t}\r\n\t\t\tarrays[i] = arr;\r\n\t\t}\r\n\t\treturn arrays;\r\n\t}", "category": "Python"}, {"instruction": "Gets json web key from jwks.\n\n@param jwks the jwks\n@return the json web key from jwks", "input": "Java", "output": "public static RsaJsonWebKey getJsonWebKeyFromJsonWebKeySet(final JsonWebKeySet jwks) {\n        if (jwks.getJsonWebKeys().isEmpty()) {\n            LOGGER.warn(\"No JSON web keys are available in the keystore\");\n            return null;\n        }\n\n        val key = (RsaJsonWebKey) jwks.getJsonWebKeys().get(0);\n        if (StringUtils.isBlank(key.getAlgorithm())) {\n            LOGGER.warn(\"Located JSON web key [{}] has no algorithm defined\", key);\n        }\n        if (StringUtils.isBlank(key.getKeyId())) {\n            LOGGER.warn(\"Located JSON web key [{}] has no key id defined\", key);\n        }\n\n        if (key.getPublicKey() == null) {\n            LOGGER.warn(\"Located JSON web key [{}] has no public key\", key);\n            return null;\n        }\n        return key;\n    }", "category": "Python"}, {"instruction": "Closes the Operation Queue and fails all Operations in it with the given exception.\n\n@param causingException The exception to fail with. If null, it will default to ObjectClosedException.", "input": "Java", "output": "private void closeQueue(Throwable causingException) {\n        // Close the operation queue and extract any outstanding Operations from it.\n        Collection<CompletableOperation> remainingOperations = this.operationQueue.close();\n        if (remainingOperations != null && remainingOperations.size() > 0) {\n            // If any outstanding Operations were left in the queue, they need to be failed.\n            // If no other cause was passed, assume we are closing the queue because we are shutting down.\n            Throwable failException = causingException != null ? causingException : new CancellationException();\n            cancelIncompleteOperations(remainingOperations, failException);\n        }\n\n        // The commit queue will auto-close when we are done and it itself is empty. We just need to unblock it in case\n        // it was idle and waiting on a pending take() operation.\n        this.commitQueue.cancelPendingTake();\n    }", "category": "Python"}, {"instruction": "For some metrics such as OpStats, Pravega generates corresponding fail metrics automatically,\nthis method is called to create the name of fail metric for a given metric.\n\nSome examples of OpStats metrics and their corresponding fail metrics:\npravega.segmentstore.bookkeeper.write_latency_ms.0\npravega.segmentstore.bookkeeper.write_latency_ms_fail.0\n\npravega.segmentstore.thread_pool.active_threads\npravega.segmentstore.thread_pool.active_threads_fail\n\nThe rule is, if the last segment of the metric is an integer, such as container id, the suffix \"_fail\"\nis appended to the preceeding segment instead of the integer itself; otherwise simply append \"_fail\"\nonto the given metric to get the fail metric.\n\n@param metricName the metric name for which fail metric is created\n@return the name of fail metric", "input": "Java", "output": "public static String failMetricName(String metricName) {\n        if (Strings.isNullOrEmpty(metricName)) {\n            return metricName;\n        }\n        String[] tags = metricName.split(\"\\\\.\");\n        if (tags.length >= 2 && Ints.tryParse(tags[tags.length - 1]) != null) {\n            tags[tags.length - 2] += \"_fail\";\n            return String.join(\".\", tags);\n        } else {\n            return metricName + \"_fail\";\n        }\n    }", "category": "Python"}, {"instruction": "Often an archive contains an extra top-level directory that's unnecessary when extracted on the disk\ninto the expected location. If your installation sources provide that kind of archives, override\nthis method to find the real root location.\n\n<p>\nThe caller will \"pull up\" the discovered real root by throw away the intermediate directory,\nso that the user-configured \"tool home\" directory contains the right files.\n\n<p>\nThe default implementation applies some heuristics to auto-determine if the pull up is necessary.\nThis should work for typical archive files.\n\n@param root\nThe directory that contains the extracted archive. This directory contains nothing but the\nextracted archive. For example, if the user installed\nhttp://archive.apache.org/dist/ant/binaries/jakarta-ant-1.1.zip , this directory would contain\na single directory \"jakarta-ant\".\n\n@return\nReturn the real top directory inside {@code root} that contains the meat. In the above example,\n{@code root.child(\"jakarta-ant\")} should be returned. If there's no directory to pull up,\nreturn null.", "input": "Java", "output": "protected FilePath findPullUpDirectory(FilePath root) throws IOException, InterruptedException {\n        // if the directory just contains one directory and that alone, assume that's the pull up subject\n        // otherwise leave it as is.\n        List<FilePath> children = root.list();\n        if(children.size()!=1)    return null;\n        if(children.get(0).isDirectory())\n            return children.get(0);\n        return null;\n    }", "category": "Python"}, {"instruction": "Parse all Http request params", "input": "Java", "output": "private Pair<String, String>[] getAllParams(final HttpServletRequest req) {\n    final List<Pair<String, String>> allParams = new LinkedList<>();\n\n    final Iterator it = req.getParameterMap().entrySet().iterator();\n    while (it.hasNext()) {\n      final Map.Entry pairs = (Map.Entry) it.next();\n      for (final Object value : (String[]) pairs.getValue()) {\n        allParams.add(new Pair<>((String) pairs.getKey(), (String) value));\n      }\n    }\n\n    return allParams.toArray(new Pair[allParams.size()]);\n  }", "category": "Python"}, {"instruction": "Resolve principal.\n\n@param handler    the handler name\n@param resolver   the resolver\n@param credential the credential\n@param principal  the current authenticated principal from a handler, if any.\n@return the principal", "input": "Java", "output": "protected Principal resolvePrincipal(final AuthenticationHandler handler, final PrincipalResolver resolver,\n                                         final Credential credential, final Principal principal) {\n        if (resolver.supports(credential)) {\n            try {\n                val p = resolver.resolve(credential, Optional.ofNullable(principal), Optional.ofNullable(handler));\n                LOGGER.debug(\"[{}] resolved [{}] from [{}]\", resolver, p, credential);\n                return p;\n            } catch (final Exception e) {\n                LOGGER.error(\"[{}] failed to resolve principal from [{}]\", resolver, credential, e);\n            }\n        } else {\n            LOGGER.warn(\n                \"[{}] is configured to use [{}] but it does not support [{}], which suggests a configuration problem.\",\n                handler.getName(), resolver, credential);\n        }\n        return null;\n    }", "category": "Python"}, {"instruction": "occur while saving.", "input": "Java", "output": "@GuardedBy(\"tasks\")\n  private void saveRunningTasks()\n  {\n    final File restoreFile = getRestoreFile();\n    final List<String> theTasks = new ArrayList<>();\n    for (ForkingTaskRunnerWorkItem forkingTaskRunnerWorkItem : tasks.values()) {\n      theTasks.add(forkingTaskRunnerWorkItem.getTaskId());\n    }\n\n    try {\n      Files.createParentDirs(restoreFile);\n      jsonMapper.writeValue(restoreFile, new TaskRestoreInfo(theTasks));\n    }\n    catch (Exception e) {\n      log.warn(e, \"Failed to save tasks to restore file[%s]. Skipping this save.\", restoreFile);\n    }\n  }", "category": "Python"}, {"instruction": "Adds the url to the list.\nBuild URI by components to facilitate proper encoding of querystring.\ne.g. http://example.com:8085/ca?action=crl&issuer=CN=CAS Test User CA\n<p>\n<p>If {@code uriString} is encoded, it will be decoded with {@code UTF-8}\nfirst before it's added to the list.</p>\n\n@param list      the list\n@param uriString the uri string", "input": "Java", "output": "private static void addURL(final List<URI> list, final String uriString) {\n        try {\n            try {\n                val url = new URL(URLDecoder.decode(uriString, StandardCharsets.UTF_8.name()));\n                list.add(new URI(url.getProtocol(), url.getAuthority(), url.getPath(), url.getQuery(), null));\n            } catch (final MalformedURLException e) {\n                list.add(new URI(uriString));\n            }\n        } catch (final Exception e) {\n            LOGGER.warn(\"[{}] is not a valid distribution point URI.\", uriString);\n        }\n    }", "category": "Python"}, {"instruction": "Removes all stale cached misconfigured hosts.\n<p>\n<strong>Note:</strong> This method should be called in a {@code synchronized} block with the object\n{@code misconfiguredHosts}.\n\n@see #misconfiguredHosts\n@see #cacheMisconfiguredHost(String, int, InetAddress)\n@see #getCachedMisconfiguredHost(String, int)", "input": "Java", "output": "private static void removeStaleCachedMisconfiguredHosts() {\r\n\t\tlong currentTime = System.currentTimeMillis();\r\n\t\tif (!((currentTime - timeStampLastStaleCheck) >= MAX_AGE_MISCONFIGURED_HOST_IN_MS)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttimeStampLastStaleCheck = currentTime;\r\n\r\n\t\tfor (MapIterator it = misconfiguredHosts.mapIterator(); it.hasNext();) {\r\n\t\t\tit.next();\r\n\r\n\t\t\tMisconfiguredHostCacheEntry entry = (MisconfiguredHostCacheEntry) it.getValue();\r\n\t\t\tif (entry.isStale(currentTime)) {\r\n\t\t\t\tlogger.info(\"Removing stale cached address of misconfigured (\\\"unrecognized_name\\\") host [host=\"\r\n\t\t\t\t\t\t+ entry.getHost() + \", port=\" + entry.getPort()\r\n\t\t\t\t\t\t+ \"], following connections will be attempted with the hostname.\");\r\n\t\t\t\tit.remove();\r\n\t\t\t}\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "Get the int value of a transaction isolation level by name.\n\n@param transactionIsolationName the name of the transaction isolation level\n@return the int value of the isolation level or -1", "input": "Java", "output": "public static int getTransactionIsolation(final String transactionIsolationName) {\n      if (transactionIsolationName != null) {\n         try {\n            // use the english locale to avoid the infamous turkish locale bug\n            final String upperCaseIsolationLevelName = transactionIsolationName.toUpperCase(Locale.ENGLISH);\n            return IsolationLevel.valueOf(upperCaseIsolationLevelName).getLevelId();\n         } catch (Exception e) {\n            throw new IllegalArgumentException(\"Invalid transaction isolation value: \" + transactionIsolationName);\n         }\n      }\n\n      return -1;\n   }", "category": "Python"}, {"instruction": "\u5b9e\u4f8b\u5316\u5bf9\u8c61\n\n@param <T> \u5bf9\u8c61\u7c7b\u578b\n@param clazz \u7c7b\n@param params \u6784\u9020\u51fd\u6570\u53c2\u6570\n@return \u5bf9\u8c61\n@throws UtilException \u5305\u88c5\u5404\u7c7b\u5f02\u5e38", "input": "Java", "output": "public static <T> T newInstance(Class<T> clazz, Object... params) throws UtilException {\r\n\t\tif (ArrayUtil.isEmpty(params)) {\r\n\t\t\tfinal Constructor<T> constructor = getConstructor(clazz);\r\n\t\t\ttry {\r\n\t\t\t\treturn constructor.newInstance();\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\tthrow new UtilException(e, \"Instance class [{}] error!\", clazz);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfinal Class<?>[] paramTypes = ClassUtil.getClasses(params);\r\n\t\tfinal Constructor<T> constructor = getConstructor(clazz, paramTypes);\r\n\t\tif (null == constructor) {\r\n\t\t\tthrow new UtilException(\"No Constructor matched for parameter types: [{}]\", new Object[] { paramTypes });\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn constructor.newInstance(params);\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new UtilException(e, \"Instance class [{}] error!\", clazz);\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "Gets an optional enum param, returning {@code null} if the parameter was not found.\n\n@param <E> the type of the enum that will be returned\n@param params the params\n@param paramName the param name\n@param enumType the type of the enum\n@return the enum, or {@code null}\n@throws ApiException if the param value does not match any of the possible enum values", "input": "Java", "output": "public static <E extends Enum<E>> E getOptionalEnumParam(JSONObject params, String paramName,\n\t\t\tClass<E> enumType) throws ApiException {\n\t\tString enumValS = params.optString(paramName, null);\n\t\tE enumVal = null;\n\t\tif (enumValS != null && !enumValS.isEmpty()) {\n\t\t\ttry {\n\t\t\t\tenumVal = Enum.valueOf(enumType, enumValS);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new ApiException(ApiException.Type.ILLEGAL_PARAMETER, paramName + \": \"\n\t\t\t\t\t\t+ ex.getLocalizedMessage());\n\t\t\t}\n\t\t}\n\t\treturn enumVal;\n\t}", "category": "Python"}, {"instruction": "Adds multiple SegmentChunks.\n\n@param segmentChunks The SegmentChunks to add. These SegmentChunks must be in continuity of any existing SegmentChunks.", "input": "Java", "output": "synchronized void addChunks(List<SegmentChunk> segmentChunks) {\n        Preconditions.checkState(!this.sealed, \"Cannot add SegmentChunks for a Sealed Handle.\");\n        long expectedOffset = 0;\n        if (this.segmentChunks.size() > 0) {\n            expectedOffset = this.segmentChunks.get(this.segmentChunks.size() - 1).getLastOffset();\n        } else if (segmentChunks.size() > 0) {\n            expectedOffset = segmentChunks.get(0).getStartOffset();\n        }\n\n        for (SegmentChunk s : segmentChunks) {\n            Preconditions.checkArgument(s.getStartOffset() == expectedOffset,\n                    \"Invalid SegmentChunk StartOffset. Expected %s, given %s.\", expectedOffset, s.getStartOffset());\n            expectedOffset += s.getLength();\n        }\n\n        this.segmentChunks.addAll(segmentChunks);\n        this.activeChunkHandle = null;\n    }", "category": "Python"}, {"instruction": "Initialize the ModelBuilder, validating all arguments and preparing the\ntraining frame.  This call is expected to be overridden in the subclasses\nand each subclass will start with \"super.init();\".  This call is made\nby the front-end whenever the GUI is clicked, and needs to be fast;\nheavy-weight prep needs to wait for the trainModel() call.\n\nValidate the probs.", "input": "Java", "output": "@Override public void init(boolean expensive) {\n    super.init(expensive);\n    for( double p : _parms._probs )\n      if( p < 0.0 || p > 1.0 )\n        error(\"_probs\",\"Probabilities must be between 0 and 1\");\n    _ncols = train().numCols()-numSpecialCols(); //offset/weights/nfold - should only ever be weights\n    if ( numSpecialCols() == 1 && _weights == null)\n      throw new IllegalArgumentException(\"The only special Vec that is supported for Quantiles is observation weights.\");\n    if ( numSpecialCols() >1 ) throw new IllegalArgumentException(\"Cannot handle more than 1 special vec (weights)\");\n  }", "category": "Python"}, {"instruction": "Computes a visual representation of the approximate histogram with a given number of equal-sized bins\n\n@param size number of equal-sized bins to divide the histogram into\n\n@return visual representation of the histogram", "input": "Java", "output": "public Histogram toHistogram(int size)\n  {\n    Preconditions.checkArgument(size > 1, \"histogram size must be greater than 1\");\n\n    float[] breaks = new float[size + 1];\n    float delta = (max - min) / (size - 1);\n    breaks[0] = min - delta;\n    for (int i = 1; i < breaks.length - 1; ++i) {\n      breaks[i] = breaks[i - 1] + delta;\n    }\n    breaks[breaks.length - 1] = max;\n    return toHistogram(breaks);\n  }", "category": "Python"}, {"instruction": "Gets a set of locality groups that should be added to the index table (not the metrics table).\n\n@param table Table for the locality groups, see AccumuloClient#getTable\n@return Mapping of locality group to column families in the locality group, 1:1 mapping in\nthis case", "input": "Java", "output": "public static Map<String, Set<Text>> getLocalityGroups(AccumuloTable table)\n    {\n        Map<String, Set<Text>> groups = new HashMap<>();\n        // For each indexed column\n        for (AccumuloColumnHandle columnHandle : table.getColumns().stream().filter(AccumuloColumnHandle::isIndexed).collect(Collectors.toList())) {\n            // Create a Text version of the index column family\n            Text indexColumnFamily = new Text(getIndexColumnFamily(columnHandle.getFamily().get().getBytes(UTF_8), columnHandle.getQualifier().get().getBytes(UTF_8)).array());\n\n            // Add this to the locality groups,\n            // it is a 1:1 mapping of locality group to column families\n            groups.put(indexColumnFamily.toString(), ImmutableSet.of(indexColumnFamily));\n        }\n        return groups;\n    }", "category": "Python"}, {"instruction": "This method tries to isolate class loading during a Function call\n\n@param clazzName    The Class which has a static method called `runTask`\n@param input        The input for `runTask`, must have `input.getClass()` be the class of the input for runTask\n@param loader       The loader to use as the context class loader during invocation\n@param <InputType>  The input type of the method.\n@param <OutputType> The output type of the method. The result of runTask must be castable to this type.\n\n@return The result of the method invocation", "input": "Java", "output": "public static <InputType, OutputType> OutputType invokeForeignLoader(\n      final String clazzName,\n      final InputType input,\n      final ClassLoader loader\n  )\n  {\n    log.debug(\"Launching [%s] on class loader [%s] with input class [%s]\", clazzName, loader, input.getClass());\n    final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();\n    try {\n      Thread.currentThread().setContextClassLoader(loader);\n      final Class<?> clazz = loader.loadClass(clazzName);\n      final Method method = clazz.getMethod(\"runTask\", input.getClass());\n      return (OutputType) method.invoke(null, input);\n    }\n    catch (IllegalAccessException | InvocationTargetException | ClassNotFoundException | NoSuchMethodException e) {\n      throw new RuntimeException(e);\n    }\n    finally {\n      Thread.currentThread().setContextClassLoader(oldLoader);\n    }\n  }", "category": "Python"}, {"instruction": "Collect the RPC client information.\n\n@param rpcClientMetricsModel client information model", "input": "Java", "output": "public void collectClient(RpcClientLookoutModel rpcClientMetricsModel) {\n\n        try {\n            Id methodConsumerId = createMethodConsumerId(rpcClientMetricsModel);\n            MixinMetric methodConsumerMetric = Lookout.registry().mixinMetric(methodConsumerId);\n\n            recordCounterAndTimer(methodConsumerMetric, rpcClientMetricsModel);\n\n            recordSize(methodConsumerMetric, rpcClientMetricsModel);\n\n        } catch (Throwable t) {\n            LOGGER.error(LogCodes.getLog(LogCodes.ERROR_METRIC_REPORT_ERROR), t);\n        }\n    }", "category": "Python"}, {"instruction": "Converts a map of class elements to type arguments.\n@param parameters The parametesr\n@return The type arguments", "input": "Java", "output": "@NotNull\n    protected  Map<String, Map<String, Object>>  toTypeArguments(ParameterElement... parameters) {\n        final LinkedHashMap<String, Map<String, Object>>  map = new LinkedHashMap<>(parameters.length);\n        for (ParameterElement ce : parameters) {\n            final ClassElement type = ce.getType();\n            if (type == null) {\n                continue;\n            }\n            final Map<String, ClassElement> subArgs = type.getTypeArguments();\n            if (CollectionUtils.isNotEmpty(subArgs)) {\n                map.put(ce.getName(), toTypeArguments(subArgs));\n            }\n        }\n        return map;\n    }", "category": "Python"}, {"instruction": "Gets the view properties configured for this view.\n@since 1.406", "input": "Java", "output": "public DescribableList<ViewProperty,ViewPropertyDescriptor> getProperties() {\n        // readResolve was the best place to do this, but for compatibility reasons,\n        // this class can no longer have readResolve() (the mechanism itself isn't suitable for class hierarchy)\n        // see JENKINS-9431\n        //\n        // until we have that, putting this logic here.\n        synchronized (PropertyList.class) {\n            if (properties == null) {\n                properties = new PropertyList(this);\n            } else {\n                properties.setOwner(this);\n            }\n            return properties;\n        }\n    }", "category": "Python"}, {"instruction": "Calculate percentage of successful builds\nAny build with status InProgress, Aborted is excluded from calculation\nBuilds with status as Success, Unstable is included as success build\n\n@param builds iterable build\n@return percentage of build success", "input": "Java", "output": "private Double fetchBuildSuccessRatio(Iterable<Build> builds) {\n    int totalBuilds = 0, totalSuccess = 0;\n    for (Build build : builds) {\n      if (Constants.IGNORE_STATUS.contains(build.getBuildStatus())) {\n        continue;\n      }\n\n      totalBuilds++;\n      if (Constants.SUCCESS_STATUS.contains(build.getBuildStatus())) {\n        totalSuccess++;\n      }\n    }\n    if (totalBuilds == 0) {\n      return 0.0d;\n    }\n    return ((totalSuccess * 100) / (double) totalBuilds);\n  }", "category": "Python"}, {"instruction": "Invokes the given {@code script}, synchronously, as a {@link ProxyScript}, handling any {@code Exception} thrown during\nthe invocation.\n<p>\nThe context class loader of caller thread is replaced with the class loader {@code AddOnLoader} to allow the script to\naccess classes of add-ons.\n\n@param script the script to invoke.\n@param msg the HTTP message being proxied.\n@param request {@code true} if processing the request, {@code false} otherwise.\n@return {@code true} if the request should be forward to the server, {@code false} otherwise.\n@since 2.2.0\n@see #getInterface(ScriptWrapper, Class)", "input": "Java", "output": "public boolean invokeProxyScript(ScriptWrapper script, HttpMessage msg, boolean request) {\r\n\t\tvalidateScriptType(script, TYPE_PROXY);\r\n\r\n\t\tWriter writer = getWriters(script);\r\n\t\ttry {\r\n\t\t\t// Dont need to check if enabled as it can only be invoked manually\r\n\t\t\tProxyScript s = this.getInterface(script, ProxyScript.class);\r\n\t\t\t\r\n\t\t\tif (s != null) {\r\n\t\t\t\tif (request) {\r\n\t\t\t\t\treturn s.proxyRequest(msg);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn s.proxyResponse(msg);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\thandleUnspecifiedScriptError(script, writer, Constant.messages.getString(\"script.interface.proxy.error\"));\r\n\t\t\t}\r\n\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\thandleScriptException(script, writer, e);\r\n\t\t}\r\n    \t// Return true so that the request is submitted - if we returned false all proxying would fail on script errors\r\n    \treturn true;\r\n\t}", "category": "Python"}, {"instruction": "Iterates over all active HTTP/2 streams.\n\n<p>This method must not be called outside of the event loop.", "input": "Java", "output": "final void forEachActiveStream(final Http2FrameStreamVisitor streamVisitor) throws Http2Exception {\n        assert ctx.executor().inEventLoop();\n\n        connection().forEachActiveStream(new Http2StreamVisitor() {\n            @Override\n            public boolean visit(Http2Stream stream) {\n                try {\n                    return streamVisitor.visit((Http2FrameStream) stream.getProperty(streamKey));\n                } catch (Throwable cause) {\n                    onError(ctx, false, cause);\n                    return false;\n                }\n            }\n        });\n    }", "category": "Python"}, {"instruction": "pretrain is used to build CoOccurrence matrix for GloVe algorithm\n@param iterator", "input": "Java", "output": "@Override\n    public void pretrain(@NonNull SequenceIterator<T> iterator) {\n        // CoOccurence table should be built here\n        coOccurrences = new AbstractCoOccurrences.Builder<T>()\n                        // TODO: symmetric should be handled via VectorsConfiguration\n                        .symmetric(this.symmetric).windowSize(configuration.getWindow()).iterate(iterator)\n                        .workers(workers).vocabCache(vocabCache).maxMemory(maxmemory).build();\n\n        coOccurrences.fit();\n    }", "category": "Python"}, {"instruction": "Allocate and return a  new array\nbased on the vertex id and weight initialization.\n@return the allocated array", "input": "Java", "output": "public INDArray storeAndAllocateNewArray() {\n        Preconditions.checkState(variableType == VariableType.VARIABLE, \"Unable to allocate and store array for variable of type %s: only\" +\n                \" VARIABLE type variables can be initialized using this method\", variableType);\n\n        if(!sameDiff.arrayAlreadyExistsForVarName(varName)){\n            long[] shape = getShape();\n            INDArray arr = getWeightInitScheme().create(dataType(), shape);\n            sameDiff.associateArrayWithVariable(arr, this);\n            if(log.isTraceEnabled()){\n                log.trace(\"Generated and stored new array for variable \\\"{}\\\": shape {}\", getVarName(), Arrays.toString(arr.shape()));\n            }\n            return arr;\n        }\n\n        //Variable type SDVariables: shape should never change (i.e., these are params in the net!)\n        INDArray ret = getArr();\n        return ret;\n    }", "category": "Python"}, {"instruction": "Throws a DException if the remote throws, wrapping the original exception.", "input": "Java", "output": "@Override public V get() {\n    // check priorities - FJ task can only block on a task with higher priority!\n    Thread cThr = Thread.currentThread();\n    int priority = (cThr instanceof FJWThr) ? ((FJWThr)cThr)._priority : -1;\n    assert _dt.priority() > priority || (_dt.priority() == priority && _dt instanceof MRTask)\n      : \"*** Attempting to block on task (\" + _dt.getClass() + \") with equal or lower priority. Can lead to deadlock! \" + _dt.priority() + \" <=  \" + priority;\n    if( _done ) return result(); // Fast-path shortcut, or throw if exception\n    // Use FJP ManagedBlock for this blocking-wait - so the FJP can spawn\n    // another thread if needed.\n    try { ForkJoinPool.managedBlock(this); } catch( InterruptedException ignore ) { }\n    if( _done ) return result(); // Fast-path shortcut or throw if exception\n    assert isCancelled();\n    return null;\n  }", "category": "Python"}, {"instruction": "Scan {@code uri} for a session ID. This is identified by scanning for \"{code /session/}\" and\nthen extracting the next fragment of the URL. This means that both \"{@code /session/foo}\" and\n\"{@code /wd/hub/session/foo/bar}\" would both identify the session id as being \"foo\".", "input": "Java", "output": "public static Optional<String> getSessionId(String uri) {\n    int sessionIndex = uri.indexOf(\"/session/\");\n    if (sessionIndex != -1) {\n      sessionIndex += \"/session/\".length();\n      int nextSlash = uri.indexOf(\"/\", sessionIndex);\n      if (nextSlash != -1) {\n        return Optional.of(uri.substring(sessionIndex, nextSlash));\n      }\n      return Optional.of(uri.substring(sessionIndex));\n    }\n    return Optional.empty();\n  }", "category": "Python"}, {"instruction": "As per {@link #execBackwards(Map)}, but the set of gradients to calculate can be specified manually.<br>\nFor example, to calculate the gradient for placeholder variable \"myPlaceholder\", use\n{@code execBackwards(placeholders, Arrays.asList(myPlaceholder.gradient().getVarName())}.\n\n@param placeholders Values for the placeholder variables in the graph. For graphs without placeholders, use null or an empty map\n@param variableGradNamesList Names of the gradient variables to calculate", "input": "Java", "output": "public void execBackwards(Map<String,INDArray> placeholders, List<String> variableGradNamesList){\n        if (getFunction(\"grad\") == null) {\n            createGradFunction();\n        }\n\n        log.trace(\"About to execute backward function\");\n\n        //Edge case: if no variables, no variable gradients to calculate...\n        if(variableGradNamesList.isEmpty()){\n            log.warn(\"Skipping gradient calculation (backward pass) - no variables to be calculated (variableGradNamesList is empty)\");\n            return;\n        }\n\n        sameDiffFunctionInstances.get(\"grad\").exec(placeholders, variableGradNamesList);\n    }", "category": "Python"}, {"instruction": "------ tables ------", "input": "Java", "output": "@Override\n\tpublic void createTable(ObjectPath tablePath, CatalogBaseTable table, boolean ignoreIfExists)\n\t\tthrows TableAlreadyExistException, DatabaseNotExistException {\n\t\tcheckNotNull(tablePath);\n\t\tcheckNotNull(table);\n\n\t\tif (!databaseExists(tablePath.getDatabaseName())) {\n\t\t\tthrow new DatabaseNotExistException(catalogName, tablePath.getDatabaseName());\n\t\t}\n\n\t\tif (tableExists(tablePath)) {\n\t\t\tif (!ignoreIfExists) {\n\t\t\t\tthrow new TableAlreadyExistException(catalogName, tablePath);\n\t\t\t}\n\t\t} else {\n\t\t\ttables.put(tablePath, table.copy());\n\n\t\t\tif ((table instanceof CatalogTable) && ((CatalogTable) table).isPartitioned()) {\n\t\t\t\tpartitions.put(tablePath, new LinkedHashMap<>());\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Helper method which sets up an iteration with the given vertex value.\n\n@param iteration", "input": "Java", "output": "private void setUpIteration(DeltaIteration<?, ?> iteration) {\n\n\t\t// set up the iteration operator\n\t\tif (this.configuration != null) {\n\n\t\t\titeration.name(this.configuration.getName(\"Vertex-centric iteration (\" + computeFunction + \")\"));\n\t\t\titeration.parallelism(this.configuration.getParallelism());\n\t\t\titeration.setSolutionSetUnManaged(this.configuration.isSolutionSetUnmanagedMemory());\n\n\t\t\t// register all aggregators\n\t\t\tfor (Map.Entry<String, Aggregator<?>> entry : this.configuration.getAggregators().entrySet()) {\n\t\t\t\titeration.registerAggregator(entry.getKey(), entry.getValue());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// no configuration provided; set default name\n\t\t\titeration.name(\"Vertex-centric iteration (\" + computeFunction + \")\");\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Handles the logout processing.\n\n<p>\nThe default implementation erases the session and do a few other clean up, then\nredirect the user to the URL specified by {@link #getPostLogOutUrl(StaplerRequest, Authentication)}.\n\n@since 1.314", "input": "Java", "output": "public void doLogout(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        HttpSession session = req.getSession(false);\n        if(session!=null)\n            session.invalidate();\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        SecurityContextHolder.clearContext();\n\n        // reset remember-me cookie\n        Cookie cookie = new Cookie(ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY,\"\");\n        cookie.setMaxAge(0);\n        cookie.setSecure(req.isSecure());\n        cookie.setHttpOnly(true);\n        cookie.setPath(req.getContextPath().length()>0 ? req.getContextPath() : \"/\");\n        rsp.addCookie(cookie);\n\n        rsp.sendRedirect2(getPostLogOutUrl(req,auth));\n    }", "category": "Python"}, {"instruction": "Gets flow or job props from flow yaml file.\n\n@param path the flow or job path delimited by \":\", e.g. \"flow:subflow1:subflow2:job3\"\n@param flowFile the flow yaml file\n@return the props from yaml file", "input": "Java", "output": "public static Props getPropsFromYamlFile(final String path, final File flowFile) {\n    final List<Props> propsList = new ArrayList<>();\n    final NodeBeanLoader loader = new NodeBeanLoader();\n\n    try {\n      final NodeBean nodeBean = loader.load(flowFile);\n      final String[] pathList = path.split(Constants.PATH_DELIMITER);\n      if (findPropsFromNodeBean(nodeBean, pathList, 0, propsList)) {\n        if (!propsList.isEmpty()) {\n          return propsList.get(0);\n        } else {\n          logger.error(\"Error getting props for \" + path);\n        }\n      }\n    } catch (final Exception e) {\n      logger.error(\"Failed to get props, error loading flow YAML file. \", e);\n    }\n    return null;\n  }", "category": "Python"}, {"instruction": "since Erlang discerns between exit and exit/2.", "input": "Java", "output": "private void exit(final int arity, final OtpErlangPid to,\n            final OtpErlangObject reason) {\n        try {\n            final String node = to.node();\n            if (node.equals(home.node())) {\n                home.deliver(new OtpMsg(OtpMsg.exitTag, self, to, reason));\n            } else {\n                final OtpCookedConnection conn = home.getConnection(node);\n                if (conn == null) {\n                    return;\n                }\n                switch (arity) {\n                case 1:\n                    conn.exit(self, to, reason);\n                    break;\n\n                case 2:\n                    conn.exit2(self, to, reason);\n                    break;\n                }\n            }\n        } catch (final Exception e) {\n        }\n    }", "category": "Python"}, {"instruction": "\u8ba1\u7b97Hash\u503c\n@param str \u88ab\u8ba1\u7b97Hash\u7684\u5b57\u7b26\u4e32\n@param k Hash\u7b97\u6cd5\u5e8f\u53f7\n@return Hash\u503c", "input": "Java", "output": "public static int hash(String str, int k) {\r\n\t\tswitch (k) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn HashUtil.rsHash(str);\r\n\t\t\tcase 1:\r\n\t\t\t\treturn HashUtil.jsHash(str);\r\n\t\t\tcase 2:\r\n\t\t\t\treturn HashUtil.elfHash(str);\r\n\t\t\tcase 3:\r\n\t\t\t\treturn HashUtil.bkdrHash(str);\r\n\t\t\tcase 4:\r\n\t\t\t\treturn HashUtil.apHash(str);\r\n\t\t\tcase 5:\r\n\t\t\t\treturn HashUtil.djbHash(str);\r\n\t\t\tcase 6:\r\n\t\t\t\treturn HashUtil.sdbmHash(str);\r\n\t\t\tcase 7:\r\n\t\t\t\treturn HashUtil.pjwHash(str);\r\n\t\t\tdefault:\r\n\t\t\t\treturn 0;\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "Releases all memory segments for the given owner.\n\n@param owner The owner memory segments are to be released.", "input": "Java", "output": "public void releaseAll(Object owner) {\n\t\tif (owner == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// -------------------- BEGIN CRITICAL SECTION -------------------\n\t\tsynchronized (lock) {\n\t\t\tif (isShutDown) {\n\t\t\t\tthrow new IllegalStateException(\"Memory manager has been shut down.\");\n\t\t\t}\n\n\t\t\t// get all segments\n\t\t\tfinal Set<MemorySegment> segments = allocatedSegments.remove(owner);\n\n\t\t\t// all segments may have been freed previously individually\n\t\t\tif (segments == null || segments.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// free each segment\n\t\t\tif (isPreAllocated) {\n\t\t\t\tfor (MemorySegment seg : segments) {\n\t\t\t\t\tmemoryPool.returnSegmentToPool(seg);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (MemorySegment seg : segments) {\n\t\t\t\t\tseg.free();\n\t\t\t\t}\n\t\t\t\tnumNonAllocatedPages += segments.size();\n\t\t\t}\n\n\t\t\tsegments.clear();\n\t\t}\n\t\t// -------------------- END CRITICAL SECTION -------------------\n\t}", "category": "Python"}, {"instruction": "Get default diagram image as bytes array\n@return the default diagram image", "input": "Java", "output": "protected InputStream getDefaultDiagram(String diagramImageFileName) {\n        String imageFileName = diagramImageFileName != null ?\n                diagramImageFileName :\n                getDefaultDiagramImageFileName();\n        InputStream imageStream = getClass().getResourceAsStream(imageFileName);\n        if (imageStream == null) {\n            throw new ActivitiImageException(\"Error occurred while getting default diagram image from file: \" + imageFileName);\n        }\n        return imageStream;\n    }", "category": "Python"}, {"instruction": "Extracts a time unit from a time value (milliseconds since midnight).", "input": "Java", "output": "public static int unixTimeExtract(TimeUnitRange range, int time) {\n\t\tassert time >= 0;\n\t\tassert time < MILLIS_PER_DAY;\n\t\tswitch (range) {\n\t\t\tcase HOUR:\n\t\t\t\treturn time / (int) MILLIS_PER_HOUR;\n\t\t\tcase MINUTE:\n\t\t\t\tfinal int minutes = time / (int) MILLIS_PER_MINUTE;\n\t\t\t\treturn minutes % 60;\n\t\t\tcase SECOND:\n\t\t\t\tfinal int seconds = time / (int) MILLIS_PER_SECOND;\n\t\t\t\treturn seconds % 60;\n\t\t\tdefault:\n\t\t\t\tthrow new ValidationException(\"unit \" + range + \" can not be applied to time variable\");\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Creates a {@link PemEncoded} value from the {@link PrivateKey}.", "input": "Java", "output": "static PemEncoded toPEM(ByteBufAllocator allocator, boolean useDirect, PrivateKey key) {\n        // We can take a shortcut if the private key happens to be already\n        // PEM/PKCS#8 encoded. This is the ideal case and reason why all\n        // this exists. It allows the user to pass pre-encoded bytes straight\n        // into OpenSSL without having to do any of the extra work.\n        if (key instanceof PemEncoded) {\n            return ((PemEncoded) key).retain();\n        }\n\n        byte[] bytes = key.getEncoded();\n        if (bytes == null) {\n            throw new IllegalArgumentException(key.getClass().getName() + \" does not support encoding\");\n        }\n\n        return toPEM(allocator, useDirect, bytes);\n    }", "category": "Python"}, {"instruction": "Creates a subscription to a given topic. See the &lt;a\nhref=\"https://cloud.google.com/pubsub/docs/admin#resource_names\"&gt; resource name\nrules&lt;/a&gt;. If the subscription already exists, returns `ALREADY_EXISTS`. If the\ncorresponding topic doesn't exist, returns `NOT_FOUND`.\n\n<p>If the name is not provided in the request, the server will assign a random name for this\nsubscription on the same project as the topic, conforming to the [resource name\nformat](https://cloud.google.com/pubsub/docs/admin#resource_names). The generated name is\npopulated in the returned Subscription object. Note that for REST API requests, you must\nspecify a name in the request.\n\n<p>Sample code:\n\n<pre><code>\ntry (SubscriptionAdminClient subscriptionAdminClient = SubscriptionAdminClient.create()) {\nProjectSubscriptionName name = ProjectSubscriptionName.of(\"[PROJECT]\", \"[SUBSCRIPTION]\");\nProjectTopicName topic = ProjectTopicName.of(\"[PROJECT]\", \"[TOPIC]\");\nPushConfig pushConfig = PushConfig.newBuilder().build();\nint ackDeadlineSeconds = 0;\nSubscription response = subscriptionAdminClient.createSubscription(name, topic, pushConfig, ackDeadlineSeconds);\n}\n</code></pre>\n\n@param name The name of the subscription. It must have the format\n`\"projects/{project}/subscriptions/{subscription}\"`. `{subscription}` must start with a\nletter, and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`), underscores\n(`_`), periods (`.`), tildes (`~`), plus (`+`) or percent signs (`%`). It must be between 3\nand 255 characters in length, and it must not start with `\"goog\"`\n@param topic The name of the topic from which this subscription is receiving messages. Format\nis `projects/{project}/topics/{topic}`. The value of this field will be `_deleted-topic_`\nif the topic has been deleted.\n@param pushConfig If push delivery is used with this subscription, this field is used to\nconfigure it. An empty `pushConfig` signifies that the subscriber will pull and ack\nmessages using API methods.\n@param ackDeadlineSeconds The approximate amount of time (on a best-effort basis) Pub/Sub waits\nfor the subscriber to acknowledge receipt before resending the message. In the interval\nafter the message is delivered and before it is acknowledged, it is considered to be\n&lt;i&gt;outstanding&lt;/i&gt;. During that time period, the message will not be\nredelivered (on a best-effort basis).\n<p>For pull subscriptions, this value is used as the initial value for the ack deadline. To\noverride this value for a given message, call `ModifyAckDeadline` with the corresponding\n`ack_id` if using non-streaming pull or send the `ack_id` in a\n`StreamingModifyAckDeadlineRequest` if using streaming pull. The minimum custom deadline\nyou can specify is 10 seconds. The maximum custom deadline you can specify is 600 seconds\n(10 minutes). If this parameter is 0, a default value of 10 seconds is used.\n<p>For push delivery, this value is also used to set the request timeout for the call to\nthe push endpoint.\n<p>If the subscriber never acknowledges the message, the Pub/Sub system will eventually\nredeliver the message.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "public final Subscription createSubscription(\n      ProjectSubscriptionName name,\n      ProjectTopicName topic,\n      PushConfig pushConfig,\n      int ackDeadlineSeconds) {\n\n    Subscription request =\n        Subscription.newBuilder()\n            .setName(name == null ? null : name.toString())\n            .setTopic(topic == null ? null : topic.toString())\n            .setPushConfig(pushConfig)\n            .setAckDeadlineSeconds(ackDeadlineSeconds)\n            .build();\n    return createSubscription(request);\n  }", "category": "Python"}, {"instruction": "Return the sub task's serialized job information.\n\n@return serialized job information (may be <tt>null</tt> before a call to {@link\n#loadBigData(PermanentBlobService)}).", "input": "Java", "output": "@Nullable\n\tpublic SerializedValue<JobInformation> getSerializedJobInformation() {\n\t\tif (serializedJobInformation instanceof NonOffloaded) {\n\t\t\tNonOffloaded<JobInformation> jobInformation =\n\t\t\t\t(NonOffloaded<JobInformation>) serializedJobInformation;\n\t\t\treturn jobInformation.serializedValue;\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\"Trying to work with offloaded serialized job information.\");\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Finds all unused stubs for given mocks\n\n@param mocks full list of mocks", "input": "Java", "output": "public List<Invocation> find(List<?> mocks) {\n        List<Invocation> unused = new LinkedList<Invocation>();\n        for (Object mock : mocks) {\n            List<Stubbing> fromSingleMock = MockUtil.getInvocationContainer(mock).getStubbingsDescending();\n            for(Stubbing s : fromSingleMock) {\n                if (!s.wasUsed()) {\n                     unused.add(s.getInvocation());\n                }\n            }\n        }\n        return unused;\n    }", "category": "Python"}, {"instruction": "Checks whether {@link DateTimeFormat} pattern contains time zone-related field.", "input": "Java", "output": "private static boolean datetimeFormatSpecifiesZone(Slice formatString)\n    {\n        boolean quoted = false;\n        for (char c : formatString.toStringUtf8().toCharArray()) {\n            if (quoted) {\n                if (c == '\\'') {\n                    quoted = false;\n                }\n                continue;\n            }\n\n            switch (c) {\n                case 'z':\n                case 'Z':\n                    return true;\n                case '\\'':\n                    // '' (two apostrophes) in a pattern denote single apostrophe and here we interpret this as \"start quote\" + \"end quote\".\n                    // This has no impact on method's result value.\n                    quoted = true;\n                    break;\n            }\n        }\n        return false;\n    }", "category": "Python"}, {"instruction": "This method creates compressed INDArray from Java float array, skipping usual INDArray instantiation routines\n\n@param data\n@param shape\n@param order\n@return", "input": "Java", "output": "@Override\n    public INDArray compress(float[] data, int[] shape, char order) {\n        FloatPointer pointer = new FloatPointer(data);\n\n        DataBuffer shapeInfo = Nd4j.getShapeInfoProvider().createShapeInformation(ArrayUtil.toLongArray(shape), order, DataType.FLOAT).getFirst();\n        DataBuffer buffer = compressPointer(DataTypeEx.FLOAT, pointer, data.length, 4);\n\n        return Nd4j.createArrayFromShapeBuffer(buffer, shapeInfo);\n    }", "category": "Python"}, {"instruction": "Gets the selected alerts from the {@link #treeAlert alerts tree}.\n\n@param allAlerts {@code true} if it should return all selected alerts, {@code false} to just return the first selected\nalert.\n@return a {@code Set} with the selected alerts, never {@code null}.", "input": "Java", "output": "private Set<Alert> getSelectedAlertsImpl(boolean allAlerts) {\r\n\t\tTreePath[] paths = getTreeAlert().getSelectionPaths();\r\n\t\tif (paths == null || paths.length == 0) {\r\n\t\t\treturn Collections.emptySet();\r\n\t\t}\r\n\r\n\t\tSet<Alert> alerts = new HashSet<>();\r\n\t\tif (!allAlerts) {\r\n\t\t\tDefaultMutableTreeNode alertNode = (DefaultMutableTreeNode) paths[0].getLastPathComponent();\r\n\t\t\talerts.add((Alert) alertNode.getUserObject());\r\n\t\t\treturn alerts;\r\n\t\t}\r\n\r\n\t\tfor (int i = 0; i < paths.length; i++) {\r\n\t\t\tDefaultMutableTreeNode alertNode = (DefaultMutableTreeNode) paths[i].getLastPathComponent();\r\n\t\t\tif (alertNode.getChildCount() == 0) {\r\n\t\t\t\talerts.add((Alert) alertNode.getUserObject());\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (int j = 0; j < alertNode.getChildCount(); j++) {\r\n\t\t\t\tDefaultMutableTreeNode node = (DefaultMutableTreeNode) alertNode.getChildAt(j);\r\n\t\t\t\talerts.add((Alert) node.getUserObject());\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn alerts;\r\n\t}", "category": "Python"}, {"instruction": "Fit a MultiDataSet (only compute based on the statistics from this dataset)\n\n@param dataSet the dataset to compute on", "input": "Java", "output": "@Override\n    public void fit(@NonNull MultiDataSet dataSet) {\n        Map<Integer, NormalizerStats.Builder> inputStatsBuilders = new HashMap<>();\n        Map<Integer, NormalizerStats.Builder> outputStatsBuilders = new HashMap<>();\n\n        fitPartial(dataSet, inputStatsBuilders, outputStatsBuilders);\n\n        inputStats = buildAllStats(inputStatsBuilders);\n        outputStats = buildAllStats(outputStatsBuilders);\n    }", "category": "Python"}, {"instruction": "\u83b7\u5f97\u5b57\u6bb5\u540d\u548c\u5b57\u6bb5\u63cf\u8ff0Map\u3002\u5185\u90e8\u4f7f\u7528\uff0c\u76f4\u63a5\u83b7\u53d6Bean\u7c7b\u7684PropertyDescriptor\n\n@param clazz Bean\u7c7b\n@param ignoreCase \u662f\u5426\u5ffd\u7565\u5927\u5c0f\u5199\n@return \u5b57\u6bb5\u540d\u548c\u5b57\u6bb5\u63cf\u8ff0Map\n@throws BeanException \u83b7\u53d6\u5c5e\u6027\u5f02\u5e38", "input": "Java", "output": "private static Map<String, PropertyDescriptor> internalGetPropertyDescriptorMap(Class<?> clazz, boolean ignoreCase) throws BeanException {\r\n\t\tfinal PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(clazz);\r\n\t\tfinal Map<String, PropertyDescriptor> map = ignoreCase ? new CaseInsensitiveMap<String, PropertyDescriptor>(propertyDescriptors.length, 1)\r\n\t\t\t\t: new HashMap<String, PropertyDescriptor>((int) (propertyDescriptors.length), 1);\r\n\r\n\t\tfor (PropertyDescriptor propertyDescriptor : propertyDescriptors) {\r\n\t\t\tmap.put(propertyDescriptor.getName(), propertyDescriptor);\r\n\t\t}\r\n\t\treturn map;\r\n\t}", "category": "Python"}, {"instruction": "Reset the TableColumnManager to only manage the TableColumns that are\ncurrently visible in the table.\n\nGenerally this method should only be invoked by the TableColumnManager\nwhen the TableModel of the table is changed.", "input": "Java", "output": "public void reset() {\r\n\t\ttable.getColumnModel().removeColumnModelListener(this);\r\n\t\tcolumnModel = table.getColumnModel();\r\n\t\tcolumnModel.addColumnModelListener(this);\r\n\r\n\t\t// Keep a duplicate TableColumns for managing hidden TableColumns\r\n\r\n\t\tint count = columnModel.getColumnCount();\r\n\t\tallColumns = new ArrayList<>(count);\r\n\r\n\t\tfor (int i = 0; i < count; i++) {\r\n\t\t\tallColumns.add(columnModel.getColumn(i));\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "\u83b7\u5f97 Sofa Runtime \u7684\u65e5\u5fd7\u5bf9\u8c61\uff0c\u6253\u5370\u51fa\u83b7\u5f97Config Data \u4fe1\u606f", "input": "Java", "output": "private void printConfigData(String dataId, ConfigData configData) {\n\n        StringBuilder sb = new StringBuilder();\n        int count = 0;\n\n        if (configData != null && StringUtils.isNotBlank(configData.getData())) {\n            final String[] split = StringUtils.split(configData.getData(), CONFIG_SEPARATOR);\n            List<String> dataList = Arrays.asList(split);\n            for (String provider : dataList) {\n                sb.append(\"  >>> \").append(provider).append(\"\\n\");\n                count++;\n            }\n        }\n\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(LogCodes.getLiteLog(\n                \"Receive RPC config info: service[{0}]\\n  usable config info[{1}]\\n{2}\",\n                dataId, count, sb.toString()));\n        }\n    }", "category": "Python"}, {"instruction": "\u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u4e32\u7684\u6240\u6709\u5b57\u7b26\u662f\u5426\u5728\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\u96c6\u5408\u4e2d\n\n@param aggr \u5b57\u7b26\u4e32\u96c6\u5408\n@param str  \u9700\u8981\u5224\u65ad\u7684\u5b57\u7b26\u4e32\n@return", "input": "Java", "output": "public static boolean isInAggregate(String aggr, String str)\n    {\n        if (aggr != null && str != null)\n        {\n            str += \"1\";\n            for (int i = 0; i < str.length(); i++)\n            {\n                String s = str.substring(i, i + 1);\n                if (aggr.indexOf(s) == -1)\n                    return false;\n            }\n            return true;\n        }\n\n        return false;\n    }", "category": "Python"}, {"instruction": "This method initializes menuItemPolicy\n\n@return javax.swing.JMenuItem", "input": "Java", "output": "private ZapMenuItem getMenuItemPolicy() {\r\n        if (menuItemPolicy == null) {\r\n            menuItemPolicy = new ZapMenuItem(\"menu.analyse.scanPolicy\",\r\n                    getView().getMenuShortcutKeyStroke(KeyEvent.VK_P, 0, false));\r\n\r\n            menuItemPolicy.addActionListener(new java.awt.event.ActionListener() {\r\n                @Override\r\n                public void actionPerformed(java.awt.event.ActionEvent e) {\r\n                    showPolicyManagerDialog();\r\n                }\r\n            });\r\n\r\n        }\r\n        \r\n        return menuItemPolicy;\r\n    }", "category": "Python"}, {"instruction": "Creates a data stream from the given non-empty collection. The type of the data stream is that of the\nelements in the collection.\n\n<p>The framework will try and determine the exact type from the collection elements. In case of generic\nelements, it may be necessary to manually supply the type information via\n{@link #fromCollection(java.util.Collection, org.apache.flink.api.common.typeinfo.TypeInformation)}.\n\n<p>Note that this operation will result in a non-parallel data stream source, i.e. a data stream source with\nparallelism one.\n\n@param data\nThe collection of elements to create the data stream from.\n@param <OUT>\nThe generic type of the returned data stream.\n@return\nThe data stream representing the given collection", "input": "Java", "output": "public <OUT> DataStreamSource<OUT> fromCollection(Collection<OUT> data) {\n\t\tPreconditions.checkNotNull(data, \"Collection must not be null\");\n\t\tif (data.isEmpty()) {\n\t\t\tthrow new IllegalArgumentException(\"Collection must not be empty\");\n\t\t}\n\n\t\tOUT first = data.iterator().next();\n\t\tif (first == null) {\n\t\t\tthrow new IllegalArgumentException(\"Collection must not contain null elements\");\n\t\t}\n\n\t\tTypeInformation<OUT> typeInfo;\n\t\ttry {\n\t\t\ttypeInfo = TypeExtractor.getForObject(first);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new RuntimeException(\"Could not create TypeInformation for type \" + first.getClass()\n\t\t\t\t\t+ \"; please specify the TypeInformation manually via \"\n\t\t\t\t\t+ \"StreamExecutionEnvironment#fromElements(Collection, TypeInformation)\", e);\n\t\t}\n\t\treturn fromCollection(data, typeInfo);\n\t}", "category": "Python"}, {"instruction": "Copies the content of this string to a byte array.\n\n@param srcIdx the starting offset of characters to copy.\n@param dst the destination byte array.\n@param dstIdx the starting offset in the destination byte array.\n@param length the number of characters to copy.", "input": "Java", "output": "public void copy(int srcIdx, byte[] dst, int dstIdx, int length) {\n        if (isOutOfBounds(srcIdx, length, length())) {\n            throw new IndexOutOfBoundsException(\"expected: \" + \"0 <= srcIdx(\" + srcIdx + \") <= srcIdx + length(\"\n                            + length + \") <= srcLen(\" + length() + ')');\n        }\n\n        System.arraycopy(value, srcIdx + offset, checkNotNull(dst, \"dst\"), dstIdx, length);\n    }", "category": "Python"}, {"instruction": "Removes the given panels of given panel type from the workbench panel.\n\n@param panels the panels to remove from the workbench panel\n@param panelType the type of the panels\n@throws IllegalArgumentException if any of the parameters is {@code null}.\n@since 2.5.0\n@see #addPanels(List, PanelType)\n@see #removePanel(AbstractPanel, PanelType)", "input": "Java", "output": "public void removePanels(List<AbstractPanel> panels, PanelType panelType) {\r\n\t\tvalidateNotNull(panels, \"panels\");\r\n\t\tvalidateNotNull(panelType, \"panelType\");\r\n\r\n\t\tremovePanels(getTabbedFull(), panels);\r\n\r\n\t\tswitch (panelType) {\r\n\t\tcase SELECT:\r\n\t\t\tremovePanels(getTabbedSelect(), panels);\r\n\t\t\tbreak;\r\n\t\tcase STATUS:\r\n\t\t\tremovePanels(getTabbedStatus(), panels);\r\n\t\t\tbreak;\r\n\t\tcase WORK:\r\n\t\t\tremovePanels(getTabbedWork(), panels);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "This method initializes this", "input": "Java", "output": "private void initialize() {\r\n        this.setName(Constant.messages.getString(\"options.script.title\"));\r\n        this.setLayout(new GridBagLayout());\r\n\r\n        GridBagConstraints gbc = new GridBagConstraints();\r\n        gbc.gridx = 0;\r\n        gbc.weightx = 1.0;\r\n        gbc.anchor = GridBagConstraints.LINE_START;\r\n        gbc.fill = GridBagConstraints.BOTH;\r\n\r\n        this.add(new JLabel(Constant.messages.getString(\"options.script.label.dirs\")), gbc);\r\n\r\n        tokensOptionsPanel = new AntiCsrfMultipleOptionsPanel(this.extension, getScriptDirModel());\r\n        \r\n        gbc.weighty = 1.0;\r\n        this.add(tokensOptionsPanel, gbc);\r\n\t}", "category": "Python"}, {"instruction": "Basically it works as low and high values were the same for source and filteringSource and just looks at NDVs.", "input": "Java", "output": "public static PlanNodeStatsEstimate computeSemiJoin(PlanNodeStatsEstimate sourceStats, PlanNodeStatsEstimate filteringSourceStats, Symbol sourceJoinSymbol, Symbol filteringSourceJoinSymbol)\n    {\n        return compute(sourceStats, filteringSourceStats, sourceJoinSymbol, filteringSourceJoinSymbol,\n                (sourceJoinSymbolStats, filteringSourceJoinSymbolStats) ->\n                        min(filteringSourceJoinSymbolStats.getDistinctValuesCount(), sourceJoinSymbolStats.getDistinctValuesCount()));\n    }", "category": "Python"}, {"instruction": "region AutoCloseable Implementation", "input": "Java", "output": "@Override\n    public void close() {\n        if (!this.closed.getAndSet(true)) {\n            // Close all containers that are still open.\n            ArrayList<CompletableFuture<Void>> results = new ArrayList<>();\n            synchronized (this.handles) {\n                ArrayList<ContainerHandle> toClose = new ArrayList<>(this.handles.values());\n                for (ContainerHandle handle : toClose) {\n                    results.add(this.registry.stopContainer(handle, CLOSE_TIMEOUT_PER_CONTAINER));\n                }\n            }\n\n            // Wait for all the containers to be closed.\n            Futures.await(Futures.allOf(results), CLOSE_TIMEOUT_PER_CONTAINER.toMillis());\n        }\n    }", "category": "Python"}, {"instruction": "Generates the REST API documentation.\n\n@param args args[0] contains the directory into which the generated files are placed\n@throws IOException if any file operation failed", "input": "Java", "output": "public static void main(String[] args) throws IOException {\n\t\tString outputDirectory = args[0];\n\n\t\tfor (final RestAPIVersion apiVersion : RestAPIVersion.values()) {\n\t\t\tif (apiVersion == RestAPIVersion.V0) {\n\t\t\t\t// this version exists only for testing purposes\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcreateHtmlFile(\n\t\t\t\tnew DocumentingDispatcherRestEndpoint(),\n\t\t\t\tapiVersion,\n\t\t\t\tPaths.get(outputDirectory, \"rest_\" + apiVersion.getURLVersionPrefix() + \"_dispatcher.html\"));\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Checks if the current security principal has the permission to create top level items within the specified\nitem group.\n<p>\nThis is just a convenience function.\n@param c the container of the item.\n@param d the descriptor of the item to be created.\n@throws AccessDeniedException\nif the user doesn't have the permission.\n@since 1.607", "input": "Java", "output": "public final void checkCreatePermission(@Nonnull ItemGroup c,\n                                            @Nonnull TopLevelItemDescriptor d) {\n        Authentication a = Jenkins.getAuthentication();\n        if (a == SYSTEM) {\n            return;\n        }\n        if (!hasCreatePermission(a, c, d)) {\n            throw new AccessDeniedException(Messages.AccessDeniedException2_MissingPermission(a.getName(),\n                    Item.CREATE.group.title+\"/\"+Item.CREATE.name + Item.CREATE + \"/\" + d.getDisplayName()));\n        }\n    }", "category": "Python"}, {"instruction": "Removes the given slot from the slot manager.\n\n@param slotId identifying the slot to remove", "input": "Java", "output": "private void removeSlot(SlotID slotId) {\n\t\tTaskManagerSlot slot = slots.remove(slotId);\n\n\t\tif (null != slot) {\n\t\t\tfreeSlots.remove(slotId);\n\n\t\t\tif (slot.getState() == TaskManagerSlot.State.PENDING) {\n\t\t\t\t// reject the pending slot request --> triggering a new allocation attempt\n\t\t\t\trejectPendingSlotRequest(\n\t\t\t\t\tslot.getAssignedSlotRequest(),\n\t\t\t\t\tnew Exception(\"The assigned slot \" + slot.getSlotId() + \" was removed.\"));\n\t\t\t}\n\n\t\t\tAllocationID oldAllocationId = slot.getAllocationId();\n\n\t\t\tif (oldAllocationId != null) {\n\t\t\t\tfulfilledSlotRequests.remove(oldAllocationId);\n\n\t\t\t\tresourceActions.notifyAllocationFailure(\n\t\t\t\t\tslot.getJobId(),\n\t\t\t\t\toldAllocationId,\n\t\t\t\t\tnew FlinkException(\"The assigned slot \" + slot.getSlotId() + \" was removed.\"));\n\t\t\t}\n\t\t} else {\n\t\t\tLOG.debug(\"There was no slot registered with slot id {}.\", slotId);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Utility method for determining the appropriate preprocessor for CNN layers, such as {@link ConvolutionLayer} and\n{@link SubsamplingLayer}\n\n@param inputType     Input type to get the preprocessor for\n@return              Null if no preprocessor is required; otherwise the appropriate preprocessor for the given input type", "input": "Java", "output": "public static InputPreProcessor getPreProcessorForInputTypeCnn3DLayers(InputType inputType, String layerName) {\n        switch (inputType.getType()) {\n            case FF:\n                log.info(\"Automatic addition of FF -> CNN3D preprocessors: not yet implemented (layer name: \\\"\"\n                                + layerName + \"\\\")\");\n                return null;\n            case RNN:\n                log.warn(\"Automatic addition of RNN -> CNN3D preprocessors: not yet implemented (layer name: \\\"\"\n                                + layerName + \"\\\")\");\n                return null;\n            // TODO: handle CNN to CNN3D\n            case CNN3D:\n                return null;\n            default:\n                throw new RuntimeException(\"Unknown input type: \" + inputType);\n        }\n    }", "category": "Python"}, {"instruction": "Get a sum of bucket counts from either the start of a histogram's range or end, up to a specified cutoff value.\n\nFor example, if I have the following histogram with a range of 0-40, with 4 buckets and\nper-bucket counts of 5, 2, 10, and 7:\n\n|   5   |   2   |   24   |   7   |\n0       10      20       30      40\n\nCalling this function with a cutoff of 25 and fromStart = true would:\n- Sum the first two bucket counts 5 + 2\n- Since the cutoff falls in the third bucket, multiply the third bucket's count by the fraction of the bucket range\ncovered by the cutoff, in this case the fraction is ((25 - 20) / 10) = 0.5\n- The total count returned is 5 + 2 + 12\n\n@param cutoff Cutoff point within the histogram's range\n@param fromStart If true, sum the bucket counts starting from the beginning of the histogram range.\nIf false, sum from the other direction, starting from the end of the histogram range.\n@return Sum of bucket counts up to the cutoff point", "input": "Java", "output": "private double getCumulativeCount(double cutoff, boolean fromStart)\n  {\n    int cutoffBucket = (int) ((cutoff - lowerLimit) / bucketSize);\n    double count = 0;\n\n    if (fromStart) {\n      for (int i = 0; i <= cutoffBucket; i++) {\n        if (i == cutoffBucket) {\n          double bucketStart = i * bucketSize + lowerLimit;\n          double partialCount = ((cutoff - bucketStart) / bucketSize) * histogram[i];\n          count += partialCount;\n        } else {\n          count += histogram[i];\n        }\n      }\n    } else {\n      for (int i = cutoffBucket; i < histogram.length; i++) {\n        if (i == cutoffBucket) {\n          double bucketEnd = ((i + 1) * bucketSize) + lowerLimit;\n          double partialCount = ((bucketEnd - cutoff) / bucketSize) * histogram[i];\n          count += partialCount;\n        } else {\n          count += histogram[i];\n        }\n      }\n    }\n    return count;\n  }", "category": "Python"}, {"instruction": "\u83b7\u53d6\u5f53\u524d\u72b6\u6001\u53ef\u80fd\u7684\u52a8\u4f5c\uff08\u52a8\u4f5c=shift | left | right + \u4f9d\u5b58\u5173\u7cfb\uff0c\u4e5f\u5c31\u662f\u8bf4\u662f\u4e00\u6761\u65e2\u6709\u65b9\u5411\u53c8\u6709\u4f9d\u5b58\u5173\u7cfb\u540d\u79f0\u7684\u4f9d\u5b58\u8fb9\uff09\n@param source \u5f53\u524d\u72b6\u6001\n@param actions \u8f93\u51fa\u53ef\u80fd\u52a8\u4f5c", "input": "Java", "output": "void get_possible_actions(State source,\n                              List<Action> actions)\n    {\n        if (0 == L || -1 == R)\n        {\n            System.err.println(\"decoder: not initialized, please check if the root dependency relation is correct set by --root.\");\n            return;\n        }\n        actions.clear();\n\n        if (!source.buffer_empty())\n        {\n            actions.add(ActionFactory.make_shift());\n        }\n\n        if (source.stack_size() == 2)\n        {\n            if (source.buffer_empty())\n            {\n                actions.add(ActionFactory.make_right_arc(R));\n            }\n        }\n        else if (source.stack_size() > 2)\n        {\n            for (int l = 0; l < L; ++l)\n            {\n                if (l == R)\n                {\n                    continue;\n                }\n                actions.add(ActionFactory.make_left_arc(l));\n                actions.add(ActionFactory.make_right_arc(l));\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Return the layer size (number of units) for the specified layer.<br>\nNote that the meaning of the \"layer size\" can depend on the type of layer. For example:<br>\n- DenseLayer, OutputLayer, recurrent layers: number of units (nOut configuration option)<br>\n- ConvolutionLayer: the channels (number of channels)<br>\n- Subsampling layers, global pooling layers, etc: size of 0 is always returned<br>\n\n@param layerName Name of the layer to get the size of\n@return Size of the layer", "input": "Java", "output": "public int layerSize(String layerName) {\n        Layer l = getLayer(layerName);\n        if(l == null){\n            throw new IllegalArgumentException(\"No layer with name \\\"\" + layerName + \"\\\" exists\");\n        }\n        org.deeplearning4j.nn.conf.layers.Layer conf = l.conf().getLayer();\n        if (conf == null || !(conf instanceof FeedForwardLayer)) {\n            return 0;\n        }\n        FeedForwardLayer ffl = (FeedForwardLayer) conf;\n\n        // FIXME: int cast\n        return (int) ffl.getNOut();\n    }", "category": "Python"}, {"instruction": "Get the offset associated with an address encoded by\n{@link TaskMemoryManager#encodePageNumberAndOffset(MemoryBlock, long)}", "input": "Java", "output": "public long getOffsetInPage(long pagePlusOffsetAddress) {\n    final long offsetInPage = decodeOffset(pagePlusOffsetAddress);\n    if (tungstenMemoryMode == MemoryMode.ON_HEAP) {\n      return offsetInPage;\n    } else {\n      // In off-heap mode, an offset is an absolute address. In encodePageNumberAndOffset, we\n      // converted the absolute address into a relative address. Here, we invert that operation:\n      final int pageNumber = decodePageNumber(pagePlusOffsetAddress);\n      assert (pageNumber >= 0 && pageNumber < PAGE_TABLE_SIZE);\n      final MemoryBlock page = pageTable[pageNumber];\n      assert (page != null);\n      return page.getBaseOffset() + offsetInPage;\n    }\n  }", "category": "Python"}, {"instruction": "\u6839\u636e\u7ed9\u5b9a\u7684\u56fe\u7247\u683c\u5f0f\u6216\u8005\u6269\u5c55\u540d\u83b7\u53d6{@link ImageWriter}\uff0c\u5982\u679c\u672a\u627e\u5230\u5408\u9002\u7684Writer\uff0c\u8fd4\u56denull\n\n@param formatName \u56fe\u7247\u683c\u5f0f\u6216\u6269\u5c55\u540d\uff0c\u4f8b\u5982\"jpg\"\u3001\"png\"\n@return {@link ImageWriter}\n@since 4.3.2", "input": "Java", "output": "public static ImageWriter getWriter(String formatName) {\r\n\t\tImageWriter writer = null;\r\n\t\tIterator<ImageWriter> iter = ImageIO.getImageWritersByFormatName(formatName);\r\n\t\tif (iter.hasNext()) {\r\n\t\t\twriter = iter.next();\r\n\t\t}\r\n\t\tif (null == writer) {\r\n\t\t\t// \u5c1d\u8bd5\u6269\u5c55\u540d\u83b7\u53d6\r\n\t\t\titer = ImageIO.getImageWritersBySuffix(formatName);\r\n\t\t\tif (iter.hasNext()) {\r\n\t\t\t\twriter = iter.next();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn writer;\r\n\t}", "category": "Python"}, {"instruction": "/*\nthis method simulates net_kernel only for the purpose of replying to\npings.", "input": "Java", "output": "private boolean netKernel(final OtpMsg m) {\n        OtpMbox mbox = null;\n        try {\n            final OtpErlangTuple t = (OtpErlangTuple) m.getMsg();\n            final OtpErlangTuple req = (OtpErlangTuple) t.elementAt(1); // actual\n            // request\n\n            final OtpErlangPid pid = (OtpErlangPid) req.elementAt(0); // originating\n            // pid\n\n            final OtpErlangObject[] pong = new OtpErlangObject[2];\n            pong[0] = req.elementAt(1); // his #Ref\n            pong[1] = new OtpErlangAtom(\"yes\");\n\n            mbox = createMbox();\n            mbox.send(pid, new OtpErlangTuple(pong));\n            return true;\n        } catch (final Exception e) {\n        } finally {\n            closeMbox(mbox);\n        }\n        return false;\n    }", "category": "Python"}, {"instruction": "\u521b\u5efa\u5e26cluster\u6a21\u5f0f\u7684\u5ba2\u6237\u7aef\u94fe\u63a5\uff0c\u81ea\u52a8\u5b8c\u6210failover\u5207\u6362\uff0c\u670d\u52a1\u5668\u5217\u8868\u81ea\u52a8\u626b\u63cf\n\n@param zkServers\n@param destination\n@param username\n@param password\n@return", "input": "Java", "output": "public static CanalConnector newClusterConnector(String zkServers, String destination, String username,\n                                                     String password) {\n        ClusterCanalConnector canalConnector = new ClusterCanalConnector(username,\n            password,\n            destination,\n            new ClusterNodeAccessStrategy(destination, ZkClientx.getZkClient(zkServers)));\n        canalConnector.setSoTimeout(60 * 1000);\n        canalConnector.setIdleTimeout(60 * 60 * 1000);\n        return canalConnector;\n    }", "category": "Python"}, {"instruction": "Sets the Active SegmentChunk handle.\n\n@param handle The handle. Must not be read-only and for the last SegmentChunk.", "input": "Java", "output": "synchronized void setActiveChunkHandle(SegmentHandle handle) {\n        Preconditions.checkArgument(handle == null || !handle.isReadOnly(), \"Active SegmentChunk handle cannot be readonly.\");\n        SegmentChunk last = lastChunk();\n        Preconditions.checkState(last != null, \"Cannot set an Active SegmentChunk handle when there are no SegmentChunks.\");\n        Preconditions.checkArgument(handle == null || handle.getSegmentName().equals(last.getName()),\n                \"Active SegmentChunk handle must be for the last SegmentChunk.\");\n        this.activeChunkHandle = handle;\n    }", "category": "Python"}, {"instruction": "Can ping.\n\n@return true/false", "input": "Java", "output": "public boolean canPing() {\n        val uidPsw = getClass().getSimpleName();\n        for (val server : this.servers) {\n            LOGGER.debug(\"Attempting to ping RADIUS server [{}] via simulating an authentication request. If the server responds \"\n                + \"successfully, mock authentication will fail correctly.\", server);\n            try {\n                server.authenticate(uidPsw, uidPsw);\n            } catch (final TimeoutException | SocketTimeoutException e) {\n                LOGGER.debug(\"Server [{}] is not available\", server);\n                continue;\n            } catch (final Exception e) {\n                LOGGER.debug(\"Pinging RADIUS server was successful. Response [{}]\", e.getMessage());\n            }\n            return true;\n        }\n        return false;\n    }", "category": "Python"}, {"instruction": "Load Keras (Functional API) Model saved using model.save_model(...).\n\n@param modelHdf5Filename     path to HDF5 archive storing Keras Model\n@param inputShape            optional input shape for models that come without such (e.g. notop = false models)\n@param enforceTrainingConfig whether to enforce training configuration options\n@return ComputationGraph\n@throws IOException                            IO exception\n@throws InvalidKerasConfigurationException     Invalid Keras config\n@throws UnsupportedKerasConfigurationException Unsupported Keras config\n@see ComputationGraph", "input": "Java", "output": "public static ComputationGraph importKerasModelAndWeights(String modelHdf5Filename, int[] inputShape,\n                                                              boolean enforceTrainingConfig)\n            throws IOException, UnsupportedKerasConfigurationException, InvalidKerasConfigurationException {\n        KerasModel kerasModel = new KerasModel().modelBuilder.modelHdf5Filename(modelHdf5Filename)\n                .enforceTrainingConfig(enforceTrainingConfig).inputShape(inputShape).buildModel();\n        return kerasModel.getComputationGraph();\n    }", "category": "Python"}, {"instruction": "Applies the given window function to each window. The window function is called for each\nevaluation of the window. The output of the window function is\ninterpreted as a regular non-windowed stream.\n\n<p>Note that this function requires that all data in the windows is buffered until the window\nis evaluated, as the function provides no means of incremental aggregation.\n\n@param function The process window function.\n@return The data stream that is the result of applying the window function to the window.", "input": "Java", "output": "@PublicEvolving\n\tpublic <R> SingleOutputStreamOperator<R> process(ProcessAllWindowFunction<T, R, W> function) {\n\t\tString callLocation = Utils.getCallLocationName();\n\t\tfunction = input.getExecutionEnvironment().clean(function);\n\t\tTypeInformation<R> resultType = getProcessAllWindowFunctionReturnType(function, getInputType());\n\t\treturn apply(new InternalIterableProcessAllWindowFunction<>(function), resultType, callLocation);\n\t}", "category": "Python"}, {"instruction": "Evaluate the network (for classification) on the provided data set, with top N accuracy in addition to standard accuracy.\nFor 'standard' accuracy evaluation only, use topN = 1\n\n@param iterator   Iterator (data) to evaluate on\n@param labelsList List of labels. May be null.\n@param topN       N value for top N accuracy evaluation\n@return Evaluation object, summarizing the results of the evaluation on the provided DataSetIterator", "input": "Java", "output": "public <T extends Evaluation> T evaluate(DataSetIterator iterator, List<String> labelsList, int topN) {\n        if (labelsList == null)\n            labelsList = iterator.getLabels();\n\n        Layer outputLayer = getOutputLayer(0);\n        if(getConfiguration().isValidateOutputLayerConfig()){\n            OutputLayerUtil.validateOutputLayerForClassifierEvaluation(outputLayer.conf().getLayer(), Evaluation.class);\n        }\n\n        return (T)doEvaluation(iterator, new org.deeplearning4j.eval.Evaluation(labelsList, topN))[0];\n    }", "category": "Python"}, {"instruction": "Execute add operation boolean.\n\n@param connectionFactory the connection factory\n@param entry             the entry\n@return true/false", "input": "Java", "output": "public static boolean executeAddOperation(final ConnectionFactory connectionFactory, final LdapEntry entry) {\n        try (val connection = createConnection(connectionFactory)) {\n            val operation = new AddOperation(connection);\n            operation.execute(new AddRequest(entry.getDn(), entry.getAttributes()));\n            return true;\n        } catch (final LdapException e) {\n            LOGGER.error(e.getMessage(), e);\n        }\n        return false;\n    }", "category": "Python"}, {"instruction": "Returns type information for Java arrays of primitive type (such as <code>byte[]</code>). The array\nmust not be null.\n\n@param elementType element type of the array (e.g. Types.BOOLEAN, Types.INT, Types.DOUBLE)", "input": "Java", "output": "public static TypeInformation<?> PRIMITIVE_ARRAY(TypeInformation<?> elementType) {\n\t\tif (elementType == BOOLEAN) {\n\t\t\treturn PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO;\n\t\t} else if (elementType == BYTE) {\n\t\t\treturn PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO;\n\t\t} else if (elementType == SHORT) {\n\t\t\treturn PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO;\n\t\t} else if (elementType == INT) {\n\t\t\treturn PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO;\n\t\t} else if (elementType == LONG) {\n\t\t\treturn PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO;\n\t\t} else if (elementType == FLOAT) {\n\t\t\treturn PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO;\n\t\t} else if (elementType == DOUBLE) {\n\t\t\treturn PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO;\n\t\t} else if (elementType == CHAR) {\n\t\t\treturn PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Invalid element type for a primitive array.\");\n\t}", "category": "Python"}, {"instruction": "Closes the queue and prevents any other access to it. Any blocked call to takeAllItems() will fail with InterruptedException.\n\n@return If the queue has any more items in it, these will be returned here in the order in which they were inserted.\nThe items are guaranteed not to be returned both here and via take()/poll().", "input": "Java", "output": "public Queue<T> close() {\n        CompletableFuture<Queue<T>> pending = null;\n        Queue<T> result = null;\n        synchronized (this.contents) {\n            if (!this.closed) {\n                this.closed = true;\n                pending = this.pendingTake;\n                this.pendingTake = null;\n                result = fetch(this.contents.size());\n            }\n        }\n\n        // Cancel any pending poll request.\n        if (pending != null) {\n            pending.cancel(true);\n        }\n\n        return result != null ? result : new LinkedList<>();\n    }", "category": "Python"}, {"instruction": "Gets the nodes from the site tree which are \"In Scope\". Searches recursively starting from\nthe root node. Should be used with care, as it is time-consuming, querying the database for\nevery node in the Site Tree.\n\n@return the nodes in scope from site tree", "input": "Java", "output": "public List<SiteNode> getTopNodesInContextFromSiteTree() {\r\n\t\tList<SiteNode> nodes = new LinkedList<>();\r\n\t\tSiteNode rootNode = session.getSiteTree().getRoot();\r\n\t\t@SuppressWarnings(\"unchecked\")\r\n\t\tEnumeration<TreeNode> en = rootNode.children();\r\n\t\twhile (en.hasMoreElements()) {\r\n\t\t\tSiteNode sn = (SiteNode) en.nextElement();\r\n\t\t\tif (isContainsNodesInContext(sn)) {\r\n\t\t\t\tnodes.add(sn);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn nodes;\r\n\t}", "category": "Python"}, {"instruction": "Set the {@code Supplier} of {@link ClientHttpRequestFactory} that should be called\neach time we {@link #build()} a new {@link RestTemplate} instance.\n@param requestFactorySupplier the supplier for the request factory\n@return a new builder instance\n@since 2.0.0", "input": "Java", "output": "public RestTemplateBuilder requestFactory(\n\t\t\tSupplier<ClientHttpRequestFactory> requestFactorySupplier) {\n\t\tAssert.notNull(requestFactorySupplier,\n\t\t\t\t\"RequestFactory Supplier must not be null\");\n\t\treturn new RestTemplateBuilder(this.detectRequestFactory, this.rootUri,\n\t\t\t\tthis.messageConverters, requestFactorySupplier, this.uriTemplateHandler,\n\t\t\t\tthis.errorHandler, this.basicAuthentication, this.restTemplateCustomizers,\n\t\t\t\tthis.requestFactoryCustomizer, this.interceptors);\n\t}", "category": "Python"}, {"instruction": "Wraps the given {@link Throwable} in a {@link StatusRuntimeException}. If it contains an\nembedded {@link StatusException} or {@link StatusRuntimeException}, the returned exception will\ncontain the embedded trailers and status, with the given exception as the cause. Otherwise, an\nexception will be generated from an {@link Status#UNKNOWN} status.", "input": "Java", "output": "private static StatusRuntimeException toStatusRuntimeException(Throwable t) {\n    Throwable cause = checkNotNull(t, \"t\");\n    while (cause != null) {\n      // If we have an embedded status, use it and replace the cause\n      if (cause instanceof StatusException) {\n        StatusException se = (StatusException) cause;\n        return new StatusRuntimeException(se.getStatus(), se.getTrailers());\n      } else if (cause instanceof StatusRuntimeException) {\n        StatusRuntimeException se = (StatusRuntimeException) cause;\n        return new StatusRuntimeException(se.getStatus(), se.getTrailers());\n      }\n      cause = cause.getCause();\n    }\n    return Status.UNKNOWN.withDescription(\"unexpected exception\").withCause(t)\n        .asRuntimeException();\n  }", "category": "Python"}, {"instruction": "TODO optimize", "input": "Java", "output": "public ByteBuf preprocessJson(Integer jsonIndex, ByteBuf content) throws IOException {\n        String packet = URLDecoder.decode(content.toString(CharsetUtil.UTF_8), CharsetUtil.UTF_8.name());\n\n        if (jsonIndex != null) {\n            /**\n            * double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n            * (c) socket.io.js\n            *\n            * @see https://github.com/Automattic/socket.io-client/blob/1.3.3/socket.io.js#L2682\n            */\n            packet = packet.replace(\"\\\\\\\\n\", \"\\\\n\");\n\n            // skip \"d=\"\n            packet = packet.substring(2);\n        }\n\n        return Unpooled.wrappedBuffer(packet.getBytes(CharsetUtil.UTF_8));\n    }", "category": "Python"}, {"instruction": "11.14 Comma Operator", "input": "JavaScript", "output": "function parseExpression() {\n        var expr, startToken = lookahead;\n\n        expr = parseAssignmentExpression();\n\n        if (match(',')) {\n            expr = delegate.createSequenceExpression([ expr ]);\n\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expr.expressions.push(parseAssignmentExpression());\n            }\n\n            delegate.markEnd(expr, startToken);\n        }\n\n        return expr;\n    }", "category": "Python"}, {"instruction": "/* [MS-OFFCRYPTO] 2.1.6 DataSpaceMap", "input": "JavaScript", "output": "function parse_DataSpaceMap(blob) {\n\tvar o = [];\n\tblob.l += 4; // must be 0x8\n\tvar cnt = blob.read_shift(4);\n\twhile(cnt-- > 0) o.push(parse_DataSpaceMapEntry(blob));\n\treturn o;\n}", "category": "Python"}, {"instruction": "Checks a node to see if it's followed by a semicolon.\n@param {ASTNode} node The node to check.\n@returns {void}", "input": "JavaScript", "output": "function checkForSemicolon(node) {\n\t\t\t\tvar lastToken = sourceCode.getLastToken(node);\n\n\t\t\t\tif (never) {\n\t\t\t\t\tif (isUnnecessarySemicolon(lastToken)) {\n\t\t\t\t\t\treport(node, true);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!isSemicolon(lastToken)) {\n\t\t\t\t\t\tif (!exceptOneLine || !isOneLinerBlock(node)) {\n\t\t\t\t\t\t\treport(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (exceptOneLine && isOneLinerBlock(node)) {\n\t\t\t\t\t\t\treport(node, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}", "category": "Python"}, {"instruction": "Only use for SSL (RDP security layer TODO)\n@see http://msdn.microsoft.com/en-us/library/cc240518.aspx\n@param opt {object} Classic type options\n@returns {type.Component}", "input": "JavaScript", "output": "function serverSecurityData(opt) {\n\tvar self = {\n\t\t__TYPE__ : MessageType.SC_SECURITY,\n\t\tencryptionMethod : new type.UInt32Le(),\n\t\tencryptionLevel : new type.UInt32Le() \n\t};\n\t\n\treturn new type.Component(self, opt);\n}", "category": "Python"}, {"instruction": "i18n: - from .library/appData/manifest/sap.ui5/library/i18n - from library resources (if \"messagebundle.properties\" exists)", "input": "JavaScript", "output": "function i18n() {\n\t\t\t\tconst i18nElement = findChild(libraryAppData, \"i18n\");\n\t\t\t\tif ( i18nElement ) {\n\t\t\t\t\tconst i18n = i18nElement._;\n\t\t\t\t\tif ( i18n === \"false\" ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if ( i18n === \"true\" ) {\n\t\t\t\t\t\treturn \"messagebundle.properties\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn i18n;\n\t\t\t\t\t}\n\t\t\t\t\t// log.verbose(\"  sap.ui5/library/i18n property taken from .library appData: '%s'\", library.i18n);\n\t\t\t\t} else {\n\t\t\t\t\tif ( libBundle.findResource(\"messagebundle.properties\") != null ) {\n\t\t\t\t\t\t// log.verbose(\"  sap.ui5/library/i18n property determined from resources: '%s'\", library.i18n);\n\t\t\t\t\t\treturn \"messagebundle.properties\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}", "category": "Python"}, {"instruction": "Helper to instantiate chess.js correctly on both browser and Node.", "input": "JavaScript", "output": "function Load(pgn) {\n  let chess = null;\n  if (Chess.Chess) {\n    chess = new Chess.Chess();\n  } else {\n    chess = new Chess();\n  }\n  chess.load_pgn(pgn);\n  return chess;\n}", "category": "Python"}, {"instruction": "(C) 1995-2013 Jean-loup Gailly and Mark Adler (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin  This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.  Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:  1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required. 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software. 3. This notice may not be removed or altered from any source distribution. Use ordinary array, since untyped makes no boost here", "input": "JavaScript", "output": "function makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}", "category": "Python"}, {"instruction": "Copy a simple polygon coordinates into a flat array, closes the ring if needed.\n@param {Float64Array} target - destination\n@param {Number} targetStartIndex - index in the destination to start copying into\n@param {Array} simplePolygon - array of points\n@param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n@returns {Number} - the index of the write head in the destination", "input": "JavaScript", "output": "function copyNestedRing(target, targetStartIndex, simplePolygon, size) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n  return targetIndex;\n}", "category": "Python"}, {"instruction": "This method is like `_.forOwn` except that it iterates over elements\nof a `collection` in the opposite order.\n\n@static\n@memberOf _\n@category Objects\n@param {Object} object The object to iterate over.\n@param {Function} [callback=identity] The function called per iteration.\n@param {*} [thisArg] The `this` binding of `callback`.\n@returns {Object} Returns `object`.\n@example\n\n_.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\nconsole.log(key);\n});\n// => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'", "input": "JavaScript", "output": "function forOwnRight(object, callback, thisArg) {\n      var props = keys(object),\n          length = props.length;\n\n      callback = baseCreateCallback(callback, thisArg, 3);\n      while (length--) {\n        var key = props[length];\n        if (callback(object[key], key, object) === false) {\n          break;\n        }\n      }\n      return object;\n    }", "category": "Python"}, {"instruction": "If the TypeDoc readme doesn't have this header\nIt won't be accessible in docusaurus", "input": "JavaScript", "output": "function addHeaderToReadme(packageName) {\n\n    const readmePath = path.join(destDir, packageName, 'api', 'README.md');\n    const readmeText = fs.readFileSync(readmePath).toString();\n\n    var docusaurusHeader = \n    `---\\n` + \n    `id: index\\n` +\n    `---\\n\\n`;\n\n    try {\n        fs.writeFileSync(readmePath, docusaurusHeader);\n        fs.appendFileSync(readmePath, readmeText);\n    } catch (err) {\n        console.log(chalk.red(err));\n    }\n\n}", "category": "Python"}, {"instruction": "Get a list of indexes of nodes containing a non-axis-aligned rectangle\n\n@param  {array}  corners      An array containing each corner of the\nrectangle defined by its coordinates (x, y).\n@param  {array}  quadCorners  An array of the quad nodes' corners.\n@return {array}               An array of indexes containing one to\nfour integers.", "input": "JavaScript", "output": "function _quadCollision(corners, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if (_geom.collision(corners, quadCorners[i]))\n        indexes.push(i);\n\n    return indexes;\n  }", "category": "Python"}, {"instruction": "Remove a specific event handler for a given event.\n@function\n@param {String} eventName - Name of event for which the handler is to be removed.\n@param {OpenSeadragon.EventHandler} handler - Function to be removed.", "input": "JavaScript", "output": "function ( eventName, handler ) {\n        var events = this.events[ eventName ],\n            handlers = [],\n            i;\n        if ( !events ) {\n            return;\n        }\n        if ( $.isArray( events ) ) {\n            for ( i = 0; i < events.length; i++ ) {\n                if ( events[i].handler !== handler ) {\n                    handlers.push( events[ i ] );\n                }\n            }\n            this.events[ eventName ] = handlers;\n        }\n    }", "category": "Python"}, {"instruction": "Removes the given controller from the GUI.\n@param {Controller} controller\n@instance", "input": "JavaScript", "output": "function(controller) {\n      // TODO listening?\n      this.__ul.removeChild(controller.__li);\n      this.__controllers.splice(this.__controllers.indexOf(controller), 1);\n      const _this = this;\n      common.defer(function() {\n        _this.onResize();\n      });\n    }", "category": "Python"}, {"instruction": "Completely all callbacks for every event, such as on object destruction", "input": "JavaScript", "output": "function() {\n        if (!this._callbacks) return;\n        this.__callbacksFrozen = false;\n        for (var event in this._callbacks) {\n            if (this._callbacks[event]) {\n                // Remove the normal way, in case we've got a nested loop\n                this._unbindCallbacks(event);\n                // Also completely delete the registered callback from handlers\n                delete handlers[event][this[0]];\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Return an option value that has a default, but may be overridden by a\ncallback or a node instance attribute.\n\nEvaluation sequence:<br>\n\nIf tree.options.<optionName> is a callback that returns something, use that.<br>\nElse if node.<optionName> is defined, use that.<br>\nElse if tree.options.<optionName> is a value, use that.<br>\nElse use `defaultValue`.\n\n@param {string} optionName name of the option property (on node and tree)\n@param {FancytreeNode} node passed to the callback\n@param {object} nodeObject where to look for the local option property, e.g. `node` or `node.data`\n@param {object} treeOption where to look for the tree option, e.g. `tree.options` or `tree.options.dnd5`\n@param {any} [defaultValue]\n@returns {any}\n\n@example\n// Check for node.foo, tree,options.foo(), and tree.options.foo:\n$.ui.fancytree.evalOption(\"foo\", node, node, tree.options);\n// Check for node.data.bar, tree,options.qux.bar(), and tree.options.qux.bar:\n$.ui.fancytree.evalOption(\"bar\", node, node.data, tree.options.qux);\n\n@since 2.22", "input": "JavaScript", "output": "function(\n\t\t\t\toptionName,\n\t\t\t\tnode,\n\t\t\t\tnodeObject,\n\t\t\t\ttreeOptions,\n\t\t\t\tdefaultValue\n\t\t\t) {\n\t\t\t\tvar ctx,\n\t\t\t\t\tres,\n\t\t\t\t\ttree = node.tree,\n\t\t\t\t\ttreeOpt = treeOptions[optionName],\n\t\t\t\t\tnodeOpt = nodeObject[optionName];\n\n\t\t\t\tif ($.isFunction(treeOpt)) {\n\t\t\t\t\tctx = {\n\t\t\t\t\t\tnode: node,\n\t\t\t\t\t\ttree: tree,\n\t\t\t\t\t\twidget: tree.widget,\n\t\t\t\t\t\toptions: tree.widget.options,\n\t\t\t\t\t\ttypeInfo: tree.types[node.type] || {},\n\t\t\t\t\t};\n\t\t\t\t\tres = treeOpt.call(tree, { type: optionName }, ctx);\n\t\t\t\t\tif (res == null) {\n\t\t\t\t\t\tres = nodeOpt;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tres = nodeOpt != null ? nodeOpt : treeOpt;\n\t\t\t\t}\n\t\t\t\tif (res == null) {\n\t\t\t\t\tres = defaultValue; // no option set at all: return default\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}", "category": "Python"}, {"instruction": "Block for when broadcast received.\n@this Blockly.Block", "input": "JavaScript", "output": "function() {\n    this.jsonInit({\n      \"id\": \"event_whenbroadcastreceived\",\n      \"message0\": Blockly.Msg.EVENT_WHENBROADCASTRECEIVED,\n      \"args0\": [\n        {\n          \"type\": \"field_variable\",\n          \"name\": \"BROADCAST_OPTION\",\n          \"variableTypes\": [Blockly.BROADCAST_MESSAGE_VARIABLE_TYPE],\n          \"variable\": Blockly.Msg.DEFAULT_BROADCAST_MESSAGE_NAME\n        }\n      ],\n      \"category\": Blockly.Categories.event,\n      \"extensions\": [\"colours_event\", \"shape_hat\"]\n    });\n  }", "category": "Python"}, {"instruction": "Return a three.js constant determining blending\n\n@param {string} [blending=normal]\n- `none`, additive`, `subtractive`,`multiply` or `normal`.\n@returns {number}", "input": "JavaScript", "output": "function parseBlending (blending) {\n  switch (blending) {\n    case 'none': {\n      return THREE.NoBlending;\n    }\n    case 'additive': {\n      return THREE.AdditiveBlending;\n    }\n    case 'subtractive': {\n      return THREE.SubtractiveBlending;\n    }\n    case 'multiply': {\n      return THREE.MultiplyBlending;\n    }\n    default: {\n      return THREE.NormalBlending;\n    }\n  }\n}", "category": "Python"}, {"instruction": "23.3.3.3 WeakMap.prototype.get(key)", "input": "JavaScript", "output": "function get(key) {\n        var state = getInternalState(this);\n        if (isObject(key)) {\n          var data = getWeakData(key);\n          if (data === true) return uncaughtFrozenStore(state).get(key);\n          return data ? data[state.id] : undefined;\n        }\n      }", "category": "Python"}, {"instruction": "ServiceCatalog class\n\n@description wrapper for the service catalog response from keystone\n\n@param {object}  catalog     the raw data to parse into the catalog\n@constructor", "input": "JavaScript", "output": "function (catalog) {\n  var self = this;\n\n  self.services = {};\n\n  _.each(catalog, function (service) {\n    // Special hack for rackspace with two compute types\n    if (service.type === 'compute' && service.name === 'cloudServers') {\n      return;\n    }\n\n    self.services[service.name] = new Service(service);\n  });\n}", "category": "Python"}, {"instruction": "Draws the data entries inside the tooltip\n@param  {Object} dataPoint   Data entry from to take the info\n@return void\n@private", "input": "JavaScript", "output": "function updateContent(dataPoint){\n            var topics = dataPoint[topicLabel];\n\n            // sort order by topicsOrder array if passed\n            if (topicsOrder.length) {\n                topics = _sortByTopicsOrder(topics);\n            } else if (topics.length && topics[0].name) {\n                topics = _sortByAlpha(topics);\n            }\n\n            cleanContent();\n            updateTitle(dataPoint);\n            resetSizeAndPositionPointers();\n            topics.forEach(updateTopicContent);\n        }", "category": "Python"}, {"instruction": "Sets which annotations types are shown in the annotation ruler.  Annotations are visible by default.\n\n@param {Object} types a hash table mapping annotation type to visibility (i.e. AnnotationType.ANNOTATION_INFO -> true).\n@since 14.0", "input": "JavaScript", "output": "function(types) {\n\t\t\tif (textUtil.compare(this._annotationTypesVisible, types)) return;\n\t\t\tthis._annotationTypesVisible = types;\n\t\t\tif (!this._annotationRuler || !this._textView || !this._annotationRulerVisible) { return; }\n\t\t\tthis._annotationRuler.setAnnotationTypeVisible(types);\n\t\t\tthis._textView.redrawLines(0, undefined, this._annotationRuler);\n\t\t}", "category": "Python"}, {"instruction": "JavaScript code to be evaluated  `window.location.href`", "input": "JavaScript", "output": "function () {\n                    var str, j = i, e;\n\n                    if (input.charAt(j) === '~') { j++; e = true; } // Escaped strings\n                    if (input.charAt(j) !== '`') { return; }\n                    if (env.javascriptEnabled !== undefined && !env.javascriptEnabled) {\n                        error(\"You are using JavaScript, which has been disabled.\");\n                    }\n\n                    if (e) { $char('~'); }\n\n                    str = $re(/^`([^`]*)`/);\n                    if (str) {\n                        return new(tree.JavaScript)(str[1], i, e);\n                    }\n                }", "category": "Python"}, {"instruction": "Hash Password Setter", "input": "JavaScript", "output": "function hashPassword (data) {\n  var password = data.password\n  var hash = data.hash\n\n  if (password) {\n    var salt = bcrypt.genSaltSync(10)\n    hash = bcrypt.hashSync(password, salt)\n  }\n\n  this.hash = hash\n}", "category": "Python"}, {"instruction": "gets the metadata that should be printed next to each event", "input": "JavaScript", "output": "function getEventMetadata({ event, payload }) {\n  if (event === 'state') {\n    return chalk.bold(payload.value);\n  }\n\n  if (event === 'instance-start' || event === 'instance-stop') {\n    if (payload.dc != null) {\n      return chalk.green(`(${payload.dc})`);\n    }\n  }\n\n  return '';\n}", "category": "Python"}, {"instruction": "Built-in hook to upload PIXI.Graphics to the GPU.\n\n@private\n@param {PIXI.Renderer} renderer - instance of the webgl renderer\n@param {PIXI.DisplayObject} item - Item to check\n@return {boolean} If item was uploaded.", "input": "JavaScript", "output": "function uploadGraphics(renderer, item)\n{\n    if (item instanceof Graphics)\n    {\n        // if the item is not dirty and already has webgl data, then it got prepared or rendered\n        // before now and we shouldn't waste time updating it again\n        if (item.dirty || item.clearDirty || !item._webGL[renderer.plugins.graphics.CONTEXT_UID])\n        {\n            renderer.plugins.graphics.updateGraphics(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}", "category": "Python"}, {"instruction": "Crop connection if connection cropping is provided.\n\n@param {Connection} connection\n@param {Array<Point>} newWaypoints\n\n@return {Array<Point>} cropped connection waypoints", "input": "JavaScript", "output": "function cropConnection(connection, newWaypoints) {\n\n    // crop connection, if docking service is provided only\n    if (!connectionDocking) {\n      return newWaypoints;\n    }\n\n    var oldWaypoints = connection.waypoints,\n        croppedWaypoints;\n\n    // temporary set new waypoints\n    connection.waypoints = newWaypoints;\n\n    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);\n\n    // restore old waypoints\n    connection.waypoints = oldWaypoints;\n\n    return croppedWaypoints;\n  }", "category": "Python"}, {"instruction": "Step through all source packages and transpose dependencies on the build function to be dependent on the function call instead, ensuring that the function is finally called. Although we could simply push the call body into the build package, this way allows the source to be faithfully rebuilt no matter where the build call occurs.", "input": "JavaScript", "output": "function transposeDependencies() {\n        sourcePackages.forEach(function(p) {\n          if (p.name === fnCallName) {\n            // Do not transpose the call package itself. After this loop\n            // there should be only one dependency on the build function anymore.\n            return;\n          }\n          var index = p.dependencies.indexOf(fnName);\n          if (index !== -1) {\n            p.dependencies.splice(index, 1, fnCallName);\n          }\n        });\n      }", "category": "Python"}, {"instruction": "Get stylesheets from `documentFragment`\n\n@param {Object} options configuration options of `loadCssom`\n@returns {Array<Object>}", "input": "JavaScript", "output": "function getStylesheetsFromDocumentFragment(options) {\n\tconst { rootNode, convertDataToStylesheet } = options;\n\treturn (\n\t\tArray.from(rootNode.children)\n\t\t\t.filter(filerStyleAndLinkAttributesInDocumentFragment)\n\t\t\t// Reducer to convert `<style></style>` and `<link>` references to `CSSStyleSheet` object\n\t\t\t.reduce((out, node) => {\n\t\t\t\tconst nodeName = node.nodeName.toUpperCase();\n\t\t\t\tconst data = nodeName === 'STYLE' ? node.textContent : node;\n\t\t\t\tconst isLink = nodeName === 'LINK';\n\t\t\t\tconst stylesheet = convertDataToStylesheet({\n\t\t\t\t\tdata,\n\t\t\t\t\tisLink,\n\t\t\t\t\troot: rootNode\n\t\t\t\t});\n\t\t\t\tout.push(stylesheet.sheet);\n\t\t\t\treturn out;\n\t\t\t}, [])\n\t);\n}", "category": "Python"}, {"instruction": "Utils", "input": "JavaScript", "output": "function removeFromArray(array, value) {\n    if (array.includes(value)) {\n      var value_index = array.indexOf(value);\n      array.splice(value_index, 1);\n    }\n\n    return array;\n  }", "category": "Python"}, {"instruction": "\u622a\u53d6\u96c6\u5408\u7684\u90e8\u5206\n\n@param <T> \u96c6\u5408\u5143\u7d20\u7c7b\u578b\n@param list \u88ab\u622a\u53d6\u7684\u6570\u7ec4\n@param start \u5f00\u59cb\u4f4d\u7f6e\uff08\u5305\u542b\uff09\n@param end \u7ed3\u675f\u4f4d\u7f6e\uff08\u4e0d\u5305\u542b\uff09\n@param step \u6b65\u8fdb\n@return \u622a\u53d6\u540e\u7684\u6570\u7ec4\uff0c\u5f53\u5f00\u59cb\u4f4d\u7f6e\u8d85\u8fc7\u6700\u5927\u65f6\uff0c\u8fd4\u56de\u7a7a\u7684List\n@since 4.0.6", "input": "Java", "output": "public static <T> List<T> sub(List<T> list, int start, int end, int step) {\r\n\t\tif (list == null || list.isEmpty()) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tfinal int size = list.size();\r\n\t\tif (start < 0) {\r\n\t\t\tstart += size;\r\n\t\t}\r\n\t\tif (end < 0) {\r\n\t\t\tend += size;\r\n\t\t}\r\n\t\tif (start == size) {\r\n\t\t\treturn new ArrayList<>(0);\r\n\t\t}\r\n\t\tif (start > end) {\r\n\t\t\tint tmp = start;\r\n\t\t\tstart = end;\r\n\t\t\tend = tmp;\r\n\t\t}\r\n\t\tif (end > size) {\r\n\t\t\tif (start >= size) {\r\n\t\t\t\treturn new ArrayList<>(0);\r\n\t\t\t}\r\n\t\t\tend = size;\r\n\t\t}\r\n\r\n\t\tif (step <= 1) {\r\n\t\t\treturn list.subList(start, end);\r\n\t\t}\r\n\r\n\t\tfinal List<T> result = new ArrayList<>();\r\n\t\tfor (int i = start; i < end; i += step) {\r\n\t\t\tresult.add(list.get(i));\r\n\t\t}\r\n\t\treturn result;\r\n\t}", "category": "Python"}, {"instruction": "Save `namespaces`.\n\n@param {String} namespaces\n@api private", "input": "JavaScript", "output": "function save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}", "category": "Python"}, {"instruction": "/*\nChange findNodes ==> filterNodes\n \n@name filterNodes\n@type {function}\n@description\nFunction to find certain nodes based on a filter passed.\n@param {object} ast   AST node\n@param {function} filter  Filter function to find nodes\n@return {object[]} Array of all the nodes found", "input": "JavaScript", "output": "function(ast, filter) {\n  checkASTandFunction(ast, 'ast', filter, 'filter');\n\n  let result = [];\n  walkNodes(ast, node => {\n    if (filter(node)) result.push(Object.assign({}, node));\n  });\n  return result;\n}", "category": "Python"}, {"instruction": "Slow path in case a line of bytes cannot be read in one #fill() operation. This is still faster\nthan creating the StrinbBuilder, String, then encoding as byte[] in Protocol, then decoding\nback into a String.", "input": "Java", "output": "private byte[] readLineBytesSlowly() {\n    ByteArrayOutputStream bout = null;\n    while (true) {\n      ensureFill();\n\n      byte b = buf[count++];\n      if (b == '\\r') {\n        ensureFill(); // Must be one more byte\n\n        byte c = buf[count++];\n        if (c == '\\n') {\n          break;\n        }\n\n        if (bout == null) {\n          bout = new ByteArrayOutputStream(16);\n        }\n\n        bout.write(b);\n        bout.write(c);\n      } else {\n        if (bout == null) {\n          bout = new ByteArrayOutputStream(16);\n        }\n\n        bout.write(b);\n      }\n    }\n\n    return bout == null ? new byte[0] : bout.toByteArray();\n  }", "category": "Python"}, {"instruction": "Used during {@link Jenkins#refreshExtensions()} to add new components into existing {@link ExtensionList}s.\nDo not call from anywhere else.", "input": "Java", "output": "public void refresh(ExtensionComponentSet delta) {\n        boolean fireOnChangeListeners = false;\n        synchronized (getLoadLock()) {\n            if (extensions==null)\n                return;     // not yet loaded. when we load it, we'll load everything visible by then, so no work needed\n\n            Collection<ExtensionComponent<T>> found = load(delta);\n            if (!found.isEmpty()) {\n                List<ExtensionComponent<T>> l = Lists.newArrayList(extensions);\n                l.addAll(found);\n                extensions = sort(l);\n                fireOnChangeListeners = true;\n            }\n        }\n        if (fireOnChangeListeners) {\n            fireOnChangeListeners();\n        }\n    }", "category": "Python"}, {"instruction": "Returns the URL of the index page jelly script.", "input": "Java", "output": "public URL getIndexPage() {\n        // In the current impl dependencies are checked first, so the plugin itself\n        // will add the last entry in the getResources result.\n        URL idx = null;\n        try {\n            Enumeration<URL> en = classLoader.getResources(\"index.jelly\");\n            while (en.hasMoreElements())\n                idx = en.nextElement();\n        } catch (IOException ignore) { }\n        // In case plugin has dependencies but is missing its own index.jelly,\n        // check that result has this plugin's artifactId in it:\n        return idx != null && idx.toString().contains(shortName) ? idx : null;\n    }", "category": "Python"}, {"instruction": "Create/load a HikariConfig from Hibernate properties.\n\n@param props a map of Hibernate properties\n@return a HikariConfig", "input": "Java", "output": "@SuppressWarnings(\"rawtypes\")\n   public static HikariConfig loadConfiguration(Map props)\n   {\n      Properties hikariProps = new Properties();\n      copyProperty(AvailableSettings.ISOLATION, props, \"transactionIsolation\", hikariProps);\n      copyProperty(AvailableSettings.AUTOCOMMIT, props, \"autoCommit\", hikariProps);\n      copyProperty(AvailableSettings.DRIVER, props, \"driverClassName\", hikariProps);\n      copyProperty(AvailableSettings.URL, props, \"jdbcUrl\", hikariProps);\n      copyProperty(AvailableSettings.USER, props, \"username\", hikariProps);\n      copyProperty(AvailableSettings.PASS, props, \"password\", hikariProps);\n\n      for (Object keyo : props.keySet()) {\n         String key = (String) keyo;\n         if (key.startsWith(CONFIG_PREFIX)) {\n            hikariProps.setProperty(key.substring(CONFIG_PREFIX.length()), (String) props.get(key));\n         }\n      }\n\n      return new HikariConfig(hikariProps);\n   }", "category": "Python"}, {"instruction": "Evaluate on a directory containing a set of DataSet objects to be loaded with a {@link DataSetLoader}.\nUses default batch size of {@link #DEFAULT_EVAL_SCORE_BATCH_SIZE}\n@param path Path/URI to the directory containing the datasets to load\n@return Evaluation", "input": "Java", "output": "public <T extends Evaluation> T evaluate(String path, int batchSize, DataSetLoader loader){\n        JavaRDD<String> paths;\n        try {\n            paths = SparkUtils.listPaths(sc, path);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error listing paths in directory\", e);\n        }\n\n        JavaRDD<DataSet> rdd = paths.map(new LoadDataSetFunction(loader, new RemoteFileSourceFactory(BroadcastHadoopConfigHolder.get(sc))));\n        return (T)doEvaluation(rdd, batchSize, new org.deeplearning4j.eval.Evaluation())[0];\n    }", "category": "Python"}, {"instruction": "\u5bf9\u8c61\u8f6cMap<br>\n\u901a\u8fc7\u5b9e\u73b0{@link Editor} \u53ef\u4ee5\u81ea\u5b9a\u4e49\u5b57\u6bb5\u503c\uff0c\u5982\u679c\u8fd9\u4e2aEditor\u8fd4\u56denull\u5219\u5ffd\u7565\u8fd9\u4e2a\u5b57\u6bb5\uff0c\u4ee5\u4fbf\u5b9e\u73b0\uff1a\n\n<pre>\n1. \u5b57\u6bb5\u7b5b\u9009\uff0c\u53ef\u4ee5\u53bb\u9664\u4e0d\u9700\u8981\u7684\u5b57\u6bb5\n2. \u5b57\u6bb5\u53d8\u6362\uff0c\u4f8b\u5982\u5b9e\u73b0\u9a7c\u5cf0\u8f6c\u4e0b\u5212\u7ebf\n3. \u81ea\u5b9a\u4e49\u5b57\u6bb5\u524d\u7f00\u6216\u540e\u7f00\u7b49\u7b49\n</pre>\n\n@param bean bean\u5bf9\u8c61\n@param targetMap \u76ee\u6807\u7684Map\n@param ignoreNullValue \u662f\u5426\u5ffd\u7565\u503c\u4e3a\u7a7a\u7684\u5b57\u6bb5\n@param keyEditor \u5c5e\u6027\u5b57\u6bb5\uff08Map\u7684key\uff09\u7f16\u8f91\u5668\uff0c\u7528\u4e8e\u7b5b\u9009\u3001\u7f16\u8f91key\n@return Map\n@since 4.0.5", "input": "Java", "output": "public static Map<String, Object> beanToMap(Object bean, Map<String, Object> targetMap, boolean ignoreNullValue, Editor<String> keyEditor) {\r\n\t\tif (bean == null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tfinal Collection<PropDesc> props = BeanUtil.getBeanDesc(bean.getClass()).getProps();\r\n\r\n\t\tString key;\r\n\t\tMethod getter;\r\n\t\tObject value;\r\n\t\tfor (PropDesc prop : props) {\r\n\t\t\tkey = prop.getFieldName();\r\n\t\t\t// \u8fc7\u6ee4class\u5c5e\u6027\r\n\t\t\t// \u5f97\u5230property\u5bf9\u5e94\u7684getter\u65b9\u6cd5\r\n\t\t\tgetter = prop.getGetter();\r\n\t\t\tif (null != getter) {\r\n\t\t\t\t// \u53ea\u8bfb\u53d6\u6709getter\u65b9\u6cd5\u7684\u5c5e\u6027\r\n\t\t\t\ttry {\r\n\t\t\t\t\tvalue = getter.invoke(bean);\r\n\t\t\t\t} catch (Exception ignore) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (false == ignoreNullValue || (null != value && false == value.equals(bean))) {\r\n\t\t\t\t\tkey = keyEditor.edit(key);\r\n\t\t\t\t\tif (null != key) {\r\n\t\t\t\t\t\ttargetMap.put(key, value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn targetMap;\r\n\t}", "category": "Python"}, {"instruction": "Invalidates the cache.\n\n@param name The name of the cache to invalidate\n@return A maybe that emits a boolean if the operation was successful", "input": "Java", "output": "@Delete\n    public Maybe<Boolean> invalidateCache(@NotBlank @Selector String name) {\n        try {\n            final SyncCache<Object> cache = cacheManager.getCache(name);\n            return Maybe.create(emitter -> cache.async().invalidateAll().whenComplete((aBoolean, throwable) -> {\n                if (throwable != null) {\n                    emitter.onError(throwable);\n                } else {\n                    emitter.onSuccess(aBoolean);\n                    emitter.onComplete();\n                }\n            }));\n        } catch (ConfigurationException e) {\n            // no cache\n            return Maybe.empty();\n        }\n    }", "category": "Python"}, {"instruction": "Create XA connection from normal connection.\n\n@param databaseType database type\n@param connection normal connection\n@param xaDataSource XA data source\n@return XA connection", "input": "Java", "output": "public static XAConnection createXAConnection(final DatabaseType databaseType, final XADataSource xaDataSource, final Connection connection) {\n        switch (databaseType) {\n            case MySQL:\n                return new MySQLXAConnectionWrapper().wrap(xaDataSource, connection);\n            case PostgreSQL:\n                return new PostgreSQLXAConnectionWrapper().wrap(xaDataSource, connection);\n            case H2:\n                return new H2XAConnectionWrapper().wrap(xaDataSource, connection);\n            default:\n                throw new UnsupportedOperationException(String.format(\"Cannot support database type: `%s`\", databaseType));\n        }\n    }", "category": "Python"}, {"instruction": "This method returns total amount of memory allocated within system\n\n@return", "input": "Java", "output": "@Override\n    public Table<AllocationStatus, Integer, Long> getAllocationStatistics() {\n        Table<AllocationStatus, Integer, Long> table = HashBasedTable.create();\n        table.put(AllocationStatus.HOST, 0, zeroUseCounter.get());\n        for (Integer deviceId : configuration.getAvailableDevices()) {\n            table.put(AllocationStatus.DEVICE, deviceId, getAllocatedDeviceMemory(deviceId));\n        }\n        return table;\n    }", "category": "Python"}, {"instruction": "returns null. this can be improved in future but is good enough for most use-cases.", "input": "Java", "output": "public static TimestampSpec mergeTimestampSpec(List<TimestampSpec> toMerge)\n  {\n    if (toMerge == null || toMerge.size() == 0) {\n      return null;\n    }\n\n    TimestampSpec result = toMerge.get(0);\n    for (int i = 1; i < toMerge.size(); i++) {\n      if (toMerge.get(i) == null) {\n        continue;\n      }\n      if (!Objects.equals(result, toMerge.get(i))) {\n        return null;\n      }\n    }\n\n    return result;\n  }", "category": "Python"}, {"instruction": "Removes decision from ldap attribute set.\n\n@param ldapConsent the ldap attribute holding consent decisions\n@param decisionId  the decision Id\n@return the new decision set", "input": "Java", "output": "private static Set<String> removeDecision(final LdapAttribute ldapConsent, final long decisionId) {\n        val result = new HashSet<String>();\n        if (ldapConsent.size() != 0) {\n            ldapConsent.getStringValues()\n                .stream()\n                .map(LdapConsentRepository::mapFromJson)\n                .filter(d -> d.getId() != decisionId)\n                .map(LdapConsentRepository::mapToJson)\n                .filter(Objects::nonNull)\n                .forEach(result::add);\n        }\n        return result;\n    }", "category": "Python"}, {"instruction": "True if there is no item in Jenkins that has this name\n@param name The name to test\n@param currentJobName The name of the job that the user is configuring", "input": "Java", "output": "boolean isNameUnique(String name, String currentJobName) {\n        Item item = getItem(name);\n\n        if(null==item) {\n            // the candidate name didn't return any items so the name is unique\n            return true;\n        }\n        else if(item.getName().equals(currentJobName)) {\n            // the candidate name returned an item, but the item is the item\n            // that the user is configuring so this is ok\n            return true;\n        }\n        else {\n            // the candidate name returned an item, so it is not unique\n            return false;\n        }\n    }", "category": "Python"}, {"instruction": "Determines whether the given path is a \"resource path\" or a \"collection path\".\nResource paths operate on a single REST resource, whereas collection paths operate on\na collection of resources.\n\nNOTE: This algorithm is subject to change. Over time, it should get smarter and better at determining request types.\n\n@param   {Request} req\n@returns {boolean}", "input": "JavaScript", "output": "function isCollectionRequest (req) {\n  let isCollection = responseIsCollection(req);\n\n  if (isCollection === undefined) {\n    isCollection = !lastPathSegmentIsAParameter(req);\n  }\n\n  return isCollection;\n}", "category": "Python"}, {"instruction": "Returns true if a swipe happened after the last touchstart event fired on\nevent.target.\n\nWe need to differentiate a swipe from a tap before we let the event open\nor close the tooltip. A swipe is when a touchmove (scroll) event happens\non the body between the touchstart and the touchend events of an element.\n\n@param {object} target The HTML element that may have triggered the swipe\n@returns {boolean}\n@protected", "input": "JavaScript", "output": "function(target) {\n\t\t\n\t\tvar swiped = false;\n\t\t\n\t\tfor (var i = this.__touchEvents.length - 1; i >= 0; i--) {\n\t\t\t\n\t\t\tvar e = this.__touchEvents[i];\n\t\t\t\n\t\t\tif (e.type == 'touchmove') {\n\t\t\t\tswiped = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (\n\t\t\t\te.type == 'touchstart'\n\t\t\t\t&&\ttarget === e.target\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn swiped;\n\t}", "category": "Python"}, {"instruction": "Returns an array of names of merged-column which contains every column name in the given array.\n@param {Array.<String>} columnNames - an array of column names to test\n@returns {Array.<String>}\n@private", "input": "JavaScript", "output": "function(columnNames) {\n        var columnModel = this.columnModel;\n        var mergedColumnNames = _.pluck(columnModel.get('complexHeaderColumns'), 'name');\n\n        return _.filter(mergedColumnNames, function(mergedColumnName) {\n            var unitColumnNames = columnModel.getUnitColumnNamesIfMerged(mergedColumnName);\n\n            return _.every(unitColumnNames, function(name) {\n                return _.contains(columnNames, name);\n            });\n        });\n    }", "category": "Python"}, {"instruction": "/*\nThis function initializes the js_graph objects inspecting the html document", "input": "JavaScript", "output": "function initPageObjects()\n{\n\tif(isCanvas(document.body))\n\t{\n\t\tvar newCanvas = new Canvas(document.body);\n\t\tnewCanvas.initCanvas();\n\t\tcanvases.push(newCanvas);\n\t}\n\telse\n\t{\t\n\t\tvar divs = document.getElementsByTagName('div');\n\t\tvar i;\n\t\tfor(i = 0; i < divs.length; i++)\n\t\t{\n\t\t\tif(isCanvas(divs[i]) && !findCanvas(divs[i].id))\n\t\t\t{\n\t\t\t\tvar newCanvas = new Canvas(divs[i]);\n\t\t\t\tnewCanvas.initCanvas();\n\t\t\t\tcanvases.push(newCanvas);\n\t\t\t\tnewCanvas.fitBlocks();\n\t\t\t\tnewCanvas.alignBlocks();\n\t\t\t}\n\t\t}\n\t}\n}", "category": "Python"}, {"instruction": "Iterate over an input collection, invoking an `iterator` function for each element in the\ncollection and passing to it three arguments: `(value, index, collection)`. The `iterator`\nfunction can end iteration early by returning `false`.\n\n@name each\n@api public\n@param {Function(value, key, collection)} iterator The function to invoke per iteration.\n@param {Array|Object|string} collection The collection to iterate over.\n@return {undefined} Because `each` is run only for side effects, always returns `undefined`.\n@example\nvar log = console.log.bind(console);\n\neach(log, ['a', 'b', 'c']);\n//-> 'a', 0, ['a', 'b', 'c']\n//-> 'b', 1, ['a', 'b', 'c']\n//-> 'c', 2, ['a', 'b', 'c']\n//=> undefined\n\neach(log, 'tim');\n//-> 't', 2, 'tim'\n//-> 'i', 1, 'tim'\n//-> 'm', 0, 'tim'\n//=> undefined\n\n// Note: Iteration order not guaranteed across environments\neach(log, { name: 'tim', occupation: 'enchanter' });\n//-> 'tim', 'name', { name: 'tim', occupation: 'enchanter' }\n//-> 'enchanter', 'occupation', { name: 'tim', occupation: 'enchanter' }\n//=> undefined", "input": "JavaScript", "output": "function each(iterator, collection) {\n  return (isArrayLike(collection) ? arrayEach : baseEach).call(this, iterator, collection);\n}", "category": "Python"}, {"instruction": "code from this gist: https://gist.github.com/dchest/4582374 (no license declared)", "input": "JavaScript", "output": "function Salsa20(key, nonce) {\n    // Constants.\n    this.rounds = 20; // number of Salsa rounds\n    this.sigmaWords = [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574];\n\n    // State.\n    this.keyWords = [];           // key words\n    this.nonceWords = [0, 0];     // nonce words\n    this.counterWords = [0, 0];   // block counter words\n\n    // Output buffer.\n    this.block = [];        // output block of 64 bytes\n    this.blockUsed = 64;     // number of block bytes used\n\n    this.setKey(key);\n    this.setNonce(nonce);\n}", "category": "Python"}, {"instruction": "Assertion errors, can provide a detailed error messages.\n\ninspect() and cliMessage() added to display errors with params.", "input": "JavaScript", "output": "function AssertionFailedError(params, template) {\n  this.params = params;\n  this.template = template;\n  // this.message = \"AssertionFailedError\";\n  let stack = new Error().stack;\n  // this.showDiff = true;\n  stack = stack ? stack.split('\\n').filter(line =>\n    // @todo cut assert things nicer\n    line.indexOf('lib/assert') < 0).join('\\n') : '';\n  this.showDiff = true;\n\n  this.actual = this.params.actual;\n  this.expected = this.params.expected;\n\n  this.inspect = () => {\n    const params = this.params || {};\n    const msg = params.customMessage || '';\n    return msg + subs(this.template, params);\n  };\n\n  this.cliMessage = () => this.inspect();\n}", "category": "Python"}, {"instruction": "/*\nvar apply_impulse = function(body, j, r){\nbody.v = vadd(body.v, vmult(j, body.m_inv));\nbody.w += body.i_inv*vcross(r, j);\n};\n\nvar apply_impulses = function(a, b, r1, r2, j)\n{\napply_impulse(a, vneg(j), r1);\napply_impulse(b, j, r2);\n};", "input": "JavaScript", "output": "function(body, jx, jy, r){\n//  body.v = body.v.add(vmult(j, body.m_inv));\n    body.vx += jx * body.m_inv;\n    body.vy += jy * body.m_inv;\n//  body.w += body.i_inv*vcross(r, j);\n    body.w += body.i_inv*(r.x*jy - r.y*jx);\n}", "category": "Python"}, {"instruction": "this function can be outsourced in future when the ComponentMetadata is not used anymore and the new Application manifest is used - but for now we keep it as it will be one of the common use cases to have the classical ComponentMetadata and this should be transformed into the new manifest structure for compatibility converter for array with string values to object", "input": "JavaScript", "output": "function(a, fnCallback) {\n\t\t\tvar o = {};\n\t\t\tif (a) {\n\t\t\t\tfor (var i = 0, l = a.length; i < l; i++) {\n\t\t\t\t\tvar oValue = a[i];\n\t\t\t\t\tif (typeof oValue === \"string\") {\n\t\t\t\t\t\to[oValue] = typeof fnCallback === \"function\" && fnCallback(oValue) || {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn o;\n\t\t}", "category": "Python"}, {"instruction": "Return default list of env variables with their assigned value, if any.", "input": "JavaScript", "output": "function _getFileContents(values) {\n  const env = getDefaultSlateEnv();\n\n  for (const key in values) {\n    if (values.hasOwnProperty(key) && env.hasOwnProperty(key)) {\n      env[key] = values[key];\n    }\n  }\n\n  return Object.entries(env)\n    .map((keyValues) => {\n      return `${keyValues.join('=')}\\r\\n`;\n    })\n    .join('\\r\\n\\r\\n');\n}", "category": "Python"}, {"instruction": "11.12 Conditional Operator", "input": "JavaScript", "output": "function parseConditionalExpression() {\n        var expr, consequent, alternate;\n\n        expr = parseBinaryExpression();\n\n        if (match('?')) {\n            lex();\n            consequent = parseConditionalExpression();\n            expect(':');\n            alternate = parseConditionalExpression();\n\n            expr = delegate.createConditionalExpression(expr, consequent, alternate);\n        }\n\n        return expr;\n    }", "category": "Python"}, {"instruction": "/*\nReturns a flattened acc info object (infos of children are merged together)\nNote: The info object does only contain a focusable flag (true if one of the children is focusable)\nand a combined description.\n@see sap.ui.core.Control#getAccessibilityInfo", "input": "JavaScript", "output": "function(oControl) {\n\t\t\tif (oControl && typeof oControl.getAccessibilityInfo === \"function\") {\n\t\t\t\tif (typeof oControl.getVisible === \"function\" && !oControl.getVisible()) {\n\t\t\t\t\treturn ACCInfoHelper._normalize({});\n\t\t\t\t}\n\t\t\t\tvar oSource = oControl.getAccessibilityInfo();\n\t\t\t\tif (oSource) {\n\t\t\t\t\tvar oTarget = {};\n\t\t\t\t\tACCInfoHelper._flatten(oSource, oTarget);\n\t\t\t\t\treturn oTarget;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}", "category": "Python"}, {"instruction": "# last :: Foldable f => f a -> Maybe a . . Returns Just the last element of the given structure if the structure . contains at least one element; Nothing otherwise. . . ```javascript . > S.last ([1, 2, 3]) . Just (3) . . > S.last ([]) . Nothing . . > S.last (Cons (1) (Cons (2) (Cons (3) (Nil)))) . Just (3) . . > S.last (Nil) . Nothing . ```", "input": "JavaScript", "output": "function last(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) {\n      return foldable.length > 0 ? Just (foldable[foldable.length - 1])\n                                 : Nothing;\n    }\n    return Z.reduce (function(_, x) { return Just (x); }, Nothing, foldable);\n  }", "category": "Python"}, {"instruction": "options.path must be specified; callback(err, data)", "input": "JavaScript", "output": "function devToolsInterface(options, callback) {\n    options.host = options.host || defaults.HOST;\n    options.port = options.port || defaults.PORT;\n    options.secure = !!(options.secure);\n    options.useHostName = !!(options.useHostName);\n    externalRequest(options.secure ? https : http, options, callback);\n}", "category": "Python"}, {"instruction": "Internal *", "input": "JavaScript", "output": "function addTransformsToNotifier(notifier) {\n  notifier\n    .addTransform(transforms.baseData)\n    .addTransform(transforms.handleItemWithError)\n    .addTransform(transforms.addBody)\n    .addTransform(sharedTransforms.addMessageWithError)\n    .addTransform(sharedTransforms.addTelemetryData)\n    .addTransform(sharedTransforms.addConfigToPayload)\n    .addTransform(transforms.scrubPayload)\n    .addTransform(sharedTransforms.itemToPayload);\n}", "category": "Python"}, {"instruction": "/*", "input": "JavaScript", "output": "function genClassForVnode (vnode) {\n  let data = vnode.data;\n  let parentNode = vnode;\n  let childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}", "category": "Python"}, {"instruction": "VML override to create a regular HTML image\n@param {String} src\n@param {Number} x\n@param {Number} y\n@param {Number} width\n@param {Number} height", "input": "JavaScript", "output": "function (src, x, y, width, height) {\r\n\t\tvar obj = this.createElement('img')\r\n\t\t\t.attr({ src: src });\r\n\r\n\t\tif (arguments.length > 1) {\r\n\t\t\tobj.css({\r\n\t\t\t\tleft: x,\r\n\t\t\t\ttop: y,\r\n\t\t\t\twidth: width,\r\n\t\t\t\theight: height\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn obj;\r\n\t}", "category": "Python"}, {"instruction": "Unregisters the KvState instance identified by the given KvStateID.\n\n@param jobId     JobId the KvState instance belongs to\n@param kvStateId KvStateID to identify the KvState instance\n@param keyGroupRange    Key group range the KvState instance belongs to", "input": "Java", "output": "public void unregisterKvState(\n\t\t\tJobID jobId,\n\t\t\tJobVertexID jobVertexId,\n\t\t\tKeyGroupRange keyGroupRange,\n\t\t\tString registrationName,\n\t\t\tKvStateID kvStateId) {\n\n\t\tKvStateEntry<?, ?, ?> entry = registeredKvStates.remove(kvStateId);\n\t\tif (entry != null) {\n\t\t\tentry.clear();\n\n\t\t\tfinal KvStateRegistryListener listener = getKvStateRegistryListener(jobId);\n\t\t\tif (listener != null) {\n\t\t\t\tlistener.notifyKvStateUnregistered(\n\t\t\t\t\t\tjobId,\n\t\t\t\t\t\tjobVertexId,\n\t\t\t\t\t\tkeyGroupRange,\n\t\t\t\t\t\tregistrationName);\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Update the AllServer list in the LoadBalancer if necessary and enabled\n\n@param ls", "input": "Java", "output": "protected void updateAllServerList(List<T> ls) {\n        // other threads might be doing this - in which case, we pass\n        if (serverListUpdateInProgress.compareAndSet(false, true)) {\n            try {\n                for (T s : ls) {\n                    s.setAlive(true); // set so that clients can start using these\n                                      // servers right away instead\n                                      // of having to wait out the ping cycle.\n                }\n                setServersList(ls);\n                super.forceQuickPing();\n            } finally {\n                serverListUpdateInProgress.set(false);\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Get the probability matrix (probability of the specified class, assuming an object is present, for all x/y\npositions), from the network output activations array\n\n@param networkOutput Network output activations\n@param example       Example number, in minibatch\n@param classNumber   Class number\n@return Confidence matrix", "input": "Java", "output": "public INDArray getProbabilityMatrix(INDArray networkOutput, int example, int classNumber){\n        //Input format: [minibatch, 5B+C, H, W], with order [x,y,w,h,c]\n        //Therefore: probabilities for class I is at depths 5B + classNumber\n\n        val bbs = layerConf().getBoundingBoxes().size(0);\n        INDArray conf = networkOutput.get(point(example), point(5*bbs + classNumber), all(), all());\n        return conf;\n    }", "category": "Python"}, {"instruction": "Generate response for access token model and view.\n\n@param request  the request\n@param response the response\n@param result   the result\n@return the model and view", "input": "Java", "output": "protected ModelAndView generateResponseForAccessToken(final HttpServletRequest request,\n                                                          final HttpServletResponse response,\n                                                          final OAuth20AccessTokenResponseResult result) {\n        val model = getAccessTokenResponseModel(request, response, result);\n        return new ModelAndView(new MappingJackson2JsonView(MAPPER), model);\n    }", "category": "Python"}, {"instruction": "ZAP: Added type arguments.", "input": "Java", "output": "protected Hashtable<String, String> parseParameter(String param){\r\n        // ZAP: Added type arguments.\r\n        Hashtable<String, String> table = new Hashtable<>();\r\n        \r\n        try{\t  \r\n            matcher2 = pSeparator.matcher(param);\r\n            while (matcher2.find()){\r\n                // start of a request\r\n                table.put(matcher2.group(1), matcher2.group(2));\r\n                \r\n            }\r\n        } catch(Exception e){\r\n        \tlogger.error(e.getMessage(), e);\r\n        }\r\n        return table;\r\n        \r\n    }", "category": "Python"}, {"instruction": "This returns the minimized loss values for a given vector.\nIt is assumed that  the x, y pairs are at\nvector[i], vector[i+1]\n@param vector the vector of numbers to getFromOrigin the weights for\n@return a double array with w_0 and w_1 are the associated indices.", "input": "Java", "output": "public static double[] weightsFor(List<Double> vector) {\n        /* split coordinate system */\n        List<double[]> coords = coordSplit(vector);\n        /* x vals */\n        double[] x = coords.get(0);\n        /* y vals */\n        double[] y = coords.get(1);\n\n\n        double meanX = sum(x) / x.length;\n        double meanY = sum(y) / y.length;\n\n        double sumOfMeanDifferences = sumOfMeanDifferences(x, y);\n        double xDifferenceOfMean = sumOfMeanDifferencesOnePoint(x);\n\n        double w_1 = sumOfMeanDifferences / xDifferenceOfMean;\n\n        double w_0 = meanY - (w_1) * meanX;\n\n        //double w_1=(n*sumOfProducts(x,y) - sum(x) * sum(y))/(n*sumOfSquares(x) - Math.pow(sum(x),2));\n\n        //\tdouble w_0=(sum(y) - (w_1 * sum(x)))/n;\n\n        double[] ret = new double[vector.size()];\n        ret[0] = w_0;\n        ret[1] = w_1;\n\n        return ret;\n    }", "category": "Python"}, {"instruction": "Checks if the constant pool contains a reference to a given field, either for writing or reading.\n\n@param className must be provided JVM-style, such as {@code java/lang/String}", "input": "Java", "output": "public boolean usesField(String className, String fieldName) {\n\t\tint classIndex = findClass(className);\n\t\tif (classIndex == NOT_FOUND) return false;\n\t\tint fieldNameIndex = findUtf8(fieldName);\n\t\tif (fieldNameIndex == NOT_FOUND) return false;\n\t\t\n\t\tfor (int i = 1; i < maxPoolSize; i++) {\n\t\t\tif (types[i] == FIELD && readValue(offsets[i]) == classIndex) {\n\t\t\t\tint nameAndTypeIndex = readValue(offsets[i] + 2);\n\t\t\t\tif (readValue(offsets[nameAndTypeIndex]) == fieldNameIndex) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "category": "Python"}, {"instruction": "Get layer output type.\n\n@param inputType Array of InputTypes\n@return output type as InputType\n@throws InvalidKerasConfigurationException Invalid Keras config", "input": "Java", "output": "public InputType getOutputType(InputType... inputType) throws InvalidKerasConfigurationException {\n        if (inputType.length > 1)\n            throw new InvalidKerasConfigurationException(\n                    \"Keras PReLU layer accepts only one input (received \" + inputType.length + \")\");\n        InputType inType = inputType[0];\n\n        // Dynamically infer input shape of PReLU layer from input type\n        PReLULayer shapedLayer = (PReLULayer) this.layer;\n        shapedLayer.setInputShape(inType.getShape());\n        this.layer = shapedLayer;\n\n        return this.getPReLULayer().getOutputType(-1, inputType[0]);\n    }", "category": "Python"}, {"instruction": "Renew disabled data source names.\n\n@param disabledStateChangedEvent disabled state changed event", "input": "Java", "output": "@Subscribe\n    public synchronized void renew(final DisabledStateChangedEvent disabledStateChangedEvent) {\n        OrchestrationShardingSchema shardingSchema = disabledStateChangedEvent.getShardingSchema();\n        if (getName().equals(shardingSchema.getSchemaName())) {\n            for (MasterSlaveRule each : shardingRule.getMasterSlaveRules()) {\n                ((OrchestrationMasterSlaveRule) each).updateDisabledDataSourceNames(shardingSchema.getDataSourceName(), disabledStateChangedEvent.isDisabled());\n            }\n        }\n    }", "category": "Python"}, {"instruction": "[VARIABLE \"my_dataset\"]", "input": "Java", "output": "public Sink updateSink(String sinkName, String datasetName) {\n    // [START logging_update_sink]\n    SinkInfo sinkInfo =\n        SinkInfo.newBuilder(sinkName, DatasetDestination.of(datasetName))\n            .setVersionFormat(SinkInfo.VersionFormat.V2)\n            .setFilter(\"severity>=ERROR\")\n            .build();\n    Sink sink = logging.update(sinkInfo);\n    // [END logging_update_sink]\n    return sink;\n  }", "category": "Python"}, {"instruction": "Reads a message body into across one or more frames. Control frames that occur between\nfragments will be processed. If the message payload is masked this will unmask as it's being\nprocessed.", "input": "Java", "output": "private void readMessage() throws IOException {\n    while (true) {\n      if (closed) throw new IOException(\"closed\");\n\n      if (frameLength > 0) {\n        source.readFully(messageFrameBuffer, frameLength);\n\n        if (!isClient) {\n          messageFrameBuffer.readAndWriteUnsafe(maskCursor);\n          maskCursor.seek(messageFrameBuffer.size() - frameLength);\n          toggleMask(maskCursor, maskKey);\n          maskCursor.close();\n        }\n      }\n\n      if (isFinalFrame) break; // We are exhausted and have no continuations.\n\n      readUntilNonControlFrame();\n      if (opcode != OPCODE_CONTINUATION) {\n        throw new ProtocolException(\"Expected continuation opcode. Got: \" + toHexString(opcode));\n      }\n    }\n  }", "category": "Python"}, {"instruction": "This method initializes this panel.", "input": "Java", "output": "private void initialize() {\r\n\t\tthis.setName(Constant.messages.getString(\"httpsessions.options.title\"));\r\n\t\tthis.setLayout(new GridBagLayout());\r\n\r\n\t\tGridBagConstraints gbc = new GridBagConstraints();\r\n\t\tgbc.gridx = 0;\r\n\t\tgbc.weightx = 1.0;\r\n\t\tgbc.anchor = GridBagConstraints.LINE_START;\r\n\t\tgbc.fill = GridBagConstraints.BOTH;\r\n\t\t\r\n\t\tJLabel tokenNamesLabel = new JLabel();\r\n\t\ttokenNamesLabel.setText(Constant.messages.getString(\"httpsessions.options.label.tokens\"));\r\n\r\n\t\tthis.add(tokenNamesLabel, gbc);\r\n\r\n\t\ttokensOptionsPanel = new HttpSessionTokensMultipleOptionsPanel(getDefaultTokensModel());\r\n\t\t\r\n\t\tgbc.weighty = 1.0;\r\n\t\tthis.add(tokensOptionsPanel, gbc);\r\n\t\t\r\n\t\tgbc.weighty = 0.0;\r\n\t\tgbc.insets = new Insets(10, 2, 2, 2);\r\n\t\tthis.add(getChkProxyOnly(), gbc);\r\n\t}", "category": "Python"}, {"instruction": "Returns the index of minimum value between {@code index} and\n{@code index + len}, or {@code -1} if {@code index} is greater than\n{@code size}.", "input": "Java", "output": "private int findMin(Comparator comparator, int index, int len)\n  {\n    if (index >= heapSize) {\n      return -1;\n    }\n    int limit = Math.min(index, heapSize - len) + len;\n    int minIndex = index;\n    for (int i = index + 1; i < limit; i++) {\n      if (comparator.compare(buf.getInt(i * Integer.BYTES), buf.getInt(minIndex * Integer.BYTES)) < 0) {\n        minIndex = i;\n      }\n    }\n    return minIndex;\n  }", "category": "Python"}, {"instruction": "\u8bbe\u7f6e\u8fd4\u56de\u503c\u7c7b\u578b - \u4e3a\u4e86\u8ba9typeHandler\u5728select\u65f6\u6709\u6548\uff0c\u6539\u4e3a\u8bbe\u7f6eresultMap\n\n@param ms\n@param entityClass", "input": "Java", "output": "protected void setResultType(MappedStatement ms, Class<?> entityClass) {\n        EntityTable entityTable = EntityHelper.getEntityTable(entityClass);\n        List<ResultMap> resultMaps = new ArrayList<ResultMap>();\n        resultMaps.add(entityTable.getResultMap(ms.getConfiguration()));\n        MetaObject metaObject = MetaObjectUtil.forObject(ms);\n        metaObject.setValue(\"resultMaps\", Collections.unmodifiableList(resultMaps));\n    }", "category": "Python"}, {"instruction": "{@inheritDoc}.\n<p>\nChecks whether the IP should even be paid attention to,\nthen does a reverse DNS lookup, and if it matches the supplied pattern, performs SPNEGO\nelse skips the process.\n\n@param remoteIp The remote ip address to validate", "input": "Java", "output": "@Override\n    protected boolean shouldDoSpnego(final String remoteIp) {\n        val ipCheck = ipPatternCanBeChecked(remoteIp);\n        if (ipCheck && !ipPatternMatches(remoteIp)) {\n            return false;\n        }\n        val hostName = getRemoteHostName(remoteIp);\n        LOGGER.debug(\"Retrieved host name for the remote ip is [{}]\", hostName);\n        return this.hostNamePatternString.matcher(hostName).find();\n    }", "category": "Python"}, {"instruction": "Save the user configuration.", "input": "Java", "output": "public synchronized void save() throws IOException {\n        if (!isIdOrFullnameAllowed(id)) {\n            throw FormValidation.error(Messages.User_IllegalUsername(id));\n        }\n        if (!isIdOrFullnameAllowed(fullName)) {\n            throw FormValidation.error(Messages.User_IllegalFullname(fullName));\n        }\n        if (BulkChange.contains(this)) {\n            return;\n        }\n        XmlFile xmlFile = new XmlFile(XSTREAM, constructUserConfigFile());\n        xmlFile.write(this);\n        SaveableListener.fireOnChange(this, xmlFile);\n    }", "category": "Python"}, {"instruction": "Power to an integer.\n\n@param exponent the exponent.\n@return this value raised to the power given by the exponent.\nIf the exponent is 0, the value 1 is returned.", "input": "Java", "output": "public Rational pow(BigInteger exponent) throws NumberFormatException {\n        /* test for overflow */\n        if (exponent.compareTo(MAX_INT) == 1) {\n            throw new NumberFormatException(\"Exponent \" + exponent.toString() + \" too large.\");\n        }\n        if (exponent.compareTo(MIN_INT) == -1) {\n            throw new NumberFormatException(\"Exponent \" + exponent.toString() + \" too small.\");\n        }\n        /* promote to the simpler interface above */\n        return pow(exponent.intValue());\n    }", "category": "Python"}, {"instruction": "\u8ba1\u7b97\u5e73\u5747\u5f02\u5e38\u7387\uff0c\u5982\u679c\u8c03\u7528\u6b21\u6570\u5c0f\u4e8eleastWindowCount\u5219\u4e0d\u53c2\u4e0e\u8ba1\u7b97\u3002 \u5982\u679c\u6240\u6709\u8c03\u7528\u6b21\u6570\u5747\u4e3a0\u5219\u8fd4\u56de-1\n\n@param invocationStats List<InvocationStat>\n@param leastWindowCount leastWindowCount\n@return The average exception rate of all invocation statics", "input": "Java", "output": "private double calculateAverageExceptionRate(List<InvocationStat> invocationStats, long leastWindowCount) {\n        long sumException = 0;\n        long sumCall = 0;\n        for (InvocationStat invocationStat : invocationStats) {\n\n            long invocationLeastWindowCount = getInvocationLeastWindowCount(invocationStat,\n                ProviderInfoWeightManager.getWeight(invocationStat.getDimension().getProviderInfo()),\n                leastWindowCount);\n\n            if (invocationLeastWindowCount != -1\n                && invocationStat.getInvokeCount() >= invocationLeastWindowCount) {\n                sumException += invocationStat.getExceptionCount();\n                sumCall += invocationStat.getInvokeCount();\n            }\n        }\n        if (sumCall == 0) {\n            return -1;\n        }\n        return CalculateUtils.divide(sumException, sumCall);\n    }", "category": "Python"}, {"instruction": "For a given commit, will traverse the pipeline and find the time it entered in each stage of the pipeline\n@param commit\n@param dashboard\n@param pipeline\n@return", "input": "Java", "output": "private PipelineResponseCommit applyStageTimestamps(PipelineResponseCommit commit, Dashboard dashboard, Pipeline pipeline,List<PipelineStage> pipelineStageList){\r\n        PipelineResponseCommit returnCommit = new PipelineResponseCommit(commit);\r\n\r\n        for(PipelineStage systemStage : pipelineStageList) {\r\n            //get commits for a given stage\r\n            Map<String, PipelineCommit> commitMap = findCommitsForStage(dashboard, pipeline, systemStage);\r\n\r\n            //if this commit doesnt have a processed timestamp for this stage, add one\r\n            PipelineCommit pipelineCommit = commitMap.get(commit.getScmRevisionNumber());\r\n            if(pipelineCommit != null && !returnCommit.getProcessedTimestamps().containsKey(systemStage.getName())){\r\n                Long timestamp = pipelineCommit.getTimestamp();\r\n                returnCommit.addNewPipelineProcessedTimestamp(systemStage, timestamp);\r\n            }\r\n        }\r\n        return returnCommit;\r\n    }", "category": "Python"}, {"instruction": "\u83b7\u53d6\u6ce8\u518c\u914d\u7f6e\n\n@param config consumer config\n@return", "input": "Java", "output": "private AbstractInterfaceConfig getRegisterConfig(ConsumerConfig config) {\n        String url = ZookeeperRegistryHelper.convertConsumerToUrl(config);\n        String addr = url.substring(0, url.indexOf(\"?\"));\n        for (Map.Entry<ConsumerConfig, String> consumerUrl : consumerUrls.entrySet()) {\n            if (consumerUrl.getValue().contains(addr)) {\n                return consumerUrl.getKey();\n            }\n        }\n        return null;\n    }", "category": "Python"}, {"instruction": "[VARIABLE \"my_value\"]", "input": "Java", "output": "public List<Entity> runQueryOnProperty(String kind, String property, String value) {\n    // TODO change so that it's not necessary to hold the entities in a list for integration testing\n    // [START runQueryOnProperty]\n    StructuredQuery<Entity> query =\n        Query.newEntityQueryBuilder()\n            .setKind(kind)\n            .setFilter(PropertyFilter.eq(property, value))\n            .build();\n    QueryResults<Entity> results = datastore.run(query);\n    List<Entity> entities = Lists.newArrayList();\n    while (results.hasNext()) {\n      Entity result = results.next();\n      // do something with result\n      entities.add(result);\n    }\n    // [END runQueryOnProperty]\n    return entities;\n  }", "category": "Python"}, {"instruction": "Make a prediction on a new data point using a Binomial model.\n\n@param data A new data point.\n@return The prediction.\n@throws PredictException", "input": "Java", "output": "public AnomalyDetectionPrediction predictAnomalyDetection(RowData data) throws PredictException {\n    double[] preds = preamble(ModelCategory.AnomalyDetection, data, 0.0);\n\n    AnomalyDetectionPrediction p = new AnomalyDetectionPrediction();\n    p.normalizedScore = preds[0];\n    p.score = preds[1];\n    if (enableLeafAssignment) { // only get leaf node assignment if enabled\n      SharedTreeMojoModel.LeafNodeAssignments assignments = leafNodeAssignmentExtended(data);\n      p.leafNodeAssignments = assignments._paths;\n      p.leafNodeAssignmentIds = assignments._nodeIds;\n    }\n    if (enableStagedProbabilities) {\n        double[] rawData = nanArray(m.nfeatures());\n        rawData = fillRawData(data, rawData);\n        p.stageProbabilities = ((SharedTreeMojoModel) m).scoreStagedPredictions(rawData, preds.length);\n    }\n    return p;\n  }", "category": "Python"}, {"instruction": "Inserts the specified element at the tail of this queue if it is\npossible to do so immediately or if capacity limit is exited\nthe oldest element (the head) will be evicted, and then the new element added at the tail.\nThis method is generally preferable to method {@link #add},\nwhich can fail to insert an element only by throwing an exception.\n\n@throws NullPointerException if the specified element is null", "input": "Java", "output": "@Override\n    public boolean offer(final E e) {\n        requireNonNull(e, ILLEGAL_ELEMENT);\n\n        Supplier<Boolean> offerElement = () -> {\n            if (size == 0) {\n                ringBuffer[tailIndex] = e;\n                modificationsCount++;\n                size++;\n            } else if (size == maxSize) {\n                headIndex = nextIndex(headIndex);\n                tailIndex = nextIndex(tailIndex);\n                ringBuffer[tailIndex] = e;\n                modificationsCount++;\n            } else {\n                tailIndex = nextIndex(tailIndex);\n                ringBuffer[tailIndex] = e;\n                size++;\n                modificationsCount++;\n            }\n            return true;\n        };\n        return writeConcurrently(offerElement);\n    }", "category": "Python"}, {"instruction": "Checks the current resource less than or equal with the other resource by comparing\nall the fields in the resource.\n\n@param other The resource to compare\n@return True if current resource is less than or equal with the other resource, otherwise return false.", "input": "Java", "output": "public boolean lessThanOrEqual(@Nonnull ResourceSpec other) {\n\t\tint cmp1 = Double.compare(this.cpuCores, other.cpuCores);\n\t\tint cmp2 = Integer.compare(this.heapMemoryInMB, other.heapMemoryInMB);\n\t\tint cmp3 = Integer.compare(this.directMemoryInMB, other.directMemoryInMB);\n\t\tint cmp4 = Integer.compare(this.nativeMemoryInMB, other.nativeMemoryInMB);\n\t\tint cmp5 = Integer.compare(this.stateSizeInMB, other.stateSizeInMB);\n\t\tif (cmp1 <= 0 && cmp2 <= 0 && cmp3 <= 0 && cmp4 <= 0 && cmp5 <= 0) {\n\t\t\tfor (Resource resource : extendedResources.values()) {\n\t\t\t\tif (!other.extendedResources.containsKey(resource.getName()) ||\n\t\t\t\t\tother.extendedResources.get(resource.getName()).getResourceAggregateType() != resource.getResourceAggregateType() ||\n\t\t\t\t\t\tother.extendedResources.get(resource.getName()).getValue() < resource.getValue()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}", "category": "Python"}, {"instruction": "\u6362\u7b97\u6cd5\uff1f MD5  SHA-1 MurMurHash???\n\n@param value the value\n@return the byte []", "input": "Java", "output": "public static byte[] messageDigest(String value) {\n        MessageDigest md5;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(value.getBytes(\"UTF-8\"));\n            return md5.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new SofaRpcRuntimeException(\"No such algorithm named md5\", e);\n        } catch (UnsupportedEncodingException e) {\n            throw new SofaRpcRuntimeException(\"Unsupported encoding of\" + value, e);\n        }\n    }", "category": "Python"}, {"instruction": "Returns the double data\nfor this ndarray.\nIf possible (the offset is 0 representing the whole buffer)\nit will return a direct reference to the underlying array\n@param buf the ndarray to get the data for\n@return the double data for this ndarray", "input": "Java", "output": "public static double[] getDoubleData(INDArray buf) {\n        if (buf.data().dataType() != DataType.DOUBLE)\n            throw new IllegalArgumentException(\"Double data must be obtained from a double buffer\");\n\n        if (buf.data().allocationMode() == DataBuffer.AllocationMode.HEAP) {\n            return buf.data().asDouble();\n\n        } else {\n            double[] ret = new double[(int) buf.length()];\n            INDArray linear = buf.reshape(-1);\n            for (int i = 0; i < buf.length(); i++)\n                ret[i] = linear.getDouble(i);\n            return ret;\n\n        }\n    }", "category": "Python"}, {"instruction": "Gets origin weight.\n\n@return the origin weight", "input": "Java", "output": "public int getOriginWeight() {\n        if (originWeight == null) {\n            if (providerInfo == null) {\n                originWeight = RpcConfigs.getIntValue(RpcOptions.PROVIDER_WEIGHT);\n            } else {\n                originWeight = CommonUtils.parseInt(providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_WEIGHT),\n                    RpcConfigs.getIntValue(RpcOptions.PROVIDER_WEIGHT));\n            }\n        }\n        return originWeight;\n    }", "category": "Python"}, {"instruction": "Generate the output for all examples/batches in the input iterator, and concatenate them into a single array\nper network output\n\n@param iterator Data to pass through the network\n@return output for all examples in the iterator", "input": "Java", "output": "public INDArray[] output(MultiDataSetIterator iterator){\n        List<INDArray[]> outputs = new ArrayList<>();\n        while(iterator.hasNext()){\n            MultiDataSet next = iterator.next();\n            INDArray[] out = output(false, next.getFeatures(), next.getFeaturesMaskArrays(), next.getLabelsMaskArrays());\n            outputs.add(out);\n        }\n        INDArray[][] arr = outputs.toArray(new INDArray[outputs.size()][0]);\n        return DataSetUtil.mergeFeatures(arr, null).getFirst();\n    }", "category": "Python"}, {"instruction": "\u83b7\u53d6\u5171\u73b0\u9891\u6b21\n\n@param a \u7b2c\u4e00\u4e2a\u8bcd\n@param b \u7b2c\u4e8c\u4e2a\u8bcd\n@return \u7b2c\u4e00\u4e2a\u8bcd@\u7b2c\u4e8c\u4e2a\u8bcd\u51fa\u73b0\u7684\u9891\u6b21", "input": "Java", "output": "public static int getBiFrequency(String a, String b)\n    {\n        int idA = CoreDictionary.trie.exactMatchSearch(a);\n        if (idA == -1)\n        {\n            return 0;\n        }\n        int idB = CoreDictionary.trie.exactMatchSearch(b);\n        if (idB == -1)\n        {\n            return 0;\n        }\n        int index = binarySearch(pair, start[idA], start[idA + 1] - start[idA], idB);\n        if (index < 0) return 0;\n        index <<= 1;\n        return pair[index + 1];\n    }", "category": "Python"}, {"instruction": "Formats a link between two nodes\n\n@param from  from node\n@param to  to node\n@param label  label for this link\n@param tailport  tail port to use when formatting (dot-specific, \"sw\" or \"se)\n@return formatted link, not null", "input": "Java", "output": "private String formatPointer(PatriciaTrie.PatriciaNode<V> from, PatriciaTrie.PatriciaNode<V> to, String label,\n                    String tailport) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(getNodeId(from));\n        builder.append(\" -> \");\n        builder.append(getNodeId(to));\n        builder.append(\" [ \");\n        builder.append(\"label=\\\"\");\n        builder.append(label);\n        builder.append(\" \\\"\");\n        builder.append(\"tailport=\\\"\");\n        builder.append(tailport);\n        builder.append(\" \\\"\");\n        builder.append(\"fontcolor=\\\"#666666\\\" \");\n        builder.append(\" ]\");\n        builder.append(\"\\n\");\n        return builder.toString();\n    }", "category": "Python"}, {"instruction": "Return big decimal from buffer.\n\n@see mysql-5.1.60/strings/decimal.c - bin2decimal()", "input": "Java", "output": "public final BigDecimal getDecimal(final int pos, final int precision, final int scale) {\r\n        final int intg = precision - scale;\r\n        final int frac = scale;\r\n        final int intg0 = intg / DIG_PER_INT32;\r\n        final int frac0 = frac / DIG_PER_INT32;\r\n        final int intg0x = intg - intg0 * DIG_PER_INT32;\r\n        final int frac0x = frac - frac0 * DIG_PER_INT32;\r\n\r\n        final int binSize = intg0 * SIZE_OF_INT32 + dig2bytes[intg0x] + frac0 * SIZE_OF_INT32 + dig2bytes[frac0x];\r\n        if (pos + binSize > limit || pos < 0) {\r\n            throw new IllegalArgumentException(\"limit excceed: \" + (pos < 0 ? pos : (pos + binSize)));\r\n        }\r\n        return getDecimal0(origin + pos, intg, frac, // NL\r\n            intg0,\r\n            frac0,\r\n            intg0x,\r\n            frac0x);\r\n    }", "category": "Python"}, {"instruction": "To assist boot failure script, record the number of boot attempts.\nThis file gets deleted in case of successful boot.\n\n@see BootFailure", "input": "Java", "output": "private void recordBootAttempt(File home) {\n        try (OutputStream o=Files.newOutputStream(BootFailure.getBootFailureFile(home).toPath(), StandardOpenOption.CREATE, StandardOpenOption.APPEND)) {\n            o.write((new Date().toString() + System.getProperty(\"line.separator\", \"\\n\")).toString().getBytes());\n        } catch (IOException | InvalidPathException e) {\n            LOGGER.log(WARNING, \"Failed to record boot attempts\",e);\n        }\n    }", "category": "Python"}, {"instruction": "Fails all pending checkpoints which have not been acknowledged by the given execution\nattempt id.\n\n@param executionAttemptId for which to discard unacknowledged pending checkpoints\n@param cause of the failure", "input": "Java", "output": "public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {\n\t\tsynchronized (lock) {\n\t\t\tIterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator();\n\n\t\t\twhile (pendingCheckpointIterator.hasNext()) {\n\t\t\t\tfinal PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next();\n\n\t\t\t\tif (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {\n\t\t\t\t\tpendingCheckpointIterator.remove();\n\t\t\t\t\tdiscardCheckpoint(pendingCheckpoint, cause);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Creates a SSLEngineFactory to be used by internal communication server endpoints.", "input": "Java", "output": "public static SSLHandlerFactory createInternalServerSSLEngineFactory(final Configuration config) throws Exception {\n\t\tSSLContext sslContext = createInternalSSLContext(config);\n\t\tif (sslContext == null) {\n\t\t\tthrow new IllegalConfigurationException(\"SSL is not enabled for internal communication.\");\n\t\t}\n\n\t\treturn new SSLHandlerFactory(\n\t\t\t\tsslContext,\n\t\t\t\tgetEnabledProtocols(config),\n\t\t\t\tgetEnabledCipherSuites(config),\n\t\t\t\tfalse,\n\t\t\t\ttrue,\n\t\t\t\tconfig.getInteger(SecurityOptions.SSL_INTERNAL_HANDSHAKE_TIMEOUT),\n\t\t\t\tconfig.getInteger(SecurityOptions.SSL_INTERNAL_CLOSE_NOTIFY_FLUSH_TIMEOUT));\n\t}", "category": "Python"}, {"instruction": "Translates the properties as much as possible, and truncates at the first non-translatable property", "input": "Java", "output": "public static <X, Y> List<LocalProperty<Y>> translate(List<? extends LocalProperty<X>> properties, Function<X, Optional<Y>> translator)\n    {\n        properties = normalizeAndPrune(properties);\n\n        ImmutableList.Builder<LocalProperty<Y>> builder = ImmutableList.builder();\n        for (LocalProperty<X> property : properties) {\n            Optional<LocalProperty<Y>> translated = property.translate(translator);\n            if (translated.isPresent()) {\n                builder.add(translated.get());\n            }\n            else if (!(property instanceof ConstantProperty)) {\n                break; // Only break if we fail to translate non-constants\n            }\n        }\n\n        return builder.build();\n    }", "category": "Python"}, {"instruction": "The Uri Path.\n\n@return the uri path.", "input": "Java", "output": "public String path() {\n    /* build the fully qualified url with all query parameters */\n    StringBuilder path = new StringBuilder();\n    if (this.target != null) {\n      path.append(this.target);\n    }\n    if (this.uriTemplate != null) {\n      path.append(this.uriTemplate.toString());\n    }\n    if (path.length() == 0) {\n      /* no path indicates the root uri */\n      path.append(\"/\");\n    }\n    return path.toString();\n\n  }", "category": "Python"}, {"instruction": "Process the queue of commands and dispatch them to the stream. This method is only\ncalled in the event loop", "input": "Java", "output": "private void flush() {\n    try {\n      QueuedCommand cmd;\n      int i = 0;\n      boolean flushedOnce = false;\n      while ((cmd = queue.poll()) != null) {\n        cmd.run(channel);\n        if (++i == DEQUE_CHUNK_SIZE) {\n          i = 0;\n          // Flush each chunk so we are releasing buffers periodically. In theory this loop\n          // might never end as new events are continuously added to the queue, if we never\n          // flushed in that case we would be guaranteed to OOM.\n          channel.flush();\n          flushedOnce = true;\n        }\n      }\n      // Must flush at least once, even if there were no writes.\n      if (i != 0 || !flushedOnce) {\n        channel.flush();\n      }\n    } finally {\n      // Mark the write as done, if the queue is non-empty after marking trigger a new write.\n      scheduled.set(false);\n      if (!queue.isEmpty()) {\n        scheduleFlush();\n      }\n    }\n  }", "category": "Python"}, {"instruction": "/*\nReturns a unique name for the given script name", "input": "Java", "output": "private String getUniqueScriptName(String name, String ext) {\r\n\t\tif (this.getScriptImpl(name) == null) {\r\n\t\t\t// Its unique\r\n\t\t\treturn name;\r\n\t\t}\r\n\t\t// Its not unique, add a suitable index...\r\n\t\tString stub = name.substring(0, name.length() - ext.length() - 1);\r\n\t\tint index = 1;\r\n\t\tdo {\r\n\t\t\tindex++;\r\n\t\t\tname = stub + \"(\" + index + \").\" + ext;\r\n\t\t}\r\n\t\twhile (this.getScriptImpl(name) != null);\r\n\t\t\r\n\t\treturn name;\r\n\t}", "category": "Python"}, {"instruction": "\u4fdd\u5b58\u5230\u4e8c\u8fdb\u5236\u8f93\u51fa\u6d41\n\n@param out\n@return", "input": "Java", "output": "public boolean save(DataOutputStream out)\n    {\n        try\n        {\n            for (BaseNode node : child)\n            {\n                if (node == null)\n                {\n                    out.writeInt(0);\n                }\n                else\n                {\n                    out.writeInt(1);\n                    node.walkToSave(out);\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            logger.warning(\"\u4fdd\u5b58\u5230\" + out + \"\u5931\u8d25\" + TextUtility.exceptionToString(e));\n            return false;\n        }\n\n        return true;\n    }", "category": "Python"}, {"instruction": "Track trusted multifactor authentication attribute.\n\n@param authn         the authn\n@param attributeName the attribute name", "input": "Java", "output": "public static void trackTrustedMultifactorAuthenticationAttribute(\n        final Authentication authn,\n        final String attributeName) {\n\n        val newAuthn = DefaultAuthenticationBuilder.newInstance(authn)\n            .addAttribute(attributeName, Boolean.TRUE)\n            .build();\n        LOGGER.debug(\"Updated authentication session to remember trusted multifactor record via [{}]\", attributeName);\n        authn.update(newAuthn);\n    }", "category": "Python"}, {"instruction": "Example of getting a subscription.", "input": "Java", "output": "public Subscription getSubscription(String subscriptionId) throws Exception {\n    // [START pubsub_get_subscription]\n    try (SubscriptionAdminClient subscriptionAdminClient = SubscriptionAdminClient.create()) {\n      ProjectSubscriptionName subscriptionName =\n          ProjectSubscriptionName.of(projectId, subscriptionId);\n      Subscription subscription = subscriptionAdminClient.getSubscription(subscriptionName);\n      return subscription;\n    }\n    // [END pubsub_get_subscription]\n  }", "category": "Python"}, {"instruction": "Add an ndarray to the storage\n\n@param array the array to add", "input": "Java", "output": "@Override\n    public void addUpdate(NDArrayMessage array) {\n        UnsafeBuffer directBuffer = (UnsafeBuffer) NDArrayMessage.toBuffer(array);\n        byte[] data = directBuffer.byteArray();\n        if (data == null) {\n            data = new byte[directBuffer.capacity()];\n            directBuffer.getBytes(0, data, 0, data.length);\n        }\n        byte[] key = ByteBuffer.allocate(4).putInt(size).array();\n        try {\n            db.put(key, data);\n        } catch (RocksDBException e) {\n            throw new RuntimeException(e);\n        }\n\n        size++;\n\n    }", "category": "Python"}, {"instruction": "To enable \"run out of the box for testing\".", "input": "Java", "output": "private static String[] prepareDefaultConf() throws IOException {\n    final File templateFolder = new File(\"test/local-conf-templates\");\n    final File localConfFolder = new File(\"local/conf\");\n    if (!localConfFolder.exists()) {\n      FileUtils.copyDirectory(templateFolder, localConfFolder.getParentFile());\n      log.info(\"Copied local conf templates from \" + templateFolder.getAbsolutePath());\n    }\n    log.info(\"Using conf at \" + localConfFolder.getAbsolutePath());\n    return new String[]{\"-conf\", \"local/conf\"};\n  }", "category": "Python"}, {"instruction": "Generic method to create an input data stream with {@link org.apache.flink.api.common.io.InputFormat}.\n\n<p>The data stream is typed to the given TypeInformation. This method is intended for input formats\nwhere the return type cannot be determined by reflection analysis, and that do not implement the\n{@link org.apache.flink.api.java.typeutils.ResultTypeQueryable} interface.\n\n<p><b>NOTES ON CHECKPOINTING: </b> In the case of a {@link FileInputFormat}, the source\n(which executes the {@link ContinuousFileMonitoringFunction}) monitors the path, creates the\n{@link org.apache.flink.core.fs.FileInputSplit FileInputSplits} to be processed, forwards\nthem to the downstream {@link ContinuousFileReaderOperator} to read the actual data, and exits,\nwithout waiting for the readers to finish reading. This implies that no more checkpoint\nbarriers are going to be forwarded after the source exits, thus having no checkpoints.\n\n@param inputFormat\nThe input format used to create the data stream\n@param typeInfo\nThe information about the type of the output type\n@param <OUT>\nThe type of the returned data stream\n@return The data stream that represents the data created by the input format", "input": "Java", "output": "@PublicEvolving\n\tpublic <OUT> DataStreamSource<OUT> createInput(InputFormat<OUT, ?> inputFormat, TypeInformation<OUT> typeInfo) {\n\t\tDataStreamSource<OUT> source;\n\n\t\tif (inputFormat instanceof FileInputFormat) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tFileInputFormat<OUT> format = (FileInputFormat<OUT>) inputFormat;\n\n\t\t\tsource = createFileInput(format, typeInfo, \"Custom File source\",\n\t\t\t\t\tFileProcessingMode.PROCESS_ONCE, -1);\n\t\t} else {\n\t\t\tsource = createInput(inputFormat, typeInfo, \"Custom Source\");\n\t\t}\n\t\treturn source;\n\t}", "category": "Python"}, {"instruction": "\u67e5\u8be2\u5168\u90e8\u7ed3\u679c\n\n@param ms\n@return", "input": "Java", "output": "public String selectAll(MappedStatement ms) {\n        final Class<?> entityClass = getEntityClass(ms);\n        //\u4fee\u6539\u8fd4\u56de\u503c\u7c7b\u578b\u4e3a\u5b9e\u4f53\u7c7b\u578b\n        setResultType(ms, entityClass);\n        StringBuilder sql = new StringBuilder();\n        sql.append(SqlHelper.selectAllColumns(entityClass));\n        sql.append(SqlHelper.fromTable(entityClass, tableName(entityClass)));\n\n        // \u903b\u8f91\u5220\u9664\u7684\u672a\u5220\u9664\u67e5\u8be2\u6761\u4ef6\n        sql.append(\"<where>\");\n        sql.append(SqlHelper.whereLogicDelete(entityClass, false));\n        sql.append(\"</where>\");\n\n        sql.append(SqlHelper.orderByDefault(entityClass));\n        return sql.toString();\n    }", "category": "Python"}, {"instruction": "Perform SPNEGO login using the hadoop shim API if the configuration is available", "input": "Java", "output": "public static UserGroupInformation loginFromSpnegoKeytabAndReturnUGI(HiveConf hiveConf)\n    throws IOException {\n    String principal = hiveConf.getVar(ConfVars.HIVE_SERVER2_SPNEGO_PRINCIPAL);\n    String keyTabFile = hiveConf.getVar(ConfVars.HIVE_SERVER2_SPNEGO_KEYTAB);\n    if (principal.isEmpty() || keyTabFile.isEmpty()) {\n      throw new IOException(\"HiveServer2 SPNEGO principal or keytab is not correctly configured\");\n    } else {\n      return UserGroupInformation.loginUserFromKeytabAndReturnUGI(SecurityUtil.getServerPrincipal(principal, \"0.0.0.0\"), keyTabFile);\n    }\n  }", "category": "Python"}, {"instruction": "return the privateIp address of the given InstanceInfo record. The record could be for the local server\nor a remote server.\n\n@param instanceInfo\n@return the private Ip (also known as localIpv4 in ec2)", "input": "Java", "output": "public static String getPrivateIp(InstanceInfo instanceInfo) {\n        String defaultPrivateIp = null;\n        if (instanceInfo.getDataCenterInfo() instanceof AmazonInfo) {\n            defaultPrivateIp = ((AmazonInfo) instanceInfo.getDataCenterInfo()).get(AmazonInfo.MetaDataKey.localIpv4);\n        }\n\n        if (isNullOrEmpty(defaultPrivateIp)) {\n            // no other information, best effort\n            defaultPrivateIp = instanceInfo.getIPAddr();\n        }\n\n        return defaultPrivateIp;\n    }", "category": "Python"}, {"instruction": "Reads an attribute in {@link #b b}.\n\n@param attrs   prototypes of the attributes that must be parsed during the\nvisit of the class. Any attribute whose type is not equal to\nthe type of one the prototypes is ignored (i.e. an empty\n{@link Attribute} instance is returned).\n@param type    the type of the attribute.\n@param off     index of the first byte of the attribute's content in\n{@link #b b}. The 6 attribute header bytes, containing the\ntype and the length of the attribute, are not taken into\naccount here (they have already been read).\n@param len     the length of the attribute's content.\n@param buf     buffer to be used to call {@link #readUTF8 readUTF8},\n{@link #readClass(int, char[]) readClass} or {@link #readConst\nreadConst}.\n@param codeOff index of the first byte of code's attribute content in\n{@link #b b}, or -1 if the attribute to be read is not a code\nattribute. The 6 attribute header bytes, containing the type\nand the length of the attribute, are not taken into account\nhere.\n@param labels  the labels of the method's code, or <tt>null</tt> if the\nattribute to be read is not a code attribute.\n@return the attribute that has been read, or <tt>null</tt> to skip this\nattribute.", "input": "Java", "output": "private Attribute readAttribute(final Attribute[] attrs, final String type,\n                                    final int off, final int len, final char[] buf, final int codeOff,\n                                    final Label[] labels) {\n        for (int i = 0; i < attrs.length; ++i) {\n            if (attrs[i].type.equals(type)) {\n                return attrs[i].read(this, off, len, buf, codeOff, labels);\n            }\n        }\n        return new Attribute(type).read(this, off, len, null, -1, null);\n    }", "category": "Python"}, {"instruction": "Acquire the lock object.\n\n@param lock the lock\n@return true, if successful", "input": "Java", "output": "public boolean acquire(final Lock lock) {\n        lock.setUniqueId(this.uniqueId);\n        if (this.lockTimeout > 0) {\n            lock.setExpirationDate(ZonedDateTime.now(ZoneOffset.UTC).plusSeconds(this.lockTimeout));\n        } else {\n            lock.setExpirationDate(null);\n        }\n        var success = false;\n        try {\n            if (lock.getApplicationId() != null) {\n                this.entityManager.merge(lock);\n            } else {\n                lock.setApplicationId(this.applicationId);\n                this.entityManager.persist(lock);\n            }\n            success = true;\n        } catch (final Exception e) {\n            success = false;\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"[{}] could not obtain [{}] lock.\", this.uniqueId, this.applicationId, e);\n            } else {\n                LOGGER.info(\"[{}] could not obtain [{}] lock.\", this.uniqueId, this.applicationId);\n            }\n        }\n        return success;\n    }", "category": "Python"}, {"instruction": "Gets login context.\n\n@param credential the credential\n@return the login context\n@throws GeneralSecurityException the general security exception", "input": "Java", "output": "protected LoginContext getLoginContext(final UsernamePasswordCredential credential) throws GeneralSecurityException {\n        val callbackHandler = new UsernamePasswordCallbackHandler(credential.getUsername(), credential.getPassword());\n        if (this.loginConfigurationFile != null && StringUtils.isNotBlank(this.loginConfigType)\n            && this.loginConfigurationFile.exists() && this.loginConfigurationFile.canRead()) {\n            final Configuration.Parameters parameters = new URIParameter(loginConfigurationFile.toURI());\n            val loginConfig = Configuration.getInstance(this.loginConfigType, parameters);\n            return new LoginContext(this.realm, null, callbackHandler, loginConfig);\n        }\n        return new LoginContext(this.realm, callbackHandler);\n    }", "category": "Python"}, {"instruction": "Creates a new pending checkpoint tracker.\n\n@param checkpointId ID of the checkpoint.\n@param triggerTimestamp Trigger timestamp of the checkpoint.\n@param props The checkpoint properties.\n@return Tracker for statistics gathering.", "input": "Java", "output": "PendingCheckpointStats reportPendingCheckpoint(\n\t\t\tlong checkpointId,\n\t\t\tlong triggerTimestamp,\n\t\t\tCheckpointProperties props) {\n\n\t\tConcurrentHashMap<JobVertexID, TaskStateStats> taskStateStats = createEmptyTaskStateStatsMap();\n\n\t\tPendingCheckpointStats pending = new PendingCheckpointStats(\n\t\t\t\tcheckpointId,\n\t\t\t\ttriggerTimestamp,\n\t\t\t\tprops,\n\t\t\t\ttotalSubtaskCount,\n\t\t\t\ttaskStateStats,\n\t\t\t\tnew PendingCheckpointStatsCallback());\n\n\t\tstatsReadWriteLock.lock();\n\t\ttry {\n\t\t\tcounts.incrementInProgressCheckpoints();\n\t\t\thistory.addInProgressCheckpoint(pending);\n\n\t\t\tdirty = true;\n\t\t} finally {\n\t\t\tstatsReadWriteLock.unlock();\n\t\t}\n\n\t\treturn pending;\n\t}", "category": "Python"}, {"instruction": "Do the work.", "input": "Java", "output": "public void doIt() {\n    if (nodeidx == -1) {\n      GetLogsTask t = new GetLogsTask();\n      t.doIt();\n      bytes = t._bytes;\n    }\n    else {\n      H2ONode node = H2O.CLOUD._memary[nodeidx];\n      GetLogsTask t = new GetLogsTask();\n      Log.trace(\"GetLogsTask starting to node \" + nodeidx + \"...\");\n      // Synchronous RPC call to get ticks from remote (possibly this) node.\n      new RPC<>(node, t).call().get();\n      Log.trace(\"GetLogsTask completed to node \" + nodeidx);\n      bytes = t._bytes;\n    }\n  }", "category": "Python"}, {"instruction": "Resumes ZooKeeper (if it had previously been suspended).\n\n@throws Exception If an exception got thrown.", "input": "Java", "output": "public void resumeZooKeeper() throws Exception {\n        val zk = new ZooKeeperServiceRunner(this.zkPort, this.secureZK, this.tLSKeyStore, this.tLSKeyStorePasswordPath, this.tlsTrustStore);\n        if (this.zkServer.compareAndSet(null, zk)) {\n            // Initialize ZK runner (since nobody else did it for us).\n            zk.initialize();\n            log.info(\"ZooKeeper initialized.\");\n        } else {\n            zk.close();\n        }\n\n        // Start or resume ZK.\n        this.zkServer.get().start();\n        log.info(\"ZooKeeper resumed.\");\n    }", "category": "Python"}, {"instruction": "\u5b57\u8282\u6570\u8f6c\u5408\u9002\u5185\u5b58\u5927\u5c0f\n<p>\u4fdd\u75593\u4f4d\u5c0f\u6570</p>\n\n@param byteNum \u5b57\u8282\u6570\n@return \u5408\u9002\u5185\u5b58\u5927\u5c0f", "input": "Java", "output": "public static String byte2FitMemoryString(final long byteNum) {\n        if (byteNum < 0) {\n            return \"shouldn't be less than zero!\";\n        } else if (byteNum < MemoryConst.KB) {\n            return String.format(\"%d B\", byteNum);\n        } else if (byteNum < MemoryConst.MB) {\n            return String.format(\"%d KB\", byteNum / MemoryConst.KB);\n        } else if (byteNum < MemoryConst.GB) {\n            return String.format(\"%d MB\", byteNum / MemoryConst.MB);\n        } else {\n            return String.format(\"%d GB\", byteNum / MemoryConst.GB);\n        }\n    }", "category": "Python"}, {"instruction": "\u5c06\u5c5e\u6027\u7684\u8bcd\u6027\u9501\u5b9a\u4e3anature\n\n@param nature \u8bcd\u6027\n@return \u5982\u679c\u9501\u5b9a\u8bcd\u6027\u5728\u8bcd\u6027\u5217\u8868\u4e2d\uff0c\u8fd4\u56de\u771f\uff0c\u5426\u5219\u8fd4\u56de\u5047", "input": "Java", "output": "public boolean confirmNature(Nature nature)\n    {\n        if (attribute.nature.length == 1 && attribute.nature[0] == nature)\n        {\n            return true;\n        }\n        boolean result = true;\n        int frequency = attribute.getNatureFrequency(nature);\n        if (frequency == 0)\n        {\n            frequency = 1000;\n            result = false;\n        }\n        attribute = new CoreDictionary.Attribute(nature, frequency);\n        return result;\n    }", "category": "Python"}, {"instruction": "\u8bbe\u7f6e\u6620\u5c04\u8868\n@param deprelTranslatorPath \u6620\u5c04\u8868\u8def\u5f84\n@return", "input": "Java", "output": "public IDependencyParser setDeprelTranslater(String deprelTranslatorPath)\n    {\n        deprelTranslater = GlobalObjectPool.get(deprelTranslatorPath);\n        if (deprelTranslater != null) return this;\n\n        IOUtil.LineIterator iterator = new IOUtil.LineIterator(deprelTranslatorPath);\n        deprelTranslater = new TreeMap<String, String>();\n        while (iterator.hasNext())\n        {\n            String[] args = iterator.next().split(\"\\\\s\");\n            deprelTranslater.put(args[0], args[1]);\n        }\n        if (deprelTranslater.size() == 0)\n        {\n            deprelTranslater = null;\n        }\n        GlobalObjectPool.put(deprelTranslatorPath, deprelTranslater);\n\n        return this;\n    }", "category": "Python"}, {"instruction": "Returns the concatenation of 8-bit, length prefixed protocol names.\nhttp://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4", "input": "Java", "output": "public static byte[] concatLengthPrefixed(List<Protocol> protocols) {\n    Buffer result = new Buffer();\n    for (int i = 0, size = protocols.size(); i < size; i++) {\n      Protocol protocol = protocols.get(i);\n      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.\n      result.writeByte(protocol.toString().length());\n      result.writeUtf8(protocol.toString());\n    }\n    return result.readByteArray();\n  }", "category": "Python"}, {"instruction": "Creates a new ScheduledExecutorService that will use daemon threads with appropriate names the threads.\n@param size The number of threads in the threadpool\n@param poolName The name of the pool (this will be printed in logs)\n@return A new executor service.", "input": "Java", "output": "public static ScheduledExecutorService newScheduledThreadPool(int size, String poolName) {\n        // Caller runs only occurs after shutdown, as queue size is unbounded.\n        ScheduledThreadPoolExecutor result = new ScheduledThreadPoolExecutor(size, getThreadFactory(poolName), new CallerRuns());\n\n        // Do not execute any periodic tasks after shutdown.\n        result.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n\n        // Do not execute any delayed tasks after shutdown.\n        result.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n\n        // Remove tasks from the executor once they are done executing. By default, even when canceled, these tasks are\n        // not removed; if this setting is not enabled we could end up with leaked (and obsolete) tasks.\n        result.setRemoveOnCancelPolicy(true);\n        return result;\n    }", "category": "Python"}, {"instruction": "Attach a {@link ConfigurationPropertySource} support to the specified\n{@link Environment}. Adapts each {@link PropertySource} managed by the environment\nto a {@link ConfigurationPropertySource} and allows classic\n{@link PropertySourcesPropertyResolver} calls to resolve using\n{@link ConfigurationPropertyName configuration property names}.\n<p>\nThe attached resolver will dynamically track any additions or removals from the\nunderlying {@link Environment} property sources.\n@param environment the source environment (must be an instance of\n{@link ConfigurableEnvironment})\n@see #get(Environment)", "input": "Java", "output": "public static void attach(Environment environment) {\n\t\tAssert.isInstanceOf(ConfigurableEnvironment.class, environment);\n\t\tMutablePropertySources sources = ((ConfigurableEnvironment) environment)\n\t\t\t\t.getPropertySources();\n\t\tPropertySource<?> attached = sources.get(ATTACHED_PROPERTY_SOURCE_NAME);\n\t\tif (attached != null && attached.getSource() != sources) {\n\t\t\tsources.remove(ATTACHED_PROPERTY_SOURCE_NAME);\n\t\t\tattached = null;\n\t\t}\n\t\tif (attached == null) {\n\t\t\tsources.addFirst(new ConfigurationPropertySourcesPropertySource(\n\t\t\t\t\tATTACHED_PROPERTY_SOURCE_NAME,\n\t\t\t\t\tnew SpringConfigurationPropertySources(sources)));\n\t\t}\n\t}", "category": "Python"}, {"instruction": "\u8fd4\u56de\u65e0\u5e8f\u96c6\u5408\u4e2d\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\n\n\u5728\u8fd4\u56de\u7684Pair\u4e2d\uff0c\u7b2c\u4e00\u4e2a\u4e3a\u6700\u5c0f\u503c\uff0c\u7b2c\u4e8c\u4e2a\u4e3a\u6700\u5927\u503c", "input": "Java", "output": "public static <T> Pair<T, T> minAndMax(Collection<? extends T> coll, Comparator<? super T> comp) {\n\n\t\tIterator<? extends T> i = coll.iterator();\n\t\tT minCandidate = i.next();\n\t\tT maxCandidate = minCandidate;\n\n\t\twhile (i.hasNext()) {\n\t\t\tT next = i.next();\n\t\t\tif (comp.compare(next, minCandidate) < 0) {\n\t\t\t\tminCandidate = next;\n\t\t\t} else if (comp.compare(next, maxCandidate) > 0) {\n\t\t\t\tmaxCandidate = next;\n\t\t\t}\n\t\t}\n\n\t\treturn Pair.of(minCandidate, maxCandidate);\n\t}", "category": "Python"}, {"instruction": "Create collection.\n\n@param mongoTemplate  the mongo template\n@param collectionName the collection name\n@param dropCollection the drop collection", "input": "Java", "output": "public void createCollection(final MongoOperations mongoTemplate, final String collectionName, final boolean dropCollection) {\n        if (dropCollection) {\n            LOGGER.trace(\"Dropping database collection: [{}]\", collectionName);\n            mongoTemplate.dropCollection(collectionName);\n        }\n\n        if (!mongoTemplate.collectionExists(collectionName)) {\n            LOGGER.trace(\"Creating database collection: [{}]\", collectionName);\n            mongoTemplate.createCollection(collectionName);\n        }\n    }", "category": "Python"}, {"instruction": "Destroy is called after the produce or consume phase of a task finishes.", "input": "Java", "output": "@Override\n\tpublic void lazyDestroy() {\n\t\t// NOTE: if you change this logic, be sure to update recycle() as well!\n\t\tsynchronized (availableMemorySegments) {\n\t\t\tif (!isDestroyed) {\n\t\t\t\tMemorySegment segment;\n\t\t\t\twhile ((segment = availableMemorySegments.poll()) != null) {\n\t\t\t\t\treturnMemorySegment(segment);\n\t\t\t\t}\n\n\t\t\t\tBufferListener listener;\n\t\t\t\twhile ((listener = registeredListeners.poll()) != null) {\n\t\t\t\t\tlistener.notifyBufferDestroyed();\n\t\t\t\t}\n\n\t\t\t\tisDestroyed = true;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tnetworkBufferPool.destroyBufferPool(this);\n\t\t} catch (IOException e) {\n\t\t\tExceptionUtils.rethrow(e);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "\u5220\u9664\u5df2\u7ecf\u88ab\u5e9f\u5f03\u7684processId", "input": "Java", "output": "private synchronized void compareProgress(List<Long> processIds) {\n        if (CollectionUtils.isEmpty(processIds) == false) {\n            Long minProcessId = processIds.get(0);\n            // \u5bf9\u6bd4\u4e00\u4e0bprogress\u4e2d\u7684\u8bb0\u5f55\uff0c\u5982\u679c\u5c0f\u4e8e\u5f53\u524d\u6700\u5c0f\u7684processId\uff0c\u76f4\u63a5\u5220\u9664\u5185\u5b58\u4e2d\u7684\u8bb0\u5f55\n            // \u56e0\u4e3a\u53d1\u751f\u8de8\u673a\u5668\u8c03\u7528\u6216\u8005\u51fa\u73b0restart\u6307\u4ee4\uff0c\u5bf9\u5e94\u7684process\u8bb0\u5f55\u4e0d\u4f1a\u88ab\u5220\u9664\n            for (Long processId : progress.keySet()) {\n                if (processId < minProcessId) {\n                    progress.remove(processId);\n                }\n            }\n        }\n    }", "category": "Python"}, {"instruction": "This method places incoming VoidAggregation into clipboard, for further tracking\n\n@param aggregation\n@return TRUE, if given VoidAggregation was the last chunk, FALSE otherwise", "input": "Java", "output": "public boolean pin(@NonNull VoidAggregation aggregation) {\n        RequestDescriptor descriptor =\n                        RequestDescriptor.createDescriptor(aggregation.getOriginatorId(), aggregation.getTaskId());\n        VoidAggregation existing = clipboard.get(descriptor);\n        if (existing == null) {\n            existing = aggregation;\n            trackingCounter.incrementAndGet();\n            clipboard.put(descriptor, aggregation);\n        }\n\n        existing.accumulateAggregation(aggregation);\n\n        //if (counter.incrementAndGet() % 10000 == 0)\n        //    log.info(\"Clipboard stats: Totals: {}; Completed: {};\", clipboard.size(), completedQueue.size());\n\n        int missing = existing.getMissingChunks();\n        if (missing == 0) {\n            //  completedQueue.add(existing);\n            completedCounter.incrementAndGet();\n            return true;\n        } else\n            return false;\n    }", "category": "Python"}, {"instruction": "normal login handler part //todo: consider using mostly the same code as in proxy part below", "input": "Java", "output": "@Override\n  public boolean loginHandler(String target, HttpServletRequest request, HttpServletResponse response) throws IOException {\n    if (! isLoginTarget(target)) {\n      return false;\n    }\n\n    if (isPageRequest(request)) {\n      sendLoginForm(request, response);\n    } else {\n      ServletUtils.sendResponseError(response, HttpServletResponse.SC_UNAUTHORIZED, \"Access denied. Please login.\");\n    }\n    return true;\n  }", "category": "Python"}, {"instruction": "Retrieve a workflow by workflow id\n\n@param workflowId   the id of the workflow\n@param includeTasks specify if the tasks in the workflow need to be returned\n@return the requested workflow", "input": "Java", "output": "public Workflow getWorkflow(String workflowId, boolean includeTasks) {\n        Preconditions.checkArgument(StringUtils.isNotBlank(workflowId), \"workflow id cannot be blank\");\n        WorkflowPb.Workflow workflow = stub.getWorkflowStatus(\n                WorkflowServicePb.GetWorkflowStatusRequest.newBuilder()\n                        .setWorkflowId(workflowId)\n                        .setIncludeTasks(includeTasks)\n                        .build()\n        );\n        return protoMapper.fromProto(workflow);\n    }", "category": "Python"}, {"instruction": "Returns a slot that has been allocated from this instance. The slot needs have been canceled\nprior to calling this method.\n\n<p>The method will transition the slot to the \"released\" state. If the slot is already in state\n\"released\", this method will do nothing.</p>\n\n@param logicalSlot The slot to return.\n@return Future which is completed with true, if the slot was returned, false if not.", "input": "Java", "output": "@Override\n\tpublic void returnLogicalSlot(LogicalSlot logicalSlot) {\n\t\tcheckNotNull(logicalSlot);\n\t\tcheckArgument(logicalSlot instanceof Slot);\n\n\t\tfinal Slot slot = ((Slot) logicalSlot);\n\t\tcheckArgument(!slot.isAlive(), \"slot is still alive\");\n\t\tcheckArgument(slot.getOwner() == this, \"slot belongs to the wrong TaskManager.\");\n\n\t\tif (slot.markReleased()) {\n\t\t\tLOG.debug(\"Return allocated slot {}.\", slot);\n\t\t\tsynchronized (instanceLock) {\n\t\t\t\tif (isDead) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (this.allocatedSlots.remove(slot)) {\n\t\t\t\t\tthis.availableSlots.add(slot.getSlotNumber());\n\n\t\t\t\t\tif (this.slotAvailabilityListener != null) {\n\t\t\t\t\t\tthis.slotAvailabilityListener.newSlotAvailable(this);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Slot was not allocated from this TaskManager.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Load a graph into memory, using a given EdgeLineProcessor.\nAssume one edge per line\n@param path Path to the file containing the edges, one per line\n@param lineProcessor EdgeLineProcessor used to convert lines of text into a graph (or null for comment lines etc)\n@param vertexFactory Used to create vertices\n@param numVertices number of vertices in the graph\n@param allowMultipleEdges whether the graph should allow multiple edges between a given pair of vertices or not\n@return IGraph", "input": "Java", "output": "public static <V, E> Graph<V, E> loadGraph(String path, EdgeLineProcessor<E> lineProcessor,\n                    VertexFactory<V> vertexFactory, int numVertices, boolean allowMultipleEdges) throws IOException {\n        Graph<V, E> graph = new Graph<>(numVertices, allowMultipleEdges, vertexFactory);\n\n        try (BufferedReader br = new BufferedReader(new FileReader(new File(path)))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                Edge<E> edge = lineProcessor.processLine(line);\n                if (edge != null) {\n                    graph.addEdge(edge);\n                }\n            }\n        }\n\n        return graph;\n    }", "category": "Python"}, {"instruction": "Registers a KvState instance for the given key group index.\n\n@param keyGroupRange  Key group range to register\n@param kvStateId      ID of the KvState instance at the key group index.\n@param kvStateAddress Server address of the KvState instance at the key group index.\n@throws IndexOutOfBoundsException If key group range start < 0 or key group range end >= Number of key groups", "input": "Java", "output": "public void registerKvState(KeyGroupRange keyGroupRange, KvStateID kvStateId, InetSocketAddress kvStateAddress) {\n\n\t\tif (keyGroupRange.getStartKeyGroup() < 0 || keyGroupRange.getEndKeyGroup() >= numKeyGroups) {\n\t\t\tthrow new IndexOutOfBoundsException(\"Key group index\");\n\t\t}\n\n\t\tfor (int kgIdx = keyGroupRange.getStartKeyGroup(); kgIdx <= keyGroupRange.getEndKeyGroup(); ++kgIdx) {\n\n\t\t\tif (kvStateIds[kgIdx] == null && kvStateAddresses[kgIdx] == null) {\n\t\t\t\tnumRegisteredKeyGroups++;\n\t\t\t}\n\n\t\t\tkvStateIds[kgIdx] = kvStateId;\n\t\t\tkvStateAddresses[kgIdx] = kvStateAddress;\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Determine the SCM url and branch that is set for the component. Information\nis gathered with the assumption that the data is stored in options.url and\noptions.branch.\n\n@param component\n@return\t\t\tthe {@link RepoBranch} that the component uses", "input": "Java", "output": "protected RepoBranch getComponentRepoBranch(Component component) {\r\n        CollectorItem item = component.getFirstCollectorItemForType(CollectorType.SCM);\r\n        if (item == null) {\r\n        \tlogger.warn(\"Error encountered building pipeline: could not find scm collector item for dashboard.\");\r\n        \treturn new RepoBranch(\"\", \"\", RepoType.Unknown);\r\n        }\r\n        \r\n        // TODO find a better way?\r\n        String url = (String)item.getOptions().get(\"url\");\r\n        String branch = (String)item.getOptions().get(\"branch\");\r\n        \r\n        return new RepoBranch(url, branch, RepoType.Unknown);\r\n\t}", "category": "Python"}, {"instruction": "This method will return a borrowed object to the bag.  Objects\nthat are borrowed from the bag but never \"requited\" will result\nin a memory leak.\n\n@param bagEntry the value to return to the bag\n@throws NullPointerException if value is null\n@throws IllegalStateException if the bagEntry was not borrowed from the bag", "input": "Java", "output": "public void requite(final T bagEntry)\n   {\n      bagEntry.setState(STATE_NOT_IN_USE);\n\n      for (int i = 0; waiters.get() > 0; i++) {\n         if (bagEntry.getState() != STATE_NOT_IN_USE || handoffQueue.offer(bagEntry)) {\n            return;\n         }\n         else if ((i & 0xff) == 0xff) {\n            parkNanos(MICROSECONDS.toNanos(10));\n         }\n         else {\n            yield();\n         }\n      }\n\n      final List<Object> threadLocalList = threadList.get();\n      if (threadLocalList.size() < 50) {\n         threadLocalList.add(weakThreadLocals ? new WeakReference<>(bagEntry) : bagEntry);\n      }\n   }", "category": "Python"}, {"instruction": "Get zero masking flag\n\n@param layerConfig dictionary containing Keras layer configuration\n@return if masking zeros or not\n@throws InvalidKerasConfigurationException Invalid Keras configuration", "input": "Java", "output": "public static boolean getZeroMaskingFromConfig(Map<String, Object> layerConfig,\n                                                   KerasLayerConfiguration conf)\n            throws InvalidKerasConfigurationException {\n        Map<String, Object> innerConfig = KerasLayerUtils.getInnerLayerConfigFromConfig(layerConfig, conf);\n        boolean hasZeroMasking = true;\n        if (innerConfig.containsKey(conf.getLAYER_FIELD_MASK_ZERO())) {\n            hasZeroMasking = (boolean) innerConfig.get(conf.getLAYER_FIELD_MASK_ZERO());\n        }\n        return hasZeroMasking;\n    }", "category": "Python"}, {"instruction": "Init method validates configuration defined using", "input": "Java", "output": "protected void init() {\n        if (storage.size() != vocabCache.numWords())\n            throw new RuntimeException(\"Number of words in Vocab isn't matching number of stored Vectors. vocab: [\"\n                            + vocabCache.numWords() + \"]; storage: [\" + storage.size() + \"]\");\n\n        // initializing device cache\n        for (int i = 0; i < Nd4j.getAffinityManager().getNumberOfDevices(); i++) {\n            cacheWrtDevice.add(new ConcurrentHashMap<Integer, INDArray>());\n        }\n    }", "category": "Python"}, {"instruction": "Parse a template fragment.\n\n@param fragment to parse\n@param query if the fragment is part of a query string.", "input": "Java", "output": "private void parseFragment(String fragment, boolean query) {\n    ChunkTokenizer tokenizer = new ChunkTokenizer(fragment);\n\n    while (tokenizer.hasNext()) {\n      /* check to see if we have an expression or a literal */\n      String chunk = tokenizer.next();\n\n      if (chunk.startsWith(\"{\")) {\n        /* it's an expression, defer encoding until resolution */\n        FragmentType type = (query) ? FragmentType.QUERY : FragmentType.PATH_SEGMENT;\n\n        Expression expression = Expressions.create(chunk, type);\n        if (expression == null) {\n          this.templateChunks.add(Literal.create(encode(chunk, query)));\n        } else {\n          this.templateChunks.add(expression);\n        }\n      } else {\n        /* it's a literal, pct-encode it */\n        this.templateChunks.add(Literal.create(encode(chunk, query)));\n      }\n    }\n  }", "category": "Python"}, {"instruction": "Assign a SDVariable to represent the gradient of the SDVariable with the specified name\n\n@param variableName the variable name to assign the gradient variable for\n@param variable     the gradient variable", "input": "Java", "output": "public void setGradientForVariableName(String variableName, SDVariable variable) {\n        Preconditions.checkState(variables.containsKey(variableName), \"No variable exists with name \\\"%s\\\"\", variableName);\n        if (variable == null) {\n            throw new ND4JIllegalStateException(\"Unable to set null gradient for variable name \" + variableName);\n        }\n        variables.get(variableName).setGradient(variable);\n    }", "category": "Python"}, {"instruction": "Load some or all of completely persisted Values", "input": "Java", "output": "byte[] loadPersist() {\n    // 00       assert: not written yet\n    // 01       assert: load-after-delete\n    // 10       expected; read\n    // 11       assert: load-after-delete\n    assert isPersisted();\n    try {\n      byte[] res = H2O.getPM().load(backend(), this);\n      assert !isDeleted();        // Race in user-land: load-after-delete\n      return res;\n    } catch( IOException ioe ) { throw Log.throwErr(ioe); }\n  }", "category": "Python"}, {"instruction": "Gets the number of shared slots into which the given group can place subtasks or\nnested task groups.\n\n@param groupId The ID of the group.\n@return The number of shared slots available to the given job vertex.", "input": "Java", "output": "public int getNumberOfAvailableSlotsForGroup(AbstractID groupId) {\n\t\tsynchronized (lock) {\n\t\t\tMap<ResourceID, List<SharedSlot>> available = availableSlotsPerJid.get(groupId);\n\n\t\t\tif (available != null) {\n\t\t\t\tSet<SharedSlot> set = new HashSet<SharedSlot>();\n\n\t\t\t\tfor (List<SharedSlot> list : available.values()) {\n\t\t\t\t\tfor (SharedSlot slot : list) {\n\t\t\t\t\t\tset.add(slot);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn set.size();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// if no entry exists for a JobVertexID so far, then the vertex with that ID can\n\t\t\t\t// add a subtask into each shared slot of this group. Consequently, all\n\t\t\t\t// of them are available for that JobVertexID.\n\t\t\t\treturn allSlots.size();\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Gets the XML representation of the given API {@code response}.\n<p>\nAn XML element named with name of the endpoint and with child elements as given by\n{@link ApiResponse#toXML(Document, Element)}.\n\n@param endpointName the name of the API endpoint, must not be {@code null}.\n@param response the API response, must not be {@code null}.\n@return the XML representation of the given response.\n@throws ApiException if an error occurred while converting the response.", "input": "Java", "output": "static String responseToXml(String endpointName, ApiResponse response) throws ApiException {\n\t\ttry {\n\t\t\tDocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder docBuilder = docFactory.newDocumentBuilder();\n\t\n\t\t\tDocument doc = docBuilder.newDocument();\n\t\t\tElement rootElement = doc.createElement(endpointName);\n\t\t\tdoc.appendChild(rootElement);\n\t\t\tresponse.toXML(doc, rootElement);\n\t\t\t\n\t\t\tTransformerFactory transformerFactory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = transformerFactory.newTransformer();\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\t\n\t\t\tStringWriter sw = new StringWriter();\n\t\t\tStreamResult result =  new StreamResult(sw);\n\t\t\ttransformer.transform(source, result);\n\t\t\t\n\t\t\treturn sw.toString();\n\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(\"Failed to convert API response to XML: \" + e.getMessage(), e);\n\t\t\tthrow new ApiException(ApiException.Type.INTERNAL_ERROR, e);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "This method is not intended to be used in the client.\nThe client makes a request to the server to get the {@link ExternalStorageLocation}", "input": "Java", "output": "@Override\n    public ExternalStorageLocation getLocation(Operation operation, PayloadType payloadType, String path) {\n        String uri;\n        switch (payloadType) {\n            case WORKFLOW_INPUT:\n            case WORKFLOW_OUTPUT:\n                uri = \"workflow\";\n                break;\n            case TASK_INPUT:\n            case TASK_OUTPUT:\n                uri = \"tasks\";\n                break;\n            default:\n                throw new ConductorClientException(String.format(\"Invalid payload type: %s for operation: %s\", payloadType.toString(), operation.toString()));\n        }\n        return clientBase.getForEntity(String.format(\"%s/externalstoragelocation\", uri), new Object[]{\"path\", path, \"operation\", operation.toString(), \"payloadType\", payloadType.toString()}, ExternalStorageLocation.class);\n    }", "category": "Python"}, {"instruction": "Adds an indexed sequence of properties (with sub-properties) under a common key.\n\n<p>For example:\n\n<pre>\nschema.fields.0.type = INT, schema.fields.0.name = test\nschema.fields.1.type = LONG, schema.fields.1.name = test2\n</pre>\n\n<p>The arity of each subKeyValues must match the arity of propertyKeys.", "input": "Java", "output": "public void putIndexedFixedProperties(String key, List<String> subKeys, List<List<String>> subKeyValues) {\n\t\tcheckNotNull(key);\n\t\tcheckNotNull(subKeys);\n\t\tcheckNotNull(subKeyValues);\n\t\tfor (int idx = 0; idx < subKeyValues.size(); idx++) {\n\t\t\tfinal List<String> values = subKeyValues.get(idx);\n\t\t\tif (values == null || values.size() != subKeys.size()) {\n\t\t\t\tthrow new ValidationException(\"Values must have same arity as keys.\");\n\t\t\t}\n\t\t\tfor (int keyIdx = 0; keyIdx < values.size(); keyIdx++) {\n\t\t\t\tput(key + '.' + idx + '.' + subKeys.get(keyIdx), values.get(keyIdx));\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Convert a DataSet to the equivalent MultiDataSet", "input": "Java", "output": "public static MultiDataSet toMultiDataSet(DataSet dataSet) {\n        INDArray f = dataSet.getFeatures();\n        INDArray l = dataSet.getLabels();\n        INDArray fMask = dataSet.getFeaturesMaskArray();\n        INDArray lMask = dataSet.getLabelsMaskArray();\n\n        INDArray[] fNew = f == null ? null : new INDArray[] {f};\n        INDArray[] lNew = l == null ? null : new INDArray[] {l};\n        INDArray[] fMaskNew = (fMask != null ? new INDArray[] {fMask} : null);\n        INDArray[] lMaskNew = (lMask != null ? new INDArray[] {lMask} : null);\n\n        return new org.nd4j.linalg.dataset.MultiDataSet(fNew, lNew, fMaskNew, lMaskNew);\n    }", "category": "Python"}, {"instruction": "Returns an {@link Iterable} that lists items in the normal order\nbut which hides the base iterator implementation details.\n\n@since 1.492", "input": "Java", "output": "public static <T> Iterable<T> wrap(final Iterable<T> base) {\n        return new Iterable<T>() {\n            public Iterator<T> iterator() {\n                final Iterator<T> itr = base.iterator();\n                return new Iterator<T>() {\n                    public boolean hasNext() {\n                        return itr.hasNext();\n                    }\n\n                    public T next() {\n                        return itr.next();\n                    }\n\n                    public void remove() {\n                        itr.remove();\n                    }\n                };\n            }\n        };\n    }", "category": "Python"}, {"instruction": "Determine unauthorized service redirect url.\n\n@param context the context\n@return the uri", "input": "Java", "output": "protected URI determineUnauthorizedServiceRedirectUrl(final RequestContext context) {\n        val redirectUrl = WebUtils.getUnauthorizedRedirectUrlFromFlowScope(context);\n        val currentEvent = context.getCurrentEvent();\n        val eventAttributes = currentEvent.getAttributes();\n        LOGGER.debug(\"Finalizing the unauthorized redirect URL [{}] when processing event [{}] with attributes [{}]\",\n            redirectUrl, currentEvent.getId(), eventAttributes);\n        return redirectUrl;\n    }", "category": "Python"}, {"instruction": "Returns the next available {@link JsonElement} on the reader. Null if none available.\n\n@return the next available {@link JsonElement} on the reader. Null if none available.\n@throws JsonParseException if the incoming stream is malformed JSON.\n@since 1.4", "input": "Java", "output": "public JsonElement next() throws JsonParseException {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    try {\n      return Streams.parse(parser);\n    } catch (StackOverflowError e) {\n      throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n    } catch (OutOfMemoryError e) {\n      throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n    } catch (JsonParseException e) {\n      throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e;\n    }\n  }", "category": "Python"}, {"instruction": "Convert a parquet 'map' logical type {@link Group} to a java map of string keys to groups/lists/primitive values", "input": "Java", "output": "private static Map<String, Object> convertLogicalMap(Group g, boolean binaryAsString)\n  {\n    /*\n      // Map<String, Integer> (nullable map, non-null values)\n      optional group my_map (MAP) {\n        repeated group map {\n          required binary str (UTF8);\n          required int32 num;\n        }\n      }\n\n      // Map<String, Integer> (nullable map, nullable values)\n      optional group my_map (MAP_KEY_VALUE) {(\n        repeated group map {\n          required binary key (UTF8);\n          optional int32 value;\n        }\n      }\n     */\n    assert isLogicalMapType(g.getType());\n    int mapEntries = g.getFieldRepetitionCount(0);\n    Map<String, Object> converted = new HashMap<>();\n    for (int i = 0; i < mapEntries; i++) {\n      Group mapEntry = g.getGroup(0, i);\n      String key = convertPrimitiveField(mapEntry, 0, binaryAsString).toString();\n      Object value = convertField(mapEntry, \"value\", binaryAsString);\n      converted.put(key, value);\n    }\n    return converted;\n  }", "category": "Python"}, {"instruction": "DES\u52a0\u5bc6\u6a21\u677f\n\n@param data           \u6570\u636e\n@param key            \u79d8\u94a5\n@param algorithm      \u52a0\u5bc6\u7b97\u6cd5\n@param transformation \u8f6c\u53d8\n@param isEncrypt      {@code true}: \u52a0\u5bc6 {@code false}: \u89e3\u5bc6\n@return \u5bc6\u6587\u6216\u8005\u660e\u6587\uff0c\u9002\u7528\u4e8eDES\uff0c3DES\uff0cAES", "input": "Java", "output": "public static byte[] desTemplate(byte[] data, byte[] key, String algorithm, String transformation, boolean isEncrypt) {\n        if (data == null || data.length == 0 || key == null || key.length == 0) return null;\n        try {\n            SecretKeySpec keySpec = new SecretKeySpec(key, algorithm);\n            Cipher        cipher  = Cipher.getInstance(transformation);\n            SecureRandom  random  = new SecureRandom();\n            cipher.init(isEncrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE, keySpec, random);\n            return cipher.doFinal(data);\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return null;\n        }\n    }", "category": "Python"}, {"instruction": "\u4e24\u4e2a\u96c6\u5408\u7684\u5dee\u96c6<br>\n\u9488\u5bf9\u4e00\u4e2a\u96c6\u5408\u4e2d\u5b58\u5728\u591a\u4e2a\u76f8\u540c\u5143\u7d20\u7684\u60c5\u51b5\uff0c\u8ba1\u7b97\u4e24\u4e2a\u96c6\u5408\u4e2d\u6b64\u5143\u7d20\u7684\u4e2a\u6570\uff0c\u4fdd\u7559\u4e24\u4e2a\u96c6\u5408\u4e2d\u6b64\u5143\u7d20\u4e2a\u6570\u5dee\u7684\u4e2a\u6570<br>\n\u4f8b\u5982\uff1a\u96c6\u54081\uff1a[a, b, c, c, c]\uff0c\u96c6\u54082\uff1a[a, b, c, c]<br>\n\u7ed3\u679c\uff1a[c]\uff0c\u6b64\u7ed3\u679c\u4e2d\u53ea\u4fdd\u7559\u4e86\u4e00\u4e2a<br>\n\u4efb\u610f\u4e00\u4e2a\u96c6\u5408\u4e3a\u7a7a\uff0c\u8fd4\u56de\u53e6\u4e00\u4e2a\u96c6\u5408<br>\n\u4e24\u4e2a\u96c6\u5408\u65e0\u4ea4\u96c6\u5219\u8fd4\u56de\u4e24\u4e2a\u96c6\u5408\u7684\u7ec4\u5408\n\n@param <T> \u96c6\u5408\u5143\u7d20\u7c7b\u578b\n@param coll1 \u96c6\u54081\n@param coll2 \u96c6\u54082\n@return \u5dee\u96c6\u7684\u96c6\u5408\uff0c\u8fd4\u56de {@link ArrayList}", "input": "Java", "output": "public static <T> Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2) {\r\n\t\tif (isEmpty(coll1)) {\r\n\t\t\treturn coll2;\r\n\t\t}\r\n\t\tif (isEmpty(coll2)) {\r\n\t\t\treturn coll1;\r\n\t\t}\r\n\r\n\t\tfinal ArrayList<T> result = new ArrayList<>();\r\n\t\tfinal Map<T, Integer> map1 = countMap(coll1);\r\n\t\tfinal Map<T, Integer> map2 = countMap(coll2);\r\n\t\tfinal Set<T> elts = newHashSet(coll2);\r\n\t\telts.addAll(coll1);\r\n\t\tint m;\r\n\t\tfor (T t : elts) {\r\n\t\t\tm = Math.abs(Convert.toInt(map1.get(t), 0) - Convert.toInt(map2.get(t), 0));\r\n\t\t\tfor (int i = 0; i < m; i++) {\r\n\t\t\t\tresult.add(t);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}", "category": "Python"}, {"instruction": "Swap data source to database access configuration.\n\n@param dataSource data source\n@return database access configuration", "input": "Java", "output": "public DatabaseAccessConfiguration swap(final DataSource dataSource) {\n        DataSourcePropertyProvider provider = DataSourcePropertyProviderLoader.getProvider(dataSource);\n        try {\n            String url = (String) findGetterMethod(dataSource, provider.getURLPropertyName()).invoke(dataSource);\n            String username = (String) findGetterMethod(dataSource, provider.getUsernamePropertyName()).invoke(dataSource);\n            String password = (String) findGetterMethod(dataSource, provider.getPasswordPropertyName()).invoke(dataSource);\n            return new DatabaseAccessConfiguration(url, username, password);\n        } catch (final ReflectiveOperationException ex) {\n            throw new ShardingException(\"Cannot swap data source type: `%s`, please provide an implementation from SPI `%s`\", \n                    dataSource.getClass().getName(), DataSourcePropertyProvider.class.getName());\n        }\n    }", "category": "Python"}, {"instruction": "/* (non-Javadoc)\n@see org.apache.hive.service.cli.operation.Operation#getNextRowSet(org.apache.hive.service.cli.FetchOrientation, long)", "input": "Java", "output": "@Override\n  public RowSet getNextRowSet(FetchOrientation orientation, long maxRows) throws HiveSQLException {\n    validateDefaultFetchOrientation(orientation);\n    if (orientation.equals(FetchOrientation.FETCH_FIRST)) {\n      resetResultReader();\n    }\n    List<String> rows = readResults((int) maxRows);\n    RowSet rowSet = RowSetFactory.create(resultSchema, getProtocolVersion());\n\n    for (String row : rows) {\n      rowSet.addRow(new String[] {row});\n    }\n    return rowSet;\n  }", "category": "Python"}, {"instruction": "set bit from segments.\n\n@param segments target segments.\n@param baseOffset bits base offset.\n@param index bit index from base offset.", "input": "Java", "output": "public static void bitSet(MemorySegment[] segments, int baseOffset, int index) {\n\t\tif (segments.length == 1) {\n\t\t\tint offset = baseOffset + ((index & BIT_BYTE_POSITION_MASK) >>> 3);\n\t\t\tMemorySegment segment = segments[0];\n\t\t\tbyte current = segment.get(offset);\n\t\t\tcurrent |= (1 << (index & BIT_BYTE_INDEX_MASK));\n\t\t\tsegment.put(offset, current);\n\t\t} else {\n\t\t\tbitSetMultiSegments(segments, baseOffset, index);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "\u5206\u6790\u53e5\u6cd5\n\n@param words   \u8bcd\u8bed\u5217\u8868\n@param postags \u8bcd\u6027\u5217\u8868\n@param heads   \u8f93\u51fa\u4f9d\u5b58\u6307\u5411\u5217\u8868\n@param deprels \u8f93\u51fa\u4f9d\u5b58\u540d\u79f0\u5217\u8868\n@return \u8282\u70b9\u7684\u4e2a\u6570", "input": "Java", "output": "public int parse(List<String> words, List<String> postags, List<Integer> heads, List<String> deprels)\n    {\n        Instance inst = new Instance();\n        inst.forms.add(SpecialOption.ROOT);\n        inst.postags.add(SpecialOption.ROOT);\n\n        for (int i = 0; i < words.size(); i++)\n        {\n            inst.forms.add(words.get(i));\n            inst.postags.add(postags.get(i));\n        }\n\n        parser.predict(inst, heads, deprels);\n        heads.remove(0);\n        deprels.remove(0);\n\n        return heads.size();\n    }", "category": "Python"}, {"instruction": "Build metadata resolver aggregate. Loops through metadata resources\nand attempts to resolve the metadata.\n\n@param entityId the entity id", "input": "Java", "output": "@Synchronized\n    @SneakyThrows\n    public void buildMetadataResolverAggregate(final String entityId) {\n        LOGGER.trace(\"Building metadata resolver aggregate\");\n        this.metadataResolver = new ChainingMetadataResolver();\n        val resolvers = new ArrayList<MetadataResolver>();\n        val entries = this.metadataResources.entrySet();\n        entries.forEach(entry -> {\n            val resource = entry.getKey();\n            LOGGER.debug(\"Loading [{}]\", resource.getFilename());\n            resolvers.addAll(loadMetadataFromResource(entry.getValue(), resource, entityId));\n        });\n        this.metadataResolver.setId(ChainingMetadataResolver.class.getCanonicalName());\n        this.metadataResolver.setResolvers(resolvers);\n        LOGGER.debug(\"Collected metadata from [{}] resolvers(s). Initializing aggregate resolver...\", resolvers.size());\n        this.metadataResolver.initialize();\n        LOGGER.info(\"Metadata aggregate initialized successfully.\");\n    }", "category": "Python"}, {"instruction": "Find first by uid, otp pair.\n\n@param uid uid to search\n@param otp otp to search\n@return token for uid, otp pair", "input": "Java", "output": "@View(name = \"by_uid_otp\", map = \"function(doc) { if(doc.token && doc.userId) { emit([doc.userId, doc.token], doc) } }\")\n    public CouchDbGoogleAuthenticatorToken findOneByUidForOtp(final String uid, final Integer otp) {\n        val view = createQuery(\"by_uid_otp\").key(ComplexKey.of(uid, otp)).limit(1);\n        return db.queryView(view, CouchDbGoogleAuthenticatorToken.class).stream().findFirst().orElse(null);\n    }", "category": "Python"}, {"instruction": "Download the resource at getURL() to the local resource directory, and return the local copy as a File\n\n@return File of the local resource", "input": "Java", "output": "protected File getResourceFile(){\n\n        URL url = getURL();\n        String urlString = url.toString();\n        String filename = urlString.substring(urlString.lastIndexOf('/')+1);\n        File resourceDir = DL4JResources.getDirectory(ResourceType.RESOURCE, resourceName());\n        File localFile = new File(resourceDir, filename);\n\n        String expMD5 = resourceMD5();\n        if(localFile.exists()){\n            try{\n                if(Downloader.checkMD5OfFile(expMD5, localFile)){\n                    return localFile;\n                }\n            } catch (IOException e){\n                //Ignore\n            }\n            //MD5 failed\n            localFile.delete();\n        }\n\n        //Download\n        try {\n            Downloader.download(resourceName(), url, localFile, expMD5, 3);\n        } catch (IOException e){\n            throw new RuntimeException(\"Error downloading labels\",e);\n        }\n\n        return localFile;\n    }", "category": "Python"}, {"instruction": "Converts a 128 bit array into a UUID.\nCopied from UUID's private constructor.", "input": "Java", "output": "@VisibleForTesting\n    static UUID bytesToUUID(byte[] data) {\n        long msb = 0;\n        long lsb = 0;\n        assert data.length == 16 : \"data must be 16 bytes in length\";\n        for (int i = 0; i < 8; i++) {\n            msb = (msb << 8) | (data[i] & 0xff);\n        }\n        for (int i = 8; i < 16; i++) {\n            lsb = (lsb << 8) | (data[i] & 0xff);\n        }\n        return new UUID(msb, lsb);\n    }", "category": "Python"}, {"instruction": "Create a new SAML ECP response object.\n\n@param assertionConsumerUrl the assertion consumer url\n@return the response", "input": "Java", "output": "public org.opensaml.saml.saml2.ecp.Response newEcpResponse(final String assertionConsumerUrl) {\n        val samlResponse = newSamlObject(org.opensaml.saml.saml2.ecp.Response.class);\n        samlResponse.setSOAP11MustUnderstand(Boolean.TRUE);\n        samlResponse.setSOAP11Actor(ActorBearing.SOAP11_ACTOR_NEXT);\n        samlResponse.setAssertionConsumerServiceURL(assertionConsumerUrl);\n        return samlResponse;\n    }", "category": "Python"}, {"instruction": "------------------------------------------------------------------------", "input": "Java", "output": "@Override\n\tpublic MutableObjectIterator<E> getIterator() throws InterruptedException {\n\t\tsynchronized (this.iteratorLock) {\n\t\t\t// wait while both the iterator and the exception are not set\n\t\t\twhile (this.iterator == null && this.iteratorException == null) {\n\t\t\t\tthis.iteratorLock.wait();\n\t\t\t}\n\t\t\t\n\t\t\tif (this.iteratorException != null) {\n\t\t\t\tthrow new RuntimeException(\"Error obtaining the sorted input: \" + this.iteratorException.getMessage(),\n\t\t\t\t\tthis.iteratorException);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.iterator;\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Convert a raw record via\nthe {@link TransformProcess}\nto a base 64ed ndarray\n@param batch the record to convert\n@return teh base 64ed ndarray\n@throws IOException", "input": "Java", "output": "public Base64NDArrayBody toArray(BatchCSVRecord batch) throws IOException {\n        List<List<Writable>> converted =  execute(toArrowWritables(toArrowColumnsString(\n                bufferAllocator,transformProcess.getInitialSchema(),\n                batch.getRecordsAsString()),\n                transformProcess.getInitialSchema()),transformProcess);\n\n        ArrowWritableRecordBatch arrowRecordBatch = (ArrowWritableRecordBatch) converted;\n        INDArray convert = ArrowConverter.toArray(arrowRecordBatch);\n        return new Base64NDArrayBody(Nd4jBase64.base64String(convert));\n    }", "category": "Python"}, {"instruction": "Based on the ConciseSet implementation by Alessandro Colantonio", "input": "Java", "output": "private static void trimZeros(IntList set)\n  {\n    // loop over ALL_ZEROS_LITERAL words\n    int w;\n    int last = set.length() - 1;\n    do {\n      w = set.get(last);\n      if (w == ConciseSetUtils.ALL_ZEROS_LITERAL) {\n        set.set(last, 0);\n        last--;\n      } else if (ConciseSetUtils.isZeroSequence(w)) {\n        if (ConciseSetUtils.isSequenceWithNoBits(w)) {\n          set.set(last, 0);\n          last--;\n        } else {\n          // convert the sequence in a 1-bit literal word\n          set.set(last, ConciseSetUtils.getLiteral(w, false));\n          return;\n        }\n      } else {\n        // one sequence or literal\n        return;\n      }\n      if (set.isEmpty() || last == -1) {\n        return;\n      }\n    } while (true);\n  }", "category": "Python"}, {"instruction": "\u79d2\u6570\u8f6c\u4e3a\u65f6\u95f4\u683c\u5f0f(HH:mm:ss)<br>\n\u53c2\u8003\uff1ahttps://github.com/iceroot\n\n@param seconds \u9700\u8981\u8f6c\u6362\u7684\u79d2\u6570\n@return \u8f6c\u6362\u540e\u7684\u5b57\u7b26\u4e32\n@since 3.1.2", "input": "Java", "output": "public static String secondToTime(int seconds) {\r\n\t\tif (seconds < 0) {\r\n\t\t\tthrow new IllegalArgumentException(\"Seconds must be a positive number!\");\r\n\t\t}\r\n\r\n\t\tint hour = seconds / 3600;\r\n\t\tint other = seconds % 3600;\r\n\t\tint minute = other / 60;\r\n\t\tint second = other % 60;\r\n\t\tfinal StringBuilder sb = new StringBuilder();\r\n\t\tif (hour < 10) {\r\n\t\t\tsb.append(\"0\");\r\n\t\t}\r\n\t\tsb.append(hour);\r\n\t\tsb.append(\":\");\r\n\t\tif (minute < 10) {\r\n\t\t\tsb.append(\"0\");\r\n\t\t}\r\n\t\tsb.append(minute);\r\n\t\tsb.append(\":\");\r\n\t\tif (second < 10) {\r\n\t\t\tsb.append(\"0\");\r\n\t\t}\r\n\t\tsb.append(second);\r\n\t\treturn sb.toString();\r\n\t}", "category": "Python"}, {"instruction": "Creates a new big-endian buffer whose content is a subregion of\nthe specified {@code string} encoded in the specified {@code charset}.\nThe new buffer's {@code readerIndex} and {@code writerIndex} are\n{@code 0} and the length of the encoded string respectively.", "input": "Java", "output": "public static ByteBuf copiedBuffer(\n            CharSequence string, int offset, int length, Charset charset) {\n        if (string == null) {\n            throw new NullPointerException(\"string\");\n        }\n        if (length == 0) {\n            return EMPTY_BUFFER;\n        }\n\n        if (string instanceof CharBuffer) {\n            CharBuffer buf = (CharBuffer) string;\n            if (buf.hasArray()) {\n                return copiedBuffer(\n                        buf.array(),\n                        buf.arrayOffset() + buf.position() + offset,\n                        length, charset);\n            }\n\n            buf = buf.slice();\n            buf.limit(length);\n            buf.position(offset);\n            return copiedBuffer(buf, charset);\n        }\n\n        return copiedBuffer(CharBuffer.wrap(string, offset, offset + length), charset);\n    }", "category": "Python"}, {"instruction": "Build an object out of a given class and a map for field names to values.\n@param clazz The class to be created.\n@param params A map of the parameters.\n@return An instantiated object.\n@throws Exception when constructor fails.", "input": "Java", "output": "public static Object constructByNamedParams(Class clazz, Map params) throws Exception {\n        Object obj = clazz.getConstructor().newInstance();\n\n        Method[] allMethods = clazz.getMethods();\n        for(Method method : allMethods) {\n            if(method.getName().startsWith(\"set\")) {\n                Object [] o = new Object [1];\n                String propertyName = Introspector.decapitalize(method.getName().substring(3));\n                if (params.containsKey(propertyName)) {\n                    o[0] = params.get(propertyName);\n                    method.invoke(obj, o);\n                }\n            }\n        }\n        return obj;\n    }", "category": "Python"}, {"instruction": "Resolve all of the type arguments for the given super type from the given type.\n\n@param type      The type to resolve from\n@param superTypeToResolve The suepr type to resolve from\n@return The type arguments to the interface", "input": "Java", "output": "public static Class[] resolveSuperTypeGenericArguments(Class<?> type, Class<?> superTypeToResolve) {\n        Type supertype = type.getGenericSuperclass();\n        Class<?> superclass = type.getSuperclass();\n        while (superclass != null && superclass != Object.class) {\n            if (supertype instanceof ParameterizedType) {\n                ParameterizedType pt = (ParameterizedType) supertype;\n                if (pt.getRawType() == superTypeToResolve) {\n                    return resolveTypeArguments(supertype);\n                }\n            }\n\n            supertype = superclass.getGenericSuperclass();\n            superclass = superclass.getSuperclass();\n        }\n        return ReflectionUtils.EMPTY_CLASS_ARRAY;\n    }", "category": "Python"}, {"instruction": "Creates a projection list that removes given columns.\n\n<p><b>NOTE:</b> Resulting expression are still unresolved.\n\n@param inputFields names of current columns\n@param dropExpressions columns to remove\n@return projection expressions", "input": "Java", "output": "public static List<Expression> dropFields(List<String> inputFields, List<Expression> dropExpressions) {\n\t\tSet<String> columnsToDrop = dropExpressions.stream()\n\t\t\t.map(expr -> expr.accept(dropColumnsExtractor))\n\t\t\t.collect(Collectors.toSet());\n\n\t\tcolumnsToDrop.forEach(c -> {\n\t\t\tif (!inputFields.contains(c)) {\n\t\t\t\tthrow new ValidationException(format(\"Field %s does not exist in source table\", c));\n\t\t\t}\n\t\t});\n\n\t\treturn inputFields.stream()\n\t\t\t.filter(oldName -> !columnsToDrop.contains(oldName))\n\t\t\t.map(UnresolvedReferenceExpression::new)\n\t\t\t.collect(Collectors.toList());\n\t}", "category": "Python"}, {"instruction": "Extracts Zipkin metrics to provide backward compatibility", "input": "Java", "output": "@Get(\"/metrics\")\n  @ProducesJson\n  public ObjectNode fetchMetricsFromMicrometer() {\n    ObjectNode metricsJson = factory.objectNode();\n    // Get the Zipkin Custom meters for constructing the Metrics endpoint\n    for (Meter meter : meterRegistry.getMeters()) {\n      String name = meter.getId().getName();\n      if (!name.startsWith(\"zipkin_collector\")) continue;\n      String transport = meter.getId().getTag(\"transport\");\n      if (transport == null) continue;\n      switch (meter.getId().getType()) {\n        case COUNTER:\n          metricsJson.put(\"counter.\" + name + \".\" + transport,\n            ((Counter) meter).count());\n          continue;\n        case GAUGE:\n          metricsJson.put(\"gauge.\" + name + \".\" + transport,\n            ((Gauge) meter).value());\n      }\n    }\n    return metricsJson;\n  }", "category": "Python"}, {"instruction": "The column size for this type.\nFor numeric data this is the maximum precision.\nFor character data this is the length in characters.\nFor datetime types this is the length in characters of the String representation\n(assuming the maximum allowed precision of the fractional seconds component).\nFor binary data this is the length in bytes.\nNull is returned for data types where the column size is not applicable.", "input": "Java", "output": "public Integer getColumnSize() {\n    if (type.isNumericType()) {\n      return getPrecision();\n    }\n    switch (type) {\n    case STRING_TYPE:\n    case BINARY_TYPE:\n      return Integer.MAX_VALUE;\n    case CHAR_TYPE:\n    case VARCHAR_TYPE:\n      return typeQualifiers.getCharacterMaximumLength();\n    case DATE_TYPE:\n      return 10;\n    case TIMESTAMP_TYPE:\n      return 29;\n    default:\n      return null;\n    }\n  }", "category": "Python"}, {"instruction": "\u5904\u7406PlainSelect\u7c7b\u578b\u7684selectBody\n\n@param plainSelect", "input": "Java", "output": "public void processPlainSelect(PlainSelect plainSelect) {\n        if (!orderByHashParameters(plainSelect.getOrderByElements())) {\n            plainSelect.setOrderByElements(null);\n        }\n        if (plainSelect.getFromItem() != null) {\n            processFromItem(plainSelect.getFromItem());\n        }\n        if (plainSelect.getJoins() != null && plainSelect.getJoins().size() > 0) {\n            List<Join> joins = plainSelect.getJoins();\n            for (Join join : joins) {\n                if (join.getRightItem() != null) {\n                    processFromItem(join.getRightItem());\n                }\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Generates the files for the documents relation. The entries apply the\nfollowing format: <br />\n<code>URL | Content</code>\n\n@param noDocs\nNumber of entries for the documents relation\n@param filterKeyWords\nA list of keywords that should be contained\n@param words\nA list of words to fill the entries\n@param path\nOutput path for the documents relation", "input": "Java", "output": "private static void genDocs(int noDocs, String[] filterKeyWords, String[] words, String path) {\n\n\t\tRandom rand = new Random(Calendar.getInstance().getTimeInMillis());\n\n\t\ttry (BufferedWriter fw = new BufferedWriter(new FileWriter(path))) {\n\t\t\tfor (int i = 0; i < noDocs; i++) {\n\n\t\t\t\tint wordsInDoc = rand.nextInt(40) + 10;\n\t\t\t\t// URL\n\t\t\t\tStringBuilder doc = new StringBuilder(\"url_\" + i + \"|\");\n\t\t\t\tfor (int j = 0; j < wordsInDoc; j++) {\n\t\t\t\t\tif (rand.nextDouble() > 0.9) {\n\t\t\t\t\t\t// Approx. every 10th word is a keyword\n\t\t\t\t\t\tdoc.append(filterKeyWords[rand.nextInt(filterKeyWords.length)] + \" \");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Fills up the docs file(s) with random words\n\t\t\t\t\t\tdoc.append(words[rand.nextInt(words.length)] + \" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdoc.append(\"|\\n\");\n\n\t\t\t\tfw.write(doc.toString());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Specifies the weigher to use in determining the weight of entries. Entry weight is taken into\nconsideration by {@link #maximumWeight(long)} when determining which entries to evict, and use\nof this method requires a corresponding call to {@link #maximumWeight(long)} prior to calling\n{@link #build}. Weights are measured and recorded when entries are inserted into or updated in\nthe cache, and are thus effectively static during the lifetime of a cache entry.\n<p>\nWhen the weight of an entry is zero it will not be considered for size-based eviction (though\nit still may be evicted by other means).\n<p>\n<b>Important note:</b> Instead of returning <em>this</em> as a {@code Caffeine} instance, this\nmethod returns {@code Caffeine<K1, V1>}. From this point on, either the original reference or\nthe returned reference may be used to complete configuration and build the cache, but only the\n\"generic\" one is type-safe. That is, it will properly prevent you from building caches whose\nkey or value types are incompatible with the types accepted by the weigher already provided;\nthe {@code Caffeine} type cannot do this. For best results, simply use the standard\nmethod-chaining idiom, as illustrated in the documentation at top, configuring a\n{@code Caffeine} and building your {@link Cache} all in a single statement.\n<p>\n<b>Warning:</b> if you ignore the above advice, and use this {@code Caffeine} to build a cache\nwhose key or value type is incompatible with the weigher, you will likely experience a\n{@link ClassCastException} at some <i>undefined</i> point in the future.\n\n@param weigher the weigher to use in calculating the weight of cache entries\n@param <K1> key type of the weigher\n@param <V1> value type of the weigher\n@return the cache builder reference that should be used instead of {@code this} for any\nremaining configuration and cache building\n@throws IllegalStateException if a weigher was already set", "input": "Java", "output": "@NonNull\n  public <K1 extends K, V1 extends V> Caffeine<K1, V1> weigher(\n      @NonNull Weigher<? super K1, ? super V1> weigher) {\n    requireNonNull(weigher);\n    requireState(this.weigher == null, \"weigher was already set to %s\", this.weigher);\n    requireState(!strictParsing || this.maximumSize == UNSET_INT,\n        \"weigher can not be combined with maximum size\", this.maximumSize);\n\n    @SuppressWarnings(\"unchecked\")\n    Caffeine<K1, V1> self = (Caffeine<K1, V1>) this;\n    self.weigher = weigher;\n    return self;\n  }", "category": "Python"}, {"instruction": "\u62f7\u8d1d\u6d41\n\n@param in \u8f93\u5165\u6d41\n@param out \u8f93\u51fa\u6d41\n@param bufferSize \u7f13\u5b58\u5927\u5c0f\n@param streamProgress \u8fdb\u5ea6\u6761\n@return \u4f20\u8f93\u7684byte\u6570\n@throws IORuntimeException IO\u5f02\u5e38", "input": "Java", "output": "public static long copy(InputStream in, OutputStream out, int bufferSize, StreamProgress streamProgress) throws IORuntimeException {\r\n\t\tAssert.notNull(in, \"InputStream is null !\");\r\n\t\tAssert.notNull(out, \"OutputStream is null !\");\r\n\t\tif (bufferSize <= 0) {\r\n\t\t\tbufferSize = DEFAULT_BUFFER_SIZE;\r\n\t\t}\r\n\r\n\t\tbyte[] buffer = new byte[bufferSize];\r\n\t\tif (null != streamProgress) {\r\n\t\t\tstreamProgress.start();\r\n\t\t}\r\n\t\tlong size = 0;\r\n\t\ttry {\r\n\t\t\tfor (int readSize = -1; (readSize = in.read(buffer)) != EOF;) {\r\n\t\t\t\tout.write(buffer, 0, readSize);\r\n\t\t\t\tsize += readSize;\r\n\t\t\t\tout.flush();\r\n\t\t\t\tif (null != streamProgress) {\r\n\t\t\t\t\tstreamProgress.progress(size);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new IORuntimeException(e);\r\n\t\t}\r\n\t\tif (null != streamProgress) {\r\n\t\t\tstreamProgress.finish();\r\n\t\t}\r\n\t\treturn size;\r\n\t}", "category": "Python"}, {"instruction": "This method must be the only place to call {@link #recoverAndCommit(Object)} to ensure that\nthe configuration parameters {@link #transactionTimeout} and\n{@link #ignoreFailuresAfterTransactionTimeout} are respected.", "input": "Java", "output": "private void recoverAndCommitInternal(TransactionHolder<TXN> transactionHolder) {\n\t\ttry {\n\t\t\tlogWarningIfTimeoutAlmostReached(transactionHolder);\n\t\t\trecoverAndCommit(transactionHolder.handle);\n\t\t} catch (final Exception e) {\n\t\t\tfinal long elapsedTime = clock.millis() - transactionHolder.transactionStartTime;\n\t\t\tif (ignoreFailuresAfterTransactionTimeout && elapsedTime > transactionTimeout) {\n\t\t\t\tLOG.error(\"Error while committing transaction {}. \" +\n\t\t\t\t\t\t\"Transaction has been open for longer than the transaction timeout ({}).\" +\n\t\t\t\t\t\t\"Commit will not be attempted again. Data loss might have occurred.\",\n\t\t\t\t\ttransactionHolder.handle, transactionTimeout, e);\n\t\t\t} else {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Determines whether the given ByteArraySegment represents an Index Page\n\n@param pageContents The ByteArraySegment to check.\n@return True if Index Page, False if Leaf page.\n@throws IllegalDataFormatException If the given contents is not a valid BTreePage format.", "input": "Java", "output": "static boolean isIndexPage(@NonNull ByteArraySegment pageContents) {\n        // Check ID match.\n        int headerId = BitConverter.readInt(pageContents, ID_OFFSET);\n        int footerId = BitConverter.readInt(pageContents, pageContents.getLength() - FOOTER_LENGTH);\n        if (headerId != footerId) {\n            throw new IllegalDataFormatException(\"Invalid Page Format (id mismatch). HeaderId=%s, FooterId=%s.\", headerId, footerId);\n        }\n\n        int flags = pageContents.get(FLAGS_OFFSET);\n        return (flags & FLAG_INDEX_PAGE) == FLAG_INDEX_PAGE;\n    }", "category": "Python"}, {"instruction": "Should encrypt token for service?\n\n@param svc the svc\n@return the boolean", "input": "Java", "output": "@Override\n    protected boolean shouldEncryptTokenFor(final OidcRegisteredService svc) {\n        if (AlgorithmIdentifiers.NONE.equalsIgnoreCase(svc.getIdTokenEncryptionAlg())) {\n            LOGGER.warn(\"ID token encryption algorithm is set to none for [{}] and ID token will not be encrypted\", svc.getServiceId());\n            return false;\n        }\n        return svc.isEncryptIdToken() && StringUtils.isNotBlank(svc.getIdTokenEncryptionAlg()) && StringUtils.isNotBlank(svc.getIdTokenEncryptionEncoding());\n    }", "category": "Python"}, {"instruction": "This method adds specified SequenceElement to vocabulary\n\n@param element the word to add", "input": "Java", "output": "@Override\n    public boolean addToken(T element) {\n        boolean ret = false;\n        T oldElement = vocabulary.putIfAbsent(element.getStorageId(), element);\n        if (oldElement == null) {\n            //putIfAbsent added our element\n            if (element.getLabel() != null) {\n                extendedVocabulary.put(element.getLabel(), element);\n            }\n            oldElement = element;\n            ret = true;\n        } else {\n            oldElement.incrementSequencesCount(element.getSequencesCount());\n            oldElement.increaseElementFrequency((int) element.getElementFrequency());\n        }\n        totalWordCount.addAndGet((long) oldElement.getElementFrequency());\n        return ret;\n    }", "category": "Python"}, {"instruction": "Sets the maintenance policy for a cluster.\n\n<p>Sample code:\n\n<pre><code>\ntry (ClusterManagerClient clusterManagerClient = ClusterManagerClient.create()) {\nString projectId = \"\";\nString zone = \"\";\nString clusterId = \"\";\nMaintenancePolicy maintenancePolicy = MaintenancePolicy.newBuilder().build();\nOperation response = clusterManagerClient.setMaintenancePolicy(projectId, zone, clusterId, maintenancePolicy);\n}\n</code></pre>\n\n@param projectId The Google Developers Console [project ID or project\nnumber](https://support.google.com/cloud/answer/6158840).\n@param zone The name of the Google Compute Engine [zone](/compute/docs/zones#available) in\nwhich the cluster resides.\n@param clusterId The name of the cluster to update.\n@param maintenancePolicy The maintenance policy to be set for the cluster. An empty field\nclears the existing maintenance policy.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "public final Operation setMaintenancePolicy(\n      String projectId, String zone, String clusterId, MaintenancePolicy maintenancePolicy) {\n\n    SetMaintenancePolicyRequest request =\n        SetMaintenancePolicyRequest.newBuilder()\n            .setProjectId(projectId)\n            .setZone(zone)\n            .setClusterId(clusterId)\n            .setMaintenancePolicy(maintenancePolicy)\n            .build();\n    return setMaintenancePolicy(request);\n  }", "category": "Python"}, {"instruction": "Returns true if a given context should be invoked.", "input": "Java", "output": "public boolean shouldInvoke(C context) {\n    cleanupExpiredSuppressions();\n\n    if (cache.containsKey(context)) return false;\n\n    Suppression<C> suppression = new Suppression<>(ticker, context, ticker.read() + ttlNanos);\n\n    if (cache.putIfAbsent(context, suppression) != null) return false; // lost race\n\n    suppressions.offer(suppression);\n\n    // If we added an entry, it could make us go over the max size.\n    if (suppressions.size() > cardinality) removeOneSuppression();\n\n    return true;\n  }", "category": "Python"}, {"instruction": "This will encode the random metadata fields, and repeatedly lookup the default other headers.", "input": "Java", "output": "@Benchmark\n  @BenchmarkMode(Mode.SampleTime)\n  @OutputTimeUnit(TimeUnit.NANOSECONDS)\n  public ByteBuf encodeClientHeaders() throws Exception {\n    scratchBuffer.clear();\n    Http2Headers headers =\n        Utils.convertClientHeaders(metadata, scheme, defaultPath, authority, Utils.HTTP_METHOD,\n            userAgent);\n    headersEncoder.encodeHeaders(1, headers, scratchBuffer);\n    return scratchBuffer;\n  }", "category": "Python"}, {"instruction": "Create an SDVariable with a fixed/constant value<br>\nConstants are not modified by training/backprop. See {@link VariableType} for more details.\n@param name  Name of the constant SDVariable\n@param constant Value for the constant SDVariable\n@return The created variable", "input": "Java", "output": "public SDVariable constant(String name, @NonNull INDArray constant){\n        Preconditions.checkState(!variables.containsKey(name), \"Variable with name \\\"%s\\\" already exists\", name);\n        if (name == null || name.length() < 1)\n            name = getNewVarName();\n        SDVariable v = new SDVariable(name, VariableType.CONSTANT, this, constant.shape(), constant.dataType(), null);\n        variables.put(name, Variable.builder().name(name).variable(v).build());\n        constantArrays.put(name, new DeviceLocalNDArray(constant));\n        return v;\n    }", "category": "Python"}, {"instruction": "Keep the algorithm consistent with Calcite DateTimeUtils.julianDateFloor, but here\nwe take time zone into account.", "input": "Java", "output": "public static long timestampCeil(TimeUnitRange range, long ts, TimeZone tz) {\n\t\t// assume that we are at UTC timezone, just for algorithm performance\n\t\tlong offset = tz.getOffset(ts);\n\t\tlong utcTs = ts + offset;\n\n\t\tswitch (range) {\n\t\t\tcase HOUR:\n\t\t\t\treturn ceil(utcTs, MILLIS_PER_HOUR) - offset;\n\t\t\tcase DAY:\n\t\t\t\treturn ceil(utcTs, MILLIS_PER_DAY) - offset;\n\t\t\tcase MONTH:\n\t\t\tcase YEAR:\n\t\t\tcase QUARTER:\n\t\t\t\tint days = (int) (utcTs / MILLIS_PER_DAY + EPOCH_JULIAN);\n\t\t\t\treturn julianDateFloor(range, days, false) * MILLIS_PER_DAY - offset;\n\t\t\tdefault:\n\t\t\t\t// for MINUTE and SECONDS etc...,\n\t\t\t\t// it is more effective to use arithmetic Method\n\t\t\t\tthrow new AssertionError(range);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Load a custom class, which is provided by a configuration CUSTOM_JMX_ATTRIBUTE_PROCESSOR_PROPERTY.\n\nThis method will try to instantiate an instance of this custom class and with given properties\nas the argument in the constructor.\n\nBasically the custom class must have a constructor that takes an argument with type\nProperties.", "input": "Java", "output": "private void loadCustomJMXAttributeProcessor(final Props props) {\n    final String jmxAttributeEmitter =\n        props.get(CUSTOM_JMX_ATTRIBUTE_PROCESSOR_PROPERTY);\n    if (jmxAttributeEmitter != null) {\n      try {\n        logger.info(\"jmxAttributeEmitter: \" + jmxAttributeEmitter);\n        final Constructor<Props>[] constructors =\n            (Constructor<Props>[]) Class.forName(jmxAttributeEmitter).getConstructors();\n\n        constructors[0].newInstance(props.toProperties());\n      } catch (final Exception e) {\n        logger.error(\"Encountered error while loading and instantiating \"\n            + jmxAttributeEmitter, e);\n        throw new IllegalStateException(\n            \"Encountered error while loading and instantiating \"\n                + jmxAttributeEmitter, e);\n      }\n    } else {\n      logger.info(\"No value for property: \"\n          + CUSTOM_JMX_ATTRIBUTE_PROCESSOR_PROPERTY + \" was found\");\n    }\n  }", "category": "Python"}, {"instruction": "and patches .resolve() on LocalDeclaration itself to just-in-time replace the 'val' vartype with the right one.", "input": "Java", "output": "public static TypeBinding skipResolveInitializerIfAlreadyCalled(Expression expr, BlockScope scope) {\n\t\tif (expr.resolvedType != null) return expr.resolvedType;\n\t\ttry {\n\t\t\treturn expr.resolveType(scope);\n\t\t} catch (NullPointerException e) {\n\t\t\treturn null;\n\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t// This will occur internally due to for example 'val x = mth(\"X\");', where mth takes 2 arguments.\n\t\t\treturn null;\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Get the output size of a deconvolution operation for given input data. In deconvolution, we compute the inverse\nof the shape computation of a convolution.\n\n@param inputData       Input data\n@param kernel          Kernel size (height/width)\n@param strides         Strides (height/width)\n@param padding         Padding (height/width)\n@param convolutionMode Convolution mode (Same, Strict, Truncate)\n@param dilation        Kernel dilation (height/width)\n@return Output size: int[2] with output height/width", "input": "Java", "output": "public static int[] getDeconvolutionOutputSize(INDArray inputData, int[] kernel, int[] strides, int[] padding,\n                                                   ConvolutionMode convolutionMode, int[] dilation) {\n\n        // FIXME: int cast\n        int hIn = (int) inputData.size(2);\n        int wIn = (int) inputData.size(3);\n        int[] eKernel = effectiveKernelSize(kernel, dilation);\n\n        if (convolutionMode == ConvolutionMode.Same) {\n            int hOut = strides[0] * hIn;\n            int wOut = strides[1] * wIn;\n            return new int[]{hOut, wOut};\n        }\n\n        int hOut = strides[0] * (hIn - 1) + eKernel[0] - 2 * padding[0];\n        int wOut = strides[1] * (wIn - 1) + eKernel[1] - 2 * padding[1];\n\n        return new int[]{hOut, wOut};\n    }", "category": "Python"}, {"instruction": "Indicates that any modifications to the given PageWrapper have completed.\n\n@param page The PageWrapper that has been completed. This instance's offset will be adjusted to the current value\nof getIndexLength(), and the stored index length will be incremented by this PageWrapper's length.", "input": "Java", "output": "synchronized void complete(PageWrapper page) {\n        Preconditions.checkArgument(this.pageByOffset.containsKey(page.getOffset()), \"Given page is not registered.\");\n        Preconditions.checkArgument(this.incompleteNewPageOffset == PagePointer.NO_OFFSET || this.incompleteNewPageOffset == page.getOffset(),\n                \"Not expecting this page to be completed.\");\n\n        this.incompleteNewPageOffset = PagePointer.NO_OFFSET;\n        long pageOffset = this.indexLength;\n        this.indexLength += page.getPage().getLength();\n\n        this.pageByOffset.remove(page.getOffset());\n        page.setOffset(pageOffset);\n        this.pageByOffset.put(page.getOffset(), page);\n    }", "category": "Python"}, {"instruction": "\u83b7\u53d6\u6570\u5b57\u7c7b\u578b\u7684\u5355\u5143\u683c\u503c\n\n@param cell \u5355\u5143\u683c\n@return \u5355\u5143\u683c\u503c\uff0c\u53ef\u80fd\u4e3aLong\u3001Double\u3001Date", "input": "Java", "output": "private static Object getNumericValue(Cell cell) {\r\n\t\tfinal double value = cell.getNumericCellValue();\r\n\r\n\t\tfinal CellStyle style = cell.getCellStyle();\r\n\t\tif (null == style) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfinal short formatIndex = style.getDataFormat();\r\n\t\t// \u5224\u65ad\u662f\u5426\u4e3a\u65e5\u671f\r\n\t\tif (isDateType(cell, formatIndex)) {\r\n\t\t\treturn DateUtil.date(cell.getDateCellValue());// \u4f7f\u7528Hutool\u7684DateTime\u5305\u88c5\r\n\t\t}\r\n\r\n\t\tfinal String format = style.getDataFormatString();\r\n\t\t// \u666e\u901a\u6570\u5b57\r\n\t\tif (null != format && format.indexOf(StrUtil.C_DOT) < 0) {\r\n\t\t\tfinal long longPart = (long) value;\r\n\t\t\tif (longPart == value) {\r\n\t\t\t\t// \u5bf9\u4e8e\u65e0\u5c0f\u6570\u90e8\u5206\u7684\u6570\u5b57\u7c7b\u578b\uff0c\u8f6c\u4e3aLong\r\n\t\t\t\treturn longPart;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn value;\r\n\t}", "category": "Python"}, {"instruction": "Initialize field if not initialized and return the actual instance.\n\n@return Actual field instance.", "input": "Java", "output": "public FieldInitializationReport initialize() {\n        final AccessibilityChanger changer = new AccessibilityChanger();\n        changer.enableAccess(field);\n\n        try {\n            return acquireFieldInstance();\n        } catch(IllegalAccessException e) {\n            throw new MockitoException(\"Problems initializing field '\" + field.getName() + \"' of type '\" + field.getType().getSimpleName() + \"'\", e);\n        } finally {\n            changer.safelyDisableAccess(field);\n        }\n    }", "category": "Python"}, {"instruction": "{@inheritDoc}.\n\nNote that the look up is case-insensitive.", "input": "Java", "output": "@Override public TopLevelItem getItem(String name) throws AccessDeniedException {\n        if (name==null)    return null;\n        TopLevelItem item = items.get(name);\n        if (item==null)\n            return null;\n        if (!item.hasPermission(Item.READ)) {\n            if (item.hasPermission(Item.DISCOVER)) {\n                throw new AccessDeniedException(\"Please login to access job \" + name);\n            }\n            return null;\n        }\n        return item;\n    }", "category": "Python"}, {"instruction": "Return the number of correct predictions according to top N value. For top N = 1 (default) this is equivalent to\nthe number of correct predictions\n@return Number of correct top N predictions", "input": "Java", "output": "public int getTopNCorrectCount() {\n        if (confusion == null)\n            return 0;\n        if (topN <= 1) {\n            int nClasses = confusion().getClasses().size();\n            int countCorrect = 0;\n            for (int i = 0; i < nClasses; i++) {\n                countCorrect += confusion().getCount(i, i);\n            }\n            return countCorrect;\n        }\n        return topNCorrectCount;\n    }", "category": "Python"}, {"instruction": "Set a header name and value. If the name is not found, it will be added.\nIf the value is null, the header will be removed.\n\n@param name\n@param value", "input": "Java", "output": "public void setHeader(String name, String value) {\r\n//\t\tint pos = 0;\r\n//\t\tint crlfpos = 0;\r\n        Pattern pattern = null;\r\n\r\n        if (getHeaders(name) == null && value != null) {\r\n            // header value not found, append to end\r\n            addHeader(name, value);\r\n        } else {\r\n            pattern = getHeaderRegex(name);\r\n            Matcher matcher = pattern.matcher(mMsgHeader);\r\n            if (value == null) {\r\n                // delete header\r\n                mMsgHeader = matcher.replaceAll(\"\");\r\n            } else {\r\n                // replace header\r\n                String newString = name + \": \" + value + mLineDelimiter;\r\n                mMsgHeader = matcher.replaceAll(Matcher.quoteReplacement(newString));\r\n            }\r\n\r\n            // set into hashtable\r\n            replaceInternalHeaderFields(name, value);\r\n        }\r\n    }", "category": "Python"}, {"instruction": "\u7528\u4e8eModel\u5bf9\u8c61\u8f6c\u5316\u4e3aDO\u5bf9\u8c61", "input": "Java", "output": "private DataMatrixDO modelToDo(DataMatrix matrix) {\n        DataMatrixDO matrixDo = new DataMatrixDO();\n        try {\n            matrixDo.setId(matrix.getId());\n            matrixDo.setGroupKey(matrix.getGroupKey());\n            matrixDo.setDescription(matrix.getDescription());\n            matrixDo.setMaster(matrix.getMaster());\n            matrixDo.setSlave(matrix.getSlave());\n            matrixDo.setGmtCreate(matrix.getGmtCreate());\n            matrixDo.setGmtModified(matrix.getGmtModified());\n        } catch (Exception e) {\n            logger.error(\"ERROR ## change the matrix Model to Do has an exception\");\n            throw new ManagerException(e);\n        }\n        return matrixDo;\n    }", "category": "Python"}, {"instruction": "def mmf(x, alpha, beta, kappa, delta):\n    \"\"\"Morgan-Mercer-Flodin\n    http://www.pisces-conservation.com/growthhelp/index.html?morgan_mercer_floden.htm\n\n    Parameters\n    ----------\n    x: int\n    alpha: float\n    beta: float\n    kappa: float\n    delta: float\n\n    Returns\n    -------\n    float\n        alpha - (alpha - beta) / (1. + (kappa * x)**delta)\n    \"\"\"\n", "input": "", "output": "    return alpha - (alpha - beta) / (1. + (kappa * x)**delta)", "category": "Python"}, {"instruction": "Returns a new initialized {@link OpenSslX509KeyManagerFactory} which will provide its private key by using the\n{@link OpenSslPrivateKeyMethod}.", "input": "Java", "output": "public static OpenSslX509KeyManagerFactory newKeyless(X509Certificate... certificateChain)\n            throws CertificateException, IOException,\n            KeyStoreException, NoSuchAlgorithmException, UnrecoverableKeyException {\n        KeyStore store = new OpenSslKeyStore(certificateChain.clone(), true);\n        store.load(null, null);\n        OpenSslX509KeyManagerFactory factory = new OpenSslX509KeyManagerFactory();\n        factory.init(store, null);\n        return factory;\n    }", "category": "Python"}, {"instruction": "Updates all the process definition entities to have the correct diagram resource name.  Must\nbe called after createAndPersistNewDiagramsAsNeeded to ensure that any newly-created diagrams\nalready have their resources attached to the deployment.", "input": "Java", "output": "protected void setProcessDefinitionDiagramNames(ParsedDeployment parsedDeployment) {\n        Map<String, ResourceEntity> resources = parsedDeployment.getDeployment().getResources();\n\n        for (ProcessDefinitionEntity processDefinition : parsedDeployment.getAllProcessDefinitions()) {\n            String diagramResourceName = ResourceNameUtil.getProcessDiagramResourceNameFromDeployment(processDefinition,\n                                                                                                      resources);\n            processDefinition.setDiagramResourceName(diagramResourceName);\n        }\n    }", "category": "Python"}, {"instruction": "Build the ticket properties.\n\n@param webContext the web context\n@return the ticket properties", "input": "Java", "output": "protected Map<String, Serializable> buildTicketProperties(final J2EContext webContext) {\n        val properties = new HashMap<String, Serializable>();\n\n        val themeParamName = casProperties.getTheme().getParamName();\n        val localParamName = casProperties.getLocale().getParamName();\n\n        properties.put(themeParamName, StringUtils.defaultString(webContext.getRequestParameter(themeParamName)));\n        properties.put(localParamName, StringUtils.defaultString(webContext.getRequestParameter(localParamName)));\n        properties.put(CasProtocolConstants.PARAMETER_METHOD,\n            StringUtils.defaultString(webContext.getRequestParameter(CasProtocolConstants.PARAMETER_METHOD)));\n\n        return properties;\n    }", "category": "Python"}, {"instruction": "Only for debugging.\nPrints local timeline to stdout.\n\nTo be used in case of an error when global timeline can not be relied upon as we might not be able to talk to other nodes.", "input": "Java", "output": "static void printMyTimeLine(){\n    long [] s = TimeLine.snapshot();\n    System.err.println(\"===================================<TIMELINE>==============================================\");\n    for(int i = 0; i < TimeLine.length(); ++i) {\n      long lo = TimeLine.l0(s, i),hi = TimeLine.l8(s, i);\n      int port = (int)((lo >> 8) & 0xFFFF);\n      String op = TimeLine.send_recv(s,i) == 0?\"SEND\":\"RECV\";\n      if(!TimeLine.isEmpty(s, i) && (lo & 0xFF) == UDP.udp.exec.ordinal())\n        System.err.println(TimeLine.ms(s, i) + \": \" + op + \" \" + (((TimeLine.ns(s, i) & 4) != 0)?\"TCP\":\"UDP\")  +  TimeLine.inet(s, i) + \":\" + port + \" | \" + UDP.printx16(lo, hi));\n    }\n    System.err.println(\"===========================================================================================\");\n  }", "category": "Python"}, {"instruction": "Create a new read only representation of headers used by servers.\n@param validateHeaders {@code true} will run validation on each header name/value pair to ensure protocol\ncompliance.\n@param status The value for {@link PseudoHeaderName#STATUS}.\n@param otherHeaders A an array of key:value pairs. Must not contain any\n<a href=\"https://tools.ietf.org/html/rfc7540#section-8.1.2.1\">pseudo headers</a>\nor {@code null} names/values.\nA copy will <strong>NOT</strong> be made of this array. If the contents of this array\nmay be modified externally you are responsible for passing in a copy.\n@return a new read only representation of headers used by servers.", "input": "Java", "output": "public static ReadOnlyHttp2Headers serverHeaders(boolean validateHeaders,\n                                                     AsciiString status,\n                                                     AsciiString... otherHeaders) {\n        return new ReadOnlyHttp2Headers(validateHeaders,\n                                        new AsciiString[] { PseudoHeaderName.STATUS.value(), status },\n                                        otherHeaders);\n    }", "category": "Python"}, {"instruction": "Updates an instance's network interface. This method follows PATCH semantics.\n\n<p>Sample code:\n\n<pre><code>\ntry (InstanceClient instanceClient = InstanceClient.create()) {\nProjectZoneInstanceName instance = ProjectZoneInstanceName.of(\"[PROJECT]\", \"[ZONE]\", \"[INSTANCE]\");\nString networkInterface = \"\";\nNetworkInterface networkInterfaceResource = NetworkInterface.newBuilder().build();\nList&lt;String&gt; fieldMask = new ArrayList&lt;&gt;();\nOperation response = instanceClient.updateNetworkInterfaceInstance(instance, networkInterface, networkInterfaceResource, fieldMask);\n}\n</code></pre>\n\n@param instance The instance name for this request.\n@param networkInterface The name of the network interface to update.\n@param networkInterfaceResource A network interface resource attached to an instance.\n@param fieldMask The fields that should be serialized (even if they have empty values). If the\ncontaining message object has a non-null fieldmask, then all the fields in the field mask\n(and only those fields in the field mask) will be serialized. If the containing object does\nnot have a fieldmask, then only non-empty fields will be serialized.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation updateNetworkInterfaceInstance(\n      ProjectZoneInstanceName instance,\n      String networkInterface,\n      NetworkInterface networkInterfaceResource,\n      List<String> fieldMask) {\n\n    UpdateNetworkInterfaceInstanceHttpRequest request =\n        UpdateNetworkInterfaceInstanceHttpRequest.newBuilder()\n            .setInstance(instance == null ? null : instance.toString())\n            .setNetworkInterface(networkInterface)\n            .setNetworkInterfaceResource(networkInterfaceResource)\n            .addAllFieldMask(fieldMask)\n            .build();\n    return updateNetworkInterfaceInstance(request);\n  }", "category": "Python"}, {"instruction": "Normalize by zero mean unit variance\n\n@param frame the data to normalize\n@return a zero mean unit variance centered\nrdd", "input": "Java", "output": "public static DataRowsFacade zeromeanUnitVariance(DataRowsFacade frame, List<String> skipColumns) {\n        List<String> columnsList = DataFrames.toList(frame.get().columns());\n        columnsList.removeAll(skipColumns);\n        String[] columnNames = DataFrames.toArray(columnsList);\n        //first row is std second row is mean, each column in a row is for a particular column\n        List<Row> stdDevMean = stdDevMeanColumns(frame, columnNames);\n        for (int i = 0; i < columnNames.length; i++) {\n            String columnName = columnNames[i];\n            double std = ((Number) stdDevMean.get(0).get(i)).doubleValue();\n            double mean = ((Number) stdDevMean.get(1).get(i)).doubleValue();\n            if (std == 0.0)\n                std = 1; //All same value -> (x-x)/1 = 0\n\n            frame = dataRows(frame.get().withColumn(columnName, frame.get().col(columnName).minus(mean).divide(std)));\n        }\n\n\n\n        return frame;\n    }", "category": "Python"}, {"instruction": "Shuts down the checkpoint coordinator.\n\n<p>After this method has been called, the coordinator does not accept\nand further messages and cannot trigger any further checkpoints.", "input": "Java", "output": "public void shutdown(JobStatus jobStatus) throws Exception {\n\t\tsynchronized (lock) {\n\t\t\tif (!shutdown) {\n\t\t\t\tshutdown = true;\n\t\t\t\tLOG.info(\"Stopping checkpoint coordinator for job {}.\", job);\n\n\t\t\t\tperiodicScheduling = false;\n\t\t\t\ttriggerRequestQueued = false;\n\n\t\t\t\t// shut down the hooks\n\t\t\t\tMasterHooks.close(masterHooks.values(), LOG);\n\t\t\t\tmasterHooks.clear();\n\n\t\t\t\t// shut down the thread that handles the timeouts and pending triggers\n\t\t\t\ttimer.shutdownNow();\n\n\t\t\t\t// clear and discard all pending checkpoints\n\t\t\t\tfor (PendingCheckpoint pending : pendingCheckpoints.values()) {\n\t\t\t\t\tpending.abort(CheckpointFailureReason.CHECKPOINT_COORDINATOR_SHUTDOWN);\n\t\t\t\t}\n\t\t\t\tpendingCheckpoints.clear();\n\n\t\t\t\tcompletedCheckpointStore.shutdown(jobStatus);\n\t\t\t\tcheckpointIdCounter.shutdown(jobStatus);\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Create default global exception handlers.\n\n@param flow the flow", "input": "Java", "output": "protected void createDefaultEndStates(final Flow flow) {\n        createRedirectUnauthorizedServiceUrlEndState(flow);\n        createServiceErrorEndState(flow);\n        createRedirectEndState(flow);\n        createPostEndState(flow);\n        createInjectHeadersActionState(flow);\n        createGenericLoginSuccessEndState(flow);\n        createServiceWarningViewState(flow);\n        createEndWebflowEndState(flow);\n    }", "category": "Python"}, {"instruction": "Returns the index within this string of the first occurrence of the\nspecified substring. If it is not a substring, return -1.\n\n@param content the content where we've to search into\n@return the index of the occurrence or -1 if no occurrence has been found", "input": "Java", "output": "public int findInContent(String content) {\r\n        int n = content.length();\r\n        int m = pattern.length();\r\n        int skip;\r\n        char val;\r\n\r\n        for (int i = 0; i <= n - m; i = i + skip) {\r\n            skip = 0;\r\n            for (int j = m - 1; j >= 0; j--) {\r\n                if (pattern.charAt(j) != content.charAt(i + j)) {\r\n                    val = content.charAt(i + j);\r\n\r\n                    skip = (occurrence.get(val) != null) ?\r\n                            Math.max(1, j - occurrence.get(val)) :\r\n                            j + 1;\r\n\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (skip == 0) {\r\n                return i;\r\n            }\r\n        }\r\n        \r\n        return -1;\r\n    }", "category": "Python"}, {"instruction": "Read some bytes from the stream.\n@param b The byte array that will hold the contents from the stream.\n@param off The offset into the byte array at which bytes will start to be\nplaced.\n@param len the maximum number of bytes that can be returned.\n@return The number of bytes returned or -1 if the end of stream has been\nreached.\n@see java.io.InputStream#read(byte[], int, int)\n@throws IOException if an IO problem occurs.", "input": "Java", "output": "@Override\n    public int read (byte[] b, int off, int len) throws IOException {\n\n        if (closed) {\n            throw new IOException(\"Attempted read from closed stream.\");\n        }\n\n        if (eof) {\n            return -1;\n        }\n        if (pos >= chunkSize) {\n            nextChunk();\n            if (eof) {\n                return -1;\n            }\n        }\n        len = Math.min(len, chunkSize - pos);\n        int count = in.read(b, off, len);\n        pos += count;\n        return count;\n    }", "category": "Python"}, {"instruction": "\u4ececontent\u4e2d\u5339\u914d\u51fa\u591a\u4e2a\u503c\u5e76\u6839\u636etemplate\u751f\u6210\u65b0\u7684\u5b57\u7b26\u4e32<br>\n\u5339\u914d\u7ed3\u675f\u540e\u4f1a\u5220\u9664\u5339\u914d\u5185\u5bb9\u4e4b\u524d\u7684\u5185\u5bb9\uff08\u5305\u62ec\u5339\u914d\u5185\u5bb9\uff09<br>\n\u4f8b\u5982\uff1a<br>\ncontent 2013\u5e745\u6708 pattern (.*?)\u5e74(.*?)\u6708 template\uff1a $1-$2 return 2013-5\n\n@param pattern \u5339\u914d\u6b63\u5219\n@param contentHolder \u88ab\u5339\u914d\u7684\u5185\u5bb9\u7684Holder\uff0cvalue\u4e3a\u5185\u5bb9\u6b63\u6587\uff0c\u7ecf\u8fc7\u8fd9\u4e2a\u65b9\u6cd5\u7684\u539f\u6587\u5c06\u88ab\u53bb\u6389\u5339\u914d\u4e4b\u524d\u7684\u5185\u5bb9\n@param template \u751f\u6210\u5185\u5bb9\u6a21\u677f\uff0c\u53d8\u91cf $1 \u8868\u793agroup1\u7684\u5185\u5bb9\uff0c\u4ee5\u6b64\u7c7b\u63a8\n@return \u65b0\u5b57\u7b26\u4e32", "input": "Java", "output": "public static String extractMultiAndDelPre(Pattern pattern, Holder<CharSequence> contentHolder, String template) {\r\n\t\tif (null == contentHolder || null == pattern || null == template) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tHashSet<String> varNums = findAll(PatternPool.GROUP_VAR, template, 1, new HashSet<String>());\r\n\r\n\t\tfinal CharSequence content = contentHolder.get();\r\n\t\tMatcher matcher = pattern.matcher(content);\r\n\t\tif (matcher.find()) {\r\n\t\t\tfor (String var : varNums) {\r\n\t\t\t\tint group = Integer.parseInt(var);\r\n\t\t\t\ttemplate = template.replace(\"$\" + var, matcher.group(group));\r\n\t\t\t}\r\n\t\t\tcontentHolder.set(StrUtil.sub(content, matcher.end(), content.length()));\r\n\t\t\treturn template;\r\n\t\t}\r\n\t\treturn null;\r\n\t}", "category": "Python"}, {"instruction": "\u52a0\u5bc6\n\n@param data \u6570\u636e\n@param cipherKey \u5bc6\u94a5\n@return \u5bc6\u6587", "input": "Java", "output": "public static String encrypt(CharSequence data, CharSequence cipherKey) {\r\n\t\tfinal int dataLen = data.length();\r\n\t\tfinal int cipherKeyLen = cipherKey.length();\r\n\r\n\t\tfinal char[] cipherArray = new char[dataLen];\r\n\t\tfor (int i = 0; i < dataLen / cipherKeyLen + 1; i++) {\r\n\t\t\tfor (int t = 0; t < cipherKeyLen; t++) {\r\n\t\t\t\tif (t + i * cipherKeyLen < dataLen) {\r\n\t\t\t\t\tfinal char dataChar = data.charAt(t + i * cipherKeyLen);\r\n\t\t\t\t\tfinal char cipherKeyChar = cipherKey.charAt(t);\r\n\t\t\t\t\tcipherArray[t + i * cipherKeyLen] = (char) ((dataChar + cipherKeyChar - 64) % 95 + 32);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn String.valueOf(cipherArray);\r\n\t}", "category": "Python"}, {"instruction": "icon ( or generic html if icon not available )", "input": "Java", "output": "private String getSingleSlotHtml(TestSlot s, String icon) {\n    StringBuilder builder = new StringBuilder();\n    TestSession session = s.getSession();\n    if (icon != null) {\n      builder.append(\"<img \");\n      builder.append(\"src='\").append(icon).append(\"' width='16' height='16'\");\n    } else {\n      builder.append(\"<a href='#' \");\n    }\n\n    if (session != null) {\n      builder.append(\" class='busy' \");\n      builder.append(\" title='\").append(session.get(\"lastCommand\")).append(\"' \");\n    } else {\n      builder.append(\" title='\").append(s.getCapabilities()).append(\"'\");\n    }\n\n    if (icon != null) {\n      builder.append(\" />\\n\");\n    } else {\n      builder.append(\">\");\n      builder.append(s.getCapabilities().get(CapabilityType.BROWSER_NAME));\n      builder.append(\"</a>\");\n    }\n    return builder.toString();\n  }", "category": "Python"}, {"instruction": "This is more advanced and does not make use of the stub.  You should not normally need to do\nthis, but here is how you would.", "input": "Java", "output": "void advancedAsyncCall() {\n    ClientCall<HelloRequest, HelloReply> call =\n        channel.newCall(GreeterGrpc.getSayHelloMethod(), CallOptions.DEFAULT);\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    call.start(new ClientCall.Listener<HelloReply>() {\n\n      @Override\n      public void onClose(Status status, Metadata trailers) {\n        Verify.verify(status.getCode() == Status.Code.INTERNAL);\n        Verify.verify(status.getDescription().contains(\"Narwhal\"));\n        // Cause is not transmitted over the wire.\n        latch.countDown();\n      }\n    }, new Metadata());\n\n    call.sendMessage(HelloRequest.newBuilder().setName(\"Marge\").build());\n    call.halfClose();\n\n    if (!Uninterruptibles.awaitUninterruptibly(latch, 1, TimeUnit.SECONDS)) {\n      throw new RuntimeException(\"timeout!\");\n    }\n  }", "category": "Python"}, {"instruction": "Sends the response headers to the client.", "input": "Java", "output": "private void sendResponseHeaders(ChannelHandlerContext ctx, SendResponseHeadersCommand cmd,\n      ChannelPromise promise) throws Http2Exception {\n    // TODO(carl-mastrangelo): remove this check once https://github.com/netty/netty/issues/6296 is\n    // fixed.\n    int streamId = cmd.stream().id();\n    Http2Stream stream = connection().stream(streamId);\n    if (stream == null) {\n      resetStream(ctx, streamId, Http2Error.CANCEL.code(), promise);\n      return;\n    }\n    if (cmd.endOfStream()) {\n      closeStreamWhenDone(promise, streamId);\n    }\n    encoder().writeHeaders(ctx, streamId, cmd.headers(), 0, cmd.endOfStream(), promise);\n  }", "category": "Python"}, {"instruction": "Schedules or updates the consumer tasks of the result partition with the given ID.", "input": "Java", "output": "void scheduleOrUpdateConsumers(ResultPartitionID partitionId) {\n\n\t\tfinal Execution execution = currentExecution;\n\n\t\t// Abort this request if there was a concurrent reset\n\t\tif (!partitionId.getProducerId().equals(execution.getAttemptId())) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal IntermediateResultPartition partition = resultPartitions.get(partitionId.getPartitionId());\n\n\t\tif (partition == null) {\n\t\t\tthrow new IllegalStateException(\"Unknown partition \" + partitionId + \".\");\n\t\t}\n\n\t\tpartition.markDataProduced();\n\n\t\tif (partition.getIntermediateResult().getResultType().isPipelined()) {\n\t\t\t// Schedule or update receivers of this partition\n\t\t\texecution.scheduleOrUpdateConsumers(partition.getConsumers());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"ScheduleOrUpdateConsumers msg is only valid for\" +\n\t\t\t\t\t\"pipelined partitions.\");\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Initiates a forceful shutdown in which preexisting and new calls are cancelled. Although\nforceful, the shutdown process is still not instantaneous; {@link #isTerminated()} will likely\nreturn {@code false} immediately after this method returns.", "input": "Java", "output": "@Override\n  public ManagedChannelImpl shutdownNow() {\n    channelLogger.log(ChannelLogLevel.DEBUG, \"shutdownNow() called\");\n    shutdown();\n    uncommittedRetriableStreamsRegistry.onShutdownNow(SHUTDOWN_NOW_STATUS);\n    final class ShutdownNow implements Runnable {\n      @Override\n      public void run() {\n        if (shutdownNowed) {\n          return;\n        }\n        shutdownNowed = true;\n        maybeShutdownNowSubchannels();\n      }\n    }\n\n    syncContext.execute(new ShutdownNow());\n    return this;\n  }", "category": "Python"}, {"instruction": "\u79fb\u52a8\u6587\u4ef6\u6216\u8005\u76ee\u5f55\n\n@param src \u6e90\u6587\u4ef6\u6216\u8005\u76ee\u5f55\n@param dest \u76ee\u6807\u6587\u4ef6\u6216\u8005\u76ee\u5f55\n@param isOverride \u662f\u5426\u8986\u76d6\u76ee\u6807\uff0c\u53ea\u6709\u76ee\u6807\u4e3a\u6587\u4ef6\u624d\u8986\u76d6\n@throws IORuntimeException IO\u5f02\u5e38", "input": "Java", "output": "public static void move(File src, File dest, boolean isOverride) throws IORuntimeException {\r\n\t\t// check\r\n\t\tif (false == src.exists()) {\r\n\t\t\tthrow new IORuntimeException(\"File not found: \" + src);\r\n\t\t}\r\n\r\n\t\t// \u6765\u6e90\u4e3a\u6587\u4ef6\u5939\uff0c\u76ee\u6807\u4e3a\u6587\u4ef6\r\n\t\tif (src.isDirectory() && dest.isFile()) {\r\n\t\t\tthrow new IORuntimeException(StrUtil.format(\"Can not move directory [{}] to file [{}]\", src, dest));\r\n\t\t}\r\n\r\n\t\tif (isOverride && dest.isFile()) {// \u53ea\u6709\u76ee\u6807\u4e3a\u6587\u4ef6\u7684\u60c5\u51b5\u4e0b\u8986\u76d6\u4e4b\r\n\t\t\tdest.delete();\r\n\t\t}\r\n\r\n\t\t// \u6765\u6e90\u4e3a\u6587\u4ef6\uff0c\u76ee\u6807\u4e3a\u6587\u4ef6\u5939\r\n\t\tif (src.isFile() && dest.isDirectory()) {\r\n\t\t\tdest = new File(dest, src.getName());\r\n\t\t}\r\n\r\n\t\tif (false == src.renameTo(dest)) {\r\n\t\t\t// \u5728\u6587\u4ef6\u7cfb\u7edf\u4e0d\u540c\u7684\u60c5\u51b5\u4e0b\uff0crenameTo\u4f1a\u5931\u8d25\uff0c\u6b64\u65f6\u4f7f\u7528copy\uff0c\u7136\u540e\u5220\u9664\u539f\u6587\u4ef6\r\n\t\t\ttry {\r\n\t\t\t\tcopy(src, dest, isOverride);\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\tthrow new IORuntimeException(StrUtil.format(\"Move [{}] to [{}] failed!\", src, dest), e);\r\n\t\t\t}\r\n\t\t\t// \u590d\u5236\u540e\u5220\u9664\u6e90\r\n\t\t\tdel(src);\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "This method removes all cached constants", "input": "Java", "output": "@Override\n    public void purgeConstants() {\n        buffersCache = new HashMap<>();\n\n        protector.purgeProtector();\n\n        resetHappened = true;\n        logger.info(\"Resetting Constants...\");\n\n        for (Integer device : constantOffsets.keySet()) {\n            constantOffsets.get(device).set(0);\n            buffersCache.put(device, new ConcurrentHashMap<ArrayDescriptor, DataBuffer>());\n        }\n    }", "category": "Python"}, {"instruction": "\u5c06\u9a7c\u5cf0\u98ce\u683c\u66ff\u6362\u4e3a\u4e0b\u5212\u7ebf\u98ce\u683c", "input": "Java", "output": "public static String camelhumpToUnderline(String str) {\n        final int size;\n        final char[] chars;\n        final StringBuilder sb = new StringBuilder(\n                (size = (chars = str.toCharArray()).length) * 3 / 2 + 1);\n        char c;\n        for (int i = 0; i < size; i++) {\n            c = chars[i];\n            if (isUppercaseAlpha(c)) {\n                sb.append('_').append(toLowerAscii(c));\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.charAt(0) == '_' ? sb.substring(1) : sb.toString();\n    }", "category": "Python"}, {"instruction": "Start the monitoring process.", "input": "Java", "output": "@Override\n    public synchronized void start() {\n        if (monitorActive) {\n            return;\n        }\n        lastTime.set(milliSecondFromNano());\n        long localCheckInterval = checkInterval.get();\n        if (localCheckInterval > 0) {\n            monitorActive = true;\n            monitor = new MixedTrafficMonitoringTask((GlobalChannelTrafficShapingHandler) trafficShapingHandler, this);\n            scheduledFuture =\n                executor.schedule(monitor, localCheckInterval, TimeUnit.MILLISECONDS);\n        }\n    }", "category": "Python"}, {"instruction": "Encodes URI string.\n\nThis is a two mapping, one from original characters to octets, and\nsubsequently a second from octets to URI characters:\n<p><blockquote><pre>\noriginal character sequence-&gt;octet sequence-&gt;URI character sequence\n</pre></blockquote><p>\n\nAn escaped octet is encoded as a character triplet, consisting of the\npercent character \"%\" followed by the two hexadecimal digits\nrepresenting the octet code. For example, \"%20\" is the escaped\nencoding for the US-ASCII space character.\n<p>\nConversion from the local filesystem character set to UTF-8 will\nnormally involve a two step process. First convert the local character\nset to the UCS; then convert the UCS to UTF-8.\nThe first step in the process can be performed by maintaining a mapping\ntable that includes the local character set code and the corresponding\nUCS code.\nThe next step is to convert the UCS character code to the UTF-8 encoding.\n<p>\nMapping between vendor codepages can be done in a very similar manner\nas described above.\n<p>\nThe only time escape encodings can allowedly be made is when a URI is\nbeing created from its component parts.  The escape and validate methods\nare internally performed within this method.\n\n@param original the original character sequence\n@param allowed those characters that are allowed within a component\n@param charset the protocol charset\n@return URI character sequence\n@throws URIException null component or unsupported character encoding", "input": "Java", "output": "protected static char[] encode(String original, BitSet allowed,\n            String charset) throws URIException {\n        if (original == null) {\n            throw new IllegalArgumentException(\"Original string may not be null\");\n        }\n        if (allowed == null) {\n            throw new IllegalArgumentException(\"Allowed bitset may not be null\");\n        }\n        byte[] rawdata = URLCodec.encodeUrl(allowed, EncodingUtil.getBytes(original, charset));\n        return EncodingUtil.getAsciiString(rawdata).toCharArray();\n    }", "category": "Python"}, {"instruction": "<pre>\nUses YarnClient to kill the job on HDFS.\nUsing JobClient only works partially:\nIf yarn container has started but spark job haven't, it will kill\nIf spark job has started, the cancel will hang until the spark job is complete\nIf the spark job is complete, it will return immediately, with a job not found on job tracker\n</pre>", "input": "Java", "output": "public static void killJobOnCluster(String applicationId, Logger log) throws YarnException,\n      IOException {\n\n    YarnConfiguration yarnConf = new YarnConfiguration();\n    YarnClient yarnClient = YarnClient.createYarnClient();\n    yarnClient.init(yarnConf);\n    yarnClient.start();\n\n    String[] split = applicationId.split(\"_\");\n    ApplicationId aid = ApplicationId.newInstance(Long.parseLong(split[1]),\n        Integer.parseInt(split[2]));\n\n    log.info(\"start klling application: \" + aid);\n    yarnClient.killApplication(aid);\n    log.info(\"successfully killed application: \" + aid);\n  }", "category": "Python"}, {"instruction": "Direct method for a complete ContentMatcher instance creation.\n@param xmlInputStream the stream of the XML file that need to be used for initialization\n@return a ContentMatcher instance", "input": "Java", "output": "public static ContentMatcher getInstance(InputStream xmlInputStream) {\r\n        ContentMatcher cm = new ContentMatcher();\r\n\r\n        // Load the pattern definitions from an XML file\r\n        try {\r\n            cm.loadXMLPatternDefinitions(xmlInputStream);\r\n            \r\n        } catch (JDOMException | IOException ex) {\r\n            throw new IllegalArgumentException(\"Failed to initialize the ContentMatcher object using that stream\", ex);\r\n        }\r\n        \r\n        return cm;\r\n    }", "category": "Python"}, {"instruction": "Lists all shared VPC host projects visible to the user in an organization.\n\n<p>Sample code:\n\n<pre><code>\ntry (ProjectClient projectClient = ProjectClient.create()) {\nProjectName project = ProjectName.of(\"[PROJECT]\");\nProjectsListXpnHostsRequest projectsListXpnHostsRequestResource = ProjectsListXpnHostsRequest.newBuilder().build();\nfor (Project element : projectClient.listXpnHostsProjects(project, projectsListXpnHostsRequestResource).iterateAll()) {\n// doThingsWith(element);\n}\n}\n</code></pre>\n\n@param project Project ID for this request.\n@param projectsListXpnHostsRequestResource\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final ListXpnHostsProjectsPagedResponse listXpnHostsProjects(\n      ProjectName project, ProjectsListXpnHostsRequest projectsListXpnHostsRequestResource) {\n    ListXpnHostsProjectsHttpRequest request =\n        ListXpnHostsProjectsHttpRequest.newBuilder()\n            .setProject(project == null ? null : project.toString())\n            .setProjectsListXpnHostsRequestResource(projectsListXpnHostsRequestResource)\n            .build();\n    return listXpnHostsProjects(request);\n  }", "category": "Python"}, {"instruction": "Execute the specified TransformProcess with the given <i>sequence</i> input data<br>\nNote: this method can only be used if the TransformProcess starts with sequence data, but returns <i>non-sequential</i>\ndata (after reducing or converting sequential data to individual examples)\n\n@param inputSequence    Input sequence data to process\n@param transformProcess TransformProcess to execute\n@return Processed (non-sequential) data", "input": "Java", "output": "public static List<List<Writable>> executeSequenceToSeparate(List<List<List<Writable>>> inputSequence,\n                                                                 TransformProcess transformProcess) {\n        if (transformProcess.getFinalSchema() instanceof SequenceSchema) {\n            throw new IllegalStateException(\"Cannot return sequence data with this method\");\n        }\n\n        return execute(null, inputSequence, transformProcess).getFirst();\n    }", "category": "Python"}, {"instruction": "Create a new SAML object.\n\n@param <T>        the generic type\n@param objectType the object type\n@return the t", "input": "Java", "output": "@SneakyThrows\n    public <T extends SAMLObject> T newSamlObject(final Class<T> objectType) {\n        val qName = getSamlObjectQName(objectType);\n        val builder = (SAMLObjectBuilder<T>)\n            XMLObjectProviderRegistrySupport.getBuilderFactory().getBuilder(qName);\n        if (builder == null) {\n            throw new IllegalStateException(\"No SAML object builder is registered for class \" + objectType.getName());\n        }\n        return objectType.cast(builder.buildObject(qName));\n    }", "category": "Python"}, {"instruction": "add additional config entries from the Flink config to the Hadoop config", "input": "Java", "output": "private org.apache.hadoop.conf.Configuration loadHadoopConfigFromFlink() {\n\t\torg.apache.hadoop.conf.Configuration hadoopConfig = new org.apache.hadoop.conf.Configuration();\n\t\tfor (String key : flinkConfig.keySet()) {\n\t\t\tfor (String prefix : flinkConfigPrefixes) {\n\t\t\t\tif (key.startsWith(prefix)) {\n\t\t\t\t\tString newKey = hadoopConfigPrefix + key.substring(prefix.length());\n\t\t\t\t\tString newValue = fixHadoopConfig(key, flinkConfig.getString(key, null));\n\t\t\t\t\thadoopConfig.set(newKey, newValue);\n\n\t\t\t\t\tLOG.debug(\"Adding Flink config entry for {} as {} to Hadoop config\", key, newKey);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hadoopConfig;\n\t}", "category": "Python"}, {"instruction": "Invokes a nullary static factory method using reflection to stay backwards-compatible with older JDKs.\n\n@param fqcn The fully qualified class name of the type to be produced.\n@param methodName The name of the factory method.\n@return the object produced.", "input": "Java", "output": "private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {\n        try {\n            final Class<?> type = Class.forName(fqcn);\n            final Method method = type.getMethod(methodName);\n\n            return method.invoke(null);\n            // any exception is really unexpected since the type name has\n            // already been verified\n        } catch (final Exception e) {\n            throw new InstantiationException(\n                    String.format(\"Could not create %s#%s(): %s\", fqcn, methodName, e), e);\n        }\n    }", "category": "Python"}, {"instruction": "Get activation enum value from Keras layer configuration.\n\n@param layerConfig dictionary containing Keras layer configuration\n@return DL4J activation enum value\n@throws InvalidKerasConfigurationException     Invalid Keras config\n@throws UnsupportedKerasConfigurationException Unsupported Keras config", "input": "Java", "output": "public static Activation getActivationFromConfig(Map<String, Object> layerConfig, KerasLayerConfiguration conf)\n            throws InvalidKerasConfigurationException, UnsupportedKerasConfigurationException {\n        Map<String, Object> innerConfig = KerasLayerUtils.getInnerLayerConfigFromConfig(layerConfig, conf);\n        if (!innerConfig.containsKey(conf.getLAYER_FIELD_ACTIVATION()))\n            throw new InvalidKerasConfigurationException(\"Keras layer is missing \"\n                    + conf.getLAYER_FIELD_ACTIVATION() + \" field\");\n        return mapToActivation((String) innerConfig.get(conf.getLAYER_FIELD_ACTIVATION()), conf);\n    }", "category": "Python"}, {"instruction": "***********************************************************************", "input": "Java", "output": "private Class<?> attemptFromContextLoader(final String driverClassName) {\n      final ClassLoader threadContextClassLoader = Thread.currentThread().getContextClassLoader();\n      if (threadContextClassLoader != null) {\n         try {\n            final Class<?> driverClass = threadContextClassLoader.loadClass(driverClassName);\n            LOGGER.debug(\"Driver class {} found in Thread context class loader {}\", driverClassName, threadContextClassLoader);\n            return driverClass;\n         } catch (ClassNotFoundException e) {\n            LOGGER.debug(\"Driver class {} not found in Thread context class loader {}, trying classloader {}\",\n               driverClassName, threadContextClassLoader, this.getClass().getClassLoader());\n         }\n      }\n\n      return null;\n   }", "category": "Python"}, {"instruction": "Method returns an Optional that will contain a {@link MultifactorAuthenticationProvider} that has the\nsame id as the passed providerId parameter.\n\n@param providerId - the id to match\n@param context    - ApplicationContext\n@return - Optional", "input": "Java", "output": "public static Optional<MultifactorAuthenticationProvider> getMultifactorAuthenticationProviderById(final String providerId,\n                                                                                                       final ApplicationContext context) {\n        return getAvailableMultifactorAuthenticationProviders(context).values()\n            .stream()\n            .filter(p -> p.matches(providerId))\n            .findFirst();\n    }", "category": "Python"}, {"instruction": "Tries to find a {@link SerializedThrowable} as the cause of the given throwable and throws its\ndeserialized value. If there is no such throwable, then the original throwable is thrown.\n\n@param throwable to check for a SerializedThrowable\n@param classLoader to be used for the deserialization of the SerializedThrowable\n@throws Throwable either the deserialized throwable or the given throwable", "input": "Java", "output": "public static void tryDeserializeAndThrow(Throwable throwable, ClassLoader classLoader) throws Throwable {\n\t\tThrowable current = throwable;\n\n\t\twhile (!(current instanceof SerializedThrowable) && current.getCause() != null) {\n\t\t\tcurrent = current.getCause();\n\t\t}\n\n\t\tif (current instanceof SerializedThrowable) {\n\t\t\tthrow ((SerializedThrowable) current).deserializeError(classLoader);\n\t\t} else {\n\t\t\tthrow throwable;\n\t\t}\n\t}", "category": "Python"}, {"instruction": "An expectation for checking WebElement with given locator has specific text\n\n@param locator used to find the element\n@param value   used as expected text\n@return Boolean true when element has text value equal to @value", "input": "Java", "output": "public static ExpectedCondition<Boolean> textToBe(final By locator, final String value) {\n    return new ExpectedCondition<Boolean>() {\n      private String currentValue = null;\n\n      @Override\n      public Boolean apply(WebDriver driver) {\n        try {\n          currentValue = driver.findElement(locator).getText();\n          return currentValue.equals(value);\n        } catch (Exception e) {\n          return false;\n        }\n      }\n\n      @Override\n      public String toString() {\n        return String.format(\"element found by %s to have text \\\"%s\\\". Current text: \\\"%s\\\"\",\n                             locator, value, currentValue);\n      }\n    };\n  }", "category": "Python"}, {"instruction": "Returns alternative names (non-deprecated keys or previously-set deprecated keys)\nfor a given non-deprecated key.\nIf the given key is deprecated, return null.\n\n@param name property name.\n@return alternative names.", "input": "Java", "output": "private String[] getAlternativeNames(String name) {\n\t\tString altNames[] = null;\n\t\tDeprecatedKeyInfo keyInfo = null;\n\t\tDeprecationContext cur = deprecationContext.get();\n\t\tString depKey = cur.getReverseDeprecatedKeyMap().get(name);\n\t\tif(depKey != null) {\n\t\t\tkeyInfo = cur.getDeprecatedKeyMap().get(depKey);\n\t\t\tif(keyInfo.newKeys.length > 0) {\n\t\t\t\tif(getProps().containsKey(depKey)) {\n\t\t\t\t\t//if deprecated key is previously set explicitly\n\t\t\t\t\tList<String> list = new ArrayList<String>();\n\t\t\t\t\tlist.addAll(Arrays.asList(keyInfo.newKeys));\n\t\t\t\t\tlist.add(depKey);\n\t\t\t\t\taltNames = list.toArray(new String[list.size()]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taltNames = keyInfo.newKeys;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn altNames;\n\t}", "category": "Python"}, {"instruction": "For classpath reasons, we'll put each link file in a separate directory.\nThis must be called only after the job id has been inserted by the job.\n\n@param props The Azkaban properties", "input": "Java", "output": "public static String getDirName(Props props) {\n    String dirSuffix = props.get(CommonJobProperties.NESTED_FLOW_PATH);\n\n    if ((dirSuffix == null) || (dirSuffix.length() == 0)) {\n      dirSuffix = props.get(CommonJobProperties.JOB_ID);\n      if ((dirSuffix == null) || (dirSuffix.length() == 0)) {\n        throw new RuntimeException(\"azkaban.flow.nested.path and azkaban.job.id were not set\");\n      }\n    }\n\n    return \"_resources_\" + dirSuffix.replace(':', '_');\n  }", "category": "Python"}, {"instruction": "Creates HostAndPort instance from string.\nString must be in ( host + \":\" + port ) format.\nPort is mandatory. Can convert host part.\n@see #convertHost(String)\n@param from String to parse\n@return HostAndPort instance", "input": "Java", "output": "public static HostAndPort parseString(String from){\n    // NOTE: redis answers with\n    // '99aa9999aa9a99aa099aaa990aa99a09aa9a9999 9a09:9a9:a090:9a::99a slave 8c88888888cc08088cc8c8c888c88c8888c88cc8 0 1468251272993 37 connected'\n    // for CLUSTER NODES, ASK and MOVED scenarios. That's why there is no possibility to parse address in 'correct' way.\n    // Redis should switch to 'bracketized' (RFC 3986) IPv6 address.\n    try {\n      String[] parts = extractParts(from);\n      String host = parts[0];\n      int port = Integer.parseInt(parts[1]);\n      return new HostAndPort(convertHost(host), port);\n    } catch (NumberFormatException ex) {\n      throw new IllegalArgumentException(ex);\n    }\n  }", "category": "Python"}, {"instruction": "Produce a comma delimited text row from a JSONArray. Values containing the comma character will be quoted. Troublesome characters may be removed.\n\n@param ja\nA JSONArray of strings.\n@return A string ending in NEWLINE.", "input": "Java", "output": "public static String rowToString(JSONArray ja) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < ja.length(); i += 1) {\n      if (i > 0) {\n        sb.append(',');\n      }\n      Object o = ja.opt(i);\n      if (o != null) {\n        String s = o.toString();\n        if (s.length() > 0 && (s.indexOf(',') >= 0 || s.indexOf('\\n') >= 0 || s.indexOf('\\r') >= 0 || s.indexOf(0) >= 0 || s.charAt(0) == '\"')) {\n          sb.append('\"');\n          int length = s.length();\n          for (int j = 0; j < length; j += 1) {\n            char c = s.charAt(j);\n            if (c >= ' ' && c != '\"') {\n              sb.append(c);\n            }\n          }\n          sb.append('\"');\n        } else {\n          sb.append(s);\n        }\n      }\n    }\n    sb.append('\\n');\n    return sb.toString();\n  }", "category": "Python"}, {"instruction": "\u552f\u4e00\u6807\u8bc6UniqueName\u7684\u4ea7\u751f\u65b9\u6cd5\uff0c\u4e3b\u8981\u7528\u4e8e\u5185\u90e8\u627e\u63a5\u53e3\u7b49\uff0c\u683c\u5f0f\u4e3ainterface:version[:uniqueId]\n\n@param interfaceConfig \u670d\u52a1\u63d0\u4f9b\u8005\u6216\u8005\u670d\u52a1\u6d88\u8d39\u8005\u914d\u7f6e\n@return \u914d\u7f6e\u552f\u4e00\u540d\u5b57", "input": "Java", "output": "public static String getUniqueName(AbstractInterfaceConfig interfaceConfig) {\n        // \u52a0\u4e0a 1.0 \u662f\u4e3a\u4e86\u517c\u5bb9\u4e4b\u524d\u7684\u7248\u672c\n        String version = interfaceConfig.getVersion();\n        String uniqueId = interfaceConfig.getUniqueId();\n        return interfaceConfig.getInterfaceId()\n            + (StringUtils.isEmpty(version) ? \":1.0\" : \":\" + version)\n            + (StringUtils.isEmpty(uniqueId) ? \"\" : \":\" + uniqueId);\n    }", "category": "Python"}, {"instruction": "Gets the interface {@code class1} from the given {@code script}. Might return {@code null} if the {@code script} does not\nimplement the interface.\n<p>\nFirst tries to get the interface directly from the {@code script} by calling the method\n{@code ScriptWrapper.getInterface(Class)}, if it returns {@code null} the interface will be extracted from the script\nafter invoking it, using the method {@code Invocable.getInterface(Class)}.\n<p>\nThe context class loader of caller thread is replaced with the class loader {@code AddOnLoader} to allow the script to\naccess classes of add-ons. If this behaviour is not desired call the method {@code getInterfaceWithOutAddOnLoader(}\ninstead.\n\n@param script the script that will be invoked\n@param class1 the interface that will be obtained from the script\n@return the interface implemented by the script, or {@code null} if the {@code script} does not implement the interface.\n@throws ScriptException if the engine of the given {@code script} was not found.\n@throws IOException if an error occurred while obtaining the interface directly from the script (\n{@code ScriptWrapper.getInterface(Class)})\n@see #getInterfaceWithOutAddOnLoader(ScriptWrapper, Class)\n@see ScriptWrapper#getInterface(Class)\n@see Invocable#getInterface(Class)", "input": "Java", "output": "public <T> T getInterface(ScriptWrapper script, Class<T> class1) throws ScriptException, IOException {\r\n\t\r\n\t\tClassLoader previousContextClassLoader = Thread.currentThread().getContextClassLoader();\r\n\t\tThread.currentThread().setContextClassLoader(ExtensionFactory.getAddOnLoader());\r\n\t\ttry {\r\n\t\t\tT iface = script.getInterface(class1);\r\n\t\t\t\r\n\t\t\tif (iface != null) {\r\n\t\t\t\t// the script wrapper has overriden the usual scripting mechanism\r\n\t\t\t\treturn iface;\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\tThread.currentThread().setContextClassLoader(previousContextClassLoader);\r\n\t\t}\r\n\t\t\r\n\t\tif (script.isRunableStandalone()) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tInvocable invocable = invokeScript(script);\r\n\t\tif (invocable != null) {\r\n\t\t\treturn invocable.getInterface(class1);\r\n\t\t}\r\n\t\treturn null;\r\n\r\n\t}", "category": "Python"}, {"instruction": "{@link #compute} can be called by multiple threads, so this function should be thread-safe to avoid extra\nscript compilation.", "input": "Java", "output": "@EnsuresNonNull(\"fn\")\n  private Function getCompiledScript()\n  {\n    // JavaScript configuration should be checked when it's actually used because someone might still want Druid\n    // nodes to be able to deserialize JavaScript-based objects even though JavaScript is disabled.\n    Preconditions.checkState(config.isEnabled(), \"JavaScript is disabled\");\n\n    Function syncedFn = fn;\n    if (syncedFn == null) {\n      synchronized (config) {\n        syncedFn = fn;\n        if (syncedFn == null) {\n          syncedFn = compile(function);\n          fn = syncedFn;\n        }\n      }\n    }\n    return syncedFn;\n  }", "category": "Python"}, {"instruction": "Specifies that each entry should be automatically removed from the cache once a fixed duration\nhas elapsed after the entry's creation, the most recent replacement of its value, or its last\nread. Access time is reset by all cache read and write operations (including\n{@code Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by operations\non the collection-views of {@link Cache#asMap}.\n<p>\nExpired entries may be counted in {@link Cache#estimatedSize()}, but will never be visible to\nread or write operations. Expired entries are cleaned up as part of the routine maintenance\ndescribed in the class javadoc.\n<p>\nIf you can represent the duration as a {@link java.time.Duration} (which should be preferred\nwhen feasible), use {@link #expireAfterAccess(Duration)} instead.\n\n@param duration the length of time after an entry is last accessed that it should be\nautomatically removed\n@param unit the unit that {@code duration} is expressed in\n@return this {@code Caffeine} instance (for chaining)\n@throws IllegalArgumentException if {@code duration} is negative\n@throws IllegalStateException if the time to idle or variable expiration was already set", "input": "Java", "output": "@NonNull\n  public Caffeine<K, V> expireAfterAccess(@NonNegative long duration, @NonNull TimeUnit unit) {\n    requireState(expireAfterAccessNanos == UNSET_INT,\n        \"expireAfterAccess was already set to %s ns\", expireAfterAccessNanos);\n    requireState(expiry == null, \"expireAfterAccess may not be used with variable expiration\");\n    requireArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n    this.expireAfterAccessNanos = unit.toNanos(duration);\n    return this;\n  }", "category": "Python"}, {"instruction": "Splice from this {@link AbstractEpollStreamChannel} to another {@link AbstractEpollStreamChannel}.\nThe {@code len} is the number of bytes to splice. If using {@link Integer#MAX_VALUE} it will\nsplice until the {@link ChannelFuture} was canceled or it was failed.\n\nPlease note:\n<ul>\n<li>both channels need to be registered to the same {@link EventLoop}, otherwise an\n{@link IllegalArgumentException} is thrown. </li>\n<li>{@link EpollChannelConfig#getEpollMode()} must be {@link EpollMode#LEVEL_TRIGGERED} for this and the\ntarget {@link AbstractEpollStreamChannel}</li>\n</ul>", "input": "Java", "output": "public final ChannelFuture spliceTo(final AbstractEpollStreamChannel ch, final int len,\n                                        final ChannelPromise promise) {\n        if (ch.eventLoop() != eventLoop()) {\n            throw new IllegalArgumentException(\"EventLoops are not the same.\");\n        }\n        checkPositiveOrZero(len, \"len\");\n        if (ch.config().getEpollMode() != EpollMode.LEVEL_TRIGGERED\n                || config().getEpollMode() != EpollMode.LEVEL_TRIGGERED) {\n            throw new IllegalStateException(\"spliceTo() supported only when using \" + EpollMode.LEVEL_TRIGGERED);\n        }\n        checkNotNull(promise, \"promise\");\n        if (!isOpen()) {\n            promise.tryFailure(SPLICE_TO_CLOSED_CHANNEL_EXCEPTION);\n        } else {\n            addToSpliceQueue(new SpliceInChannelTask(ch, len, promise));\n            failSpliceIfClosed(promise);\n        }\n        return promise;\n    }", "category": "Python"}, {"instruction": "[VARIABLE my_singer_id]", "input": "Java", "output": "public Timestamp singleUseReadOnlyTransaction(long singerId) {\n    // [START singleUseReadOnlyTransaction]\n    String column = \"FirstName\";\n    ReadOnlyTransaction txn = dbClient.singleUseReadOnlyTransaction();\n    Struct row = txn.readRow(\"Singers\", Key.of(singerId), Collections.singleton(column));\n    row.getString(column);\n    Timestamp timestamp = txn.getReadTimestamp();\n    // [END singleUseReadOnlyTransaction]\n    return timestamp;\n  }", "category": "Python"}, {"instruction": "Must be called from syncContext", "input": "Java", "output": "private void shutdownNameResolverAndLoadBalancer(boolean channelIsActive) {\n    syncContext.throwIfNotInThisSynchronizationContext();\n    if (channelIsActive) {\n      checkState(nameResolverStarted, \"nameResolver is not started\");\n      checkState(lbHelper != null, \"lbHelper is null\");\n    }\n    if (nameResolver != null) {\n      cancelNameResolverBackoff();\n      nameResolver.shutdown();\n      nameResolverStarted = false;\n      if (channelIsActive) {\n        nameResolver = getNameResolver(target, nameResolverFactory, nameResolverHelper);\n      } else {\n        nameResolver = null;\n      }\n    }\n    if (lbHelper != null) {\n      lbHelper.lb.shutdown();\n      lbHelper = null;\n    }\n    subchannelPicker = null;\n  }", "category": "Python"}, {"instruction": "Handler for an inbound HTTP/2 RST_STREAM frame, terminating a stream.", "input": "Java", "output": "private void onRstStreamRead(int streamId, long errorCode) {\n    NettyClientStream.TransportState stream = clientStream(connection().stream(streamId));\n    if (stream != null) {\n      Status status = GrpcUtil.Http2Error.statusForCode((int) errorCode)\n          .augmentDescription(\"Received Rst Stream\");\n      stream.transportReportStatus(\n          status,\n          errorCode == Http2Error.REFUSED_STREAM.code()\n              ? RpcProgress.REFUSED : RpcProgress.PROCESSED,\n          false /*stop delivery*/,\n          new Metadata());\n      if (keepAliveManager != null) {\n        keepAliveManager.onDataReceived();\n      }\n    }\n  }", "category": "Python"}, {"instruction": "\u5378\u8f7d\u6a21\u5757\n\n@param moduleName module name", "input": "Java", "output": "public static void uninstallModule(String moduleName) {\n        Module module = INSTALLED_MODULES.get(moduleName);\n        if (module != null) {\n            try {\n                module.uninstall();\n                INSTALLED_MODULES.remove(moduleName);\n            } catch (Exception e) {\n                if (LOGGER.isWarnEnabled()) {\n                    LOGGER.warn(\"Error when uninstall module \" + moduleName, e);\n                }\n            }\n        }\n    }", "category": "Python"}, {"instruction": "\u6839\u636e\u4e3b\u952e\u8fdb\u884c\u67e5\u8be2\n\n@param ms", "input": "Java", "output": "public String selectByPrimaryKey(MappedStatement ms) {\n        final Class<?> entityClass = getEntityClass(ms);\n        //\u5c06\u8fd4\u56de\u503c\u4fee\u6539\u4e3a\u5b9e\u4f53\u7c7b\u578b\n        setResultType(ms, entityClass);\n        StringBuilder sql = new StringBuilder();\n        sql.append(SqlHelper.selectAllColumns(entityClass));\n        sql.append(SqlHelper.fromTable(entityClass, tableName(entityClass)));\n        sql.append(SqlHelper.wherePKColumns(entityClass));\n        return sql.toString();\n    }", "category": "Python"}, {"instruction": "Retrieve instance of {@link HystrixConcurrencyStrategy} to use based on order of precedence as defined in {@link HystrixPlugins} class header.\n<p>\nOverride default by using {@link #registerConcurrencyStrategy(HystrixConcurrencyStrategy)} or setting property (via Archaius): <code>hystrix.plugin.HystrixConcurrencyStrategy.implementation</code> with the\nfull classname to load.\n\n@return {@link HystrixConcurrencyStrategy} implementation to use", "input": "Java", "output": "public HystrixConcurrencyStrategy getConcurrencyStrategy() {\n        if (concurrencyStrategy.get() == null) {\n            // check for an implementation from Archaius first\n            Object impl = getPluginImplementation(HystrixConcurrencyStrategy.class);\n            if (impl == null) {\n                // nothing set via Archaius so initialize with default\n                concurrencyStrategy.compareAndSet(null, HystrixConcurrencyStrategyDefault.getInstance());\n                // we don't return from here but call get() again in case of thread-race so the winner will always get returned\n            } else {\n                // we received an implementation from Archaius so use it\n                concurrencyStrategy.compareAndSet(null, (HystrixConcurrencyStrategy) impl);\n            }\n        }\n        return concurrencyStrategy.get();\n    }", "category": "Python"}, {"instruction": "Leave the information about login failure.\n\n<p>\nOtherwise it seems like Acegi doesn't really leave the detail of the failure anywhere.", "input": "Java", "output": "@Override\n    protected void onUnsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException {\n        super.onUnsuccessfulAuthentication(request, response, failed);\n        LOGGER.log(Level.FINE, \"Login attempt failed\", failed);\n        Authentication auth = failed.getAuthentication();\n        if (auth != null) {\n            SecurityListener.fireFailedToLogIn(auth.getName());\n        }\n    }", "category": "Python"}, {"instruction": "init fxml when loaded.", "input": "Java", "output": "@PostConstruct\n    public void init() {\n        Timeline task = new Timeline(\n            new KeyFrame(\n                Duration.ZERO,\n                new KeyValue(progress1.progressProperty(), 0),\n                new KeyValue(progress2.progressProperty(), 0),\n                new KeyValue(progress2.secondaryProgressProperty(), 0.5)),\n            new KeyFrame(\n                Duration.seconds(1),\n                new KeyValue(progress2.secondaryProgressProperty(), 1)),\n            new KeyFrame(\n                Duration.seconds(2),\n                new KeyValue(progress1.progressProperty(), 1),\n                new KeyValue(progress2.progressProperty(), 1)));\n        task.setCycleCount(Timeline.INDEFINITE);\n        task.play();\n    }", "category": "Python"}, {"instruction": "Serialize array data linearly.", "input": "Java", "output": "public void write(DataOutput out) throws IOException {\n        if (array == null) {\n            out.write(NDARRAY_SER_VERSION_HEADER_NULL);\n            return;\n        }\n\n        INDArray toWrite;\n        if (array.isView()) {\n            toWrite = array.dup();\n        } else {\n            toWrite = array;\n        }\n\n        //Write version header: this allows us to maintain backward compatibility in the future,\n        // with features such as compression, sparse arrays or changes on the DataVec side\n        out.write(NDARRAY_SER_VERSION_HEADER);\n        Nd4j.write(toWrite, new DataOutputStream(new DataOutputWrapperStream(out)));\n    }", "category": "Python"}, {"instruction": "\u8f6c\u4e49\u4e0d\u53ef\u89c1\u5b57\u7b26<br>\n\u89c1\uff1ahttps://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF\n\n@param c \u5b57\u7b26\n@return \u8f6c\u4e49\u540e\u7684\u5b57\u7b26\u4e32", "input": "Java", "output": "private static String escape(char c) {\r\n\t\tswitch (c) {\r\n\t\tcase '\\b':\r\n\t\t\treturn \"\\\\b\";\r\n\t\tcase '\\t':\r\n\t\t\treturn \"\\\\t\";\r\n\t\tcase '\\n':\r\n\t\t\treturn \"\\\\n\";\r\n\t\tcase '\\f':\r\n\t\t\treturn \"\\\\f\";\r\n\t\tcase '\\r':\r\n\t\t\treturn \"\\\\r\";\r\n\t\tdefault:\r\n\t\t\tif (c < StrUtil.C_SPACE || //\r\n\t\t\t\t\t(c >= '\\u0080' && c <= '\\u00a0') || //\r\n\t\t\t\t\t(c >= '\\u2000' && c <= '\\u2010') || //\r\n\t\t\t\t\t(c >= '\\u2028' && c <= '\\u202F') || //\r\n\t\t\t\t\t(c >= '\\u2066' && c <= '\\u206F')//\r\n\t\t\t) {\r\n\t\t\t\treturn HexUtil.toUnicodeHex(c);\r\n\t\t\t} else {\r\n\t\t\t\treturn Character.toString(c);\r\n\t\t\t}\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "Returns the type information factory for a type using the factory registry or annotations.", "input": "Java", "output": "@Internal\n\tpublic static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {\n\t\tfinal Class<?> factoryClass;\n\t\tif (registeredTypeInfoFactories.containsKey(t)) {\n\t\t\tfactoryClass = registeredTypeInfoFactories.get(t);\n\t\t}\n\t\telse {\n\t\t\tif (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfinal TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class);\n\t\t\tfactoryClass = typeInfoAnnotation.value();\n\t\t\t// check for valid factory class\n\t\t\tif (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {\n\t\t\t\tthrow new InvalidTypesException(\"TypeInfo annotation does not specify a valid TypeInfoFactory.\");\n\t\t\t}\n\t\t}\n\n\t\t// instantiate\n\t\treturn (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass);\n\t}", "category": "Python"}, {"instruction": "/* (non-Javadoc)\n@see org.parosproxy.paros.db.paros.TableContext#insert(int, int, java.lang.String)", "input": "Java", "output": "@Override\r\n\tpublic synchronized RecordContext insert(int contextId, int type, String url) throws DatabaseException {\r\n        try {\r\n\t\t\tpsInsert.setInt(1, contextId);\r\n\t\t\tpsInsert.setInt(2, type);\r\n\t\t\tpsInsert.setString(3, url);\r\n\t\t\tpsInsert.executeUpdate();\r\n\t\t\t\r\n\t\t\tlong id;\r\n\t\t\ttry (ResultSet rs = psGetIdLastInsert.executeQuery()) {\r\n\t\t\t\trs.next();\r\n\t\t\t\tid = rs.getLong(1);\r\n\t\t\t}\r\n\t\t\treturn read(id);\r\n\t\t} catch (SQLException e) {\r\n\t\t\tthrow new DatabaseException(e);\r\n\t\t}\r\n\t\t\r\n    }", "category": "Python"}, {"instruction": "ZAP: New method checking for connection upgrade.\n\n@return True if this connection should be upgraded to WebSockets.", "input": "Java", "output": "public boolean isWebSocketUpgrade() {\r\n\t\tif (!getResponseHeader().isEmpty()) {\r\n\t\t\tString connectionHeader = getResponseHeader().getHeader(\"connection\");\r\n\t\t\tString upgradeHeader = getResponseHeader().getHeader(\"upgrade\");\r\n\t\t\t\r\n\t\t\tif (connectionHeader != null && connectionHeader.equalsIgnoreCase(\"upgrade\")) {\r\n\t\t\t\tif (upgradeHeader != null && upgradeHeader.equalsIgnoreCase(\"websocket\")) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}", "category": "Python"}, {"instruction": "Removes duplicate deterministic expressions. Preserves the relative order\nof the expressions in the list.", "input": "Java", "output": "private List<RowExpression> removeDuplicates(List<RowExpression> expressions)\n    {\n        Set<RowExpression> seen = new HashSet<>();\n\n        ImmutableList.Builder<RowExpression> result = ImmutableList.builder();\n        for (RowExpression expression : expressions) {\n            if (!determinismEvaluator.isDeterministic(expression)) {\n                result.add(expression);\n            }\n            else if (!seen.contains(expression)) {\n                result.add(expression);\n                seen.add(expression);\n            }\n        }\n\n        return result.build();\n    }", "category": "Python"}, {"instruction": "Gets a list from an object for the given key.  If the key is not present, this returns null.\nIf the value is not a List, throws an exception.", "input": "Java", "output": "@SuppressWarnings(\"unchecked\")\n  @Nullable\n  static List<?> getList(Map<String, ?> obj, String key) {\n    assert key != null;\n    if (!obj.containsKey(key)) {\n      return null;\n    }\n    Object value = obj.get(key);\n    if (!(value instanceof List)) {\n      throw new ClassCastException(\n          String.format(\"value '%s' for key '%s' in '%s' is not List\", value, key, obj));\n    }\n    return (List<?>) value;\n  }", "category": "Python"}, {"instruction": "(and return Long.MIN_VALUE but this is a valid long return value).", "input": "Java", "output": "private static Long attemptUUIDParseLow(BufferedString str) {\n    final byte[] buf = str.getBuffer();\n    int i=str.getOffset();\n    if( i+36 > buf.length ) return markBad(str);\n    long lo=0;\n    lo = get2(lo,buf,(i+=2)-2);\n    lo = get2(lo,buf,(i+=2)-2);\n    lo = get2(lo,buf,(i+=2)-2);\n    lo = get2(lo,buf,(i+=2)-2);\n    if( buf[i++]!='-' ) return markBad(str);\n    lo = get2(lo,buf,(i+=2)-2);\n    lo = get2(lo,buf,(i+=2)-2);\n    if( buf[i++]!='-' ) return markBad(str);\n    lo = get2(lo,buf,(i+=2)-2);\n    return attemptUUIDParseEnd(str, lo, buf, i);\n  }", "category": "Python"}, {"instruction": "Auto-widen the scalar to every element of the frame", "input": "Java", "output": "private ValFrame scalar_op_frame(final double d, Frame fr) {\n    Frame res = new MRTask() {\n      @Override\n      public void map(Chunk[] chks, NewChunk[] cress) {\n        for (int c = 0; c < chks.length; c++) {\n          Chunk chk = chks[c];\n          NewChunk cres = cress[c];\n          for (int i = 0; i < chk._len; i++)\n            cres.addNum(op(d, chk.atd(i)));\n        }\n      }\n    }.doAll(fr.numCols(), Vec.T_NUM, fr).outputFrame(fr._names, null);\n    return cleanCategorical(fr, res); // Cleanup categorical misuse\n  }", "category": "Python"}, {"instruction": "Sets the deprecation status of an image.\n\n<p>If an empty request body is given, clears the deprecation status instead.\n\n<p>Sample code:\n\n<pre><code>\ntry (ImageClient imageClient = ImageClient.create()) {\nProjectGlobalImageName image = ProjectGlobalImageName.of(\"[PROJECT]\", \"[IMAGE]\");\nDeprecationStatus deprecationStatusResource = DeprecationStatus.newBuilder().build();\nOperation response = imageClient.deprecateImage(image, deprecationStatusResource);\n}\n</code></pre>\n\n@param image Image name.\n@param deprecationStatusResource Deprecation status for a public resource.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation deprecateImage(\n      ProjectGlobalImageName image, DeprecationStatus deprecationStatusResource) {\n\n    DeprecateImageHttpRequest request =\n        DeprecateImageHttpRequest.newBuilder()\n            .setImage(image == null ? null : image.toString())\n            .setDeprecationStatusResource(deprecationStatusResource)\n            .build();\n    return deprecateImage(request);\n  }", "category": "Python"}, {"instruction": "\u8fd4\u56de\u6240\u6709\u5b9e\u4f8b curl http://127.0.0.1:8081/destinations", "input": "Java", "output": "@GetMapping(\"/destinations\")\n    public List<Map<String, String>> destinations() {\n        List<Map<String, String>> result = new ArrayList<>();\n        Set<String> destinations = adapterCanalConfig.DESTINATIONS;\n        for (String destination : destinations) {\n            Map<String, String> resMap = new LinkedHashMap<>();\n            boolean status = syncSwitch.status(destination);\n            String resStatus;\n            if (status) {\n                resStatus = \"on\";\n            } else {\n                resStatus = \"off\";\n            }\n            resMap.put(\"destination\", destination);\n            resMap.put(\"status\", resStatus);\n            result.add(resMap);\n        }\n        return result;\n    }", "category": "Python"}, {"instruction": "Poll for a task of a certain type.\n\n@param taskType Task name\n@param workerId Id of the workflow\n@param domain   Domain of the workflow\n@return polled {@link Task}", "input": "Java", "output": "@Service\n    public Task poll(String taskType, String workerId, String domain) {\n        LOGGER.debug(\"Task being polled: /tasks/poll/{}?{}&{}\", taskType, workerId, domain);\n        Task task = executionService.getLastPollTask(taskType, workerId, domain);\n        if (task != null) {\n            LOGGER.debug(\"The Task {} being returned for /tasks/poll/{}?{}&{}\", task, taskType, workerId, domain);\n        }\n        Monitors.recordTaskPollCount(taskType, domain, 1);\n        return task;\n    }", "category": "Python"}, {"instruction": "\u5c06\u952e\u503c\u5bf9\u52a0\u5165\u5230\u5bf9\u5e94\u5206\u7ec4\u4e2d\n\n@param group \u5206\u7ec4\n@param key \u952e\n@param value \u503c\n@return \u6b64key\u4e4b\u524d\u5b58\u5728\u7684\u503c\uff0c\u5982\u679c\u6ca1\u6709\u8fd4\u56denull", "input": "Java", "output": "public String put(String group, String key, String value) {\r\n\t\tgroup = StrUtil.nullToEmpty(group).trim();\r\n\t\twriteLock.lock();\r\n\t\ttry {\r\n\t\t\tLinkedHashMap<String, String> valueMap = this.get(group);\r\n\t\t\tif (null == valueMap) {\r\n\t\t\t\tvalueMap = new LinkedHashMap<>();\r\n\t\t\t\tthis.put(group, valueMap);\r\n\t\t\t}\r\n\t\t\tthis.size = -1;\r\n\t\t\treturn valueMap.put(key, value);\r\n\t\t} finally {\r\n\t\t\twriteLock.unlock();\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "Specifies a writer instance that caches should notify each time an entry is explicitly created\nor modified, or removed for any {@linkplain RemovalCause reason}. The writer is not notified\nwhen an entry is loaded or computed. Each cache created by this builder will invoke this writer\nas part of the atomic operation that modifies the cache.\n<p>\n<b>Warning:</b> after invoking this method, do not continue to use <i>this</i> cache builder\nreference; instead use the reference this method <i>returns</i>. At runtime, these point to the\nsame instance, but only the returned reference has the correct generic type information so as\nto ensure type safety. For best results, use the standard method-chaining idiom illustrated in\nthe class documentation above, configuring a builder and building your cache in a single\nstatement. Failure to heed this advice can result in a {@link ClassCastException} being thrown\nby a cache operation at some <i>undefined</i> point in the future.\n<p>\n<b>Warning:</b> any exception thrown by {@code writer} will be propagated to the {@code Cache}\nuser.\n<p>\nThis feature cannot be used in conjunction with {@link #weakKeys()} or {@link #buildAsync}.\n\n@param writer a writer instance that caches should notify each time an entry is explicitly\ncreated or modified, or removed for any reason\n@param <K1> the key type of the writer\n@param <V1> the value type of the writer\n@return the cache builder reference that should be used instead of {@code this} for any\nremaining configuration and cache building\n@throws IllegalStateException if a writer was already set or if the key strength is weak\n@throws NullPointerException if the specified writer is null", "input": "Java", "output": "@NonNull\n  public <K1 extends K, V1 extends V> Caffeine<K1, V1> writer(\n      @NonNull CacheWriter<? super K1, ? super V1> writer) {\n    requireState(this.writer == null, \"Writer was already set to %s\", this.writer);\n    requireState(keyStrength == null, \"Weak keys may not be used with CacheWriter\");\n\n    @SuppressWarnings(\"unchecked\")\n    Caffeine<K1, V1> self = (Caffeine<K1, V1>) this;\n    self.writer = requireNonNull(writer);\n    return self;\n  }", "category": "Python"}, {"instruction": "Get layer output type.\n\n@param inputType Array of InputTypes\n@return output type as InputType\n@throws InvalidKerasConfigurationException Invalid Keras config", "input": "Java", "output": "@Override\n    public InputType getOutputType(InputType... inputType) throws InvalidKerasConfigurationException {\n        if (inputType.length > 1)\n            throw new InvalidKerasConfigurationException(\n                    \"Keras SimpleRnn layer accepts only one input (received \" + inputType.length + \")\");\n        InputPreProcessor preProcessor = getInputPreprocessor(inputType);\n        if (preProcessor != null)\n            return preProcessor.getOutputType(inputType[0]);\n        else\n            return this.getSimpleRnnLayer().getOutputType(-1, inputType[0]);\n    }", "category": "Python"}, {"instruction": "Register an application with its secret.\nExecutors need to first authenticate themselves with the same secret before\nfetching shuffle files written by other executors in this application.", "input": "Java", "output": "public void registerApp(String appId, String shuffleSecret) {\n    // Always put the new secret information to make sure it's the most up to date.\n    // Otherwise we have to specifically look at the application attempt in addition\n    // to the applicationId since the secrets change between application attempts on yarn.\n    shuffleSecretMap.put(appId, shuffleSecret);\n    logger.info(\"Registered shuffle secret for application {}\", appId);\n  }", "category": "Python"}, {"instruction": "\u5207\u53d6\u90e8\u5206\u6570\u636e<br>\n\u5207\u53d6\u540e\u7684\u6808\u5c06\u51cf\u5c11\u8fd9\u4e9b\u5143\u7d20\n\n@param <T> \u96c6\u5408\u5143\u7d20\u7c7b\u578b\n@param surplusAlaDatas \u539f\u6570\u636e\n@param partSize \u6bcf\u90e8\u5206\u6570\u636e\u7684\u957f\u5ea6\n@return \u5207\u53d6\u51fa\u7684\u6570\u636e\u6216null", "input": "Java", "output": "public static <T> List<T> popPart(Stack<T> surplusAlaDatas, int partSize) {\r\n\t\tif (isEmpty(surplusAlaDatas)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tfinal List<T> currentAlaDatas = new ArrayList<>();\r\n\t\tint size = surplusAlaDatas.size();\r\n\t\t// \u5207\u5272\r\n\t\tif (size > partSize) {\r\n\t\t\tfor (int i = 0; i < partSize; i++) {\r\n\t\t\t\tcurrentAlaDatas.add(surplusAlaDatas.pop());\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = 0; i < size; i++) {\r\n\t\t\t\tcurrentAlaDatas.add(surplusAlaDatas.pop());\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn currentAlaDatas;\r\n\t}", "category": "Python"}, {"instruction": "Generates a new secure-random secret key of a length suitable for creating and verifying HMAC signatures\naccording to the specified {@code SignatureAlgorithm} using the specified SecureRandom number generator.  This\nimplementation returns secure-random key sizes as follows:\n\n<table> <caption>Key Sizes</caption> <thead> <tr> <th>Signature Algorithm</th> <th>Generated Key Size</th> </tr> </thead> <tbody> <tr>\n<td>HS256</td> <td>256 bits (32 bytes)</td> </tr> <tr> <td>HS384</td> <td>384 bits (48 bytes)</td> </tr> <tr>\n<td>HS512</td> <td>512 bits (64 bytes)</td> </tr> </tbody> </table>\n\n@param alg    the signature algorithm that will be used with the generated key\n@param random the secure random number generator used during key generation\n@return a new secure-random secret key of a length suitable for creating and verifying HMAC signatures according\nto the specified {@code SignatureAlgorithm} using the specified SecureRandom number generator.\n@see #generateKey()\n@see #generateKey(SignatureAlgorithm)\n@since 0.5\n@deprecated since 0.10.0 - use {@link #generateKey(SignatureAlgorithm)} instead.", "input": "Java", "output": "@Deprecated\n    public static SecretKey generateKey(SignatureAlgorithm alg, SecureRandom random) {\n\n        Assert.isTrue(alg.isHmac(), \"SignatureAlgorithm argument must represent an HMAC algorithm.\");\n\n        KeyGenerator gen;\n\n        try {\n            gen = KeyGenerator.getInstance(alg.getJcaName());\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"The \" + alg.getJcaName() + \" algorithm is not available.  \" +\n                \"This should never happen on JDK 7 or later - please report this to the JJWT developers.\", e);\n        }\n\n        return gen.generateKey();\n    }", "category": "Python"}, {"instruction": "Merge this configuration with the specified {@link GridHubConfiguration}\n@param other", "input": "Java", "output": "public void merge(GridHubConfiguration other) {\n    if (other == null) {\n      return;\n    }\n    super.merge(other);\n\n    if (isMergeAble(CapabilityMatcher.class, other.capabilityMatcher, capabilityMatcher)) {\n      capabilityMatcher = other.capabilityMatcher;\n    }\n    if (isMergeAble(Integer.class, other.newSessionWaitTimeout, newSessionWaitTimeout)) {\n      newSessionWaitTimeout = other.newSessionWaitTimeout;\n    }\n    if (isMergeAble(Prioritizer.class, other.prioritizer, prioritizer)) {\n      prioritizer = other.prioritizer;\n    }\n    if (isMergeAble(Boolean.class, other.throwOnCapabilityNotPresent, throwOnCapabilityNotPresent)) {\n      throwOnCapabilityNotPresent = other.throwOnCapabilityNotPresent;\n    }\n    if (isMergeAble(String.class, other.registry, registry)) {\n      registry = other.registry;\n    }\n  }", "category": "Python"}, {"instruction": "------------------------------------------------------------------------", "input": "Java", "output": "@Override\n\tpublic JobExecutionResult execute(String jobName) throws Exception {\n\t\tPlanExecutor executor = getExecutor();\n\n\t\tPlan p = createProgramPlan(jobName);\n\n\t\t// Session management is disabled, revert this commit to enable\n\t\t//p.setJobId(jobID);\n\t\t//p.setSessionTimeout(sessionTimeout);\n\n\t\tJobExecutionResult result = executor.executePlan(p);\n\n\t\tthis.lastJobExecutionResult = result;\n\t\treturn result;\n\t}", "category": "Python"}, {"instruction": "Return the currently-active lock posses for some task.\n\n@param task task for which to locate locks", "input": "Java", "output": "private List<TaskLockPosse> findLockPossesForTask(final Task task)\n  {\n    giant.lock();\n\n    try {\n      // Scan through all locks for this datasource\n      final NavigableMap<DateTime, SortedMap<Interval, List<TaskLockPosse>>> dsRunning = running.get(task.getDataSource());\n      if (dsRunning == null) {\n        return ImmutableList.of();\n      } else {\n        return dsRunning.values().stream()\n                        .flatMap(map -> map.values().stream())\n                        .flatMap(Collection::stream)\n                        .filter(taskLockPosse -> taskLockPosse.containsTask(task))\n                        .collect(Collectors.toList());\n      }\n    }\n    finally {\n      giant.unlock();\n    }\n  }", "category": "Python"}, {"instruction": "Method that assigns a unique {@link Long} value to all elements in the input data set as described below.\n<ul>\n<li> a map function is applied to the input data set\n<li> each map task holds a counter c which is increased for each record\n<li> c is shifted by n bits where n = log2(number of parallel tasks)\n<li> to create a unique ID among all tasks, the task id is added to the counter\n<li> for each record, the resulting counter is collected\n</ul>\n\n@param input the input data set\n@return a data set of tuple 2 consisting of ids and initial values.", "input": "Java", "output": "public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {\n\n\t\treturn input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {\n\n\t\t\tlong maxBitSize = getBitSize(Long.MAX_VALUE);\n\t\t\tlong shifter = 0;\n\t\t\tlong start = 0;\n\t\t\tlong taskId = 0;\n\t\t\tlong label = 0;\n\n\t\t\t@Override\n\t\t\tpublic void open(Configuration parameters) throws Exception {\n\t\t\t\tsuper.open(parameters);\n\t\t\t\tshifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1);\n\t\t\t\ttaskId = getRuntimeContext().getIndexOfThisSubtask();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {\n\t\t\t\tfor (T value : values) {\n\t\t\t\t\tlabel = (start << shifter) + taskId;\n\n\t\t\t\t\tif (getBitSize(start) + shifter < maxBitSize) {\n\t\t\t\t\t\tout.collect(new Tuple2<>(label, value));\n\t\t\t\t\t\tstart++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Exception(\"Exceeded Long value range while generating labels\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}", "category": "Python"}, {"instruction": "Used to reset a reset a reader group to a checkpoint. This should be removed in time.\n@deprecated Use {@link ReaderGroup#resetReaderGroup(ReaderGroupConfig)} to reset readers to a given Checkpoint.", "input": "Java", "output": "@Override\n    @Deprecated\n    public void resetReadersToCheckpoint(Checkpoint checkpoint) {\n        synchronizer.updateState((state, updates) -> {\n            ReaderGroupConfig config = state.getConfig();\n            Map<Segment, Long> positions = new HashMap<>();\n            for (StreamCut cut : checkpoint.asImpl().getPositions().values()) {\n                positions.putAll(cut.asImpl().getPositions());\n            }\n            updates.add(new ReaderGroupStateInit(config, positions, getEndSegmentsForStreams(config)));\n        });\n    }", "category": "Python"}, {"instruction": "Determine consent event string.\n\n@param requestContext the request context\n@return the string", "input": "Java", "output": "protected String determineConsentEvent(final RequestContext requestContext) {\n        val webService = WebUtils.getService(requestContext);\n        val service = this.authenticationRequestServiceSelectionStrategies.resolveService(webService);\n        if (service == null) {\n            return null;\n        }\n\n        val registeredService = getRegisteredServiceForConsent(requestContext, service);\n\n        val authentication = WebUtils.getAuthentication(requestContext);\n        if (authentication == null) {\n            return null;\n        }\n\n        return isConsentRequired(service, registeredService, authentication, requestContext);\n    }", "category": "Python"}, {"instruction": "get the last reference invoke information\n\n@param clear true: framework will clear the ThreadLocal when return\n@return RPC Reference Context, it can be null", "input": "Java", "output": "public static RpcReferenceContext lastReferenceContext(boolean clear) {\n        try {\n            RpcInvokeContext invokeCtx = RpcInvokeContext.getContext();\n            RpcReferenceContext referenceCtx = (RpcReferenceContext) invokeCtx\n                .get(RemotingConstants.INVOKE_CTX_RPC_REF_CTX);\n            if (referenceCtx != null) {\n                String resultCode = (String) invokeCtx.get(RemotingConstants.INVOKE_CTX_RPC_RESULT_CODE);\n                if (resultCode != null) {\n                    referenceCtx.setResultCode(ResultCodeEnum.getResultCode(resultCode));\n                }\n            }\n            return referenceCtx;\n        } finally {\n            if (clear) {\n                clearReferenceContext();\n            }\n        }\n    }", "category": "Python"}, {"instruction": "init fxml when loaded.", "input": "Java", "output": "@PostConstruct\n    public void init() {\n        validatedText.focusedProperty().addListener((o, oldVal, newVal) -> {\n            if (!newVal) {\n                validatedText.validate();\n            }\n        });\n        validatedPassowrd.focusedProperty().addListener((o, oldVal, newVal) -> {\n            if (!newVal) {\n                validatedPassowrd.validate();\n            }\n        });\n        jfxTextArea.focusedProperty().addListener((o, oldVal, newVal) -> {\n            if (!newVal) {\n                jfxTextArea.validate();\n            }\n        });\n    }", "category": "Python"}, {"instruction": "Compute the ideal deadline, set subsequent modacks to this deadline, and return it.", "input": "Java", "output": "@InternalApi\n  int computeDeadlineSeconds() {\n    int sec = ackLatencyDistribution.getPercentile(PERCENTILE_FOR_ACK_DEADLINE_UPDATES);\n\n    // Use Ints.constrainToRange when we get guava 21.\n    if (sec < Subscriber.MIN_ACK_DEADLINE_SECONDS) {\n      sec = Subscriber.MIN_ACK_DEADLINE_SECONDS;\n    } else if (sec > Subscriber.MAX_ACK_DEADLINE_SECONDS) {\n      sec = Subscriber.MAX_ACK_DEADLINE_SECONDS;\n    }\n    return sec;\n  }", "category": "Python"}, {"instruction": "This method should not be public so as to not expose internals to user code.", "input": "Java", "output": "@Override\n\tOperatorStateHandle closeAndGetHandle() throws IOException {\n\t\tStreamStateHandle streamStateHandle = delegate.closeAndGetHandle();\n\n\t\tif (null == streamStateHandle) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (partitionOffsets.isEmpty() && delegate.getPos() > initialPosition) {\n\t\t\tstartNewPartition();\n\t\t}\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> offsetsMap = new HashMap<>(1);\n\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tpartitionOffsets.toArray(),\n\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\n\t\toffsetsMap.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\treturn new OperatorStreamStateHandle(offsetsMap, streamStateHandle);\n\t}", "category": "Python"}, {"instruction": "Maintains backwards compatibility. Invoked by XStream when this object is de-serialized.", "input": "Java", "output": "@SuppressWarnings({\"unused\"})\n    private Object readResolve() {\n        if (jdks == null) {\n            jdks = new ArrayList<>();\n        }\n        if (SLAVE_AGENT_PORT_ENFORCE) {\n            slaveAgentPort = getSlaveAgentPortInitialValue(slaveAgentPort);\n        }\n        if (disabledAgentProtocols == null && _disabledAgentProtocols != null) {\n            disabledAgentProtocols = Arrays.asList(_disabledAgentProtocols);\n            _disabledAgentProtocols = null;\n        }\n        if (enabledAgentProtocols == null && _enabledAgentProtocols != null) {\n            enabledAgentProtocols = Arrays.asList(_enabledAgentProtocols);\n            _enabledAgentProtocols = null;\n        }\n        // Invalidate the protocols cache after the reload\n        agentProtocols = null;\n        return this;\n    }", "category": "Python"}, {"instruction": "Computes how much of the queue can be filled by splits with the network topology distance to a node given by\nsplitAffinity. A split with zero affinity can only fill half the queue, whereas one that matches\nexactly can fill the entire queue.", "input": "Java", "output": "private int calculateMaxPendingSplits(int splitAffinity, int totalDepth)\n    {\n        if (totalDepth == 0) {\n            return maxPendingSplitsPerTask;\n        }\n        // Use half the queue for any split\n        // Reserve the other half for splits that have some amount of network affinity\n        double queueFraction = 0.5 * (1.0 + splitAffinity / (double) totalDepth);\n        return (int) Math.ceil(maxPendingSplitsPerTask * queueFraction);\n    }", "category": "Python"}, {"instruction": "Gets the action (first instance to be found) of a specified type that contributed to this build.\n\n@param type\n@return The action or <code>null</code> if no such actions exist.\n@see #getActions(Class)", "input": "Java", "output": "public <T extends Action> T getAction(Class<T> type) {\n        // Shortcut: if the persisted list has one, return it.\n        for (Action a : getActions()) {\n            if (type.isInstance(a)) {\n                return type.cast(a);\n            }\n        }\n        // Otherwise check transient factories.\n        for (TransientActionFactory<?> taf : TransientActionFactory.factoriesFor(getClass(), type)) {\n            for (Action a : createFor(taf)) {\n                if (type.isInstance(a)) {\n                    return type.cast(a);\n                }\n            }\n        }\n        return null;\n    }", "category": "Python"}, {"instruction": "MD5\u52a0\u5bc6\u6587\u4ef6\n\n@param file \u6587\u4ef6\n@return \u6587\u4ef6\u7684MD5\u6821\u9a8c\u7801", "input": "Java", "output": "public static byte[] md5FileToByte(File file) {\n        if (file == null) return null;\n        FileInputStream   fis               = null;\n        DigestInputStream digestInputStream = null;\n        try {\n            fis = new FileInputStream(file);\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            digestInputStream = new DigestInputStream(fis, md);\n            byte[] buffer = new byte[256 * 1024];\n            while (digestInputStream.read(buffer) > 0) ;\n            md = digestInputStream.getMessageDigest();\n            return md.digest();\n        } catch (NoSuchAlgorithmException | IOException e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            IOKit.closeQuietly(fis);\n            IOKit.closeQuietly(digestInputStream);\n        }\n    }", "category": "Python"}, {"instruction": "This method returns 2D array, where each row represents corresponding label\n\n@param labels\n@return", "input": "Java", "output": "@Override\n    public INDArray getWordVectors(@NonNull Collection<String> labels) {\n        int indexes[] = new int[labels.size()];\n        int cnt = 0;\n        boolean useIndexUnknown = useUnknown && vocab.containsWord(getUNK());\n\n        for (String label : labels) {\n            if (vocab.containsWord(label)) {\n                indexes[cnt] = vocab.indexOf(label);\n            } else\n                indexes[cnt] = useIndexUnknown ? vocab.indexOf(getUNK()) : -1;\n            cnt++;\n        }\n\n        while (ArrayUtils.contains(indexes, -1)) {\n            indexes = ArrayUtils.removeElement(indexes, -1);\n        }\n        if (indexes.length == 0) {\n                return Nd4j.empty(((InMemoryLookupTable)lookupTable).getSyn0().dataType());\n        }\n\n        INDArray result = Nd4j.pullRows(lookupTable.getWeights(), 1, indexes);\n        return result;\n    }", "category": "Python"}, {"instruction": "This method updates VocabCache and all it's elements with Huffman indexes\nPlease note: it should be the same VocabCache as was used for Huffman tree initialization\n\n@param cache VocabCache to be updated.", "input": "Java", "output": "public void applyIndexes(VocabCache<? extends SequenceElement> cache) {\n        if (!buildTrigger)\n            build();\n\n        for (int a = 0; a < words.size(); a++) {\n            if (words.get(a).getLabel() != null) {\n                cache.addWordToIndex(a, words.get(a).getLabel());\n            } else {\n                cache.addWordToIndex(a, words.get(a).getStorageId());\n            }\n\n            words.get(a).setIndex(a);\n        }\n    }", "category": "Python"}, {"instruction": "This should be overriden for any custom columns", "input": "Java", "output": "@Override\n\tpublic Object getValueAt(int row, int col) {\n\t\t// Get the href and the required field\n\t\tHistoryReference href = hrefList.get(row);\n\t\ttry {\n\t\t\tswitch (this.columns[col]) {\n\t\t\tcase HREF_ID:\t\treturn href.getHistoryId();\n\t\t\tcase TYPE_FLAG:\t\treturn this.getHrefTypeIcon(href);\n\t\t\tcase METHOD:\t\treturn href.getMethod();\n\t\t\tcase URL:\t\t\treturn href.getURI().toString();\n\t\t\tcase CODE:\t\t\treturn href.getStatusCode();\n\t\t\tcase REASON:\t\treturn href.getReason();\n\t\t\tcase RTT:\t\t\treturn href.getRtt();\n\t\t\tcase SIZE:\t\t\treturn href.getResponseBodyLength();\n\t\t\tcase SESSION_ID:\treturn href.getSessionId();\n\t\t\tcase ALERT_FLAG:\treturn this.getHrefAlertIcon(href);\n\t\t\tcase TAGS:\t\t\treturn listToCsv(href.getTags());\n\t\t\tdefault:\t\t\treturn null;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(e.getMessage(), e);\n\t\t\treturn null;\n\t\t}\n\t}", "category": "Python"}, {"instruction": "\u6784\u5efa\u67e5\u8be2\u8ba2\u5355\u53c2\u6570\n\n@return <Map<String, String>>", "input": "Java", "output": "public Map<String, String> orderQueryBuild() {\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tif (getPayModel().equals(PayModel.SERVICEMODE)) {\n\t\t\tmap.put(\"sub_mch_id\", getSubMchId());\n\t\t\tmap.put(\"sub_appid\", getSubAppId());\n\t\t}\n\n\t\tmap.put(\"appid\", getAppId());\n\t\tmap.put(\"mch_id\", getMchId());\n\n\t\tif (StrKit.notBlank(getTransactionId())) {\n\t\t\tmap.put(\"transaction_id\", getTransactionId());\n\t\t} else {\n\t\t\tif (StrKit.isBlank(getOutTradeNo())) {\n\t\t\t\tthrow new IllegalArgumentException(\"out_trade_no,transaction_id \u4e0d\u80fd\u540c\u65f6\u4e3a\u7a7a\");\n\t\t\t}\n\t\t\tmap.put(\"out_trade_no\", getOutTradeNo());\n\t\t}\n\t\tmap.put(\"nonce_str\", String.valueOf(System.currentTimeMillis()));\n\t\tmap.put(\"sign\", PaymentKit.createSign(map, getPaternerKey()));\n\t\treturn map;\n\t}", "category": "Python"}, {"instruction": "Try to instantiate the given class.\n\n@param name        The class name\n@param classLoader The class loader to use\n@return The instantiated instance or {@link Optional#empty()}", "input": "Java", "output": "public static Optional<?> tryInstantiate(String name, ClassLoader classLoader) {\n        try {\n            return ClassUtils.forName(name, classLoader)\n                .flatMap(InstantiationUtils::tryInstantiate);\n        } catch (Throwable e) {\n            Logger log = LoggerFactory.getLogger(InstantiationUtils.class);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Tried, but could not instantiate type: \" + name, e);\n            }\n            return Optional.empty();\n        }\n    }", "category": "Python"}, {"instruction": "/* Helper method to fetch flow priority from flow props", "input": "Java", "output": "private int getPriority(final ExecutableFlow exflow) {\n    final ExecutionOptions options = exflow.getExecutionOptions();\n    int priority = ExecutionOptions.DEFAULT_FLOW_PRIORITY;\n    if (options != null\n        && options.getFlowParameters() != null\n        && options.getFlowParameters()\n        .containsKey(ExecutionOptions.FLOW_PRIORITY)) {\n      try {\n        priority =\n            Integer.valueOf(options.getFlowParameters().get(\n                ExecutionOptions.FLOW_PRIORITY));\n      } catch (final NumberFormatException ex) {\n        priority = ExecutionOptions.DEFAULT_FLOW_PRIORITY;\n        logger.error(\n            \"Failed to parse flow priority for exec_id = \"\n                + exflow.getExecutionId(), ex);\n      }\n    }\n    return priority;\n  }", "category": "Python"}, {"instruction": "Returns all unsaved resources of the given {@code addOns} and {@code extensions} wrapped in {@code <li>} elements or an\nempty {@code String} if there are no unsaved resources.\n\n@param addOns the add-ons that will be queried for unsaved resources\n@param extensions the extensions that will be queried for unsaved resources\n@return a {@code String} containing all unsaved resources or empty {@code String} if none\n@since 2.4.0\n@see Extension#getUnsavedResources()", "input": "Java", "output": "private static String getExtensionsUnsavedResources(Collection<AddOn> addOns, Set<Extension> extensions) {\n        List<String> unsavedResources = new ArrayList<>();\n        for (AddOn addOn : addOns) {\n            for (Extension extension : addOn.getLoadedExtensions()) {\n                if (!extension.isEnabled()) {\n                    continue;\n                }\n\n                List<String> resources = extension.getUnsavedResources();\n                if (resources != null) {\n                    unsavedResources.addAll(resources);\n                }\n            }\n        }\n        for (Extension extension : extensions) {\n            if (!extension.isEnabled()) {\n                continue;\n            }\n\n            List<String> resources = extension.getUnsavedResources();\n            if (resources != null) {\n                unsavedResources.addAll(resources);\n            }\n        }\n        return wrapEntriesInLiTags(unsavedResources);\n    }", "category": "Python"}, {"instruction": "\u83b7\u5f97\u7ed3\u679c\u96c6\u7684\u6240\u6709\u5217\u540d\n\n@param rs \u7ed3\u679c\u96c6\n@return \u5217\u540d\u6570\u7ec4\n@throws DbRuntimeException SQL\u6267\u884c\u5f02\u5e38", "input": "Java", "output": "public static String[] getColumnNames(ResultSet rs) throws DbRuntimeException {\r\n\t\ttry {\r\n\t\t\tResultSetMetaData rsmd = rs.getMetaData();\r\n\t\t\tint columnCount = rsmd.getColumnCount();\r\n\t\t\tString[] labelNames = new String[columnCount];\r\n\t\t\tfor (int i = 0; i < labelNames.length; i++) {\r\n\t\t\t\tlabelNames[i] = rsmd.getColumnLabel(i + 1);\r\n\t\t\t}\r\n\t\t\treturn labelNames;\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new DbRuntimeException(\"Get colunms error!\", e);\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "Returns staged predictions of tree algorithms (prediction probabilities of trees per iteration).\nThe output structure is for tree Tt and class Cc:\nBinomial models: [probability T1.C1, probability T2.C1, ..., Tt.C1] where Tt.C1 correspond to the the probability p0\nMultinomial models: [probability T1.C1, probability T1.C2, ..., Tt.Cc]\n@param row Input row.\n@param predsLength Length of prediction result.\n@return array of staged prediction probabilities", "input": "Java", "output": "public double[] scoreStagedPredictions(double[] row, int predsLength) {\n        int contribOffset = nclasses() == 1 ? 0 : 1;\n        double[] trees_result = new double[_ntree_groups * _ntrees_per_group];\n\n        for (int groupIndex = 0; groupIndex < _ntree_groups; groupIndex++) {\n            double[] tmpPreds = new double[predsLength];\n            scoreTreeRange(row, 0, groupIndex+1, tmpPreds);\n            unifyPreds(row, 0, tmpPreds);\n            for (int classIndex = 0; classIndex < _ntrees_per_group; classIndex++) {\n                int tree_index = groupIndex * _ntrees_per_group + classIndex;\n                trees_result[tree_index] = tmpPreds[contribOffset+classIndex];\n            }\n        }\n        return trees_result;\n    }", "category": "Python"}, {"instruction": "Return 16-bit unsigned int from buffer. (little-endian)\n\n@see mysql-5.1.60/include/my_global.h - uint2korr", "input": "Java", "output": "public final int getUint16(final int pos) {\r\n        final int position = origin + pos;\r\n\r\n        if (pos + 1 >= limit || pos < 0) throw new IllegalArgumentException(\"limit excceed: \"\r\n                                                                            + (pos < 0 ? pos : (pos + 1)));\r\n\r\n        byte[] buf = buffer;\r\n        return (0xff & buf[position]) | ((0xff & buf[position + 1]) << 8);\r\n    }", "category": "Python"}, {"instruction": "\u8bc6\u522bJDBC\u9a71\u52a8\u540d\n\n@param ds \u6570\u636e\u6e90\n@return \u9a71\u52a8", "input": "Java", "output": "public static String identifyDriver(DataSource ds) {\r\n\t\tif(ds instanceof DataSourceWrapper) {\r\n\t\t\tfinal String driver = ((DataSourceWrapper)ds).getDriver();\r\n\t\t\tif(StrUtil.isNotBlank(driver)) {\r\n\t\t\t\treturn driver;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tConnection conn = null;\r\n\t\tString driver = null;\r\n\t\ttry {\r\n\t\t\ttry {\r\n\t\t\t\tconn = ds.getConnection();\r\n\t\t\t} catch (SQLException e) {\r\n\t\t\t\tthrow new DbRuntimeException(\"Get Connection error !\", e);\r\n\t\t\t} catch (NullPointerException e) {\r\n\t\t\t\tthrow new DbRuntimeException(\"Unexpected NullPointException, maybe [jdbcUrl] or [url] is empty!\", e);\r\n\t\t\t}\r\n\t\t\tdriver = identifyDriver(conn);\r\n\t\t} finally {\r\n\t\t\tDbUtil.close(conn);\r\n\t\t}\r\n\r\n\t\treturn driver;\r\n\t}", "category": "Python"}, {"instruction": "Extracts the Win32 error message from {@link Throwable} if possible.\n\n@return\nnull if there seems to be no error code or if the platform is not Win32.", "input": "Java", "output": "@CheckForNull\n    public static String getWin32ErrorMessage(Throwable e) {\n        String msg = e.getMessage();\n        if(msg!=null) {\n            Matcher m = errorCodeParser.matcher(msg);\n            if(m.matches()) {\n                try {\n                    ResourceBundle rb = ResourceBundle.getBundle(\"/hudson/win32errors\");\n                    return rb.getString(\"error\"+m.group(1));\n                } catch (Exception ignored) {\n                    // silently recover from resource related failures\n                }\n            }\n        }\n\n        if(e.getCause()!=null)\n            return getWin32ErrorMessage(e.getCause());\n        return null; // no message\n    }", "category": "Python"}, {"instruction": "Refresh the locally held version of {@link com.netflix.appinfo.AmazonInfo}", "input": "Java", "output": "public synchronized void refresh() {\n        try {\n            AmazonInfo newInfo = getNewAmazonInfo();\n\n            if (shouldUpdate(newInfo, info)) {\n                // the datacenter info has changed, re-sync it\n                logger.info(\"The AmazonInfo changed from : {} => {}\", info, newInfo);\n                this.info = newInfo;\n            }\n        } catch (Throwable t) {\n            logger.error(\"Cannot refresh the Amazon Info \", t);\n        }\n    }", "category": "Python"}, {"instruction": "Default value for {@link ToolInstallation#getProperties()} used in the form binding.\n@since 1.305", "input": "Java", "output": "public DescribableList<ToolProperty<?>,ToolPropertyDescriptor> getDefaultProperties() throws IOException {\n        DescribableList<ToolProperty<?>,ToolPropertyDescriptor> r\n                = new DescribableList<>(NOOP);\n\n        List<? extends ToolInstaller> installers = getDefaultInstallers();\n        if(!installers.isEmpty())\n            r.add(new InstallSourceProperty(installers));\n\n        return r;\n    }", "category": "Python"}, {"instruction": "Gets response mode type.\n\n@param context the context\n@return the response type", "input": "Java", "output": "public static OAuth20ResponseModeTypes getResponseModeType(final J2EContext context) {\n        val responseType = context.getRequestParameter(OAuth20Constants.RESPONSE_MODE);\n        val type = Arrays.stream(OAuth20ResponseModeTypes.values())\n            .filter(t -> t.getType().equalsIgnoreCase(responseType))\n            .findFirst()\n            .orElse(OAuth20ResponseModeTypes.NONE);\n        LOGGER.debug(\"OAuth response type is [{}]\", type);\n        return type;\n    }", "category": "Python"}, {"instruction": "gets quoted attribute value: QUOTATION *( quotechar / pair ) QUOTATION", "input": "Java", "output": "private String quotedAV() {\n    pos++;\n    beg = pos;\n    end = beg;\n    while (true) {\n\n      if (pos == length) {\n        throw new IllegalStateException(\"Unexpected end of DN: \" + dn);\n      }\n\n      if (chars[pos] == '\"') {\n        // enclosing quotation was found\n        pos++;\n        break;\n      } else if (chars[pos] == '\\\\') {\n        chars[end] = getEscaped();\n      } else {\n        // shift char: required for string with escaped chars\n        chars[end] = chars[pos];\n      }\n      pos++;\n      end++;\n    }\n\n    // skip trailing space chars before comma or semicolon.\n    // (compatibility with RFC 1779)\n    for (; pos < length && chars[pos] == ' '; pos++) {\n    }\n\n    return new String(chars, beg, end - beg);\n  }", "category": "Python"}, {"instruction": "\u6839\u636e\u540d\u5b57\u5728manager\u914d\u7f6e\u7684\u6620\u5c04\u5173\u7cfb\uff0c\u8f6c\u5316\u4e3a\u76ee\u6807\u7684\u5b57\u6bb5\u540d\u5b57", "input": "Java", "output": "private String translateColumnName(String srcColumnName, DataMediaPair dataMediaPair,\n                                       Multimap<String, String> translateDict) {\n        if (dataMediaPair.getColumnPairMode().isExclude() || CollectionUtils.isEmpty(dataMediaPair.getColumnPairs())) {\n            return srcColumnName; // \u9ed8\u8ba4\u540c\u540d\n        }\n\n        Collection<String> tColumnNames = translateDict.get(srcColumnName);\n        if (CollectionUtils.isEmpty(tColumnNames)) {\n            throw new TransformException(srcColumnName + \" is not found in column pairs: \" + translateDict.toString());\n        }\n        String columnName = tColumnNames.iterator().next();\n\n        return columnName;\n    }", "category": "Python"}, {"instruction": "------------------------------------------------------------------------", "input": "Java", "output": "private static String getAndCheckOption(Configuration config, ConfigOption<String> primaryOption, ConfigOption<String> fallbackOption) {\n\t\tString value = config.getString(primaryOption, config.getString(fallbackOption));\n\t\tif (value != null) {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalConfigurationException(\"The config option \" + primaryOption.key() +\n\t\t\t\t\t\" or \" + fallbackOption.key() + \" is missing.\");\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Get parameter sets.\n\n@param statement statement\n@return parameter sets", "input": "Java", "output": "public List<List<Object>> getParameterSet(final Statement statement) {\n        List<List<Object>> result = new LinkedList<>();\n        for (ShardingExecuteGroup<StatementExecuteUnit> each : getExecuteGroups()) {\n            Optional<StatementExecuteUnit> target = getStatementExecuteUnit(statement, each);\n            if (target.isPresent()) {\n                result = getParameterSets(target.get());\n                break;\n            }\n        }\n        return result;\n    }", "category": "Python"}, {"instruction": "returns the version of the backed up plugin,\nor null if there's no back up.", "input": "Java", "output": "@Exported\n    public String getBackupVersion() {\n        File backup = getBackupFile();\n        if (backup.exists()) {\n            try {\n                try (JarFile backupPlugin = new JarFile(backup)) {\n                    return backupPlugin.getManifest().getMainAttributes().getValue(\"Plugin-Version\");\n                }\n            } catch (IOException e) {\n                LOGGER.log(WARNING, \"Failed to get backup version from \" + backup, e);\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }", "category": "Python"}, {"instruction": "Handles expected Attribute-related exceptions. Since the attribute index is a separate segment from the main one,\nit is highly likely that it may get temporarily out of sync with the main one, thus causing spurious StreamSegmentSealedExceptions\nor StreamSegmentNotExistsExceptions. If we get either of those, and they are consistent with our current state, the\nwe can safely ignore them; otherwise we should be rethrowing them.", "input": "Java", "output": "private CompletableFuture<Void> handleAttributeException(CompletableFuture<Void> future) {\n        return Futures.exceptionallyExpecting(\n                future,\n                ex -> (ex instanceof StreamSegmentSealedException && this.metadata.isSealedInStorage())\n                        || ((ex instanceof StreamSegmentNotExistsException || ex instanceof StreamSegmentMergedException)\n                        && (this.metadata.isMerged() || this.metadata.isDeleted())),\n                null);\n    }", "category": "Python"}, {"instruction": "Opens the interactive CLI shell.", "input": "Java", "output": "public void open() {\n\t\tisRunning = true;\n\n\t\t// print welcome\n\t\tterminal.writer().append(CliStrings.MESSAGE_WELCOME);\n\n\t\t// begin reading loop\n\t\twhile (isRunning) {\n\t\t\t// make some space to previous command\n\t\t\tterminal.writer().append(\"\\n\");\n\t\t\tterminal.flush();\n\n\t\t\tfinal String line;\n\t\t\ttry {\n\t\t\t\tline = lineReader.readLine(prompt, null, (MaskingCallback) null, null);\n\t\t\t} catch (UserInterruptException e) {\n\t\t\t\t// user cancelled line with Ctrl+C\n\t\t\t\tcontinue;\n\t\t\t} catch (EndOfFileException | IOError e) {\n\t\t\t\t// user cancelled application with Ctrl+D or kill\n\t\t\t\tbreak;\n\t\t\t} catch (Throwable t) {\n\t\t\t\tthrow new SqlClientException(\"Could not read from command line.\", t);\n\t\t\t}\n\t\t\tif (line == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfinal Optional<SqlCommandCall> cmdCall = parseCommand(line);\n\t\t\tcmdCall.ifPresent(this::callCommand);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "When a ephemeral worker node disappears from ZK, incomplete running tasks will be retried by\nthe logic in the status listener. We still have to make sure there are no tasks assigned\nto the worker but not yet running.\n\n@param worker - the removed worker", "input": "Java", "output": "private void removeWorker(final Worker worker)\n  {\n    log.info(\"Kaboom! Worker[%s] removed!\", worker.getHost());\n\n    final ZkWorker zkWorker = zkWorkers.get(worker.getHost());\n    if (zkWorker != null) {\n      try {\n        scheduleTasksCleanupForWorker(worker.getHost(), getAssignedTasks(worker));\n      }\n      catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n      finally {\n        try {\n          zkWorker.close();\n        }\n        catch (Exception e) {\n          log.error(e, \"Exception closing worker[%s]!\", worker.getHost());\n        }\n        zkWorkers.remove(worker.getHost());\n        checkBlackListedNodes();\n      }\n    }\n    lazyWorkers.remove(worker.getHost());\n  }", "category": "Python"}, {"instruction": "\u63d0\u4f9b\u7cbe\u786e\u7684\u51cf\u6cd5\u8fd0\u7b97<br>\n\u5982\u679c\u4f20\u5165\u591a\u4e2a\u503c\u4e3anull\u6216\u8005\u7a7a\uff0c\u5219\u8fd4\u56de0\n\n@param values \u591a\u4e2a\u88ab\u51cf\u503c\n@return \u5dee\n@since 4.0.0", "input": "Java", "output": "public static BigDecimal sub(Number... values) {\r\n\t\tif (ArrayUtil.isEmpty(values)) {\r\n\t\t\treturn BigDecimal.ZERO;\r\n\t\t}\r\n\r\n\t\tNumber value = values[0];\r\n\t\tBigDecimal result = new BigDecimal(null == value ? \"0\" : value.toString());\r\n\t\tfor (int i = 1; i < values.length; i++) {\r\n\t\t\tvalue = values[i];\r\n\t\t\tif (null != value) {\r\n\t\t\t\tresult = result.subtract(new BigDecimal(value.toString()));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}", "category": "Python"}, {"instruction": "Text coming from an input stream considered as one document\n\n@param is    the input stream to read from\n@param label the label to assign\n@return a dataset with a applyTransformToDestination of weights(relative to impl; could be word counts or tfidf scores)", "input": "Java", "output": "@Override\n    public DataSet vectorize(InputStream is, String label) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n            String line = \"\";\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            return vectorize(builder.toString(), label);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }", "category": "Python"}, {"instruction": "Returns the cache as a {@link Maybe}.\n\n@param name The name of the cache to retrieve\n@return The cache as a {@link Single}", "input": "Java", "output": "@Read\n    public Maybe<Map<String, Object>> getCache(@NotBlank @Selector String name) {\n        try {\n            final Cache<Object> cache = cacheManager.getCache(name);\n            return Flowable.fromPublisher(cache.getCacheInfo())\n                           .map(CacheInfo::get)\n                           .singleElement();\n        } catch (ConfigurationException e) {\n            // no cache exists\n            return Maybe.empty();\n        }\n    }", "category": "Python"}, {"instruction": "Returns the caches as a {@link Single}.\n\n@return The caches as a {@link Single}", "input": "Java", "output": "@Read\n    public Single<Map<String, Object>> getCaches() {\n        return Flowable.fromIterable(cacheManager.getCacheNames())\n                       .flatMapMaybe(n -> Flowable.fromPublisher(cacheManager.getCache(n).getCacheInfo()).firstElement())\n                       .reduce(new HashMap<>(), (seed, info) -> {\n                           seed.put(info.getName(), info.get());\n                           return seed;\n                       }).map(objectObjectHashMap -> Collections.singletonMap(\n                           NAME, objectObjectHashMap\n                       ));\n    }", "category": "Python"}, {"instruction": "Scan for entities with the specified annotations.\n@param annotationTypes the annotation types used on the entities\n@return a set of entity classes\n@throws ClassNotFoundException if an entity class cannot be loaded", "input": "Java", "output": "@SafeVarargs\n\tpublic final Set<Class<?>> scan(Class<? extends Annotation>... annotationTypes)\n\t\t\tthrows ClassNotFoundException {\n\t\tList<String> packages = getPackages();\n\t\tif (packages.isEmpty()) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\tClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(\n\t\t\t\tfalse);\n\t\tscanner.setEnvironment(this.context.getEnvironment());\n\t\tscanner.setResourceLoader(this.context);\n\t\tfor (Class<? extends Annotation> annotationType : annotationTypes) {\n\t\t\tscanner.addIncludeFilter(new AnnotationTypeFilter(annotationType));\n\t\t}\n\t\tSet<Class<?>> entitySet = new HashSet<>();\n\t\tfor (String basePackage : packages) {\n\t\t\tif (StringUtils.hasText(basePackage)) {\n\t\t\t\tfor (BeanDefinition candidate : scanner\n\t\t\t\t\t\t.findCandidateComponents(basePackage)) {\n\t\t\t\t\tentitySet.add(ClassUtils.forName(candidate.getBeanClassName(),\n\t\t\t\t\t\t\tthis.context.getClassLoader()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn entitySet;\n\t}", "category": "Python"}, {"instruction": "Check if job is paused.\n\n@return true if job is paused, false otherwise.", "input": "Java", "output": "public synchronized boolean isJobPaused(final String jobName, final String groupName)\n      throws SchedulerException {\n    if (!ifJobExist(jobName, groupName)) {\n      throw new SchedulerException(String.format(\"Job (job name %s, group name %s) doesn't \"\n          + \"exist'\", jobName, groupName));\n    }\n    final JobKey jobKey = new JobKey(jobName, groupName);\n    final JobDetail jobDetail = this.scheduler.getJobDetail(jobKey);\n    final List<? extends Trigger> triggers = this.scheduler.getTriggersOfJob(jobDetail.getKey());\n    for (final Trigger trigger : triggers) {\n      final TriggerState triggerState = this.scheduler.getTriggerState(trigger.getKey());\n      if (TriggerState.PAUSED.equals(triggerState)) {\n        return true;\n      }\n    }\n    return false;\n  }", "category": "Python"}, {"instruction": "Returns an unmodifiable snapshot map ordered by the provided iterator. Beware that obtaining\nthe mappings is <em>NOT</em> a constant-time operation.\n\n@param iteratorSupplier the iterator\n@param limit the maximum number of entries\n@param transformer a function that unwraps the value\n@return an unmodifiable snapshot in the iterator's order", "input": "Java", "output": "Map<K, V> fixedSnapshot(Supplier<Iterator<Node<K, V>>> iteratorSupplier,\n      int limit, Function<V, V> transformer) {\n    requireArgument(limit >= 0);\n    evictionLock.lock();\n    try {\n      maintenance(/* ignored */ null);\n\n      int initialCapacity = Math.min(limit, size());\n      Iterator<Node<K, V>> iterator = iteratorSupplier.get();\n      Map<K, V> map = new LinkedHashMap<>(initialCapacity);\n      while ((map.size() < limit) && iterator.hasNext()) {\n        Node<K, V> node = iterator.next();\n        K key = node.getKey();\n        V value = transformer.apply(node.getValue());\n        if ((key != null) && (value != null) && node.isAlive()) {\n          map.put(key, value);\n        }\n      }\n      return Collections.unmodifiableMap(map);\n    } finally {\n      evictionLock.unlock();\n    }\n  }", "category": "Python"}, {"instruction": "\u5ba2\u6237\u7aef\u5df2\u7ecf\u8d85\u65f6\u4e86\uff08\u4f8b\u5982\u5728\u4e1a\u52a1\u6267\u884c\u65f6\u95f4\u592a\u957f\uff09\uff0c\u4e22\u5f03\u8fd9\u4e2a\u8fd4\u56de\u503c\n\n@param appName       \u5e94\u7528\n@param serviceName   \u670d\u52a1\n@param remoteAddress \u8fdc\u7a0b\u5730\u5740\n@return \u4e22\u5f03\u7684\u5f02\u5e38", "input": "Java", "output": "private SofaRpcException clientTimeoutWhenSendResponse(String appName, String serviceName, String remoteAddress) {\n        String errorMsg = LogCodes.getLog(\n            LogCodes.ERROR_DISCARD_TIMEOUT_RESPONSE, serviceName, remoteAddress);\n        if (LOGGER.isWarnEnabled(appName)) {\n            LOGGER.warnWithApp(appName, errorMsg);\n        }\n        return new SofaRpcException(RpcErrorType.SERVER_UNDECLARED_ERROR, errorMsg);\n    }", "category": "Python"}, {"instruction": "\u904d\u5386\u67d0\u4e2a\u76ee\u5f55\u4e0b\u6240\u6709\u6587\u4ef6\u6216\u76ee\u5f55\uff0c\u4e0d\u4f1a\u9012\u5f52\u904d\u5386\n\n@param path \u904d\u5386\u67d0\u4e2a\u76ee\u5f55\u4e0b\u6240\u6709\u6587\u4ef6\u6216\u76ee\u5f55\n@param filter \u6587\u4ef6\u6216\u76ee\u5f55\u8fc7\u6ee4\u5668\uff0c\u53ef\u4ee5\u5b9e\u73b0\u8fc7\u6ee4\u5668\u8fd4\u56de\u81ea\u5df1\u9700\u8981\u7684\u6587\u4ef6\u6216\u76ee\u5f55\u540d\u5217\u8868\n@return \u76ee\u5f55\u6216\u6587\u4ef6\u540d\u5217\u8868\n@since 4.0.5", "input": "Java", "output": "public List<String> ls(String path, final Filter<LsEntry> filter) {\r\n\t\tfinal List<String> fileNames = new ArrayList<>();\r\n\t\ttry {\r\n\t\t\tchannel.ls(path, new LsEntrySelector() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic int select(LsEntry entry) {\r\n\t\t\t\t\tString fileName = entry.getFilename();\r\n\t\t\t\t\tif (false == StrUtil.equals(\".\", fileName) && false == StrUtil.equals(\"..\", fileName)) {\r\n\t\t\t\t\t\tif (null == filter || filter.accept(entry)) {\r\n\t\t\t\t\t\t\tfileNames.add(entry.getFilename());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn CONTINUE;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} catch (SftpException e) {\r\n\t\t\tthrow new JschRuntimeException(e);\r\n\t\t}\r\n\t\treturn fileNames;\r\n\t}", "category": "Python"}, {"instruction": "This method is handling the IllegalAccess exceptions of Field.get()", "input": "Java", "output": "public final Object accessField(Field field, Object object) {\n\t\ttry {\n\t\t\tobject = field.get(object);\n\t\t} catch (NullPointerException npex) {\n\t\t\tthrow new NullKeyFieldException(\"Unable to access field \"+field+\" on object \"+object);\n\t\t} catch (IllegalAccessException iaex) {\n\t\t\tthrow new RuntimeException(\"This should not happen since we call setAccesssible(true) in PojoTypeInfo.\"\n\t\t\t+ \" fields: \" + field + \" obj: \" + object);\n\t\t}\n\t\treturn object;\n\t}", "category": "Python"}, {"instruction": "Returns the class name for the given logical name and trailing name. For example \"person\" and \"Controller\" would evaluate to \"PersonController\".\n\n@param logicalName  The logical name\n@param trailingName The trailing name\n@return The class name", "input": "Java", "output": "public static String getClassName(String logicalName, String trailingName) {\n        if (isBlank(logicalName)) {\n            throw new IllegalArgumentException(\"Argument [logicalName] cannot be null or blank\");\n        }\n\n        String className = logicalName.substring(0, 1).toUpperCase(Locale.ENGLISH) + logicalName.substring(1);\n        if (trailingName != null) {\n            className = className + trailingName;\n        }\n        return className;\n    }", "category": "Python"}, {"instruction": "Creates a new config option, using this option's key and default value, and\nadding the given deprecated keys.\n\n<p>When obtaining a value from the configuration via {@link Configuration#getValue(ConfigOption)},\nthe deprecated keys will be checked in the order provided to this method. The first key for which\na value is found will be used - that value will be returned.\n\n@param deprecatedKeys The deprecated keys, in the order in which they should be checked.\n@return A new config options, with the given deprecated keys.", "input": "Java", "output": "public ConfigOption<T> withDeprecatedKeys(String... deprecatedKeys) {\n\t\tfinal Stream<FallbackKey> newDeprecatedKeys = Arrays.stream(deprecatedKeys).map(FallbackKey::createDeprecatedKey);\n\t\tfinal Stream<FallbackKey> currentAlternativeKeys = Arrays.stream(this.fallbackKeys);\n\n\t\t// put deprecated keys last so that they are de-prioritized\n\t\tfinal FallbackKey[] mergedAlternativeKeys = Stream.concat(currentAlternativeKeys, newDeprecatedKeys)\n\t\t\t.toArray(FallbackKey[]::new);\n\t\treturn new ConfigOption<>(key, description, defaultValue, mergedAlternativeKeys);\n\t}", "category": "Python"}, {"instruction": "Log {@link CasServiceTicketValidatedEvent} at debug level.\n\n@param e the event", "input": "Java", "output": "@EventListener\n    public void logServiceTicketValidatedEvent(final CasServiceTicketValidatedEvent e) {\n        val principal = e.getServiceTicket().getTicketGrantingTicket().getAuthentication().getPrincipal();\n        LOGGER.debug(VALIDATED_ST_MSG,\n                e.getServiceTicket().getCreationTime(),\n                e.getServiceTicket().getId(),\n                e.getServiceTicket().getService().getId(),\n                principal.getId(),\n                principal.getAttributes());\n    }", "category": "Python"}, {"instruction": "Notify all {@link ChannelFuture}s that were registered with {@link #add(ChannelPromise, int)} and\ntheir pendingDatasize isis smaller then the current writeCounter returned by {@link #writeCounter()}.\n\nAfter a {@link ChannelFuture} was notified it will be removed from this {@link ChannelFlushPromiseNotifier} and\nso not receive anymore notification.\n\nThe rest of the remaining {@link ChannelFuture}s will be failed with the given {@link Throwable}.\n\nSo after this operation this {@link ChannelFutureListener} is empty.", "input": "Java", "output": "public ChannelFlushPromiseNotifier notifyPromises(Throwable cause) {\n        notifyPromises();\n        for (;;) {\n            FlushCheckpoint cp = flushCheckpoints.poll();\n            if (cp == null) {\n                break;\n            }\n            if (tryNotify) {\n                cp.promise().tryFailure(cause);\n            } else {\n                cp.promise().setFailure(cause);\n            }\n        }\n        return this;\n    }", "category": "Python"}, {"instruction": "Prepare a command line for execution from a Windows batch script.\n\nThe method quotes all arguments so that spaces are handled as expected. Quotes within arguments\nare \"double quoted\" (which is batch for escaping a quote). This page has more details about\nquoting and other batch script fun stuff: http://ss64.com/nt/syntax-esc.html", "input": "Java", "output": "private static String prepareWindowsCommand(List<String> cmd, Map<String, String> childEnv) {\n    StringBuilder cmdline = new StringBuilder();\n    for (Map.Entry<String, String> e : childEnv.entrySet()) {\n      cmdline.append(String.format(\"set %s=%s\", e.getKey(), e.getValue()));\n      cmdline.append(\" && \");\n    }\n    for (String arg : cmd) {\n      cmdline.append(quoteForBatchScript(arg));\n      cmdline.append(\" \");\n    }\n    return cmdline.toString();\n  }", "category": "Python"}, {"instruction": "build consul service from url\n\n@param url a URL object\n@return ConsulService consul service", "input": "Java", "output": "public static ConsulService buildService(URL url) {\n        ConsulService service = new ConsulService();\n        service.setAddress(url.getHost());\n        service.setId(ConsulUtils.convertConsulSerivceId(url));\n        service.setName(url.getPath());\n        service.setPort(url.getPort());\n        List<String> tags = new ArrayList<String>();\n        String env = url.getParameter(Constants.TAG_ENVIRONMENT);\n        if(env != null) tags.add(env);\n        service.setTags(tags);\n\n        return service;\n    }", "category": "Python"}, {"instruction": "Returns the interconnectDiagnostics for the specified interconnect.\n\n<p>Sample code:\n\n<pre><code>\ntry (InterconnectClient interconnectClient = InterconnectClient.create()) {\nProjectGlobalInterconnectName interconnect = ProjectGlobalInterconnectName.of(\"[PROJECT]\", \"[INTERCONNECT]\");\nInterconnectsGetDiagnosticsResponse response = interconnectClient.getDiagnosticsInterconnect(interconnect);\n}\n</code></pre>\n\n@param interconnect Name of the interconnect resource to query.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final InterconnectsGetDiagnosticsResponse getDiagnosticsInterconnect(\n      ProjectGlobalInterconnectName interconnect) {\n\n    GetDiagnosticsInterconnectHttpRequest request =\n        GetDiagnosticsInterconnectHttpRequest.newBuilder()\n            .setInterconnect(interconnect == null ? null : interconnect.toString())\n            .build();\n    return getDiagnosticsInterconnect(request);\n  }", "category": "Python"}, {"instruction": "Get the value of the <code>name</code> property as a <code>Class</code>\nimplementing the interface specified by <code>xface</code>.\n\nIf no such property is specified, then <code>defaultValue</code> is\nreturned.\n\nAn exception is thrown if the returned class does not implement the named\ninterface.\n\n@param name the class name.\n@param defaultValue default value.\n@param xface the interface implemented by the named class.\n@return property value as a <code>Class</code>,\nor <code>defaultValue</code>.", "input": "Java", "output": "public <U> Class<? extends U> getClass(String name,\n\t                                       Class<? extends U> defaultValue,\n\t                                       Class<U> xface) {\n\t\ttry {\n\t\t\tClass<?> theClass = getClass(name, defaultValue);\n\t\t\tif (theClass != null && !xface.isAssignableFrom(theClass))\n\t\t\t\tthrow new RuntimeException(theClass+\" not \"+xface.getName());\n\t\t\telse if (theClass != null)\n\t\t\t\treturn theClass.asSubclass(xface);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Creates a subscription to a given topic. See the &lt;a\nhref=\"https://cloud.google.com/pubsub/docs/admin#resource_names\"&gt; resource name\nrules&lt;/a&gt;. If the subscription already exists, returns `ALREADY_EXISTS`. If the\ncorresponding topic doesn't exist, returns `NOT_FOUND`.\n\n<p>If the name is not provided in the request, the server will assign a random name for this\nsubscription on the same project as the topic, conforming to the [resource name\nformat](https://cloud.google.com/pubsub/docs/admin#resource_names). The generated name is\npopulated in the returned Subscription object. Note that for REST API requests, you must\nspecify a name in the request.\n\n<p>Sample code:\n\n<pre><code>\ntry (SubscriptionAdminClient subscriptionAdminClient = SubscriptionAdminClient.create()) {\nProjectSubscriptionName name = ProjectSubscriptionName.of(\"[PROJECT]\", \"[SUBSCRIPTION]\");\nProjectTopicName topic = ProjectTopicName.of(\"[PROJECT]\", \"[TOPIC]\");\nPushConfig pushConfig = PushConfig.newBuilder().build();\nint ackDeadlineSeconds = 0;\nSubscription response = subscriptionAdminClient.createSubscription(name.toString(), topic.toString(), pushConfig, ackDeadlineSeconds);\n}\n</code></pre>\n\n@param name The name of the subscription. It must have the format\n`\"projects/{project}/subscriptions/{subscription}\"`. `{subscription}` must start with a\nletter, and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`), underscores\n(`_`), periods (`.`), tildes (`~`), plus (`+`) or percent signs (`%`). It must be between 3\nand 255 characters in length, and it must not start with `\"goog\"`\n@param topic The name of the topic from which this subscription is receiving messages. Format\nis `projects/{project}/topics/{topic}`. The value of this field will be `_deleted-topic_`\nif the topic has been deleted.\n@param pushConfig If push delivery is used with this subscription, this field is used to\nconfigure it. An empty `pushConfig` signifies that the subscriber will pull and ack\nmessages using API methods.\n@param ackDeadlineSeconds The approximate amount of time (on a best-effort basis) Pub/Sub waits\nfor the subscriber to acknowledge receipt before resending the message. In the interval\nafter the message is delivered and before it is acknowledged, it is considered to be\n&lt;i&gt;outstanding&lt;/i&gt;. During that time period, the message will not be\nredelivered (on a best-effort basis).\n<p>For pull subscriptions, this value is used as the initial value for the ack deadline. To\noverride this value for a given message, call `ModifyAckDeadline` with the corresponding\n`ack_id` if using non-streaming pull or send the `ack_id` in a\n`StreamingModifyAckDeadlineRequest` if using streaming pull. The minimum custom deadline\nyou can specify is 10 seconds. The maximum custom deadline you can specify is 600 seconds\n(10 minutes). If this parameter is 0, a default value of 10 seconds is used.\n<p>For push delivery, this value is also used to set the request timeout for the call to\nthe push endpoint.\n<p>If the subscriber never acknowledges the message, the Pub/Sub system will eventually\nredeliver the message.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "public final Subscription createSubscription(\n      String name, String topic, PushConfig pushConfig, int ackDeadlineSeconds) {\n\n    Subscription request =\n        Subscription.newBuilder()\n            .setName(name)\n            .setTopic(topic)\n            .setPushConfig(pushConfig)\n            .setAckDeadlineSeconds(ackDeadlineSeconds)\n            .build();\n    return createSubscription(request);\n  }", "category": "Python"}, {"instruction": "Create a DataBuffer for indices of given arrays of indices.\n@param indices\n@param shape\n@return", "input": "Java", "output": "protected static DataBuffer createIndiceBuffer(long[][] indices, long[] shape){\n        checkNotNull(indices);\n        checkNotNull(shape);\n        if(indices.length == 0){\n            return Nd4j.getDataBufferFactory().createLong(shape.length);\n        }\n\n        if (indices.length == shape.length) {\n            return Nd4j.createBuffer(ArrayUtil.flattenF(indices));\n        }\n\n        return Nd4j.createBuffer(ArrayUtil.flatten(indices));\n    }", "category": "Python"}, {"instruction": "Called once the user logs in. Just forward to the top page.\nUsed only by {@link LegacySecurityRealm}.", "input": "Java", "output": "public void doLoginEntry( StaplerRequest req, StaplerResponse rsp ) throws IOException {\n        if(req.getUserPrincipal()==null) {\n            rsp.sendRedirect2(\"noPrincipal\");\n            return;\n        }\n\n        // TODO fire something in SecurityListener?\n\n        String from = req.getParameter(\"from\");\n        if(from!=null && from.startsWith(\"/\") && !from.equals(\"/loginError\")) {\n            rsp.sendRedirect2(from);    // I'm bit uncomfortable letting users redirected to other sites, make sure the URL falls into this domain\n            return;\n        }\n\n        String url = AbstractProcessingFilter.obtainFullRequestUrl(req);\n        if(url!=null) {\n            // if the login redirect is initiated by Acegi\n            // this should send the user back to where s/he was from.\n            rsp.sendRedirect2(url);\n            return;\n        }\n\n        rsp.sendRedirect2(\".\");\n    }", "category": "Python"}, {"instruction": "Encodes the specified cookies into a single Cookie header value.\n\n@param cookies\nsome cookies\n@return a Rfc6265 style Cookie header value, null if no cookies are passed.", "input": "Java", "output": "public String encode(Cookie... cookies) {\n        if (checkNotNull(cookies, \"cookies\").length == 0) {\n            return null;\n        }\n\n        StringBuilder buf = stringBuilder();\n        if (strict) {\n            if (cookies.length == 1) {\n                encode(buf, cookies[0]);\n            } else {\n                Cookie[] cookiesSorted = Arrays.copyOf(cookies, cookies.length);\n                Arrays.sort(cookiesSorted, COOKIE_COMPARATOR);\n                for (Cookie c : cookiesSorted) {\n                    encode(buf, c);\n                }\n            }\n        } else {\n            for (Cookie c : cookies) {\n                encode(buf, c);\n            }\n        }\n        return stripTrailingSeparatorOrNull(buf);\n    }", "category": "Python"}, {"instruction": "Applies a flat select function to the detected pattern sequence. For each pattern sequence\nthe provided {@link PatternFlatSelectFunction} is called. The pattern flat select function\ncan produce an arbitrary number of resulting elements.\n\n@param patternFlatSelectFunction The pattern flat select function which is called for each\ndetected pattern sequence.\n@param <R> Type of the resulting elements\n@return {@link DataStream} which contains the resulting elements from the pattern flat select\nfunction.", "input": "Java", "output": "public <R> SingleOutputStreamOperator<R> flatSelect(final PatternFlatSelectFunction<T, R> patternFlatSelectFunction) {\n\t\t// we have to extract the output type from the provided pattern selection function manually\n\t\t// because the TypeExtractor cannot do that if the method is wrapped in a MapFunction\n\n\t\tfinal TypeInformation<R> outTypeInfo = TypeExtractor.getUnaryOperatorReturnType(\n\t\t\tpatternFlatSelectFunction,\n\t\t\tPatternFlatSelectFunction.class,\n\t\t\t0,\n\t\t\t1,\n\t\t\tnew int[]{1, 0},\n\t\t\tbuilder.getInputType(),\n\t\t\tnull,\n\t\t\tfalse);\n\n\t\treturn flatSelect(patternFlatSelectFunction, outTypeInfo);\n\t}", "category": "Python"}, {"instruction": "Returns the indices of non-zero element of the vector\n\n@return indices in Databuffer", "input": "Java", "output": "@Override\n    public DataBuffer getVectorCoordinates() {\n        int idx;\n        if (isRowVector()) {\n            idx = 1;\n        } else if (isColumnVector()) {\n            idx = 0;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n\n        // FIXME: int cast\n        int[] temp = new int[(int) length()];\n        for (int i = 0; i < length(); i++) {\n            temp[i] = getUnderlyingIndicesOf(i).getInt(idx);\n        }\n        return Nd4j.createBuffer(temp);\n    }", "category": "Python"}, {"instruction": "Gets encrypter.\n\n@param samlObject    the saml object\n@param service       the service\n@param adaptor       the adaptor\n@param keyEncParams  the key enc params\n@param dataEncParams the data enc params\n@return the encrypter", "input": "Java", "output": "protected Encrypter getEncrypter(final Object samlObject,\n                                     final SamlRegisteredService service,\n                                     final SamlRegisteredServiceServiceProviderMetadataFacade adaptor,\n                                     final KeyEncryptionParameters keyEncParams,\n                                     final DataEncryptionParameters dataEncParams) {\n        val encrypter = new Encrypter(dataEncParams, keyEncParams);\n        encrypter.setKeyPlacement(Encrypter.KeyPlacement.PEER);\n        return encrypter;\n    }", "category": "Python"}, {"instruction": "Gets resource from a String location.\n\n@param location the metadata location\n@return the resource from\n@throws IOException the exception", "input": "Java", "output": "public static AbstractResource getRawResourceFrom(final String location) throws IOException {\n        if (StringUtils.isBlank(location)) {\n            throw new IllegalArgumentException(\"Provided location does not exist and is empty\");\n        }\n        if (location.toLowerCase().startsWith(HTTP_URL_PREFIX)) {\n            return new UrlResource(location);\n        }\n        if (location.toLowerCase().startsWith(CLASSPATH_URL_PREFIX)) {\n            return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()));\n        }\n        return new FileSystemResource(StringUtils.remove(location, FILE_URL_PREFIX));\n    }", "category": "Python"}, {"instruction": "Checks and installs all the add-ons whose installation status is {@code NOT_INSTALLED} that have (now) all required\ndependencies fulfilled.\n<p>\nShould be called after an installation of an add-on.\n\n@see #addAddOnImpl(AddOn)\n@see AddOn.InstallationStatus#NOT_INSTALLED\n@since 2.4.0", "input": "Java", "output": "private void checkAndInstallAddOnsNotInstalled() {\r\n        List<AddOn> runnableAddOns = new ArrayList<>();\r\n        for (AddOn addOn : aoc.getAddOns()) {\r\n            if (AddOn.InstallationStatus.NOT_INSTALLED == addOn.getInstallationStatus() && addOnLoaders.get(addOn.getId()) == null) {\r\n                AddOnRunRequirements reqs = addOn.calculateRunRequirements(aoc.getInstalledAddOns());\r\n                if (reqs.isRunnable()) {\r\n                    runnableAddOns.add(addOn);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (AddOn addOn : runnableAddOns) {\r\n            addAddOnImpl(addOn);\r\n        }\r\n    }", "category": "Python"}, {"instruction": "Apply L1 and L2 regularization, if necessary. Note that L1/L2 may differ for different layers in the same block\n\n@param layer        The layer to apply L1/L2 to\n@param paramName    Parameter name in the given layer\n@param gradientView Gradient view array for the layer + param\n@param paramsView   Parameter view array for the layer + param", "input": "Java", "output": "protected void applyRegularization(Regularization.ApplyStep step, Trainable layer, String paramName, INDArray gradientView, INDArray paramsView, int iter, int epoch, double lr) {\n        //TODO: do this for multiple contiguous params/layers (fewer, larger ops)\n\n        List<Regularization> l = layer.getConfig().getRegularizationByParam(paramName);\n        if(l != null && !l.isEmpty()){\n            for(Regularization r : l){\n                if(r.applyStep() == step){\n                    r.apply(paramsView, gradientView, lr, iter, epoch);\n                }\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Given a {@link ROC} instance, render the ROC chart and precision vs. recall charts to a stand-alone HTML file (returned as a String)\n@param roc  ROC to render", "input": "Java", "output": "public static String rocChartToHtml(ROC roc) {\n        RocCurve rocCurve = roc.getRocCurve();\n\n        Component c = getRocFromPoints(ROC_TITLE, rocCurve, roc.getCountActualPositive(), roc.getCountActualNegative(),\n                        roc.calculateAUC(), roc.calculateAUCPR());\n        Component c2 = getPRCharts(PR_TITLE, PR_THRESHOLD_TITLE, roc.getPrecisionRecallCurve());\n\n        return StaticPageUtil.renderHTML(c, c2);\n    }", "category": "Python"}, {"instruction": "Tries to write&flush unannounced credits for the next input channel in queue.\n\n<p>This method may be called by the first input channel enqueuing, or the complete\nfuture's callback in previous input channel, or the channel writability changed event.", "input": "Java", "output": "private void writeAndFlushNextMessageIfPossible(Channel channel) {\n\t\tif (channelError.get() != null || !channel.isWritable()) {\n\t\t\treturn;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tRemoteInputChannel inputChannel = inputChannelsWithCredit.poll();\n\n\t\t\t// The input channel may be null because of the write callbacks\n\t\t\t// that are executed after each write.\n\t\t\tif (inputChannel == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//It is no need to notify credit for the released channel.\n\t\t\tif (!inputChannel.isReleased()) {\n\t\t\t\tAddCredit msg = new AddCredit(\n\t\t\t\t\tinputChannel.getPartitionId(),\n\t\t\t\t\tinputChannel.getAndResetUnannouncedCredit(),\n\t\t\t\t\tinputChannel.getInputChannelId());\n\n\t\t\t\t// Write and flush and wait until this is done before\n\t\t\t\t// trying to continue with the next input channel.\n\t\t\t\tchannel.writeAndFlush(msg).addListener(writeListener);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Called when a checkpoint barrier arrives. It closes any open streams to the backend\nand marks them as pending for committing to the external, third-party storage system.\n\n@param checkpointId the id of the latest received checkpoint.\n@throws IOException in case something went wrong when handling the stream to the backend.", "input": "Java", "output": "private void saveHandleInState(final long checkpointId, final long timestamp) throws Exception {\n\n\t\t//only add handle if a new OperatorState was created since the last snapshot\n\t\tif (out != null) {\n\t\t\tint subtaskIdx = getRuntimeContext().getIndexOfThisSubtask();\n\t\t\tStreamStateHandle handle = out.closeAndGetHandle();\n\n\t\t\tPendingCheckpoint pendingCheckpoint = new PendingCheckpoint(\n\t\t\t\tcheckpointId, subtaskIdx, timestamp, handle);\n\n\t\t\tif (pendingCheckpoints.contains(pendingCheckpoint)) {\n\t\t\t\t//we already have a checkpoint stored for that ID that may have been partially written,\n\t\t\t\t//so we discard this \"alternate version\" and use the stored checkpoint\n\t\t\t\thandle.discardState();\n\t\t\t} else {\n\t\t\t\tpendingCheckpoints.add(pendingCheckpoint);\n\t\t\t}\n\t\t\tout = null;\n\t\t}\n\t}", "category": "Python"}, {"instruction": "A final allocation pass with no code length limit.\n@param array The code length array", "input": "Java", "output": "private static void allocateNodeLengths(final int[] array) {\n        int firstNode = array.length - 2;\n        int nextNode = array.length - 1;\n\n        for (int currentDepth = 1, availableNodes = 2; availableNodes > 0; currentDepth++) {\n            final int lastNode = firstNode;\n            firstNode = first(array, lastNode - 1, 0);\n\n            for (int i = availableNodes - (lastNode - firstNode); i > 0; i--) {\n                array[nextNode--] = currentDepth;\n            }\n\n            availableNodes = (lastNode - firstNode) << 1;\n        }\n    }", "category": "Python"}, {"instruction": "Picks up a {@link RepositoryBrowser} that matches the\ngiven {@link SCM} from existing other jobs.\n\n@return\nnull if no applicable configuration was found.", "input": "Java", "output": "private RepositoryBrowser infer() {\n        for( AbstractProject p : Jenkins.getInstance().allItems(AbstractProject.class) ) {\n            SCM scm = p.getScm();\n            if (scm!=null && scm.getClass()==owner.getClass() && scm.getBrowser()!=null &&\n                    ((SCMDescriptor)scm.getDescriptor()).isBrowserReusable(scm,owner)) {\n                return scm.getBrowser();\n            }\n        }\n        return null;\n    }", "category": "Python"}, {"instruction": "\u4ece\u5b57\u8282\u6570\u7ec4\u52a0\u8f7d\uff08\u53d1\u73b0\u5728MacOS\u4e0a\uff0c\u6b64\u65b9\u6cd5\u6bd4ByteArray\u66f4\u5feb\uff09\n@param bytes\n@param offset\n@param value\n@return", "input": "Java", "output": "public boolean load(byte[] bytes, int offset, V[] value)\n    {\n        if (bytes == null) return false;\n        size = ByteUtil.bytesHighFirstToInt(bytes, offset);\n        offset += 4;\n        base = new int[size + 65535];   // \u591a\u7559\u4e00\u4e9b\uff0c\u9632\u6b62\u8d8a\u754c\n        check = new int[size + 65535];\n        for (int i = 0; i < size; i++)\n        {\n            base[i] = ByteUtil.bytesHighFirstToInt(bytes, offset);\n            offset += 4;\n            check[i] = ByteUtil.bytesHighFirstToInt(bytes, offset);\n            offset += 4;\n        }\n        v = value;\n        return true;\n    }", "category": "Python"}, {"instruction": "Generate a project based on the specified {@link ProjectGenerationRequest}.\n@param request the generation request\n@return an entity defining the project\n@throws IOException if generation fails", "input": "Java", "output": "public ProjectGenerationResponse generate(ProjectGenerationRequest request)\n\t\t\tthrows IOException {\n\t\tLog.info(\"Using service at \" + request.getServiceUrl());\n\t\tInitializrServiceMetadata metadata = loadMetadata(request.getServiceUrl());\n\t\tURI url = request.generateUrl(metadata);\n\t\tCloseableHttpResponse httpResponse = executeProjectGenerationRequest(url);\n\t\tHttpEntity httpEntity = httpResponse.getEntity();\n\t\tvalidateResponse(httpResponse, request.getServiceUrl());\n\t\treturn createResponse(httpResponse, httpEntity);\n\t}", "category": "Python"}, {"instruction": "Put.\n\n@param service the service", "input": "Java", "output": "public void put(final RegisteredService service) {\n        val values = buildTableAttributeValuesMapFromService(service);\n        val putItemRequest = new PutItemRequest(dynamoDbProperties.getTableName(), values);\n        LOGGER.debug(\"Submitting put request [{}] for service id [{}]\", putItemRequest, service.getServiceId());\n        val putItemResult = amazonDynamoDBClient.putItem(putItemRequest);\n        LOGGER.debug(\"Service added with result [{}]\", putItemResult);\n    }", "category": "Python"}, {"instruction": "\u7528\u4e8eModel\u5bf9\u8c61\u8f6c\u5316\u4e3aDO\u5bf9\u8c61\n\n@param canal\n@return CanalDO", "input": "Java", "output": "private CanalDO modelToDo(Canal canal) {\n        CanalDO canalDo = new CanalDO();\n        try {\n            canalDo.setId(canal.getId());\n            canalDo.setName(canal.getName());\n            canalDo.setStatus(canal.getStatus());\n            canalDo.setDescription(canal.getDesc());\n            canalDo.setParameters(canal.getCanalParameter());\n            canalDo.setGmtCreate(canal.getGmtCreate());\n            canalDo.setGmtModified(canal.getGmtModified());\n        } catch (Exception e) {\n            logger.error(\"ERROR ## change the canal Model to Do has an exception\");\n            throw new ManagerException(e);\n        }\n        return canalDo;\n    }", "category": "Python"}, {"instruction": "Set the list of search domains of the resolver.\n\n@param searchDomains the search domains\n@return {@code this}", "input": "Java", "output": "public DnsNameResolverBuilder searchDomains(Iterable<String> searchDomains) {\n        checkNotNull(searchDomains, \"searchDomains\");\n\n        final List<String> list = new ArrayList<String>(4);\n\n        for (String f : searchDomains) {\n            if (f == null) {\n                break;\n            }\n\n            // Avoid duplicate entries.\n            if (list.contains(f)) {\n                continue;\n            }\n\n            list.add(f);\n        }\n\n        this.searchDomains = list.toArray(new String[0]);\n        return this;\n    }", "category": "Python"}, {"instruction": "Update references to a renamed job in the fingerprint", "input": "Java", "output": "public synchronized void rename(String oldName, String newName) throws IOException {\n        boolean touched = false;\n        if (original != null) {\n            if (original.getName().equals(oldName)) {\n                original.setName(newName);\n                touched = true;\n            }\n        }\n        \n        if (usages != null) {\n            RangeSet r = usages.get(oldName);\n            if (r != null) {\n                usages.put(newName, r);\n                usages.remove(oldName);\n                touched = true;\n            }\n        }\n        \n        if (touched) {\n            save();\n        }\n    }", "category": "Python"}, {"instruction": "Converts a map of class elements to type arguments.\n@param typeArguments The type arguments\n@return The type arguments", "input": "Java", "output": "@NotNull\n    protected Map<String, Object> toTypeArguments(@NotNull Map<String, ClassElement> typeArguments) {\n        final LinkedHashMap<String, Object> map = new LinkedHashMap<>(typeArguments.size());\n        for (Map.Entry<String, ClassElement> entry : typeArguments.entrySet()) {\n            final ClassElement ce = entry.getValue();\n            final Map<String, ClassElement> subArgs = ce.getTypeArguments();\n            if (CollectionUtils.isNotEmpty(subArgs)) {\n                map.put(entry.getKey(), toTypeArguments(subArgs));\n            } else {\n                final Type typeReference = getTypeForElement(ce);\n                map.put(entry.getKey(), typeReference);\n            }\n        }\n\n        return map;\n    }", "category": "Python"}, {"instruction": "Called from RequestVariable.shutdown() to unschedule the task.", "input": "Java", "output": "public void shutdown() {\n        RequestBatch<BatchReturnType, ResponseType, RequestArgumentType> currentBatch = batch.getAndSet(null);\n        if (currentBatch != null) {\n            currentBatch.shutdown();\n        }\n\n        if (timerListenerReference.get() != null) {\n            // if the timer was started we'll clear it so it stops ticking\n            timerListenerReference.get().clear();\n        }\n    }", "category": "Python"}, {"instruction": "Executes one instance of the task, or queues it up at most once should the task be currently running.", "input": "Java", "output": "void runAsync() {\n        // Determine if a task is running. If so, record the fact we want to have it run again, otherwise reserve our spot.\n        synchronized (this) {\n            Exceptions.checkNotClosed(this.closed, this);\n            if (this.running) {\n                this.runAgain = true;\n                return;\n            }\n\n            this.running = true;\n        }\n\n        // Execute the task.\n        runInternal();\n    }", "category": "Python"}, {"instruction": "Add the given stream element queue entry to the operator's stream element queue. This\noperation blocks until the element has been added.\n\n<p>For that it tries to put the element into the queue and if not successful then it waits on\nthe checkpointing lock. The checkpointing lock is also used by the {@link Emitter} to output\nelements. The emitter is also responsible for notifying this method if the queue has capacity\nleft again, by calling notifyAll on the checkpointing lock.\n\n@param streamElementQueueEntry to add to the operator's queue\n@param <T> Type of the stream element queue entry's result\n@throws InterruptedException if the current thread has been interrupted", "input": "Java", "output": "private <T> void addAsyncBufferEntry(StreamElementQueueEntry<T> streamElementQueueEntry) throws InterruptedException {\n\t\tassert(Thread.holdsLock(checkpointingLock));\n\n\t\tpendingStreamElementQueueEntry = streamElementQueueEntry;\n\n\t\twhile (!queue.tryPut(streamElementQueueEntry)) {\n\t\t\t// we wait for the emitter to notify us if the queue has space left again\n\t\t\tcheckpointingLock.wait();\n\t\t}\n\n\t\tpendingStreamElementQueueEntry = null;\n\t}", "category": "Python"}, {"instruction": "Gets attribute merger.\n\n@param mergingPolicy the merging policy\n@return the attribute merger", "input": "Java", "output": "public static IAttributeMerger getAttributeMerger(final String mergingPolicy) {\n        switch (mergingPolicy.toLowerCase()) {\n            case \"multivalued\":\n            case \"multi_valued\":\n            case \"combine\":\n                return new MultivaluedAttributeMerger();\n            case \"add\":\n                return new NoncollidingAttributeAdder();\n            case \"replace\":\n            case \"overwrite\":\n            case \"override\":\n                return new ReplacingAttributeAdder();\n            default:\n                return new BaseAdditiveAttributeMerger() {\n                    @Override\n                    protected Map<String, List<Object>> mergePersonAttributes(final Map<String, List<Object>> toModify,\n                                                                              final Map<String, List<Object>> toConsider) {\n                        return new LinkedHashMap<>(toModify);\n                    }\n                };\n        }\n    }", "category": "Python"}, {"instruction": "-------------------------------------------------------------------------------", "input": "Java", "output": "public static <K, N> InternalTimersSnapshotReader<K, N> getReaderForVersion(\n\t\tint version, ClassLoader userCodeClassLoader) {\n\n\t\tswitch (version) {\n\t\t\tcase NO_VERSION:\n\t\t\t\treturn new InternalTimersSnapshotReaderPreVersioned<>(userCodeClassLoader);\n\n\t\t\tcase 1:\n\t\t\t\treturn new InternalTimersSnapshotReaderV1<>(userCodeClassLoader);\n\n\t\t\tcase InternalTimerServiceSerializationProxy.VERSION:\n\t\t\t\treturn new InternalTimersSnapshotReaderV2<>(userCodeClassLoader);\n\n\t\t\tdefault:\n\t\t\t\t// guard for future\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Unrecognized internal timers snapshot writer version: \" + version);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Extract the OAuth bearer token from a header.\n\n@param request The request.\n@return The token, or null if no OAuth authorization header was supplied.", "input": "Java", "output": "protected String extractHeaderToken(HttpServletRequest request) {\n\t\tEnumeration<String> headers = request.getHeaders(\"Authorization\");\n\t\twhile (headers.hasMoreElements()) { // typically there is only one (most servers enforce that)\n\t\t\tString value = headers.nextElement();\n\t\t\tif ((value.toLowerCase().startsWith(OAuth2AccessToken.BEARER_TYPE.toLowerCase()))) {\n\t\t\t\tString authHeaderValue = value.substring(OAuth2AccessToken.BEARER_TYPE.length()).trim();\n\t\t\t\t// Add this here for the auth details later. Would be better to change the signature of this method.\n\t\t\t\trequest.setAttribute(OAuth2AuthenticationDetails.ACCESS_TOKEN_TYPE,\n\t\t\t\t\t\tvalue.substring(0, OAuth2AccessToken.BEARER_TYPE.length()).trim());\n\t\t\t\tint commaIndex = authHeaderValue.indexOf(',');\n\t\t\t\tif (commaIndex > 0) {\n\t\t\t\t\tauthHeaderValue = authHeaderValue.substring(0, commaIndex);\n\t\t\t\t}\n\t\t\t\treturn authHeaderValue;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}", "category": "Python"}, {"instruction": "Translates to an \"expression\" type leaf filter. Used as a fallback if we can't use a simple leaf filter.", "input": "Java", "output": "@Nullable\n  private static DimFilter toExpressionLeafFilter(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final RexNode rexNode\n  )\n  {\n    final DruidExpression druidExpression = toDruidExpression(plannerContext, rowSignature, rexNode);\n    return druidExpression != null\n           ? new ExpressionDimFilter(druidExpression.getExpression(), plannerContext.getExprMacroTable())\n           : null;\n  }", "category": "Python"}, {"instruction": "\u63d2\u5165\u6570\u636e<br>\n\u6b64\u65b9\u6cd5\u4e0d\u4f1a\u5173\u95edConnection\n@param conn \u6570\u636e\u5e93\u8fde\u63a5\n@param record \u8bb0\u5f55\n@return \u4e3b\u952e\u5217\u8868\n@throws SQLException SQL\u6267\u884c\u5f02\u5e38", "input": "Java", "output": "public List<Object> insertForGeneratedKeys(Connection conn, Entity record) throws SQLException {\r\n\t\tcheckConn(conn);\r\n\t\tif(CollectionUtil.isEmpty(record)){\r\n\t\t\tthrow new SQLException(\"Empty entity provided!\");\r\n\t\t}\r\n\t\t\r\n\t\tPreparedStatement ps = null;\r\n\t\ttry {\r\n\t\t\tps = dialect.psForInsert(conn, record);\r\n\t\t\tps.executeUpdate();\r\n\t\t\treturn StatementUtil.getGeneratedKeys(ps);\r\n\t\t} catch (SQLException e) {\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\tDbUtil.close(ps);\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "Create a node.\n\n@param path\n@param data\n@param mode\n@return create node's path\n@throws ZkInterruptedException if operation was interrupted, or a required reconnection got interrupted\n@throws IllegalArgumentException if called from anything except the ZooKeeper event thread\n@throws ZkException if any ZooKeeper exception occurred\n@throws RuntimeException if any other exception occurs", "input": "Java", "output": "public String create(final String path, Object data, final CreateMode mode) throws ZkInterruptedException,\n                                                                               IllegalArgumentException, ZkException,\n                                                                               RuntimeException {\n        if (path == null) {\n            throw new NullPointerException(\"path must not be null.\");\n        }\n        final byte[] bytes = data == null ? null : serialize(data);\n\n        return retryUntilConnected(new Callable<String>() {\n\n            @Override\n            public String call() throws Exception {\n                return _connection.create(path, bytes, mode);\n            }\n        });\n    }", "category": "Python"}, {"instruction": "This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.", "input": "Java", "output": "private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(\n\t\tList<StateMetaInfoSnapshot> stateMetaInfoSnapshots,\n\t\tboolean registerTtlCompactFilter) {\n\n\t\tList<ColumnFamilyDescriptor> columnFamilyDescriptors =\n\t\t\tnew ArrayList<>(stateMetaInfoSnapshots.size());\n\n\t\tfor (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {\n\t\t\tRegisteredStateMetaInfoBase metaInfoBase =\n\t\t\t\tRegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot);\n\t\t\tColumnFamilyDescriptor columnFamilyDescriptor = RocksDBOperationUtils.createColumnFamilyDescriptor(\n\t\t\t\tmetaInfoBase, columnFamilyOptionsFactory, registerTtlCompactFilter ? ttlCompactFiltersManager : null);\n\t\t\tcolumnFamilyDescriptors.add(columnFamilyDescriptor);\n\t\t}\n\t\treturn columnFamilyDescriptors;\n\t}", "category": "Python"}, {"instruction": "Static factory method: to be used when a new execution is created for the very first time/\nCalling this will make sure no extra db fetches are needed later on, as all collections\nwill be populated with empty collections. If they would be null, it would trigger\na database fetch for those relationship entities.", "input": "Java", "output": "public static ExecutionEntityImpl createWithEmptyRelationshipCollections() {\n    ExecutionEntityImpl execution = new ExecutionEntityImpl();\n    execution.executions = new ArrayList<ExecutionEntityImpl>(1);\n    execution.tasks = new ArrayList<TaskEntity>(1);\n    execution.variableInstances = new HashMap<String, VariableInstanceEntity>(1);\n    execution.jobs = new ArrayList<JobEntity>(1);\n    execution.timerJobs = new ArrayList<TimerJobEntity>(1);\n    execution.eventSubscriptions = new ArrayList<EventSubscriptionEntity>(1);\n    execution.identityLinks = new ArrayList<IdentityLinkEntity>(1);\n    return execution;\n  }", "category": "Python"}, {"instruction": "This private field in the superclass needs to be reset so that we can continue reporting leaks even\nif they're duplicates. This is ugly but ideally should not be called frequently (or at all).", "input": "Java", "output": "private void resetReportedLeaks() {\n        try {\n            Field reportedLeaks = ResourceLeakDetector.class.getDeclaredField(\"reportedLeaks\");\n            reportedLeaks.setAccessible(true);\n            Object f = reportedLeaks.get(this);\n            if (f instanceof Map) {\n                ((Map) f).clear();\n            }\n        }\n        catch (Throwable t) {\n            // do nothing\n        }\n    }", "category": "Python"}, {"instruction": "Locate the vertices and the codewords area of a black blob using the Start\nand Stop patterns as locators.\n\n@param matrix the scanned barcode image.\n@return an array containing the vertices:\nvertices[0] x, y top left barcode\nvertices[1] x, y bottom left barcode\nvertices[2] x, y top right barcode\nvertices[3] x, y bottom right barcode\nvertices[4] x, y top left codeword area\nvertices[5] x, y bottom left codeword area\nvertices[6] x, y top right codeword area\nvertices[7] x, y bottom right codeword area", "input": "Java", "output": "private static ResultPoint[] findVertices(BitMatrix matrix, int startRow, int startColumn) {\n    int height = matrix.getHeight();\n    int width = matrix.getWidth();\n\n    ResultPoint[] result = new ResultPoint[8];\n    copyToResult(result, findRowsWithPattern(matrix, height, width, startRow, startColumn, START_PATTERN),\n        INDEXES_START_PATTERN);\n\n    if (result[4] != null) {\n      startColumn = (int) result[4].getX();\n      startRow = (int) result[4].getY();\n    }\n    copyToResult(result, findRowsWithPattern(matrix, height, width, startRow, startColumn, STOP_PATTERN),\n        INDEXES_STOP_PATTERN);\n    return result;\n  }", "category": "Python"}, {"instruction": "Used to produce an index for particular annotation type. Method referenced by generated byte code and\nnot for public consumption. Should be called after {@link #addProperty(BeanProperty)} if required.\n\n@param annotationType The annotation type\n@param propertyName The property name", "input": "Java", "output": "@SuppressWarnings(\"unused\")\n    @Internal\n    @UsedByGeneratedCode\n    protected final void indexProperty(@Nonnull Class<? extends Annotation> annotationType, @Nonnull String propertyName) {\n        ArgumentUtils.requireNonNull(\"annotationType\", annotationType);\n        if (StringUtils.isNotEmpty(propertyName)) {\n            final BeanProperty<T, Object> property = beanProperties.get(propertyName);\n            if (property == null) {\n                throw new IllegalStateException(\"Invalid byte code generated during bean introspection. Call addProperty first!\");\n            }\n            if (indexed == null) {\n                indexed = new HashMap<>(2);\n            }\n            final List<BeanProperty<T, Object>> indexed = this.indexed.computeIfAbsent(annotationType, aClass -> new ArrayList<>(2));\n\n            indexed.add(property);\n        }\n    }", "category": "Python"}, {"instruction": "For the given input shape/type for the network, return a list of activation sizes for each layer in the network.<br>\ni.e., list.get(i) is the output activation sizes for layer i\n\n@param inputType Input type for the network\n@return A lits of activation types for the network, indexed by layer number", "input": "Java", "output": "public List<InputType> getLayerActivationTypes(@NonNull InputType inputType) {\n        List<InputType> out = new ArrayList<>();\n        int nLayers = confs.size();\n        for (int i = 0; i < nLayers; i++) {\n            InputPreProcessor preproc = getInputPreProcess(i);\n            if (preproc != null) {\n                inputType = preproc.getOutputType(inputType);\n            }\n\n            inputType = confs.get(i).getLayer().getOutputType(i, inputType);\n            out.add(inputType);\n        }\n        return out;\n    }", "category": "Python"}, {"instruction": "Deletes this recorder, then go back to the parent.", "input": "Java", "output": "@RequirePOST\n    public synchronized void doDoDelete(StaplerResponse rsp) throws IOException, ServletException {\n        getConfigFile().delete();\n        getParent().logRecorders.remove(name);\n        // Disable logging for all our targets,\n        // then reenable all other loggers in case any also log the same targets\n        for (Target t : targets)\n            t.disable();\n        for (LogRecorder log : getParent().logRecorders.values())\n            for (Target t : log.targets)\n                t.enable();\n        rsp.sendRedirect2(\"..\");\n    }", "category": "Python"}, {"instruction": "Overwrites the document referred to by this DocumentReference. If the document doesn't exist\nyet, it will be created. If you pass {@link SetOptions}, the provided data can be merged into\nan existing document.\n\n@param documentReference The DocumentReference to overwrite.\n@param pojo The POJO that will be used to populate the document contents.\n@param options An object to configure the set behavior.\n@return The instance for chaining.", "input": "Java", "output": "@Nonnull\n  public T set(\n      @Nonnull DocumentReference documentReference,\n      @Nonnull Object pojo,\n      @Nonnull SetOptions options) {\n    Object data = CustomClassMapper.convertToPlainJavaTypes(pojo);\n    if (!(data instanceof Map)) {\n      throw new IllegalArgumentException(\"Can't set a document's data to an array or primitive\");\n    }\n    return performSet(documentReference, (Map<String, Object>) data, options);\n  }", "category": "Python"}, {"instruction": "Reads the given file line-by-line and creates a data stream that contains a string with the\ncontents of each such line. The {@link java.nio.charset.Charset} with the given name will be\nused to read the files.\n\n<p><b>NOTES ON CHECKPOINTING: </b> The source monitors the path, creates the\n{@link org.apache.flink.core.fs.FileInputSplit FileInputSplits} to be processed,\nforwards them to the downstream {@link ContinuousFileReaderOperator readers} to read the actual data,\nand exits, without waiting for the readers to finish reading. This implies that no more checkpoint\nbarriers are going to be forwarded after the source exits, thus having no checkpoints after that point.\n\n@param filePath\nThe path of the file, as a URI (e.g., \"file:///some/local/file\" or \"hdfs://host:port/file/path\")\n@param charsetName\nThe name of the character set used to read the file\n@return The data stream that represents the data read from the given file as text lines", "input": "Java", "output": "public DataStreamSource<String> readTextFile(String filePath, String charsetName) {\n\t\tPreconditions.checkArgument(!StringUtils.isNullOrWhitespaceOnly(filePath), \"The file path must not be null or blank.\");\n\n\t\tTextInputFormat format = new TextInputFormat(new Path(filePath));\n\t\tformat.setFilesFilter(FilePathFilter.createDefaultFilter());\n\t\tTypeInformation<String> typeInfo = BasicTypeInfo.STRING_TYPE_INFO;\n\t\tformat.setCharsetName(charsetName);\n\n\t\treturn readFile(format, filePath, FileProcessingMode.PROCESS_ONCE, -1, typeInfo);\n\t}", "category": "Python"}, {"instruction": "Encode a Uri Chunk, ensuring that all reserved characters are also encoded.\n\n@param value to encode.\n@param type identifying which uri fragment rules to apply.\n@param charset to use.\n@return an encoded uri chunk.", "input": "Java", "output": "private static String encodeChunk(String value, FragmentType type, Charset charset) {\n    byte[] data = value.getBytes(charset);\n    ByteArrayOutputStream encoded = new ByteArrayOutputStream();\n\n    for (byte b : data) {\n      if (type.isAllowed(b)) {\n        encoded.write(b);\n      } else {\n        /* percent encode the byte */\n        pctEncode(b, encoded);\n      }\n    }\n    return new String(encoded.toByteArray());\n  }", "category": "Python"}, {"instruction": "Creates a sorted set with all the parameters from the given {@code query}, ordered lexicographically by name and value.\n\n@param queryString the query string\n@return a sorted set with all parameters, or {@code null} if the query string is {@code null} or empty.", "input": "Java", "output": "private static SortedSet<QueryParameter> createSortedParameters(final String queryString) {\n\t\tif (queryString == null || queryString.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal String[] pairs = queryString.split(\"&\");\n\t\tfinal SortedSet<QueryParameter> params = new TreeSet<>();\n\n\t\tfor (final String pair : pairs) {\n\t\t\tif (pair.length() == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString[] tokens = pair.split(\"=\", 2);\n\t\t\tswitch (tokens.length) {\n\t\t\tcase 1:\n\t\t\t\tif (pair.charAt(0) == '=') {\n\t\t\t\t\tparams.add(new QueryParameter(\"\", tokens[0]));\n\t\t\t\t} else {\n\t\t\t\t\tparams.add(new QueryParameter(tokens[0], \"\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tparams.add(new QueryParameter(tokens[0], tokens[1]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn params;\n\t}", "category": "Python"}, {"instruction": "Check if a {@link ByteBuffer} contains a file identifier.\n\n@param bb A {@code ByteBuffer} to check if it contains the identifier\n`ident`.\n@param ident A `String` identifier of the FlatBuffer file.\n@return True if the buffer contains the file identifier", "input": "Java", "output": "protected static boolean __has_identifier(ByteBuffer bb, String ident) {\n    if (ident.length() != FILE_IDENTIFIER_LENGTH)\n        throw new AssertionError(\"FlatBuffers: file identifier must be length \" +\n                                 FILE_IDENTIFIER_LENGTH);\n    for (int i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n      if (ident.charAt(i) != (char)bb.get(bb.position() + SIZEOF_INT + i)) return false;\n    }\n    return true;\n  }", "category": "Python"}, {"instruction": "Returns whether the supplied cache loader has bulk load functionality.", "input": "Java", "output": "private static boolean canBulkLoad(AsyncCacheLoader<?, ?> loader) {\n    try {\n      Class<?> defaultLoaderClass = AsyncCacheLoader.class;\n      if (loader instanceof CacheLoader<?, ?>) {\n        defaultLoaderClass = CacheLoader.class;\n\n        Method classLoadAll = loader.getClass().getMethod(\"loadAll\", Iterable.class);\n        Method defaultLoadAll = CacheLoader.class.getMethod(\"loadAll\", Iterable.class);\n        if (!classLoadAll.equals(defaultLoadAll)) {\n          return true;\n        }\n      }\n\n      Method classAsyncLoadAll = loader.getClass().getMethod(\n          \"asyncLoadAll\", Iterable.class, Executor.class);\n      Method defaultAsyncLoadAll = defaultLoaderClass.getMethod(\n          \"asyncLoadAll\", Iterable.class, Executor.class);\n      return !classAsyncLoadAll.equals(defaultAsyncLoadAll);\n    } catch (NoSuchMethodException | SecurityException e) {\n      logger.log(Level.WARNING, \"Cannot determine if CacheLoader can bulk load\", e);\n      return false;\n    }\n  }", "category": "Python"}, {"instruction": "Locates the index for the given key. This method probes using double hashing.\n\n@param key the key for an entry in the map.\n@return the index where the key was found, or {@code -1} if no entry is found for that key.", "input": "Java", "output": "private int indexOf(int key) {\n\t\tint startIndex = hashIndex(key);\n\t\tint index = startIndex;\n\n\t\tfor (;;) {\n\t\t\tif (values[index] == null) {\n\t\t\t\t// It's available, so no chance that this value exists anywhere in the map.\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (key == keys[index]) {\n\t\t\t\treturn index;\n\t\t\t}\n\n\t\t\t// Conflict, keep probing ...\n\t\t\tif ((index = probeNext(index)) == startIndex) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Retrieve authn request authn request.\n\n@param request the request\n@return the authn request\n@throws Exception the exception", "input": "Java", "output": "protected AuthnRequest retrieveSamlAuthenticationRequestFromHttpRequest(final HttpServletRequest request) throws Exception {\n        LOGGER.debug(\"Retrieving authentication request from scope\");\n        val requestValue = request.getParameter(SamlProtocolConstants.PARAMETER_SAML_REQUEST);\n        if (StringUtils.isBlank(requestValue)) {\n            throw new IllegalArgumentException(\"SAML request could not be determined from the authentication request\");\n        }\n        val encodedRequest = EncodingUtils.decodeBase64(requestValue.getBytes(StandardCharsets.UTF_8));\n        return (AuthnRequest) XMLObjectSupport.unmarshallFromInputStream(samlProfileHandlerConfigurationContext.getOpenSamlConfigBean().getParserPool(),\n            new ByteArrayInputStream(encodedRequest));\n    }", "category": "Python"}, {"instruction": "\u5224\u65ad\u81ea\u52a8!=null\u7684\u6761\u4ef6\u7ed3\u6784\n\n@param entityName\n@param column\n@param contents\n@param empty\n@return", "input": "Java", "output": "public static String getIfNotNull(String entityName, EntityColumn column, String contents, boolean empty) {\n        StringBuilder sql = new StringBuilder();\n        sql.append(\"<if test=\\\"\");\n        if (StringUtil.isNotEmpty(entityName)) {\n            sql.append(entityName).append(\".\");\n        }\n        sql.append(column.getProperty()).append(\" != null\");\n        if (empty && column.getJavaType().equals(String.class)) {\n            sql.append(\" and \");\n            if (StringUtil.isNotEmpty(entityName)) {\n                sql.append(entityName).append(\".\");\n            }\n            sql.append(column.getProperty()).append(\" != '' \");\n        }\n        sql.append(\"\\\">\");\n        sql.append(contents);\n        sql.append(\"</if>\");\n        return sql.toString();\n    }", "category": "Python"}, {"instruction": "[TARGET listMetricsAsync(ListOption...)]", "input": "Java", "output": "public Page<Metric> listMetricsAsync() throws ExecutionException, InterruptedException {\n    // [START listMetricsAsync]\n    Future<AsyncPage<Metric>> future = logging.listMetricsAsync(ListOption.pageSize(100));\n    // ...\n    AsyncPage<Metric> metrics = future.get();\n    for (Metric metric : metrics.iterateAll()) {\n      // do something with the metric\n    }\n    // [END listMetricsAsync]\n    return metrics;\n  }", "category": "Python"}, {"instruction": "Find a resource for class name.\n\n@param className The class name\n@return The resource if found, {@code null} otherwise", "input": "Java", "output": "public Resource findResourceForClassName(String className) {\n\n        if (className.contains(CLOSURE_MARKER)) {\n            className = className.substring(0, className.indexOf(CLOSURE_MARKER));\n        }\n        Resource resource = classNameToResourceCache.get(className);\n        if (resource == null) {\n            String classNameWithPathSeparator = className.replace(\".\", FILE_SEPARATOR);\n            for (String pathPattern : getSearchPatternForExtension(classNameWithPathSeparator, \".groovy\", \".java\", \".kt\")) {\n                resource = resolveExceptionSafe(pathPattern);\n                if (resource != null && resource.exists()) {\n                    classNameToResourceCache.put(className, resource);\n                    break;\n                }\n            }\n        }\n        return resource != null && resource.exists() ? resource : null;\n    }", "category": "Python"}, {"instruction": "Value for absent column, i. e. {@link NilColumnValueSelector}, should be equivalent to [null] during index merging.\n\nDuring index merging, if one of the merged indexes has absent columns, {@link StringDimensionMergerV9} ensures\nthat null value is present, and it has index = 0 after sorting, because sorting puts null first. See {@link\nStringDimensionMergerV9#hasNull} and the place where it is assigned.", "input": "Java", "output": "private static IndexedInts getRow(ColumnValueSelector s)\n  {\n    if (s instanceof DimensionSelector) {\n      return ((DimensionSelector) s).getRow();\n    } else if (s instanceof NilColumnValueSelector) {\n      return ZeroIndexedInts.instance();\n    } else {\n      throw new ISE(\n          \"ColumnValueSelector[%s], only DimensionSelector or NilColumnValueSelector is supported\",\n          s.getClass()\n      );\n    }\n  }", "category": "Python"}, {"instruction": "This method builds\n@param op", "input": "Java", "output": "public void processStackCall(Op op, long timeStart) {\n        //StackTraceElement stack[] = Thread.currentThread().getStackTrace();\n\n        long timeSpent = (System.nanoTime() - timeStart) / 1000;\n\n        /*\n           basically we want to unroll stack trace for few levels ABOVE nd4j classes\n           and update invocations list for last few levels, to keep that stat on few levels\n         */\n\n        methodsAggregator.incrementCount(timeSpent);\n    }", "category": "Python"}, {"instruction": "\u9012\u5f52\u538b\u7f29\u6587\u4ef6\u5939<br>\nsrcRootDir\u51b3\u5b9a\u4e86\u8def\u5f84\u622a\u53d6\u7684\u4f4d\u7f6e\uff0c\u4f8b\u5982\uff1a<br>\nfile\u7684\u8def\u5f84\u4e3ad:/a/b/c/d.txt\uff0csrcRootDir\u4e3ad:/a/b\uff0c\u5219\u538b\u7f29\u540e\u7684\u6587\u4ef6\u4e0e\u76ee\u5f55\u4e3a\u7ed3\u6784\u4e3ac/d.txt\n\n@param out \u538b\u7f29\u6587\u4ef6\u5b58\u50a8\u5bf9\u8c61\n@param srcRootDir \u88ab\u538b\u7f29\u7684\u6587\u4ef6\u5939\u6839\u76ee\u5f55\n@param file \u5f53\u524d\u9012\u5f52\u538b\u7f29\u7684\u6587\u4ef6\u6216\u76ee\u5f55\u5bf9\u8c61\n@throws UtilException IO\u5f02\u5e38", "input": "Java", "output": "private static void zip(File file, String srcRootDir, ZipOutputStream out) throws UtilException {\r\n\t\tif (file == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfinal String subPath = FileUtil.subPath(srcRootDir, file); // \u83b7\u53d6\u6587\u4ef6\u76f8\u5bf9\u4e8e\u538b\u7f29\u6587\u4ef6\u5939\u6839\u76ee\u5f55\u7684\u5b50\u8def\u5f84\r\n\t\tif (file.isDirectory()) {// \u5982\u679c\u662f\u76ee\u5f55\uff0c\u5219\u538b\u7f29\u538b\u7f29\u76ee\u5f55\u4e2d\u7684\u6587\u4ef6\u6216\u5b50\u76ee\u5f55\r\n\t\t\tfinal File[] files = file.listFiles();\r\n\t\t\tif (ArrayUtil.isEmpty(files) && StrUtil.isNotEmpty(subPath)) {\r\n\t\t\t\t// \u52a0\u5165\u76ee\u5f55\uff0c\u53ea\u6709\u7a7a\u76ee\u5f55\u65f6\u624d\u52a0\u5165\u76ee\u5f55\uff0c\u975e\u7a7a\u65f6\u4f1a\u5728\u521b\u5efa\u6587\u4ef6\u65f6\u81ea\u52a8\u6dfb\u52a0\u7236\u7ea7\u76ee\u5f55\r\n\t\t\t\taddDir(subPath, out);\r\n\t\t\t}\r\n\t\t\t// \u538b\u7f29\u76ee\u5f55\u4e0b\u7684\u5b50\u6587\u4ef6\u6216\u76ee\u5f55\r\n\t\t\tfor (File childFile : files) {\r\n\t\t\t\tzip(childFile, srcRootDir, out);\r\n\t\t\t}\r\n\t\t} else {// \u5982\u679c\u662f\u6587\u4ef6\u6216\u5176\u5b83\u7b26\u53f7\uff0c\u5219\u76f4\u63a5\u538b\u7f29\u8be5\u6587\u4ef6\r\n\t\t\taddFile(file, subPath, out);\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "Get BatchNormalization epsilon parameter from Keras layer configuration.\n\n@param layerConfig dictionary containing Keras layer configuration\n@return epsilon\n@throws InvalidKerasConfigurationException Invalid Keras config", "input": "Java", "output": "private double getEpsFromConfig(Map<String, Object> layerConfig) throws InvalidKerasConfigurationException {\n        Map<String, Object> innerConfig = KerasLayerUtils.getInnerLayerConfigFromConfig(layerConfig, conf);\n        if (!innerConfig.containsKey(LAYER_FIELD_EPSILON))\n            throw new InvalidKerasConfigurationException(\n                    \"Keras BatchNorm layer config missing \" + LAYER_FIELD_EPSILON + \" field\");\n        return (double) innerConfig.get(LAYER_FIELD_EPSILON);\n    }", "category": "Python"}, {"instruction": "Update the given picker to the helper if it's different from the current one.", "input": "Java", "output": "private void maybeUpdatePicker(ConnectivityState state, RoundRobinPicker picker) {\n    // Discard the new picker if we are sure it won't make any difference, in order to save\n    // re-processing pending streams, and avoid unnecessary resetting of the pointer in\n    // RoundRobinPicker.\n    if (picker.dropList.equals(currentPicker.dropList)\n        && picker.pickList.equals(currentPicker.pickList)) {\n      return;\n    }\n    currentPicker = picker;\n    logger.log(\n        ChannelLogLevel.INFO, \"{0}: picks={1}, drops={2}\", state, picker.pickList, picker.dropList);\n    helper.updateBalancingState(state, picker);\n  }", "category": "Python"}, {"instruction": "Is this computer reachable via the given address?\n\n@param ia      The address to check.\n@param timeout Timeout in seconds.", "input": "Java", "output": "public static boolean checkIsReachable(InetAddress ia, int timeout) throws IOException {\n        for (ComputerPinger pinger : ComputerPinger.all()) {\n            try {\n                if (pinger.isReachable(ia, timeout)) {\n                    return true;\n                }\n            } catch (IOException e) {\n                LOGGER.fine(\"Error checking reachability with \" + pinger + \": \" + e.getMessage());\n            }\n        }\n\n        return false;\n    }", "category": "Python"}, {"instruction": "Saves the client cert settings if the flag is set explicitly.\nOnly works for the CLI currently.", "input": "Java", "output": "private void saveClientCertSettings(){\r\n\r\n        if (getBoolean(PERSIST_CLIENT_CERT, false)){\r\n            logger.warn(\"Saving Client Certificate settings: password will be found in config\");\r\n            setUseClientCert(getBoolean(USE_CLIENT_CERT, false));\r\n            setClientCertLocation(getString(CLIENT_CERT_LOCATION, \"\"));\r\n            setClientCertPassword(getString(CLIENT_CERT_PASSWORD, \"\"));\r\n            setClientCertIndex(getInt(CLIENT_CERT_INDEX, 0));\r\n\r\n        } else {\r\n            // Default to clear settings\r\n            setUseClientCert(false);\r\n            setClientCertLocation(\"\");\r\n            setClientCertPassword(\"\");\r\n            setClientCertIndex(0);\r\n        }\r\n    }", "category": "Python"}, {"instruction": "Private helper that fetches the Instances for each application.\n@param serviceId of the service that the instance list should be returned for\n@return List of instances for a given service id\n@throws Exception - retrieving and marshalling service instances may result in an\nException", "input": "Java", "output": "@Override\n\tprotected List<Instance> getInstancesForApp(String serviceId) throws Exception {\n\t\tList<Instance> instances = new ArrayList<>();\n\t\tlog.info(\"Fetching instances for app: \" + serviceId);\n\t\tApplication app = eurekaClient.getApplication(serviceId);\n\t\tif (app == null) {\n\t\t\tlog.warn(\"Eureka returned null for app: \" + serviceId);\n\t\t\treturn instances;\n\t\t}\n\t\ttry {\n\t\t\tList<InstanceInfo> instancesForApp = app.getInstances();\n\t\t\tif (instancesForApp != null) {\n\t\t\t\tlog.info(\"Received instance list for app: \" + serviceId + \", size=\"\n\t\t\t\t\t\t+ instancesForApp.size());\n\t\t\t\tfor (InstanceInfo iInfo : instancesForApp) {\n\t\t\t\t\tInstance instance = marshall(iInfo);\n\t\t\t\t\tif (instance != null) {\n\t\t\t\t\t\tinstances.add(instance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.warn(\"Failed to retrieve instances from Eureka\", e);\n\t\t}\n\t\treturn instances;\n\t}", "category": "Python"}, {"instruction": "Validates all panels, throwing an exception if there's any validation error.\n<p>\nThe message of the exception can be shown in GUI components (for example, an error dialogue) callers can expect an\ninternationalised message.\n\n@throws Exception if there's any validation error.\n@see #initParam(Object)\n@see #saveParam()", "input": "Java", "output": "public void validateParam() throws Exception {\r\n        Enumeration<AbstractParamPanel> en = tablePanel.elements();\r\n        AbstractParamPanel panel = null;\r\n        while (en.hasMoreElements()) {\r\n            panel = en.nextElement();\r\n            try {\r\n                panel.validateParam(paramObject);\r\n            } catch (Exception e) {\r\n                showParamPanel(panel, panel.getName());\r\n                throw e;\r\n            }\r\n        }\r\n    }", "category": "Python"}, {"instruction": "Programmatically registers the auto-configuration package names. Subsequent\ninvocations will add the given package names to those that have already been\nregistered. You can use this method to manually define the base packages that will\nbe used for a given {@link BeanDefinitionRegistry}. Generally it's recommended that\nyou don't call this method directly, but instead rely on the default convention\nwhere the package name is set from your {@code @EnableAutoConfiguration}\nconfiguration class or classes.\n@param registry the bean definition registry\n@param packageNames the package names to set", "input": "Java", "output": "public static void register(BeanDefinitionRegistry registry, String... packageNames) {\n\t\tif (registry.containsBeanDefinition(BEAN)) {\n\t\t\tBeanDefinition beanDefinition = registry.getBeanDefinition(BEAN);\n\t\t\tConstructorArgumentValues constructorArguments = beanDefinition\n\t\t\t\t\t.getConstructorArgumentValues();\n\t\t\tconstructorArguments.addIndexedArgumentValue(0,\n\t\t\t\t\taddBasePackages(constructorArguments, packageNames));\n\t\t}\n\t\telse {\n\t\t\tGenericBeanDefinition beanDefinition = new GenericBeanDefinition();\n\t\t\tbeanDefinition.setBeanClass(BasePackages.class);\n\t\t\tbeanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0,\n\t\t\t\t\tpackageNames);\n\t\t\tbeanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tregistry.registerBeanDefinition(BEAN, beanDefinition);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Convenience function equivalent to calling\n{@link #createColumnSelectorPluses(ColumnSelectorStrategyFactory, List, ColumnSelectorFactory)} with a singleton\nlist of dimensionSpecs and then retrieving the only element in the returned array.\n\n@param <ColumnSelectorStrategyClass> The strategy type created by the provided strategy factory.\n@param strategyFactory               A factory provided by query engines that generates type-handling strategies\n@param dimensionSpec                 column to generate a ColumnSelectorPlus object for\n@param cursor                        Used to create value selectors for columns.\n\n@return A ColumnSelectorPlus object", "input": "Java", "output": "public static <ColumnSelectorStrategyClass extends ColumnSelectorStrategy> ColumnSelectorPlus<ColumnSelectorStrategyClass> createColumnSelectorPlus(\n      ColumnSelectorStrategyFactory<ColumnSelectorStrategyClass> strategyFactory,\n      DimensionSpec dimensionSpec,\n      ColumnSelectorFactory cursor\n  )\n  {\n    return createColumnSelectorPluses(strategyFactory, ImmutableList.of(dimensionSpec), cursor)[0];\n  }", "category": "Python"}, {"instruction": "\u662f\u5426\u4e3a\u65e5\u671f\u683c\u5f0f<br>\n\u5224\u65ad\u65b9\u5f0f\uff1a\n\n<pre>\n1\u3001\u6307\u5b9a\u5e8f\u53f7\n2\u3001org.apache.poi.ss.usermodel.DateUtil.isADateFormat\u65b9\u6cd5\u5224\u5b9a\n</pre>\n\n@param cell \u5355\u5143\u683c\n@param formatIndex \u683c\u5f0f\u5e8f\u53f7\n@return \u662f\u5426\u4e3a\u65e5\u671f\u683c\u5f0f", "input": "Java", "output": "private static boolean isDateType(Cell cell, int formatIndex) {\r\n\t\t// yyyy-MM-dd----- 14\r\n\t\t// yyyy\u5e74m\u6708d\u65e5---- 31\r\n\t\t// yyyy\u5e74m\u6708------- 57\r\n\t\t// m\u6708d\u65e5 ---------- 58\r\n\t\t// HH:mm----------- 20\r\n\t\t// h\u65f6mm\u5206 -------- 32\r\n\t\tif (formatIndex == 14 || formatIndex == 31 || formatIndex == 57 || formatIndex == 58 || formatIndex == 20 || formatIndex == 32) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (org.apache.poi.ss.usermodel.DateUtil.isCellDateFormatted(cell)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}", "category": "Python"}, {"instruction": "\u8fdb\u884c\u9012\u5f52\u89e3\u6790\u6ce8\u89e3\uff0c\u76f4\u5230\u5168\u90e8\u90fd\u662f\u5143\u6ce8\u89e3\u4e3a\u6b62\n\n@param annotations Class, Method, Field\u7b49", "input": "Java", "output": "private void parseDeclared(Annotation[] annotations) {\r\n\t\tClass<? extends Annotation> annotationType;\r\n\t\t// \u76f4\u63a5\u6ce8\u89e3\r\n\t\tfor (Annotation annotation : annotations) {\r\n\t\t\tannotationType = annotation.annotationType();\r\n\t\t\tif (false == META_ANNOTATIONS.contains(annotationType)) {\r\n\t\t\t\tdeclaredAnnotationMap.put(annotationType, annotation);\r\n\t\t\t\tparseDeclared(annotationType.getDeclaredAnnotations());\r\n\t\t\t}\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "Token count for a user.\n\n@param userId user to count tokens for\n@return count of the user's tokens", "input": "Java", "output": "@View(name = \"count_by_userId\", map = \"function(doc) { if(doc.token && doc.userId) { emit(doc.userId, doc) } }\", reduce = \"_count\")\n    public long countByUserId(final String userId) {\n        val view = createQuery(\"count_by_userId\").key(userId);\n        val rows = db.queryView(view).getRows();\n        if (rows.isEmpty()) {\n            return 0;\n        }\n        return rows.get(0).getValueAsInt();\n    }", "category": "Python"}, {"instruction": "Turns a String text into a sequence of tokens.\n\n@param text                 input text\n@param filters              characters to filter\n@param lower                whether to lowercase input or not\n@param split                by which string to split words (usually single space)\n@return Sequence of tokens as String array", "input": "Java", "output": "public static String[] textToWordSequence(String text, String filters, boolean lower, String split) {\n        if (lower)\n            text = text.toLowerCase();\n\n        for (String filter: filters.split(\"\")) {\n            text = text.replace(filter, split);\n        }\n        String[] sequences = text.split(split);\n        List<String> seqList = new ArrayList(Arrays.asList(sequences));\n        seqList.removeAll(Arrays.asList(\"\", null));\n\n        return seqList.toArray(new String[seqList.size()]);\n    }", "category": "Python"}, {"instruction": "Starts an Actor System at a specific port.\n@param configuration The Flink configuration.\n@param listeningAddress The address to listen at.\n@param listeningPort The port to listen at.\n@param logger the logger to output log information.\n@param actorSystemExecutorConfiguration configuration for the ActorSystem's underlying executor\n@return The ActorSystem which has been started.\n@throws Exception", "input": "Java", "output": "public static ActorSystem startActorSystem(\n\t\t\t\tConfiguration configuration,\n\t\t\t\tString listeningAddress,\n\t\t\t\tint listeningPort,\n\t\t\t\tLogger logger,\n\t\t\t\tActorSystemExecutorConfiguration actorSystemExecutorConfiguration) throws Exception {\n\t\treturn startActorSystem(\n\t\t\tconfiguration,\n\t\t\tAkkaUtils.getFlinkActorSystemName(),\n\t\t\tlisteningAddress,\n\t\t\tlisteningPort,\n\t\t\tlogger,\n\t\t\tactorSystemExecutorConfiguration);\n\t}", "category": "Python"}, {"instruction": "Gets declared method from specified type by mame and parameters types.\n\n@param type           the type\n@param methodName     the name of the method\n@param parameterTypes the parameter array\n@return a {@link Method} object or null if method doesn't exist", "input": "Java", "output": "public static Method getDeclaredMethod(Class<?> type, String methodName, Class<?>... parameterTypes) {\n        Method method = null;\n        try {\n            method = type.getDeclaredMethod(methodName, parameterTypes);\n            if(method.isBridge()){\n                method = MethodProvider.getInstance().unbride(method, type);\n            }\n        } catch (NoSuchMethodException e) {\n            Class<?> superclass = type.getSuperclass();\n            if (superclass != null) {\n                method = getDeclaredMethod(superclass, methodName, parameterTypes);\n            }\n        } catch (ClassNotFoundException e) {\n            Throwables.propagate(e);\n        } catch (IOException e) {\n            Throwables.propagate(e);\n        }\n        return method;\n    }", "category": "Python"}, {"instruction": "Removes the token with the given {@code name}.\n<p>\nThe call to this method has no effect if the given {@code name} is null or empty, or a token with the given {@code name}\ndoes not exist.\n\n@param name the name of the token that will be removed", "input": "Java", "output": "public void removeToken(String name) {\r\n        if (name == null || name.isEmpty()) {\r\n            return;\r\n        }\r\n\r\n        for (Iterator<AntiCsrfParamToken> it = tokens.iterator(); it.hasNext();) {\r\n            AntiCsrfParamToken token = it.next();\r\n            if (name.equals(token.getName())) {\r\n                it.remove();\r\n                if (token.isEnabled()) {\r\n                    this.enabledTokensNames.remove(name);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }", "category": "Python"}, {"instruction": "Validate.\n\n@param profile the profile", "input": "Java", "output": "@JsonIgnore\n    public void validate(final CommonProfile profile) {\n        if (StringUtils.isBlank(getClientId())) {\n            throw new InvalidResourceSetException(HttpStatus.BAD_REQUEST.value(), \"Authentication request does contain a client id\");\n        }\n\n        if (getScopes().isEmpty()) {\n            throw new InvalidResourceSetException(HttpStatus.BAD_REQUEST.value(), \"Resource set registration is missing scopes\");\n        }\n\n        if (!getOwner().equals(profile.getId())) {\n            throw new InvalidResourceSetException(HttpStatus.FORBIDDEN.value(), \"Resource-set owner does not match the authenticated profile\");\n        }\n    }", "category": "Python"}, {"instruction": "Save this samediff instance as a zip file\nwith the training configuration\n@param trainingConfig the training configuration to save\n@param outputStream the output stream to write to\n@throws IOException", "input": "Java", "output": "public void saveWithTrainingConfig(TrainingConfig trainingConfig,OutputStream outputStream) throws  IOException {\n        ObjectMapper objectMapper = ObjectMapperHolder.getJsonMapper();\n        String configJson = objectMapper.writeValueAsString(trainingConfig);\n        ZipOutputStream zipfile = new ZipOutputStream(new CloseShieldOutputStream(outputStream));\n        ZipEntry config = new ZipEntry(TRAINING_CONFIG_JSON_ZIP_ENTRY_NAME);\n        zipfile.putNextEntry(config);\n        zipfile.write(configJson.getBytes());\n\n        ZipEntry sameDiff = new ZipEntry(SAMEDIFF_FILE_ENTRY_NAME);\n        zipfile.putNextEntry(sameDiff);\n\n        val fb = asFlatBuffers();\n        val offset = fb.position();\n\n        val array = fb.array();\n\n        try (BufferedOutputStream zipFileOutputStream = new BufferedOutputStream(zipfile);\n             val dos = new DataOutputStream(zipFileOutputStream)) {\n            dos.write(array, offset, array.length - offset);\n        }\n    }", "category": "Python"}, {"instruction": "Transform an object\nin to another object\n\n@param input the record to transform\n@return the transformed writable", "input": "Java", "output": "@Override\n    public Object map(Object input) {\n        List<Long> list = (List<Long>) input;\n        switch (mathOp) {\n            case Add:\n                long sum = 0;\n                for (Long w : list)\n                    sum += w;\n                return new LongWritable(sum);\n            case Subtract:\n                return list.get(0) - list.get(1);\n            case Multiply:\n                long product = 1;\n                for (Long w : list)\n                    product *= w;\n                return product;\n            case Divide:\n                return list.get(0) / list.get(1);\n            case Modulus:\n                return list.get(0) % list.get(1);\n            case ReverseSubtract:\n            case ReverseDivide:\n            case ScalarMin:\n            case ScalarMax:\n            default:\n                throw new RuntimeException(\"Invalid mathOp: \" + mathOp); //Should never happen\n        }\n    }", "category": "Python"}, {"instruction": "Returns the type of column for given column index.\nThis should be overriden for any custom columns\n\n@param columnIndex the column index\n@return the column class", "input": "Java", "output": "@Override\n\tpublic Class<?> getColumnClass(int columnIndex) {\n\t\tswitch (this.columns[columnIndex]) {\n\t\tcase HREF_ID:\t\treturn Integer.class;\n\t\tcase TYPE_FLAG:\t\treturn ImageIcon.class;\n\t\tcase METHOD:\t\treturn String.class;\n\t\tcase URL:\t\t\treturn String.class;\n\t\tcase CODE:\t\t\treturn Integer.class;\n\t\tcase REASON:\t\treturn String.class;\n\t\tcase RTT:\t\t\treturn Integer.class;\n\t\tcase SIZE:\t\t\treturn Integer.class;\n\t\tcase SESSION_ID:\treturn Long.class;\n\t\tcase ALERT_FLAG:\treturn ImageIcon.class;\n\t\tcase TAGS:\t\t\treturn String.class;\n\t\tdefault:\t\t\treturn null;\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Initialize Settings for child components in build widget\n1. Build Status criteria settings\n2. Build Duration criteria settings\n\n@param buildScoreSettings", "input": "Java", "output": "private void initBuildScoreChildrenSettings(BuildScoreSettings buildScoreSettings) {\n    ScoreComponentSettings buildStatusSettings = Utils.getInstanceIfNull(\n      buildScoreSettings.getStatus(),\n      ScoreComponentSettings.class\n    );\n    buildStatusSettings.setCriteria(\n      Utils.mergeCriteria(buildScoreSettings.getCriteria(), buildStatusSettings.getCriteria())\n    );\n    buildScoreSettings.setStatus(buildStatusSettings);\n\n    BuildScoreSettings.BuildDurationScoreSettings buildDurationSettings = Utils.getInstanceIfNull(\n      buildScoreSettings.getDuration(),\n      BuildScoreSettings.BuildDurationScoreSettings.class\n    );\n\n    buildDurationSettings.setCriteria(\n      Utils.mergeCriteria(buildScoreSettings.getCriteria(), buildDurationSettings.getCriteria())\n    );\n    buildScoreSettings.setDuration(buildDurationSettings);\n  }", "category": "Python"}, {"instruction": "\u6784\u5efa\u961f\u5217\n\n@param size       \u961f\u5217\u5927\u5c0f\n@param isPriority \u662f\u5426\u4f18\u5148\u7ea7\u961f\u5217\n@return \u961f\u5217", "input": "Java", "output": "public static BlockingQueue<Runnable> buildQueue(int size, boolean isPriority) {\n        BlockingQueue<Runnable> queue;\n        if (size == 0) { // \u9ed8\u8ba4\u65e0\u961f\u5217\n            queue = new SynchronousQueue<Runnable>();\n        } else { // \u6709\u9650\u961f\u5217\u6216\u65e0\u9650\u961f\u5217\n            if (isPriority) {\n                queue = size < 0 ? new PriorityBlockingQueue<Runnable>()\n                    : new PriorityBlockingQueue<Runnable>(size);\n            } else {\n                queue = size < 0 ? new LinkedBlockingQueue<Runnable>()\n                    : new LinkedBlockingQueue<Runnable>(size);\n            }\n        }\n        return queue;\n    }", "category": "Python"}, {"instruction": "Produce ticket.\n\n@param <T>                 the type parameter\n@param proxyGrantingTicket the proxy granting ticket\n@param service             the service\n@param ticketId            the ticket id\n@param clazz               the clazz\n@return the ticket", "input": "Java", "output": "protected <T extends Ticket> T produceTicket(final ProxyGrantingTicket proxyGrantingTicket,\n                                                 final Service service, final String ticketId,\n                                                 final Class<T> clazz) {\n        val expirationPolicyToUse = determineExpirationPolicyForService(service);\n        val result = proxyGrantingTicket.grantProxyTicket(\n            ticketId,\n            service,\n            expirationPolicyToUse,\n            this.onlyTrackMostRecentSession);\n\n        if (!clazz.isAssignableFrom(result.getClass())) {\n            throw new ClassCastException(\"Result [\" + result\n                + \" is of type \" + result.getClass()\n                + \" when we were expecting \" + clazz);\n        }\n        return (T) result;\n    }", "category": "Python"}, {"instruction": "Processing of queries with BitmapOffsets, whose Bitmaps has different factorized fullness (bucket), reported from\nthis method, uses different copies of the same code, so JIT compiler analyzes and compiles the code for different\nfactorized fullness separately. The goal is to capture frequency of abstraction usage in compressed bitmap\nalgorithms, i. e.\n- \"Zero sequence\" vs. \"Literal\" vs. \"One sequence\" in {@link org.apache.druid.extendedset.intset.ImmutableConciseSet}\n- {@link org.roaringbitmap.ArrayContainer} vs {@link org.roaringbitmap.BitmapContainer} in Roaring\nand then https://shipilev.net/blog/2015/black-magic-method-dispatch/ comes into play. The secondary goal is to\ncapture HotSpot's thresholds, which it uses to compile conditional blocks differently inside bitmap impls. See\nhttps://bugs.openjdk.java.net/browse/JDK-6743900. The default BlockLayoutMinDiamondPercentage=20, i. e. if\nprobability of taking some branch is less than 20%, it is moved out of the hot path (to save some icache?).\n\nOn the other hand, we don't want to factor fullness into too small pieces, because\n- too little queries may fall into those small buckets, and they are not compiled with Hotspot's C2 compiler\n- if there are a lot of queries for each small factorized fullness and their copies of the code is compiled by\nC2, this pollutes code cache and takes time to perform too many compilations, while some of them likely produce\nidentical code.\n\nIdeally there should be as much buckets as possible as long as Hotspot's C2 output for each bucket is different.", "input": "Java", "output": "private static String factorizeFullness(long bitmapCardinality, long numRows)\n  {\n    if (bitmapCardinality == 0) {\n      return \"0\";\n    } else if (bitmapCardinality == numRows) {\n      return \"1\";\n    } else {\n      double fullness = bitmapCardinality / (double) numRows;\n      int index = Arrays.binarySearch(BITMAP_FULLNESS_FACTORIZATION_STOPS, fullness);\n      if (index < 0) {\n        index = ~index;\n      }\n      return FACTORIZED_FULLNESS[index];\n    }\n  }", "category": "Python"}, {"instruction": "!!! Only supports MySQL", "input": "Java", "output": "public static List<String> findSchemas(JdbcTemplate jdbcTemplate, final String schemaPattern,\n                                           final DdlSchemaFilter ddlSchemaFilter) {\n        List<String> schemas = findSchemas(jdbcTemplate, schemaPattern);\n        if (ddlSchemaFilter == null) {\n            return schemas;\n        }\n        List<String> filterSchemas = new ArrayList<String>();\n        for (String schema : schemas) {\n            if (ddlSchemaFilter.accept(schema)) {\n                filterSchemas.add(schema);\n            }\n        }\n        return filterSchemas;\n    }", "category": "Python"}, {"instruction": "Return the appropriate {@link AnnotationAttributes} from the\n{@link AnnotationMetadata}. By default this method will return attributes for\n{@link #getAnnotationClass()}.\n@param metadata the annotation metadata\n@return annotation attributes", "input": "Java", "output": "protected AnnotationAttributes getAttributes(AnnotationMetadata metadata) {\n\t\tString name = getAnnotationClass().getName();\n\t\tAnnotationAttributes attributes = AnnotationAttributes\n\t\t\t\t.fromMap(metadata.getAnnotationAttributes(name, true));\n\t\tAssert.notNull(attributes,\n\t\t\t\t() -> \"No auto-configuration attributes found. Is \"\n\t\t\t\t\t\t+ metadata.getClassName() + \" annotated with \"\n\t\t\t\t\t\t+ ClassUtils.getShortName(name) + \"?\");\n\t\treturn attributes;\n\t}", "category": "Python"}, {"instruction": "Remove a value from the bag.  This method should only be called\nwith objects obtained by <code>borrow(long, TimeUnit)</code> or <code>reserve(T)</code>\n\n@param bagEntry the value to remove\n@return true if the entry was removed, false otherwise\n@throws IllegalStateException if an attempt is made to remove an object\nfrom the bag that was not borrowed or reserved first", "input": "Java", "output": "public boolean remove(final T bagEntry)\n   {\n      if (!bagEntry.compareAndSet(STATE_IN_USE, STATE_REMOVED) && !bagEntry.compareAndSet(STATE_RESERVED, STATE_REMOVED) && !closed) {\n         LOGGER.warn(\"Attempt to remove an object from the bag that was not borrowed or reserved: {}\", bagEntry);\n         return false;\n      }\n\n      final boolean removed = sharedList.remove(bagEntry);\n      if (!removed && !closed) {\n         LOGGER.warn(\"Attempt to remove an object from the bag that does not exist: {}\", bagEntry);\n      }\n\n      return removed;\n   }", "category": "Python"}, {"instruction": "Takes and rotates the it 90 degrees", "input": "Java", "output": "private static byte[][] rotateArray(byte[][] bitarray) {\n    byte[][] temp = new byte[bitarray[0].length][bitarray.length];\n    for (int ii = 0; ii < bitarray.length; ii++) {\n      // This makes the direction consistent on screen when rotating the\n      // screen;\n      int inverseii = bitarray.length - ii - 1;\n      for (int jj = 0; jj < bitarray[0].length; jj++) {\n        temp[jj][inverseii] = bitarray[ii][jj];\n      }\n    }\n    return temp;\n  }", "category": "Python"}, {"instruction": "If the session has a delegation token obtained from the metastore, then cancel it", "input": "Java", "output": "private void cancelDelegationToken() throws HiveSQLException {\n    if (delegationTokenStr != null) {\n      try {\n        Hive.get(getHiveConf()).cancelDelegationToken(delegationTokenStr);\n      } catch (HiveException e) {\n        throw new HiveSQLException(\"Couldn't cancel delegation token\", e);\n      }\n      // close the metastore connection created with this delegation token\n      Hive.closeCurrent();\n    }\n  }", "category": "Python"}, {"instruction": "\u6241\u5e73\u5316\u590d\u5236\n@param prefix \u524d\u7f00\n@param sourceMap \u539f\u59cbmap\n@param dstMap \u76ee\u6807map", "input": "Java", "output": "public static void flatCopyTo(String prefix, Map<String, Object> sourceMap,\n                                  Map<String, String> dstMap) {\n        for (Map.Entry<String, Object> entry : sourceMap.entrySet()) {\n            String key = prefix + entry.getKey();\n            Object value = entry.getValue();\n            if (value instanceof String) {\n                dstMap.put(key, (String) value);\n            } else if (value instanceof Number) {\n                dstMap.put(key, value.toString());\n            } else if (value instanceof Map) {\n                flatCopyTo(key + \".\", (Map<String, Object>) value, dstMap);\n            }\n        }\n    }", "category": "Python"}, {"instruction": "In addition to the expiration requested by the super class, we also check the expiration is not too far in the future.\nEspecially to detect maliciously crafted cookie.", "input": "Java", "output": "@Override\n    protected boolean isTokenExpired(long tokenExpiryTimeMs) {\n        long nowMs = System.currentTimeMillis();\n        long maxExpirationMs = TimeUnit.SECONDS.toMillis(tokenValiditySeconds) + nowMs;\n        if(!SKIP_TOO_FAR_EXPIRATION_DATE_CHECK && tokenExpiryTimeMs > maxExpirationMs){\n            // attempt to use a cookie that has more than the maximum allowed expiration duration\n            // was either created before a change of configuration or maliciously crafted\n            long diffMs = tokenExpiryTimeMs - maxExpirationMs;\n            LOGGER.log(Level.WARNING, \"Attempt to use a cookie with an expiration duration larger than the one configured (delta of: {0} ms)\", diffMs);\n            return true;\n        }\n        // Check it has not expired\n        if (tokenExpiryTimeMs < nowMs) {\n            return true;\n        }\n        return false;\n    }", "category": "Python"}, {"instruction": "Shuts down a reader, releasing all of its segments. The reader should cease all operations.\n@param lastPosition The last position the reader successfully read from.", "input": "Java", "output": "static void readerShutdown(String readerId, Position lastPosition, StateSynchronizer<ReaderGroupState> sync) {\n        sync.updateState((state, updates) -> {\n            Set<Segment> segments = state.getSegments(readerId);\n            if (segments == null) {\n                return;\n            }\n            log.debug(\"Removing reader {} from reader grop. CurrentState is: {}\", readerId, state);\n            updates.add(new RemoveReader(readerId, lastPosition == null ? Collections.emptyMap()\n                    : lastPosition.asImpl().getOwnedSegmentsWithOffsets()));\n        });\n    }", "category": "Python"}, {"instruction": "Print the job properties except property key contains \"pass\" and \"word\".", "input": "Java", "output": "@VisibleForTesting\n  Map<String, String> printableJobProperties(Props jobProps) {\n    Predicate<String> keyPredicate = new Predicate<String>() {\n\n      @Override\n      public boolean apply(String key) {\n        if (StringUtils.isEmpty(key)) {\n          return true;\n        }\n        key = key.toLowerCase();\n        return !(key.contains(\"pass\") && key.contains(\"word\"));\n      }\n\n    };\n    return Maps.filterKeys(jobProps.getFlattened(), keyPredicate);\n  }", "category": "Python"}, {"instruction": "WAP\u652f\u4ed8\n\n@param response\n{HttpServletResponse}\n@param model\n{AlipayTradeWapPayModel}\n@param returnUrl\n\u5f02\u6b65\u901a\u77e5URL\n@param notifyUrl\n\u540c\u6b65\u901a\u77e5URL\n@return {String}\n@throws {AlipayApiException}\n@throws {IOException}", "input": "Java", "output": "public static String wapPayStr(HttpServletResponse response, AlipayTradeWapPayModel model, String returnUrl,\n\t\t\tString notifyUrl) throws AlipayApiException, IOException {\n\t\tAlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();// \u521b\u5efaAPI\u5bf9\u5e94\u7684request\n\t\talipayRequest.setReturnUrl(returnUrl);\n\t\talipayRequest.setNotifyUrl(notifyUrl);// \u5728\u516c\u5171\u53c2\u6570\u4e2d\u8bbe\u7f6e\u56de\u8df3\u548c\u901a\u77e5\u5730\u5740\n\t\talipayRequest.setBizModel(model);// \u586b\u5145\u4e1a\u52a1\u53c2\u6570\n\t\treturn AliPayApiConfigKit.getAliPayApiConfig().getAlipayClient().pageExecute(alipayRequest).getBody(); // \u8c03\u7528SDK\u751f\u6210\u8868\u5355\n\t}", "category": "Python"}, {"instruction": "An expectation to check if js executable.\n\nUseful when you know that there should be a Javascript value or something at the stage.\n\n@param javaScript used as executable script\n@return true once javaScript executed without errors", "input": "Java", "output": "public static ExpectedCondition<Boolean> javaScriptThrowsNoExceptions(final String javaScript) {\n    return new ExpectedCondition<Boolean>() {\n      @Override\n      public Boolean apply(WebDriver driver) {\n        try {\n          ((JavascriptExecutor) driver).executeScript(javaScript);\n          return true;\n        } catch (WebDriverException e) {\n          return false;\n        }\n      }\n\n      @Override\n      public String toString() {\n        return String.format(\"js %s to be executable\", javaScript);\n      }\n    };\n  }", "category": "Python"}, {"instruction": "For 'speed' reasons, Eclipse works a lot with char arrays. I have my doubts this was a fruitful exercise,\nbut we need to deal with it. This turns [[java][lang][String]] into \"java.lang.String\".", "input": "Java", "output": "public static String toQualifiedName(char[][] typeName) {\n\t\tint len = typeName.length - 1; // number of dots\n\t\tif (len == 0) return new String(typeName[0]);\n\t\t\n\t\tfor (char[] c : typeName) len += c.length;\n\t\tchar[] ret = new char[len];\n\t\tchar[] part = typeName[0];\n\t\tSystem.arraycopy(part, 0, ret, 0, part.length);\n\t\tint pos = part.length;\n\t\tfor (int i = 1; i < typeName.length; i++) {\n\t\t\tret[pos++] = '.';\n\t\t\tpart = typeName[i];\n\t\t\tSystem.arraycopy(part, 0, ret, pos, part.length);\n\t\t\tpos += part.length;\n\t\t}\n\t\treturn new String(ret);\n\t}", "category": "Python"}, {"instruction": "Adds health check URLs to a target pool.\n\n<p>Sample code:\n\n<pre><code>\ntry (TargetPoolClient targetPoolClient = TargetPoolClient.create()) {\nProjectRegionTargetPoolName targetPool = ProjectRegionTargetPoolName.of(\"[PROJECT]\", \"[REGION]\", \"[TARGET_POOL]\");\nTargetPoolsAddHealthCheckRequest targetPoolsAddHealthCheckRequestResource = TargetPoolsAddHealthCheckRequest.newBuilder().build();\nOperation response = targetPoolClient.addHealthCheckTargetPool(targetPool.toString(), targetPoolsAddHealthCheckRequestResource);\n}\n</code></pre>\n\n@param targetPool Name of the target pool to add a health check to.\n@param targetPoolsAddHealthCheckRequestResource\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation addHealthCheckTargetPool(\n      String targetPool,\n      TargetPoolsAddHealthCheckRequest targetPoolsAddHealthCheckRequestResource) {\n\n    AddHealthCheckTargetPoolHttpRequest request =\n        AddHealthCheckTargetPoolHttpRequest.newBuilder()\n            .setTargetPool(targetPool)\n            .setTargetPoolsAddHealthCheckRequestResource(targetPoolsAddHealthCheckRequestResource)\n            .build();\n    return addHealthCheckTargetPool(request);\n  }", "category": "Python"}, {"instruction": "This method duplicates array, and stores it to all devices\n\n@param array", "input": "Java", "output": "public void broadcast(INDArray array) {\n        if (array == null)\n            return;\n\n        Nd4j.getExecutioner().commit();\n\n        val config = OpProfiler.getInstance().getConfig();\n        val locality = config.isCheckLocality();\n\n        if (locality)\n            config.setCheckLocality(false);\n\n        int numDevices = Nd4j.getAffinityManager().getNumberOfDevices();\n        for (int i = 0; i < numDevices; i++) {\n            // if current thread equal to this device - we just save it, without duplication\n            if (Nd4j.getAffinityManager().getDeviceForCurrentThread() == i) {\n                set(i, array);\n            } else {\n                set(i, Nd4j.getAffinityManager().replicateToDevice(i, array));\n            }\n\n        }\n\n        config.setCheckLocality(locality);\n    }", "category": "Python"}, {"instruction": "{@inheritDoc}", "input": "Java", "output": "@Override\n    public long reservePermission(Duration timeoutDuration) {\n        long timeoutInNanos = timeoutDuration.toNanos();\n        State modifiedState = updateStateWithBackOff(timeoutInNanos);\n\n        boolean canAcquireImmediately = modifiedState.nanosToWait <= 0;\n        if (canAcquireImmediately) {\n            publishRateLimiterEvent(true);\n            return 0;\n        }\n\n        boolean canAcquireInTime = timeoutInNanos >= modifiedState.nanosToWait;\n        if (canAcquireInTime) {\n            publishRateLimiterEvent(true);\n            return modifiedState.nanosToWait;\n        }\n\n        publishRateLimiterEvent(false);\n        return -1;\n    }", "category": "Python"}, {"instruction": "Utility method that can be used by subclasses wishing to combine the specified\n{@link ServletContextInitializer} parameters with those defined in this instance.\n@param initializers the initializers to merge\n@return a complete set of merged initializers (with the specified parameters\nappearing first)", "input": "Java", "output": "protected final ServletContextInitializer[] mergeInitializers(\n\t\t\tServletContextInitializer... initializers) {\n\t\tList<ServletContextInitializer> mergedInitializers = new ArrayList<>();\n\t\tmergedInitializers.add((servletContext) -> this.initParameters\n\t\t\t\t.forEach(servletContext::setInitParameter));\n\t\tmergedInitializers.add(new SessionConfiguringInitializer(this.session));\n\t\tmergedInitializers.addAll(Arrays.asList(initializers));\n\t\tmergedInitializers.addAll(this.initializers);\n\t\treturn mergedInitializers.toArray(new ServletContextInitializer[0]);\n\t}", "category": "Python"}, {"instruction": "Splits a comma-separated header value. The returned set is case-insensitive and contains each\npart with whitespace removed.", "input": "Java", "output": "private static List<CharSequence> splitHeader(CharSequence header) {\n        final StringBuilder builder = new StringBuilder(header.length());\n        final List<CharSequence> protocols = new ArrayList<CharSequence>(4);\n        for (int i = 0; i < header.length(); ++i) {\n            char c = header.charAt(i);\n            if (Character.isWhitespace(c)) {\n                // Don't include any whitespace.\n                continue;\n            }\n            if (c == ',') {\n                // Add the string and reset the builder for the next protocol.\n                protocols.add(builder.toString());\n                builder.setLength(0);\n            } else {\n                builder.append(c);\n            }\n        }\n\n        // Add the last protocol\n        if (builder.length() > 0) {\n            protocols.add(builder.toString());\n        }\n\n        return protocols;\n    }", "category": "Python"}, {"instruction": "Set the maximum value. The maximum value is an acceptable value if and\nonly if inclusive is set to true.\n\n@param maximumValue the maximum value\n@param inclusive whether the maximum value is a valid value\n@return this", "input": "Java", "output": "public DoubleParameter setMaximumValue(double maximumValue, boolean inclusive) {\n\t\tif (hasDefaultValue) {\n\t\t\tif (inclusive) {\n\t\t\t\tUtil.checkParameter(maximumValue >= defaultValue,\n\t\t\t\t\t\"Maximum value (\" + maximumValue + \") must be greater than or equal to default (\" + defaultValue + \")\");\n\t\t\t} else {\n\t\t\t\tUtil.checkParameter(maximumValue > defaultValue,\n\t\t\t\t\t\"Maximum value (\" + maximumValue + \") must be greater than default (\" + defaultValue + \")\");\n\t\t\t}\n\t\t} else if (hasMinimumValue) {\n\t\t\tif (inclusive && minimumValueInclusive) {\n\t\t\t\tUtil.checkParameter(maximumValue >= minimumValue,\n\t\t\t\t\t\"Maximum value (\" + maximumValue + \") must be greater than or equal to minimum (\" + minimumValue + \")\");\n\t\t\t} else {\n\t\t\t\tUtil.checkParameter(maximumValue > minimumValue,\n\t\t\t\t\t\"Maximum value (\" + maximumValue + \") must be greater than minimum (\" + minimumValue + \")\");\n\t\t\t}\n\t\t}\n\n\t\tthis.hasMaximumValue = true;\n\t\tthis.maximumValue = maximumValue;\n\t\tthis.maximumValueInclusive = inclusive;\n\n\t\treturn this;\n\t}", "category": "Python"}, {"instruction": "Verifies that no two process definitions share the same key, to prevent database unique\nindex violation.\n\n@throws ActivitiException if any two processes have the same key", "input": "Java", "output": "public void verifyProcessDefinitionsDoNotShareKeys(\n      Collection<ProcessDefinitionEntity> processDefinitions) {\n    Set<String> keySet = new LinkedHashSet<String>();\n    for (ProcessDefinitionEntity processDefinition : processDefinitions) {\n      if (keySet.contains(processDefinition.getKey())) {\n        throw new ActivitiException(\n            \"The deployment contains process definitions with the same key (process id attribute), this is not allowed\");\n      }\n      keySet.add(processDefinition.getKey());\n    }\n  }", "category": "Python"}, {"instruction": "This method serializaes object  into JSON string\n\n@param element\n@return", "input": "Java", "output": "@Override\n    public String serialize(T element) {\n        String json = null;\n        try {\n            json = element.toJSON();\n        } catch (Exception e) {\n            log.error(\"Direct serialization failed, falling back to jackson\");\n        }\n\n        if (json == null || json.isEmpty()) {\n            ObjectMapper mapper = SequenceElement.mapper();\n            try {\n                json = mapper.writeValueAsString(element);\n            } catch (org.nd4j.shade.jackson.core.JsonProcessingException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return json;\n    }", "category": "Python"}, {"instruction": "\u6839\u636e\u5bc6\u94a5\u7c7b\u578b\u83b7\u5f97\u76f8\u5e94\u5bc6\u94a5\n\n@param type \u7c7b\u578b {@link KeyType}\n@return {@link Key}", "input": "Java", "output": "protected Key getKeyByType(KeyType type) {\r\n\t\tswitch (type) {\r\n\t\tcase PrivateKey:\r\n\t\t\tif (null == this.privateKey) {\r\n\t\t\t\tthrow new NullPointerException(\"Private key must not null when use it !\");\r\n\t\t\t}\r\n\t\t\treturn this.privateKey;\r\n\t\tcase PublicKey:\r\n\t\t\tif (null == this.publicKey) {\r\n\t\t\t\tthrow new NullPointerException(\"Public key must not null when use it !\");\r\n\t\t\t}\r\n\t\t\treturn this.publicKey;\r\n\t\t}\r\n\t\tthrow new CryptoException(\"Uknown key type: \" + type);\r\n\t}", "category": "Python"}, {"instruction": "Encodes 64 or 128 bits from the input into a hex trace ID.\n\n@param high Upper 64bits of the trace ID. Zero means the trace ID is 64-bit.\n@param low Lower 64bits of the trace ID.\n@throws IllegalArgumentException if both values are zero", "input": "Java", "output": "public Builder traceId(long high, long low) {\n      if (high == 0L && low == 0L) throw new IllegalArgumentException(\"empty trace ID\");\n      char[] result = new char[high != 0L ? 32 : 16];\n      int pos = 0;\n      if (high != 0L) {\n        writeHexLong(result, pos, high);\n        pos += 16;\n      }\n      writeHexLong(result, pos, low);\n      this.traceId = new String(result);\n      return this;\n    }", "category": "Python"}, {"instruction": "Gets the zone to pick up for this instance.", "input": "Java", "output": "private static int getZoneOffset(String myZone, boolean preferSameZone, String[] availZones) {\n        for (int i = 0; i < availZones.length; i++) {\n            if (myZone != null && (availZones[i].equalsIgnoreCase(myZone.trim()) == preferSameZone)) {\n                return i;\n            }\n        }\n        logger.warn(\"DISCOVERY: Could not pick a zone based on preferred zone settings. My zone - {},\" +\n                \" preferSameZone - {}. Defaulting to {}\", myZone, preferSameZone, availZones[0]);\n\n        return 0;\n    }", "category": "Python"}, {"instruction": "Executes the webflow action.\n\n@param context the context\n@return the event", "input": "Java", "output": "@Override\n    protected Event doExecute(final RequestContext context) {\n        try {\n            val request = WebUtils.getHttpServletRequestFromExternalWebflowContext(context);\n            val wa = request.getParameter(WA);\n            if (StringUtils.isNotBlank(wa) && wa.equalsIgnoreCase(WSIGNIN)) {\n                wsFederationResponseValidator.validateWsFederationAuthenticationRequest(context);\n                return super.doExecute(context);\n            }\n            return wsFederationRequestBuilder.buildAuthenticationRequestEvent(context);\n        } catch (final Exception ex) {\n            LOGGER.error(ex.getMessage(), ex);\n            throw new UnauthorizedServiceException(UnauthorizedServiceException.CODE_UNAUTHZ_SERVICE, ex.getMessage());\n        }\n    }", "category": "Python"}, {"instruction": "Specifies the types for the CSV fields. This method parses the CSV data to a 2-tuple\nwhich has fields of the specified types.\nThis method is overloaded for each possible length of the tuples to support type safe\ncreation of data sets through CSV parsing.\n\n@param type0 The type of CSV field 0 and the type of field 0 in the returned tuple type.\n@param type1 The type of CSV field 1 and the type of field 1 in the returned tuple type.\n@return The {@link org.apache.flink.api.java.DataSet} representing the parsed CSV data.", "input": "Java", "output": "public <T0, T1> DataSource<Tuple2<T0, T1>> types(Class<T0> type0, Class<T1> type1) {\n\t\tTupleTypeInfo<Tuple2<T0, T1>> types = TupleTypeInfo.getBasicAndBasicValueTupleTypeInfo(type0, type1);\n\t\tCsvInputFormat<Tuple2<T0, T1>> inputFormat = new TupleCsvInputFormat<Tuple2<T0, T1>>(path, types, this.includedMask);\n\t\tconfigureInputFormat(inputFormat);\n\t\treturn new DataSource<Tuple2<T0, T1>>(executionContext, inputFormat, types, Utils.getCallLocationName());\n\t}", "category": "Python"}, {"instruction": "Class[]\u8f6cString[] <br>\n\u6ce8\u610f\uff0c\u5f97\u5230\u7684String\u53ef\u80fd\u4e0d\u80fd\u76f4\u63a5\u7528\u4e8eClass.forName\uff0c\u8bf7\u4f7f\u7528getClasses(String[])\u53cd\u5411\u83b7\u53d6\n\n@param types Class[]\n@param javaStyle JDK\u81ea\u5e26\u683c\u5f0f\uff0c\u4f8b\u5982 int[], true\u7684\u8bdd\u8fd4\u56de [I; false\u7684\u8bdd\u8fd4\u56deint[]\n@return \u5bf9\u8c61\u63cf\u8ff0\n@see #getClasses(String[])", "input": "Java", "output": "public static String[] getTypeStrs(Class[] types, boolean javaStyle) {\n        if (CommonUtils.isEmpty(types)) {\n            return StringUtils.EMPTY_STRING_ARRAY;\n        } else {\n            String[] strings = new String[types.length];\n            for (int i = 0; i < types.length; i++) {\n                strings[i] = javaStyle ? types[i].getName() : getTypeStr(types[i]);\n            }\n            return strings;\n        }\n    }", "category": "Python"}, {"instruction": "Updates the task execution state for a given task.\n\n@param taskExecutionState New task execution state for a given task\n@return Acknowledge the task execution state update", "input": "Java", "output": "@Override\n\tpublic CompletableFuture<Acknowledge> updateTaskExecutionState(\n\t\t\tfinal TaskExecutionState taskExecutionState) {\n\t\tcheckNotNull(taskExecutionState, \"taskExecutionState\");\n\n\t\tif (executionGraph.updateState(taskExecutionState)) {\n\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n\t\t} else {\n\t\t\treturn FutureUtils.completedExceptionally(\n\t\t\t\tnew ExecutionGraphException(\"The execution attempt \" +\n\t\t\t\t\ttaskExecutionState.getID() + \" was not found.\"));\n\t\t}\n\t}", "category": "Python"}, {"instruction": "calc the gradient based on the n-step rewards", "input": "Java", "output": "public Gradient[] calcGradient(IDQN current, Stack<MiniTrans<Integer>> rewards) {\n\n        MiniTrans<Integer> minTrans = rewards.pop();\n\n        int size = rewards.size();\n\n        int[] shape = getHistoryProcessor() == null ? mdp.getObservationSpace().getShape()\n                        : getHistoryProcessor().getConf().getShape();\n        int[] nshape = Learning.makeShape(size, shape);\n        INDArray input = Nd4j.create(nshape);\n        INDArray targets = Nd4j.create(size, mdp.getActionSpace().getSize());\n\n        double r = minTrans.getReward();\n        for (int i = size - 1; i >= 0; i--) {\n            minTrans = rewards.pop();\n\n            r = minTrans.getReward() + conf.getGamma() * r;\n            input.putRow(i, minTrans.getObs());\n            INDArray row = minTrans.getOutput()[0];\n            row = row.putScalar(minTrans.getAction(), r);\n            targets.putRow(i, row);\n        }\n\n        return current.gradient(input, targets);\n    }", "category": "Python"}, {"instruction": "Cancel Hadoop Tokens\n\n@param logger logger handler", "input": "Java", "output": "public void cancelHadoopTokens(final Logger logger) {\n    if (tokenFile == null) {\n      return;\n    }\n    try {\n      hadoopSecurityManager.cancelTokens(tokenFile, userToProxy, logger);\n    } catch (HadoopSecurityManagerException e) {\n      logger.error(e.getCause() + e.getMessage());\n    } catch (Exception e) {\n      logger.error(e.getCause() + e.getMessage());\n    }\n    if (tokenFile.exists()) {\n      tokenFile.delete();\n    }\n  }", "category": "Python"}, {"instruction": "Handle asynchronous {@link Runnable}. This method simply executes the given {@link Runnable}\nin the context of the actor thread.\n\n@param runAsync Run async message", "input": "Java", "output": "private void handleRunAsync(RunAsync runAsync) {\n\t\tfinal long timeToRun = runAsync.getTimeNanos();\n\t\tfinal long delayNanos;\n\n\t\tif (timeToRun == 0 || (delayNanos = timeToRun - System.nanoTime()) <= 0) {\n\t\t\t// run immediately\n\t\t\ttry {\n\t\t\t\trunAsync.getRunnable().run();\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlog.error(\"Caught exception while executing runnable in main thread.\", t);\n\t\t\t\tExceptionUtils.rethrowIfFatalErrorOrOOM(t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// schedule for later. send a new message after the delay, which will then be immediately executed\n\t\t\tFiniteDuration delay = new FiniteDuration(delayNanos, TimeUnit.NANOSECONDS);\n\t\t\tRunAsync message = new RunAsync(runAsync.getRunnable(), timeToRun);\n\n\t\t\tfinal Object envelopedSelfMessage = envelopeSelfMessage(message);\n\n\t\t\tgetContext().system().scheduler().scheduleOnce(delay, getSelf(), envelopedSelfMessage,\n\t\t\t\t\tgetContext().dispatcher(), ActorRef.noSender());\n\t\t}\n\t}", "category": "Python"}, {"instruction": "This method tracks op calls\n\n@param op", "input": "Java", "output": "public void processOpCall(CustomOp op) {\n        // total number of invocations\n        invocationsCount.incrementAndGet();\n\n        // number of invocations for this specific op\n        opCounter.incrementCount(op.opName());\n\n        // number of invocations for specific class\n        String opClass = getOpClass(op);\n        classCounter.incrementCount(opClass);\n\n\n        lastZ = 0;\n        prevOpMatching = opClass;\n        prevOpMatchingDetailed = opClass + \" \" + op.opName();\n        prevOpMatchingInverted = opClass + \" \" + op.opName();\n\n        updatePairs(op.opName(), opClass);\n\n        // TODO: to be implemented\n        //for (OpProfilerListener listener : listeners) {\n        //  listener.invoke(op);\n        //}\n    }", "category": "Python"}, {"instruction": "Reads from a data input view a {@link TypeSerializerSnapshot} that was previously\nwritten using {@link TypeSerializerSnapshotSerializationUtil#writeSerializerSnapshot(DataOutputView, TypeSerializerSnapshot, TypeSerializer)}.\n\n@param in the data input view\n@param userCodeClassLoader the user code class loader to use\n@param existingPriorSerializer the prior serializer. This would only be non-null if we are\nrestoring from a snapshot taken with Flink version <= 1.6.\n\n@return the read serializer configuration snapshot", "input": "Java", "output": "public static <T> TypeSerializerSnapshot<T> readSerializerSnapshot(\n\t\t\tDataInputView in,\n\t\t\tClassLoader userCodeClassLoader,\n\t\t\t@Nullable TypeSerializer<T> existingPriorSerializer) throws IOException {\n\n\t\tfinal TypeSerializerSnapshotSerializationProxy<T> proxy =\n\t\t\tnew TypeSerializerSnapshotSerializationProxy<>(userCodeClassLoader, existingPriorSerializer);\n\t\tproxy.read(in);\n\n\t\treturn proxy.getSerializerSnapshot();\n\t}", "category": "Python"}, {"instruction": "Checks whether the given directory exists and is writable. If it doesn't exist, this method\nwill attempt to create it.\n\n@param uploadDir directory to check\n@param log logger used for logging output\n@throws IOException if the directory does not exist and cannot be created, or if the\ndirectory isn't writable", "input": "Java", "output": "private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {\n\t\tif (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {\n\t\t\tlog.info(\"Using directory {} for file uploads.\", uploadDir);\n\t\t} else if (Files.isWritable(Files.createDirectories(uploadDir))) {\n\t\t\tlog.info(\"Created directory {} for file uploads.\", uploadDir);\n\t\t} else {\n\t\t\tlog.warn(\"Upload directory {} cannot be created or is not writable.\", uploadDir);\n\t\t\tthrow new IOException(\n\t\t\t\tString.format(\"Upload directory %s cannot be created or is not writable.\",\n\t\t\t\t\tuploadDir));\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Recursively retrieve files that match the given pattern,\nadding them to the given result list.\n\n@param fullPattern the pattern to match against,\nwith prepended root directory path\n@param dir         the current directory\n@param result      the Set of matching File instances to add to\n@throws IOException if directory contents could not be retrieved", "input": "Java", "output": "protected void doRetrieveMatchingFiles(String fullPattern, File dir, Set<File> result) throws IOException {\n        File[] dirContents = dir.listFiles();\n        if (dirContents == null) {\n            return;\n        }\n        for (File content : dirContents) {\n            String currPath = content.getAbsolutePath().replace(File.separator, \"/\");\n            if (content.isDirectory() && getPathMatcher().matchStart(fullPattern, currPath + \"/\")) {\n                if (content.canRead()) {\n                    doRetrieveMatchingFiles(fullPattern, content, result);\n                }\n            }\n            if (getPathMatcher().match(fullPattern, currPath)) {\n                result.add(content);\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Sets the access control policy on the specified resource. Replaces any existing policy.\n\n<p>Sample code:\n\n<pre><code>\ntry (InstanceTemplateClient instanceTemplateClient = InstanceTemplateClient.create()) {\nProjectGlobalInstanceTemplateResourceName resource = ProjectGlobalInstanceTemplateResourceName.of(\"[PROJECT]\", \"[RESOURCE]\");\nGlobalSetPolicyRequest globalSetPolicyRequestResource = GlobalSetPolicyRequest.newBuilder().build();\nPolicy response = instanceTemplateClient.setIamPolicyInstanceTemplate(resource, globalSetPolicyRequestResource);\n}\n</code></pre>\n\n@param resource Name or id of the resource for this request.\n@param globalSetPolicyRequestResource\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Policy setIamPolicyInstanceTemplate(\n      ProjectGlobalInstanceTemplateResourceName resource,\n      GlobalSetPolicyRequest globalSetPolicyRequestResource) {\n\n    SetIamPolicyInstanceTemplateHttpRequest request =\n        SetIamPolicyInstanceTemplateHttpRequest.newBuilder()\n            .setResource(resource == null ? null : resource.toString())\n            .setGlobalSetPolicyRequestResource(globalSetPolicyRequestResource)\n            .build();\n    return setIamPolicyInstanceTemplate(request);\n  }", "category": "Python"}, {"instruction": "true if {@link AbstractBuild#hasParticipant} or {@link hudson.model.Cause.UserIdCause}", "input": "Java", "output": "private boolean relatedTo(@Nonnull AbstractBuild<?, ?> b) {\n        if (b.hasParticipant(this)) {\n            return true;\n        }\n        for (Cause cause : b.getCauses()) {\n            if (cause instanceof Cause.UserIdCause) {\n                String userId = ((Cause.UserIdCause) cause).getUserId();\n                if (userId != null && idStrategy().equals(userId, getId())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }", "category": "Python"}, {"instruction": "Encode ticket id into a SHA-512.\n\n@param ticketId the ticket id\n@return the ticket", "input": "Java", "output": "protected String encodeTicketId(final String ticketId) {\n        if (!isCipherExecutorEnabled()) {\n            LOGGER.trace(MESSAGE);\n            return ticketId;\n        }\n        if (StringUtils.isBlank(ticketId)) {\n            return ticketId;\n        }\n        val encodedId = DigestUtils.sha512(ticketId);\n        LOGGER.debug(\"Encoded original ticket id [{}] to [{}]\", ticketId, encodedId);\n        return encodedId;\n    }", "category": "Python"}, {"instruction": "Use ZipOutputStream to zip text to byte array, then convert\nbyte array to base64 string, so it can be transferred via http request.\n\n@param srcTxt the src txt\n@return the string in UTF-8 format and base64'ed, or null.", "input": "Java", "output": "@SneakyThrows\n    public static String compress(final String srcTxt) {\n        try (val rstBao = new ByteArrayOutputStream(); val zos = new GZIPOutputStream(rstBao)) {\n            zos.write(srcTxt.getBytes(StandardCharsets.UTF_8));\n            zos.flush();\n            zos.finish();\n            val bytes = rstBao.toByteArray();\n            val base64 = StringUtils.remove(EncodingUtils.encodeBase64(bytes), '\\0');\n            return new String(StandardCharsets.UTF_8.encode(base64).array(), StandardCharsets.UTF_8);\n        }\n    }", "category": "Python"}, {"instruction": "Configure ldap authentication provider.\n\n@param auth the auth\n@param ldap the ldap", "input": "Java", "output": "protected void configureLdapAuthenticationProvider(final AuthenticationManagerBuilder auth, final MonitorProperties.Endpoints.LdapSecurity ldap) {\n        if (isLdapAuthorizationActive()) {\n            val p = new MonitorEndpointLdapAuthenticationProvider(ldap, securityProperties);\n            auth.authenticationProvider(p);\n        } else {\n            LOGGER.trace(\"LDAP authorization is undefined, given no LDAP url, base-dn, search filter or role/group filter is configured\");\n        }\n    }", "category": "Python"}, {"instruction": "Create merge engine instance.\n\n@param databaseType database type\n@param shardingRule sharding rule\n@param routeResult SQL route result\n@param shardingTableMetaData sharding table meta Data\n@param queryResults query results\n@return merge engine instance\n@throws SQLException SQL exception", "input": "Java", "output": "public static MergeEngine newInstance(final DatabaseType databaseType, final ShardingRule shardingRule,\n                                          final SQLRouteResult routeResult, final ShardingTableMetaData shardingTableMetaData, final List<QueryResult> queryResults) throws SQLException {\n        if (routeResult.getSqlStatement() instanceof SelectStatement) {\n            return new DQLMergeEngine(databaseType, routeResult, queryResults);\n        } \n        if (routeResult.getSqlStatement() instanceof DALStatement) {\n            return new DALMergeEngine(shardingRule, queryResults, (DALStatement) routeResult.getSqlStatement(), shardingTableMetaData);\n        }\n        throw new UnsupportedOperationException(String.format(\"Cannot support type '%s'\", routeResult.getSqlStatement().getType()));\n    }", "category": "Python"}, {"instruction": "Convert a string time series to\nthe proper writable set based on the schema.\nNote that this does not use arrow.\nThis just uses normal writable objects.\n\n@param stringInput the string input\n@param schema the schema to use\n@return the converted records", "input": "Java", "output": "public static List<List<String>> convertWritableInputToString(List<List<Writable>> stringInput,Schema schema) {\n        List<List<String>> ret = new ArrayList<>();\n        List<List<String>> timeStepAdd = new ArrayList<>();\n        for(int j = 0; j < stringInput.size(); j++) {\n            List<Writable> record = stringInput.get(j);\n            List<String> recordAdd = new ArrayList<>();\n            for(int k = 0; k < record.size(); k++) {\n                recordAdd.add(record.get(k).toString());\n            }\n\n            timeStepAdd.add(recordAdd);\n        }\n\n\n        return ret;\n    }", "category": "Python"}, {"instruction": "------------------------------------------------------------------------", "input": "Java", "output": "@Override\n\tpublic Long getValue() {\n\t\tfinal JobStatus status = eg.getState();\n\n\t\tif (status == JobStatus.RUNNING) {\n\t\t\t// running right now - report the uptime\n\t\t\tfinal long runningTimestamp = eg.getStatusTimestamp(JobStatus.RUNNING);\n\t\t\t// we use 'Math.max' here to avoid negative timestamps when clocks change\n\t\t\treturn Math.max(System.currentTimeMillis() - runningTimestamp, 0);\n\t\t}\n\t\telse if (status.isTerminalState()) {\n\t\t\t// not running any more -> finished or not on leader\n\t\t\treturn NO_LONGER_RUNNING;\n\t\t}\n\t\telse {\n\t\t\t// not yet running or not up at the moment\n\t\t\treturn 0L;\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Instantiates a template and begins execution.\n\n<p>This method is equivalent to executing the sequence\n[CreateWorkflowTemplate][google.cloud.dataproc.v1beta2.WorkflowTemplateService.CreateWorkflowTemplate],\n[InstantiateWorkflowTemplate][google.cloud.dataproc.v1beta2.WorkflowTemplateService.InstantiateWorkflowTemplate],\n[DeleteWorkflowTemplate][google.cloud.dataproc.v1beta2.WorkflowTemplateService.DeleteWorkflowTemplate].\n\n<p>The returned Operation can be used to track execution of workflow by polling\n[operations.get][google.longrunning.Operations.GetOperation]. The Operation will complete when\nentire workflow is finished.\n\n<p>The running workflow can be aborted via\n[operations.cancel][google.longrunning.Operations.CancelOperation]. This will cause any\ninflight jobs to be cancelled and workflow-owned clusters to be deleted.\n\n<p>The [Operation.metadata][google.longrunning.Operation.metadata] will be\n[WorkflowMetadata][google.cloud.dataproc.v1beta2.WorkflowMetadata].\n\n<p>On successful completion, [Operation.response][google.longrunning.Operation.response] will\nbe [Empty][google.protobuf.Empty].\n\n<p>Sample code:\n\n<pre><code>\ntry (WorkflowTemplateServiceClient workflowTemplateServiceClient = WorkflowTemplateServiceClient.create()) {\nString formattedParent = RegionName.format(\"[PROJECT]\", \"[REGION]\");\nWorkflowTemplate template = WorkflowTemplate.newBuilder().build();\nworkflowTemplateServiceClient.instantiateInlineWorkflowTemplateAsync(formattedParent, template).get();\n}\n</code></pre>\n\n@param parent Required. The \"resource name\" of the workflow template region, as described in\nhttps://cloud.google.com/apis/design/resource_names of the form\n`projects/{project_id}/regions/{region}`\n@param template Required. The workflow template to instantiate.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi(\n      \"The surface for long-running operations is not stable yet and may change in the future.\")\n  public final OperationFuture<Empty, WorkflowMetadata> instantiateInlineWorkflowTemplateAsync(\n      String parent, WorkflowTemplate template) {\n\n    InstantiateInlineWorkflowTemplateRequest request =\n        InstantiateInlineWorkflowTemplateRequest.newBuilder()\n            .setParent(parent)\n            .setTemplate(template)\n            .build();\n    return instantiateInlineWorkflowTemplateAsync(request);\n  }", "category": "Python"}, {"instruction": "return current date time by specified hour:minute\n\n@param plan format: hh:mm", "input": "Java", "output": "public static Date getCurrentDateByPlan(String plan, String pattern) {\n\t\ttry {\n\t\t\tFastDateFormat format = FastDateFormat.getInstance(pattern);\n\t\t\tDate end = format.parse(plan);\n\t\t\tCalendar today = Calendar.getInstance();\n\t\t\tend = DateUtils.setYears(end, (today.get(Calendar.YEAR)));\n\t\t\tend = DateUtils.setMonths(end, today.get(Calendar.MONTH));\n\t\t\tend = DateUtils.setDays(end, today.get(Calendar.DAY_OF_MONTH));\n\t\t\treturn end;\n\t\t} catch (Exception e) {\n\t\t\tthrow ExceptionUtil.unchecked(e);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Returns the number of selected messages of the given message container.\n<p>\nBy default it returns the number of selected messages from {@code SelectableHttpMessagesContainer}s and for\n{@code SingleHttpMessageContainer}s returns 1 if it contains a message, 0 otherwise.\n</p>\n<p>\nNormally overridden if other implementations of {@code HttpMessageContainer} are supported. Default are\n{@code SingleHttpMessageContainer} and {@code SelectableHttpMessagesContainer}.\n</p>\n\n@param httpMessageContainer the container that will be evaluated\n@return the number of selected messages in the message container\n@see SingleHttpMessageContainer\n@see SelectableHttpMessagesContainer", "input": "Java", "output": "protected int getNumberOfSelectedMessages(HttpMessageContainer httpMessageContainer) {\n        if (httpMessageContainer instanceof SelectableHttpMessagesContainer) {\n            return ((SelectableHttpMessagesContainer) httpMessageContainer).getNumberOfSelectedMessages();\n        } else if (httpMessageContainer instanceof SingleHttpMessageContainer) {\n            return ((SingleHttpMessageContainer) httpMessageContainer).isEmpty() ? 0 : 1;\n        }\n\n        return 0;\n    }", "category": "Python"}, {"instruction": "Calculate the output shape for this op\n\n@return", "input": "Java", "output": "public List<LongShapeDescriptor> calculateOutputShape() {\n        if(x == null || y == null)\n            return Collections.emptyList();\n\n        long[] shapeX = x.shape();\n        long[] shapeY = y.shape();\n\n        return Collections.singletonList(LongShapeDescriptor.fromShape(Shape.broadcastOutputShape(shapeX, shapeY),\n                Shape.pickPairwiseDataType(x.dataType(), y.dataType())));\n    }", "category": "Python"}, {"instruction": "------------------------------------------------------------------------", "input": "Java", "output": "@Override\n\tpublic void report() {\n\t\t// instead of locking here, we tolerate exceptions\n\t\t// we do this to prevent holding the lock for very long and blocking\n\t\t// operator creation and shutdown\n\t\ttry {\n\t\t\tfor (Map.Entry<Gauge<?>, String> entry : gauges.entrySet()) {\n\t\t\t\tif (closed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treportGauge(entry.getValue(), entry.getKey());\n\t\t\t}\n\n\t\t\tfor (Map.Entry<Counter, String> entry : counters.entrySet()) {\n\t\t\t\tif (closed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treportCounter(entry.getValue(), entry.getKey());\n\t\t\t}\n\n\t\t\tfor (Map.Entry<Histogram, String> entry : histograms.entrySet()) {\n\t\t\t\treportHistogram(entry.getValue(), entry.getKey());\n\t\t\t}\n\n\t\t\tfor (Map.Entry<Meter, String> entry : meters.entrySet()) {\n\t\t\t\treportMeter(entry.getValue(), entry.getKey());\n\t\t\t}\n\t\t}\n\t\tcatch (ConcurrentModificationException | NoSuchElementException e) {\n\t\t\t// ignore - may happen when metrics are concurrently added or removed\n\t\t\t// report next time\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Tries to load the record #N.\n\n@return null if the data failed to load.", "input": "Java", "output": "private R load(int n, Index editInPlace) {\n        assert Thread.holdsLock(this);\n        assert dir != null;\n        R v = load(new File(dir, String.valueOf(n)), editInPlace);\n        if (v==null && editInPlace!=null) {\n            // remember the failure.\n            // if editInPlace==null, we can create a new copy for this, but not sure if it's worth doing,\n            // TODO should we also update numberOnDisk?\n            editInPlace.byNumber.put(n, null);\n        }\n        return v;\n    }", "category": "Python"}, {"instruction": "Checks if the constant pool contains a reference to a given method, with any signature (return type and parameter types).\n\n@param className must be provided JVM-style, such as {@code java/lang/String}", "input": "Java", "output": "public boolean usesMethod(String className, String methodName) {\n\t\tint classIndex = findClass(className);\n\t\tif (classIndex == NOT_FOUND) return false;\n\t\tint methodNameIndex = findUtf8(methodName);\n\t\tif (methodNameIndex == NOT_FOUND) return false;\n\t\t\n\t\tfor (int i = 1; i < maxPoolSize; i++) {\n\t\t\tif (isMethod(i) && readValue(offsets[i]) == classIndex) {\n\t\t\t\tint nameAndTypeIndex = readValue(offsets[i] + 2);\n\t\t\t\tif (readValue(offsets[nameAndTypeIndex]) == methodNameIndex) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "category": "Python"}, {"instruction": "\u5339\u914d\u6bcd\u6587\u672c\n\n@param text \u4e00\u4e9b\u6587\u672c\n@return \u4e00\u4e2apair\u5217\u8868", "input": "Java", "output": "public List<Hit<V>> parseText(String text)\n    {\n        int position = 1;\n        int currentState = 0;\n        List<Hit<V>> collectedEmits = new LinkedList<Hit<V>>();\n        for (int i = 0; i < text.length(); ++i)\n        {\n            currentState = getState(currentState, text.charAt(i));\n            storeEmits(position, currentState, collectedEmits);\n            ++position;\n        }\n\n        return collectedEmits;\n    }", "category": "Python"}, {"instruction": "Subscribe provider list from direct url\n\n@param directUrl direct url of consume config\n@return Provider group list", "input": "Java", "output": "protected List<ProviderGroup> subscribeFromDirectUrl(String directUrl) {\n        List<ProviderGroup> result = new ArrayList<ProviderGroup>();\n        List<ProviderInfo> tmpProviderInfoList = new ArrayList<ProviderInfo>();\n        String[] providerStrs = StringUtils.splitWithCommaOrSemicolon(directUrl);\n        for (String providerStr : providerStrs) {\n            ProviderInfo providerInfo = convertToProviderInfo(providerStr);\n            if (providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_SOURCE) == null) {\n                providerInfo.setStaticAttr(ProviderInfoAttrs.ATTR_SOURCE, \"direct\");\n            }\n            tmpProviderInfoList.add(providerInfo);\n        }\n\n        result.add(new ProviderGroup(RpcConstants.ADDRESS_DIRECT_GROUP, tmpProviderInfoList));\n        return result;\n    }", "category": "Python"}, {"instruction": "Raw digest byte [ ].\n\n@param alg  the alg\n@param salt the salt\n@param data the data\n@return the byte [ ]", "input": "Java", "output": "public static byte[] rawDigest(final String alg, final String salt, final String... data) {\n        try {\n            val digest = getMessageDigestInstance(alg);\n            Arrays.stream(data).forEach(d -> digest.update(d.getBytes(StandardCharsets.UTF_8)));\n            return digest.digest(salt.getBytes(StandardCharsets.UTF_8));\n        } catch (final Exception cause) {\n            throw new SecurityException(cause);\n        }\n    }", "category": "Python"}, {"instruction": "Delete TGT's service tickets.\n\n@param ticket the ticket\n@return the count of tickets that were removed including child tickets and zero if the ticket was not deleted", "input": "Java", "output": "protected int deleteChildren(final TicketGrantingTicket ticket) {\n        val count = new AtomicInteger(0);\n        val services = ticket.getServices();\n        if (services != null && !services.isEmpty()) {\n            services.keySet().forEach(ticketId -> {\n                if (deleteSingleTicket(ticketId)) {\n                    LOGGER.debug(\"Removed ticket [{}]\", ticketId);\n                    count.incrementAndGet();\n                } else {\n                    LOGGER.debug(\"Unable to remove ticket [{}]\", ticketId);\n                }\n            });\n        }\n        return count.intValue();\n    }", "category": "Python"}, {"instruction": "Resolve the JVM arguments to use.\n@return a {@link RunArguments} defining the JVM arguments", "input": "Java", "output": "protected RunArguments resolveJvmArguments() {\n\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\tif (this.systemPropertyVariables != null) {\n\t\t\tstringBuilder.append(this.systemPropertyVariables.entrySet().stream()\n\t\t\t\t\t.map((e) -> SystemPropertyFormatter.format(e.getKey(), e.getValue()))\n\t\t\t\t\t.collect(Collectors.joining(\" \")));\n\t\t}\n\t\tif (this.jvmArguments != null) {\n\t\t\tstringBuilder.append(\" \").append(this.jvmArguments);\n\t\t}\n\t\treturn new RunArguments(stringBuilder.toString());\n\t}", "category": "Python"}, {"instruction": "\u521b\u5efa\u7528\u4e8e\u67e5\u8be2\u8bed\u53e5\u7684{@link URLEncoder}<br>\n\u7f16\u7801\u5668\u9488\u5bf9URI\u8def\u5f84\u7f16\u7801\uff0c\u5b9a\u4e49\u5982\u4e0b\uff1a\n\n<pre>\n0x20 ' ' =\u300b '+'\n0x2A, 0x2D, 0x2E, 0x30 to 0x39, 0x41 to 0x5A, 0x5F, 0x61 to 0x7A as-is\n'*', '-', '.', '0' to '9', 'A' to 'Z', '_', 'a' to 'z' Also '=' and '&' \u4e0d\u7f16\u7801\n\u5176\u5b83\u7f16\u7801\u4e3a %nn \u5f62\u5f0f\n</pre>\n\n\u8be6\u7ec6\u89c1\uff1ahttps://www.w3.org/TR/html5/forms.html#application/x-www-form-urlencoded-encoding-algorithm\n\n@return {@link URLEncoder}", "input": "Java", "output": "public static URLEncoder createQuery() {\r\n\t\tfinal URLEncoder encoder = new URLEncoder();\r\n\t\t// Special encoding for space\r\n\t\tencoder.setEncodeSpaceAsPlus(true);\r\n\t\t// Alpha and digit are safe by default\r\n\t\t// Add the other permitted characters\r\n\t\tencoder.addSafeCharacter('*');\r\n\t\tencoder.addSafeCharacter('-');\r\n\t\tencoder.addSafeCharacter('.');\r\n\t\tencoder.addSafeCharacter('_');\r\n\t\tencoder.addSafeCharacter('=');\r\n\t\tencoder.addSafeCharacter('&');\r\n\r\n\t\treturn encoder;\r\n\t}", "category": "Python"}, {"instruction": "This method initializes this", "input": "Java", "output": "private void initialize() {\r\n        this.setCursor(new java.awt.Cursor(java.awt.Cursor.WAIT_CURSOR));\r\n        this.setContentPane(getJPanel());\r\n        if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {\r\n        \tthis.setSize(282, 118);\r\n        }\r\n        this.setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);\r\n        this.setResizable(false);\r\n\t\t\t\r\n\t}", "category": "Python"}, {"instruction": "Update account info from account object.\n@param account to be updated\n@return this", "input": "Java", "output": "public CouchDbGoogleAuthenticatorAccount update(final OneTimeTokenAccount account) {\n        setId(account.getId());\n        setUsername(account.getUsername());\n        setSecretKey(account.getSecretKey());\n        setValidationCode(account.getValidationCode());\n        setScratchCodes(account.getScratchCodes());\n        setRegistrationDate(account.getRegistrationDate());\n        return this;\n    }", "category": "Python"}, {"instruction": "Eagerly reads {@code byteCount} bytes from the source before launching a background task to\nprocess the data.  This avoids corrupting the stream.", "input": "Java", "output": "void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,\n      final boolean inFinished) throws IOException {\n    final Buffer buffer = new Buffer();\n    source.require(byteCount); // Eagerly read the frame before firing client thread.\n    source.read(buffer, byteCount);\n    if (buffer.size() != byteCount) throw new IOException(buffer.size() + \" != \" + byteCount);\n    pushExecutorExecute(new NamedRunnable(\"OkHttp %s Push Data[%s]\", connectionName, streamId) {\n      @Override public void execute() {\n        try {\n          boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);\n          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);\n          if (cancel || inFinished) {\n            synchronized (Http2Connection.this) {\n              currentPushRequests.remove(streamId);\n            }\n          }\n        } catch (IOException ignored) {\n        }\n      }\n    });\n  }", "category": "Python"}, {"instruction": "Gets the serializer that recognizes the previous serialization schema of the state.\nThis is the serializer that should be used for restoring the state, i.e. when the state\nis still in the previous serialization schema.\n\n<p>This method only returns a serializer if this provider has the previous serializer's\nsnapshot. Otherwise, trying to access the previous schema serializer will fail\nwith an exception.\n\n@return a serializer that reads and writes in the previous schema of the state.", "input": "Java", "output": "@Nonnull\n\tpublic final TypeSerializer<T> previousSchemaSerializer() {\n\t\tif (cachedRestoredSerializer != null) {\n\t\t\treturn cachedRestoredSerializer;\n\t\t}\n\n\t\tif (previousSerializerSnapshot == null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"This provider does not contain the state's previous serializer's snapshot. Cannot provider a serializer for previous schema.\");\n\t\t}\n\n\t\tthis.cachedRestoredSerializer = previousSerializerSnapshot.restoreSerializer();\n\t\treturn cachedRestoredSerializer;\n\t}", "category": "Python"}, {"instruction": "\u5bf9\u6bd4\u4e24\u4e2aReader\u7684\u5185\u5bb9\u662f\u5426\u4e00\u81f4<br>\n\u5185\u90e8\u4f1a\u8f6c\u6362\u6d41\u4e3a {@link BufferedInputStream}\n\n@param input1 \u7b2c\u4e00\u4e2areader\n@param input2 \u7b2c\u4e8c\u4e2areader\n@return \u4e24\u4e2a\u6d41\u7684\u5185\u5bb9\u4e00\u81f4\u8fd4\u56detrue\uff0c\u5426\u5219false\n@throws IORuntimeException IO\u5f02\u5e38\n@since 4.0.6", "input": "Java", "output": "public static boolean contentEquals(Reader input1, Reader input2) throws IORuntimeException {\r\n\t\tinput1 = getReader(input1);\r\n\t\tinput2 = getReader(input2);\r\n\r\n\t\ttry {\r\n\t\t\tint ch = input1.read();\r\n\t\t\twhile (EOF != ch) {\r\n\t\t\t\tint ch2 = input2.read();\r\n\t\t\t\tif (ch != ch2) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tch = input1.read();\r\n\t\t\t}\r\n\r\n\t\t\tint ch2 = input2.read();\r\n\t\t\treturn ch2 == EOF;\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new IORuntimeException(e);\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "\u5c1d\u8bd5\u904d\u5386\u5e76\u8c03\u7528\u6b64\u7c7b\u7684\u6240\u6709\u6784\u9020\u65b9\u6cd5\uff0c\u76f4\u5230\u6784\u9020\u6210\u529f\u5e76\u8fd4\u56de\n\n@param <T> \u5bf9\u8c61\u7c7b\u578b\n@param beanClass \u88ab\u6784\u9020\u7684\u7c7b\n@return \u6784\u9020\u540e\u7684\u5bf9\u8c61", "input": "Java", "output": "public static <T> T newInstanceIfPossible(Class<T> beanClass) {\r\n\t\tAssert.notNull(beanClass);\r\n\t\ttry {\r\n\t\t\treturn newInstance(beanClass);\r\n\t\t} catch (Exception e) {\r\n\t\t\t// ignore\r\n\t\t\t// \u9ed8\u8ba4\u6784\u9020\u4e0d\u5b58\u5728\u7684\u60c5\u51b5\u4e0b\u67e5\u627e\u5176\u5b83\u6784\u9020\r\n\t\t}\r\n\t\t\r\n\t\tfinal Constructor<T>[] constructors = getConstructors(beanClass);\r\n\t\tClass<?>[] parameterTypes;\r\n\t\tfor (Constructor<T> constructor : constructors) {\r\n\t\t\tparameterTypes = constructor.getParameterTypes();\r\n\t\t\tif (0 == parameterTypes.length) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconstructor.setAccessible(true);\r\n\t\t\ttry {\r\n\t\t\t\treturn constructor.newInstance(ClassUtil.getDefaultValues(parameterTypes));\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\t// \u6784\u9020\u51fa\u9519\u65f6\u7ee7\u7eed\u5c1d\u8bd5\u4e0b\u4e00\u79cd\u6784\u9020\u65b9\u5f0f\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}", "category": "Python"}, {"instruction": "Sets the number of fields in the record. If the new number of fields is longer than the current number of\nfields, then null fields are appended. If the new number of fields is smaller than the current number of\nfields, then the last fields are truncated.\n\n@param numFields The new number of fields.", "input": "Java", "output": "public void setNumFields(final int numFields) {\n\t\tfinal int oldNumFields = this.numFields;\n\t\t// check whether we increase or decrease the fields \n\t\tif (numFields > oldNumFields) {\n\t\t\tmakeSpace(numFields);\n\t\t\tfor (int i = oldNumFields; i < numFields; i++) {\n\t\t\t\tthis.offsets[i] = NULL_INDICATOR_OFFSET;\n\t\t\t}\n\t\t\tmarkModified(oldNumFields);\n\t\t}\n\t\telse {\n\t\t\t// decrease the number of fields\n\t\t\t// we do not remove the values from the cache, as the objects (if they are there) will most likely\n\t\t\t// be reused when the record is re-filled\n\t\t\tmarkModified(numFields);\n\t\t}\n\t\tthis.numFields = numFields;\n\t}", "category": "Python"}, {"instruction": "Collects a record and emits it to all writers.", "input": "Java", "output": "@Override\n\tpublic void collect(T record)  {\n\t\tif (record != null) {\n\t\t\tthis.delegate.setInstance(record);\n\t\t\ttry {\n\t\t\t\tfor (RecordWriter<SerializationDelegate<T>> writer : writers) {\n\t\t\t\t\twriter.emit(this.delegate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"Emitting the record caused an I/O exception: \" + e.getMessage(), e);\n\t\t\t}\n\t\t\tcatch (InterruptedException e) {\n\t\t\t\tthrow new RuntimeException(\"Emitting the record was interrupted: \" + e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new NullPointerException(\"The system does not support records that are null.\"\n\t\t\t\t\t\t\t\t+ \"Null values are only supported as fields inside other objects.\");\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Create Unicode code points from a String.\n\n@param s\na String to convert to an Unicode code point array\n\n@return the corresponding array of integers representing Unicode code\npoints", "input": "Java", "output": "public static int[] stringToCodePoints(final String s) {\n        final int m = s.codePointCount(0, s.length());\n        final int[] codePoints = new int[m];\n        int j = 0;\n        for (int offset = 0; offset < s.length();) {\n            final int codepoint = s.codePointAt(offset);\n            codePoints[j++] = codepoint;\n            offset += Character.charCount(codepoint);\n        }\n        return codePoints;\n    }", "category": "Python"}, {"instruction": "\u83b7\u53d6\u96c6\u5408\u4e2d\u6307\u5b9a\u591a\u4e2a\u4e0b\u6807\u7684\u5143\u7d20\u503c\uff0c\u4e0b\u6807\u53ef\u4ee5\u4e3a\u8d1f\u6570\uff0c\u4f8b\u5982-1\u8868\u793a\u6700\u540e\u4e00\u4e2a\u5143\u7d20\n\n@param <T> \u5143\u7d20\u7c7b\u578b\n@param collection \u96c6\u5408\n@param indexes \u4e0b\u6807\uff0c\u652f\u6301\u8d1f\u6570\n@return \u5143\u7d20\u503c\u5217\u8868\n@since 4.0.6", "input": "Java", "output": "@SuppressWarnings(\"unchecked\")\r\n\tpublic static <T> List<T> getAny(Collection<T> collection, int... indexes) {\r\n\t\tfinal int size = collection.size();\r\n\t\tfinal ArrayList<T> result = new ArrayList<>();\r\n\t\tif (collection instanceof List) {\r\n\t\t\tfinal List<T> list = ((List<T>) collection);\r\n\t\t\tfor (int index : indexes) {\r\n\t\t\t\tif (index < 0) {\r\n\t\t\t\t\tindex += size;\r\n\t\t\t\t}\r\n\t\t\t\tresult.add(list.get(index));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tObject[] array = ((Collection<T>) collection).toArray();\r\n\t\t\tfor (int index : indexes) {\r\n\t\t\t\tif (index < 0) {\r\n\t\t\t\t\tindex += size;\r\n\t\t\t\t}\r\n\t\t\t\tresult.add((T) array[index]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}", "category": "Python"}, {"instruction": "fill the result set with the remaining flow capacity .\n\n@param stats reference to the result container which contains all the results, this specific\nmethod will only work on the property \"remainingFlowCapacity\".", "input": "Java", "output": "protected void fillRemainingFlowCapacityAndLastDispatchedTime(final ExecutorInfo stats) {\n\n    final AzkabanExecutorServer server = AzkabanExecutorServer.getApp();\n    if (server != null) {\n      final FlowRunnerManager runnerMgr = AzkabanExecutorServer.getApp().getFlowRunnerManager();\n      final int assignedFlows = runnerMgr.getNumRunningFlows() + runnerMgr.getNumQueuedFlows();\n      stats.setRemainingFlowCapacity(runnerMgr.getMaxNumRunningFlows() - assignedFlows);\n      stats.setNumberOfAssignedFlows(assignedFlows);\n      stats.setLastDispatchedTime(runnerMgr.getLastFlowSubmittedTime());\n    } else {\n      logger.error(\"failed to get data for remaining flow capacity or LastDispatchedTime\"\n          + \" as the AzkabanExecutorServer has yet been initialized.\");\n    }\n  }", "category": "Python"}, {"instruction": "Create a RPC service for the task manager.\n\n@param configuration The configuration for the TaskManager.\n@param haServices to use for the task manager hostname retrieval", "input": "Java", "output": "public static RpcService createRpcService(\n\t\t\tfinal Configuration configuration,\n\t\t\tfinal HighAvailabilityServices haServices) throws Exception {\n\n\t\tcheckNotNull(configuration);\n\t\tcheckNotNull(haServices);\n\n\t\tfinal String taskManagerAddress = determineTaskManagerBindAddress(configuration, haServices);\n\t\tfinal String portRangeDefinition = configuration.getString(TaskManagerOptions.RPC_PORT);\n\n\t\treturn AkkaRpcServiceUtils.createRpcService(taskManagerAddress, portRangeDefinition, configuration);\n\t}", "category": "Python"}, {"instruction": "Gets authenticated profile.\n\n@param request            the request\n@param response           the response\n@param requiredPermission the required permission\n@return the authenticated profile", "input": "Java", "output": "protected CommonProfile getAuthenticatedProfile(final HttpServletRequest request,\n                                                    final HttpServletResponse response,\n                                                    final String requiredPermission) {\n        val context = new J2EContext(request, response, getUmaConfigurationContext().getSessionStore());\n        val manager = new ProfileManager<>(context, context.getSessionStore());\n        val profile = manager.get(true).orElse(null);\n        if (profile == null) {\n            throw new AuthenticationException(\"Unable to locate authenticated profile\");\n        }\n        if (!profile.getPermissions().contains(requiredPermission)) {\n            throw new AuthenticationException(\"Authenticated profile does not carry the UMA protection scope\");\n        }\n        return profile;\n    }", "category": "Python"}, {"instruction": "Return next fix length string from buffer.", "input": "Java", "output": "public final String getFixString(final int len, String charsetName) {\r\n        if (position + len > origin + limit) throw new IllegalArgumentException(\"limit excceed: \"\r\n                                                                                + (position + len - origin));\r\n\r\n        final int from = position;\r\n        final int end = from + len;\r\n        byte[] buf = buffer;\r\n        int found = from;\r\n        for (; (found < end) && buf[found] != '\\0'; found++)\r\n            /* empty loop */;\r\n\r\n        try {\r\n            String string = new String(buf, from, found - from, charsetName);\r\n            position += len;\r\n            return string;\r\n        } catch (UnsupportedEncodingException e) {\r\n            throw new IllegalArgumentException(\"Unsupported encoding: \" + charsetName, e);\r\n        }\r\n    }", "category": "Python"}, {"instruction": "Identifying certificate for this host. {@code keyCertChainInputStream} and {@code keyInputStream} may\nbe {@code null} for client contexts, which disables mutual authentication.\n\n@param keyCertChainInputStream an input stream for an X.509 certificate chain in PEM format\n@param keyInputStream an input stream for a PKCS#8 private key in PEM format\n@param keyPassword the password of the {@code keyInputStream}, or {@code null} if it's not\npassword-protected", "input": "Java", "output": "public SslContextBuilder keyManager(InputStream keyCertChainInputStream, InputStream keyInputStream,\n            String keyPassword) {\n        X509Certificate[] keyCertChain;\n        PrivateKey key;\n        try {\n            keyCertChain = SslContext.toX509Certificates(keyCertChainInputStream);\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Input stream not contain valid certificates.\", e);\n        }\n        try {\n            key = SslContext.toPrivateKey(keyInputStream, keyPassword);\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Input stream does not contain valid private key.\", e);\n        }\n        return keyManager(key, keyPassword, keyCertChain);\n    }", "category": "Python"}, {"instruction": "Returns the number of registers that are no longer zero after the value was added\n\n@param position   The position into the byte buffer, this position represents two \"registers\"\n@param offsetDiff The difference in offset between the byteToAdd and the current HyperLogLogCollector\n@param byteToAdd  The byte to merge into the current HyperLogLogCollector", "input": "Java", "output": "private static short mergeAndStoreByteRegister(\n      final ByteBuffer storageBuffer,\n      final int position,\n      final int offsetDiff,\n      final byte byteToAdd\n  )\n  {\n    if (byteToAdd == 0) {\n      return 0;\n    }\n\n    final byte currVal = storageBuffer.get(position);\n\n    final int upperNibble = currVal & 0xf0;\n    final int lowerNibble = currVal & 0x0f;\n\n    // subtract the differences so that the nibbles align\n    final int otherUpper = (byteToAdd & 0xf0) - (offsetDiff << bitsPerBucket);\n    final int otherLower = (byteToAdd & 0x0f) - offsetDiff;\n\n    final int newUpper = Math.max(upperNibble, otherUpper);\n    final int newLower = Math.max(lowerNibble, otherLower);\n\n    storageBuffer.put(position, (byte) ((newUpper | newLower) & 0xff));\n\n    short numNoLongerZero = 0;\n    if (upperNibble == 0 && newUpper > 0) {\n      ++numNoLongerZero;\n    }\n    if (lowerNibble == 0 && newLower > 0) {\n      ++numNoLongerZero;\n    }\n\n    return numNoLongerZero;\n  }", "category": "Python"}, {"instruction": "Computes the build cause, using RemoteCause or UserCause as appropriate.", "input": "Java", "output": "@Restricted(NoExternalUse.class)\n    public static CauseAction getBuildCause(ParameterizedJob job, StaplerRequest req) {\n        Cause cause;\n        @SuppressWarnings(\"deprecation\")\n        hudson.model.BuildAuthorizationToken authToken = job.getAuthToken();\n        if (authToken != null && authToken.getToken() != null && req.getParameter(\"token\") != null) {\n            // Optional additional cause text when starting via token\n            String causeText = req.getParameter(\"cause\");\n            cause = new Cause.RemoteCause(req.getRemoteAddr(), causeText);\n        } else {\n            cause = new Cause.UserIdCause();\n        }\n        return new CauseAction(cause);\n    }", "category": "Python"}, {"instruction": "Return an array of the underlying storage from {@code buf} into a byte array.\nThe copy will start at {@code start} and copy {@code length} bytes.\nIf {@code copy} is true a copy will be made of the memory.\nIf {@code copy} is false the underlying storage will be shared, if possible.", "input": "Java", "output": "public static byte[] getBytes(ByteBuf buf, int start, int length, boolean copy) {\n        int capacity = buf.capacity();\n        if (isOutOfBounds(start, length, capacity)) {\n            throw new IndexOutOfBoundsException(\"expected: \" + \"0 <= start(\" + start + \") <= start + length(\" + length\n                    + \") <= \" + \"buf.capacity(\" + capacity + ')');\n        }\n\n        if (buf.hasArray()) {\n            if (copy || start != 0 || length != capacity) {\n                int baseOffset = buf.arrayOffset() + start;\n                return Arrays.copyOfRange(buf.array(), baseOffset, baseOffset + length);\n            } else {\n                return buf.array();\n            }\n        }\n\n        byte[] v = PlatformDependent.allocateUninitializedArray(length);\n        buf.getBytes(start, v);\n        return v;\n    }", "category": "Python"}, {"instruction": "\u67e5\u627e\u7c7b\u4e2d\u7684\u6307\u5b9a\u53c2\u6570\u7684\u6784\u9020\u65b9\u6cd5\uff0c\u5982\u679c\u627e\u5230\u6784\u9020\u65b9\u6cd5\uff0c\u4f1a\u81ea\u52a8\u8bbe\u7f6e\u53ef\u8bbf\u95ee\u4e3atrue\n\n@param <T> \u5bf9\u8c61\u7c7b\u578b\n@param clazz \u7c7b\n@param parameterTypes \u53c2\u6570\u7c7b\u578b\uff0c\u53ea\u8981\u4efb\u4f55\u4e00\u4e2a\u53c2\u6570\u662f\u6307\u5b9a\u53c2\u6570\u7684\u7236\u7c7b\u6216\u63a5\u53e3\u6216\u76f8\u7b49\u5373\u53ef\uff0c\u6b64\u53c2\u6570\u53ef\u4ee5\u4e0d\u4f20\n@return \u6784\u9020\u65b9\u6cd5\uff0c\u5982\u679c\u672a\u627e\u5230\u8fd4\u56denull", "input": "Java", "output": "@SuppressWarnings(\"unchecked\")\r\n\tpublic static <T> Constructor<T> getConstructor(Class<T> clazz, Class<?>... parameterTypes) {\r\n\t\tif (null == clazz) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tfinal Constructor<?>[] constructors = getConstructors(clazz);\r\n\t\tClass<?>[] pts;\r\n\t\tfor (Constructor<?> constructor : constructors) {\r\n\t\t\tpts = constructor.getParameterTypes();\r\n\t\t\tif (ClassUtil.isAllAssignableFrom(pts, parameterTypes)) {\r\n\t\t\t\t// \u6784\u9020\u53ef\u8bbf\u95ee\r\n\t\t\t\tconstructor.setAccessible(true);\r\n\t\t\t\treturn (Constructor<T>) constructor;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}", "category": "Python"}, {"instruction": "Creates a uima sentence iterator with the given path\n@param path the path to the root directory or file to read from\n@return the uima sentence iterator for the given root dir or file\n@throws Exception", "input": "Java", "output": "public static SentenceIterator createWithPath(String path) throws Exception {\n        return new UimaSentenceIterator(path,\n                        new UimaResource(AnalysisEngineFactory.createEngine(AnalysisEngineFactory\n                                        .createEngineDescription(TokenizerAnnotator.getDescription(),\n                                                        SentenceAnnotator.getDescription()))));\n    }", "category": "Python"}, {"instruction": "Creates a ZFS file system to migrate the data to.\n\n<p>\nThis has to be done while we still have an interactive access with the user, since it involves the password.\n\n<p>\nAn exception will be thrown if the operation fails. A normal completion means a success.\n\n@return\nThe ZFS dataset name to migrate the data to.", "input": "Java", "output": "private String createZfsFileSystem(final TaskListener listener, String rootUsername, String rootPassword) throws IOException, InterruptedException, ZFSException {\n        // capture the UID that Hudson runs under\n        // so that we can allow this user to do everything on this new partition\n        final int uid = LIBC.geteuid();\n        final int gid = LIBC.getegid();\n        passwd pwd = LIBC.getpwuid(uid);\n        if(pwd==null)\n            throw new IOException(\"Failed to obtain the current user information for \"+uid);\n        final String userName = pwd.pw_name;\n\n        final File home = Jenkins.getInstance().getRootDir();\n\n        // this is the actual creation of the file system.\n        // return true indicating a success\n        return SU.execute(listener, rootUsername, rootPassword, new Create(listener, home, uid, gid, userName));\n    }", "category": "Python"}, {"instruction": "[VARIABLE 42]", "input": "Java", "output": "public boolean deleteBlobFromStringsWithGeneration(\n      String bucketName, String blobName, long blobGeneration) {\n    // [START deleteBlobFromStringsWithGeneration]\n    boolean deleted =\n        storage.delete(bucketName, blobName, BlobSourceOption.generationMatch(blobGeneration));\n    if (deleted) {\n      // the blob was deleted\n    } else {\n      // the blob was not found\n    }\n    // [END deleteBlobFromStringsWithGeneration]\n    return deleted;\n  }", "category": "Python"}, {"instruction": "To use this method, {@link #objectMapper} should be a smileMapper.", "input": "Java", "output": "protected FullResponseHolder submitSmileRequest(\n      String taskId,\n      HttpMethod method,\n      String encodedPathSuffix,\n      @Nullable String encodedQueryString,\n      byte[] content,\n      boolean retry\n  ) throws IOException, ChannelException, NoTaskLocationException\n  {\n    return submitRequest(\n        taskId,\n        SmileMediaTypes.APPLICATION_JACKSON_SMILE,\n        method,\n        encodedPathSuffix,\n        encodedQueryString,\n        content,\n        retry\n    );\n  }", "category": "Python"}, {"instruction": "This should only be called as last operation from a method as this may adjust the underlying\narray of components and so affect the index etc.", "input": "Java", "output": "private void consolidateIfNeeded() {\n        // Consolidate if the number of components will exceed the allowed maximum by the current\n        // operation.\n        int size = componentCount;\n        if (size > maxNumComponents) {\n            final int capacity = components[size - 1].endOffset;\n\n            ByteBuf consolidated = allocBuffer(capacity);\n            lastAccessed = null;\n\n            // We're not using foreach to avoid creating an iterator.\n            for (int i = 0; i < size; i ++) {\n                components[i].transferTo(consolidated);\n            }\n\n            components[0] = new Component(consolidated, 0, 0, capacity, consolidated);\n            removeCompRange(1, size);\n        }\n    }", "category": "Python"}, {"instruction": "Converts the given objects into a map of interned strings. See {@link String#intern()}.\n\n@param values The objects\n@return An unmodifiable set of strings\n@see CollectionUtils#mapOf(Object...)", "input": "Java", "output": "@SuppressWarnings(\"unused\")\n    public static Map<String, Object> internMapOf(Object... values) {\n        if (values == null) {\n            return Collections.emptyMap();\n        }\n        int len = values.length;\n        if (len % 2 != 0) {\n            throw new IllegalArgumentException(\"Number of arguments should be an even number representing the keys and values\");\n        }\n\n        Map<String, Object> answer = new HashMap<>((int) (len / 2 / 0.75));\n        int i = 0;\n        while (i < values.length - 1) {\n            String key = values[i++].toString().intern();\n            Object val = values[i++];\n            answer.put(key, val);\n        }\n        return answer;\n    }", "category": "Python"}, {"instruction": "Replace deprecated configuration properties for {@link FlinkKinesisProducer}.\nThis should be remove along with deprecated keys", "input": "Java", "output": "public static Properties replaceDeprecatedProducerKeys(Properties configProps) {\n\t\t// Replace deprecated key\n\t\tif (configProps.containsKey(ProducerConfigConstants.COLLECTION_MAX_COUNT)) {\n\t\t\tconfigProps.setProperty(COLLECTION_MAX_COUNT,\n\t\t\t\t\tconfigProps.getProperty(ProducerConfigConstants.COLLECTION_MAX_COUNT));\n\t\t\tconfigProps.remove(ProducerConfigConstants.COLLECTION_MAX_COUNT);\n\t\t}\n\t\t// Replace deprecated key\n\t\tif (configProps.containsKey(ProducerConfigConstants.AGGREGATION_MAX_COUNT)) {\n\t\t\tconfigProps.setProperty(AGGREGATION_MAX_COUNT,\n\t\t\t\t\tconfigProps.getProperty(ProducerConfigConstants.AGGREGATION_MAX_COUNT));\n\t\t\tconfigProps.remove(ProducerConfigConstants.AGGREGATION_MAX_COUNT);\n\t\t}\n\t\treturn configProps;\n\t}", "category": "Python"}, {"instruction": "\u589e\u52a0\u4e00\u4e2a\u8bcd\u5178\n\n@param key\n@param path\n@param value", "input": "Java", "output": "public static void putLibrary(String key, String path, Object value) {\n        if (key.startsWith(DicLibrary.DEFAULT)) {\n            DicLibrary.put(key, path, (Forest) value);\n        } else if (key.startsWith(StopLibrary.DEFAULT)) {\n            StopLibrary.put(key, path, (StopRecognition) value);\n        } else if (key.startsWith(SynonymsLibrary.DEFAULT)) {\n            SynonymsLibrary.put(key, path, (SmartForest) value);\n        } else if (key.startsWith(AmbiguityLibrary.DEFAULT)) {\n            AmbiguityLibrary.put(key, path, (Forest) value);\n        } else if (key.startsWith(CrfLibrary.DEFAULT)) {\n            CrfLibrary.put(key, path, (SplitWord) value);\n        } else {\n            throw new LibraryException(key + \" type err must start with dic,stop,ambiguity,synonyms\");\n        }\n        ENV.put(key, path);\n    }", "category": "Python"}, {"instruction": "Reads a number of items starting with the first one that has a Sequence Number higher than the given one.\n\n@param afterSequenceNumber The sequence to search from.\n@param count               The maximum number of items to read.\n@return An Iterator with the resulting items. If no results are available for the given parameters, an empty iterator is returned.", "input": "Java", "output": "public Iterator<T> read(long afterSequenceNumber, int count) {\n        ListNode<T> firstNode;\n        synchronized (this.lock) {\n            firstNode = this.head;\n        }\n\n        // Find the first node that has a Sequence Number after the given one, but make sure we release and reacquire\n        // the lock with every iteration. This will prevent long-list scans from blocking adds.\n        while (firstNode != null && firstNode.item.getSequenceNumber() <= afterSequenceNumber) {\n            synchronized (this.lock) {\n                firstNode = firstNode.next;\n            }\n        }\n\n        return new NodeIterator<>(firstNode, count, this.lock);\n    }", "category": "Python"}, {"instruction": "Deletes all alerts of this node and all child nodes recursively.", "input": "Java", "output": "public void deleteAllAlerts() {\r\n        for(int i = 0; i < getChildCount(); i++) {\r\n            ((SiteNode) getChildAt(i)).deleteAllAlerts();\r\n        }\r\n\r\n        if (!alerts.isEmpty()) {\r\n            alerts.clear();\r\n            highestAlert = null;\r\n            calculateHighestAlert = false;\r\n        \tif (this.siteMap != null) {\r\n        \t\t// Deleting alert might affect the nodes visibility in a filtered tree\r\n        \t\tsiteMap.applyFilter(this);\r\n        \t}\r\n            nodeChanged();\r\n        }\r\n    }", "category": "Python"}, {"instruction": "Merge the absolute paths of source paths into the list of destination paths\n\n@param destinationPaths the path list which the source paths will be merged into\n@param sourcePaths source paths\n@param rootPath defined root path for source paths when they are not absolute path", "input": "Java", "output": "public static void mergeTypeClassPaths(\n      List<String> destinationPaths, final List<String> sourcePaths, final String rootPath) {\n    if (sourcePaths != null) {\n      for (String jar : sourcePaths) {\n        File file = new File(jar);\n        if (!file.isAbsolute()) {\n          file = new File(rootPath + File.separatorChar + jar);\n        }\n\n        String path = file.getAbsolutePath();\n        if (!destinationPaths.contains(path)) {\n          destinationPaths.add(path);\n        }\n      }\n    }\n  }", "category": "Python"}, {"instruction": "Deregister the given epoll from this {@link EventLoop}.", "input": "Java", "output": "void remove(AbstractEpollChannel ch) throws IOException {\n        assert inEventLoop();\n\n        if (ch.isOpen()) {\n            int fd = ch.socket.intValue();\n            if (channels.remove(fd) != null) {\n                // Remove the epoll. This is only needed if it's still open as otherwise it will be automatically\n                // removed once the file-descriptor is closed.\n                Native.epollCtlDel(epollFd.intValue(), ch.fd().intValue());\n            }\n        }\n    }", "category": "Python"}, {"instruction": "\u6839\u636e\u7279\u5f81\u51fd\u6570\u8ba1\u7b97\u8f93\u51fa\n\n@param table\n@param current\n@return", "input": "Java", "output": "protected LinkedList<double[]> computeScoreList(Table table, int current)\n    {\n        LinkedList<double[]> scoreList = new LinkedList<double[]>();\n        for (FeatureTemplate featureTemplate : featureTemplateList)\n        {\n            char[] o = featureTemplate.generateParameter(table, current);\n            FeatureFunction featureFunction = featureFunctionTrie.get(o);\n            if (featureFunction == null) continue;\n            scoreList.add(featureFunction.w);\n        }\n\n        return scoreList;\n    }", "category": "Python"}, {"instruction": "\u5bfb\u627e\u91cd\u53e0\n@param interval \u4e00\u4e2a\u533a\u95f4\uff0c\u4e0e\u8be5\u533a\u95f4\u91cd\u53e0\n@param direction \u65b9\u5411\uff0c\u8868\u660e\u91cd\u53e0\u533a\u95f4\u5728interval\u7684\u5de6\u8fb9\u8fd8\u662f\u53f3\u8fb9\n@return", "input": "Java", "output": "protected List<Intervalable> checkForOverlaps(Intervalable interval, Direction direction)\n    {\n\n        List<Intervalable> overlaps = new ArrayList<Intervalable>();\n        for (Intervalable currentInterval : this.intervals)\n        {\n            switch (direction)\n            {\n                case LEFT:\n                    if (currentInterval.getStart() <= interval.getEnd())\n                    {\n                        overlaps.add(currentInterval);\n                    }\n                    break;\n                case RIGHT:\n                    if (currentInterval.getEnd() >= interval.getStart())\n                    {\n                        overlaps.add(currentInterval);\n                    }\n                    break;\n            }\n        }\n        return overlaps;\n    }", "category": "Python"}, {"instruction": "Loads the data from the user folder into the new object.\n<p>\nIf the folder does not exist yet, a fresh new instance is created.", "input": "Java", "output": "public static @Nonnull ApiTokenStats load(@Nonnull User user) {\n        // even if we are not using statistics, we load the existing one in case the configuration\n        // is enabled afterwards to avoid erasing data\n        \n        ApiTokenStats apiTokenStats = null;\n        \n        File userFolder = user.getUserFolder();\n        if (userFolder != null) {\n            apiTokenStats = internalLoad(userFolder);\n        }\n        \n        if (apiTokenStats == null) {\n            apiTokenStats = new ApiTokenStats();\n        }\n        \n        apiTokenStats.user = user;\n        \n        return apiTokenStats;\n    }", "category": "Python"}, {"instruction": "Parse and return a user defined function of the form \"{arg1 arg2 . (expr)}\"", "input": "Java", "output": "private AstFunction parseFunctionDefinition() {\n    eatChar('{');\n\n    // Parse the list of ids\n    ArrayList<String> ids = new ArrayList<>();\n    ids.add(\"\");  // 1-based ID list\n    while (skipWS() != '.') {\n      String id = token();\n      if (!Character.isJavaIdentifierStart(id.charAt(0)))\n        throw new IllegalASTException(\"variable must be a valid Java identifier: \" + id);\n      for (char c : id.toCharArray())\n        if (!Character.isJavaIdentifierPart(c))\n          throw new IllegalASTException(\"variable must be a valid Java identifier: \" + id);\n      ids.add(id);\n    }\n\n    // Single dot separates the list of ids from the body of the function\n    eatChar('.');\n\n    // Parse the body\n    AstRoot body = parseNext();\n    if (skipWS() != '}')\n      throw new IllegalASTException(\"Expected the end of the function, but found '\" + peek(0) + \"'\");\n    eatChar('}');\n\n    return new AstFunction(ids, body);\n  }", "category": "Python"}, {"instruction": "The lookup handler method, maps the SEOMapper method to the request URL.\n<p>If no mapping is found, or if the URL is disabled, it will simply drop through\nto the standard 404 handling.</p>\n\n@param urlPath the path to match.\n@param request the http servlet request.\n@return The HandlerMethod if one was found.", "input": "Java", "output": "@Override\n  protected HandlerMethod lookupHandlerMethod(String urlPath, HttpServletRequest request) {\n    logger.debug(\"looking up handler for path: \" + urlPath);\n    HandlerMethod handlerMethod = handlerMethods.get(urlPath);\n    if (handlerMethod != null) {\n      return handlerMethod;\n    }\n    for (String path : handlerMethods.keySet()) {\n      UriTemplate template = new UriTemplate(path);\n      if (template.matches(urlPath)) {\n        request.setAttribute(\n            HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE,\n            template.match(urlPath));\n        return handlerMethods.get(path);\n      }\n    }\n    return null;\n  }", "category": "Python"}, {"instruction": "Processes the GRPC compression header which is composed of the compression flag and the outer\nframe length.", "input": "Java", "output": "private void processHeader() {\n    int type = nextFrame.readUnsignedByte();\n    if ((type & RESERVED_MASK) != 0) {\n      throw Status.INTERNAL.withDescription(\n          \"gRPC frame header malformed: reserved bits not zero\")\n          .asRuntimeException();\n    }\n    compressedFlag = (type & COMPRESSED_FLAG_MASK) != 0;\n\n    // Update the required length to include the length of the frame.\n    requiredLength = nextFrame.readInt();\n    if (requiredLength < 0 || requiredLength > maxInboundMessageSize) {\n      throw Status.RESOURCE_EXHAUSTED.withDescription(\n          String.format(\"gRPC message exceeds maximum size %d: %d\",\n              maxInboundMessageSize, requiredLength))\n          .asRuntimeException();\n    }\n\n    currentMessageSeqNo++;\n    statsTraceCtx.inboundMessage(currentMessageSeqNo);\n    transportTracer.reportMessageReceived();\n    // Continue reading the frame body.\n    state = State.BODY;\n  }", "category": "Python"}, {"instruction": "Called when a stream is closed, we do things like:\n<ul>\n<li>Removing the stream from the map.\n<li>Optionally reporting the status.\n<li>Starting pending streams if we can.\n<li>Stopping the transport if this is the last live stream under a go-away status.\n</ul>\n\n@param streamId the Id of the stream.\n@param status the final status of this stream, null means no need to report.\n@param stopDelivery interrupt queued messages in the deframer\n@param errorCode reset the stream with this ErrorCode if not null.\n@param trailers the trailers received if not null", "input": "Java", "output": "void finishStream(\n      int streamId,\n      @Nullable Status status,\n      RpcProgress rpcProgress,\n      boolean stopDelivery,\n      @Nullable ErrorCode errorCode,\n      @Nullable Metadata trailers) {\n    synchronized (lock) {\n      OkHttpClientStream stream = streams.remove(streamId);\n      if (stream != null) {\n        if (errorCode != null) {\n          frameWriter.rstStream(streamId, ErrorCode.CANCEL);\n        }\n        if (status != null) {\n          stream\n              .transportState()\n              .transportReportStatus(\n                  status,\n                  rpcProgress,\n                  stopDelivery,\n                  trailers != null ? trailers : new Metadata());\n        }\n        if (!startPendingStreams()) {\n          stopIfNecessary();\n          maybeClearInUse(stream);\n        }\n      }\n    }\n  }", "category": "Python"}, {"instruction": "todo dmgcodevil: it would be better to reuse the code from build() method", "input": "Java", "output": "public HystrixObservableCommand.Setter buildObservableCommandSetter() {\n        HystrixObservableCommand.Setter setter = HystrixObservableCommand.Setter\n                .withGroupKey(HystrixCommandGroupKey.Factory.asKey(groupKey))\n                .andCommandKey(HystrixCommandKey.Factory.asKey(commandKey));\n        try {\n            setter.andCommandPropertiesDefaults(HystrixPropertiesManager.initializeCommandProperties(commandProperties));\n        } catch (IllegalArgumentException e) {\n            throw new HystrixPropertyException(\"Failed to set Command properties. \" + getInfo(), e);\n        }\n        return setter;\n    }", "category": "Python"}, {"instruction": "\u5206\u8bcd\n@param text \u6587\u672c\n@return \u5206\u8bcd\u7ed3\u679c", "input": "Java", "output": "public static List<Term> segment(String text)\n    {\n        List<Term> termList = new LinkedList<Term>();\n        Matcher matcher = WEB_URL.matcher(text);\n        int begin = 0;\n        int end;\n        while (matcher.find())\n        {\n            end = matcher.start();\n            termList.addAll(SEGMENT.seg(text.substring(begin, end)));\n            termList.add(new Term(matcher.group(), Nature.xu));\n            begin = matcher.end();\n        }\n        if (begin < text.length()) termList.addAll(SEGMENT.seg(text.substring(begin)));\n\n        return termList;\n    }", "category": "Python"}, {"instruction": "ZapTocMerger#mergeNodes(TreeNode, TreeNode) instead of UniteAppendMerge#mergeNodes(TreeNode, TreeNode).", "input": "Java", "output": "@Override\n    public TreeNode processMerge(TreeNode node) {\n\n        DefaultMutableTreeNode masterNode = (DefaultMutableTreeNode) node;\n\n        // if master and slave are the same object return the\n        // masterNode\n        if (masterNode.equals(slaveTopNode)) {\n            return masterNode;\n        }\n\n        // If there are not children in slaveTopNode return the\n        // masterNode\n        if (slaveTopNode.getChildCount() == 0) {\n            return masterNode;\n        }\n\n        mergeNodes(masterNode, slaveTopNode);\n        return masterNode;\n    }", "category": "Python"}, {"instruction": "Build a new set of genes. Has two distinct modes of operation\n<ul>\n<li>Before the population has reached the culled size: will return a random set of genes.</li>\n<li>After: Parents will be selected among the population, a crossover will be applied followed by a mutation.</li>\n</ul>\n@return Returns the generated set of genes\n@throws GeneticGenerationException If buildNextGenes() can't generate a set that has not already been tried,\nor if the crossover and the mutation operators can't generate a set,\nthis exception is thrown.", "input": "Java", "output": "@Override\n    public double[] buildNextGenes() {\n        double[] result;\n\n        boolean hasAlreadyBeenTried;\n        int attemptsRemaining = MAX_NUM_GENERATION_ATTEMPTS;\n        do {\n            if (populationModel.isReadyToBreed()) {\n                result = buildOffspring();\n            } else {\n                result = buildRandomGenes();\n            }\n\n            hasAlreadyBeenTried = hasAlreadyBeenTried(result);\n            if (hasAlreadyBeenTried && --attemptsRemaining == 0) {\n                throw new GeneticGenerationException(\"Failed to generate a set of genes not already tried.\");\n            }\n        } while (hasAlreadyBeenTried);\n\n        previousGenes[previousGenesIdx] = result;\n        previousGenesIdx = ++previousGenesIdx % previousGenes.length;\n\n        return result;\n    }", "category": "Python"}, {"instruction": "Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies\na user-defined transformation on the values of the matched records.\nThe vertex ID and the first field of the Tuple2 DataSet are used as the join keys.\n\n@param inputDataSet the Tuple2 DataSet to join with.\nThe first field of the Tuple2 is used as the join key and the second field is passed\nas a parameter to the transformation function.\n@param vertexJoinFunction the transformation function to apply.\nThe first parameter is the current vertex value and the second parameter is the value\nof the matched Tuple2 from the input DataSet.\n@return a new Graph, where the vertex values have been updated according to the\nresult of the vertexJoinFunction.\n\n@param <T> the type of the second field of the input Tuple2 DataSet.", "input": "Java", "output": "public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,\n\t\t\tfinal VertexJoinFunction<VV, T> vertexJoinFunction) {\n\n\t\tDataSet<Vertex<K, VV>> resultedVertices = this.getVertices()\n\t\t\t\t.coGroup(inputDataSet).where(0).equalTo(0)\n\t\t\t\t.with(new ApplyCoGroupToVertexValues<>(vertexJoinFunction))\n\t\t\t\t\t.name(\"Join with vertices\");\n\t\treturn new Graph<>(resultedVertices, this.edges, this.context);\n\t}", "category": "Python"}, {"instruction": "\u8ba1\u7b97\u5bf9\u8c61\u957f\u5ea6\uff0c\u5982\u679c\u662f\u5b57\u7b26\u4e32\u8c03\u7528\u5176length\u51fd\u6570\uff0c\u96c6\u5408\u7c7b\u8c03\u7528\u5176size\u51fd\u6570\uff0c\u6570\u7ec4\u8c03\u7528\u5176length\u5c5e\u6027\uff0c\u5176\u4ed6\u53ef\u904d\u5386\u5bf9\u8c61\u904d\u5386\u8ba1\u7b97\u957f\u5ea6<br>\n\u652f\u6301\u7684\u7c7b\u578b\u5305\u62ec\uff1a\n<ul>\n<li>CharSequence</li>\n<li>Map</li>\n<li>Iterator</li>\n<li>Enumeration</li>\n<li>Array</li>\n</ul>\n\n@param obj \u88ab\u8ba1\u7b97\u957f\u5ea6\u7684\u5bf9\u8c61\n@return \u957f\u5ea6", "input": "Java", "output": "public static int length(Object obj) {\r\n\t\tif (obj == null) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (obj instanceof CharSequence) {\r\n\t\t\treturn ((CharSequence) obj).length();\r\n\t\t}\r\n\t\tif (obj instanceof Collection) {\r\n\t\t\treturn ((Collection<?>) obj).size();\r\n\t\t}\r\n\t\tif (obj instanceof Map) {\r\n\t\t\treturn ((Map<?, ?>) obj).size();\r\n\t\t}\r\n\r\n\t\tint count;\r\n\t\tif (obj instanceof Iterator) {\r\n\t\t\tIterator<?> iter = (Iterator<?>) obj;\r\n\t\t\tcount = 0;\r\n\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\tcount++;\r\n\t\t\t\titer.next();\r\n\t\t\t}\r\n\t\t\treturn count;\r\n\t\t}\r\n\t\tif (obj instanceof Enumeration) {\r\n\t\t\tEnumeration<?> enumeration = (Enumeration<?>) obj;\r\n\t\t\tcount = 0;\r\n\t\t\twhile (enumeration.hasMoreElements()) {\r\n\t\t\t\tcount++;\r\n\t\t\t\tenumeration.nextElement();\r\n\t\t\t}\r\n\t\t\treturn count;\r\n\t\t}\r\n\t\tif (obj.getClass().isArray() == true) {\r\n\t\t\treturn Array.getLength(obj);\r\n\t\t}\r\n\t\treturn -1;\r\n\t}", "category": "Python"}, {"instruction": "Process a resource, searching for links (uris) to other resources.\n\n@param message the HTTP Message", "input": "Java", "output": "private void processResource(HttpMessage message) {\n\t\tList<SpiderParser> parsers = parent.getController().getParsers();\n\n\t\t// Prepare the Jericho source\n\t\tSource source = new Source(message.getResponseBody().toString());\n\t\t\n\t\t// Get the full path of the file\n\t\tString path = null;\n\t\ttry {\n\t\t\tpath = message.getRequestHeader().getURI().getPath();\n\t\t} catch (URIException e) {\n\t\t} finally {\n\t\t\t// Handle null paths.\n\t\t\tif (path == null)\n\t\t\t\tpath = \"\";\n\t\t}\n\t\t\n\t\t// Parse the resource\n\t\tboolean alreadyConsumed = false;\n\t\tfor (SpiderParser parser : parsers) {\t\t\t\n\t\t\tif (parser.canParseResource(message, path, alreadyConsumed)) {\n\t\t\t\tif (log.isDebugEnabled()) log.debug(\"Parser \"+ parser +\" can parse resource '\"+ path + \"'\");\n\t\t\t\tif (parser.parseResource(message, source, depth))\n\t\t\t\t\talreadyConsumed = true;\n\t\t\t} else {\n\t\t\t\tif (log.isDebugEnabled()) log.debug(\"Parser \"+ parser +\" cannot parse resource '\"+ path + \"'\");\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "\u83b7\u53d6\u6307\u5b9a\u7c7b\u578b\u5206\u7684\u9ed8\u8ba4\u503c<br>\n\u9ed8\u8ba4\u503c\u89c4\u5219\u4e3a\uff1a\n\n<pre>\n1\u3001\u5982\u679c\u4e3a\u539f\u59cb\u7c7b\u578b\uff0c\u8fd4\u56de0\n2\u3001\u975e\u539f\u59cb\u7c7b\u578b\u8fd4\u56de{@code null}\n</pre>\n\n@param clazz \u7c7b\n@return \u9ed8\u8ba4\u503c\n@since 3.0.8", "input": "Java", "output": "public static Object getDefaultValue(Class<?> clazz) {\r\n\t\tif (clazz.isPrimitive()) {\r\n\t\t\tif (long.class == clazz) {\r\n\t\t\t\treturn 0L;\r\n\t\t\t} else if (int.class == clazz) {\r\n\t\t\t\treturn 0;\r\n\t\t\t} else if (short.class == clazz) {\r\n\t\t\t\treturn (short) 0;\r\n\t\t\t} else if (char.class == clazz) {\r\n\t\t\t\treturn (char) 0;\r\n\t\t\t} else if (byte.class == clazz) {\r\n\t\t\t\treturn (byte) 0;\r\n\t\t\t} else if (double.class == clazz) {\r\n\t\t\t\treturn 0D;\r\n\t\t\t} else if (float.class == clazz) {\r\n\t\t\t\treturn 0f;\r\n\t\t\t} else if (boolean.class == clazz) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}", "category": "Python"}, {"instruction": "Build a MultiLayerNetwork from this Keras Sequential model configuration and import weights.\n\n@return MultiLayerNetwork", "input": "Java", "output": "public MultiLayerNetwork getMultiLayerNetwork(boolean importWeights)\n            throws InvalidKerasConfigurationException, UnsupportedKerasConfigurationException {\n        MultiLayerNetwork model = new MultiLayerNetwork(getMultiLayerConfiguration());\n        model.init();\n        if (importWeights)\n            model = (MultiLayerNetwork) KerasModelUtils.copyWeightsToModel(model, this.layers);\n        return model;\n    }", "category": "Python"}, {"instruction": "\u5224\u65ad\u6307\u5b9a\u7684\u5355\u5143\u683c\u662f\u5426\u662f\u5408\u5e76\u5355\u5143\u683c\n\n@param sheet {@link Sheet}\n@param row \u884c\u53f7\n@param column \u5217\u53f7\n@return \u662f\u5426\u662f\u5408\u5e76\u5355\u5143\u683c", "input": "Java", "output": "public static boolean isMergedRegion(Sheet sheet, int row, int column) {\r\n\t\tfinal int sheetMergeCount = sheet.getNumMergedRegions();\r\n\t\tCellRangeAddress ca;\r\n\t\tfor (int i = 0; i < sheetMergeCount; i++) {\r\n\t\t\tca = sheet.getMergedRegion(i);\r\n\t\t\tif (row >= ca.getFirstRow() && row <= ca.getLastRow() && column >= ca.getFirstColumn() && column <= ca.getLastColumn()) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}", "category": "Python"}, {"instruction": "Takes the serialized accumulator results and tries to deserialize them using the provided\nclass loader.\n@param serializedAccumulators The serialized accumulator results.\n@param loader The class loader to use.\n@return The deserialized accumulator results.\n@throws IOException\n@throws ClassNotFoundException", "input": "Java", "output": "public static Map<String, OptionalFailure<Object>> deserializeAccumulators(\n\t\t\tMap<String, SerializedValue<OptionalFailure<Object>>> serializedAccumulators,\n\t\t\tClassLoader loader) throws IOException, ClassNotFoundException {\n\n\t\tif (serializedAccumulators == null || serializedAccumulators.isEmpty()) {\n\t\t\treturn Collections.emptyMap();\n\t\t}\n\n\t\tMap<String, OptionalFailure<Object>> accumulators = new HashMap<>(serializedAccumulators.size());\n\n\t\tfor (Map.Entry<String, SerializedValue<OptionalFailure<Object>>> entry : serializedAccumulators.entrySet()) {\n\n\t\t\tOptionalFailure<Object> value = null;\n\t\t\tif (entry.getValue() != null) {\n\t\t\t\tvalue = entry.getValue().deserializeValue(loader);\n\t\t\t}\n\n\t\t\taccumulators.put(entry.getKey(), value);\n\t\t}\n\n\t\treturn accumulators;\n\t}", "category": "Python"}, {"instruction": "}", "input": "Java", "output": "@Bean\n\t@ConditionalOnBean(AutoServiceRegistrationProperties.class)\n\t@ConditionalOnProperty(value = \"spring.cloud.service-registry.auto-registration.enabled\", matchIfMissing = true)\n\tpublic EurekaAutoServiceRegistration eurekaAutoServiceRegistration(\n\t\t\tApplicationContext context, EurekaServiceRegistry registry,\n\t\t\tEurekaRegistration registration) {\n\t\treturn new EurekaAutoServiceRegistration(context, registry, registration);\n\t}", "category": "Python"}, {"instruction": "\u6267\u884cWebservice\u8bf7\u6c42\uff0c\u65e2\u53d1\u9001SOAP\u5185\u5bb9\n\n@return \u8fd4\u56de\u7ed3\u679c", "input": "Java", "output": "public SOAPMessage sendForMessage() {\r\n\t\tfinal HttpResponse res = sendForResponse();\r\n\t\tfinal MimeHeaders headers = new MimeHeaders();\r\n\t\tfor (Entry<String, List<String>> entry : res.headers().entrySet()) {\r\n\t\t\tif(StrUtil.isNotEmpty(entry.getKey())) {\r\n\t\t\t\theaders.setHeader(entry.getKey(), CollUtil.get(entry.getValue(), 0));\r\n\t\t\t}\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn this.factory.createMessage(headers, res.bodyStream());\r\n\t\t} catch (IOException | SOAPException e) {\r\n\t\t\tthrow new SoapRuntimeException(e);\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "\u68c0\u67e5\u8bc1\u4e66\u94fe\n\n@param rootCerts\n\u6839\u8bc1\u4e66\n@param cert\n\u5f85\u9a8c\u8bc1\u7684\u8bc1\u4e66\n@return", "input": "Java", "output": "public static boolean verifyCertificate(X509Certificate cert) {\n\t\t\n\t\tif ( null == cert) {\n\t\t\tLogUtil.writeErrorLog(\"cert must Not null\");\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tcert.checkValidity();//\u9a8c\u8bc1\u6709\u6548\u671f\n//\t\t\tcert.verify(middleCert.getPublicKey());\n\t\t\tif(!verifyCertificateChain(cert)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLogUtil.writeErrorLog(\"verifyCertificate fail\", e);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(SDKConfig.getConfig().isIfValidateCNName()){\n\t\t\t// \u9a8c\u8bc1\u516c\u94a5\u662f\u5426\u5c5e\u4e8e\u94f6\u8054\n\t\t\tif(!UNIONPAY_CNNAME.equals(CertUtil.getIdentitiesFromCertficate(cert))) {\n\t\t\t\tLogUtil.writeErrorLog(\"cer owner is not CUP:\" + CertUtil.getIdentitiesFromCertficate(cert));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\t// \u9a8c\u8bc1\u516c\u94a5\u662f\u5426\u5c5e\u4e8e\u94f6\u8054\n\t\t\tif(!UNIONPAY_CNNAME.equals(CertUtil.getIdentitiesFromCertficate(cert)) \n\t\t\t\t\t&& !\"00040000:SIGN\".equals(CertUtil.getIdentitiesFromCertficate(cert))) {\n\t\t\t\tLogUtil.writeErrorLog(\"cer owner is not CUP:\" + CertUtil.getIdentitiesFromCertficate(cert));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\t\t\n\t}", "category": "Python"}, {"instruction": "Writes the given {@link AccessExecutionGraph} to the {@link FileSystem} pointed to by\n{@link JobManagerOptions#ARCHIVE_DIR}.\n\n@param rootPath directory to which the archive should be written to\n@param jobId  job id\n@param jsonToArchive collection of json-path pairs to that should be archived\n@return path to where the archive was written, or null if no archive was created\n@throws IOException", "input": "Java", "output": "public static Path archiveJob(Path rootPath, JobID jobId, Collection<ArchivedJson> jsonToArchive) throws IOException {\n\t\ttry {\n\t\t\tFileSystem fs = rootPath.getFileSystem();\n\t\t\tPath path = new Path(rootPath, jobId.toString());\n\t\t\tOutputStream out = fs.create(path, FileSystem.WriteMode.NO_OVERWRITE);\n\n\t\t\ttry (JsonGenerator gen = jacksonFactory.createGenerator(out, JsonEncoding.UTF8)) {\n\t\t\t\tgen.writeStartObject();\n\t\t\t\tgen.writeArrayFieldStart(ARCHIVE);\n\t\t\t\tfor (ArchivedJson archive : jsonToArchive) {\n\t\t\t\t\tgen.writeStartObject();\n\t\t\t\t\tgen.writeStringField(PATH, archive.getPath());\n\t\t\t\t\tgen.writeStringField(JSON, archive.getJson());\n\t\t\t\t\tgen.writeEndObject();\n\t\t\t\t}\n\t\t\t\tgen.writeEndArray();\n\t\t\t\tgen.writeEndObject();\n\t\t\t} catch (Exception e) {\n\t\t\t\tfs.delete(path, false);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tLOG.info(\"Job {} has been archived at {}.\", jobId, path);\n\t\t\treturn path;\n\t\t} catch (IOException e) {\n\t\t\tLOG.error(\"Failed to archive job.\", e);\n\t\t\tthrow e;\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Copy the contents of the given Reader to the given Writer.\nCloses both when done.\n\n@param in  the Reader to copy from\n@param out the Writer to copy to\n@return the number of characters copied\n@throws IOException in case of I/O errors", "input": "Java", "output": "public static int copy(Reader in, Writer out) throws IOException {\n        assert in != null : \"No input Reader specified\";\n        assert out != null : \"No output Writer specified\";\n\n        try {\n            int byteCount = 0;\n            char[] buffer = new char[BUFFER_SIZE];\n            int bytesRead = -1;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n                byteCount += bytesRead;\n            }\n            out.flush();\n            return byteCount;\n        } finally {\n            try {\n                in.close();\n            } catch (IOException ex) {\n            }\n            try {\n                out.close();\n            } catch (IOException ex) {\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Returns the next items from the queue. If the queue is empty, it blocks the call until at least one item is added.\n\n@param maxCount The maximum number of items to return. This argument will be ignored if the queue is currently empty,\nbut in that case the result will always be completed with exactly one element.\n@return A CompletableFuture that, when completed, will contain the requested result. If the queue is not currently\nempty, this Future will already be completed, otherwise it will be completed the next time the add() method is called.\nIf the queue is closed and this Future is not yet completed, it will be cancelled.\n@throws ObjectClosedException If the Queue is closed.\n@throws IllegalStateException If another call to take() is in progress.", "input": "Java", "output": "public CompletableFuture<Queue<T>> take(int maxCount) {\n        synchronized (this.contents) {\n            Exceptions.checkNotClosed(this.closed, this);\n            Preconditions.checkState(this.pendingTake == null, \"Cannot have more than one concurrent pending take() request.\");\n            Queue<T> result = fetch(maxCount);\n            if (result.size() > 0) {\n                return CompletableFuture.completedFuture(result);\n            } else {\n                this.pendingTake = new CompletableFuture<>();\n                return this.pendingTake;\n            }\n        }\n    }", "category": "Python"}, {"instruction": "[VARIABLE \"bucket_\"]", "input": "Java", "output": "public Page<Bucket> listBucketsWithSizeAndPrefix(String prefix) {\n    // [START listBucketsWithSizeAndPrefix]\n    // Include a prefix of bucket-name to reduce search space.\n    // For more information read https://cloud.google.com/storage/docs/json_api/v1/buckets/list\n    Page<Bucket> buckets =\n        storage.list(BucketListOption.pageSize(100), BucketListOption.prefix(prefix));\n    for (Bucket bucket : buckets.iterateAll()) {\n      // do something with the bucket\n    }\n    // [END listBucketsWithSizeAndPrefix]\n    return buckets;\n  }", "category": "Python"}, {"instruction": "Ipv4 String \u8f6c\u6362\u5230byte[]", "input": "Java", "output": "private static byte[] ip4StringToBytes(String ipv4Str) {\n\t\tif (ipv4Str == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tList<String> it = MoreStringUtil.split(ipv4Str, '.', 4);\n\t\tif (it.size() != 4) {\n\t\t\treturn null;\n\t\t}\n\n\t\tbyte[] byteAddress = new byte[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint tempInt = Integer.parseInt(it.get(i));\n\t\t\tif (tempInt > 255) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbyteAddress[i] = (byte) tempInt;\n\t\t}\n\t\treturn byteAddress;\n\t}", "category": "Python"}, {"instruction": "Executes one iteration of the MetadataCleaner. This ensures that there cannot be more than one concurrent executions of\nsuch an iteration (whether it's from this direct call or from the regular MetadataCleaner invocation). If concurrent\ninvocations are made, then subsequent calls will be tied to the execution of the first, and will all complete at\nthe same time (even though there's only one executing).\n\n@return A CompletableFuture that, when completed, indicates that the operation completed (successfully or not).", "input": "Java", "output": "CompletableFuture<Void> runOnce() {\n        CompletableFuture<Void> result;\n        synchronized (this.singleRunLock) {\n            if (this.currentIteration != null) {\n                // Some other iteration is in progress. Piggyback on that one and return when it is done.\n                return this.currentIteration;\n            } else {\n                // No other iteration is running.\n                this.currentIteration = new CompletableFuture<>();\n                this.currentIteration.whenComplete((r, ex) -> {\n                    // Unregister the current iteration when done.\n                    synchronized (this.singleRunLock) {\n                        this.currentIteration = null;\n                    }\n                });\n                result = this.currentIteration;\n            }\n        }\n\n        Futures.completeAfter(this::runOnceInternal, result);\n        return result;\n    }", "category": "Python"}, {"instruction": "/*\nReturns the JVM-specific size of a primitive type.", "input": "Java", "output": "private static int sizeofPrimitiveType(final Class type) {\n        if (type == int.class) {\n            return INT_FIELD_SIZE;\n        } else if (type == long.class) {\n            return LONG_FIELD_SIZE;\n        } else if (type == short.class) {\n            return SHORT_FIELD_SIZE;\n        } else if (type == byte.class) {\n            return BYTE_FIELD_SIZE;\n        } else if (type == boolean.class) {\n            return BOOLEAN_FIELD_SIZE;\n        } else if (type == char.class) {\n            return CHAR_FIELD_SIZE;\n        } else if (type == double.class) {\n            return DOUBLE_FIELD_SIZE;\n        } else if (type == float.class) {\n            return FLOAT_FIELD_SIZE;\n        } else {\n            throw new IllegalArgumentException(\"not primitive: \" + type);\n        }\n    }", "category": "Python"}, {"instruction": "BC\u7684SM3withSM2\u7b7e\u540d\u5f97\u5230\u7684\u7ed3\u679c\u7684rs\u662fasn1\u683c\u5f0f\u7684\uff0c\u8fd9\u4e2a\u65b9\u6cd5\u8f6c\u5316\u6210\u76f4\u63a5\u62fc\u63a5r||s<br>\n\u6765\u81ea\uff1ahttps://blog.csdn.net/pridas/article/details/86118774\n\n@param rsDer rs in asn1 format\n@return sign result in plain byte array\n@since 4.5.0", "input": "Java", "output": "public static byte[] rsAsn1ToPlain(byte[] rsDer) {\r\n\t\tASN1Sequence seq = ASN1Sequence.getInstance(rsDer);\r\n\t\tbyte[] r = bigIntToFixexLengthBytes(ASN1Integer.getInstance(seq.getObjectAt(0)).getValue());\r\n\t\tbyte[] s = bigIntToFixexLengthBytes(ASN1Integer.getInstance(seq.getObjectAt(1)).getValue());\r\n\t\tbyte[] result = new byte[RS_LEN * 2];\r\n\t\tSystem.arraycopy(r, 0, result, 0, r.length);\r\n\t\tSystem.arraycopy(s, 0, result, RS_LEN, s.length);\r\n\t\treturn result;\r\n\t}", "category": "Python"}, {"instruction": "Deflate the given string via a {@link java.util.zip.Deflater}.\n\n@param data the data\n@return base64 encoded string", "input": "Java", "output": "public static String deflate(final String data) {\n        val deflater = new Deflater();\n        deflater.setInput(data.getBytes(StandardCharsets.UTF_8));\n        deflater.finish();\n        val buffer = new byte[data.length()];\n        val resultSize = deflater.deflate(buffer);\n        val output = new byte[resultSize];\n        System.arraycopy(buffer, 0, output, 0, resultSize);\n        return EncodingUtils.encodeBase64(output);\n    }", "category": "Python"}, {"instruction": "Return a view macro that may or may not be defined in a certain schema. If it's not defined, returns null.\n\n@param schemaPlus   schema\n@param functionName function name\n\n@return view, or null", "input": "Java", "output": "@Nullable\n  private static TableMacro getView(final SchemaPlus schemaPlus, final String functionName)\n  {\n    // Look for a zero-arg function that is also a TableMacro. The returned value\n    // is never null so we don't need to check for that.\n    final Collection<org.apache.calcite.schema.Function> functions =\n        schemaPlus.getFunctions(functionName);\n\n    for (org.apache.calcite.schema.Function function : functions) {\n      if (function.getParameters().isEmpty() && function instanceof TableMacro) {\n        return (TableMacro) function;\n      }\n    }\n\n    return null;\n  }", "category": "Python"}, {"instruction": "\u83b7\u53d6\u6c49\u5b57\u5bf9\u5e94\u7684ascii\u7801\n@param chs \u6c49\u5b57\n@return ascii\u7801", "input": "Java", "output": "private static int getChsAscii(String chs) {\r\n\t\tint asc = 0;\r\n\t\tbyte[] bytes = chs.getBytes(CharsetUtil.CHARSET_GBK);\r\n\t\tswitch (bytes.length) {\r\n\t\tcase 1:\r\n\t\t\t// \u82f1\u6587\u5b57\u7b26\r\n\t\t\tasc = bytes[0];\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\t// \u4e2d\u6587\u5b57\u7b26\r\n\t\t\tint hightByte = 256 + bytes[0];\r\n\t\t\tint lowByte = 256 + bytes[1];\r\n\t\t\tasc = (256 * hightByte + lowByte) - 256 * 256;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow new UtilException(\"Illegal resource string\");\r\n\t\t}\r\n\t\treturn asc;\r\n\t}", "category": "Python"}, {"instruction": "Get all dashboards filtered by title and Pageable ( default page size = 10)\n\n@param title, pageable\n@return Page<Dashboard>", "input": "Java", "output": "@Override\n    public Page<Dashboard> getDashboardByTitleWithFilter(String title, String type, Pageable pageable) {\n        Page<Dashboard> dashboardItems = null;\n        if ((type != null) && (!type.isEmpty()) && (!UNDEFINED.equalsIgnoreCase(type))) {\n            dashboardItems = dashboardRepository.findAllByTypeContainingIgnoreCaseAndTitleContainingIgnoreCase(type, title, pageable);\n        } else {\n            dashboardItems = dashboardRepository.findAllByTitleContainingIgnoreCase(title, pageable);\n        }\n\n        return dashboardItems;\n    }", "category": "Python"}, {"instruction": "\u5220\u9664\u64cd\u4f5c\n\n@param config\n@param dml", "input": "Java", "output": "private void delete(BatchExecutor batchExecutor, MappingConfig config, SingleDml dml) throws SQLException {\n        Map<String, Object> data = dml.getData();\n        if (data == null || data.isEmpty()) {\n            return;\n        }\n\n        DbMapping dbMapping = config.getDbMapping();\n\n        Map<String, Integer> ctype = getTargetColumnType(batchExecutor.getConn(), config);\n\n        StringBuilder sql = new StringBuilder();\n        sql.append(\"DELETE FROM \").append(SyncUtil.getDbTableName(dbMapping)).append(\" WHERE \");\n\n        List<Map<String, ?>> values = new ArrayList<>();\n        // \u62fc\u63a5\u4e3b\u952e\n        appendCondition(dbMapping, sql, ctype, values, data);\n        batchExecutor.execute(sql.toString(), values);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Delete from target table, sql: {}\", sql);\n        }\n    }", "category": "Python"}, {"instruction": "\u7ed9\u5b9a\u8303\u56f4\u5185\u7684\u6574\u6570\u5217\u8868\n\n@param start \u5f00\u59cb\uff08\u5305\u542b\uff09\n@param stop \u7ed3\u675f\uff08\u5305\u542b\uff09\n@param step \u6b65\u8fdb\n@return \u6574\u6570\u5217\u8868", "input": "Java", "output": "public static int[] range(int start, int stop, int step) {\r\n\t\tif (start < stop) {\r\n\t\t\tstep = Math.abs(step);\r\n\t\t} else if (start > stop) {\r\n\t\t\tstep = -Math.abs(step);\r\n\t\t} else {// start == end\r\n\t\t\treturn new int[] { start };\r\n\t\t}\r\n\r\n\t\tint size = Math.abs((stop - start) / step) + 1;\r\n\t\tint[] values = new int[size];\r\n\t\tint index = 0;\r\n\t\tfor (int i = start; (step > 0) ? i <= stop : i >= stop; i += step) {\r\n\t\t\tvalues[index] = i;\r\n\t\t\tindex++;\r\n\t\t}\r\n\t\treturn values;\r\n\t}", "category": "Python"}, {"instruction": "Takes an image and executes a pipeline of combined transforms.\n\n@param image to transform, null == end of stream\n@param random object to use (or null for deterministic)\n@return transformed image", "input": "Java", "output": "@Override\n    protected ImageWritable doTransform(ImageWritable image, Random random) {\n        if (shuffle) {\n            Collections.shuffle(imageTransforms);\n        }\n\n        currentTransforms.clear();\n\n        // execute each item in the pipeline\n        for (Pair<ImageTransform, Double> tuple : imageTransforms) {\n            if (tuple.getSecond() == 1.0 || rng.nextDouble() < tuple.getSecond()) { // probability of execution\n                currentTransforms.add(tuple.getFirst());\n                image = random != null ? tuple.getFirst().transform(image, random)\n                        : tuple.getFirst().transform(image);\n            }\n        }\n\n        return image;\n    }", "category": "Python"}, {"instruction": "\u8bbe\u7f6e\u54cd\u5e94\u7684Header\n\n@param response \u54cd\u5e94\u5bf9\u8c61{@link HttpServletResponse}\n@param name \u540d\n@param value \u503c\uff0c\u53ef\u4ee5\u662fString\uff0cDate\uff0c int", "input": "Java", "output": "public static void setHeader(HttpServletResponse response, String name, Object value) {\r\n\t\tif (value instanceof String) {\r\n\t\t\tresponse.setHeader(name, (String) value);\r\n\t\t} else if (Date.class.isAssignableFrom(value.getClass())) {\r\n\t\t\tresponse.setDateHeader(name, ((Date) value).getTime());\r\n\t\t} else if (value instanceof Integer || \"int\".equals(value.getClass().getSimpleName().toLowerCase())) {\r\n\t\t\tresponse.setIntHeader(name, (Integer) value);\r\n\t\t} else {\r\n\t\t\tresponse.setHeader(name, value.toString());\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "default value is used for backwards compatibility", "input": "Java", "output": "@POST\n  @Path(\"/worker\")\n  @Consumes(MediaType.APPLICATION_JSON)\n  @ResourceFilters(ConfigResourceFilter.class)\n  public Response setWorkerConfig(\n      final WorkerBehaviorConfig workerBehaviorConfig,\n      @HeaderParam(AuditManager.X_DRUID_AUTHOR) @DefaultValue(\"\") final String author,\n      @HeaderParam(AuditManager.X_DRUID_COMMENT) @DefaultValue(\"\") final String comment,\n      @Context final HttpServletRequest req\n  )\n  {\n    final SetResult setResult = configManager.set(\n        WorkerBehaviorConfig.CONFIG_KEY,\n        workerBehaviorConfig,\n        new AuditInfo(author, comment, req.getRemoteAddr())\n    );\n    if (setResult.isOk()) {\n      log.info(\"Updating Worker configs: %s\", workerBehaviorConfig);\n\n      return Response.ok().build();\n    } else {\n      return Response.status(Response.Status.BAD_REQUEST).build();\n    }\n  }", "category": "Python"}, {"instruction": "Visits a pre-destroy method injection point.\n\n@param declaringType The declaring type of the method. Either a Class or a string representing the name of the type\n@param returnType    The return type of the method\n@param methodName    The method name", "input": "Java", "output": "public void visitPreDestroyMethod(Object declaringType,\n                                      Object returnType,\n                                      String methodName) {\n        visitPreDestroyMethodDefinition();\n        final MethodVisitData methodVisitData = new MethodVisitData(\n                declaringType,\n                false,\n                returnType,\n                methodName,\n                Collections.emptyMap(),\n                Collections.emptyMap(),\n                Collections.emptyMap(),\n                AnnotationMetadata.EMPTY_METADATA);\n        preDestroyMethodVisits.add(methodVisitData);\n        visitMethodInjectionPointInternal(methodVisitData,\n                constructorVisitor,\n                preDestroyMethodVisitor,\n                preDestroyInstanceIndex,\n                ADD_PRE_DESTROY_METHOD);\n    }", "category": "Python"}, {"instruction": "\u63d0\u4ea4\u6279\u6b21", "input": "Java", "output": "public void commit() {\n        if (getBulk().numberOfActions() > 0) {\n            BulkResponse response = getBulk().execute().actionGet();\n            if (response.hasFailures()) {\n                for (BulkItemResponse itemResponse : response.getItems()) {\n                    if (!itemResponse.isFailed()) {\n                        continue;\n                    }\n\n                    if (itemResponse.getFailure().getStatus() == RestStatus.NOT_FOUND) {\n                        logger.error(itemResponse.getFailureMessage());\n                    } else {\n                        throw new RuntimeException(\"ES sync commit error\" + itemResponse.getFailureMessage());\n                    }\n                }\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Register an instance.\n\n@param registration registration info\n@param builder      UriComponentsBuilder\n@return The registered instance id;", "input": "Java", "output": "@PostMapping(path = \"/instances\", consumes = MediaType.APPLICATION_JSON_VALUE)\n    public Mono<ResponseEntity<Map<String, InstanceId>>> register(@RequestBody Registration registration,\n                                                                  UriComponentsBuilder builder) {\n        Registration withSource = Registration.copyOf(registration).source(\"http-api\").build();\n        LOGGER.debug(\"Register instance {}\", withSource);\n        return registry.register(withSource).map(id -> {\n            URI location = builder.replacePath(\"/instances/{id}\").buildAndExpand(id).toUri();\n            return ResponseEntity.created(location).body(Collections.singletonMap(\"id\", id));\n        });\n    }", "category": "Python"}, {"instruction": "Instrumentation for RxJava 1 using function with {@link io.micronaut.tracing.instrument.util.TracingRunnable}..\n\n@param instrumenter A function that instruments an existing Runnable with {@link io.micronaut.tracing.instrument.util.TracingRunnable}.", "input": "Java", "output": "@PostConstruct\n    void init(TracingRunnableInstrumenter instrumenter) {\n        if (instrumenter != null) {\n            Func1<Action0, Action0> existing = RxJavaHooks.getOnScheduleAction();\n            if (existing != null && !(existing instanceof InstrumentScheduleAction)) {\n                RxJavaHooks.setOnScheduleAction(action0 ->\n                        new InstrumentScheduleAction(instrumenter).call(existing.call(action0))\n                );\n            } else {\n                RxJavaHooks.setOnScheduleAction(new InstrumentScheduleAction(instrumenter));\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Returns a {@link Set} view of the mappings contained in this map.  The\nset is backed by the map, so changes to the map are reflected in the\nset, and vice-versa.  The set supports element removal, which removes\nthe corresponding mapping from the map, via the\n<tt>Iterator.remove</tt>, <tt>Set.remove</tt>, <tt>removeAll</tt>,\n<tt>retainAll</tt>, and <tt>clear</tt> operations.  It does not support\nthe <tt>add</tt> or <tt>addAll</tt> operations.\n\n<p>The view's <tt>iterator</tt> is a \"weakly consistent\" iterator\nthat will never throw {@link ConcurrentModificationException},\nand guarantees to traverse elements as they existed upon\nconstruction of the iterator, and may (but is not guaranteed to)\nreflect any modifications subsequent to construction.\n\n<p><strong>Warning:</strong> the iterator associated with this Set\nrequires the creation of {@link java.util.Map.Entry} objects with each\niteration.  The org.cliffc.high_scale_lib.NonBlockingHashMap\ndoes not normally create or using {@link java.util.Map.Entry} objects so\nthey will be created soley to support this iteration.  Iterating using\n{@link #keySet} or {@link #values} will be more efficient.  In addition,\nthis version requires <strong>auto-boxing</strong> the keys.", "input": "Java", "output": "public Set<Map.Entry<Long,TypeV>> entrySet() {\n    return new AbstractSet<Map.Entry<Long,TypeV>>() {\n      public void    clear   (          ) {        NonBlockingHashMapLong.this.clear( ); }\n      public int     size    (          ) { return NonBlockingHashMapLong.this.size ( ); }\n      public boolean remove( final Object o ) {\n        if (!(o instanceof Map.Entry)) return false;\n        final Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n        return NonBlockingHashMapLong.this.remove(e.getKey(), e.getValue());\n      }\n      public boolean contains(final Object o) {\n        if (!(o instanceof Map.Entry)) return false;\n        final Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n        TypeV v = get(e.getKey());\n        return v.equals(e.getValue());\n      }\n      public Iterator<Map.Entry<Long,TypeV>> iterator() { return new SnapshotE(); }\n    };\n  }", "category": "Python"}, {"instruction": "Creates a new data stream that contains the given elements. The elements must all be of the\nsame type, for example, all of the {@link String} or {@link Integer}.\n\n<p>The framework will try and determine the exact type from the elements. In case of generic\nelements, it may be necessary to manually supply the type information via\n{@link #fromCollection(java.util.Collection, org.apache.flink.api.common.typeinfo.TypeInformation)}.\n\n<p>Note that this operation will result in a non-parallel data stream source, i.e. a data\nstream source with a degree of parallelism one.\n\n@param data\nThe array of elements to create the data stream from.\n@param <OUT>\nThe type of the returned data stream\n@return The data stream representing the given array of elements", "input": "Java", "output": "@SafeVarargs\n\tpublic final <OUT> DataStreamSource<OUT> fromElements(OUT... data) {\n\t\tif (data.length == 0) {\n\t\t\tthrow new IllegalArgumentException(\"fromElements needs at least one element as argument\");\n\t\t}\n\n\t\tTypeInformation<OUT> typeInfo;\n\t\ttry {\n\t\t\ttypeInfo = TypeExtractor.getForObject(data[0]);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new RuntimeException(\"Could not create TypeInformation for type \" + data[0].getClass().getName()\n\t\t\t\t\t+ \"; please specify the TypeInformation manually via \"\n\t\t\t\t\t+ \"StreamExecutionEnvironment#fromElements(Collection, TypeInformation)\", e);\n\t\t}\n\t\treturn fromCollection(Arrays.asList(data), typeInfo);\n\t}", "category": "Python"}, {"instruction": "Convert the \"messy\" min/max values on a dataset to something clean. For example, 0.895732 becomes 1.0\n\n@param max   Maximum data point value\n@param min   Minimum data point value\n@param nTick Number of tick marks desired on chart (good setting: 5)\n@return double[] of length 2 - with new minimum and maximum", "input": "Java", "output": "public static double[] graphNiceRange(double max, double min, int nTick){\n        if(max == min || !Double.isFinite(max)){\n            if(max == 0.0 || !Double.isFinite(max)){\n                return new double[]{0.0, 1.0};\n            }\n\n            return graphNiceRange(1.5 * max, 0.5 * max, nTick);\n        }\n\n        double range = niceNum(max-min, false);\n        double d = niceNum(range / (nTick-1), true );\n        double graphMin = Math.floor(min/d)*d;\n        double graphMax = Math.ceil(max/d)*d;\n\n\n        return new double[]{graphMin, graphMax};\n    }", "category": "Python"}, {"instruction": "Initializes the process that periodically fetches CRL data.", "input": "Java", "output": "@SneakyThrows\n    @SuppressWarnings(\"FutureReturnValueIgnored\")\n    public void init() {\n        if (!validateConfiguration()) {\n            return;\n        }\n\n        val results = this.fetcher.fetch(getResources());\n        ResourceCRLRevocationChecker.this.addCrls(results);\n\n        final Runnable scheduledFetcher = () -> {\n            try {\n                val fetchedResults = getFetcher().fetch(getResources());\n                ResourceCRLRevocationChecker.this.addCrls(fetchedResults);\n            } catch (final Exception e) {\n                LOGGER.debug(e.getMessage(), e);\n            }\n        };\n\n        this.scheduler.scheduleAtFixedRate(\n            scheduledFetcher,\n            this.refreshInterval,\n            this.refreshInterval,\n            TimeUnit.SECONDS);\n\n    }", "category": "Python"}, {"instruction": "Convert a class name with underscores to the corresponding column name using \"_\". A name like \"CustomerNumber\"\nclass name would match a \"CUSTOMER_NUMBER\".\n\n@param name the class name to be converted\n@return the name using \"_\"", "input": "Java", "output": "public static String convertClassNameToUnderscoreName(String name) {\n        StringBuilder result = new StringBuilder();\n\n        if (name != null) {\n            int len = name.length();\n\n            if (len > 0) {\n                result.append(name.charAt(0));\n\n                for (int i = 1; i < len; i++) {\n                    if (true == Character.isUpperCase(name.charAt(i))) {\n                        result.append('_');\n                    }\n\n                    result.append(name.charAt(i));\n                }\n            }\n        }\n\n        return result.toString().toUpperCase();\n    }", "category": "Python"}, {"instruction": "This method will either generate a new random sessionId or will retrieve the value stored\nin the \"io\" cookie.  Failures to parse will cause a logging warning to be generated and a\nrandom uuid to be generated instead (same as not passing a cookie in the first place).", "input": "Java", "output": "private UUID generateOrGetSessionIdFromRequest(HttpHeaders headers) {\n        List<String> values = headers.getAll(\"io\");\n        if (values.size() == 1) {\n            try {\n                return UUID.fromString(values.get(0));\n            } catch (IllegalArgumentException iaex) {\n                log.warn(\"Malformed UUID received for session! io=\" + values.get(0));\n            }\n        }\n\n        for (String cookieHeader : headers.getAll(HttpHeaderNames.COOKIE)) {\n            Set<Cookie> cookies = ServerCookieDecoder.LAX.decode(cookieHeader);\n\n            for (Cookie cookie : cookies) {\n                if (cookie.name().equals(\"io\")) {\n                    try {\n                        return UUID.fromString(cookie.value());\n                    } catch (IllegalArgumentException iaex) {\n                        log.warn(\"Malformed UUID received for session! io=\" + cookie.value());\n                    }\n                }\n            }\n        }\n\n        return UUID.randomUUID();\n    }", "category": "Python"}, {"instruction": "\u8ba1\u7b97\u6587\u4ef6\u6821\u9a8c\u7801\n\n@param file \u6587\u4ef6\uff0c\u4e0d\u80fd\u4e3a\u76ee\u5f55\n@param checksum {@link Checksum}\n@return Checksum\n@throws IORuntimeException IO\u5f02\u5e38\n@since 4.0.6", "input": "Java", "output": "public static Checksum checksum(File file, Checksum checksum) throws IORuntimeException {\r\n\t\tAssert.notNull(file, \"File is null !\");\r\n\t\tif (file.isDirectory()) {\r\n\t\t\tthrow new IllegalArgumentException(\"Checksums can't be computed on directories\");\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn IoUtil.checksum(new FileInputStream(file), checksum);\r\n\t\t} catch (FileNotFoundException e) {\r\n\t\t\tthrow new IORuntimeException(e);\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "arg.toByte", "input": "Java", "output": "public static java.lang.Byte toByte(Object arg) throws NoSuchMethodException {\n        if (arg instanceof java.lang.Integer) return boxToByte((byte)unboxToInt(arg));\n        if (arg instanceof java.lang.Character) return boxToByte((byte)unboxToChar(arg));\n        if (arg instanceof java.lang.Byte) return (java.lang.Byte)arg;\n        if (arg instanceof java.lang.Long) return boxToByte((byte)unboxToLong(arg));\n        if (arg instanceof java.lang.Short) return boxToByte((byte)unboxToShort(arg));\n        if (arg instanceof java.lang.Float) return boxToByte((byte)unboxToFloat(arg));\n        if (arg instanceof java.lang.Double) return boxToByte((byte)unboxToDouble(arg));\n        throw new NoSuchMethodException();\n    }", "category": "Python"}, {"instruction": "\u521d\u59cb\u5316<br>\n\u8bbe\u5b9a\u6587\u4ef6\u4e2d\u7684host\u548c\u7aef\u53e3\u6709\u4e09\u79cd\u5f62\u5f0f\uff1a\n\n<pre>\nhost = host:port\n</pre>\n\n<pre>\nhost = host\nport = port\n</pre>\n\n<pre>\nhost = host\n</pre>", "input": "Java", "output": "synchronized public void initSingle() {\r\n\t\tif (setting == null) {\r\n\t\t\ttry {\r\n\t\t\t\tsetting = new Setting(MONGO_CONFIG_PATH, true);\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\t// \u5728single\u6a21\u5f0f\u4e0b\uff0c\u53ef\u4ee5\u6ca1\u6709\u914d\u7f6e\u6587\u4ef6\u3002\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tString group = StrUtil.EMPTY;\r\n\t\tif (null == this.serverAddress) {\r\n\t\t\t//\u5b58\u5728\u552f\u4e00\u5206\u7ec4\r\n\t\t\tif (groups != null && groups.length == 1) {\r\n\t\t\t\tgroup = groups[0];\r\n\t\t\t}\r\n\t\t\tserverAddress = createServerAddress(group);\r\n\t\t}\r\n\r\n\t\tfinal MongoCredential credentail = createCredentail(group);\r\n\t\ttry {\r\n\t\t\tif (null == credentail) {\r\n\t\t\t\tmongo = new MongoClient(serverAddress, buildMongoClientOptions(group));\r\n\t\t\t} else {\r\n\t\t\t\tmongo = new MongoClient(serverAddress, credentail, buildMongoClientOptions(group));\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new DbRuntimeException(StrUtil.format(\"Init MongoDB pool with connection to [{}] error!\", serverAddress), e);\r\n\t\t}\r\n\r\n\t\tlog.info(\"Init MongoDB pool with connection to [{}]\", serverAddress);\r\n\t}", "category": "Python"}, {"instruction": "Find by principal name.\n@param principal name to search for\n@return records for given principal", "input": "Java", "output": "@View(name = \"by_principal\",\n        map = \"function(doc) { if (doc.principal && doc.deviceFingerprint && doc.recordDate) { emit(doc.principal, doc) } }\")\n    public List<CouchDbMultifactorAuthenticationTrustRecord> findByPrincipal(final String principal) {\n        val view = createQuery(\"by_principal\").key(principal);\n        return db.queryView(view, CouchDbMultifactorAuthenticationTrustRecord.class);\n    }", "category": "Python"}, {"instruction": "An expectation for checking if the given text is present in the specified elements value\nattribute.\n\n@param locator used to find the element\n@param text    to be present in the value attribute of the element found by the locator\n@return true once the value attribute of the first element located by locator contains the\ngiven text", "input": "Java", "output": "public static ExpectedCondition<Boolean> textToBePresentInElementValue(final By locator,\n                                                                         final String text) {\n\n    return new ExpectedCondition<Boolean>() {\n      @Override\n      public Boolean apply(WebDriver driver) {\n        try {\n          String elementText = driver.findElement(locator).getAttribute(\"value\");\n          if (elementText != null) {\n            return elementText.contains(text);\n          }\n          return false;\n        } catch (StaleElementReferenceException e) {\n          return null;\n        }\n      }\n\n      @Override\n      public String toString() {\n        return String.format(\"text ('%s') to be the value of element located by %s\",\n                             text, locator);\n      }\n    };\n  }", "category": "Python"}, {"instruction": "------------------------------------------------------------------------", "input": "Java", "output": "@Override\n\tpublic void onTaskFailure(Execution taskExecution, Throwable cause) {\n\t\tfinal ExecutionVertex ev = taskExecution.getVertex();\n\t\tfinal FailoverRegion failoverRegion = vertexToRegion.get(ev);\n\n\t\tif (failoverRegion == null) {\n\t\t\texecutionGraph.failGlobal(new FlinkException(\n\t\t\t\t\t\"Can not find a failover region for the execution \" + ev.getTaskNameWithSubtaskIndex(), cause));\n\t\t}\n\t\telse {\n\t\t\tLOG.info(\"Recovering task failure for {} #{} ({}) via restart of failover region\",\n\t\t\t\t\ttaskExecution.getVertex().getTaskNameWithSubtaskIndex(),\n\t\t\t\t\ttaskExecution.getAttemptNumber(),\n\t\t\t\t\ttaskExecution.getAttemptId());\n\n\t\t\tfailoverRegion.onExecutionFail(taskExecution, cause);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Get metric snapshots for a metric and date specification", "input": "Java", "output": "private void handleGetMetricHistory(final int executorId, final HttpServletRequest req,\n      final HashMap<String, Object> ret, final User user) throws IOException,\n      ServletException {\n    try {\n      final Map<String, Object> result =\n          this.execManagerAdapter.callExecutorStats(executorId,\n              ConnectorParams.STATS_GET_METRICHISTORY, getAllParams(req));\n      if (result.containsKey(ConnectorParams.RESPONSE_ERROR)) {\n        ret.put(ConnectorParams.RESPONSE_ERROR,\n            result.get(ConnectorParams.RESPONSE_ERROR).toString());\n      } else {\n        ret.put(\"data\", result.get(\"data\"));\n      }\n    } catch (final ExecutorManagerException ex) {\n      logger.error(ex.getMessage(), ex);\n      ret.put(\"error\", \"Failed to fetch metric history\");\n    }\n  }", "category": "Python"}, {"instruction": "Uploads and registers a single resource and adds it to <tt>localResources</tt>.\n\n@param key\nthe key to add the resource under\n@param fs\nthe remote file system to upload to\n@param appId\napplication ID\n@param localSrcPath\nlocal path to the file\n@param localResources\nmap of resources\n\n@return the remote path to the uploaded resource", "input": "Java", "output": "private static Path setupSingleLocalResource(\n\t\t\tString key,\n\t\t\tFileSystem fs,\n\t\t\tApplicationId appId,\n\t\t\tPath localSrcPath,\n\t\t\tMap<String, LocalResource> localResources,\n\t\t\tPath targetHomeDir,\n\t\t\tString relativeTargetPath) throws IOException, URISyntaxException {\n\n\t\tTuple2<Path, LocalResource> resource = Utils.setupLocalResource(\n\t\t\tfs,\n\t\t\tappId.toString(),\n\t\t\tlocalSrcPath,\n\t\t\ttargetHomeDir,\n\t\t\trelativeTargetPath);\n\n\t\tlocalResources.put(key, resource.f1);\n\n\t\treturn resource.f0;\n\t}", "category": "Python"}, {"instruction": "Lists time series that match a filter. This method does not require a Stackdriver account.\n\n<p>Sample code:\n\n<pre><code>\ntry (MetricServiceClient metricServiceClient = MetricServiceClient.create()) {\nProjectName name = ProjectName.of(\"[PROJECT]\");\nString filter = \"\";\nTimeInterval interval = TimeInterval.newBuilder().build();\nListTimeSeriesRequest.TimeSeriesView view = ListTimeSeriesRequest.TimeSeriesView.FULL;\nfor (TimeSeries element : metricServiceClient.listTimeSeries(name, filter, interval, view).iterateAll()) {\n// doThingsWith(element);\n}\n}\n</code></pre>\n\n@param name The project on which to execute the request. The format is\n\"projects/{project_id_or_number}\".\n@param filter A [monitoring filter](/monitoring/api/v3/filters) that specifies which time\nseries should be returned. The filter must specify a single metric type, and can\nadditionally specify metric labels and other information. For example:\n<p>metric.type = \"compute.googleapis.com/instance/cpu/usage_time\" AND\nmetric.label.instance_name = \"my-instance-name\"\n@param interval The time interval for which results should be returned. Only time series that\ncontain data points in the specified interval are included in the response.\n@param view Specifies which information is returned about the time series.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "public final ListTimeSeriesPagedResponse listTimeSeries(\n      ProjectName name,\n      String filter,\n      TimeInterval interval,\n      ListTimeSeriesRequest.TimeSeriesView view) {\n    ListTimeSeriesRequest request =\n        ListTimeSeriesRequest.newBuilder()\n            .setName(name == null ? null : name.toString())\n            .setFilter(filter)\n            .setInterval(interval)\n            .setView(view)\n            .build();\n    return listTimeSeries(request);\n  }", "category": "Python"}, {"instruction": "This method initializes logPanel\n\n@return org.parosproxy.paros.extension.history.LogPanel", "input": "Java", "output": "private LogPanel getLogPanel() {\r\n\t\tif (logPanel == null) {\r\n\t\t\tlogPanel = new LogPanel(getView());\r\n\t\t\tlogPanel.setName(Constant.messages.getString(\"history.panel.title\"));\t// ZAP: i18n\r\n\t\t\t// ZAP: Added History (calendar) icon\r\n\t\t\tlogPanel.setIcon(new ImageIcon(ExtensionHistory.class.getResource(\"/resource/icon/16/025.png\")));\t// 'calendar' icon\r\n\t\t\t// Dont allow this tab to be hidden\r\n\t\t\tlogPanel.setHideable(false);\r\n\r\n            logPanel.setExtension(this);\r\n            logPanel.setModel(historyTableModel);\r\n\t\t}\r\n\t\treturn logPanel;\r\n\t}", "category": "Python"}, {"instruction": "Create a composition with {@link LottieCompositionFactory}\n\n@return True if the composition is different from the previously set composition, false otherwise.", "input": "Java", "output": "public boolean setComposition(LottieComposition composition) {\n    if (this.composition == composition) {\n      return false;\n    }\n\n    isDirty = false;\n    clearComposition();\n    this.composition = composition;\n    buildCompositionLayer();\n    animator.setComposition(composition);\n    setProgress(animator.getAnimatedFraction());\n    setScale(scale);\n    updateBounds();\n\n    // We copy the tasks to a new ArrayList so that if this method is called from multiple threads,\n    // then there won't be two iterators iterating and removing at the same time.\n    Iterator<LazyCompositionTask> it = new ArrayList<>(lazyCompositionTasks).iterator();\n    while (it.hasNext()) {\n      LazyCompositionTask t = it.next();\n      t.run(composition);\n      it.remove();\n    }\n    lazyCompositionTasks.clear();\n\n    composition.setPerformanceTrackingEnabled(performanceTrackingEnabled);\n\n    return true;\n  }", "category": "Python"}, {"instruction": "\u5faa\u73af\u5411\u4e0a\u8f6c\u578b, \u83b7\u53d6\u5bf9\u8c61\u7684DeclaredField, \u5e76\u5f3a\u5236\u8bbe\u7f6e\u4e3a\u53ef\u8bbf\u95ee.\n\n\u5982\u5411\u4e0a\u8f6c\u578b\u5230Object\u4ecd\u65e0\u6cd5\u627e\u5230, \u8fd4\u56denull.\n\n\u56e0\u4e3agetFiled()\u4e0d\u80fd\u83b7\u53d6\u7236\u7c7b\u7684private\u5c5e\u6027, \u56e0\u6b64\u91c7\u7528\u5faa\u73af\u5411\u4e0a\u7684getDeclaredField();", "input": "Java", "output": "public static Field getField(final Class clazz, final String fieldName) {\n\t\tValidate.notNull(clazz, \"clazz can't be null\");\n\t\tValidate.notEmpty(fieldName, \"fieldName can't be blank\");\n\t\tfor (Class<?> superClass = clazz; superClass != Object.class; superClass = superClass.getSuperclass()) {\n\t\t\ttry {\n\t\t\t\tField field = superClass.getDeclaredField(fieldName);\n\t\t\t\tmakeAccessible(field);\n\t\t\t\treturn field;\n\t\t\t} catch (NoSuchFieldException e) {// NOSONAR\n\t\t\t\t// Field\u4e0d\u5728\u5f53\u524d\u7c7b\u5b9a\u4e49,\u7ee7\u7eed\u5411\u4e0a\u8f6c\u578b\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}", "category": "Python"}, {"instruction": "Save a {@code JavaRDD<List<List<Writable>>>} to a Hadoop {@link org.apache.hadoop.io.SequenceFile}. Each record\nis given a unique (but noncontiguous) {@link LongWritable} key, and values are stored as {@link SequenceRecordWritable} instances.\n<p>\nUse {@link #restoreSequenceFileSequences(String, JavaSparkContext)} to restore values saved with this method.\n\n@param path           Path to save the sequence file\n@param rdd            RDD to save\n@param maxOutputFiles Nullable. If non-null: first coalesce the RDD to the specified size (number of partitions)\nto limit the maximum number of output sequence files\n@see #saveSequenceFile(String, JavaRDD)\n@see #saveMapFileSequences(String, JavaRDD)", "input": "Java", "output": "public static void saveSequenceFileSequences(String path, JavaRDD<List<List<Writable>>> rdd,\n                     Integer maxOutputFiles) {\n        path = FilenameUtils.normalize(path, true);\n        if (maxOutputFiles != null) {\n            rdd = rdd.coalesce(maxOutputFiles);\n        }\n        JavaPairRDD<List<List<Writable>>, Long> dataIndexPairs = rdd.zipWithUniqueId(); //Note: Long values are unique + NOT contiguous; more efficient than zipWithIndex\n        JavaPairRDD<LongWritable, SequenceRecordWritable> keyedByIndex =\n                        dataIndexPairs.mapToPair(new SequenceRecordSavePrepPairFunction());\n\n        keyedByIndex.saveAsNewAPIHadoopFile(path, LongWritable.class, SequenceRecordWritable.class,\n                        SequenceFileOutputFormat.class);\n    }", "category": "Python"}, {"instruction": "This shuts down the flow runner. The call is blocking and awaits execution of all jobs.", "input": "Java", "output": "public void shutdown() {\n    logger.warn(\"Shutting down FlowRunnerManager...\");\n    if (this.azkabanProps.getBoolean(ConfigurationKeys.AZKABAN_POLL_MODEL, false)) {\n      this.pollingService.shutdown();\n    }\n    this.executorService.shutdown();\n    boolean result = false;\n    while (!result) {\n      logger.info(\"Awaiting Shutdown. # of executing flows: \" + getNumRunningFlows());\n      try {\n        result = this.executorService.awaitTermination(1, TimeUnit.MINUTES);\n      } catch (final InterruptedException e) {\n        logger.error(e);\n      }\n    }\n    logger.warn(\"Shutdown FlowRunnerManager complete.\");\n  }", "category": "Python"}, {"instruction": "Given all of the thread pool configuration, what is the actual maximumSize applied to the thread pool\nvia {@link ThreadPoolExecutor#setMaximumPoolSize(int)}\n\nCases:\n1) allowMaximumSizeToDivergeFromCoreSize == false: maximumSize is set to coreSize\n2) allowMaximumSizeToDivergeFromCoreSize == true, maximumSize >= coreSize: thread pool has different core/max sizes, so return the configured max\n3) allowMaximumSizeToDivergeFromCoreSize == true, maximumSize < coreSize: threadpool incorrectly configured, use coreSize for max size\n@return actually configured maximum size of threadpool", "input": "Java", "output": "public Integer actualMaximumSize() {\n        final int coreSize = coreSize().get();\n        final int maximumSize = maximumSize().get();\n        if (getAllowMaximumSizeToDivergeFromCoreSize().get()) {\n            if (coreSize > maximumSize) {\n                return coreSize;\n            } else {\n                return maximumSize;\n            }\n        } else {\n            return coreSize;\n        }\n    }", "category": "Python"}, {"instruction": "\u8fde\u63a5\u8f6c\u5b57\u7b26\u4e32\n\n@param local1  \u672c\u5730\u5730\u5740\n@param remote1 \u8fdc\u7a0b\u5730\u5740\n@return \u5730\u5740\u4fe1\u606f\u5b57\u7b26\u4e32", "input": "Java", "output": "public static String channelToString(SocketAddress local1, SocketAddress remote1) {\n        try {\n            InetSocketAddress local = (InetSocketAddress) local1;\n            InetSocketAddress remote = (InetSocketAddress) remote1;\n            return toAddressString(local) + \" -> \" + toAddressString(remote);\n        } catch (Exception e) {\n            return local1 + \"->\" + remote1;\n        }\n    }", "category": "Python"}, {"instruction": "This method initializes btnCancel\n\n@return javax.swing.JButton", "input": "Java", "output": "private JButton getBtnCancel() {\r\n\t\tif (btnCancel == null) {\r\n\t\t\tbtnCancel = new JButton();\r\n\t\t\tbtnCancel.setText(Constant.messages.getString(\"edit.find.button.cancel\"));\r\n\t\t\tbtnCancel.addActionListener(new java.awt.event.ActionListener() { \r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void actionPerformed(java.awt.event.ActionEvent e) {\r\n\r\n\t\t\t\t\tFindDialog.this.discard();\r\n\t\t\t\t\tFindDialog.this.dispatchEvent(new WindowEvent(FindDialog.this, WindowEvent.WINDOW_CLOSING));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\treturn btnCancel;\r\n\t}", "category": "Python"}, {"instruction": "Configure Azkaban metrics tracking for a new flowRunner instance", "input": "Java", "output": "private void configureFlowLevelMetrics(final FlowRunner flowRunner) {\n    logger.info(\"Configuring Azkaban metrics tracking for flow runner object\");\n\n    if (MetricReportManager.isAvailable()) {\n      final MetricReportManager metricManager = MetricReportManager.getInstance();\n      // Adding NumFailedFlow Metric listener\n      flowRunner.addListener((NumFailedFlowMetric) metricManager\n          .getMetricFromName(NumFailedFlowMetric.NUM_FAILED_FLOW_METRIC_NAME));\n    }\n\n  }", "category": "Python"}, {"instruction": "Gets a list of the http cookies from this request Header.\n\n@return the http cookies\n@throws IllegalArgumentException if a problem is encountered while\nprocessing the \"Cookie: \" header line.", "input": "Java", "output": "public List<HttpCookie> getHttpCookies() {\r\n        List<HttpCookie> cookies = new LinkedList<>();\r\n        // Use getCookieParams to reduce the places we parse cookies\r\n        TreeSet<HtmlParameter> ts = getCookieParams();\r\n        Iterator<HtmlParameter> it = ts.iterator();\r\n        while (it.hasNext()) {\r\n            HtmlParameter htmlParameter = it.next();\r\n            if (!htmlParameter.getName().isEmpty()) {\r\n                try {\r\n                    cookies.add(new HttpCookie(htmlParameter.getName(), htmlParameter.getValue()));\r\n                \r\n                } catch (IllegalArgumentException e) {\r\n                    // Occurs while scanning ;)\r\n                    log.debug(e.getMessage() + \" \" + htmlParameter.getName());\r\n                }\r\n            }\r\n        }\r\n        \r\n        return cookies;\r\n    }", "category": "Python"}, {"instruction": "Like the standard next method but allows a\ncustomizable number of examples returned\n\n@param num the number of examples\n@return the next data applyTransformToDestination", "input": "Java", "output": "@Override\n    public DataSet next(int num) {\n        if (num <= cachedWindow.size())\n            return fromCached(num);\n        //no more sentences, return the left over\n        else if (num >= cachedWindow.size() && !iter.hasNext())\n            return fromCached(cachedWindow.size());\n\n        //need the next sentence\n        else {\n            while (cachedWindow.size() < num && iter.hasNext()) {\n                String sentence = iter.nextSentence();\n                if (sentence.isEmpty())\n                    continue;\n                List<Window> windows = Windows.windows(sentence, vec.getTokenizerFactory(), vec.getWindow(), vec);\n                if (windows.isEmpty() && !sentence.isEmpty())\n                    throw new IllegalStateException(\"Empty window on sentence\");\n                for (Window w : windows)\n                    w.setLabel(iter.currentLabel());\n                cachedWindow.addAll(windows);\n            }\n\n            return fromCached(num);\n        }\n\n    }", "category": "Python"}, {"instruction": "/* (non-Javadoc)\n@see org.parosproxy.paros.db.paros.TableContext#getDataForContext(int)", "input": "Java", "output": "@Override\r\n\tpublic synchronized List<RecordContext> getDataForContext (int contextId) throws DatabaseException {\r\n    \ttry {\r\n\t\t\tList<RecordContext> result = new ArrayList<>();\r\n\t\t\tpsGetAllDataForContext.setInt(1, contextId);\r\n\t\t\ttry (ResultSet rs = psGetAllDataForContext.executeQuery()) {\r\n\t\t\t\twhile (rs.next()) {\r\n\t\t\t\t\tresult.add(new RecordContext(rs.getLong(DATAID), rs.getInt(CONTEXTID), rs.getInt(TYPE), rs.getString(DATA)));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t} catch (SQLException e) {\r\n\t\t\tthrow new DatabaseException(e);\r\n\t\t}\r\n    }", "category": "Python"}, {"instruction": "Calculate the inner product value between vectors.", "input": "Java", "output": "static double inner_product(SparseVector vec1, SparseVector vec2)\n    {\n        Iterator<Map.Entry<Integer, Double>> it;\n        SparseVector other;\n        if (vec1.size() < vec2.size())\n        {\n            it = vec1.entrySet().iterator();\n            other = vec2;\n        }\n        else\n        {\n            it = vec2.entrySet().iterator();\n            other = vec1;\n        }\n        double prod = 0;\n        while (it.hasNext())\n        {\n            Map.Entry<Integer, Double> entry = it.next();\n            prod += entry.getValue() * other.get(entry.getKey());\n        }\n        return prod;\n    }", "category": "Python"}, {"instruction": "Called by {@link Executor} to kill excessive executors from this computer.", "input": "Java", "output": "protected void removeExecutor(final Executor e) {\n        final Runnable task = new Runnable() {\n            @Override\n            public void run() {\n                synchronized (Computer.this) {\n                    executors.remove(e);\n                    addNewExecutorIfNecessary();\n                    if (!isAlive()) {\n                        AbstractCIBase ciBase = Jenkins.getInstanceOrNull();\n                        if (ciBase != null) { // TODO confirm safe to assume non-null and use getInstance()\n                            ciBase.removeComputer(Computer.this);\n                        }\n                    }\n                }\n            }\n        };\n        if (!Queue.tryWithLock(task)) {\n            // JENKINS-28840 if we couldn't get the lock push the operation to a separate thread to avoid deadlocks\n            threadPoolForRemoting.submit(Queue.wrapWithLock(task));\n        }\n    }", "category": "Python"}, {"instruction": "\u8c03\u7528\u8f6c\u53d1\uff0c\u5982\u679c\u9700\u8981\u8f6c\u53d1\u8fd4\u56de\u8f6c\u53d1\u7ed3\u679c\uff0c\u5426\u5219\u8fd4\u56de<code>null</code>\n\n@return {@link HttpResponse}\uff0c\u65e0\u8f6c\u53d1\u8fd4\u56de <code>null</code>", "input": "Java", "output": "private HttpResponse sendRedirectIfPosible() {\r\n\t\tif (this.maxRedirectCount < 1) {\r\n\t\t\t// \u4e0d\u91cd\u5b9a\u5411\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// \u624b\u52a8\u5b9e\u73b0\u91cd\u5b9a\u5411\r\n\t\tif (this.httpConnection.getHttpURLConnection().getInstanceFollowRedirects()) {\r\n\t\t\tint responseCode;\r\n\t\t\ttry {\r\n\t\t\t\tresponseCode = httpConnection.responseCode();\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\tthrow new HttpException(e);\r\n\t\t\t}\r\n\t\t\tif (responseCode != HttpURLConnection.HTTP_OK) {\r\n\t\t\t\tif (responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_SEE_OTHER) {\r\n\t\t\t\t\tthis.url = httpConnection.header(Header.LOCATION);\r\n\t\t\t\t\tif (redirectCount < this.maxRedirectCount) {\r\n\t\t\t\t\t\tredirectCount++;\r\n\t\t\t\t\t\treturn execute();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tStaticLog.warn(\"URL [{}] redirect count more than two !\", this.url);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}", "category": "Python"}, {"instruction": "\u89e3\u538b\u7f29", "input": "Java", "output": "public void unSimplify()\n    {\n        if (sourceNode == null)\n        {\n            sourceNode = new MDAGNode(false);\n            equivalenceClassMDAGNodeHashMap = new HashMap<MDAGNode, MDAGNode>();\n            MDAGNode[] toNodeArray = new MDAGNode[mdagDataArray.length];\n            createMDAGNode(simplifiedSourceNode, -1, toNodeArray, new MDAGNode[mdagDataArray.length]);\n            // \u6784\u5efa\u6ce8\u518c\u8868\n            for (MDAGNode mdagNode : toNodeArray)\n            {\n                equivalenceClassMDAGNodeHashMap.put(mdagNode, mdagNode);\n            }\n            // \u6254\u6389\u5783\u573e\n            simplifiedSourceNode = null;\n        }\n    }", "category": "Python"}, {"instruction": "\u8c03\u6574\u4e00\u4e0b\u7ebf\u7a0b\u6c60", "input": "Java", "output": "private void adjustPoolSize(DbLoadContext context) {\n        Pipeline pipeline = context.getPipeline();\n        int newPoolSize = pipeline.getParameters().getLoadPoolSize();\n        if (newPoolSize != poolSize) {\n            poolSize = newPoolSize;\n            if (executor instanceof ThreadPoolExecutor) {\n                ThreadPoolExecutor pool = (ThreadPoolExecutor) executor;\n                pool.setCorePoolSize(newPoolSize);\n                pool.setMaximumPoolSize(newPoolSize);\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Create a proxy for the specified {@link Connection} instance.\n@param poolEntry the PoolEntry holding pool state\n@param connection the raw database Connection\n@param openStatements a reusable list to track open Statement instances\n@param leakTask the ProxyLeakTask for this connection\n@param now the current timestamp\n@param isReadOnly the default readOnly state of the connection\n@param isAutoCommit the default autoCommit state of the connection\n@return a proxy that wraps the specified {@link Connection}", "input": "Java", "output": "static ProxyConnection getProxyConnection(final PoolEntry poolEntry, final Connection connection, final FastList<Statement> openStatements, final ProxyLeakTask leakTask, final long now, final boolean isReadOnly, final boolean isAutoCommit)\n   {\n      // Body is replaced (injected) by JavassistProxyFactory\n      throw new IllegalStateException(\"You need to run the CLI build and you need target/classes in your classpath to run.\");\n   }", "category": "Python"}, {"instruction": "Normalize the URL for use in the signature. The OAuth spec says the URL protocol and host are to be lower-case,\nand the query and fragments are to be stripped.\n\n@param url The URL.\n@return The URL normalized for use in the signature.", "input": "Java", "output": "protected String normalizeUrl(String url) {\n    try {\n      URL requestURL = new URL(url);\n      StringBuilder normalized = new StringBuilder(requestURL.getProtocol().toLowerCase()).append(\"://\").append(requestURL.getHost().toLowerCase());\n      if ((requestURL.getPort() >= 0) && (requestURL.getPort() != requestURL.getDefaultPort())) {\n        normalized.append(\":\").append(requestURL.getPort());\n      }\n      normalized.append(requestURL.getPath());\n      return normalized.toString();\n    }\n    catch (MalformedURLException e) {\n      throw new IllegalStateException(\"Illegal URL for calculating the OAuth signature.\", e);\n    }\n  }", "category": "Python"}, {"instruction": "\u65b9\u6cd5\u662f\u5426\u4e3aGetter\u65b9\u6cd5<br>\n\u5339\u914d\u89c4\u5219\u5982\u4e0b\uff08\u5ffd\u7565\u5927\u5c0f\u5199\uff09\uff1a\n\n<pre>\n\u5b57\u6bb5\u540d    -\u300b \u65b9\u6cd5\u540d\nisName  -\u300b isName\nisName  -\u300b isIsName\nisName  -\u300b getIsName\nname     -\u300b isName\nname     -\u300b getName\n</pre>\n\n@param methodName \u65b9\u6cd5\u540d\n@param fieldName \u5b57\u6bb5\u540d\n@param isBooeanField \u662f\u5426\u4e3aBoolean\u7c7b\u578b\u5b57\u6bb5\n@return \u662f\u5426\u5339\u914d", "input": "Java", "output": "private boolean isMatchGetter(String methodName, String fieldName, boolean isBooeanField) {\r\n\t\t// \u5168\u90e8\u8f6c\u4e3a\u5c0f\u5199\uff0c\u5ffd\u7565\u5927\u5c0f\u5199\u6bd4\u8f83\r\n\t\tmethodName = methodName.toLowerCase();\r\n\t\tfieldName = fieldName.toLowerCase();\r\n\r\n\t\tif (false == methodName.startsWith(\"get\") && false == methodName.startsWith(\"is\")) {\r\n\t\t\t// \u975e\u6807\u51c6Getter\u65b9\u6cd5\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif(\"getclass\".equals(methodName)) {\r\n\t\t\t//\u8df3\u8fc7getClass\u65b9\u6cd5\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// \u9488\u5bf9Boolean\u7c7b\u578b\u7279\u6b8a\u68c0\u67e5\r\n\t\tif (isBooeanField) {\r\n\t\t\tif (fieldName.startsWith(\"is\")) {\r\n\t\t\t\t// \u5b57\u6bb5\u5df2\u7ecf\u662fis\u5f00\u5934\r\n\t\t\t\tif (methodName.equals(fieldName) // isName -\u300b isName\r\n\t\t\t\t\t\t|| methodName.equals(\"get\" + fieldName)// isName -\u300b getIsName\r\n\t\t\t\t\t\t|| methodName.equals(\"is\" + fieldName)// isName -\u300b isIsName\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t} else if (methodName.equals(\"is\" + fieldName)) {\r\n\t\t\t\t// \u5b57\u6bb5\u975eis\u5f00\u5934\uff0c name -\u300b isName\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// \u5305\u62ecboolean\u7684\u4efb\u4f55\u7c7b\u578b\u53ea\u6709\u4e00\u79cd\u5339\u914d\u60c5\u51b5\uff1aname -\u300b getName\r\n\t\treturn methodName.equals(\"get\" + fieldName);\r\n\t}", "category": "Python"}, {"instruction": "VJ: \u52a0\u4e0asymbolType instanceof JavaType\u7684\u5224\u65ad\uff0c\u9632\u6b62\u6570\u7ec4\u8f6c\u6362\u51fa\u9519", "input": "Java", "output": "private static boolean isConstantType(Type symbolType) {\n\t\treturn symbolType.isPrimitive() || symbolType.is(\"java.lang.String\") ||  symbolType.is(\"java.lang.Byte\") ||\n\t\t\t\tsymbolType.is(\"java.lang.Character\") ||\n\t\t\t\tsymbolType.is(\"java.lang.Short\") ||\n\t\t\t\tsymbolType.is(\"java.lang.Integer\") ||\n\t\t\t\tsymbolType.is(\"java.lang.Long\") ||\n\t\t\t\tsymbolType.is(\"java.lang.Float\") ||\n\t\t\t\tsymbolType.is(\"java.lang.Double\") ||\n\t\t\t\tsymbolType.is(\"java.lang.Boolean\");\n\t}", "category": "Python"}, {"instruction": "Writes the request headers to the given {@link HttpConnection connection}.\n\n<p>\nThis implementation invokes {@link #addRequestHeaders(HttpState,HttpConnection)},\nand then writes each header to the request stream.\n</p>\n\n<p>\nSubclasses may want to override this method to to customize the\nprocessing.\n</p>\n\n@param state the {@link HttpState state} information associated with this method\n@param conn the {@link HttpConnection connection} used to execute\nthis HTTP method\n\n@throws IOException if an I/O (transport) error occurs. Some transport exceptions\ncan be recovered from.\n@throws HttpException  if a protocol exception occurs. Usually protocol exceptions\ncannot be recovered from.\n\n@see #addRequestHeaders\n@see #getRequestHeaders", "input": "Java", "output": "protected void writeRequestHeaders(HttpState state, HttpConnection conn)\n    throws IOException, HttpException {\n        LOG.trace(\"enter HttpMethodBase.writeRequestHeaders(HttpState,\"\n            + \"HttpConnection)\");\n        addRequestHeaders(state, conn);\n\n        String charset = getParams().getHttpElementCharset();\n        \n        Header[] headers = getRequestHeaders();\n        for (int i = 0; i < headers.length; i++) {\n            String s = headers[i].toExternalForm();\n            if (Wire.HEADER_WIRE.enabled()) {\n                Wire.HEADER_WIRE.output(s);\n            }\n            conn.print(s, charset);\n        }\n    }", "category": "Python"}, {"instruction": "Sets the position of the response panel. Should be considered a hint, not all workbench layouts might use this setting.\n<p>\nIf the position is already set no further action is taken, otherwise updates the main tool bar buttons, the workbench\npanel and the configurations file.\n\n@param position the new position of the response panel\n@throws IllegalArgumentException if the given parameter is {@code null}.\n@since 2.5.0\n@see #getResponsePanelPosition()\n@see #setWorkbenchLayout(org.parosproxy.paros.view.WorkbenchPanel.Layout)", "input": "Java", "output": "public void setResponsePanelPosition(WorkbenchPanel.ResponsePanelPosition position) {\r\n\t\tif (position == null) {\r\n\t\t\tthrow new IllegalArgumentException(\"Parameter position must not be null.\");\r\n\t\t}\r\n\r\n\t\tif (responsePanelPosition == position) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tresponsePanelPosition = position;\r\n\r\n\t\tswitch (position) {\r\n\t\tcase PANEL_ABOVE:\r\n\t\t\taboveResponsePanelPositionButton.setSelected(true);\r\n\t\t\tbreak;\r\n\t\tcase PANELS_SIDE_BY_SIDE:\r\n\t\t\tpanelsResponsePanelPositionButton.setSelected(true);\r\n\t\t\tbreak;\r\n\t\tcase TAB_SIDE_BY_SIDE:\r\n\t\t\ttabSideBySideResponsePanelPositionButton.setSelected(true);\r\n\t\t\tbreak;\r\n\t\tcase TABS_SIDE_BY_SIDE:\r\n\t\tdefault:\r\n\t\t\ttabsResponsePanelPositionButton.setSelected(true);\r\n\t\t}\r\n\r\n\t\tgetWorkbench().setResponsePanelPosition(responsePanelPosition);\r\n\t\toptions.getViewParam().setResponsePanelPosition(responsePanelPosition.toString());\r\n\t}", "category": "Python"}, {"instruction": "*************************************************************************\n* Setters / Getters * *\n************************************************************************", "input": "Java", "output": "public void setControl(Node control) {\n        if (control != null) {\n            this.control = control;\n            this.badge = new Group();\n            this.getChildren().add(control);\n            this.getChildren().add(badge);\n\n            // if the control got resized the badge must be rest\n            if (control instanceof Region) {\n                ((Region) control).widthProperty().addListener((o, oldVal, newVal) -> refreshBadge());\n                ((Region) control).heightProperty().addListener((o, oldVal, newVal) -> refreshBadge());\n            }\n            text.addListener((o, oldVal, newVal) -> refreshBadge());\n        }\n    }", "category": "Python"}, {"instruction": "Returns the Value Proto at 'fieldPath'. Returns null if the field was not found.", "input": "Java", "output": "@Nullable\n  Value extractField(@Nonnull FieldPath fieldPath) {\n    Value value = null;\n\n    if (fields != null) {\n      Iterator<String> components = fieldPath.getSegments().iterator();\n      value = fields.get(components.next());\n\n      while (value != null && components.hasNext()) {\n        if (value.getValueTypeCase() != Value.ValueTypeCase.MAP_VALUE) {\n          return null;\n        }\n        value = value.getMapValue().getFieldsOrDefault(components.next(), null);\n      }\n    }\n\n    return value;\n  }", "category": "Python"}, {"instruction": "Evaluation for multiple-output networks.<br>\nSee {@link #evaluate(MultiDataSetIterator, Map, Map)}", "input": "Java", "output": "public void evaluate(DataSetIterator iterator, Map<String,IEvaluation> variableEvals){\n        Map<String,Integer> map = new HashMap<>();\n        Map<String,List<IEvaluation>> variableEvalsList = new HashMap<>();\n        for(String s : variableEvals.keySet()){\n            map.put(s, 0);  //Only 1 possible output here with DataSetIterator\n            variableEvalsList.put(s, Collections.singletonList(variableEvals.get(s)));\n        }\n        evaluate(new MultiDataSetIteratorAdapter(iterator), variableEvalsList, map);\n    }", "category": "Python"}, {"instruction": "This method converts existing X509TrustManagers to ClientX509ExtendedTrustManagers.\n\n@param trustManagers\n@param tlsConfig\n@return", "input": "Java", "output": "public static TrustManager[] decorate(TrustManager[] trustManagers, TLSConfig tlsConfig) {\n\t\tif (null!=trustManagers && trustManagers.length>0) {\n\t\t\tTrustManager[] decoratedTrustManagers = new TrustManager[trustManagers.length];\n\t\t\t\n\t\t\tfor (int i=0; i<trustManagers.length; ++i) {\n\t\t\t\tTrustManager trustManager = trustManagers[i];\n\t\t\t\t\n\t\t\t\tif (trustManager instanceof X509TrustManager){\n\t\t\t\t\tdecoratedTrustManagers[i] = new ClientX509ExtendedTrustManager((X509TrustManager)trustManager, tlsConfig);\n\t\t\t\t}else {\n\t\t\t\t\tdecoratedTrustManagers[i] = trustManager;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn decoratedTrustManagers;\n\t\t}\n\t\t\n\t\treturn trustManagers;\n\t}", "category": "Python"}, {"instruction": "Convert a SQL search pattern into an equivalent Java Regex.\n\n@param pattern input which may contain '%' or '_' wildcard characters, or\nthese characters escaped using {@code getSearchStringEscape()}.\n@return replace %/_ with regex search characters, also handle escaped\ncharacters.", "input": "Java", "output": "public static String patternToRegex(String pattern) {\n    if (pattern == null) {\n      return \".*\";\n    } else {\n      StringBuilder result = new StringBuilder(pattern.length());\n\n      boolean escaped = false;\n      for (int i = 0, len = pattern.length(); i < len; i++) {\n        char c = pattern.charAt(i);\n        if (escaped) {\n          if (c != SEARCH_STRING_ESCAPE) {\n            escaped = false;\n          }\n          result.append(c);\n        } else {\n          if (c == SEARCH_STRING_ESCAPE) {\n            escaped = true;\n            continue;\n          } else if (c == '%') {\n            result.append(\".*\");\n          } else if (c == '_') {\n            result.append('.');\n          } else {\n            result.append(Character.toLowerCase(c));\n          }\n        }\n      }\n      return result.toString();\n    }\n  }", "category": "Python"}, {"instruction": "Exclusive buffer is recycled to this input channel directly and it may trigger return extra\nfloating buffer and notify increased credit to the producer.\n\n@param segment The exclusive segment of this channel.", "input": "Java", "output": "@Override\n\tpublic void recycle(MemorySegment segment) {\n\t\tint numAddedBuffers;\n\n\t\tsynchronized (bufferQueue) {\n\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n\t\t\t// after releaseAllResources() released all buffers (see below for details).\n\t\t\tif (isReleased.get()) {\n\t\t\t\ttry {\n\t\t\t\t\tinputGate.returnExclusiveSegments(Collections.singletonList(segment));\n\t\t\t\t\treturn;\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tExceptionUtils.rethrow(t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n\t\t}\n\n\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n\t\t\tnotifyCreditAvailable();\n\t\t}\n\t}", "category": "Python"}, {"instruction": "\u6bd4\u8f83\u4e24\u4e2a\u6587\u4ef6\u5185\u5bb9\u662f\u5426\u76f8\u540c<br>\n\u9996\u5148\u6bd4\u8f83\u957f\u5ea6\uff0c\u957f\u5ea6\u4e00\u81f4\u518d\u6bd4\u8f83\u5185\u5bb9\uff0c\u6bd4\u8f83\u5185\u5bb9\u91c7\u7528\u6309\u884c\u8bfb\u53d6\uff0c\u6bcf\u884c\u6bd4\u8f83<br>\n\u6b64\u65b9\u6cd5\u6765\u81eaApache Commons io\n\n@param file1 \u6587\u4ef61\n@param file2 \u6587\u4ef62\n@param charset \u7f16\u7801\uff0cnull\u8868\u793a\u4f7f\u7528\u5e73\u53f0\u9ed8\u8ba4\u7f16\u7801 \u4e24\u4e2a\u6587\u4ef6\u5185\u5bb9\u4e00\u81f4\u8fd4\u56detrue\uff0c\u5426\u5219false\n@throws IORuntimeException IO\u5f02\u5e38\n@since 4.0.6", "input": "Java", "output": "public static boolean contentEqualsIgnoreEOL(File file1, File file2, Charset charset) throws IORuntimeException {\r\n\t\tboolean file1Exists = file1.exists();\r\n\t\tif (file1Exists != file2.exists()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (!file1Exists) {\r\n\t\t\t// \u4e24\u4e2a\u6587\u4ef6\u90fd\u4e0d\u5b58\u5728\uff0c\u8fd4\u56detrue\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (file1.isDirectory() || file2.isDirectory()) {\r\n\t\t\t// \u4e0d\u6bd4\u8f83\u76ee\u5f55\r\n\t\t\tthrow new IORuntimeException(\"Can't compare directories, only files\");\r\n\t\t}\r\n\r\n\t\tif (equals(file1, file2)) {\r\n\t\t\t// \u540c\u4e00\u4e2a\u6587\u4ef6\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tReader input1 = null;\r\n\t\tReader input2 = null;\r\n\t\ttry {\r\n\t\t\tinput1 = getReader(file1, charset);\r\n\t\t\tinput2 = getReader(file2, charset);\r\n\t\t\treturn IoUtil.contentEqualsIgnoreEOL(input1, input2);\r\n\t\t} finally {\r\n\t\t\tIoUtil.close(input1);\r\n\t\t\tIoUtil.close(input2);\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "region AbstractService Implementation", "input": "Java", "output": "@Override\n    protected void doStart() {\n        log.info(\"{}: Starting.\", this.traceObjectId);\n\n        Services.startAsync(this.durableLog, this.executor)\n                .thenComposeAsync(v -> startWhenDurableLogOnline(), this.executor)\n                .whenComplete((v, ex) -> {\n                    if (ex == null) {\n                        // We are started and ready to accept requests when DurableLog starts. All other (secondary) services\n                        // are not required for accepting new operations and can still start in the background.\n                        notifyStarted();\n                    } else {\n                        doStop(ex);\n                    }\n                });\n    }", "category": "Python"}, {"instruction": "Create generate service ticket action.\n\n@param flow the flow", "input": "Java", "output": "protected void createGenerateServiceTicketAction(final Flow flow) {\n        val handler = createActionState(flow,\n            CasWebflowConstants.STATE_ID_GENERATE_SERVICE_TICKET,\n            createEvaluateAction(CasWebflowConstants.ACTION_ID_GENERATE_SERVICE_TICKET));\n        createTransitionForState(handler, CasWebflowConstants.TRANSITION_ID_SUCCESS, CasWebflowConstants.STATE_ID_REDIRECT);\n        createTransitionForState(handler, CasWebflowConstants.TRANSITION_ID_WARN, CasWebflowConstants.STATE_ID_WARN);\n        createTransitionForState(handler, CasWebflowConstants.TRANSITION_ID_AUTHENTICATION_FAILURE, CasWebflowConstants.STATE_ID_HANDLE_AUTHN_FAILURE);\n        createTransitionForState(handler, CasWebflowConstants.TRANSITION_ID_ERROR, CasWebflowConstants.STATE_ID_INIT_LOGIN_FORM);\n        createTransitionForState(handler, CasWebflowConstants.TRANSITION_ID_GATEWAY, CasWebflowConstants.STATE_ID_GATEWAY_SERVICES_MGMT_CHECK);\n    }", "category": "Python"}, {"instruction": "Internal method that sets a variable without validating the script name.\n\n@param scriptName the name of the script.\n@param key the key of the variable.\n@param value the value of the variable.", "input": "Java", "output": "private static void setScriptVarImpl(String scriptName, String key, String value) {\t\n\t\tvalidateKey(key);\n\t\t\n\t\tMap<String, String> scVars = scriptVars\n\t\t\t\t.computeIfAbsent(scriptName, k -> Collections.synchronizedMap(new HashMap<String, String>()));\n\t\t\n\t\tif (value == null) {\n\t\t\tscVars.remove(key);\n\t\t} else {\n\t\t\tvalidateValueLength(value);\n\t\t\tif (scVars.size() > MAX_SCRIPT_VARS) {\n\t\t\t\tthrow new IllegalArgumentException(\"Maximum number of script variables reached: \" + MAX_SCRIPT_VARS);\n\t\t\t}\n\t\t\tscVars.put(key, value);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "{@inheritDoc}", "input": "Java", "output": "@Override\n    public double f1Score(INDArray examples, INDArray labels) {\n        if (examples.rank() == 3)\n            examples = TimeSeriesUtils.reshape3dTo2d(examples, LayerWorkspaceMgr.noWorkspaces(), ArrayType.ACTIVATIONS);\n        if (labels.rank() == 3)\n            labels = TimeSeriesUtils.reshape3dTo2d(labels, LayerWorkspaceMgr.noWorkspaces(), ArrayType.ACTIVATIONS);\n        return super.f1Score(examples, labels);\n    }", "category": "Python"}, {"instruction": "Process one training row at a time (online learning)\n@param seed Seed is only used if reproducible mode is enabled\n@param r Row (must be dense for now)\n@param mb mini-batch internal index", "input": "Java", "output": "@Override public final void processRow(long seed, DataInfo.Row r, int mb) {\n    if (_localmodel.get_params()._reproducible) {\n      seed += _localmodel.get_processed_global(); //avoid periodicity\n    } else {\n      seed = _dropout_rng.nextLong(); // non-reproducible case - make a fast & good random number\n    }\n    _localmodel.checkMissingCats(r.binIds);\n    ((Neurons.Input) _neurons[0]).setInput(seed, r.isSparse() ? r.numIds : null, r.numVals, r.nBins, r.binIds, mb);\n  }", "category": "Python"}, {"instruction": "\u751f\u6210\u4e0d\u91cd\u590d\u968f\u673a\u6570 \u6839\u636e\u7ed9\u5b9a\u7684\u6700\u5c0f\u6570\u5b57\u548c\u6700\u5927\u6570\u5b57\uff0c\u4ee5\u53ca\u968f\u673a\u6570\u7684\u4e2a\u6570\uff0c\u4ea7\u751f\u6307\u5b9a\u7684\u4e0d\u91cd\u590d\u7684\u6570\u7ec4\n\n@param begin \u6700\u5c0f\u6570\u5b57\uff08\u5305\u542b\u8be5\u6570\uff09\n@param end \u6700\u5927\u6570\u5b57\uff08\u4e0d\u5305\u542b\u8be5\u6570\uff09\n@param size \u6307\u5b9a\u4ea7\u751f\u968f\u673a\u6570\u7684\u4e2a\u6570\n@return \u968f\u673aint\u6570\u7ec4", "input": "Java", "output": "public static int[] generateRandomNumber(int begin, int end, int size) {\r\n\t\tif (begin > end) {\r\n\t\t\tint temp = begin;\r\n\t\t\tbegin = end;\r\n\t\t\tend = temp;\r\n\t\t}\r\n\t\t// \u52a0\u5165\u903b\u8f91\u5224\u65ad\uff0c\u786e\u4fddbegin<end\u5e76\u4e14size\u4e0d\u80fd\u5927\u4e8e\u8be5\u8868\u793a\u8303\u56f4\r\n\t\tif ((end - begin) < size) {\r\n\t\t\tthrow new UtilException(\"Size is larger than range between begin and end!\");\r\n\t\t}\r\n\t\t// \u79cd\u5b50\u4f60\u53ef\u4ee5\u968f\u610f\u751f\u6210\uff0c\u4f46\u4e0d\u80fd\u91cd\u590d\r\n\t\tint[] seed = new int[end - begin];\r\n\r\n\t\tfor (int i = begin; i < end; i++) {\r\n\t\t\tseed[i - begin] = i;\r\n\t\t}\r\n\t\tint[] ranArr = new int[size];\r\n\t\tRandom ran = new Random();\r\n\t\t// \u6570\u91cf\u4f60\u53ef\u4ee5\u81ea\u5df1\u5b9a\u4e49\u3002\r\n\t\tfor (int i = 0; i < size; i++) {\r\n\t\t\t// \u5f97\u5230\u4e00\u4e2a\u4f4d\u7f6e\r\n\t\t\tint j = ran.nextInt(seed.length - i);\r\n\t\t\t// \u5f97\u5230\u90a3\u4e2a\u4f4d\u7f6e\u7684\u6570\u503c\r\n\t\t\tranArr[i] = seed[j];\r\n\t\t\t// \u5c06\u6700\u540e\u4e00\u4e2a\u672a\u7528\u7684\u6570\u5b57\u653e\u5230\u8fd9\u91cc\r\n\t\t\tseed[j] = seed[seed.length - 1 - i];\r\n\t\t}\r\n\t\treturn ranArr;\r\n\t}", "category": "Python"}, {"instruction": "Example of how to enable default event-based hold for a bucket", "input": "Java", "output": "public Bucket enableDefaultEventBasedHold(String bucketName) throws StorageException {\n    // [START storage_enable_default_event_based_hold]\n    // Instantiate a Google Cloud Storage client\n    Storage storage = StorageOptions.getDefaultInstance().getService();\n\n    // The name of a bucket, e.g. \"my-bucket\"\n    // String bucketName = \"my-bucket\";\n\n    Bucket bucket =\n        storage.update(BucketInfo.newBuilder(bucketName).setDefaultEventBasedHold(true).build());\n\n    System.out.println(\"Default event-based hold was enabled for \" + bucketName);\n    // [END storage_enable_default_event_based_hold]\n    return bucket;\n  }", "category": "Python"}, {"instruction": "Populates the task input from external payload storage if the external storage path is specified.\n\n@param task the task for which the input is to be populated.", "input": "Java", "output": "private void populateTaskInput(Task task) {\n        if (StringUtils.isNotBlank(task.getExternalInputPayloadStoragePath())) {\n            WorkflowTaskMetrics.incrementExternalPayloadUsedCount(task.getTaskDefName(), ExternalPayloadStorage.Operation.READ.name(), ExternalPayloadStorage.PayloadType.TASK_INPUT.name());\n            task.setInputData(downloadFromExternalStorage(ExternalPayloadStorage.PayloadType.TASK_INPUT, task.getExternalInputPayloadStoragePath()));\n            task.setExternalInputPayloadStoragePath(null);\n        }\n    }", "category": "Python"}, {"instruction": "This method initializes chkProxyChainAuth\n\n@return javax.swing.JCheckBox", "input": "Java", "output": "private JCheckBox getChkProxyChainAuth() {\r\n\t\tif (chkProxyChainAuth == null) {\r\n\t\t\tchkProxyChainAuth = new JCheckBox();\r\n\t\t\tchkProxyChainAuth.setText(Constant.messages.getString(\"conn.options.proxy.auth.required\"));\r\n\t\t\tchkProxyChainAuth.addActionListener(new java.awt.event.ActionListener() { \r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void actionPerformed(java.awt.event.ActionEvent e) {    \r\n\r\n\t\t\t\t\tsetProxyChainAuthEnabled(chkProxyChainAuth.isSelected());\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\treturn chkProxyChainAuth;\r\n\t}", "category": "Python"}, {"instruction": "Parse the from clause\nzhongshu-comment \u53ea\u89e3\u6790\u4e86\u4e00\u822c\u67e5\u8be2\u548cjoin\u67e5\u8be2\uff0c\u6ca1\u6709\u89e3\u6790\u5b50\u67e5\u8be2\n@param from the from clause.\n@return list of From objects represents all the sources.", "input": "Java", "output": "private List<From> findFrom(SQLTableSource from) {\n        //zhongshu-comment class1.isAssignableFrom(class2) class2\u662f\u4e0d\u662fclass1\u7684\u5b50\u7c7b\u6216\u8005\u5b50\u63a5\u53e3\n        //\u6539\u6210\u7528instanceof \u5e94\u8be5\u4e5f\u884c\u5427\uff1afrom instanceof SQLExprTableSource\n        boolean isSqlExprTable = from.getClass().isAssignableFrom(SQLExprTableSource.class);\n\n        if (isSqlExprTable) {\n            SQLExprTableSource fromExpr = (SQLExprTableSource) from;\n            String[] split = fromExpr.getExpr().toString().split(\",\");\n\n            ArrayList<From> fromList = new ArrayList<>();\n            for (String source : split) {\n                fromList.add(new From(source.trim(), fromExpr.getAlias()));\n            }\n            return fromList;\n        }\n\n        SQLJoinTableSource joinTableSource = ((SQLJoinTableSource) from);\n        List<From> fromList = new ArrayList<>();\n        fromList.addAll(findFrom(joinTableSource.getLeft()));\n        fromList.addAll(findFrom(joinTableSource.getRight()));\n        return fromList;\n    }", "category": "Python"}, {"instruction": "\u6784\u9020Cluster\u5bf9\u8c61\n\n@param consumerBootstrap \u5ba2\u6237\u7aef\u914d\u7f6e\n@return Cluster\u5bf9\u8c61", "input": "Java", "output": "public static Cluster getCluster(ConsumerBootstrap consumerBootstrap) {\n        try {\n            ConsumerConfig consumerConfig = consumerBootstrap.getConsumerConfig();\n            ExtensionClass<Cluster> ext = ExtensionLoaderFactory.getExtensionLoader(Cluster.class)\n                .getExtensionClass(consumerConfig.getCluster());\n            if (ext == null) {\n                throw ExceptionUtils.buildRuntime(\"consumer.cluster\",\n                    consumerConfig.getCluster(), \"Unsupported cluster of client!\");\n            }\n            return ext.getExtInstance(new Class[] { ConsumerBootstrap.class },\n                new Object[] { consumerBootstrap });\n        } catch (SofaRpcRuntimeException e) {\n            throw e;\n        } catch (Throwable e) {\n            throw new SofaRpcRuntimeException(e.getMessage(), e);\n        }\n    }", "category": "Python"}, {"instruction": "Reverses the migration, in case you want to revert to the older format.\n@param args one parameter, {@code $JENKINS_HOME}", "input": "Java", "output": "public static void main(String... args) throws Exception {\n        if (args.length != 1) {\n            throw new Exception(\"pass one parameter, $JENKINS_HOME\");\n        }\n        File root = new File(args[0]);\n        File jobs = new File(root, \"jobs\");\n        if (!jobs.isDirectory()) {\n            throw new FileNotFoundException(\"no such $JENKINS_HOME \" + root);\n        }\n        new RunIdMigrator().unmigrateJobsDir(jobs);\n    }", "category": "Python"}, {"instruction": "Is cas authentication available?\n\n@param context the context\n@return the optional authn", "input": "Java", "output": "public Optional<Authentication> isCasAuthenticationAvailable(final WebContext context) {\n        val j2EContext = (J2EContext) context;\n        if (j2EContext != null) {\n            val tgtId = ticketGrantingTicketCookieGenerator.retrieveCookieValue(j2EContext.getRequest());\n\n            if (StringUtils.isNotBlank(tgtId)) {\n                val authentication = ticketRegistrySupport.getAuthenticationFrom(tgtId);\n                if (authentication != null) {\n                    return Optional.of(authentication);\n                }\n            }\n        }\n        return Optional.empty();\n    }", "category": "Python"}, {"instruction": "Get the cacheKeys of all the ASG to which query AWS for.\n\n<p>\nThe names are obtained from the {@link com.netflix.eureka.registry.InstanceRegistry} which is then\nused for querying the AWS.\n</p>\n\n@return the set of ASG cacheKeys (asgName + accountId).", "input": "Java", "output": "private Set<CacheKey> getCacheKeys() {\n        Set<CacheKey> cacheKeys = new HashSet<CacheKey>();\n        Applications apps = registry.getApplicationsFromLocalRegionOnly();\n        for (Application app : apps.getRegisteredApplications()) {\n            for (InstanceInfo instanceInfo : app.getInstances()) {\n                String localAccountId = getAccountId(instanceInfo, accountId);\n                String asgName = instanceInfo.getASGName();\n                if (asgName != null) {\n                    CacheKey key = new CacheKey(localAccountId, asgName);\n                    cacheKeys.add(key);\n                }\n            }\n        }\n\n        return cacheKeys;\n    }", "category": "Python"}, {"instruction": "\u8fc7\u6ee4<br>\n\u8fc7\u6ee4\u8fc7\u7a0b\u901a\u8fc7\u4f20\u5165\u7684Filter\u5b9e\u73b0\u6765\u8fc7\u6ee4\u8fd4\u56de\u9700\u8981\u7684\u5143\u7d20\u5185\u5bb9\uff0c\u8fd9\u4e2aFilter\u5b9e\u73b0\u53ef\u4ee5\u5b9e\u73b0\u4ee5\u4e0b\u529f\u80fd\uff1a\n\n<pre>\n1\u3001\u8fc7\u6ee4\u51fa\u9700\u8981\u7684\u5bf9\u8c61\uff0c{@link Filter#accept(Object)}\u65b9\u6cd5\u8fd4\u56detrue\u7684\u5bf9\u8c61\u5c06\u88ab\u52a0\u5165\u7ed3\u679c\u96c6\u5408\u4e2d\n</pre>\n\n@param <T> \u96c6\u5408\u5143\u7d20\u7c7b\u578b\n@param collection \u96c6\u5408\n@param filter \u8fc7\u6ee4\u5668\n@return \u8fc7\u6ee4\u540e\u7684\u6570\u7ec4\n@since 3.1.0", "input": "Java", "output": "public static <T> Collection<T> filter(Collection<T> collection, Filter<T> filter) {\r\n\t\tif (null == collection || null == filter) {\r\n\t\t\treturn collection;\r\n\t\t}\r\n\r\n\t\tCollection<T> collection2 = ObjectUtil.clone(collection);\r\n\t\ttry {\r\n\t\t\tcollection2.clear();\r\n\t\t} catch (UnsupportedOperationException e) {\r\n\t\t\t// \u514b\u9686\u540e\u7684\u5bf9\u8c61\u4e0d\u652f\u6301\u6e05\u7a7a\uff0c\u8bf4\u660e\u4e3a\u4e0d\u53ef\u53d8\u96c6\u5408\u5bf9\u8c61\uff0c\u4f7f\u7528\u9ed8\u8ba4\u7684ArrayList\u4fdd\u5b58\u7ed3\u679c\r\n\t\t\tcollection2 = new ArrayList<>();\r\n\t\t}\r\n\r\n\t\tfor (T t : collection) {\r\n\t\t\tif (filter.accept(t)) {\r\n\t\t\t\tcollection2.add(t);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn collection2;\r\n\t}", "category": "Python"}, {"instruction": "Create a new event handler group that combines the consumers in this group with <code>otherHandlerGroup</code>.\n\n@param otherHandlerGroup the event handler group to combine.\n@return a new EventHandlerGroup combining the existing and new consumers into a single dependency group.", "input": "Java", "output": "public EventHandlerGroup<T> and(final EventHandlerGroup<T> otherHandlerGroup)\n    {\n        final Sequence[] combinedSequences = new Sequence[this.sequences.length + otherHandlerGroup.sequences.length];\n        System.arraycopy(this.sequences, 0, combinedSequences, 0, this.sequences.length);\n        System.arraycopy(\n            otherHandlerGroup.sequences, 0,\n            combinedSequences, this.sequences.length, otherHandlerGroup.sequences.length);\n        return new EventHandlerGroup<>(disruptor, consumerRepository, combinedSequences);\n    }", "category": "Python"}, {"instruction": "Returns the textual representations of the running issues (Java version and dependency) of the extensions of hte add-on,\nif any.\n<p>\nThe messages are internationalised thus suitable for UI components.\n\n@param requirements the run requirements of the add-on, whose extensions' run requirements will be used\n@param addOnSearcher the class responsible for searching add-ons with a given id, used to search for add-ons that are\nmissing for the add-on\n@return a {@code List} containing all the running issues of the add-on, empty if none\n@see #getRunningIssues(AddOn.BaseRunRequirements)\n@see #getUiExtensionsRunningIssues(AddOn.AddOnRunRequirements, AddOnSearcher)", "input": "Java", "output": "public static List<String> getUiExtensionsRunningIssues(AddOn.AddOnRunRequirements requirements, AddOnSearcher addOnSearcher) {\n        if (!requirements.hasExtensionsWithRunningIssues()) {\n            return new ArrayList<>(0);\n        }\n\n        List<String> issues = new ArrayList<>(10);\n        for (AddOn.ExtensionRunRequirements extReqs : requirements.getExtensionRequirements()) {\n            issues.addAll(getUiRunningIssues(extReqs, addOnSearcher));\n        }\n        return issues;\n    }", "category": "Python"}, {"instruction": "\u89e3\u5bc6\n\n@param data SM2\u5bc6\u6587\uff0c\u5b9e\u9645\u5305\u542b\u4e09\u90e8\u5206\uff1aECC\u516c\u94a5\u3001\u771f\u6b63\u7684\u5bc6\u6587\u3001\u516c\u94a5\u548c\u539f\u6587\u7684SM3-HASH\u503c\n@param keyType \u79c1\u94a5\u6216\u516c\u94a5 {@link KeyType}\n@return \u52a0\u5bc6\u540e\u7684bytes\n@throws CryptoException \u5305\u62ecInvalidKeyException\u548cInvalidCipherTextException\u7684\u5305\u88c5\u5f02\u5e38", "input": "Java", "output": "@Override\r\n\tpublic byte[] decrypt(byte[] data, KeyType keyType) throws CryptoException {\r\n\t\tif (KeyType.PrivateKey != keyType) {\r\n\t\t\tthrow new IllegalArgumentException(\"Decrypt is only support by private key\");\r\n\t\t}\r\n\t\tckeckKey(keyType);\r\n\r\n\t\tlock.lock();\r\n\t\tfinal SM2Engine engine = getEngine();\r\n\t\ttry {\r\n\t\t\tengine.init(false, getCipherParameters(keyType));\r\n\t\t\treturn engine.processBlock(data, 0, data.length);\r\n\t\t} finally {\r\n\t\t\tlock.unlock();\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "/*\n(non-Javadoc)\n@see java.util.Map#containsValue(java.lang.Object)", "input": "Java", "output": "@Override\n    public boolean containsValue(Object value) {\n        if (value == null) {\n            throw new NullPointerException();\n        }\n\n        for (Map.Entry<K, CachedValue<K, V>> entry : map.entrySet()) {\n            CachedValue<K, V> cachedValue = entry.getValue();\n            if (cachedValue.getValue().equals(value)) {\n                if (isValueExpired(cachedValue)) {\n                    if (map.remove(cachedValue.getKey(), cachedValue)) {\n                        onValueRemove(cachedValue);\n                    }\n                } else {\n                    readValue(cachedValue);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }", "category": "Python"}, {"instruction": "Removes the field at the given position.\n<p>\nThis method should be used carefully. Be aware that as the field is actually removed from the record, the\ntotal number of fields is modified, and all fields to the right of the field removed shift one position to\nthe left.\n\n@param fieldNum The position of the field to be removed, starting at zero.\n@throws IndexOutOfBoundsException Thrown, when the position is not between 0 (inclusive) and the\nnumber of fields (exclusive).", "input": "Java", "output": "public void removeField(int fieldNum)\n\t{\n\t\t// range check\n\t\tif (fieldNum < 0 || fieldNum >= this.numFields) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tint lastIndex = this.numFields - 1;\t\t\n\n\t\tif (fieldNum < lastIndex) {\n\t\t\tint len = lastIndex - fieldNum;\n\t\t\tSystem.arraycopy(this.offsets, fieldNum + 1, this.offsets, fieldNum, len);\n\t\t\tSystem.arraycopy(this.lengths, fieldNum + 1, this.lengths, fieldNum, len);\n\t\t\tSystem.arraycopy(this.readFields, fieldNum + 1, this.readFields, fieldNum, len);\n\t\t\tSystem.arraycopy(this.writeFields, fieldNum + 1, this.writeFields, fieldNum, len);\n\t\t\tmarkModified(fieldNum);\n\t\t}\n\t\tthis.offsets[lastIndex] = NULL_INDICATOR_OFFSET;\n\t\tthis.lengths[lastIndex] = 0;\n\t\tthis.writeFields[lastIndex] = null;\n\n\t\tsetNumFields(lastIndex);\n\t}", "category": "Python"}, {"instruction": "Gets all.\n\n@return the all", "input": "Java", "output": "public List<RegisteredService> getAll() {\n        val scan = new ScanRequest(dynamoDbProperties.getTableName());\n        LOGGER.debug(\"Scanning table with request [{}]\", scan);\n        val result = this.amazonDynamoDBClient.scan(scan);\n        LOGGER.debug(\"Scanned table with result [{}]\", scan);\n        return result.getItems()\n            .stream()\n            .map(this::deserializeServiceFromBinaryBlob)\n            .filter(Objects::nonNull)\n            .sorted(Comparator.comparingInt(RegisteredService::getEvaluationOrder))\n            .collect(Collectors.toList());\n    }", "category": "Python"}, {"instruction": "Gets the new session button.\n\n@return the new session button", "input": "Java", "output": "private JButton getNewSessionButton() {\r\n\t\tif (newSessionButton == null) {\r\n\t\t\tnewSessionButton = new JButton();\r\n\t\t\tnewSessionButton.setText(Constant.messages.getString(\"httpsessions.toolbar.newsession.label\"));\r\n\t\t\tnewSessionButton.setIcon(DisplayUtils.getScaledIcon(new ImageIcon(HttpSessionsPanel.class.getResource(\"/resource/icon/16/103.png\"))));\r\n\t\t\tnewSessionButton.setToolTipText(Constant.messages.getString(\"httpsessions.toolbar.newsession.tooltip\"));\r\n\r\n\t\t\tnewSessionButton.addActionListener(new ActionListener() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\r\n\t\t\t\t\tHttpSessionsSite site = getCurrentHttpSessionSite();\r\n\t\t\t\t\tif (site != null) {\r\n\t\t\t\t\t\tsite.createEmptySession();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\treturn newSessionButton;\r\n\t}", "category": "Python"}, {"instruction": "Make a TypeVariableName for the given TypeMirror. This form is used internally to avoid\ninfinite recursion in cases like {@code Enum<E extends Enum<E>>}. When we encounter such a\nthing, we will make a TypeVariableName without bounds and add that to the {@code typeVariables}\nmap before looking up the bounds. Then if we encounter this TypeVariable again while\nconstructing the bounds, we can just return it from the map. And, the code that put the entry\nin {@code variables} will make sure that the bounds are filled in before returning.", "input": "Java", "output": "static TypeVariableName get(\n      TypeVariable mirror, Map<TypeParameterElement, TypeVariableName> typeVariables) {\n    TypeParameterElement element = (TypeParameterElement) mirror.asElement();\n    TypeVariableName typeVariableName = typeVariables.get(element);\n    if (typeVariableName == null) {\n      // Since the bounds field is public, we need to make it an unmodifiableList. But we control\n      // the List that that wraps, which means we can change it before returning.\n      List<TypeName> bounds = new ArrayList<>();\n      List<TypeName> visibleBounds = Collections.unmodifiableList(bounds);\n      typeVariableName = new TypeVariableName(element.getSimpleName().toString(), visibleBounds);\n      typeVariables.put(element, typeVariableName);\n      for (TypeMirror typeMirror : element.getBounds()) {\n        bounds.add(TypeName.get(typeMirror, typeVariables));\n      }\n      bounds.remove(OBJECT);\n    }\n    return typeVariableName;\n  }", "category": "Python"}, {"instruction": "Finds an available TCP port.\n\n@param minPortRange The minimum port range\n@param maxPortRange The maximum port range\n@return The available port", "input": "Java", "output": "public static int findAvailableTcpPort(int minPortRange, int maxPortRange) {\n        ArgumentUtils.check(() -> minPortRange > MIN_PORT_RANGE)\n            .orElseFail(\"Port minimum value must be greater than \" + MIN_PORT_RANGE);\n        ArgumentUtils.check(() -> maxPortRange >= minPortRange)\n            .orElseFail(\"Max port range must be greater than minimum port range\");\n        ArgumentUtils.check(() -> maxPortRange <= MAX_PORT_RANGE)\n            .orElseFail(\"Port maximum value must be less than \" + MAX_PORT_RANGE);\n\n        int currentPort = nextPort(minPortRange, maxPortRange);\n        while (!isTcpPortAvailable(currentPort)) {\n            currentPort = nextPort(minPortRange, maxPortRange);\n        }\n        return currentPort;\n    }", "category": "Python"}, {"instruction": "TODO: make protected on a minor release", "input": "Java", "output": "byte[] writeAndClose(byte[] payload, StreamWrapper wrapper) throws IOException {\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream(512);\n        OutputStream compressionStream = wrapper.wrap(outputStream);\n        try {\n            compressionStream.write(payload);\n            compressionStream.flush();\n        } finally {\n            Objects.nullSafeClose(compressionStream);\n        }\n        return outputStream.toByteArray();\n    }", "category": "Python"}, {"instruction": "Applies Givens rotation to sparse vectors one of which is in compressed form.\n\n@param N The number of elements in vectors X and Y\n@param X a sparse vector\n@param Y a full-storage vector\n@param c a scalar\n@param s a scalar", "input": "Java", "output": "@Override\n    public void rot(long N, INDArray X, INDArray Y, double c, double s) {\n\n\n        if (X instanceof BaseSparseNDArray) {\n            BaseSparseNDArray sparseX = (BaseSparseNDArray) X;\n\n            switch (X.data().dataType()) {\n                case DOUBLE:\n                    droti(N, X, sparseX.getVectorCoordinates(), Y, c, s);\n                    break;\n                case FLOAT:\n                    sroti(N, X, sparseX.getVectorCoordinates(), Y, c, s);\n                    break;\n                case HALF:\n                    hroti(N, X, sparseX.getVectorCoordinates(), Y, c, s);\n                    break;\n                default:\n                    throw new UnsupportedOperationException();\n            }\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }", "category": "Python"}, {"instruction": "Authenticate ecp request.\n\n@param credential   the credential\n@param authnRequest the authn request\n@return the authentication", "input": "Java", "output": "protected Authentication authenticateEcpRequest(final Credential credential,\n                                                    final Pair<AuthnRequest, MessageContext> authnRequest) {\n        val issuer = SamlIdPUtils.getIssuerFromSamlObject(authnRequest.getKey());\n        LOGGER.debug(\"Located issuer [{}] from request prior to authenticating [{}]\", issuer, credential.getId());\n\n        val service = getSamlProfileHandlerConfigurationContext().getWebApplicationServiceFactory().createService(issuer);\n        LOGGER.debug(\"Executing authentication request for service [{}] on behalf of credential id [{}]\", service, credential.getId());\n        val authenticationResult = getSamlProfileHandlerConfigurationContext()\n            .getAuthenticationSystemSupport().handleAndFinalizeSingleAuthenticationTransaction(service, credential);\n        return authenticationResult.getAuthentication();\n    }", "category": "Python"}, {"instruction": "Register spider for monitor.\n\n@param spiders spiders\n@return this\n@throws JMException JMException", "input": "Java", "output": "public synchronized SpiderMonitor register(Spider... spiders) throws JMException {\n        for (Spider spider : spiders) {\n            MonitorSpiderListener monitorSpiderListener = new MonitorSpiderListener();\n            if (spider.getSpiderListeners() == null) {\n                List<SpiderListener> spiderListeners = new ArrayList<SpiderListener>();\n                spiderListeners.add(monitorSpiderListener);\n                spider.setSpiderListeners(spiderListeners);\n            } else {\n                spider.getSpiderListeners().add(monitorSpiderListener);\n            }\n            SpiderStatusMXBean spiderStatusMBean = getSpiderStatusMBean(spider, monitorSpiderListener);\n            registerMBean(spiderStatusMBean);\n            spiderStatuses.add(spiderStatusMBean);\n        }\n        return this;\n    }", "category": "Python"}, {"instruction": "Create a {@link ConfigurationPropertyName} by adapting the given source. The name\nis split into elements around the given {@code separator}. This method is more\nlenient than {@link #of} in that it allows mixed case names and '{@code _}'\ncharacters. Other invalid characters are stripped out during parsing.\n<p>\nThe {@code elementValueProcessor} function may be used if additional processing is\nrequired on the extracted element values.\n@param name the name to parse\n@param separator the separator used to split the name\n@param elementValueProcessor a function to process element values\n@return a {@link ConfigurationPropertyName}", "input": "Java", "output": "static ConfigurationPropertyName adapt(CharSequence name, char separator,\n\t\t\tFunction<CharSequence, CharSequence> elementValueProcessor) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tif (name.length() == 0) {\n\t\t\treturn EMPTY;\n\t\t}\n\t\tElements elements = new ElementsParser(name, separator)\n\t\t\t\t.parse(elementValueProcessor);\n\t\tif (elements.getSize() == 0) {\n\t\t\treturn EMPTY;\n\t\t}\n\t\treturn new ConfigurationPropertyName(elements);\n\t}", "category": "Python"}, {"instruction": "Returns whether the system needs a restart, and if it is supported\ne.g. { restartRequired: true, restartSupported: false }", "input": "Java", "output": "@Restricted(DoNotUse.class) // WebOnly\n    public HttpResponse doRestartStatus() throws IOException {\n        JSONObject response = new JSONObject();\n        Jenkins jenkins = Jenkins.get();\n        response.put(\"restartRequired\", jenkins.getUpdateCenter().isRestartRequiredForCompletion());\n        response.put(\"restartSupported\", jenkins.getLifecycle().canRestart());\n        return HttpResponses.okJSON(response);\n    }", "category": "Python"}, {"instruction": "Mask the input string with a list of patterns indexed by key in string section in mask.json\nThis is usually used to mask header values, query parameters and uri parameters\n\n@param input String The source of the string that needs to be masked\n@param key   String The key that maps to a list of patterns for masking in config file\n@return Masked result", "input": "Java", "output": "public static String maskString(String input, String key) {\n        String output = input;\n        Map<String, Object> stringConfig = (Map<String, Object>) config.get(MASK_TYPE_STRING);\n        if (stringConfig != null) {\n            Map<String, Object> keyConfig = (Map<String, Object>) stringConfig.get(key);\n            if (keyConfig != null) {\n                Set<String> patterns = keyConfig.keySet();\n                for (String pattern : patterns) {\n                    output = output.replaceAll(pattern, (String) keyConfig.get(pattern));\n                }\n            }\n        }\n        return output;\n    }", "category": "Python"}, {"instruction": "This method uses locks because it can be used during indexing,\nand Druid can call aggregate() and get() concurrently\nhttps://github.com/apache/incubator-druid/pull/3956", "input": "Java", "output": "@Override\n  public void aggregate(final ByteBuffer buf, final int position)\n  {\n    final ArrayOfDoublesSketch update = selector.getObject();\n    if (update == null) {\n      return;\n    }\n    // Wrapping memory and ArrayOfDoublesUnion is inexpensive compared to union operations.\n    // Maintaining a cache of wrapped objects per buffer position like in Theta sketch aggregator\n    // might might be considered, but it would increase complexity including relocate() support.\n    final WritableMemory mem = WritableMemory.wrap(buf, ByteOrder.LITTLE_ENDIAN);\n    final WritableMemory region = mem.writableRegion(position, maxIntermediateSize);\n    final Lock lock = stripedLock.getAt(ArrayOfDoublesSketchBuildBufferAggregator.lockIndex(position)).writeLock();\n    lock.lock();\n    try {\n      final ArrayOfDoublesUnion union = ArrayOfDoublesSketches.wrapUnion(region);\n      union.update(update);\n    }\n    finally {\n      lock.unlock();\n    }\n  }", "category": "Python"}, {"instruction": "\u8f6c\u6362\u4e3a\u5206\u9875\u8bed\u53e5\n\n@param sql\n@param offset\n@param limit\n@return", "input": "Java", "output": "public String convertToPageSql(String sql, Integer offset, Integer limit) {\n        //\u89e3\u6790SQL\n        Statement stmt;\n        try {\n            stmt = CCJSqlParserUtil.parse(sql);\n        } catch (Throwable e) {\n            throw new PageException(\"\u4e0d\u652f\u6301\u8be5SQL\u8f6c\u6362\u4e3a\u5206\u9875\u67e5\u8be2!\", e);\n        }\n        if (!(stmt instanceof Select)) {\n            throw new PageException(\"\u5206\u9875\u8bed\u53e5\u5fc5\u987b\u662fSelect\u67e5\u8be2!\");\n        }\n        //\u83b7\u53d6\u5206\u9875\u67e5\u8be2\u7684select\n        Select pageSelect = getPageSelect((Select) stmt);\n        String pageSql = pageSelect.toString();\n        //\u7f13\u5b58\u79fb\u5230\u5916\u9762\u4e86\uff0c\u6240\u4ee5\u4e0d\u66ff\u6362\u53c2\u6570\n        if (offset != null) {\n            pageSql = pageSql.replace(START_ROW, String.valueOf(offset));\n        }\n        if (limit != null) {\n            pageSql = pageSql.replace(PAGE_SIZE, String.valueOf(limit));\n        }\n        return pageSql;\n    }", "category": "Python"}, {"instruction": "sm3\u8ba1\u7b97\u540e\u8fdb\u884c16\u8fdb\u5236\u8f6c\u6362\n\n@param data\n\u5f85\u8ba1\u7b97\u7684\u6570\u636e\n@param encoding\n\u7f16\u7801\n@return \u8ba1\u7b97\u7ed3\u679c", "input": "Java", "output": "public static String sm3X16Str(String data, String encoding) {\n\t\tbyte[] bytes = sm3(data, encoding);\n\t\tStringBuilder sm3StrBuff = new StringBuilder();\n\t\tfor (int i = 0; i < bytes.length; i++) {\n\t\t\tif (Integer.toHexString(0xFF & bytes[i]).length() == 1) {\n\t\t\t\tsm3StrBuff.append(\"0\").append(\n\t\t\t\t\t\tInteger.toHexString(0xFF & bytes[i]));\n\t\t\t} else {\n\t\t\t\tsm3StrBuff.append(Integer.toHexString(0xFF & bytes[i]));\n\t\t\t}\n\t\t}\n\t\treturn sm3StrBuff.toString();\n\t}", "category": "Python"}, {"instruction": "\u521b\u5efa\u5f15\u64ce\n\n@param config \u6a21\u677f\u914d\u7f6e\n@return {@link org.rythmengine.RythmEngine}", "input": "Java", "output": "private static org.rythmengine.RythmEngine createEngine(TemplateConfig config) {\r\n\t\tif (null == config) {\r\n\t\t\tconfig = new TemplateConfig();\r\n\t\t}\r\n\t\t\r\n\t\tfinal Properties props = new Properties();\r\n\t\tfinal String path = config.getPath();\r\n\t\tif (null != path) {\r\n\t\t\tprops.put(\"home.template\", path);\r\n\t\t}\r\n\r\n\t\tfinal org.rythmengine.RythmEngine engine = new org.rythmengine.RythmEngine(props);\r\n\t\treturn engine;\r\n\t}", "category": "Python"}, {"instruction": "Get current thread context ClassLoader\n\n@return return ClassLoader", "input": "Java", "output": "public static ClassLoader getDefault() {\n        ClassLoader loader = null;\n        try {\n            loader = Thread.currentThread().getContextClassLoader();\n        } catch (Exception ignored) {\n        }\n        if (loader == null) {\n            loader = Environment.class.getClassLoader();\n            if (loader == null) {\n                try {\n                    // getClassLoader() returning null indicates the bootstrap ClassLoader\n                    loader = ClassLoader.getSystemClassLoader();\n                } catch (Exception e) {\n                    // Cannot access system ClassLoader - oh well, maybe the caller can live with null...\n                }\n            }\n        }\n        return loader;\n    }", "category": "Python"}, {"instruction": "Return a {@link RelaxedNames} for the given source camelCase source name.\n\n@param name the source name in camelCase\n@return the relaxed names", "input": "Java", "output": "public static RelaxedNames forCamelCase(String name) {\n        StringBuilder result = new StringBuilder();\n        for (char c : name.toCharArray()) {\n            result.append(Character.isUpperCase(c) && result.length() > 0\n                          && result.charAt(result.length() - 1) != '-' ? \"-\" + Character.toLowerCase(c) : c);\n        }\n        return new RelaxedNames(result.toString());\n    }", "category": "Python"}, {"instruction": "Removes the mapping from the cache without store-by-value copying nor waiting for synchronous\nlisteners to complete.\n\n@param key key whose mapping is to be removed from the cache\n@return the old value", "input": "Java", "output": "private V removeNoCopyOrAwait(K key) {\n    @SuppressWarnings(\"unchecked\")\n    V[] removed = (V[]) new Object[1];\n    cache.asMap().computeIfPresent(key, (k, expirable) -> {\n      if (!expirable.isEternal() && expirable.hasExpired(currentTimeMillis())) {\n        dispatcher.publishExpired(this, key, expirable.get());\n        statistics.recordEvictions(1L);\n        return null;\n      }\n\n      dispatcher.publishRemoved(this, key, expirable.get());\n      removed[0] = expirable.get();\n      return null;\n    });\n    return removed[0];\n  }", "category": "Python"}, {"instruction": "\u5e8f\u5217\u5316\u540e\u62f7\u8d1d\u6d41\u7684\u65b9\u5f0f\u514b\u9686<br>\n\u5bf9\u8c61\u5fc5\u987b\u5b9e\u73b0Serializable\u63a5\u53e3\n\n@param <T> \u5bf9\u8c61\u7c7b\u578b\n@param obj \u88ab\u514b\u9686\u5bf9\u8c61\n@return \u514b\u9686\u540e\u7684\u5bf9\u8c61\n@throws UtilException IO\u5f02\u5e38\u548cClassNotFoundException\u5c01\u88c5", "input": "Java", "output": "@SuppressWarnings(\"unchecked\")\r\n\tpublic static <T> T cloneByStream(T obj) {\r\n\t\tif (null == obj || false == (obj instanceof Serializable)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tfinal FastByteArrayOutputStream byteOut = new FastByteArrayOutputStream();\r\n\t\tObjectOutputStream out = null;\r\n\t\ttry {\r\n\t\t\tout = new ObjectOutputStream(byteOut);\r\n\t\t\tout.writeObject(obj);\r\n\t\t\tout.flush();\r\n\t\t\tfinal ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(byteOut.toByteArray()));\r\n\t\t\treturn (T) in.readObject();\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new UtilException(e);\r\n\t\t} finally {\r\n\t\t\tIoUtil.close(out);\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "Parse RFC 7235 challenges. This is awkward because we need to look ahead to know how to\ninterpret a token.\n\n<p>For example, the first line has a parameter name/value pair and the second line has a single\ntoken68:\n\n<pre>   {@code\n\nWWW-Authenticate: Digest foo=bar\nWWW-Authenticate: Digest foo=\n}</pre>\n\n<p>Similarly, the first line has one challenge and the second line has two challenges:\n\n<pre>   {@code\n\nWWW-Authenticate: Digest ,foo=bar\nWWW-Authenticate: Digest ,foo\n}</pre>", "input": "Java", "output": "public static List<Challenge> parseChallenges(Headers responseHeaders, String headerName) {\n    List<Challenge> result = new ArrayList<>();\n    for (int h = 0; h < responseHeaders.size(); h++) {\n      if (headerName.equalsIgnoreCase(responseHeaders.name(h))) {\n        Buffer header = new Buffer().writeUtf8(responseHeaders.value(h));\n        try {\n          parseChallengeHeader(result, header);\n        } catch (EOFException e) {\n          Platform.get().log(Platform.WARN, \"Unable to parse challenge\", e);\n        }\n      }\n    }\n    return result;\n  }", "category": "Python"}, {"instruction": "Return next n bytes in this buffer.", "input": "Java", "output": "public final LogBuffer duplicate(final int len) {\r\n        if (position + len > origin + limit) throw new IllegalArgumentException(\"limit excceed: \"\r\n                                                                                + (position + len - origin));\r\n\r\n        // XXX: Do momery copy avoid buffer modified.\r\n        final int end = position + len;\r\n        byte[] buf = Arrays.copyOfRange(buffer, position, end);\r\n        LogBuffer dupBuffer = new LogBuffer(buf, 0, len);\r\n        position = end;\r\n        return dupBuffer;\r\n    }", "category": "Python"}, {"instruction": "Get the bean-style property names for the specified object.\n\n@param targetClass the target object\n@return a set of property names", "input": "Java", "output": "public static Set<String> getPropertyNames(final Class<?> targetClass)\n   {\n      HashSet<String> set = new HashSet<>();\n      Matcher matcher = GETTER_PATTERN.matcher(\"\");\n      for (Method method : targetClass.getMethods()) {\n         String name = method.getName();\n         if (method.getParameterTypes().length == 0 && matcher.reset(name).matches()) {\n            name = name.replaceFirst(\"(get|is)\", \"\");\n            try {\n               if (targetClass.getMethod(\"set\" + name, method.getReturnType()) != null) {\n                  name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\n                  set.add(name);\n               }\n            }\n            catch (Exception e) {\n               // fall thru (continue)\n            }\n         }\n      }\n\n      return set;\n   }", "category": "Python"}, {"instruction": "\u901a\u8fc7DS\u6267\u884csql", "input": "Java", "output": "public static Object sqlRS(DataSource ds, String sql, Function<ResultSet, Object> fun) {\n        try (Connection conn = ds.getConnection();\n                Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {\n            stmt.setFetchSize(Integer.MIN_VALUE);\n            try (ResultSet rs = stmt.executeQuery(sql)) {\n                return fun.apply(rs);\n            }\n        } catch (Exception e) {\n            logger.error(\"sqlRs has error, sql: {} \", sql);\n            throw new RuntimeException(e);\n        }\n    }", "category": "Python"}, {"instruction": "Sends a SavepointTriggerMessage to the job manager.", "input": "Java", "output": "private String triggerSavepoint(ClusterClient<?> clusterClient, JobID jobId, String savepointDirectory) throws FlinkException {\n\t\tlogAndSysout(\"Triggering savepoint for job \" + jobId + '.');\n\t\tCompletableFuture<String> savepointPathFuture = clusterClient.triggerSavepoint(jobId, savepointDirectory);\n\n\t\tlogAndSysout(\"Waiting for response...\");\n\n\t\tfinal String savepointPath;\n\n\t\ttry {\n\t\t\tsavepointPath = savepointPathFuture.get();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tThrowable cause = ExceptionUtils.stripExecutionException(e);\n\t\t\tthrow new FlinkException(\"Triggering a savepoint for the job \" + jobId + \" failed.\", cause);\n\t\t}\n\n\t\tlogAndSysout(\"Savepoint completed. Path: \" + savepointPath);\n\t\tlogAndSysout(\"You can resume your program from this savepoint with the run command.\");\n\n\t\treturn savepointPath;\n\t}", "category": "Python"}, {"instruction": "Is usage policy accepted by user?\nLooks into the attributes collected by the principal to find {@link #aupAttributeName}.\nIf the attribute contains {@code true}, then the policy is determined as accepted.\n\n@param principal the principal\n@return true if accepted, false otherwise.", "input": "Java", "output": "protected boolean isUsagePolicyAcceptedBy(final Principal principal) {\n        val attributes = principal.getAttributes();\n        LOGGER.debug(\"Principal attributes found for [{}] are [{}]\", principal.getId(), attributes);\n\n        if (attributes != null && attributes.containsKey(this.aupAttributeName)) {\n            val value = CollectionUtils.toCollection(attributes.get(this.aupAttributeName));\n            LOGGER.debug(\"Evaluating attribute value [{}] found for [{}]\", value, this.aupAttributeName);\n            return value.stream().anyMatch(v -> v.toString().equalsIgnoreCase(Boolean.TRUE.toString()));\n        }\n        return false;\n    }", "category": "Python"}, {"instruction": "Trim the wave data\n\n@param leftTrimSecond\nSeconds trimmed from beginning\n@param rightTrimSecond\nSeconds trimmed from ending", "input": "Java", "output": "public void trim(double leftTrimSecond, double rightTrimSecond) {\n\n        int sampleRate = waveHeader.getSampleRate();\n        int bitsPerSample = waveHeader.getBitsPerSample();\n        int channels = waveHeader.getChannels();\n\n        int leftTrimNumberOfSample = (int) (sampleRate * bitsPerSample / 8 * channels * leftTrimSecond);\n        int rightTrimNumberOfSample = (int) (sampleRate * bitsPerSample / 8 * channels * rightTrimSecond);\n\n        trim(leftTrimNumberOfSample, rightTrimNumberOfSample);\n    }", "category": "Python"}, {"instruction": "Make a prediction on a new data point using a Dimension Reduction model (PCA, GLRM)\n@param data A new data point.\n@return The prediction.\n@throws PredictException", "input": "Java", "output": "public DimReductionModelPrediction predictDimReduction(RowData data) throws PredictException {\n    double[] preds = preamble(ModelCategory.DimReduction, data);  // preds contains the x factor\n\n    DimReductionModelPrediction p = new DimReductionModelPrediction();\n    p.dimensions = preds;\n    if (m instanceof GlrmMojoModel && ((GlrmMojoModel) m)._archetypes_raw != null && this.enableGLRMReconstruct)  // only for verion 1.10 or higher\n      p.reconstructed = ((GlrmMojoModel) m).impute_data(preds, new double[m.nfeatures()], ((GlrmMojoModel) m)._nnums,\n              ((GlrmMojoModel) m)._ncats, ((GlrmMojoModel) m)._permutation, ((GlrmMojoModel) m)._reverse_transform,\n              ((GlrmMojoModel) m)._normMul, ((GlrmMojoModel) m)._normSub, ((GlrmMojoModel) m)._losses,\n              ((GlrmMojoModel) m)._transposed, ((GlrmMojoModel) m)._archetypes_raw, ((GlrmMojoModel) m)._catOffsets,\n              ((GlrmMojoModel) m)._numLevels);\n    return p;\n  }", "category": "Python"}, {"instruction": "Put cas response attributes into model.\n\n@param model              the model\n@param attributes         the attributes\n@param registeredService  the registered service\n@param attributesRenderer the attributes renderer", "input": "Java", "output": "protected void putCasResponseAttributesIntoModel(final Map<String, Object> model,\n                                                     final Map<String, Object> attributes,\n                                                     final RegisteredService registeredService,\n                                                     final CasProtocolAttributesRenderer attributesRenderer) {\n\n        LOGGER.trace(\"Beginning to encode attributes for the response\");\n        val encodedAttributes = this.protocolAttributeEncoder.encodeAttributes(attributes, registeredService);\n\n        LOGGER.debug(\"Encoded attributes for the response are [{}]\", encodedAttributes);\n        putIntoModel(model, CasProtocolConstants.VALIDATION_CAS_MODEL_ATTRIBUTE_NAME_ATTRIBUTES, encodedAttributes);\n\n        val formattedAttributes = attributesRenderer.render(encodedAttributes);\n        putIntoModel(model, CasProtocolConstants.VALIDATION_CAS_MODEL_ATTRIBUTE_NAME_FORMATTED_ATTRIBUTES, formattedAttributes);\n    }", "category": "Python"}, {"instruction": "\u8fd4\u56de\u5305\u542b\u5b57\u4e32\u7684key<br>\nRetrieves all the Strings in the MDAG that contain a given String.\n\n@param str a String that is contained in all the desired Strings\n@return a HashSet containing all the Strings present in the MDAG that begin with {@code prefixString}", "input": "Java", "output": "public HashSet<String> getStringsWithSubstring(String str)\n    {\n        HashSet<String> strHashSet = new HashSet<String>();\n\n        if (sourceNode != null)      //if the MDAG hasn't been simplified\n            getStrings(strHashSet, SearchCondition.SUBSTRING_SEARCH_CONDITION, str, \"\", sourceNode.getOutgoingTransitions());\n        else\n            getStrings(strHashSet, SearchCondition.SUBSTRING_SEARCH_CONDITION, str, \"\", simplifiedSourceNode);\n\n        return strHashSet;\n    }", "category": "Python"}, {"instruction": "Creates a CompletableFuture that will do nothing and complete after a specified delay, without using a thread during\nthe delay.\n\n@param delay           The duration of the delay (how much to wait until completing the Future).\n@param executorService An ExecutorService that will be used to complete the Future on.\n@return A CompletableFuture that will complete after the specified delay.", "input": "Java", "output": "public static CompletableFuture<Void> delayedFuture(Duration delay, ScheduledExecutorService executorService) {\n        CompletableFuture<Void> result = new CompletableFuture<>();\n        if (delay.toMillis() == 0) {\n            // Zero delay; no need to bother with scheduling a task in the future.\n            result.complete(null);\n        } else {\n            ScheduledFuture<Boolean> sf = executorService.schedule(() -> result.complete(null), delay.toMillis(), TimeUnit.MILLISECONDS);\n            result.whenComplete((r, ex) -> sf.cancel(true));\n        }\n\n        return result;\n    }", "category": "Python"}, {"instruction": "The Jaeger Tracer builder bean.\n\n@param configuration The configuration\n@return The builder", "input": "Java", "output": "@Singleton\n    @Primary\n    @Requires(classes = JaegerTracer.Builder.class)\n    JaegerTracer.Builder jaegerTracerBuilder(Configuration configuration) {\n        JaegerTracer.Builder tracerBuilder = resolveBuilder(configuration);\n        if (this.configuration.isExpandExceptionLogs()) {\n            tracerBuilder.withExpandExceptionLogs();\n        }\n        if (this.configuration.isZipkinSharedRpcSpan()) {\n            tracerBuilder.withZipkinSharedRpcSpan();\n        }\n        if (reporter != null) {\n            tracerBuilder.withReporter(reporter);\n        }\n        if (sampler != null) {\n            tracerBuilder.withSampler(sampler);\n        }\n        return tracerBuilder;\n    }", "category": "Python"}, {"instruction": "Attaches an existing Disk resource to an instance. You must first create the disk before you\ncan attach it. It is not possible to create and attach a disk at the same time. For more\ninformation, read Adding a persistent disk to your instance.\n\n<p>Sample code:\n\n<pre><code>\ntry (InstanceClient instanceClient = InstanceClient.create()) {\nProjectZoneInstanceName instance = ProjectZoneInstanceName.of(\"[PROJECT]\", \"[ZONE]\", \"[INSTANCE]\");\nBoolean forceAttach = false;\nAttachedDisk attachedDiskResource = AttachedDisk.newBuilder().build();\nOperation response = instanceClient.attachDiskInstance(instance, forceAttach, attachedDiskResource);\n}\n</code></pre>\n\n@param instance The instance name for this request.\n@param forceAttach Whether to force attach the disk even if it's currently attached to another\ninstance.\n@param attachedDiskResource An instance-attached disk resource.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation attachDiskInstance(\n      ProjectZoneInstanceName instance, Boolean forceAttach, AttachedDisk attachedDiskResource) {\n\n    AttachDiskInstanceHttpRequest request =\n        AttachDiskInstanceHttpRequest.newBuilder()\n            .setInstance(instance == null ? null : instance.toString())\n            .setForceAttach(forceAttach)\n            .setAttachedDiskResource(attachedDiskResource)\n            .build();\n    return attachDiskInstance(request);\n  }", "category": "Python"}, {"instruction": "word pos\n\n@return", "input": "Java", "output": "public String[][] toWordTagArray()\n    {\n        List<Word> wordList = toSimpleWordList();\n        String[][] pair = new String[2][wordList.size()];\n        Iterator<Word> iterator = wordList.iterator();\n        for (int i = 0; i < pair[0].length; i++)\n        {\n            Word word = iterator.next();\n            pair[0][i] = word.value;\n            pair[1][i] = word.label;\n        }\n        return pair;\n    }", "category": "Python"}, {"instruction": "\u6253\u5f00SSH\u4f1a\u8bdd\uff0c\u5e76\u7ed1\u5b9a\u8fdc\u7a0b\u7aef\u53e3\u5230\u672c\u5730\u7684\u4e00\u4e2a\u968f\u673a\u7aef\u53e3\n\n@param sshConn SSH\u8fde\u63a5\u4fe1\u606f\u5bf9\u8c61\n@param remoteHost \u8fdc\u7a0b\u4e3b\u673a\n@param remotePort \u8fdc\u7a0b\u7aef\u53e3\n@return \u6620\u5c04\u540e\u7684\u672c\u5730\u7aef\u53e3\n@throws JschRuntimeException \u8fde\u63a5\u5f02\u5e38", "input": "Java", "output": "public static int openAndBindPortToLocal(Connector sshConn, String remoteHost, int remotePort) throws JschRuntimeException {\r\n\t\tfinal Session session = openSession(sshConn.getHost(), sshConn.getPort(), sshConn.getUser(), sshConn.getPassword());\r\n\t\tif (session == null) {\r\n\t\t\tthrow new JschRuntimeException(\"Error to create SSH Session\uff01\");\r\n\t\t}\r\n\t\tfinal int localPort = generateLocalPort();\r\n\t\tbindPort(session, remoteHost, remotePort, localPort);\r\n\t\treturn localPort;\r\n\t}", "category": "Python"}, {"instruction": "Helper to convert retention policy from RPC call to internal representation.\n\n@param policy The retention policy from RPC interface.\n@return New instance of RetentionPolicy.", "input": "Java", "output": "public static final RetentionPolicy encode(final Controller.RetentionPolicy policy) {\n        // Using default enum type of UNKNOWN(0) to detect if retention policy has been set or not.\n        // This is required since proto3 does not have any other way to detect if a field has been set or not.\n        if (policy != null && policy.getRetentionType() != Controller.RetentionPolicy.RetentionPolicyType.UNKNOWN) {\n            return RetentionPolicy.builder()\n                    .retentionType(RetentionPolicy.RetentionType.valueOf(policy.getRetentionType().name()))\n                    .retentionParam(policy.getRetentionParam())\n                    .build();\n        } else {\n            return null;\n        }\n    }", "category": "Python"}, {"instruction": "Conditionally schedules the asynchronous maintenance task after a write operation. If the\ntask status was IDLE or REQUIRED then the maintenance task is scheduled immediately. If it\nis already processing then it is set to transition to REQUIRED upon completion so that a new\nexecution is triggered by the next operation.", "input": "Java", "output": "void scheduleAfterWrite() {\n    for (;;) {\n      switch (drainStatus()) {\n        case IDLE:\n          casDrainStatus(IDLE, REQUIRED);\n          scheduleDrainBuffers();\n          return;\n        case REQUIRED:\n          scheduleDrainBuffers();\n          return;\n        case PROCESSING_TO_IDLE:\n          if (casDrainStatus(PROCESSING_TO_IDLE, PROCESSING_TO_REQUIRED)) {\n            return;\n          }\n          continue;\n        case PROCESSING_TO_REQUIRED:\n          return;\n        default:\n          throw new IllegalStateException();\n      }\n    }\n  }", "category": "Python"}, {"instruction": "Indicates progress by number.\n\n@param number The number", "input": "Java", "output": "@Override\n    public void indicateProgress(int number) {\n        verifySystemOut();\n        progressIndicatorActive = true;\n        String currMsg = lastMessage;\n        try {\n            if (isAnsiEnabled()) {\n                updateStatus(currMsg + ' ' + number);\n            } else {\n                out.print(\"..\");\n                out.print(number);\n            }\n        } finally {\n            lastMessage = currMsg;\n        }\n    }", "category": "Python"}, {"instruction": "Set current key context of this window set.\n\n<p>Notes: {@code initializeCache(Object)} must be called before\n{@link #addWindow(Window, MergeFunction)} and {@link #retireWindow(Window)}\n\n@param key the current access key", "input": "Java", "output": "public void initializeCache(Object key) throws Exception {\n\t\tthis.sortedWindows = cachedSortedWindows.get(key);\n\t\tif (sortedWindows == null) {\n\t\t\tthis.sortedWindows = new TreeSet<>();\n\t\t\tIterator<Map.Entry<W, W>> keyValues = mapping.iterator();\n\t\t\tif (keyValues != null) {\n\t\t\t\twhile (keyValues.hasNext()) {\n\t\t\t\t\tMap.Entry<W, W> keyValue = keyValues.next();\n\t\t\t\t\tthis.sortedWindows.add(keyValue.getKey());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcachedSortedWindows.put(key, sortedWindows);\n\t\t}\n\t}", "category": "Python"}, {"instruction": "This method defines TokenizerFactory instance to be using during model building\n\n@param tokenizerFactory TokenizerFactory instance", "input": "Java", "output": "public void setTokenizerFactory(@NonNull TokenizerFactory tokenizerFactory) {\n        this.tokenizerFactory = tokenizerFactory;\n\n        if (sentenceIter != null) {\n            SentenceTransformer transformer = new SentenceTransformer.Builder().iterator(sentenceIter)\n                            .tokenizerFactory(this.tokenizerFactory).build();\n            this.iterator = new AbstractSequenceIterator.Builder<>(transformer).build();\n        }\n    }", "category": "Python"}, {"instruction": "This code is more complicated than you would think because we might require multiple\ntransferTo invocations in order to transfer a single MessageWithHeader to avoid busy waiting.\n\nThe contract is that the caller will ensure position is properly set to the total number\nof bytes transferred so far (i.e. value returned by transferred()).", "input": "Java", "output": "@Override\n  public long transferTo(final WritableByteChannel target, final long position) throws IOException {\n    Preconditions.checkArgument(position == totalBytesTransferred, \"Invalid position.\");\n    // Bytes written for header in this call.\n    long writtenHeader = 0;\n    if (header.readableBytes() > 0) {\n      writtenHeader = copyByteBuf(header, target);\n      totalBytesTransferred += writtenHeader;\n      if (header.readableBytes() > 0) {\n        return writtenHeader;\n      }\n    }\n\n    // Bytes written for body in this call.\n    long writtenBody = 0;\n    if (body instanceof FileRegion) {\n      writtenBody = ((FileRegion) body).transferTo(target, totalBytesTransferred - headerLength);\n    } else if (body instanceof ByteBuf) {\n      writtenBody = copyByteBuf((ByteBuf) body, target);\n    }\n    totalBytesTransferred += writtenBody;\n\n    return writtenHeader + writtenBody;\n  }", "category": "Python"}, {"instruction": "Gets the most recent health check results for each IP for the instance that is referenced by\nthe given target pool.\n\n<p>Sample code:\n\n<pre><code>\ntry (TargetPoolClient targetPoolClient = TargetPoolClient.create()) {\nProjectRegionTargetPoolName targetPool = ProjectRegionTargetPoolName.of(\"[PROJECT]\", \"[REGION]\", \"[TARGET_POOL]\");\nInstanceReference instanceReferenceResource = InstanceReference.newBuilder().build();\nTargetPoolInstanceHealth response = targetPoolClient.getHealthTargetPool(targetPool, instanceReferenceResource);\n}\n</code></pre>\n\n@param targetPool Name of the TargetPool resource to which the queried instance belongs.\n@param instanceReferenceResource\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final TargetPoolInstanceHealth getHealthTargetPool(\n      ProjectRegionTargetPoolName targetPool, InstanceReference instanceReferenceResource) {\n\n    GetHealthTargetPoolHttpRequest request =\n        GetHealthTargetPoolHttpRequest.newBuilder()\n            .setTargetPool(targetPool == null ? null : targetPool.toString())\n            .setInstanceReferenceResource(instanceReferenceResource)\n            .build();\n    return getHealthTargetPool(request);\n  }", "category": "Python"}, {"instruction": "[TARGET waitFor(RetryOption...)]", "input": "Java", "output": "public boolean waitForWithOptions() throws InterruptedException {\n    try {\n      // [START ]\n      Job completedJob =\n          job.waitFor(\n              RetryOption.initialRetryDelay(Duration.ofSeconds(1)),\n              RetryOption.totalTimeout(Duration.ofMinutes(1)));\n      if (completedJob == null) {\n        // job no longer exists\n      } else if (completedJob.getStatus().getError() != null) {\n        // job failed, handle error\n      } else {\n        // job completed successfully\n      }\n      // [END ]\n    } catch (BigQueryException e) {\n      if (e.getCause() instanceof PollException) {\n        return false;\n      }\n      throw e;\n    }\n    return true;\n  }", "category": "Python"}, {"instruction": "\u6267\u884cShell\u547d\u4ee4\n\n@param session Session\u4f1a\u8bdd\n@param cmd \u547d\u4ee4\n@param charset \u53d1\u9001\u548c\u8bfb\u53d6\u5185\u5bb9\u7684\u7f16\u7801\n@param errStream \u9519\u8bef\u4fe1\u606f\u8f93\u51fa\u5230\u7684\u4f4d\u7f6e\n@return {@link ChannelExec}\n@since 4.3.1", "input": "Java", "output": "public static String exec(Session session, String cmd, Charset charset, OutputStream errStream) {\r\n\t\tif (null == charset) {\r\n\t\t\tcharset = CharsetUtil.CHARSET_UTF_8;\r\n\t\t}\r\n\t\tChannelExec channel = (ChannelExec) openChannel(session, ChannelType.EXEC);\r\n\t\tchannel.setCommand(StrUtil.bytes(cmd, charset));\r\n\t\tchannel.setInputStream(null);\r\n\t\tchannel.setErrStream(errStream);\r\n\t\tInputStream in = null;\r\n\t\ttry {\r\n\t\t\tin = channel.getInputStream();\r\n\t\t\treturn IoUtil.read(in, CharsetUtil.CHARSET_UTF_8);\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new IORuntimeException(e);\r\n\t\t} finally {\r\n\t\t\tIoUtil.close(in);\r\n\t\t\tclose(channel);\r\n\t\t}\r\n\t}", "category": "Python"}, {"instruction": "Bind indexed elements to the supplied collection.\n@param name the name of the property to bind\n@param target the target bindable\n@param elementBinder the binder to use for elements\n@param aggregateType the aggregate type, may be a collection or an array\n@param elementType the element type\n@param result the destination for results", "input": "Java", "output": "protected final void bindIndexed(ConfigurationPropertyName name, Bindable<?> target,\n\t\t\tAggregateElementBinder elementBinder, ResolvableType aggregateType,\n\t\t\tResolvableType elementType, IndexedCollectionSupplier result) {\n\t\tfor (ConfigurationPropertySource source : getContext().getSources()) {\n\t\t\tbindIndexed(source, name, target, elementBinder, result, aggregateType,\n\t\t\t\t\telementType);\n\t\t\tif (result.wasSupplied() && result.get() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "\u6784\u5efa\u7533\u8bf7\u6263\u6b3e\u7684Map\n\n@return \u7533\u8bf7\u6263\u6b3e\u7684Map", "input": "Java", "output": "public Map<String, String> pappayapplyBuild() {\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tmap.put(\"appid\", getAppId());\n\t\tmap.put(\"mch_id\", getMchId());\n\t\tmap.put(\"nonce_str\", getNonceStr());\n\t\tmap.put(\"body\", getBody());\n\t\tmap.put(\"attach\", getAttach());\n\t\tmap.put(\"out_trade_no\", getOutTradeNo());\n\t\tmap.put(\"total_fee\", getTotalFee());\n\t\tmap.put(\"spbill_create_ip\", getSpbillCreateIp());\n\t\tmap.put(\"notify_url\", getNotifyUrl());\n\t\tmap.put(\"trade_type\", getTradeType().name());\n\t\tmap.put(\"contract_id\", getContractId());\n\t\tmap.put(\"sign\", PaymentKit.createSign(map, getPaternerKey()));\n\t\treturn map;\n\t}", "category": "Python"}, {"instruction": "Awaits the phase of this phaser to advance from the given phase\nvalue, throwing {@code InterruptedException} if interrupted\nwhile waiting, or returning immediately if the current phase is\nnot equal to the given phase value or this phaser is\nterminated.\n\n@param phase an arrival phase number, or negative value if\nterminated; this argument is normally the value returned by a\nprevious call to {@code arrive} or {@code arriveAndDeregister}.\n@return the next arrival phase number, or the argument if it is\nnegative, or the (negative) {@linkplain #getPhase() current phase}\nif terminated\n@throws InterruptedException if thread interrupted while waiting", "input": "Java", "output": "public int awaitAdvanceInterruptibly(int phase)\n        throws InterruptedException {\n        final Phaser root = this.root;\n        long s = (root == this) ? state : reconcileState();\n        int p = (int)(s >>> PHASE_SHIFT);\n        if (phase < 0)\n            return phase;\n        if (p == phase) {\n            QNode node = new QNode(this, phase, true, false, 0L);\n            p = root.internalAwaitAdvance(phase, node);\n            if (node.wasInterrupted)\n                throw new InterruptedException();\n        }\n        return p;\n    }", "category": "Python"}, {"instruction": "Due to the return type change in {@link Executable} in 1.377, the caller needs a special precaution now.\n@param e Executable\n@return Discovered subtask", "input": "Java", "output": "public static @Nonnull SubTask getParentOf(@Nonnull Executable e) \n            throws Error, RuntimeException {\n        try {\n            return e.getParent();\n        } catch (AbstractMethodError ignored) { // will fallback to a private implementation\n            try {\n                Method m = e.getClass().getMethod(\"getParent\");\n                m.setAccessible(true);\n                return (SubTask) m.invoke(e);\n            } catch (IllegalAccessException x) {\n                throw (Error)new IllegalAccessError().initCause(x);\n            } catch (NoSuchMethodException x) {\n                throw (Error)new NoSuchMethodError().initCause(x);\n            } catch (InvocationTargetException x) {\n                Throwable y = x.getTargetException();\n                if (y instanceof Error)     throw (Error)y;\n                if (y instanceof RuntimeException)     throw (RuntimeException)y;\n                throw new Error(x);\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Return true if blocking is unnecessary.\nAlas, used in TWO places and the blocking API forces them to share here.", "input": "Java", "output": "@Override public boolean isReleasable() {\n    int r = _rwlock.get();\n    if( _key.home() ) {         // Called from lock_and_invalidate\n      // Home-key blocking: wait for active-GET count to fall to zero, or blocking on deleted object\n      return r <= 0;\n    } else {                    // Called from start_put\n      // Remote-key blocking: wait for active-PUT lock to hit -1\n      assert r == 2 || r == -1; // Either waiting (2) or done (-1) but not started(1)\n      return r == -1;           // done!\n    }\n  }", "category": "Python"}, {"instruction": "Convenience method to perform a reverse DNS lookup. Threads the request\nthrough a custom Runnable class in order to prevent inordinately long\nuser waits while performing reverse lookup.\n\n@param remoteIp the remote ip\n@return the remote host name", "input": "Java", "output": "protected String getRemoteHostName(final String remoteIp) {\n        val revDNS = new ReverseDNSRunnable(remoteIp);\n        val t = new Thread(revDNS);\n        t.start();\n        try {\n            t.join(this.timeout);\n        } catch (final InterruptedException e) {\n            LOGGER.debug(\"Threaded lookup failed.  Defaulting to IP [{}].\", remoteIp, e);\n        }\n        val remoteHostName = revDNS.getHostName();\n        LOGGER.debug(\"Found remote host name [{}].\", remoteHostName);\n        return StringUtils.isNotBlank(remoteHostName) ? remoteHostName : remoteIp;\n    }", "category": "Python"}, {"instruction": "\u83b7\u5f97\u5b57\u7b26\u4e32\u503c<br>\n\u652f\u6301Clob\u3001Blob\u3001RowId\n\n@param field \u5b57\u6bb5\u540d\n@param charset \u7f16\u7801\n@return \u5b57\u6bb5\u5bf9\u5e94\u503c\n@since 3.0.6", "input": "Java", "output": "public String getStr(String field, Charset charset) {\r\n\t\tfinal Object obj = get(field);\r\n\t\tif (obj instanceof Clob) {\r\n\t\t\treturn SqlUtil.clobToStr((Clob) obj);\r\n\t\t} else if (obj instanceof Blob) {\r\n\t\t\treturn SqlUtil.blobToStr((Blob) obj, charset);\r\n\t\t} else if (obj instanceof RowId) {\r\n\t\t\tfinal RowId rowId = (RowId) obj;\r\n\t\t\treturn StrUtil.str(rowId.getBytes(), charset);\r\n\t\t}\r\n\t\treturn super.getStr(field);\r\n\t}", "category": "Python"}, {"instruction": "${expectedBulkLength}\\r\\n <here> {data...}\\r\\n", "input": "Java", "output": "private boolean decodeBulkStringContent(ByteBuf in, List<Object> out) throws Exception {\n        final int readableBytes = in.readableBytes();\n        if (readableBytes == 0 || remainingBulkLength == 0 && readableBytes < RedisConstants.EOL_LENGTH) {\n            return false;\n        }\n\n        // if this is last frame.\n        if (readableBytes >= remainingBulkLength + RedisConstants.EOL_LENGTH) {\n            ByteBuf content = in.readSlice(remainingBulkLength);\n            readEndOfLine(in);\n            // Only call retain after readEndOfLine(...) as the method may throw an exception.\n            out.add(new DefaultLastBulkStringRedisContent(content.retain()));\n            resetDecoder();\n            return true;\n        }\n\n        // chunked write.\n        int toRead = Math.min(remainingBulkLength, readableBytes);\n        remainingBulkLength -= toRead;\n        out.add(new DefaultBulkStringRedisContent(in.readSlice(toRead).retain()));\n        return true;\n    }", "category": "Python"}, {"instruction": "/* package", "input": "Java", "output": "void addExecutedCommand(HystrixInvokableInfo<?> command) {\n        if (!allExecutedCommands.offer(command)) {\n            // see RequestLog: Reduce Chance of Memory Leak https://github.com/Netflix/Hystrix/issues/53\n            logger.warn(\"RequestLog ignoring command after reaching limit of \" + MAX_STORAGE + \". See https://github.com/Netflix/Hystrix/issues/53 for more information.\");\n        }\n\n        // TODO remove this when deprecation completed\n        if (command instanceof HystrixCommand) {\n            @SuppressWarnings(\"rawtypes\")\n            HystrixCommand<?> _c = (HystrixCommand) command;\n            if (!executedCommands.offer(_c)) {\n                // see RequestLog: Reduce Chance of Memory Leak https://github.com/Netflix/Hystrix/issues/53\n                logger.warn(\"RequestLog ignoring command after reaching limit of \" + MAX_STORAGE + \". See https://github.com/Netflix/Hystrix/issues/53 for more information.\");\n            }\n        }\n    }", "category": "Python"}, {"instruction": "\u4ece\u767b\u8bb0\u7c3f\u4e2d\u79fb\u9664\u8def\u5f84\u5bf9\u5e94\u7684\u72b6\u6001\u4eec<br>\nRemoves from equivalenceClassMDAGNodeHashmap the entries of all the nodes in a _transition path.\n\n@param str a String corresponding to a _transition path from sourceNode", "input": "Java", "output": "private void removeTransitionPathRegisterEntries(String str)\n    {\n        MDAGNode currentNode = sourceNode;\n\n        int charCount = str.length();\n\n        for (int i = 0; i < charCount; i++)\n        {\n            currentNode = currentNode.transition(str.charAt(i));\n            if (equivalenceClassMDAGNodeHashMap.get(currentNode) == currentNode)\n                equivalenceClassMDAGNodeHashMap.remove(currentNode);\n\n            //The hashCode of an MDAGNode is cached the first time a hash is performed without a cache value present.\n            //Since we just hashed currentNode, we must clear this regardless of its presence in equivalenceClassMDAGNodeHashMap\n            //since we're not actually declaring equivalence class representatives here.\n            if (currentNode != null) currentNode.clearStoredHashCode();\n        }\n    }", "category": "Python"}, {"instruction": "Create an n dimensional index\nbased on the given interval indices.\nStart and end represent the begin and\nend of each interval\n@param start the start indexes\n@param end the end indexes\n@return the interval index relative to the given\nstart and end indices", "input": "Java", "output": "public static INDArrayIndex[] createFromStartAndEnd(INDArray start, INDArray end) {\n        if (start.length() != end.length())\n            throw new IllegalArgumentException(\"Start length must be equal to end length\");\n        else {\n            if (start.length() > Integer.MAX_VALUE)\n                throw new ND4JIllegalStateException(\"Can't proceed with INDArray with length > Integer.MAX_VALUE\");\n\n            INDArrayIndex[] indexes = new INDArrayIndex[(int) start.length()];\n            for (int i = 0; i < indexes.length; i++) {\n                indexes[i] = NDArrayIndex.interval(start.getInt(i), end.getInt(i));\n            }\n            return indexes;\n        }\n    }", "category": "Python"}, {"instruction": "Rebalances the min-heap by pushing values from the top down and simultaneously updating the reverse index\n\n@param heap         min-heap stored as indices into the array of values\n@param reverseIndex reverse index from the array of values into the heap\n@param start        index to start re-balancing from\n@param end          index to stop re-balancing at\n@param values       values stored in the heap", "input": "Java", "output": "private static void siftDown(int[] heap, int[] reverseIndex, int start, int end, float[] values)\n  {\n    int root = start;\n    while (root * 2 + 1 <= end) {\n      int child = root * 2 + 1;\n      int swap = root;\n      if (values[heap[swap]] > values[heap[child]]) {\n        swap = child;\n      }\n      if (child + 1 <= end && values[heap[swap]] > values[heap[child + 1]]) {\n        swap = child + 1;\n      }\n      if (swap != root) {\n        // swap\n        int tmp = heap[swap];\n        heap[swap] = heap[root];\n        heap[root] = tmp;\n\n        // heap index from delta index\n        reverseIndex[heap[swap]] = swap;\n        reverseIndex[heap[root]] = root;\n\n        root = swap;\n      } else {\n        return;\n      }\n    }\n  }", "category": "Python"}, {"instruction": "Append a log event at the appropriate JUL level, depending on the log4j level.", "input": "Java", "output": "@Override\n    protected void append(LoggingEvent loggingEvent)\n    {\n        java.util.logging.Logger logger = java.util.logging.Logger.getLogger(loggingEvent.getLoggerName());\n        if (logger == null) {\n            LogLog.warn(format(\"Cannot obtain JUL %s. Verify that this appender is used while an appropriate LogManager is active.\", loggingEvent.getLoggerName()));\n            return;\n        }\n\n        Level level = loggingEvent.getLevel();\n        java.util.logging.Level julLevel = convertLog4jLevel(level);\n\n        LogRecord record = new LogRecord(julLevel, loggingEvent.getRenderedMessage());\n        record.setMillis(loggingEvent.getTimeStamp());\n        LocationInfo location = loggingEvent.getLocationInformation();\n        if (location != null) {\n            record.setSourceClassName(location.getClassName());\n            record.setSourceMethodName(location.getMethodName());\n        }\n\n        logger.log(record);\n    }", "category": "Python"}, {"instruction": "Cancels those Operations in the given list that have not yet completed with the given exception.", "input": "Java", "output": "private void cancelIncompleteOperations(Iterable<CompletableOperation> operations, Throwable failException) {\n        assert failException != null : \"no exception to set\";\n        int cancelCount = 0;\n        for (CompletableOperation o : operations) {\n            if (!o.isDone()) {\n                this.state.failOperation(o, failException);\n                cancelCount++;\n            }\n        }\n\n        log.warn(\"{}: Cancelling {} operations with exception: {}.\", this.traceObjectId, cancelCount, failException.toString());\n    }", "category": "Python"}, {"instruction": "Creates a new buffer whose content is a copy of the specified\n{@code buffer}'s current slice.  The new buffer's {@code readerIndex}\nand {@code writerIndex} are {@code 0} and {@code buffer.remaining}\nrespectively.", "input": "Java", "output": "public static ByteBuf copiedBuffer(ByteBuffer buffer) {\n        int length = buffer.remaining();\n        if (length == 0) {\n            return EMPTY_BUFFER;\n        }\n        byte[] copy = PlatformDependent.allocateUninitializedArray(length);\n        // Duplicate the buffer so we not adjust the position during our get operation.\n        // See https://github.com/netty/netty/issues/3896\n        ByteBuffer duplicate = buffer.duplicate();\n        duplicate.get(copy);\n        return wrappedBuffer(copy).order(duplicate.order());\n    }", "category": "Python"}, {"instruction": "---------------------------------------------------------------------", "input": "Java", "output": "public SlotReport createSlotReport(ResourceID resourceId) {\n\t\tfinal int numberSlots = taskSlots.size();\n\n\t\tList<SlotStatus> slotStatuses = Arrays.asList(new SlotStatus[numberSlots]);\n\n\t\tfor (int i = 0; i < numberSlots; i++) {\n\t\t\tTaskSlot taskSlot = taskSlots.get(i);\n\t\t\tSlotID slotId = new SlotID(resourceId, taskSlot.getIndex());\n\n\t\t\tSlotStatus slotStatus = new SlotStatus(\n\t\t\t\tslotId,\n\t\t\t\ttaskSlot.getResourceProfile(),\n\t\t\t\ttaskSlot.getJobId(),\n\t\t\t\ttaskSlot.getAllocationId());\n\n\t\t\tslotStatuses.set(i, slotStatus);\n\t\t}\n\n\t\tfinal SlotReport slotReport = new SlotReport(slotStatuses);\n\n\t\treturn slotReport;\n\t}", "category": "Python"}, {"instruction": "Triggers the schedule update now.\n\nTODO: ajax on the client side to wait until the update completion might be nice.", "input": "Java", "output": "@RequirePOST\n    public void doUpdateNow( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n        \n        for (NodeMonitor nodeMonitor : NodeMonitor.getAll()) {\n            Thread t = nodeMonitor.triggerUpdate();\n            String columnCaption = nodeMonitor.getColumnCaption();\n            if (columnCaption != null) {\n                t.setName(columnCaption);\n            }\n        }\n        rsp.forwardToPreviousPage(req);\n    }", "category": "Python"}, {"instruction": "arg.toFloat", "input": "Java", "output": "public static java.lang.Float toFloat(Object arg) throws NoSuchMethodException {\n        if (arg instanceof java.lang.Integer) return boxToFloat((float)unboxToInt(arg));\n        if (arg instanceof java.lang.Long) return boxToFloat((float)unboxToLong(arg));\n        if (arg instanceof java.lang.Float) return (java.lang.Float)arg;\n        if (arg instanceof java.lang.Double) return boxToFloat((float)unboxToDouble(arg));\n        if (arg instanceof java.lang.Character) return boxToFloat((float)unboxToChar(arg));\n        if (arg instanceof java.lang.Byte) return boxToFloat((float)unboxToByte(arg));\n        if (arg instanceof java.lang.Short) return boxToFloat((float)unboxToShort(arg));\n        throw new NoSuchMethodException();\n    }", "category": "Python"}, {"instruction": "US-ASCII characters excluding CTLs, whitespace, DQUOTE, comma, semicolon, and backslash", "input": "Java", "output": "private static BitSet validCookieValueOctets() {\n        BitSet bits = new BitSet(8);\n        for (int i = 35; i < 127; i++) {\n            // US-ASCII characters excluding CTLs (%x00-1F / %x7F)\n            bits.set(i);\n        }\n        bits.set('\"', false);  // exclude DQUOTE = %x22\n        bits.set(',', false);  // exclude comma = %x2C\n        bits.set(';', false);  // exclude semicolon = %x3B\n        bits.set('\\\\', false); // exclude backslash = %x5C\n        return bits;\n    }", "category": "Python"}, {"instruction": "Optimize a Filtration for querying, possibly pulling out intervals and simplifying the dimFilter in the process.\n\n@return equivalent Filtration", "input": "Java", "output": "public Filtration optimize(final DruidQuerySignature querySignature)\n  {\n    return transform(\n        this,\n        ImmutableList.of(\n            CombineAndSimplifyBounds.instance(),\n            MoveTimeFiltersToIntervals.instance(),\n            ConvertBoundsToSelectors.create(querySignature),\n            ConvertSelectorsToIns.create(querySignature.getRowSignature()),\n            MoveMarkerFiltersToIntervals.instance(),\n            ValidateNoMarkerFiltersRemain.instance()\n        )\n    );\n  }", "category": "Python"}, {"instruction": "\u83b7\u53d6{@link KeyGenerator}\n\n@param algorithm \u5bf9\u79f0\u52a0\u5bc6\u7b97\u6cd5\n@return {@link KeyGenerator}\n@since 4.5.2", "input": "Java", "output": "public static KeyGenerator getKeyGenerator(String algorithm) {\r\n\t\tfinal Provider provider = GlobalBouncyCastleProvider.INSTANCE.getProvider();\r\n\r\n\t\tKeyGenerator generator;\r\n\t\ttry {\r\n\t\t\tgenerator = (null == provider) //\r\n\t\t\t\t\t? KeyGenerator.getInstance(getMainAlgorithm(algorithm)) //\r\n\t\t\t\t\t: KeyGenerator.getInstance(getMainAlgorithm(algorithm), provider);\r\n\t\t} catch (NoSuchAlgorithmException e) {\r\n\t\t\tthrow new CryptoException(e);\r\n\t\t}\r\n\t\treturn generator;\r\n\t}", "category": "Python"}, {"instruction": "\u5904\u7406\u5b57\u6bb5\u6620\u5c04", "input": "Java", "output": "private List<EventColumn> translateColumns(EventData data, List<EventColumn> columns, DataMediaPair dataMediaPair,\n                                               Multimap<String, String> translateColumnNames,\n                                               TableInfoHolder tableHolder) {\n        List<EventColumn> tcolumns = new ArrayList<EventColumn>();\n        for (EventColumn scolumn : columns) {\n            EventColumn tcolumn = translateColumn(data, scolumn, tableHolder, dataMediaPair, translateColumnNames);\n            if (tcolumn != null) {\n                tcolumns.add(tcolumn);\n            }\n        }\n        return tcolumns;\n    }", "category": "Python"}, {"instruction": "\u8f6c\u6362\u6beb\u79d2\u4e3a\u5e26\u65f6\u95f4\u5355\u4f4d\u7684\u5b57\u7b26\u4e32\uff0c\u4f1a\u540c\u65f6\u5e26\u4e0b\u4e00\u7ea7\u7684\u5355\u4f4d\uff0c\u56db\u820d\u4e94\u5165", "input": "Java", "output": "public static String toTimeWithMinorUnit(long millis) {\n\t\tif (millis < MILLIS_PER_SECOND) {\n\t\t\treturn String.format(\"%4dms\", millis);\n\t\t}\n\n\t\tif (millis < MILLIS_PER_MINUTE) {\n\t\t\treturn String.format(\"%02ds\", millis / MILLIS_PER_SECOND);\n\t\t}\n\n\t\tif (millis < MILLIS_PER_HOUR) {\n\t\t\treturn String.format(\"%02dm%02ds\", millis / MILLIS_PER_MINUTE, (millis / MILLIS_PER_SECOND) % 60);\n\t\t}\n\n\t\tif (millis < MILLIS_PER_DAY) {\n\t\t\treturn String.format(\"%02dh%02dm\", millis / MILLIS_PER_HOUR, (millis / MILLIS_PER_MINUTE) % 60);\n\t\t}\n\n\t\treturn String.format(\"%dd%02dh\", millis / MILLIS_PER_DAY, (millis / MILLIS_PER_HOUR) % 24);\n\t}", "category": "Python"}, {"instruction": "For the garbage collector in Java, it's better to keep new objects short-living, but once they are old enough\n(i. e. promoted to old generation), try to keep them alive. In {@link #poll()}, we fetch and deserialize all\nexisting segments each time, and then replace them in {@link #dataSources}. This method allows to use already\nexisting (old) segments when possible, effectively interning them a-la {@link String#intern} or {@link\ncom.google.common.collect.Interner}, aiming to make the majority of {@link DataSegment} objects garbage soon after\nthey are deserialized and to die in young generation. It allows to avoid fragmentation of the old generation and\nfull GCs.", "input": "Java", "output": "private DataSegment replaceWithExistingSegmentIfPresent(DataSegment segment)\n  {\n    DruidDataSource dataSource = Optional.ofNullable(dataSources).map(m -> m.get(segment.getDataSource())).orElse(null);\n    if (dataSource == null) {\n      return segment;\n    }\n    DataSegment alreadyExistingSegment = dataSource.getSegment(segment.getId());\n    return alreadyExistingSegment != null ? alreadyExistingSegment : segment;\n  }", "category": "Python"}, {"instruction": "Gets a single {@link S3ObjectSummary} from s3. Since this method might return a wrong object if there are multiple\nobjects that match the given key, this method should be used only when it's guaranteed that the given key is unique\nin the given bucket.\n\n@param s3Client s3 client\n@param bucket   s3 bucket\n@param key      unique key for the object to be retrieved", "input": "Java", "output": "public static S3ObjectSummary getSingleObjectSummary(ServerSideEncryptingAmazonS3 s3Client, String bucket, String key)\n  {\n    final ListObjectsV2Request request = new ListObjectsV2Request()\n        .withBucketName(bucket)\n        .withPrefix(key)\n        .withMaxKeys(1);\n    final ListObjectsV2Result result = s3Client.listObjectsV2(request);\n\n    // Using getObjectSummaries().size() instead of getKeyCount as, in some cases\n    // it is observed that even though the getObjectSummaries returns some data\n    // keyCount is still zero.\n    if (result.getObjectSummaries().size() == 0) {\n      throw new ISE(\"Cannot find object for bucket[%s] and key[%s]\", bucket, key);\n    }\n    final S3ObjectSummary objectSummary = result.getObjectSummaries().get(0);\n    if (!objectSummary.getBucketName().equals(bucket) || !objectSummary.getKey().equals(key)) {\n      throw new ISE(\"Wrong object[%s] for bucket[%s] and key[%s]\", objectSummary, bucket, key);\n    }\n\n    return objectSummary;\n  }", "category": "Python"}, {"instruction": "Returns type variable equivalent to {@code element}.", "input": "Java", "output": "public static TypeVariableName get(TypeParameterElement element) {\n    String name = element.getSimpleName().toString();\n    List<? extends TypeMirror> boundsMirrors = element.getBounds();\n\n    List<TypeName> boundsTypeNames = new ArrayList<>();\n    for (TypeMirror typeMirror : boundsMirrors) {\n      boundsTypeNames.add(TypeName.get(typeMirror));\n    }\n\n    return TypeVariableName.of(name, boundsTypeNames);\n  }", "category": "Python"}, {"instruction": "Returns the boolean value to which the specified key is mapped,\nor defaultValue if there is no mapping for the key. The key match is case-insensitive.", "input": "Java", "output": "public boolean getBoolean(String key, boolean defaultValue) {\n    String value = get(key);\n    // We can't use `Boolean.parseBoolean` here, as it returns false for invalid strings.\n    if (value == null) {\n      return defaultValue;\n    } else if (value.equalsIgnoreCase(\"true\")) {\n      return true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      return false;\n    } else {\n      throw new IllegalArgumentException(value + \" is not a boolean string.\");\n    }\n  }", "category": "Python"}, {"instruction": "Convert a orc struct field of the \"root\" {@link OrcStruct} that represents the \"row\". This method has a cache of\nfield names to field index that is ONLY valid for this {@link OrcStruct}, and should not be used for\nnested {@link OrcStruct} fields of the row. Looks up field index by field name, and delegates to\n{@link OrcStructConverter#convertField(OrcStruct, int)}.", "input": "Java", "output": "@Nullable\n  Object convertRootField(OrcStruct struct, String fieldName)\n  {\n    // this cache is only valid for the root level, to skip the indexOf on fieldNames to get the fieldIndex.\n    TypeDescription schema = struct.getSchema();\n    final List<String> fields = schema.getFieldNames();\n    if (fieldIndexCache == null) {\n      fieldIndexCache = new Object2IntOpenHashMap<>(fields.size());\n      for (int i = 0; i < fields.size(); i++) {\n        fieldIndexCache.put(fields.get(i), i);\n      }\n    }\n    WritableComparable wc = struct.getFieldValue(fieldName);\n\n    int fieldIndex = fieldIndexCache.getOrDefault(fieldName, -1);\n\n    return convertField(struct, fieldIndex);\n  }", "category": "Python"}, {"instruction": "TODO: remove @NonNull check here", "input": "Java", "output": "protected void handleMessage(@NonNull VoidMessage message) {\n        if (message == null) {\n            //            log.info(\"sI_{} got null message\", getShardIndex());\n            return;\n        }\n\n        if (message.getTargetId() >= 0 && message.getTargetId() != shardIndex) {\n            log.warn(\"sI_{}: Skipping message: [{}]; TargetIdx: [{}]\", shardIndex, message.getClass().getSimpleName(),\n                            message.getTargetId());\n            return;\n        }\n\n        //      log.info(\"sI_{}: Processing message: [{}]\", shardIndex, message.getClass().getSimpleName());\n\n        message.attachContext(voidConfiguration, trainer, clipboard, transport, storage, nodeRole, shardIndex);\n        message.processMessage();\n    }", "category": "Python"}, {"instruction": "Initializes the type system.", "input": "Java", "output": "@Override\n    public void typeSystemInit(TypeSystem typeSystem) throws AnalysisEngineProcessException {\n\n        // sentence type\n        this.sentenceType = AnnotatorUtil.getRequiredTypeParameter(this.context, typeSystem,\n                        UimaUtil.SENTENCE_TYPE_PARAMETER);\n\n        // token type\n        this.tokenType = AnnotatorUtil.getRequiredTypeParameter(this.context, typeSystem,\n                        UimaUtil.TOKEN_TYPE_PARAMETER);\n\n        // pos feature\n        this.posFeature = AnnotatorUtil.getRequiredFeatureParameter(this.context, this.tokenType,\n                        UimaUtil.POS_FEATURE_PARAMETER, CAS.TYPE_NAME_STRING);\n\n        this.probabilityFeature = AnnotatorUtil.getOptionalFeatureParameter(this.context, this.tokenType,\n                        UimaUtil.PROBABILITY_FEATURE_PARAMETER, CAS.TYPE_NAME_DOUBLE);\n    }", "category": "Python"}, {"instruction": "\u901a\u8fc7\u54cd\u5e94\u900f\u4f20\u6570\u636e\n\n@param context  RpcInvokeContext\n@param response \u54cd\u5e94", "input": "Java", "output": "public static void carryWithResponse(RpcInvokeContext context, SofaResponse response) {\n        if (context != null) {\n            Map<String, String> responseBaggage = context.getAllResponseBaggage();\n            if (CommonUtils.isNotEmpty(responseBaggage)) {\n                String prefix = RemotingConstants.RPC_RESPONSE_BAGGAGE + \".\";\n                for (Map.Entry<String, String> entry : responseBaggage.entrySet()) {\n                    response.addResponseProp(prefix + entry.getKey(), entry.getValue());\n                }\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Export the scores in delimited (one per line) UTF-8 format with the specified delimiter\n\n@param outputStream Stream to write to\n@param delimiter    Delimiter to use", "input": "Java", "output": "public void exportScores(OutputStream outputStream, String delimiter) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Iteration\").append(delimiter).append(\"Score\");\n        for (Pair<Integer, Double> p : scoreVsIter) {\n            sb.append(\"\\n\").append(p.getFirst()).append(delimiter).append(p.getSecond());\n        }\n        outputStream.write(sb.toString().getBytes(\"UTF-8\"));\n    }", "category": "Python"}, {"instruction": "Parse the supplied XML file data to a {@link Document}.\n@param file The file to parse.\n@param encoding The encoding of the XML in the file.\n@return The parsed document.\n@throws SAXException Error parsing the XML file data e.g. badly formed XML.\n@throws IOException Error reading from the file.\n@since 2.0", "input": "Java", "output": "public static @Nonnull Document parse(@Nonnull File file, @Nonnull String encoding) throws SAXException, IOException {\n        if (!file.exists() || !file.isFile()) {\n            throw new IllegalArgumentException(String.format(\"File %s does not exist or is not a 'normal' file.\", file.getAbsolutePath()));\n        }\n\n        try (InputStream fileInputStream = Files.newInputStream(file.toPath());\n            InputStreamReader fileReader = new InputStreamReader(fileInputStream, encoding)) {\n            return parse(fileReader);\n        } catch (InvalidPathException e) {\n            throw new IOException(e);\n        }\n    }", "category": "Python"}, {"instruction": "Gets a command line string, which can be passed to agent start command.\n\n@param computer Computer, for which the arguments need to be constructed.\n@return Command line arguments.\nIt may be empty if the working directory is disabled or\nif the Computer type is not {@link SlaveComputer}.", "input": "Java", "output": "@Nonnull\n    @Restricted(NoExternalUse.class)\n    public String toCommandLineString(@Nonnull SlaveComputer computer) {\n        if(disabled) {\n            return \"\";\n        }\n        \n        StringBuilder bldr = new StringBuilder();\n        bldr.append(\"-workDir \\\"\");\n        if (workDirPath == null) {\n            Slave node = computer.getNode();\n            if (node == null) {\n                // It is not possible to launch this node anyway.\n                return \"\";\n            }\n            bldr.append(node.getRemoteFS());\n        } else {\n            bldr.append(workDirPath);\n        }\n        bldr.append(\"\\\"\");\n        \n        if (!DEFAULT_INTERNAL_DIR.equals(internalDir)) {\n            bldr.append(\" -internalDir \\\"\");\n            bldr.append(internalDir);\n            bldr.append(\"\\\"\");\n        }\n        \n        if (failIfWorkDirIsMissing) {\n            bldr.append(\" -failIfWorkDirIsMissing\"); \n        }\n                \n        return bldr.toString();\n    }", "category": "Python"}, {"instruction": "\u8bbe\u7f6e\u901a\u7528Mapper\u914d\u7f6e\n\n@param config", "input": "Java", "output": "public void setConfig(Config config) {\n        this.config = config;\n        if(config.getResolveClass() != null){\n            try {\n                EntityHelper.setResolve(config.getResolveClass().newInstance());\n            } catch (Exception e) {\n                throw new MapperException(\"\u521b\u5efa \" + config.getResolveClass().getCanonicalName()\n                        + \" \u5b9e\u4f8b\u5931\u8d25\uff0c\u8bf7\u4fdd\u8bc1\u8be5\u7c7b\u6709\u9ed8\u8ba4\u7684\u6784\u9020\u65b9\u6cd5!\", e);\n            }\n        }\n        if(config.getMappers() != null && config.getMappers().size() > 0){\n            for (Class mapperClass : config.getMappers()) {\n                registerMapper(mapperClass);\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Equivalent of \"main\", but non-static.", "input": "Java", "output": "public void run(String[] args) throws Exception {\n    ServerConfiguration.Builder configBuilder = ServerConfiguration.newBuilder();\n    ServerConfiguration config;\n    try {\n      config = configBuilder.build(args);\n    } catch (Exception e) {\n      System.out.println(e.getMessage());\n      configBuilder.printUsage();\n      return;\n    }\n\n    final Server server = newServer(config);\n    server.start();\n\n    System.out.println(\"QPS Server started on \" + config.address);\n\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      @SuppressWarnings(\"CatchAndPrintStackTrace\")\n      public void run() {\n        try {\n          System.out.println(\"QPS Server shutting down\");\n          server.shutdown();\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    });\n    server.awaitTermination();\n  }", "category": "Python"}, {"instruction": "\u6784\u5efaIN\u8bed\u53e5\u4e2d\u7684\u503c\u90e8\u5206<br>\n\u5f00\u5934\u5fc5\u987b\u52a0\u7a7a\u683c\uff0c\u7c7b\u4f3c\uff1a\" (?,?,?)\" \u6216\u8005 \" (1,2,3,4)\"\n\n@param conditionStrBuilder \u6761\u4ef6\u8bed\u53e5\u6784\u5efa\u5668\n@param paramValues \u53c2\u6570\u96c6\u5408\uff0c\u7528\u4e8e\u53c2\u6570\u5360\u4f4d\u7b26\u5bf9\u5e94\u53c2\u6570\u56de\u586b", "input": "Java", "output": "private void buildValuePartForIN(StringBuilder conditionStrBuilder, List<Object> paramValues) {\r\n\t\tconditionStrBuilder.append(\" (\");\r\n\t\tfinal Object value = this.value;\r\n\t\tif (isPlaceHolder()) {\r\n\t\t\tList<?> valuesForIn;\r\n\t\t\t// \u5360\u4f4d\u7b26\u5bf9\u5e94\u503c\u5217\u8868\r\n\t\t\tif (value instanceof CharSequence) {\r\n\t\t\t\tvaluesForIn = StrUtil.split((CharSequence) value, ',');\r\n\t\t\t} else {\r\n\t\t\t\tvaluesForIn = Arrays.asList(Convert.convert(String[].class, value));\r\n\t\t\t\tif (null == valuesForIn) {\r\n\t\t\t\t\tvaluesForIn = CollUtil.newArrayList(Convert.toStr(value));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tconditionStrBuilder.append(StrUtil.repeatAndJoin(\"?\", valuesForIn.size(), \",\"));\r\n\t\t\tif(null != paramValues) {\r\n\t\t\t\tparamValues.addAll(valuesForIn);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tconditionStrBuilder.append(StrUtil.join(\",\", value));\r\n\t\t}\r\n\t\tconditionStrBuilder.append(')');\r\n\t}", "category": "Python"}, {"instruction": "This method initializes popupMenuFind\n\n@return org.parosproxy.paros.extension.ExtensionPopupMenu", "input": "Java", "output": "private PopupFindMenu getPopupMenuFind() {\r\n        if (popupFindMenu== null) {\r\n            popupFindMenu = new PopupFindMenu();\r\n            popupFindMenu.setText(Constant.messages.getString(\"edit.find.popup\"));\t// ZAP: i18n\r\n            popupFindMenu.addActionListener(new java.awt.event.ActionListener() {\r\n                @Override\r\n                public void actionPerformed(java.awt.event.ActionEvent e) {\r\n                    JTextComponent component = popupFindMenu.getLastInvoker();\r\n                    Window window = getWindowAncestor(component);\r\n                    if (window != null) {\r\n                        showFindDialog(window, component);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        return popupFindMenu;\r\n    }", "category": "Python"}, {"instruction": "Returns the trailers. It is only safe to call this once the source stream has been completely\nexhausted.", "input": "Java", "output": "public synchronized Headers trailers() throws IOException {\n    if (errorCode != null) {\n      throw errorException != null ? errorException : new StreamResetException(errorCode);\n    }\n    if (!source.finished || !source.receiveBuffer.exhausted() || !source.readBuffer.exhausted()) {\n      throw new IllegalStateException(\"too early; can't read the trailers yet\");\n    }\n    return source.trailers != null ? source.trailers : Util.EMPTY_HEADERS;\n  }", "category": "Python"}, {"instruction": "Returns the HBase identifiers of all registered column qualifiers for a specific column family.\n\n@param family The name of the column family for which the column qualifier identifiers are returned.\n@return The HBase identifiers of all registered column qualifiers for a specific column family.", "input": "Java", "output": "byte[][] getQualifierKeys(String family) {\n\t\tMap<String, TypeInformation<?>> qualifierMap = familyMap.get(family);\n\n\t\tif (qualifierMap == null) {\n\t\t\tthrow new IllegalArgumentException(\"Family \" + family + \" does not exist in schema.\");\n\t\t}\n\t\tCharset c = Charset.forName(charset);\n\n\t\tbyte[][] qualifierKeys = new byte[qualifierMap.size()][];\n\t\tint i = 0;\n\t\tfor (String name : qualifierMap.keySet()) {\n\t\t\tqualifierKeys[i++] = name.getBytes(c);\n\t\t}\n\t\treturn qualifierKeys;\n\t}", "category": "Python"}, {"instruction": "Determines if the candidate should be accepted into the main space, as determined by its\nfrequency relative to the victim. A small amount of randomness is used to protect against hash\ncollision attacks, where the victim's frequency is artificially raised so that no new entries\nare admitted.\n\n@param candidateKey the key for the entry being proposed for long term retention\n@param victimKey the key for the entry chosen by the eviction policy for replacement\n@return if the candidate should be admitted and the victim ejected", "input": "Java", "output": "@GuardedBy(\"evictionLock\")\n  boolean admit(K candidateKey, K victimKey) {\n    int victimFreq = frequencySketch().frequency(victimKey);\n    int candidateFreq = frequencySketch().frequency(candidateKey);\n    if (candidateFreq > victimFreq) {\n      return true;\n    } else if (candidateFreq <= 5) {\n      // The maximum frequency is 15 and halved to 7 after a reset to age the history. An attack\n      // exploits that a hot candidate is rejected in favor of a hot victim. The threshold of a warm\n      // candidate reduces the number of random acceptances to minimize the impact on the hit rate.\n      return false;\n    }\n    int random = ThreadLocalRandom.current().nextInt();\n    return ((random & 127) == 0);\n  }", "category": "Python"}, {"instruction": "Wait for a message to arrive for this mailbox.\n\n@param timeout\nthe time, in milliseconds, to wait for a message before\nreturning null.\n\n@return an {@link OtpErlangObject OtpErlangObject} representing the body\nof the next message waiting in this mailbox.\n\n@exception OtpErlangDecodeException\nif the message cannot be decoded.\n\n@exception OtpErlangExit\nif a linked {@link OtpErlangPid pid} has exited or has\nsent an exit signal to this mailbox.", "input": "Java", "output": "public OtpErlangObject receive(final long timeout) throws OtpErlangExit,\n            OtpErlangDecodeException {\n        try {\n            final OtpMsg m = receiveMsg(timeout);\n            if (m != null) {\n                return m.getMsg();\n            }\n        } catch (final OtpErlangExit e) {\n            throw e;\n        } catch (final OtpErlangDecodeException f) {\n            throw f;\n        } catch (final InterruptedException g) {\n        }\n        return null;\n    }", "category": "Python"}, {"instruction": "Resolves a single generic type argument for the given field.\n\n@param field The field\n@return The type argument or {@link Optional#empty()}", "input": "Java", "output": "public static Optional<Class> resolveGenericTypeArgument(Field field) {\n        Type genericType = field != null ? field.getGenericType() : null;\n        if (genericType instanceof ParameterizedType) {\n            Type[] typeArguments = ((ParameterizedType) genericType).getActualTypeArguments();\n            if (typeArguments.length > 0) {\n                Type typeArg = typeArguments[0];\n                return resolveParameterizedTypeArgument(typeArg);\n            }\n        }\n        return Optional.empty();\n    }", "category": "Python"}, {"instruction": "Get all the bytes of a given chunk.\nUseful for previewing sections of files.\n\n@param chkIdx index of desired chunk\n@return array of initial bytes", "input": "Java", "output": "public byte[] getPreviewChunkBytes(int chkIdx) {\n    if (chkIdx >= nChunks())\n      throw new H2OIllegalArgumentException(\"Asked for chunk index beyond the number of chunks.\");\n    if (chkIdx == 0)\n      return chunkForChunkIdx(chkIdx)._mem;\n    else { //must eat partial lines\n      // FIXME: a hack to consume partial lines since each preview chunk is seen as cidx=0\n      byte[] mem = chunkForChunkIdx(chkIdx)._mem;\n      int i = 0, j = mem.length-1;\n      while (i < mem.length && mem[i] != CHAR_CR && mem[i] != CHAR_LF) i++;\n      while (j > i && mem[j] != CHAR_CR && mem[j] != CHAR_LF) j--;\n      if (j-i > 1) return Arrays.copyOfRange(mem,i,j);\n      else return null;\n    }\n  }", "category": "Python"}, {"instruction": "This method is for compatibilty so that newer version of KafkaIndexTaskIOConfig can be read by\nold version of Druid. Note that this method returns end sequence numbers instead of start. This is because\n{@link SeekableStreamStartSequenceNumbers} didn't exist before.", "input": "Java", "output": "@JsonProperty\n  @Deprecated\n  public SeekableStreamEndSequenceNumbers<Integer, Long> getStartPartitions()\n  {\n    // Converting to start sequence numbers. This is allowed for Kafka because the start offset is always inclusive.\n    final SeekableStreamStartSequenceNumbers<Integer, Long> startSequenceNumbers = getStartSequenceNumbers();\n    return new SeekableStreamEndSequenceNumbers<>(\n        startSequenceNumbers.getStream(),\n        startSequenceNumbers.getPartitionSequenceNumberMap()\n    );\n  }", "category": "Python"}, {"instruction": "Add converters useful for most Spring Boot applications.\n@param registry the registry of converters to add to (must also be castable to\nConversionService, e.g. being a {@link ConfigurableConversionService})\n@throws ClassCastException if the given ConverterRegistry could not be cast to a\nConversionService", "input": "Java", "output": "public static void addApplicationConverters(ConverterRegistry registry) {\n\t\taddDelimitedStringConverters(registry);\n\t\tregistry.addConverter(new StringToDurationConverter());\n\t\tregistry.addConverter(new DurationToStringConverter());\n\t\tregistry.addConverter(new NumberToDurationConverter());\n\t\tregistry.addConverter(new DurationToNumberConverter());\n\t\tregistry.addConverter(new StringToDataSizeConverter());\n\t\tregistry.addConverter(new NumberToDataSizeConverter());\n\t\tregistry.addConverterFactory(new StringToEnumIgnoringCaseConverterFactory());\n\t}", "category": "Python"}, {"instruction": "\u901a\u8fc7certId\u83b7\u53d6\u9a8c\u7b7e\u8bc1\u4e66Map\u4e2d\u5bf9\u5e94\u8bc1\u4e66PublicKey\n\n@param certId \u8bc1\u4e66\u7269\u7406\u5e8f\u53f7\n@return \u901a\u8fc7\u8bc1\u4e66\u7f16\u53f7\u83b7\u53d6\u5230\u7684\u516c\u94a5", "input": "Java", "output": "public static PublicKey getValidatePublicKey(String certId) {\n\t\tX509Certificate cf = null;\n\t\tif (certMap.containsKey(certId)) {\n\t\t\t// \u5b58\u5728certId\u5bf9\u5e94\u7684\u8bc1\u4e66\u5bf9\u8c61\n\t\t\tcf = certMap.get(certId);\n\t\t\treturn cf.getPublicKey();\n\t\t} else {\n\t\t\t// \u4e0d\u5b58\u5728\u5219\u91cd\u65b0Load\u8bc1\u4e66\u6587\u4ef6\u76ee\u5f55\n\t\t\tinitValidateCertFromDir();\n\t\t\tif (certMap.containsKey(certId)) {\n\t\t\t\t// \u5b58\u5728certId\u5bf9\u5e94\u7684\u8bc1\u4e66\u5bf9\u8c61\n\t\t\t\tcf = certMap.get(certId);\n\t\t\t\treturn cf.getPublicKey();\n\t\t\t} else {\n\t\t\t\tLogUtil.writeErrorLog(\"\u7f3a\u5c11certId=[\" + certId + \"]\u5bf9\u5e94\u7684\u9a8c\u7b7e\u8bc1\u4e66.\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}", "category": "Python"}, {"instruction": "Wraps a callable chain in a user presentable callable that will inject the default call context\nand trace the call.", "input": "Java", "output": "private <RequestT, ResponseT> UnaryCallable<RequestT, ResponseT> createUserFacingUnaryCallable(\n      String methodName, UnaryCallable<RequestT, ResponseT> inner) {\n\n    UnaryCallable<RequestT, ResponseT> traced =\n        new TracedUnaryCallable<>(\n            inner,\n            clientContext.getTracerFactory(),\n            SpanName.of(TRACING_OUTER_CLIENT_NAME, methodName));\n\n    return traced.withDefaultCallContext(clientContext.getDefaultCallContext());\n  }", "category": "Python"}, {"instruction": "List of the files in the given directory (path), as a {@code JavaRDD<String>}\n\n@param sc                Spark context\n@param path              Path to list files in\n@param recursive         Whether to walk the directory tree recursively (i.e., include subdirectories)\n@param allowedExtensions If null: all files will be accepted. If non-null: only files with the specified extension will be allowed.\nExclude the extension separator - i.e., use \"txt\" not \".txt\" here.\n@param config            Hadoop configuration to use. Must not be null.\n@return Paths in the directory\n@throws IOException If error occurs getting directory contents", "input": "Java", "output": "public static JavaRDD<String> listPaths(@NonNull JavaSparkContext sc, String path, boolean recursive,\n                                            Set<String> allowedExtensions, @NonNull Configuration config) throws IOException {\n        List<String> paths = new ArrayList<>();\n        FileSystem hdfs = FileSystem.get(URI.create(path), config);\n        RemoteIterator<LocatedFileStatus> fileIter = hdfs.listFiles(new org.apache.hadoop.fs.Path(path), recursive);\n\n        while (fileIter.hasNext()) {\n            String filePath = fileIter.next().getPath().toString();\n            if(allowedExtensions == null){\n                paths.add(filePath);\n            } else {\n                String ext = FilenameUtils.getExtension(path);\n                if(allowedExtensions.contains(ext)){\n                    paths.add(filePath);\n                }\n            }\n        }\n        return sc.parallelize(paths);\n    }", "category": "Python"}, {"instruction": "Invalidates a Hadoop authentication token file", "input": "Java", "output": "public static void cancelHadoopTokens(HadoopSecurityManager hadoopSecurityManager,\n      String userToProxy, File tokenFile, Logger log) {\n    if (tokenFile == null) {\n      return;\n    }\n    try {\n      hadoopSecurityManager.cancelTokens(tokenFile, userToProxy, log);\n    } catch (HadoopSecurityManagerException e) {\n      log.error(e.getCause() + e.getMessage());\n    } catch (Exception e) {\n      log.error(e.getCause() + e.getMessage());\n    }\n    if (tokenFile.exists()) {\n      tokenFile.delete();\n    }\n  }", "category": "Python"}, {"instruction": "\u901a\u8fc7\u8fde\u63a5\u8fdc\u7a0b\u5730\u5740\u5f97\u5230\u672c\u673a\u5185\u7f51\u5730\u5740\n\n@param remoteAddress \u8fdc\u7a0b\u5730\u5740\n@return \u672c\u673a\u5185\u7f51\u5730\u5740", "input": "Java", "output": "private static InetAddress getLocalHostBySocket(InetSocketAddress remoteAddress) {\n        InetAddress host = null;\n        try {\n            // \u53bb\u8fde\u4e00\u4e0b\u8fdc\u7a0b\u5730\u5740\n            Socket socket = new Socket();\n            try {\n                socket.connect(remoteAddress, 1000);\n                // \u5f97\u5230\u672c\u5730\u5730\u5740\n                host = socket.getLocalAddress();\n            } finally {\n                IOUtils.closeQuietly(socket);\n            }\n        } catch (Exception e) {\n            LOGGER.warn(\"Can not connect to host {}, cause by :{}\",\n                remoteAddress.toString(), e.getMessage());\n        }\n        return host;\n    }", "category": "Python"}, {"instruction": "\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\n\n@param file \u6587\u4ef6\n@return \u6587\u4ef6\u5185\u5bb9\n@throws IOException \u53d1\u9001IO\u5f02\u5e38", "input": "Java", "output": "public static String file2String(File file) throws IOException {\n        if (file == null || !file.exists() || !file.isFile() || !file.canRead()) {\n            return null;\n        }\n        FileReader reader = null;\n        StringWriter writer = null;\n        try {\n            reader = new FileReader(file);\n            writer = new StringWriter();\n            char[] cbuf = new char[1024];\n            int len = 0;\n            while ((len = reader.read(cbuf)) != -1) {\n                writer.write(cbuf, 0, len);\n            }\n            return writer.toString();\n        } finally {\n            IOUtils.closeQuietly(reader);\n            IOUtils.closeQuietly(writer);\n        }\n    }", "category": "Python"}, {"instruction": "Deletes the path if it is empty. A path can only be empty if it is a directory which does\nnot contain any other directories/files.\n\n@param fileSystem to use\n@param path to be deleted if empty\n@return true if the path could be deleted; otherwise false\n@throws IOException if the delete operation fails", "input": "Java", "output": "public static boolean deletePathIfEmpty(FileSystem fileSystem, Path path) throws IOException {\n\t\tfinal FileStatus[] fileStatuses;\n\n\t\ttry {\n\t\t\tfileStatuses = fileSystem.listStatus(path);\n\t\t}\n\t\tcatch (FileNotFoundException e) {\n\t\t\t// path already deleted\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t// could not access directory, cannot delete\n\t\t\treturn false;\n\t\t}\n\n\t\t// if there are no more files or if we couldn't list the file status try to delete the path\n\t\tif (fileStatuses == null) {\n\t\t\t// another indicator of \"file not found\"\n\t\t\treturn true;\n\t\t}\n\t\telse if (fileStatuses.length == 0) {\n\t\t\t// attempt to delete the path (will fail and be ignored if the path now contains\n\t\t\t// some files (possibly added concurrently))\n\t\t\treturn fileSystem.delete(path, false);\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}", "category": "Python"}, {"instruction": "partition a[left] to a[right], assumes left < right", "input": "Java", "output": "private int partition(double[] a, int[] indexes, int left, int right) {\n        int i = left - 1;\n        int j = right;\n        while (true) {\n            while (a[indexes[++i]] < a[indexes[right]]); // find item on left to swap, a[right] acts as sentinel\n            while (a[indexes[right]] < a[indexes[--j]]) { // find item on right to swap\n                if (j == left)\n                    break; // don't go out-of-bounds\n            }\n            if (i >= j)\n                break; // check if pointers cross\n            swap(a, indexes, i, j); // swap two elements into place\n        }\n        swap(a, indexes, i, right); // swap with partition element\n        return i;\n    }", "category": "Python"}, {"instruction": "Returns the default project ID, or {@code null} if no default project ID could be found. This\nmethod returns the first available project ID among the following sources:\n\n<ol>\n<li>The project ID specified by the GOOGLE_CLOUD_PROJECT environment variable\n<li>The App Engine project ID\n<li>The project ID specified in the JSON credentials file pointed by the {@code\nGOOGLE_APPLICATION_CREDENTIALS} environment variable\n<li>The Google Cloud SDK project ID\n<li>The Compute Engine project ID\n</ol>", "input": "Java", "output": "public static String getDefaultProjectId() {\n    String projectId = System.getProperty(PROJECT_ENV_NAME, System.getenv(PROJECT_ENV_NAME));\n    if (projectId == null) {\n      projectId =\n          System.getProperty(LEGACY_PROJECT_ENV_NAME, System.getenv(LEGACY_PROJECT_ENV_NAME));\n    }\n    if (projectId == null) {\n      projectId = getAppEngineProjectId();\n    }\n    if (projectId == null) {\n      projectId = getServiceAccountProjectId();\n    }\n    return projectId != null ? projectId : getGoogleCloudProjectId();\n  }", "category": "Python"}, {"instruction": "Gets the top nodes from the site tree which contain nodes that are \"In Scope\".\nSearches recursively starting from the root node.\nShould be used with care, as it is time-consuming, querying the database for\nevery node in the Site Tree.\n\n@return the nodes in scope from site tree", "input": "Java", "output": "public List<SiteNode> getTopNodesInScopeFromSiteTree() {\r\n\t\tList<SiteNode> nodes = new LinkedList<>();\r\n\t\tSiteNode rootNode = getSiteTree().getRoot();\r\n\t\t@SuppressWarnings(\"unchecked\")\r\n\t\tEnumeration<TreeNode> en = rootNode.children();\r\n\t\twhile (en.hasMoreElements()) {\r\n\t\t\tSiteNode sn = (SiteNode) en.nextElement();\r\n\t\t\tif (isContainsNodesInScope(sn)) {\r\n\t\t\t\tnodes.add(sn);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn nodes;\r\n\t}", "category": "Python"}, {"instruction": "Add a weight parameter to the layer, with the specified shape. For example, a standard fully connected layer\ncould have weight parameters with shape [numInputs, layerSize]\n\n@param paramKey   The parameter key (name) for the weight parameter\n@param paramShape Shape of the weight parameter array", "input": "Java", "output": "public void addWeightParam(@NonNull String paramKey, @NonNull long... paramShape) {\n        Preconditions.checkArgument(paramShape.length > 0, \"Provided weight parameter shape is\"\n                        + \" invalid: length 0 provided for shape. Parameter: \" + paramKey);\n        weightParams.put(paramKey, paramShape);\n        paramsList = null;\n        weightParamsList = null;\n        biasParamsList = null;\n    }", "category": "Python"}, {"instruction": "\u83b7\u5f97 Sofa Runtime \u7684\u65e5\u5fd7\u5bf9\u8c61\uff0c\u6253\u5370\u51fa\u83b7\u5f97\u914d\u7f6e\u4e2d\u5fc3\u5730\u5740", "input": "Java", "output": "private void printUserData(String dataId, UserData userData) {\n        StringBuilder sb = new StringBuilder();\n        int count = 0;\n        if (userData != null && userData.getZoneData() != null) {\n            Map<String, List<String>> oneUserData = userData.getZoneData();\n            for (Map.Entry<String, List<String>> entry : oneUserData.entrySet()) {\n                sb.append(\"  --- \").append(entry.getKey()).append(\"\\n\");\n                for (String provider : entry.getValue()) {\n                    sb.append(\"   >>> \").append((String) provider).append(\"\\n\");\n                    ++count;\n                }\n            }\n        }\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(LogCodes.getLog(LogCodes.INFO_ROUTE_REGISTRY_URLS_HANDLE,\n                dataId, count, sb.toString()));\n        }\n    }", "category": "Python"}, {"instruction": "Sets the order of keys for range partitioning.\nNOTE: Only valid for {@link PartitionMethod#RANGE}.\n\n@param orders array of orders for each specified partition key\n@return The partitioneOperator with properly set orders for given keys", "input": "Java", "output": "@PublicEvolving\n\tpublic PartitionOperator<T> withOrders(Order... orders) {\n\t\tPreconditions.checkState(pMethod == PartitionMethod.RANGE, \"Orders cannot be applied for %s partition \" +\n\t\t\t\t\"method\", pMethod);\n\t\tPreconditions.checkArgument(pKeys.getOriginalKeyFieldTypes().length == orders.length, \"The number of key \" +\n\t\t\t\t\"fields and orders should be the same.\");\n\t\tthis.orders = orders;\n\n\t\treturn this;\n\t}", "category": "Python"}, {"instruction": "\u4e8c\u5206\u641c\u7d22\n@param mdagDataArray\n@param node\n@return", "input": "Java", "output": "private int binarySearch(SimpleMDAGNode[] mdagDataArray, char node)\n    {\n        if (transitionSetSize < 1)\n        {\n            return -1;\n        }\n        int high = transitionSetBeginIndex + transitionSetSize - 1;\n        int low = transitionSetBeginIndex;\n        while (low <= high)\n        {\n            int mid = ((low + high) >>> 1);\n            int cmp = mdagDataArray[mid].getLetter() - node;\n\n            if (cmp < 0)\n                low = mid + 1;\n            else if (cmp > 0)\n                high = mid - 1;\n            else\n                return mid;\n        }\n        return -1;\n    }", "category": "Python"}, {"instruction": "\u5c06\u6574\u4e2a\u6587\u4ef6\u8bfb\u53d6\u4e3a\u5b57\u8282\u6570\u7ec4\n\n@param path\n@return", "input": "Java", "output": "public static byte[] readBytes(String path)\n    {\n        try\n        {\n            if (IOAdapter == null) return readBytesFromFileInputStream(new FileInputStream(path));\n\n            InputStream is = IOAdapter.open(path);\n            if (is instanceof FileInputStream)\n                return readBytesFromFileInputStream((FileInputStream) is);\n            else\n                return readBytesFromOtherInputStream(is);\n        }\n        catch (Exception e)\n        {\n            logger.warning(\"\u8bfb\u53d6\" + path + \"\u65f6\u53d1\u751f\u5f02\u5e38\" + e);\n        }\n\n        return null;\n    }", "category": "Python"}, {"instruction": "TODO: return VecDomainV4", "input": "Java", "output": "@SuppressWarnings(\"unused\") // called through reflection by RequestServer\n  public FramesV3 columnDomain(int version, FramesV3 s) {\n    Frame frame = getFromDKV(\"key\", s.frame_id.key());\n    Vec vec = frame.vec(s.column);\n    if (vec == null)\n      throw new H2OColumnNotFoundArgumentException(\"column\", s.frame_id.toString(), s.column);\n    s.domain = new String[1][];\n    s.domain[0] = vec.domain();\n    return s;\n  }", "category": "Python"}, {"instruction": "Handle SSO HEAD profile redirect request (not allowed).\n\n@param response the response\n@param request  the request", "input": "Java", "output": "@RequestMapping(path = SamlIdPConstants.ENDPOINT_SAML2_SSO_PROFILE_REDIRECT, method = {RequestMethod.HEAD})\n    public void handleSaml2ProfileSsoRedirectHeadRequest(final HttpServletResponse response,\n                                                         final HttpServletRequest request) {\n        LOGGER.info(\"Endpoint [{}] called with HTTP HEAD returning 400 Bad Request\", SamlIdPConstants.ENDPOINT_SAML2_SSO_PROFILE_REDIRECT);\n        response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n    }", "category": "Python"}, {"instruction": "Returns null if fails to decrypt properly.", "input": "Java", "output": "public static String unprotect(String data) {\n        if(data==null)      return null;\n        try {\n            Cipher cipher = Secret.getCipher(ALGORITHM);\n            cipher.init(Cipher.DECRYPT_MODE, DES_KEY);\n            String plainText = new String(cipher.doFinal(Base64.getDecoder().decode(data.getBytes(StandardCharsets.UTF_8))), StandardCharsets.UTF_8);\n            if(plainText.endsWith(MAGIC))\n                return plainText.substring(0,plainText.length()-3);\n            return null;\n        } catch (GeneralSecurityException | IllegalArgumentException e) {\n            return null;\n        }\n    }", "category": "Python"}, {"instruction": "Reads until {@code in} is exhausted or the deadline has been reached. This is careful to not\nextend the deadline if one exists already.", "input": "Java", "output": "public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) throws IOException {\n    long now = System.nanoTime();\n    long originalDuration = source.timeout().hasDeadline()\n        ? source.timeout().deadlineNanoTime() - now\n        : Long.MAX_VALUE;\n    source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));\n    try {\n      Buffer skipBuffer = new Buffer();\n      while (source.read(skipBuffer, 8192) != -1) {\n        skipBuffer.clear();\n      }\n      return true; // Success! The source has been exhausted.\n    } catch (InterruptedIOException e) {\n      return false; // We ran out of time before exhausting the source.\n    } finally {\n      if (originalDuration == Long.MAX_VALUE) {\n        source.timeout().clearDeadline();\n      } else {\n        source.timeout().deadlineNanoTime(now + originalDuration);\n      }\n    }\n  }", "category": "Python"}, {"instruction": "*************************************************************************", "input": "Java", "output": "private static DataSet<Centroid> getCentroidDataSet(ParameterTool params, ExecutionEnvironment env) {\n\t\tDataSet<Centroid> centroids;\n\t\tif (params.has(\"centroids\")) {\n\t\t\tcentroids = env.readCsvFile(params.get(\"centroids\"))\n\t\t\t\t.fieldDelimiter(\" \")\n\t\t\t\t.pojoType(Centroid.class, \"id\", \"x\", \"y\");\n\t\t} else {\n\t\t\tSystem.out.println(\"Executing K-Means example with default centroid data set.\");\n\t\t\tSystem.out.println(\"Use --centroids to specify file input.\");\n\t\t\tcentroids = KMeansData.getDefaultCentroidDataSet(env);\n\t\t}\n\t\treturn centroids;\n\t}", "category": "Python"}, {"instruction": "Get Metadata.\n\n@param request  the request\n@param response the response\n@throws Exception the exception", "input": "Java", "output": "@GetMapping(path = WSFederationConstants.ENDPOINT_FEDERATION_METADATA)\n    public void doGet(final HttpServletRequest request, final HttpServletResponse response) throws Exception {\n        try {\n            response.setContentType(MediaType.TEXT_HTML_VALUE);\n            val out = response.getWriter();\n            val metadata = WSFederationMetadataWriter.produceMetadataDocument(casProperties);\n            out.write(DOM2Writer.nodeToString(metadata));\n        } catch (final Exception ex) {\n            LOGGER.error(\"Failed to get metadata document\", ex);\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        }\n    }", "category": "Python"}, {"instruction": "Calculate percentage of instances online\n\n@param collectorItemId Collector Item Id of deploy\n@return percentage of instances online", "input": "Java", "output": "private Double fetchInstancesOnlineRatio(ObjectId collectorItemId) {\n    int totalInstances = 0, totalInstancesOnline = 0;\n    Double instancesOnlineScore = null;\n\n    List<EnvironmentStatus> statuses = environmentStatusRepository\n      .findByCollectorItemId(collectorItemId);\n\n    if (null == statuses || statuses.isEmpty()) {\n      return null;\n    }\n\n    for (EnvironmentStatus environmentStatus : statuses) {\n      totalInstances++;\n      if (environmentStatus.isOnline()) {\n        totalInstancesOnline++;\n      }\n    }\n    instancesOnlineScore = ((totalInstancesOnline * 100) / (double) totalInstances);\n    LOGGER.info(\"totalInstances \" + totalInstances + \" totalInstancesOnline \" + totalInstancesOnline + \" instancesOnlineScore \" + instancesOnlineScore);\n\n    return instancesOnlineScore;\n  }", "category": "Python"}, {"instruction": "Create a {@link LinkedHashMap} from an array of values.\n\n@param values The values\n@return The created map", "input": "Java", "output": "@UsedByGeneratedCode\n    public static Map mapOf(Object... values) {\n        int len = values.length;\n        if (len % 2 != 0) {\n            throw new IllegalArgumentException(\"Number of arguments should be an even number representing the keys and values\");\n        }\n\n        Map answer = new LinkedHashMap(len / 2);\n        int i = 0;\n        while (i < values.length - 1) {\n            answer.put(values[i++], values[i++]);\n        }\n        return answer;\n    }", "category": "Python"}, {"instruction": "Increases the current backoff and returns whether the operation was successful.\n\n@return <code>true</code>, iff the operation was successful. Otherwise, <code>false</code>.", "input": "Java", "output": "protected boolean increaseBackoff() {\n\t\t// Backoff is disabled\n\t\tif (currentBackoff < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// This is the first time backing off\n\t\tif (currentBackoff == 0) {\n\t\t\tcurrentBackoff = initialBackoff;\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Continue backing off\n\t\telse if (currentBackoff < maxBackoff) {\n\t\t\tcurrentBackoff = Math.min(currentBackoff * 2, maxBackoff);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Reached maximum backoff\n\t\treturn false;\n\t}", "category": "Python"}, {"instruction": "Register SQL.\n\n@param sql SQL\n@param parametersCount parameters count\n@return statement ID", "input": "Java", "output": "public synchronized int register(final String sql, final int parametersCount) {\n        Integer result = statementIdAssigner.get(sql);\n        if (null != result) {\n            return result;\n        }\n        result = sequence.incrementAndGet();\n        statementIdAssigner.putIfAbsent(sql, result);\n        binaryStatements.putIfAbsent(result, new MySQLBinaryStatement(sql, parametersCount));\n        return result;\n    }", "category": "Python"}, {"instruction": "\u5339\u914d\u6587\u672c\n\n@param text      \u6587\u672c\n@param processor \u5904\u7406\u5668", "input": "Java", "output": "public void parseText(String text, AhoCorasickDoubleArrayTrie.IHit<V> processor)\n    {\n        int length = text.length();\n        int begin = 0;\n        BaseNode<V> state = this;\n\n        for (int i = begin; i < length; ++i)\n        {\n            state = state.transition(text.charAt(i));\n            if (state != null)\n            {\n                V value = state.getValue();\n                if (value != null)\n                {\n                    processor.hit(begin, i + 1, value);\n                }\n            }\n            else\n            {\n                i = begin;\n                ++begin;\n                state = this;\n            }\n        }\n    }", "category": "Python"}, {"instruction": "Returns the host via {@link InetSocketAddress#getHostString} if it is possible,\ni.e. in jdk >= 7.\nOtherwise, return it via {@link InetSocketAddress#getHostName} which may incur a DNS lookup.", "input": "Java", "output": "public static String getHost(InetSocketAddress addr) {\n    try {\n      Method getHostStringMethod = InetSocketAddress.class.getMethod(\"getHostString\");\n      return (String) getHostStringMethod.invoke(addr);\n    } catch (NoSuchMethodException e) {\n      // noop\n    } catch (IllegalAccessException e) {\n      // noop\n    } catch (InvocationTargetException e) {\n      // noop\n    }\n    return addr.getHostName();\n  }", "category": "Python"}, {"instruction": "Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise", "input": "Java", "output": "public boolean isSet(_Fields field) {\n    if (field == null) {\n      throw new IllegalArgumentException();\n    }\n\n    switch (field) {\n    case SESSION_HANDLE:\n      return isSetSessionHandle();\n    case CATALOG_NAME:\n      return isSetCatalogName();\n    case SCHEMA_NAME:\n      return isSetSchemaName();\n    case TABLE_NAME:\n      return isSetTableName();\n    case TABLE_TYPES:\n      return isSetTableTypes();\n    }\n    throw new IllegalStateException();\n  }", "category": "Python"}, {"instruction": "This method reconnects given node to another node", "input": "Java", "output": "public synchronized void remapNode(@NonNull Node node) {\n        version++;\n\n        if (buildMode == MeshBuildMode.MESH) {\n            node.getUpstreamNode().removeFromDownstreams(node);\n\n            boolean m = false;\n            for (val n : sortedNodes) {\n                // we dont want to remap node to itself\n                if (!Objects.equals(n, node) && n.status().equals(NodeStatus.ONLINE)) {\n                    n.addDownstreamNode(node);\n                    m = true;\n                    break;\n                }\n            }\n\n            // if we were unable to find good enough node - we'll map this node to the rootNode\n            if (!m) {\n                rootNode.addDownstreamNode(node);\n            }\n\n            // i hope we won't deadlock here? :)\n            synchronized (this) {\n                Collections.sort(sortedNodes);\n            }\n        } else if (buildMode == MeshBuildMode.PLAIN) {\n            // nothing to do here\n        }\n    }", "category": "Python"}, {"instruction": "Reads the contents of the user-specified {@code filePath} based on the given {@link FileInputFormat}.\nDepending on the provided {@link FileProcessingMode}, the source may periodically monitor (every {@code interval} ms)\nthe path for new data ({@link FileProcessingMode#PROCESS_CONTINUOUSLY}), or process once the data currently in the\npath and exit ({@link FileProcessingMode#PROCESS_ONCE}). In addition, if the path contains files not to be processed,\nthe user can specify a custom {@link FilePathFilter}. As a default implementation you can use\n{@link FilePathFilter#createDefaultFilter()}.\n\n<p><b>NOTES ON CHECKPOINTING: </b> If the {@code watchType} is set to {@link FileProcessingMode#PROCESS_ONCE},\nthe source monitors the path <b>once</b>, creates the {@link org.apache.flink.core.fs.FileInputSplit FileInputSplits}\nto be processed, forwards them to the downstream {@link ContinuousFileReaderOperator readers} to read the actual data,\nand exits, without waiting for the readers to finish reading. This implies that no more checkpoint barriers\nare going to be forwarded after the source exits, thus having no checkpoints after that point.\n\n@param inputFormat\nThe input format used to create the data stream\n@param filePath\nThe path of the file, as a URI (e.g., \"file:///some/local/file\" or \"hdfs://host:port/file/path\")\n@param watchType\nThe mode in which the source should operate, i.e. monitor path and react to new data, or process once and exit\n@param typeInformation\nInformation on the type of the elements in the output stream\n@param interval\nIn the case of periodic path monitoring, this specifies the interval (in millis) between consecutive path scans\n@param <OUT>\nThe type of the returned data stream\n@return The data stream that represents the data read from the given file", "input": "Java", "output": "@PublicEvolving\n\tpublic <OUT> DataStreamSource<OUT> readFile(FileInputFormat<OUT> inputFormat,\n\t\t\t\t\t\t\t\t\t\t\t\tString filePath,\n\t\t\t\t\t\t\t\t\t\t\t\tFileProcessingMode watchType,\n\t\t\t\t\t\t\t\t\t\t\t\tlong interval,\n\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<OUT> typeInformation) {\n\n\t\tPreconditions.checkNotNull(inputFormat, \"InputFormat must not be null.\");\n\t\tPreconditions.checkArgument(!StringUtils.isNullOrWhitespaceOnly(filePath), \"The file path must not be null or blank.\");\n\n\t\tinputFormat.setFilePath(filePath);\n\t\treturn createFileInput(inputFormat, typeInformation, \"Custom File Source\", watchType, interval);\n\t}", "category": "Python"}, {"instruction": "def get_report(self):\n    \"\"\" describe the graph\n\n    :returns: report\n    :rtype: string\n    \"\"\"\n", "input": "", "output": "    ostr = ''\n    ostr += \"Nodes: \"+str(len(self.__nodes.keys()))+\"\\n\"\n    ostr += \"Edges: \"+str(len(self.__edges.keys()))+\"\\n\"\n    return ostr", "category": "Python"}]