[{"instruction": "\u6362\u7b97\u6cd5\uff1f MD5  SHA-1 MurMurHash???\n\n@param value the value\n@return the byte []", "input": "Java", "output": "public static byte[] messageDigest(String value) {\n        MessageDigest md5;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(value.getBytes(\"UTF-8\"));\n            return md5.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new SofaRpcRuntimeException(\"No such algorithm named md5\", e);\n        } catch (UnsupportedEncodingException e) {\n            throw new SofaRpcRuntimeException(\"Unsupported encoding of\" + value, e);\n        }\n    }"}, {"instruction": "Returns the double data\nfor this ndarray.\nIf possible (the offset is 0 representing the whole buffer)\nit will return a direct reference to the underlying array\n@param buf the ndarray to get the data for\n@return the double data for this ndarray", "input": "Java", "output": "public static double[] getDoubleData(INDArray buf) {\n        if (buf.data().dataType() != DataType.DOUBLE)\n            throw new IllegalArgumentException(\"Double data must be obtained from a double buffer\");\n\n        if (buf.data().allocationMode() == DataBuffer.AllocationMode.HEAP) {\n            return buf.data().asDouble();\n\n        } else {\n            double[] ret = new double[(int) buf.length()];\n            INDArray linear = buf.reshape(-1);\n            for (int i = 0; i < buf.length(); i++)\n                ret[i] = linear.getDouble(i);\n            return ret;\n\n        }\n    }"}, {"instruction": "Gets origin weight.\n\n@return the origin weight", "input": "Java", "output": "public int getOriginWeight() {\n        if (originWeight == null) {\n            if (providerInfo == null) {\n                originWeight = RpcConfigs.getIntValue(RpcOptions.PROVIDER_WEIGHT);\n            } else {\n                originWeight = CommonUtils.parseInt(providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_WEIGHT),\n                    RpcConfigs.getIntValue(RpcOptions.PROVIDER_WEIGHT));\n            }\n        }\n        return originWeight;\n    }"}, {"instruction": "Generate the output for all examples/batches in the input iterator, and concatenate them into a single array\nper network output\n\n@param iterator Data to pass through the network\n@return output for all examples in the iterator", "input": "Java", "output": "public INDArray[] output(MultiDataSetIterator iterator){\n        List<INDArray[]> outputs = new ArrayList<>();\n        while(iterator.hasNext()){\n            MultiDataSet next = iterator.next();\n            INDArray[] out = output(false, next.getFeatures(), next.getFeaturesMaskArrays(), next.getLabelsMaskArrays());\n            outputs.add(out);\n        }\n        INDArray[][] arr = outputs.toArray(new INDArray[outputs.size()][0]);\n        return DataSetUtil.mergeFeatures(arr, null).getFirst();\n    }"}, {"instruction": "\u83b7\u53d6\u5171\u73b0\u9891\u6b21\n\n@param a \u7b2c\u4e00\u4e2a\u8bcd\n@param b \u7b2c\u4e8c\u4e2a\u8bcd\n@return \u7b2c\u4e00\u4e2a\u8bcd@\u7b2c\u4e8c\u4e2a\u8bcd\u51fa\u73b0\u7684\u9891\u6b21", "input": "Java", "output": "public static int getBiFrequency(String a, String b)\n    {\n        int idA = CoreDictionary.trie.exactMatchSearch(a);\n        if (idA == -1)\n        {\n            return 0;\n        }\n        int idB = CoreDictionary.trie.exactMatchSearch(b);\n        if (idB == -1)\n        {\n            return 0;\n        }\n        int index = binarySearch(pair, start[idA], start[idA + 1] - start[idA], idB);\n        if (index < 0) return 0;\n        index <<= 1;\n        return pair[index + 1];\n    }"}, {"instruction": "Formats a link between two nodes\n\n@param from  from node\n@param to  to node\n@param label  label for this link\n@param tailport  tail port to use when formatting (dot-specific, \"sw\" or \"se)\n@return formatted link, not null", "input": "Java", "output": "private String formatPointer(PatriciaTrie.PatriciaNode<V> from, PatriciaTrie.PatriciaNode<V> to, String label,\n                    String tailport) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(getNodeId(from));\n        builder.append(\" -> \");\n        builder.append(getNodeId(to));\n        builder.append(\" [ \");\n        builder.append(\"label=\\\"\");\n        builder.append(label);\n        builder.append(\" \\\"\");\n        builder.append(\"tailport=\\\"\");\n        builder.append(tailport);\n        builder.append(\" \\\"\");\n        builder.append(\"fontcolor=\\\"#666666\\\" \");\n        builder.append(\" ]\");\n        builder.append(\"\\n\");\n        return builder.toString();\n    }"}, {"instruction": "Return big decimal from buffer.\n\n@see mysql-5.1.60/strings/decimal.c - bin2decimal()", "input": "Java", "output": "public final BigDecimal getDecimal(final int pos, final int precision, final int scale) {\r\n        final int intg = precision - scale;\r\n        final int frac = scale;\r\n        final int intg0 = intg / DIG_PER_INT32;\r\n        final int frac0 = frac / DIG_PER_INT32;\r\n        final int intg0x = intg - intg0 * DIG_PER_INT32;\r\n        final int frac0x = frac - frac0 * DIG_PER_INT32;\r\n\r\n        final int binSize = intg0 * SIZE_OF_INT32 + dig2bytes[intg0x] + frac0 * SIZE_OF_INT32 + dig2bytes[frac0x];\r\n        if (pos + binSize > limit || pos < 0) {\r\n            throw new IllegalArgumentException(\"limit excceed: \" + (pos < 0 ? pos : (pos + binSize)));\r\n        }\r\n        return getDecimal0(origin + pos, intg, frac, // NL\r\n            intg0,\r\n            frac0,\r\n            intg0x,\r\n            frac0x);\r\n    }"}, {"instruction": "Fails all pending checkpoints which have not been acknowledged by the given execution\nattempt id.\n\n@param executionAttemptId for which to discard unacknowledged pending checkpoints\n@param cause of the failure", "input": "Java", "output": "public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {\n\t\tsynchronized (lock) {\n\t\t\tIterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator();\n\n\t\t\twhile (pendingCheckpointIterator.hasNext()) {\n\t\t\t\tfinal PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next();\n\n\t\t\t\tif (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {\n\t\t\t\t\tpendingCheckpointIterator.remove();\n\t\t\t\t\tdiscardCheckpoint(pendingCheckpoint, cause);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"}, {"instruction": "normal login handler part //todo: consider using mostly the same code as in proxy part below", "input": "Java", "output": "@Override\n  public boolean loginHandler(String target, HttpServletRequest request, HttpServletResponse response) throws IOException {\n    if (! isLoginTarget(target)) {\n      return false;\n    }\n\n    if (isPageRequest(request)) {\n      sendLoginForm(request, response);\n    } else {\n      ServletUtils.sendResponseError(response, HttpServletResponse.SC_UNAUTHORIZED, \"Access denied. Please login.\");\n    }\n    return true;\n  }"}, {"instruction": "Retrieve a workflow by workflow id\n\n@param workflowId   the id of the workflow\n@param includeTasks specify if the tasks in the workflow need to be returned\n@return the requested workflow", "input": "Java", "output": "public Workflow getWorkflow(String workflowId, boolean includeTasks) {\n        Preconditions.checkArgument(StringUtils.isNotBlank(workflowId), \"workflow id cannot be blank\");\n        WorkflowPb.Workflow workflow = stub.getWorkflowStatus(\n                WorkflowServicePb.GetWorkflowStatusRequest.newBuilder()\n                        .setWorkflowId(workflowId)\n                        .setIncludeTasks(includeTasks)\n                        .build()\n        );\n        return protoMapper.fromProto(workflow);\n    }"}, {"instruction": "Returns a slot that has been allocated from this instance. The slot needs have been canceled\nprior to calling this method.\n\n<p>The method will transition the slot to the \"released\" state. If the slot is already in state\n\"released\", this method will do nothing.</p>\n\n@param logicalSlot The slot to return.\n@return Future which is completed with true, if the slot was returned, false if not.", "input": "Java", "output": "@Override\n\tpublic void returnLogicalSlot(LogicalSlot logicalSlot) {\n\t\tcheckNotNull(logicalSlot);\n\t\tcheckArgument(logicalSlot instanceof Slot);\n\n\t\tfinal Slot slot = ((Slot) logicalSlot);\n\t\tcheckArgument(!slot.isAlive(), \"slot is still alive\");\n\t\tcheckArgument(slot.getOwner() == this, \"slot belongs to the wrong TaskManager.\");\n\n\t\tif (slot.markReleased()) {\n\t\t\tLOG.debug(\"Return allocated slot {}.\", slot);\n\t\t\tsynchronized (instanceLock) {\n\t\t\t\tif (isDead) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (this.allocatedSlots.remove(slot)) {\n\t\t\t\t\tthis.availableSlots.add(slot.getSlotNumber());\n\n\t\t\t\t\tif (this.slotAvailabilityListener != null) {\n\t\t\t\t\t\tthis.slotAvailabilityListener.newSlotAvailable(this);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Slot was not allocated from this TaskManager.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"}, {"instruction": "Based on the ConciseSet implementation by Alessandro Colantonio", "input": "Java", "output": "private static void trimZeros(IntList set)\n  {\n    // loop over ALL_ZEROS_LITERAL words\n    int w;\n    int last = set.length() - 1;\n    do {\n      w = set.get(last);\n      if (w == ConciseSetUtils.ALL_ZEROS_LITERAL) {\n        set.set(last, 0);\n        last--;\n      } else if (ConciseSetUtils.isZeroSequence(w)) {\n        if (ConciseSetUtils.isSequenceWithNoBits(w)) {\n          set.set(last, 0);\n          last--;\n        } else {\n          // convert the sequence in a 1-bit literal word\n          set.set(last, ConciseSetUtils.getLiteral(w, false));\n          return;\n        }\n      } else {\n        // one sequence or literal\n        return;\n      }\n      if (set.isEmpty() || last == -1) {\n        return;\n      }\n    } while (true);\n  }"}, {"instruction": "Get sharding encryptor.\n\n@param logicTableName logic table name\n@param columnName column name\n@return optional of sharding encryptor", "input": "Java", "output": "public Optional<ShardingEncryptor> getShardingEncryptor(final String logicTableName, final String columnName) {\n        for (ShardingEncryptorStrategy each : shardingEncryptorStrategies.values()) {\n            Optional<ShardingEncryptor> result = each.getShardingEncryptor(logicTableName, columnName);\n            if (result.isPresent()) {\n                return result;\n            }\n        }\n        return Optional.absent();\n    }"}, {"instruction": "Returns all unsaved resources of the given {@code addOns} and {@code extensions} wrapped in {@code <li>} elements or an\nempty {@code String} if there are no unsaved resources.\n\n@param addOns the add-ons that will be queried for unsaved resources\n@param extensions the extensions that will be queried for unsaved resources\n@return a {@code String} containing all unsaved resources or empty {@code String} if none\n@since 2.4.0\n@see Extension#getUnsavedResources()", "input": "Java", "output": "private static String getExtensionsUnsavedResources(Collection<AddOn> addOns, Set<Extension> extensions) {\n        List<String> unsavedResources = new ArrayList<>();\n        for (AddOn addOn : addOns) {\n            for (Extension extension : addOn.getLoadedExtensions()) {\n                if (!extension.isEnabled()) {\n                    continue;\n                }\n\n                List<String> resources = extension.getUnsavedResources();\n                if (resources != null) {\n                    unsavedResources.addAll(resources);\n                }\n            }\n        }\n        for (Extension extension : extensions) {\n            if (!extension.isEnabled()) {\n                continue;\n            }\n\n            List<String> resources = extension.getUnsavedResources();\n            if (resources != null) {\n                unsavedResources.addAll(resources);\n            }\n        }\n        return wrapEntriesInLiTags(unsavedResources);\n    }"}, {"instruction": "Start the environment specified.\n@param applicationContext the application context with the environment\n@return The environment within the context", "input": "Java", "output": "protected Environment startEnvironment(ApplicationContext applicationContext) {\n        if (!applicationContext.isRunning()) {\n            if (this instanceof PropertySource) {\n                applicationContext.getEnvironment().addPropertySource((PropertySource) this);\n            }\n\n            return applicationContext\n                    .start()\n                    .getEnvironment();\n        } else {\n            return applicationContext.getEnvironment();\n        }\n    }"}, {"instruction": "\u8f6c\u4e49\u4e0d\u53ef\u89c1\u5b57\u7b26<br>\n\u89c1\uff1ahttps://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF\n\n@param c \u5b57\u7b26\n@return \u8f6c\u4e49\u540e\u7684\u5b57\u7b26\u4e32", "input": "Java", "output": "private static String escape(char c) {\r\n\t\tswitch (c) {\r\n\t\tcase '\\b':\r\n\t\t\treturn \"\\\\b\";\r\n\t\tcase '\\t':\r\n\t\t\treturn \"\\\\t\";\r\n\t\tcase '\\n':\r\n\t\t\treturn \"\\\\n\";\r\n\t\tcase '\\f':\r\n\t\t\treturn \"\\\\f\";\r\n\t\tcase '\\r':\r\n\t\t\treturn \"\\\\r\";\r\n\t\tdefault:\r\n\t\t\tif (c < StrUtil.C_SPACE || //\r\n\t\t\t\t\t(c >= '\\u0080' && c <= '\\u00a0') || //\r\n\t\t\t\t\t(c >= '\\u2000' && c <= '\\u2010') || //\r\n\t\t\t\t\t(c >= '\\u2028' && c <= '\\u202F') || //\r\n\t\t\t\t\t(c >= '\\u2066' && c <= '\\u206F')//\r\n\t\t\t) {\r\n\t\t\t\treturn HexUtil.toUnicodeHex(c);\r\n\t\t\t} else {\r\n\t\t\t\treturn Character.toString(c);\r\n\t\t\t}\r\n\t\t}\r\n\t}"}, {"instruction": "Returns the type information factory for a type using the factory registry or annotations.", "input": "Java", "output": "@Internal\n\tpublic static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {\n\t\tfinal Class<?> factoryClass;\n\t\tif (registeredTypeInfoFactories.containsKey(t)) {\n\t\t\tfactoryClass = registeredTypeInfoFactories.get(t);\n\t\t}\n\t\telse {\n\t\t\tif (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfinal TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class);\n\t\t\tfactoryClass = typeInfoAnnotation.value();\n\t\t\t// check for valid factory class\n\t\t\tif (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {\n\t\t\t\tthrow new InvalidTypesException(\"TypeInfo annotation does not specify a valid TypeInfoFactory.\");\n\t\t\t}\n\t\t}\n\n\t\t// instantiate\n\t\treturn (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass);\n\t}"}, {"instruction": "/* (non-Javadoc)\n@see org.parosproxy.paros.db.paros.TableContext#insert(int, int, java.lang.String)", "input": "Java", "output": "@Override\r\n\tpublic synchronized RecordContext insert(int contextId, int type, String url) throws DatabaseException {\r\n        try {\r\n\t\t\tpsInsert.setInt(1, contextId);\r\n\t\t\tpsInsert.setInt(2, type);\r\n\t\t\tpsInsert.setString(3, url);\r\n\t\t\tpsInsert.executeUpdate();\r\n\t\t\t\r\n\t\t\tlong id;\r\n\t\t\ttry (ResultSet rs = psGetIdLastInsert.executeQuery()) {\r\n\t\t\t\trs.next();\r\n\t\t\t\tid = rs.getLong(1);\r\n\t\t\t}\r\n\t\t\treturn read(id);\r\n\t\t} catch (SQLException e) {\r\n\t\t\tthrow new DatabaseException(e);\r\n\t\t}\r\n\t\t\r\n    }"}, {"instruction": "ZAP: New method checking for connection upgrade.\n\n@return True if this connection should be upgraded to WebSockets.", "input": "Java", "output": "public boolean isWebSocketUpgrade() {\r\n\t\tif (!getResponseHeader().isEmpty()) {\r\n\t\t\tString connectionHeader = getResponseHeader().getHeader(\"connection\");\r\n\t\t\tString upgradeHeader = getResponseHeader().getHeader(\"upgrade\");\r\n\t\t\t\r\n\t\t\tif (connectionHeader != null && connectionHeader.equalsIgnoreCase(\"upgrade\")) {\r\n\t\t\t\tif (upgradeHeader != null && upgradeHeader.equalsIgnoreCase(\"websocket\")) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}"}, {"instruction": "Removes duplicate deterministic expressions. Preserves the relative order\nof the expressions in the list.", "input": "Java", "output": "private List<RowExpression> removeDuplicates(List<RowExpression> expressions)\n    {\n        Set<RowExpression> seen = new HashSet<>();\n\n        ImmutableList.Builder<RowExpression> result = ImmutableList.builder();\n        for (RowExpression expression : expressions) {\n            if (!determinismEvaluator.isDeterministic(expression)) {\n                result.add(expression);\n            }\n            else if (!seen.contains(expression)) {\n                result.add(expression);\n                seen.add(expression);\n            }\n        }\n\n        return result.build();\n    }"}, {"instruction": "Gets a list from an object for the given key.  If the key is not present, this returns null.\nIf the value is not a List, throws an exception.", "input": "Java", "output": "@SuppressWarnings(\"unchecked\")\n  @Nullable\n  static List<?> getList(Map<String, ?> obj, String key) {\n    assert key != null;\n    if (!obj.containsKey(key)) {\n      return null;\n    }\n    Object value = obj.get(key);\n    if (!(value instanceof List)) {\n      throw new ClassCastException(\n          String.format(\"value '%s' for key '%s' in '%s' is not List\", value, key, obj));\n    }\n    return (List<?>) value;\n  }"}, {"instruction": "(and return Long.MIN_VALUE but this is a valid long return value).", "input": "Java", "output": "private static Long attemptUUIDParseLow(BufferedString str) {\n    final byte[] buf = str.getBuffer();\n    int i=str.getOffset();\n    if( i+36 > buf.length ) return markBad(str);\n    long lo=0;\n    lo = get2(lo,buf,(i+=2)-2);\n    lo = get2(lo,buf,(i+=2)-2);\n    lo = get2(lo,buf,(i+=2)-2);\n    lo = get2(lo,buf,(i+=2)-2);\n    if( buf[i++]!='-' ) return markBad(str);\n    lo = get2(lo,buf,(i+=2)-2);\n    lo = get2(lo,buf,(i+=2)-2);\n    if( buf[i++]!='-' ) return markBad(str);\n    lo = get2(lo,buf,(i+=2)-2);\n    return attemptUUIDParseEnd(str, lo, buf, i);\n  }"}, {"instruction": "Auto-widen the scalar to every element of the frame", "input": "Java", "output": "private ValFrame scalar_op_frame(final double d, Frame fr) {\n    Frame res = new MRTask() {\n      @Override\n      public void map(Chunk[] chks, NewChunk[] cress) {\n        for (int c = 0; c < chks.length; c++) {\n          Chunk chk = chks[c];\n          NewChunk cres = cress[c];\n          for (int i = 0; i < chk._len; i++)\n            cres.addNum(op(d, chk.atd(i)));\n        }\n      }\n    }.doAll(fr.numCols(), Vec.T_NUM, fr).outputFrame(fr._names, null);\n    return cleanCategorical(fr, res); // Cleanup categorical misuse\n  }"}, {"instruction": "Sets the deprecation status of an image.\n\n<p>If an empty request body is given, clears the deprecation status instead.\n\n<p>Sample code:\n\n<pre><code>\ntry (ImageClient imageClient = ImageClient.create()) {\nProjectGlobalImageName image = ProjectGlobalImageName.of(\"[PROJECT]\", \"[IMAGE]\");\nDeprecationStatus deprecationStatusResource = DeprecationStatus.newBuilder().build();\nOperation response = imageClient.deprecateImage(image, deprecationStatusResource);\n}\n</code></pre>\n\n@param image Image name.\n@param deprecationStatusResource Deprecation status for a public resource.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation deprecateImage(\n      ProjectGlobalImageName image, DeprecationStatus deprecationStatusResource) {\n\n    DeprecateImageHttpRequest request =\n        DeprecateImageHttpRequest.newBuilder()\n            .setImage(image == null ? null : image.toString())\n            .setDeprecationStatusResource(deprecationStatusResource)\n            .build();\n    return deprecateImage(request);\n  }"}, {"instruction": "Tries to find a {@link SerializedThrowable} as the cause of the given throwable and throws its\ndeserialized value. If there is no such throwable, then the original throwable is thrown.\n\n@param throwable to check for a SerializedThrowable\n@param classLoader to be used for the deserialization of the SerializedThrowable\n@throws Throwable either the deserialized throwable or the given throwable", "input": "Java", "output": "public static void tryDeserializeAndThrow(Throwable throwable, ClassLoader classLoader) throws Throwable {\n\t\tThrowable current = throwable;\n\n\t\twhile (!(current instanceof SerializedThrowable) && current.getCause() != null) {\n\t\t\tcurrent = current.getCause();\n\t\t}\n\n\t\tif (current instanceof SerializedThrowable) {\n\t\t\tthrow ((SerializedThrowable) current).deserializeError(classLoader);\n\t\t} else {\n\t\t\tthrow throwable;\n\t\t}\n\t}"}, {"instruction": "\u5378\u8f7d\u6a21\u5757\n\n@param moduleName module name", "input": "Java", "output": "public static void uninstallModule(String moduleName) {\n        Module module = INSTALLED_MODULES.get(moduleName);\n        if (module != null) {\n            try {\n                module.uninstall();\n                INSTALLED_MODULES.remove(moduleName);\n            } catch (Exception e) {\n                if (LOGGER.isWarnEnabled()) {\n                    LOGGER.warn(\"Error when uninstall module \" + moduleName, e);\n                }\n            }\n        }\n    }"}, {"instruction": "Method returns an Optional that will contain a {@link MultifactorAuthenticationProvider} that has the\nsame id as the passed providerId parameter.\n\n@param providerId - the id to match\n@param context    - ApplicationContext\n@return - Optional", "input": "Java", "output": "public static Optional<MultifactorAuthenticationProvider> getMultifactorAuthenticationProviderById(final String providerId,\n                                                                                                       final ApplicationContext context) {\n        return getAvailableMultifactorAuthenticationProviders(context).values()\n            .stream()\n            .filter(p -> p.matches(providerId))\n            .findFirst();\n    }"}, {"instruction": "Sends the response headers to the client.", "input": "Java", "output": "private void sendResponseHeaders(ChannelHandlerContext ctx, SendResponseHeadersCommand cmd,\n      ChannelPromise promise) throws Http2Exception {\n    // TODO(carl-mastrangelo): remove this check once https://github.com/netty/netty/issues/6296 is\n    // fixed.\n    int streamId = cmd.stream().id();\n    Http2Stream stream = connection().stream(streamId);\n    if (stream == null) {\n      resetStream(ctx, streamId, Http2Error.CANCEL.code(), promise);\n      return;\n    }\n    if (cmd.endOfStream()) {\n      closeStreamWhenDone(promise, streamId);\n    }\n    encoder().writeHeaders(ctx, streamId, cmd.headers(), 0, cmd.endOfStream(), promise);\n  }"}, {"instruction": "Build the ticket properties.\n\n@param webContext the web context\n@return the ticket properties", "input": "Java", "output": "protected Map<String, Serializable> buildTicketProperties(final J2EContext webContext) {\n        val properties = new HashMap<String, Serializable>();\n\n        val themeParamName = casProperties.getTheme().getParamName();\n        val localParamName = casProperties.getLocale().getParamName();\n\n        properties.put(themeParamName, StringUtils.defaultString(webContext.getRequestParameter(themeParamName)));\n        properties.put(localParamName, StringUtils.defaultString(webContext.getRequestParameter(localParamName)));\n        properties.put(CasProtocolConstants.PARAMETER_METHOD,\n            StringUtils.defaultString(webContext.getRequestParameter(CasProtocolConstants.PARAMETER_METHOD)));\n\n        return properties;\n    }"}, {"instruction": "Serialize array data linearly.", "input": "Java", "output": "public void write(DataOutput out) throws IOException {\n        if (array == null) {\n            out.write(NDARRAY_SER_VERSION_HEADER_NULL);\n            return;\n        }\n\n        INDArray toWrite;\n        if (array.isView()) {\n            toWrite = array.dup();\n        } else {\n            toWrite = array;\n        }\n\n        //Write version header: this allows us to maintain backward compatibility in the future,\n        // with features such as compression, sparse arrays or changes on the DataVec side\n        out.write(NDARRAY_SER_VERSION_HEADER);\n        Nd4j.write(toWrite, new DataOutputStream(new DataOutputWrapperStream(out)));\n    }"}, {"instruction": "Only for debugging.\nPrints local timeline to stdout.\n\nTo be used in case of an error when global timeline can not be relied upon as we might not be able to talk to other nodes.", "input": "Java", "output": "static void printMyTimeLine(){\n    long [] s = TimeLine.snapshot();\n    System.err.println(\"===================================<TIMELINE>==============================================\");\n    for(int i = 0; i < TimeLine.length(); ++i) {\n      long lo = TimeLine.l0(s, i),hi = TimeLine.l8(s, i);\n      int port = (int)((lo >> 8) & 0xFFFF);\n      String op = TimeLine.send_recv(s,i) == 0?\"SEND\":\"RECV\";\n      if(!TimeLine.isEmpty(s, i) && (lo & 0xFF) == UDP.udp.exec.ordinal())\n        System.err.println(TimeLine.ms(s, i) + \": \" + op + \" \" + (((TimeLine.ns(s, i) & 4) != 0)?\"TCP\":\"UDP\")  +  TimeLine.inet(s, i) + \":\" + port + \" | \" + UDP.printx16(lo, hi));\n    }\n    System.err.println(\"===========================================================================================\");\n  }"}, {"instruction": "Updates an instance's network interface. This method follows PATCH semantics.\n\n<p>Sample code:\n\n<pre><code>\ntry (InstanceClient instanceClient = InstanceClient.create()) {\nProjectZoneInstanceName instance = ProjectZoneInstanceName.of(\"[PROJECT]\", \"[ZONE]\", \"[INSTANCE]\");\nString networkInterface = \"\";\nNetworkInterface networkInterfaceResource = NetworkInterface.newBuilder().build();\nList&lt;String&gt; fieldMask = new ArrayList&lt;&gt;();\nOperation response = instanceClient.updateNetworkInterfaceInstance(instance, networkInterface, networkInterfaceResource, fieldMask);\n}\n</code></pre>\n\n@param instance The instance name for this request.\n@param networkInterface The name of the network interface to update.\n@param networkInterfaceResource A network interface resource attached to an instance.\n@param fieldMask The fields that should be serialized (even if they have empty values). If the\ncontaining message object has a non-null fieldmask, then all the fields in the field mask\n(and only those fields in the field mask) will be serialized. If the containing object does\nnot have a fieldmask, then only non-empty fields will be serialized.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation updateNetworkInterfaceInstance(\n      ProjectZoneInstanceName instance,\n      String networkInterface,\n      NetworkInterface networkInterfaceResource,\n      List<String> fieldMask) {\n\n    UpdateNetworkInterfaceInstanceHttpRequest request =\n        UpdateNetworkInterfaceInstanceHttpRequest.newBuilder()\n            .setInstance(instance == null ? null : instance.toString())\n            .setNetworkInterface(networkInterface)\n            .setNetworkInterfaceResource(networkInterfaceResource)\n            .addAllFieldMask(fieldMask)\n            .build();\n    return updateNetworkInterfaceInstance(request);\n  }"}, {"instruction": "Normalize by zero mean unit variance\n\n@param frame the data to normalize\n@return a zero mean unit variance centered\nrdd", "input": "Java", "output": "public static DataRowsFacade zeromeanUnitVariance(DataRowsFacade frame, List<String> skipColumns) {\n        List<String> columnsList = DataFrames.toList(frame.get().columns());\n        columnsList.removeAll(skipColumns);\n        String[] columnNames = DataFrames.toArray(columnsList);\n        //first row is std second row is mean, each column in a row is for a particular column\n        List<Row> stdDevMean = stdDevMeanColumns(frame, columnNames);\n        for (int i = 0; i < columnNames.length; i++) {\n            String columnName = columnNames[i];\n            double std = ((Number) stdDevMean.get(0).get(i)).doubleValue();\n            double mean = ((Number) stdDevMean.get(1).get(i)).doubleValue();\n            if (std == 0.0)\n                std = 1; //All same value -> (x-x)/1 = 0\n\n            frame = dataRows(frame.get().withColumn(columnName, frame.get().col(columnName).minus(mean).divide(std)));\n        }\n\n\n\n        return frame;\n    }"}, {"instruction": "Shuts down the checkpoint coordinator.\n\n<p>After this method has been called, the coordinator does not accept\nand further messages and cannot trigger any further checkpoints.", "input": "Java", "output": "public void shutdown(JobStatus jobStatus) throws Exception {\n\t\tsynchronized (lock) {\n\t\t\tif (!shutdown) {\n\t\t\t\tshutdown = true;\n\t\t\t\tLOG.info(\"Stopping checkpoint coordinator for job {}.\", job);\n\n\t\t\t\tperiodicScheduling = false;\n\t\t\t\ttriggerRequestQueued = false;\n\n\t\t\t\t// shut down the hooks\n\t\t\t\tMasterHooks.close(masterHooks.values(), LOG);\n\t\t\t\tmasterHooks.clear();\n\n\t\t\t\t// shut down the thread that handles the timeouts and pending triggers\n\t\t\t\ttimer.shutdownNow();\n\n\t\t\t\t// clear and discard all pending checkpoints\n\t\t\t\tfor (PendingCheckpoint pending : pendingCheckpoints.values()) {\n\t\t\t\t\tpending.abort(CheckpointFailureReason.CHECKPOINT_COORDINATOR_SHUTDOWN);\n\t\t\t\t}\n\t\t\t\tpendingCheckpoints.clear();\n\n\t\t\t\tcompletedCheckpointStore.shutdown(jobStatus);\n\t\t\t\tcheckpointIdCounter.shutdown(jobStatus);\n\t\t\t}\n\t\t}\n\t}"}, {"instruction": "Create default global exception handlers.\n\n@param flow the flow", "input": "Java", "output": "protected void createDefaultEndStates(final Flow flow) {\n        createRedirectUnauthorizedServiceUrlEndState(flow);\n        createServiceErrorEndState(flow);\n        createRedirectEndState(flow);\n        createPostEndState(flow);\n        createInjectHeadersActionState(flow);\n        createGenericLoginSuccessEndState(flow);\n        createServiceWarningViewState(flow);\n        createEndWebflowEndState(flow);\n    }"}, {"instruction": "Returns the index within this string of the first occurrence of the\nspecified substring. If it is not a substring, return -1.\n\n@param content the content where we've to search into\n@return the index of the occurrence or -1 if no occurrence has been found", "input": "Java", "output": "public int findInContent(String content) {\r\n        int n = content.length();\r\n        int m = pattern.length();\r\n        int skip;\r\n        char val;\r\n\r\n        for (int i = 0; i <= n - m; i = i + skip) {\r\n            skip = 0;\r\n            for (int j = m - 1; j >= 0; j--) {\r\n                if (pattern.charAt(j) != content.charAt(i + j)) {\r\n                    val = content.charAt(i + j);\r\n\r\n                    skip = (occurrence.get(val) != null) ?\r\n                            Math.max(1, j - occurrence.get(val)) :\r\n                            j + 1;\r\n\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (skip == 0) {\r\n                return i;\r\n            }\r\n        }\r\n        \r\n        return -1;\r\n    }"}, {"instruction": "Read some bytes from the stream.\n@param b The byte array that will hold the contents from the stream.\n@param off The offset into the byte array at which bytes will start to be\nplaced.\n@param len the maximum number of bytes that can be returned.\n@return The number of bytes returned or -1 if the end of stream has been\nreached.\n@see java.io.InputStream#read(byte[], int, int)\n@throws IOException if an IO problem occurs.", "input": "Java", "output": "@Override\n    public int read (byte[] b, int off, int len) throws IOException {\n\n        if (closed) {\n            throw new IOException(\"Attempted read from closed stream.\");\n        }\n\n        if (eof) {\n            return -1;\n        }\n        if (pos >= chunkSize) {\n            nextChunk();\n            if (eof) {\n                return -1;\n            }\n        }\n        len = Math.min(len, chunkSize - pos);\n        int count = in.read(b, off, len);\n        pos += count;\n        return count;\n    }"}, {"instruction": "\u4ececontent\u4e2d\u5339\u914d\u51fa\u591a\u4e2a\u503c\u5e76\u6839\u636etemplate\u751f\u6210\u65b0\u7684\u5b57\u7b26\u4e32<br>\n\u5339\u914d\u7ed3\u675f\u540e\u4f1a\u5220\u9664\u5339\u914d\u5185\u5bb9\u4e4b\u524d\u7684\u5185\u5bb9\uff08\u5305\u62ec\u5339\u914d\u5185\u5bb9\uff09<br>\n\u4f8b\u5982\uff1a<br>\ncontent 2013\u5e745\u6708 pattern (.*?)\u5e74(.*?)\u6708 template\uff1a $1-$2 return 2013-5\n\n@param pattern \u5339\u914d\u6b63\u5219\n@param contentHolder \u88ab\u5339\u914d\u7684\u5185\u5bb9\u7684Holder\uff0cvalue\u4e3a\u5185\u5bb9\u6b63\u6587\uff0c\u7ecf\u8fc7\u8fd9\u4e2a\u65b9\u6cd5\u7684\u539f\u6587\u5c06\u88ab\u53bb\u6389\u5339\u914d\u4e4b\u524d\u7684\u5185\u5bb9\n@param template \u751f\u6210\u5185\u5bb9\u6a21\u677f\uff0c\u53d8\u91cf $1 \u8868\u793agroup1\u7684\u5185\u5bb9\uff0c\u4ee5\u6b64\u7c7b\u63a8\n@return \u65b0\u5b57\u7b26\u4e32", "input": "Java", "output": "public static String extractMultiAndDelPre(Pattern pattern, Holder<CharSequence> contentHolder, String template) {\r\n\t\tif (null == contentHolder || null == pattern || null == template) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tHashSet<String> varNums = findAll(PatternPool.GROUP_VAR, template, 1, new HashSet<String>());\r\n\r\n\t\tfinal CharSequence content = contentHolder.get();\r\n\t\tMatcher matcher = pattern.matcher(content);\r\n\t\tif (matcher.find()) {\r\n\t\t\tfor (String var : varNums) {\r\n\t\t\t\tint group = Integer.parseInt(var);\r\n\t\t\t\ttemplate = template.replace(\"$\" + var, matcher.group(group));\r\n\t\t\t}\r\n\t\t\tcontentHolder.set(StrUtil.sub(content, matcher.end(), content.length()));\r\n\t\t\treturn template;\r\n\t\t}\r\n\t\treturn null;\r\n\t}"}, {"instruction": "\u52a0\u5bc6\n\n@param data \u6570\u636e\n@param cipherKey \u5bc6\u94a5\n@return \u5bc6\u6587", "input": "Java", "output": "public static String encrypt(CharSequence data, CharSequence cipherKey) {\r\n\t\tfinal int dataLen = data.length();\r\n\t\tfinal int cipherKeyLen = cipherKey.length();\r\n\r\n\t\tfinal char[] cipherArray = new char[dataLen];\r\n\t\tfor (int i = 0; i < dataLen / cipherKeyLen + 1; i++) {\r\n\t\t\tfor (int t = 0; t < cipherKeyLen; t++) {\r\n\t\t\t\tif (t + i * cipherKeyLen < dataLen) {\r\n\t\t\t\t\tfinal char dataChar = data.charAt(t + i * cipherKeyLen);\r\n\t\t\t\t\tfinal char cipherKeyChar = cipherKey.charAt(t);\r\n\t\t\t\t\tcipherArray[t + i * cipherKeyLen] = (char) ((dataChar + cipherKeyChar - 64) % 95 + 32);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn String.valueOf(cipherArray);\r\n\t}"}, {"instruction": "icon ( or generic html if icon not available )", "input": "Java", "output": "private String getSingleSlotHtml(TestSlot s, String icon) {\n    StringBuilder builder = new StringBuilder();\n    TestSession session = s.getSession();\n    if (icon != null) {\n      builder.append(\"<img \");\n      builder.append(\"src='\").append(icon).append(\"' width='16' height='16'\");\n    } else {\n      builder.append(\"<a href='#' \");\n    }\n\n    if (session != null) {\n      builder.append(\" class='busy' \");\n      builder.append(\" title='\").append(session.get(\"lastCommand\")).append(\"' \");\n    } else {\n      builder.append(\" title='\").append(s.getCapabilities()).append(\"'\");\n    }\n\n    if (icon != null) {\n      builder.append(\" />\\n\");\n    } else {\n      builder.append(\">\");\n      builder.append(s.getCapabilities().get(CapabilityType.BROWSER_NAME));\n      builder.append(\"</a>\");\n    }\n    return builder.toString();\n  }"}, {"instruction": "This is more advanced and does not make use of the stub.  You should not normally need to do\nthis, but here is how you would.", "input": "Java", "output": "void advancedAsyncCall() {\n    ClientCall<HelloRequest, HelloReply> call =\n        channel.newCall(GreeterGrpc.getSayHelloMethod(), CallOptions.DEFAULT);\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    call.start(new ClientCall.Listener<HelloReply>() {\n\n      @Override\n      public void onClose(Status status, Metadata trailers) {\n        Verify.verify(status.getCode() == Status.Code.INTERNAL);\n        Verify.verify(status.getDescription().contains(\"Narwhal\"));\n        // Cause is not transmitted over the wire.\n        latch.countDown();\n      }\n    }, new Metadata());\n\n    call.sendMessage(HelloRequest.newBuilder().setName(\"Marge\").build());\n    call.halfClose();\n\n    if (!Uninterruptibles.awaitUninterruptibly(latch, 1, TimeUnit.SECONDS)) {\n      throw new RuntimeException(\"timeout!\");\n    }\n  }"}, {"instruction": "Schedules or updates the consumer tasks of the result partition with the given ID.", "input": "Java", "output": "void scheduleOrUpdateConsumers(ResultPartitionID partitionId) {\n\n\t\tfinal Execution execution = currentExecution;\n\n\t\t// Abort this request if there was a concurrent reset\n\t\tif (!partitionId.getProducerId().equals(execution.getAttemptId())) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal IntermediateResultPartition partition = resultPartitions.get(partitionId.getPartitionId());\n\n\t\tif (partition == null) {\n\t\t\tthrow new IllegalStateException(\"Unknown partition \" + partitionId + \".\");\n\t\t}\n\n\t\tpartition.markDataProduced();\n\n\t\tif (partition.getIntermediateResult().getResultType().isPipelined()) {\n\t\t\t// Schedule or update receivers of this partition\n\t\t\texecution.scheduleOrUpdateConsumers(partition.getConsumers());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"ScheduleOrUpdateConsumers msg is only valid for\" +\n\t\t\t\t\t\"pipelined partitions.\");\n\t\t}\n\t}"}, {"instruction": "Get activation enum value from Keras layer configuration.\n\n@param layerConfig dictionary containing Keras layer configuration\n@return DL4J activation enum value\n@throws InvalidKerasConfigurationException     Invalid Keras config\n@throws UnsupportedKerasConfigurationException Unsupported Keras config", "input": "Java", "output": "public static Activation getActivationFromConfig(Map<String, Object> layerConfig, KerasLayerConfiguration conf)\n            throws InvalidKerasConfigurationException, UnsupportedKerasConfigurationException {\n        Map<String, Object> innerConfig = KerasLayerUtils.getInnerLayerConfigFromConfig(layerConfig, conf);\n        if (!innerConfig.containsKey(conf.getLAYER_FIELD_ACTIVATION()))\n            throw new InvalidKerasConfigurationException(\"Keras layer is missing \"\n                    + conf.getLAYER_FIELD_ACTIVATION() + \" field\");\n        return mapToActivation((String) innerConfig.get(conf.getLAYER_FIELD_ACTIVATION()), conf);\n    }"}, {"instruction": "Initiates a forceful shutdown in which preexisting and new calls are cancelled. Although\nforceful, the shutdown process is still not instantaneous; {@link #isTerminated()} will likely\nreturn {@code false} immediately after this method returns.", "input": "Java", "output": "@Override\n  public ManagedChannelImpl shutdownNow() {\n    channelLogger.log(ChannelLogLevel.DEBUG, \"shutdownNow() called\");\n    shutdown();\n    uncommittedRetriableStreamsRegistry.onShutdownNow(SHUTDOWN_NOW_STATUS);\n    final class ShutdownNow implements Runnable {\n      @Override\n      public void run() {\n        if (shutdownNowed) {\n          return;\n        }\n        shutdownNowed = true;\n        maybeShutdownNowSubchannels();\n      }\n    }\n\n    syncContext.execute(new ShutdownNow());\n    return this;\n  }"}, {"instruction": "\u79fb\u52a8\u6587\u4ef6\u6216\u8005\u76ee\u5f55\n\n@param src \u6e90\u6587\u4ef6\u6216\u8005\u76ee\u5f55\n@param dest \u76ee\u6807\u6587\u4ef6\u6216\u8005\u76ee\u5f55\n@param isOverride \u662f\u5426\u8986\u76d6\u76ee\u6807\uff0c\u53ea\u6709\u76ee\u6807\u4e3a\u6587\u4ef6\u624d\u8986\u76d6\n@throws IORuntimeException IO\u5f02\u5e38", "input": "Java", "output": "public static void move(File src, File dest, boolean isOverride) throws IORuntimeException {\r\n\t\t// check\r\n\t\tif (false == src.exists()) {\r\n\t\t\tthrow new IORuntimeException(\"File not found: \" + src);\r\n\t\t}\r\n\r\n\t\t// \u6765\u6e90\u4e3a\u6587\u4ef6\u5939\uff0c\u76ee\u6807\u4e3a\u6587\u4ef6\r\n\t\tif (src.isDirectory() && dest.isFile()) {\r\n\t\t\tthrow new IORuntimeException(StrUtil.format(\"Can not move directory [{}] to file [{}]\", src, dest));\r\n\t\t}\r\n\r\n\t\tif (isOverride && dest.isFile()) {// \u53ea\u6709\u76ee\u6807\u4e3a\u6587\u4ef6\u7684\u60c5\u51b5\u4e0b\u8986\u76d6\u4e4b\r\n\t\t\tdest.delete();\r\n\t\t}\r\n\r\n\t\t// \u6765\u6e90\u4e3a\u6587\u4ef6\uff0c\u76ee\u6807\u4e3a\u6587\u4ef6\u5939\r\n\t\tif (src.isFile() && dest.isDirectory()) {\r\n\t\t\tdest = new File(dest, src.getName());\r\n\t\t}\r\n\r\n\t\tif (false == src.renameTo(dest)) {\r\n\t\t\t// \u5728\u6587\u4ef6\u7cfb\u7edf\u4e0d\u540c\u7684\u60c5\u51b5\u4e0b\uff0crenameTo\u4f1a\u5931\u8d25\uff0c\u6b64\u65f6\u4f7f\u7528copy\uff0c\u7136\u540e\u5220\u9664\u539f\u6587\u4ef6\r\n\t\t\ttry {\r\n\t\t\t\tcopy(src, dest, isOverride);\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\tthrow new IORuntimeException(StrUtil.format(\"Move [{}] to [{}] failed!\", src, dest), e);\r\n\t\t\t}\r\n\t\t\t// \u590d\u5236\u540e\u5220\u9664\u6e90\r\n\t\t\tdel(src);\r\n\t\t}\r\n\t}"}, {"instruction": "Create a new read only representation of headers used by servers.\n@param validateHeaders {@code true} will run validation on each header name/value pair to ensure protocol\ncompliance.\n@param status The value for {@link PseudoHeaderName#STATUS}.\n@param otherHeaders A an array of key:value pairs. Must not contain any\n<a href=\"https://tools.ietf.org/html/rfc7540#section-8.1.2.1\">pseudo headers</a>\nor {@code null} names/values.\nA copy will <strong>NOT</strong> be made of this array. If the contents of this array\nmay be modified externally you are responsible for passing in a copy.\n@return a new read only representation of headers used by servers.", "input": "Java", "output": "public static ReadOnlyHttp2Headers serverHeaders(boolean validateHeaders,\n                                                     AsciiString status,\n                                                     AsciiString... otherHeaders) {\n        return new ReadOnlyHttp2Headers(validateHeaders,\n                                        new AsciiString[] { PseudoHeaderName.STATUS.value(), status },\n                                        otherHeaders);\n    }"}, {"instruction": "init fxml when loaded.", "input": "Java", "output": "@PostConstruct\n    public void init() {\n        Timeline task = new Timeline(\n            new KeyFrame(\n                Duration.ZERO,\n                new KeyValue(progress1.progressProperty(), 0),\n                new KeyValue(progress2.progressProperty(), 0),\n                new KeyValue(progress2.secondaryProgressProperty(), 0.5)),\n            new KeyFrame(\n                Duration.seconds(1),\n                new KeyValue(progress2.secondaryProgressProperty(), 1)),\n            new KeyFrame(\n                Duration.seconds(2),\n                new KeyValue(progress1.progressProperty(), 1),\n                new KeyValue(progress2.progressProperty(), 1)));\n        task.setCycleCount(Timeline.INDEFINITE);\n        task.play();\n    }"}, {"instruction": "Leave the information about login failure.\n\n<p>\nOtherwise it seems like Acegi doesn't really leave the detail of the failure anywhere.", "input": "Java", "output": "@Override\n    protected void onUnsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException {\n        super.onUnsuccessfulAuthentication(request, response, failed);\n        LOGGER.log(Level.FINE, \"Login attempt failed\", failed);\n        Authentication auth = failed.getAuthentication();\n        if (auth != null) {\n            SecurityListener.fireFailedToLogIn(auth.getName());\n        }\n    }"}, {"instruction": "Retrieve instance of {@link HystrixConcurrencyStrategy} to use based on order of precedence as defined in {@link HystrixPlugins} class header.\n<p>\nOverride default by using {@link #registerConcurrencyStrategy(HystrixConcurrencyStrategy)} or setting property (via Archaius): <code>hystrix.plugin.HystrixConcurrencyStrategy.implementation</code> with the\nfull classname to load.\n\n@return {@link HystrixConcurrencyStrategy} implementation to use", "input": "Java", "output": "public HystrixConcurrencyStrategy getConcurrencyStrategy() {\n        if (concurrencyStrategy.get() == null) {\n            // check for an implementation from Archaius first\n            Object impl = getPluginImplementation(HystrixConcurrencyStrategy.class);\n            if (impl == null) {\n                // nothing set via Archaius so initialize with default\n                concurrencyStrategy.compareAndSet(null, HystrixConcurrencyStrategyDefault.getInstance());\n                // we don't return from here but call get() again in case of thread-race so the winner will always get returned\n            } else {\n                // we received an implementation from Archaius so use it\n                concurrencyStrategy.compareAndSet(null, (HystrixConcurrencyStrategy) impl);\n            }\n        }\n        return concurrencyStrategy.get();\n    }"}, {"instruction": "An expectation to check if js executable.\n\nUseful when you know that there should be a Javascript value or something at the stage.\n\n@param javaScript used as executable script\n@return true once javaScript executed without errors", "input": "Java", "output": "public static ExpectedCondition<Boolean> javaScriptThrowsNoExceptions(final String javaScript) {\n    return new ExpectedCondition<Boolean>() {\n      @Override\n      public Boolean apply(WebDriver driver) {\n        try {\n          ((JavascriptExecutor) driver).executeScript(javaScript);\n          return true;\n        } catch (WebDriverException e) {\n          return false;\n        }\n      }\n\n      @Override\n      public String toString() {\n        return String.format(\"js %s to be executable\", javaScript);\n      }\n    };\n  }"}, {"instruction": "For 'speed' reasons, Eclipse works a lot with char arrays. I have my doubts this was a fruitful exercise,\nbut we need to deal with it. This turns [[java][lang][String]] into \"java.lang.String\".", "input": "Java", "output": "public static String toQualifiedName(char[][] typeName) {\n\t\tint len = typeName.length - 1; // number of dots\n\t\tif (len == 0) return new String(typeName[0]);\n\t\t\n\t\tfor (char[] c : typeName) len += c.length;\n\t\tchar[] ret = new char[len];\n\t\tchar[] part = typeName[0];\n\t\tSystem.arraycopy(part, 0, ret, 0, part.length);\n\t\tint pos = part.length;\n\t\tfor (int i = 1; i < typeName.length; i++) {\n\t\t\tret[pos++] = '.';\n\t\t\tpart = typeName[i];\n\t\t\tSystem.arraycopy(part, 0, ret, pos, part.length);\n\t\t\tpos += part.length;\n\t\t}\n\t\treturn new String(ret);\n\t}"}, {"instruction": "Adds health check URLs to a target pool.\n\n<p>Sample code:\n\n<pre><code>\ntry (TargetPoolClient targetPoolClient = TargetPoolClient.create()) {\nProjectRegionTargetPoolName targetPool = ProjectRegionTargetPoolName.of(\"[PROJECT]\", \"[REGION]\", \"[TARGET_POOL]\");\nTargetPoolsAddHealthCheckRequest targetPoolsAddHealthCheckRequestResource = TargetPoolsAddHealthCheckRequest.newBuilder().build();\nOperation response = targetPoolClient.addHealthCheckTargetPool(targetPool.toString(), targetPoolsAddHealthCheckRequestResource);\n}\n</code></pre>\n\n@param targetPool Name of the target pool to add a health check to.\n@param targetPoolsAddHealthCheckRequestResource\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation addHealthCheckTargetPool(\n      String targetPool,\n      TargetPoolsAddHealthCheckRequest targetPoolsAddHealthCheckRequestResource) {\n\n    AddHealthCheckTargetPoolHttpRequest request =\n        AddHealthCheckTargetPoolHttpRequest.newBuilder()\n            .setTargetPool(targetPool)\n            .setTargetPoolsAddHealthCheckRequestResource(targetPoolsAddHealthCheckRequestResource)\n            .build();\n    return addHealthCheckTargetPool(request);\n  }"}, {"instruction": "This method duplicates array, and stores it to all devices\n\n@param array", "input": "Java", "output": "public void broadcast(INDArray array) {\n        if (array == null)\n            return;\n\n        Nd4j.getExecutioner().commit();\n\n        val config = OpProfiler.getInstance().getConfig();\n        val locality = config.isCheckLocality();\n\n        if (locality)\n            config.setCheckLocality(false);\n\n        int numDevices = Nd4j.getAffinityManager().getNumberOfDevices();\n        for (int i = 0; i < numDevices; i++) {\n            // if current thread equal to this device - we just save it, without duplication\n            if (Nd4j.getAffinityManager().getDeviceForCurrentThread() == i) {\n                set(i, array);\n            } else {\n                set(i, Nd4j.getAffinityManager().replicateToDevice(i, array));\n            }\n\n        }\n\n        config.setCheckLocality(locality);\n    }"}, {"instruction": "{@inheritDoc}", "input": "Java", "output": "@Override\n    public long reservePermission(Duration timeoutDuration) {\n        long timeoutInNanos = timeoutDuration.toNanos();\n        State modifiedState = updateStateWithBackOff(timeoutInNanos);\n\n        boolean canAcquireImmediately = modifiedState.nanosToWait <= 0;\n        if (canAcquireImmediately) {\n            publishRateLimiterEvent(true);\n            return 0;\n        }\n\n        boolean canAcquireInTime = timeoutInNanos >= modifiedState.nanosToWait;\n        if (canAcquireInTime) {\n            publishRateLimiterEvent(true);\n            return modifiedState.nanosToWait;\n        }\n\n        publishRateLimiterEvent(false);\n        return -1;\n    }"}, {"instruction": "Utility method that can be used by subclasses wishing to combine the specified\n{@link ServletContextInitializer} parameters with those defined in this instance.\n@param initializers the initializers to merge\n@return a complete set of merged initializers (with the specified parameters\nappearing first)", "input": "Java", "output": "protected final ServletContextInitializer[] mergeInitializers(\n\t\t\tServletContextInitializer... initializers) {\n\t\tList<ServletContextInitializer> mergedInitializers = new ArrayList<>();\n\t\tmergedInitializers.add((servletContext) -> this.initParameters\n\t\t\t\t.forEach(servletContext::setInitParameter));\n\t\tmergedInitializers.add(new SessionConfiguringInitializer(this.session));\n\t\tmergedInitializers.addAll(Arrays.asList(initializers));\n\t\tmergedInitializers.addAll(this.initializers);\n\t\treturn mergedInitializers.toArray(new ServletContextInitializer[0]);\n\t}"}, {"instruction": "Splits a comma-separated header value. The returned set is case-insensitive and contains each\npart with whitespace removed.", "input": "Java", "output": "private static List<CharSequence> splitHeader(CharSequence header) {\n        final StringBuilder builder = new StringBuilder(header.length());\n        final List<CharSequence> protocols = new ArrayList<CharSequence>(4);\n        for (int i = 0; i < header.length(); ++i) {\n            char c = header.charAt(i);\n            if (Character.isWhitespace(c)) {\n                // Don't include any whitespace.\n                continue;\n            }\n            if (c == ',') {\n                // Add the string and reset the builder for the next protocol.\n                protocols.add(builder.toString());\n                builder.setLength(0);\n            } else {\n                builder.append(c);\n            }\n        }\n\n        // Add the last protocol\n        if (builder.length() > 0) {\n            protocols.add(builder.toString());\n        }\n\n        return protocols;\n    }"}, {"instruction": "Set the maximum value. The maximum value is an acceptable value if and\nonly if inclusive is set to true.\n\n@param maximumValue the maximum value\n@param inclusive whether the maximum value is a valid value\n@return this", "input": "Java", "output": "public DoubleParameter setMaximumValue(double maximumValue, boolean inclusive) {\n\t\tif (hasDefaultValue) {\n\t\t\tif (inclusive) {\n\t\t\t\tUtil.checkParameter(maximumValue >= defaultValue,\n\t\t\t\t\t\"Maximum value (\" + maximumValue + \") must be greater than or equal to default (\" + defaultValue + \")\");\n\t\t\t} else {\n\t\t\t\tUtil.checkParameter(maximumValue > defaultValue,\n\t\t\t\t\t\"Maximum value (\" + maximumValue + \") must be greater than default (\" + defaultValue + \")\");\n\t\t\t}\n\t\t} else if (hasMinimumValue) {\n\t\t\tif (inclusive && minimumValueInclusive) {\n\t\t\t\tUtil.checkParameter(maximumValue >= minimumValue,\n\t\t\t\t\t\"Maximum value (\" + maximumValue + \") must be greater than or equal to minimum (\" + minimumValue + \")\");\n\t\t\t} else {\n\t\t\t\tUtil.checkParameter(maximumValue > minimumValue,\n\t\t\t\t\t\"Maximum value (\" + maximumValue + \") must be greater than minimum (\" + minimumValue + \")\");\n\t\t\t}\n\t\t}\n\n\t\tthis.hasMaximumValue = true;\n\t\tthis.maximumValue = maximumValue;\n\t\tthis.maximumValueInclusive = inclusive;\n\n\t\treturn this;\n\t}"}, {"instruction": "Verifies that no two process definitions share the same key, to prevent database unique\nindex violation.\n\n@throws ActivitiException if any two processes have the same key", "input": "Java", "output": "public void verifyProcessDefinitionsDoNotShareKeys(\n      Collection<ProcessDefinitionEntity> processDefinitions) {\n    Set<String> keySet = new LinkedHashSet<String>();\n    for (ProcessDefinitionEntity processDefinition : processDefinitions) {\n      if (keySet.contains(processDefinition.getKey())) {\n        throw new ActivitiException(\n            \"The deployment contains process definitions with the same key (process id attribute), this is not allowed\");\n      }\n      keySet.add(processDefinition.getKey());\n    }\n  }"}, {"instruction": "This method serializaes object  into JSON string\n\n@param element\n@return", "input": "Java", "output": "@Override\n    public String serialize(T element) {\n        String json = null;\n        try {\n            json = element.toJSON();\n        } catch (Exception e) {\n            log.error(\"Direct serialization failed, falling back to jackson\");\n        }\n\n        if (json == null || json.isEmpty()) {\n            ObjectMapper mapper = SequenceElement.mapper();\n            try {\n                json = mapper.writeValueAsString(element);\n            } catch (org.nd4j.shade.jackson.core.JsonProcessingException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return json;\n    }"}, {"instruction": "\u6839\u636e\u5bc6\u94a5\u7c7b\u578b\u83b7\u5f97\u76f8\u5e94\u5bc6\u94a5\n\n@param type \u7c7b\u578b {@link KeyType}\n@return {@link Key}", "input": "Java", "output": "protected Key getKeyByType(KeyType type) {\r\n\t\tswitch (type) {\r\n\t\tcase PrivateKey:\r\n\t\t\tif (null == this.privateKey) {\r\n\t\t\t\tthrow new NullPointerException(\"Private key must not null when use it !\");\r\n\t\t\t}\r\n\t\t\treturn this.privateKey;\r\n\t\tcase PublicKey:\r\n\t\t\tif (null == this.publicKey) {\r\n\t\t\t\tthrow new NullPointerException(\"Public key must not null when use it !\");\r\n\t\t\t}\r\n\t\t\treturn this.publicKey;\r\n\t\t}\r\n\t\tthrow new CryptoException(\"Uknown key type: \" + type);\r\n\t}"}, {"instruction": "Encodes 64 or 128 bits from the input into a hex trace ID.\n\n@param high Upper 64bits of the trace ID. Zero means the trace ID is 64-bit.\n@param low Lower 64bits of the trace ID.\n@throws IllegalArgumentException if both values are zero", "input": "Java", "output": "public Builder traceId(long high, long low) {\n      if (high == 0L && low == 0L) throw new IllegalArgumentException(\"empty trace ID\");\n      char[] result = new char[high != 0L ? 32 : 16];\n      int pos = 0;\n      if (high != 0L) {\n        writeHexLong(result, pos, high);\n        pos += 16;\n      }\n      writeHexLong(result, pos, low);\n      this.traceId = new String(result);\n      return this;\n    }"}, {"instruction": "Applies a flat select function to the detected pattern sequence. For each pattern sequence\nthe provided {@link PatternFlatSelectFunction} is called. The pattern flat select function\ncan produce an arbitrary number of resulting elements.\n\n@param patternFlatSelectFunction The pattern flat select function which is called for each\ndetected pattern sequence.\n@param <R> Type of the resulting elements\n@return {@link DataStream} which contains the resulting elements from the pattern flat select\nfunction.", "input": "Java", "output": "public <R> SingleOutputStreamOperator<R> flatSelect(final PatternFlatSelectFunction<T, R> patternFlatSelectFunction) {\n\t\t// we have to extract the output type from the provided pattern selection function manually\n\t\t// because the TypeExtractor cannot do that if the method is wrapped in a MapFunction\n\n\t\tfinal TypeInformation<R> outTypeInfo = TypeExtractor.getUnaryOperatorReturnType(\n\t\t\tpatternFlatSelectFunction,\n\t\t\tPatternFlatSelectFunction.class,\n\t\t\t0,\n\t\t\t1,\n\t\t\tnew int[]{1, 0},\n\t\t\tbuilder.getInputType(),\n\t\t\tnull,\n\t\t\tfalse);\n\n\t\treturn flatSelect(patternFlatSelectFunction, outTypeInfo);\n\t}"}, {"instruction": "Removes the token with the given {@code name}.\n<p>\nThe call to this method has no effect if the given {@code name} is null or empty, or a token with the given {@code name}\ndoes not exist.\n\n@param name the name of the token that will be removed", "input": "Java", "output": "public void removeToken(String name) {\r\n        if (name == null || name.isEmpty()) {\r\n            return;\r\n        }\r\n\r\n        for (Iterator<AntiCsrfParamToken> it = tokens.iterator(); it.hasNext();) {\r\n            AntiCsrfParamToken token = it.next();\r\n            if (name.equals(token.getName())) {\r\n                it.remove();\r\n                if (token.isEnabled()) {\r\n                    this.enabledTokensNames.remove(name);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }"}, {"instruction": "Encodes the specified cookies into a single Cookie header value.\n\n@param cookies\nsome cookies\n@return a Rfc6265 style Cookie header value, null if no cookies are passed.", "input": "Java", "output": "public String encode(Cookie... cookies) {\n        if (checkNotNull(cookies, \"cookies\").length == 0) {\n            return null;\n        }\n\n        StringBuilder buf = stringBuilder();\n        if (strict) {\n            if (cookies.length == 1) {\n                encode(buf, cookies[0]);\n            } else {\n                Cookie[] cookiesSorted = Arrays.copyOf(cookies, cookies.length);\n                Arrays.sort(cookiesSorted, COOKIE_COMPARATOR);\n                for (Cookie c : cookiesSorted) {\n                    encode(buf, c);\n                }\n            }\n        } else {\n            for (Cookie c : cookies) {\n                encode(buf, c);\n            }\n        }\n        return stripTrailingSeparatorOrNull(buf);\n    }"}, {"instruction": "Poll for a task of a certain type.\n\n@param taskType Task name\n@param workerId Id of the workflow\n@param domain   Domain of the workflow\n@return polled {@link Task}", "input": "Java", "output": "@Service\n    public Task poll(String taskType, String workerId, String domain) {\n        LOGGER.debug(\"Task being polled: /tasks/poll/{}?{}&{}\", taskType, workerId, domain);\n        Task task = executionService.getLastPollTask(taskType, workerId, domain);\n        if (task != null) {\n            LOGGER.debug(\"The Task {} being returned for /tasks/poll/{}?{}&{}\", task, taskType, workerId, domain);\n        }\n        Monitors.recordTaskPollCount(taskType, domain, 1);\n        return task;\n    }"}, {"instruction": "An expectation for checking WebElement with given locator has specific text\n\n@param locator used to find the element\n@param value   used as expected text\n@return Boolean true when element has text value equal to @value", "input": "Java", "output": "public static ExpectedCondition<Boolean> textToBe(final By locator, final String value) {\n    return new ExpectedCondition<Boolean>() {\n      private String currentValue = null;\n\n      @Override\n      public Boolean apply(WebDriver driver) {\n        try {\n          currentValue = driver.findElement(locator).getText();\n          return currentValue.equals(value);\n        } catch (Exception e) {\n          return false;\n        }\n      }\n\n      @Override\n      public String toString() {\n        return String.format(\"element found by %s to have text \\\"%s\\\". Current text: \\\"%s\\\"\",\n                             locator, value, currentValue);\n      }\n    };\n  }"}, {"instruction": "\u8fd4\u56de\u6240\u6709\u5b9e\u4f8b curl http://127.0.0.1:8081/destinations", "input": "Java", "output": "@GetMapping(\"/destinations\")\n    public List<Map<String, String>> destinations() {\n        List<Map<String, String>> result = new ArrayList<>();\n        Set<String> destinations = adapterCanalConfig.DESTINATIONS;\n        for (String destination : destinations) {\n            Map<String, String> resMap = new LinkedHashMap<>();\n            boolean status = syncSwitch.status(destination);\n            String resStatus;\n            if (status) {\n                resStatus = \"on\";\n            } else {\n                resStatus = \"off\";\n            }\n            resMap.put(\"destination\", destination);\n            resMap.put(\"status\", resStatus);\n            result.add(resMap);\n        }\n        return result;\n    }"}, {"instruction": "\u6839\u636e\u4e3b\u952e\u8fdb\u884c\u67e5\u8be2\n\n@param ms", "input": "Java", "output": "public String selectByPrimaryKey(MappedStatement ms) {\n        final Class<?> entityClass = getEntityClass(ms);\n        //\u5c06\u8fd4\u56de\u503c\u4fee\u6539\u4e3a\u5b9e\u4f53\u7c7b\u578b\n        setResultType(ms, entityClass);\n        StringBuilder sql = new StringBuilder();\n        sql.append(SqlHelper.selectAllColumns(entityClass));\n        sql.append(SqlHelper.fromTable(entityClass, tableName(entityClass)));\n        sql.append(SqlHelper.wherePKColumns(entityClass));\n        return sql.toString();\n    }"}, {"instruction": "Handler for an inbound HTTP/2 RST_STREAM frame, terminating a stream.", "input": "Java", "output": "private void onRstStreamRead(int streamId, long errorCode) {\n    NettyClientStream.TransportState stream = clientStream(connection().stream(streamId));\n    if (stream != null) {\n      Status status = GrpcUtil.Http2Error.statusForCode((int) errorCode)\n          .augmentDescription(\"Received Rst Stream\");\n      stream.transportReportStatus(\n          status,\n          errorCode == Http2Error.REFUSED_STREAM.code()\n              ? RpcProgress.REFUSED : RpcProgress.PROCESSED,\n          false /*stop delivery*/,\n          new Metadata());\n      if (keepAliveManager != null) {\n        keepAliveManager.onDataReceived();\n      }\n    }\n  }"}, {"instruction": "Must be called from syncContext", "input": "Java", "output": "private void shutdownNameResolverAndLoadBalancer(boolean channelIsActive) {\n    syncContext.throwIfNotInThisSynchronizationContext();\n    if (channelIsActive) {\n      checkState(nameResolverStarted, \"nameResolver is not started\");\n      checkState(lbHelper != null, \"lbHelper is null\");\n    }\n    if (nameResolver != null) {\n      cancelNameResolverBackoff();\n      nameResolver.shutdown();\n      nameResolverStarted = false;\n      if (channelIsActive) {\n        nameResolver = getNameResolver(target, nameResolverFactory, nameResolverHelper);\n      } else {\n        nameResolver = null;\n      }\n    }\n    if (lbHelper != null) {\n      lbHelper.lb.shutdown();\n      lbHelper = null;\n    }\n    subchannelPicker = null;\n  }"}, {"instruction": "[VARIABLE my_singer_id]", "input": "Java", "output": "public Timestamp singleUseReadOnlyTransaction(long singerId) {\n    // [START singleUseReadOnlyTransaction]\n    String column = \"FirstName\";\n    ReadOnlyTransaction txn = dbClient.singleUseReadOnlyTransaction();\n    Struct row = txn.readRow(\"Singers\", Key.of(singerId), Collections.singleton(column));\n    row.getString(column);\n    Timestamp timestamp = txn.getReadTimestamp();\n    // [END singleUseReadOnlyTransaction]\n    return timestamp;\n  }"}, {"instruction": "Splice from this {@link AbstractEpollStreamChannel} to another {@link AbstractEpollStreamChannel}.\nThe {@code len} is the number of bytes to splice. If using {@link Integer#MAX_VALUE} it will\nsplice until the {@link ChannelFuture} was canceled or it was failed.\n\nPlease note:\n<ul>\n<li>both channels need to be registered to the same {@link EventLoop}, otherwise an\n{@link IllegalArgumentException} is thrown. </li>\n<li>{@link EpollChannelConfig#getEpollMode()} must be {@link EpollMode#LEVEL_TRIGGERED} for this and the\ntarget {@link AbstractEpollStreamChannel}</li>\n</ul>", "input": "Java", "output": "public final ChannelFuture spliceTo(final AbstractEpollStreamChannel ch, final int len,\n                                        final ChannelPromise promise) {\n        if (ch.eventLoop() != eventLoop()) {\n            throw new IllegalArgumentException(\"EventLoops are not the same.\");\n        }\n        checkPositiveOrZero(len, \"len\");\n        if (ch.config().getEpollMode() != EpollMode.LEVEL_TRIGGERED\n                || config().getEpollMode() != EpollMode.LEVEL_TRIGGERED) {\n            throw new IllegalStateException(\"spliceTo() supported only when using \" + EpollMode.LEVEL_TRIGGERED);\n        }\n        checkNotNull(promise, \"promise\");\n        if (!isOpen()) {\n            promise.tryFailure(SPLICE_TO_CLOSED_CHANNEL_EXCEPTION);\n        } else {\n            addToSpliceQueue(new SpliceInChannelTask(ch, len, promise));\n            failSpliceIfClosed(promise);\n        }\n        return promise;\n    }"}, {"instruction": "This method removes all cached constants", "input": "Java", "output": "@Override\n    public void purgeConstants() {\n        buffersCache = new HashMap<>();\n\n        protector.purgeProtector();\n\n        resetHappened = true;\n        logger.info(\"Resetting Constants...\");\n\n        for (Integer device : constantOffsets.keySet()) {\n            constantOffsets.get(device).set(0);\n            buffersCache.put(device, new ConcurrentHashMap<ArrayDescriptor, DataBuffer>());\n        }\n    }"}, {"instruction": "Specifies that each entry should be automatically removed from the cache once a fixed duration\nhas elapsed after the entry's creation, the most recent replacement of its value, or its last\nread. Access time is reset by all cache read and write operations (including\n{@code Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by operations\non the collection-views of {@link Cache#asMap}.\n<p>\nExpired entries may be counted in {@link Cache#estimatedSize()}, but will never be visible to\nread or write operations. Expired entries are cleaned up as part of the routine maintenance\ndescribed in the class javadoc.\n<p>\nIf you can represent the duration as a {@link java.time.Duration} (which should be preferred\nwhen feasible), use {@link #expireAfterAccess(Duration)} instead.\n\n@param duration the length of time after an entry is last accessed that it should be\nautomatically removed\n@param unit the unit that {@code duration} is expressed in\n@return this {@code Caffeine} instance (for chaining)\n@throws IllegalArgumentException if {@code duration} is negative\n@throws IllegalStateException if the time to idle or variable expiration was already set", "input": "Java", "output": "@NonNull\n  public Caffeine<K, V> expireAfterAccess(@NonNegative long duration, @NonNull TimeUnit unit) {\n    requireState(expireAfterAccessNanos == UNSET_INT,\n        \"expireAfterAccess was already set to %s ns\", expireAfterAccessNanos);\n    requireState(expiry == null, \"expireAfterAccess may not be used with variable expiration\");\n    requireArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n    this.expireAfterAccessNanos = unit.toNanos(duration);\n    return this;\n  }"}, {"instruction": "Gets the interface {@code class1} from the given {@code script}. Might return {@code null} if the {@code script} does not\nimplement the interface.\n<p>\nFirst tries to get the interface directly from the {@code script} by calling the method\n{@code ScriptWrapper.getInterface(Class)}, if it returns {@code null} the interface will be extracted from the script\nafter invoking it, using the method {@code Invocable.getInterface(Class)}.\n<p>\nThe context class loader of caller thread is replaced with the class loader {@code AddOnLoader} to allow the script to\naccess classes of add-ons. If this behaviour is not desired call the method {@code getInterfaceWithOutAddOnLoader(}\ninstead.\n\n@param script the script that will be invoked\n@param class1 the interface that will be obtained from the script\n@return the interface implemented by the script, or {@code null} if the {@code script} does not implement the interface.\n@throws ScriptException if the engine of the given {@code script} was not found.\n@throws IOException if an error occurred while obtaining the interface directly from the script (\n{@code ScriptWrapper.getInterface(Class)})\n@see #getInterfaceWithOutAddOnLoader(ScriptWrapper, Class)\n@see ScriptWrapper#getInterface(Class)\n@see Invocable#getInterface(Class)", "input": "Java", "output": "public <T> T getInterface(ScriptWrapper script, Class<T> class1) throws ScriptException, IOException {\r\n\t\r\n\t\tClassLoader previousContextClassLoader = Thread.currentThread().getContextClassLoader();\r\n\t\tThread.currentThread().setContextClassLoader(ExtensionFactory.getAddOnLoader());\r\n\t\ttry {\r\n\t\t\tT iface = script.getInterface(class1);\r\n\t\t\t\r\n\t\t\tif (iface != null) {\r\n\t\t\t\t// the script wrapper has overriden the usual scripting mechanism\r\n\t\t\t\treturn iface;\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\tThread.currentThread().setContextClassLoader(previousContextClassLoader);\r\n\t\t}\r\n\t\t\r\n\t\tif (script.isRunableStandalone()) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tInvocable invocable = invokeScript(script);\r\n\t\tif (invocable != null) {\r\n\t\t\treturn invocable.getInterface(class1);\r\n\t\t}\r\n\t\treturn null;\r\n\r\n\t}"}, {"instruction": "\u552f\u4e00\u6807\u8bc6UniqueName\u7684\u4ea7\u751f\u65b9\u6cd5\uff0c\u4e3b\u8981\u7528\u4e8e\u5185\u90e8\u627e\u63a5\u53e3\u7b49\uff0c\u683c\u5f0f\u4e3ainterface:version[:uniqueId]\n\n@param interfaceConfig \u670d\u52a1\u63d0\u4f9b\u8005\u6216\u8005\u670d\u52a1\u6d88\u8d39\u8005\u914d\u7f6e\n@return \u914d\u7f6e\u552f\u4e00\u540d\u5b57", "input": "Java", "output": "public static String getUniqueName(AbstractInterfaceConfig interfaceConfig) {\n        // \u52a0\u4e0a 1.0 \u662f\u4e3a\u4e86\u517c\u5bb9\u4e4b\u524d\u7684\u7248\u672c\n        String version = interfaceConfig.getVersion();\n        String uniqueId = interfaceConfig.getUniqueId();\n        return interfaceConfig.getInterfaceId()\n            + (StringUtils.isEmpty(version) ? \":1.0\" : \":\" + version)\n            + (StringUtils.isEmpty(uniqueId) ? \"\" : \":\" + uniqueId);\n    }"}, {"instruction": "Produce a comma delimited text row from a JSONArray. Values containing the comma character will be quoted. Troublesome characters may be removed.\n\n@param ja\nA JSONArray of strings.\n@return A string ending in NEWLINE.", "input": "Java", "output": "public static String rowToString(JSONArray ja) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < ja.length(); i += 1) {\n      if (i > 0) {\n        sb.append(',');\n      }\n      Object o = ja.opt(i);\n      if (o != null) {\n        String s = o.toString();\n        if (s.length() > 0 && (s.indexOf(',') >= 0 || s.indexOf('\\n') >= 0 || s.indexOf('\\r') >= 0 || s.indexOf(0) >= 0 || s.charAt(0) == '\"')) {\n          sb.append('\"');\n          int length = s.length();\n          for (int j = 0; j < length; j += 1) {\n            char c = s.charAt(j);\n            if (c >= ' ' && c != '\"') {\n              sb.append(c);\n            }\n          }\n          sb.append('\"');\n        } else {\n          sb.append(s);\n        }\n      }\n    }\n    sb.append('\\n');\n    return sb.toString();\n  }"}, {"instruction": "Creates HostAndPort instance from string.\nString must be in ( host + \":\" + port ) format.\nPort is mandatory. Can convert host part.\n@see #convertHost(String)\n@param from String to parse\n@return HostAndPort instance", "input": "Java", "output": "public static HostAndPort parseString(String from){\n    // NOTE: redis answers with\n    // '99aa9999aa9a99aa099aaa990aa99a09aa9a9999 9a09:9a9:a090:9a::99a slave 8c88888888cc08088cc8c8c888c88c8888c88cc8 0 1468251272993 37 connected'\n    // for CLUSTER NODES, ASK and MOVED scenarios. That's why there is no possibility to parse address in 'correct' way.\n    // Redis should switch to 'bracketized' (RFC 3986) IPv6 address.\n    try {\n      String[] parts = extractParts(from);\n      String host = parts[0];\n      int port = Integer.parseInt(parts[1]);\n      return new HostAndPort(convertHost(host), port);\n    } catch (NumberFormatException ex) {\n      throw new IllegalArgumentException(ex);\n    }\n  }"}, {"instruction": "For classpath reasons, we'll put each link file in a separate directory.\nThis must be called only after the job id has been inserted by the job.\n\n@param props The Azkaban properties", "input": "Java", "output": "public static String getDirName(Props props) {\n    String dirSuffix = props.get(CommonJobProperties.NESTED_FLOW_PATH);\n\n    if ((dirSuffix == null) || (dirSuffix.length() == 0)) {\n      dirSuffix = props.get(CommonJobProperties.JOB_ID);\n      if ((dirSuffix == null) || (dirSuffix.length() == 0)) {\n        throw new RuntimeException(\"azkaban.flow.nested.path and azkaban.job.id were not set\");\n      }\n    }\n\n    return \"_resources_\" + dirSuffix.replace(':', '_');\n  }"}, {"instruction": "Returns alternative names (non-deprecated keys or previously-set deprecated keys)\nfor a given non-deprecated key.\nIf the given key is deprecated, return null.\n\n@param name property name.\n@return alternative names.", "input": "Java", "output": "private String[] getAlternativeNames(String name) {\n\t\tString altNames[] = null;\n\t\tDeprecatedKeyInfo keyInfo = null;\n\t\tDeprecationContext cur = deprecationContext.get();\n\t\tString depKey = cur.getReverseDeprecatedKeyMap().get(name);\n\t\tif(depKey != null) {\n\t\t\tkeyInfo = cur.getDeprecatedKeyMap().get(depKey);\n\t\t\tif(keyInfo.newKeys.length > 0) {\n\t\t\t\tif(getProps().containsKey(depKey)) {\n\t\t\t\t\t//if deprecated key is previously set explicitly\n\t\t\t\t\tList<String> list = new ArrayList<String>();\n\t\t\t\t\tlist.addAll(Arrays.asList(keyInfo.newKeys));\n\t\t\t\t\tlist.add(depKey);\n\t\t\t\t\taltNames = list.toArray(new String[list.size()]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taltNames = keyInfo.newKeys;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn altNames;\n\t}"}, {"instruction": "{@link #compute} can be called by multiple threads, so this function should be thread-safe to avoid extra\nscript compilation.", "input": "Java", "output": "@EnsuresNonNull(\"fn\")\n  private Function getCompiledScript()\n  {\n    // JavaScript configuration should be checked when it's actually used because someone might still want Druid\n    // nodes to be able to deserialize JavaScript-based objects even though JavaScript is disabled.\n    Preconditions.checkState(config.isEnabled(), \"JavaScript is disabled\");\n\n    Function syncedFn = fn;\n    if (syncedFn == null) {\n      synchronized (config) {\n        syncedFn = fn;\n        if (syncedFn == null) {\n          syncedFn = compile(function);\n          fn = syncedFn;\n        }\n      }\n    }\n    return syncedFn;\n  }"}, {"instruction": "WAP\u652f\u4ed8\n\n@param response\n{HttpServletResponse}\n@param model\n{AlipayTradeWapPayModel}\n@param returnUrl\n\u5f02\u6b65\u901a\u77e5URL\n@param notifyUrl\n\u540c\u6b65\u901a\u77e5URL\n@return {String}\n@throws {AlipayApiException}\n@throws {IOException}", "input": "Java", "output": "public static String wapPayStr(HttpServletResponse response, AlipayTradeWapPayModel model, String returnUrl,\n\t\t\tString notifyUrl) throws AlipayApiException, IOException {\n\t\tAlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();// \u521b\u5efaAPI\u5bf9\u5e94\u7684request\n\t\talipayRequest.setReturnUrl(returnUrl);\n\t\talipayRequest.setNotifyUrl(notifyUrl);// \u5728\u516c\u5171\u53c2\u6570\u4e2d\u8bbe\u7f6e\u56de\u8df3\u548c\u901a\u77e5\u5730\u5740\n\t\talipayRequest.setBizModel(model);// \u586b\u5145\u4e1a\u52a1\u53c2\u6570\n\t\treturn AliPayApiConfigKit.getAliPayApiConfig().getAlipayClient().pageExecute(alipayRequest).getBody(); // \u8c03\u7528SDK\u751f\u6210\u8868\u5355\n\t}"}, {"instruction": "\u5c06\u9a7c\u5cf0\u98ce\u683c\u66ff\u6362\u4e3a\u4e0b\u5212\u7ebf\u98ce\u683c", "input": "Java", "output": "public static String camelhumpToUnderline(String str) {\n        final int size;\n        final char[] chars;\n        final StringBuilder sb = new StringBuilder(\n                (size = (chars = str.toCharArray()).length) * 3 / 2 + 1);\n        char c;\n        for (int i = 0; i < size; i++) {\n            c = chars[i];\n            if (isUppercaseAlpha(c)) {\n                sb.append('_').append(toLowerAscii(c));\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.charAt(0) == '_' ? sb.substring(1) : sb.toString();\n    }"}, {"instruction": "Encodes URI string.\n\nThis is a two mapping, one from original characters to octets, and\nsubsequently a second from octets to URI characters:\n<p><blockquote><pre>\noriginal character sequence-&gt;octet sequence-&gt;URI character sequence\n</pre></blockquote><p>\n\nAn escaped octet is encoded as a character triplet, consisting of the\npercent character \"%\" followed by the two hexadecimal digits\nrepresenting the octet code. For example, \"%20\" is the escaped\nencoding for the US-ASCII space character.\n<p>\nConversion from the local filesystem character set to UTF-8 will\nnormally involve a two step process. First convert the local character\nset to the UCS; then convert the UCS to UTF-8.\nThe first step in the process can be performed by maintaining a mapping\ntable that includes the local character set code and the corresponding\nUCS code.\nThe next step is to convert the UCS character code to the UTF-8 encoding.\n<p>\nMapping between vendor codepages can be done in a very similar manner\nas described above.\n<p>\nThe only time escape encodings can allowedly be made is when a URI is\nbeing created from its component parts.  The escape and validate methods\nare internally performed within this method.\n\n@param original the original character sequence\n@param allowed those characters that are allowed within a component\n@param charset the protocol charset\n@return URI character sequence\n@throws URIException null component or unsupported character encoding", "input": "Java", "output": "protected static char[] encode(String original, BitSet allowed,\n            String charset) throws URIException {\n        if (original == null) {\n            throw new IllegalArgumentException(\"Original string may not be null\");\n        }\n        if (allowed == null) {\n            throw new IllegalArgumentException(\"Allowed bitset may not be null\");\n        }\n        byte[] rawdata = URLCodec.encodeUrl(allowed, EncodingUtil.getBytes(original, charset));\n        return EncodingUtil.getAsciiString(rawdata).toCharArray();\n    }"}, {"instruction": "build consul service from url\n\n@param url a URL object\n@return ConsulService consul service", "input": "Java", "output": "public static ConsulService buildService(URL url) {\n        ConsulService service = new ConsulService();\n        service.setAddress(url.getHost());\n        service.setId(ConsulUtils.convertConsulSerivceId(url));\n        service.setName(url.getPath());\n        service.setPort(url.getPort());\n        List<String> tags = new ArrayList<String>();\n        String env = url.getParameter(Constants.TAG_ENVIRONMENT);\n        if(env != null) tags.add(env);\n        service.setTags(tags);\n\n        return service;\n    }"}, {"instruction": "Returns the interconnectDiagnostics for the specified interconnect.\n\n<p>Sample code:\n\n<pre><code>\ntry (InterconnectClient interconnectClient = InterconnectClient.create()) {\nProjectGlobalInterconnectName interconnect = ProjectGlobalInterconnectName.of(\"[PROJECT]\", \"[INTERCONNECT]\");\nInterconnectsGetDiagnosticsResponse response = interconnectClient.getDiagnosticsInterconnect(interconnect);\n}\n</code></pre>\n\n@param interconnect Name of the interconnect resource to query.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final InterconnectsGetDiagnosticsResponse getDiagnosticsInterconnect(\n      ProjectGlobalInterconnectName interconnect) {\n\n    GetDiagnosticsInterconnectHttpRequest request =\n        GetDiagnosticsInterconnectHttpRequest.newBuilder()\n            .setInterconnect(interconnect == null ? null : interconnect.toString())\n            .build();\n    return getDiagnosticsInterconnect(request);\n  }"}, {"instruction": "Get the value of the <code>name</code> property as a <code>Class</code>\nimplementing the interface specified by <code>xface</code>.\n\nIf no such property is specified, then <code>defaultValue</code> is\nreturned.\n\nAn exception is thrown if the returned class does not implement the named\ninterface.\n\n@param name the class name.\n@param defaultValue default value.\n@param xface the interface implemented by the named class.\n@return property value as a <code>Class</code>,\nor <code>defaultValue</code>.", "input": "Java", "output": "public <U> Class<? extends U> getClass(String name,\n\t                                       Class<? extends U> defaultValue,\n\t                                       Class<U> xface) {\n\t\ttry {\n\t\t\tClass<?> theClass = getClass(name, defaultValue);\n\t\t\tif (theClass != null && !xface.isAssignableFrom(theClass))\n\t\t\t\tthrow new RuntimeException(theClass+\" not \"+xface.getName());\n\t\t\telse if (theClass != null)\n\t\t\t\treturn theClass.asSubclass(xface);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}"}, {"instruction": "Creates a subscription to a given topic. See the &lt;a\nhref=\"https://cloud.google.com/pubsub/docs/admin#resource_names\"&gt; resource name\nrules&lt;/a&gt;. If the subscription already exists, returns `ALREADY_EXISTS`. If the\ncorresponding topic doesn't exist, returns `NOT_FOUND`.\n\n<p>If the name is not provided in the request, the server will assign a random name for this\nsubscription on the same project as the topic, conforming to the [resource name\nformat](https://cloud.google.com/pubsub/docs/admin#resource_names). The generated name is\npopulated in the returned Subscription object. Note that for REST API requests, you must\nspecify a name in the request.\n\n<p>Sample code:\n\n<pre><code>\ntry (SubscriptionAdminClient subscriptionAdminClient = SubscriptionAdminClient.create()) {\nProjectSubscriptionName name = ProjectSubscriptionName.of(\"[PROJECT]\", \"[SUBSCRIPTION]\");\nProjectTopicName topic = ProjectTopicName.of(\"[PROJECT]\", \"[TOPIC]\");\nPushConfig pushConfig = PushConfig.newBuilder().build();\nint ackDeadlineSeconds = 0;\nSubscription response = subscriptionAdminClient.createSubscription(name.toString(), topic.toString(), pushConfig, ackDeadlineSeconds);\n}\n</code></pre>\n\n@param name The name of the subscription. It must have the format\n`\"projects/{project}/subscriptions/{subscription}\"`. `{subscription}` must start with a\nletter, and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`), underscores\n(`_`), periods (`.`), tildes (`~`), plus (`+`) or percent signs (`%`). It must be between 3\nand 255 characters in length, and it must not start with `\"goog\"`\n@param topic The name of the topic from which this subscription is receiving messages. Format\nis `projects/{project}/topics/{topic}`. The value of this field will be `_deleted-topic_`\nif the topic has been deleted.\n@param pushConfig If push delivery is used with this subscription, this field is used to\nconfigure it. An empty `pushConfig` signifies that the subscriber will pull and ack\nmessages using API methods.\n@param ackDeadlineSeconds The approximate amount of time (on a best-effort basis) Pub/Sub waits\nfor the subscriber to acknowledge receipt before resending the message. In the interval\nafter the message is delivered and before it is acknowledged, it is considered to be\n&lt;i&gt;outstanding&lt;/i&gt;. During that time period, the message will not be\nredelivered (on a best-effort basis).\n<p>For pull subscriptions, this value is used as the initial value for the ack deadline. To\noverride this value for a given message, call `ModifyAckDeadline` with the corresponding\n`ack_id` if using non-streaming pull or send the `ack_id` in a\n`StreamingModifyAckDeadlineRequest` if using streaming pull. The minimum custom deadline\nyou can specify is 10 seconds. The maximum custom deadline you can specify is 600 seconds\n(10 minutes). If this parameter is 0, a default value of 10 seconds is used.\n<p>For push delivery, this value is also used to set the request timeout for the call to\nthe push endpoint.\n<p>If the subscriber never acknowledges the message, the Pub/Sub system will eventually\nredeliver the message.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "public final Subscription createSubscription(\n      String name, String topic, PushConfig pushConfig, int ackDeadlineSeconds) {\n\n    Subscription request =\n        Subscription.newBuilder()\n            .setName(name)\n            .setTopic(topic)\n            .setPushConfig(pushConfig)\n            .setAckDeadlineSeconds(ackDeadlineSeconds)\n            .build();\n    return createSubscription(request);\n  }"}, {"instruction": "Default value for {@link ToolInstallation#getProperties()} used in the form binding.\n@since 1.305", "input": "Java", "output": "public DescribableList<ToolProperty<?>,ToolPropertyDescriptor> getDefaultProperties() throws IOException {\n        DescribableList<ToolProperty<?>,ToolPropertyDescriptor> r\n                = new DescribableList<>(NOOP);\n\n        List<? extends ToolInstaller> installers = getDefaultInstallers();\n        if(!installers.isEmpty())\n            r.add(new InstallSourceProperty(installers));\n\n        return r;\n    }"}, {"instruction": "Scan for entities with the specified annotations.\n@param annotationTypes the annotation types used on the entities\n@return a set of entity classes\n@throws ClassNotFoundException if an entity class cannot be loaded", "input": "Java", "output": "@SafeVarargs\n\tpublic final Set<Class<?>> scan(Class<? extends Annotation>... annotationTypes)\n\t\t\tthrows ClassNotFoundException {\n\t\tList<String> packages = getPackages();\n\t\tif (packages.isEmpty()) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\tClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(\n\t\t\t\tfalse);\n\t\tscanner.setEnvironment(this.context.getEnvironment());\n\t\tscanner.setResourceLoader(this.context);\n\t\tfor (Class<? extends Annotation> annotationType : annotationTypes) {\n\t\t\tscanner.addIncludeFilter(new AnnotationTypeFilter(annotationType));\n\t\t}\n\t\tSet<Class<?>> entitySet = new HashSet<>();\n\t\tfor (String basePackage : packages) {\n\t\t\tif (StringUtils.hasText(basePackage)) {\n\t\t\t\tfor (BeanDefinition candidate : scanner\n\t\t\t\t\t\t.findCandidateComponents(basePackage)) {\n\t\t\t\t\tentitySet.add(ClassUtils.forName(candidate.getBeanClassName(),\n\t\t\t\t\t\t\tthis.context.getClassLoader()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn entitySet;\n\t}"}, {"instruction": "Refresh the locally held version of {@link com.netflix.appinfo.AmazonInfo}", "input": "Java", "output": "public synchronized void refresh() {\n        try {\n            AmazonInfo newInfo = getNewAmazonInfo();\n\n            if (shouldUpdate(newInfo, info)) {\n                // the datacenter info has changed, re-sync it\n                logger.info(\"The AmazonInfo changed from : {} => {}\", info, newInfo);\n                this.info = newInfo;\n            }\n        } catch (Throwable t) {\n            logger.error(\"Cannot refresh the Amazon Info \", t);\n        }\n    }"}, {"instruction": "This method should not be public so as to not expose internals to user code.", "input": "Java", "output": "@Override\n\tOperatorStateHandle closeAndGetHandle() throws IOException {\n\t\tStreamStateHandle streamStateHandle = delegate.closeAndGetHandle();\n\n\t\tif (null == streamStateHandle) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (partitionOffsets.isEmpty() && delegate.getPos() > initialPosition) {\n\t\t\tstartNewPartition();\n\t\t}\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> offsetsMap = new HashMap<>(1);\n\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tpartitionOffsets.toArray(),\n\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\n\t\toffsetsMap.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\treturn new OperatorStreamStateHandle(offsetsMap, streamStateHandle);\n\t}"}, {"instruction": "Get layer output type.\n\n@param inputType Array of InputTypes\n@return output type as InputType\n@throws InvalidKerasConfigurationException Invalid Keras config", "input": "Java", "output": "@Override\n    public InputType getOutputType(InputType... inputType) throws InvalidKerasConfigurationException {\n        if (inputType.length > 1)\n            throw new InvalidKerasConfigurationException(\n                    \"Keras SimpleRnn layer accepts only one input (received \" + inputType.length + \")\");\n        InputPreProcessor preProcessor = getInputPreprocessor(inputType);\n        if (preProcessor != null)\n            return preProcessor.getOutputType(inputType[0]);\n        else\n            return this.getSimpleRnnLayer().getOutputType(-1, inputType[0]);\n    }"}, {"instruction": "Register an application with its secret.\nExecutors need to first authenticate themselves with the same secret before\nfetching shuffle files written by other executors in this application.", "input": "Java", "output": "public void registerApp(String appId, String shuffleSecret) {\n    // Always put the new secret information to make sure it's the most up to date.\n    // Otherwise we have to specifically look at the application attempt in addition\n    // to the applicationId since the secrets change between application attempts on yarn.\n    shuffleSecretMap.put(appId, shuffleSecret);\n    logger.info(\"Registered shuffle secret for application {}\", appId);\n  }"}, {"instruction": "\u5207\u53d6\u90e8\u5206\u6570\u636e<br>\n\u5207\u53d6\u540e\u7684\u6808\u5c06\u51cf\u5c11\u8fd9\u4e9b\u5143\u7d20\n\n@param <T> \u96c6\u5408\u5143\u7d20\u7c7b\u578b\n@param surplusAlaDatas \u539f\u6570\u636e\n@param partSize \u6bcf\u90e8\u5206\u6570\u636e\u7684\u957f\u5ea6\n@return \u5207\u53d6\u51fa\u7684\u6570\u636e\u6216null", "input": "Java", "output": "public static <T> List<T> popPart(Stack<T> surplusAlaDatas, int partSize) {\r\n\t\tif (isEmpty(surplusAlaDatas)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tfinal List<T> currentAlaDatas = new ArrayList<>();\r\n\t\tint size = surplusAlaDatas.size();\r\n\t\t// \u5207\u5272\r\n\t\tif (size > partSize) {\r\n\t\t\tfor (int i = 0; i < partSize; i++) {\r\n\t\t\t\tcurrentAlaDatas.add(surplusAlaDatas.pop());\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = 0; i < size; i++) {\r\n\t\t\t\tcurrentAlaDatas.add(surplusAlaDatas.pop());\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn currentAlaDatas;\r\n\t}"}, {"instruction": "Generates a new secure-random secret key of a length suitable for creating and verifying HMAC signatures\naccording to the specified {@code SignatureAlgorithm} using the specified SecureRandom number generator.  This\nimplementation returns secure-random key sizes as follows:\n\n<table> <caption>Key Sizes</caption> <thead> <tr> <th>Signature Algorithm</th> <th>Generated Key Size</th> </tr> </thead> <tbody> <tr>\n<td>HS256</td> <td>256 bits (32 bytes)</td> </tr> <tr> <td>HS384</td> <td>384 bits (48 bytes)</td> </tr> <tr>\n<td>HS512</td> <td>512 bits (64 bytes)</td> </tr> </tbody> </table>\n\n@param alg    the signature algorithm that will be used with the generated key\n@param random the secure random number generator used during key generation\n@return a new secure-random secret key of a length suitable for creating and verifying HMAC signatures according\nto the specified {@code SignatureAlgorithm} using the specified SecureRandom number generator.\n@see #generateKey()\n@see #generateKey(SignatureAlgorithm)\n@since 0.5\n@deprecated since 0.10.0 - use {@link #generateKey(SignatureAlgorithm)} instead.", "input": "Java", "output": "@Deprecated\n    public static SecretKey generateKey(SignatureAlgorithm alg, SecureRandom random) {\n\n        Assert.isTrue(alg.isHmac(), \"SignatureAlgorithm argument must represent an HMAC algorithm.\");\n\n        KeyGenerator gen;\n\n        try {\n            gen = KeyGenerator.getInstance(alg.getJcaName());\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"The \" + alg.getJcaName() + \" algorithm is not available.  \" +\n                \"This should never happen on JDK 7 or later - please report this to the JJWT developers.\", e);\n        }\n\n        return gen.generateKey();\n    }"}, {"instruction": "Merge this configuration with the specified {@link GridHubConfiguration}\n@param other", "input": "Java", "output": "public void merge(GridHubConfiguration other) {\n    if (other == null) {\n      return;\n    }\n    super.merge(other);\n\n    if (isMergeAble(CapabilityMatcher.class, other.capabilityMatcher, capabilityMatcher)) {\n      capabilityMatcher = other.capabilityMatcher;\n    }\n    if (isMergeAble(Integer.class, other.newSessionWaitTimeout, newSessionWaitTimeout)) {\n      newSessionWaitTimeout = other.newSessionWaitTimeout;\n    }\n    if (isMergeAble(Prioritizer.class, other.prioritizer, prioritizer)) {\n      prioritizer = other.prioritizer;\n    }\n    if (isMergeAble(Boolean.class, other.throwOnCapabilityNotPresent, throwOnCapabilityNotPresent)) {\n      throwOnCapabilityNotPresent = other.throwOnCapabilityNotPresent;\n    }\n    if (isMergeAble(String.class, other.registry, registry)) {\n      registry = other.registry;\n    }\n  }"}, {"instruction": "------------------------------------------------------------------------", "input": "Java", "output": "@Override\n\tpublic JobExecutionResult execute(String jobName) throws Exception {\n\t\tPlanExecutor executor = getExecutor();\n\n\t\tPlan p = createProgramPlan(jobName);\n\n\t\t// Session management is disabled, revert this commit to enable\n\t\t//p.setJobId(jobID);\n\t\t//p.setSessionTimeout(sessionTimeout);\n\n\t\tJobExecutionResult result = executor.executePlan(p);\n\n\t\tthis.lastJobExecutionResult = result;\n\t\treturn result;\n\t}"}, {"instruction": "Prepare a command line for execution from a Windows batch script.\n\nThe method quotes all arguments so that spaces are handled as expected. Quotes within arguments\nare \"double quoted\" (which is batch for escaping a quote). This page has more details about\nquoting and other batch script fun stuff: http://ss64.com/nt/syntax-esc.html", "input": "Java", "output": "private static String prepareWindowsCommand(List<String> cmd, Map<String, String> childEnv) {\n    StringBuilder cmdline = new StringBuilder();\n    for (Map.Entry<String, String> e : childEnv.entrySet()) {\n      cmdline.append(String.format(\"set %s=%s\", e.getKey(), e.getValue()));\n      cmdline.append(\" && \");\n    }\n    for (String arg : cmd) {\n      cmdline.append(quoteForBatchScript(arg));\n      cmdline.append(\" \");\n    }\n    return cmdline.toString();\n  }"}, {"instruction": "Return the currently-active lock posses for some task.\n\n@param task task for which to locate locks", "input": "Java", "output": "private List<TaskLockPosse> findLockPossesForTask(final Task task)\n  {\n    giant.lock();\n\n    try {\n      // Scan through all locks for this datasource\n      final NavigableMap<DateTime, SortedMap<Interval, List<TaskLockPosse>>> dsRunning = running.get(task.getDataSource());\n      if (dsRunning == null) {\n        return ImmutableList.of();\n      } else {\n        return dsRunning.values().stream()\n                        .flatMap(map -> map.values().stream())\n                        .flatMap(Collection::stream)\n                        .filter(taskLockPosse -> taskLockPosse.containsTask(task))\n                        .collect(Collectors.toList());\n      }\n    }\n    finally {\n      giant.unlock();\n    }\n  }"}, {"instruction": "Used to reset a reset a reader group to a checkpoint. This should be removed in time.\n@deprecated Use {@link ReaderGroup#resetReaderGroup(ReaderGroupConfig)} to reset readers to a given Checkpoint.", "input": "Java", "output": "@Override\n    @Deprecated\n    public void resetReadersToCheckpoint(Checkpoint checkpoint) {\n        synchronizer.updateState((state, updates) -> {\n            ReaderGroupConfig config = state.getConfig();\n            Map<Segment, Long> positions = new HashMap<>();\n            for (StreamCut cut : checkpoint.asImpl().getPositions().values()) {\n                positions.putAll(cut.asImpl().getPositions());\n            }\n            updates.add(new ReaderGroupStateInit(config, positions, getEndSegmentsForStreams(config)));\n        });\n    }"}, {"instruction": "Determine consent event string.\n\n@param requestContext the request context\n@return the string", "input": "Java", "output": "protected String determineConsentEvent(final RequestContext requestContext) {\n        val webService = WebUtils.getService(requestContext);\n        val service = this.authenticationRequestServiceSelectionStrategies.resolveService(webService);\n        if (service == null) {\n            return null;\n        }\n\n        val registeredService = getRegisteredServiceForConsent(requestContext, service);\n\n        val authentication = WebUtils.getAuthentication(requestContext);\n        if (authentication == null) {\n            return null;\n        }\n\n        return isConsentRequired(service, registeredService, authentication, requestContext);\n    }"}, {"instruction": "get the last reference invoke information\n\n@param clear true: framework will clear the ThreadLocal when return\n@return RPC Reference Context, it can be null", "input": "Java", "output": "public static RpcReferenceContext lastReferenceContext(boolean clear) {\n        try {\n            RpcInvokeContext invokeCtx = RpcInvokeContext.getContext();\n            RpcReferenceContext referenceCtx = (RpcReferenceContext) invokeCtx\n                .get(RemotingConstants.INVOKE_CTX_RPC_REF_CTX);\n            if (referenceCtx != null) {\n                String resultCode = (String) invokeCtx.get(RemotingConstants.INVOKE_CTX_RPC_RESULT_CODE);\n                if (resultCode != null) {\n                    referenceCtx.setResultCode(ResultCodeEnum.getResultCode(resultCode));\n                }\n            }\n            return referenceCtx;\n        } finally {\n            if (clear) {\n                clearReferenceContext();\n            }\n        }\n    }"}, {"instruction": "init fxml when loaded.", "input": "Java", "output": "@PostConstruct\n    public void init() {\n        validatedText.focusedProperty().addListener((o, oldVal, newVal) -> {\n            if (!newVal) {\n                validatedText.validate();\n            }\n        });\n        validatedPassowrd.focusedProperty().addListener((o, oldVal, newVal) -> {\n            if (!newVal) {\n                validatedPassowrd.validate();\n            }\n        });\n        jfxTextArea.focusedProperty().addListener((o, oldVal, newVal) -> {\n            if (!newVal) {\n                jfxTextArea.validate();\n            }\n        });\n    }"}, {"instruction": "Compute the ideal deadline, set subsequent modacks to this deadline, and return it.", "input": "Java", "output": "@InternalApi\n  int computeDeadlineSeconds() {\n    int sec = ackLatencyDistribution.getPercentile(PERCENTILE_FOR_ACK_DEADLINE_UPDATES);\n\n    // Use Ints.constrainToRange when we get guava 21.\n    if (sec < Subscriber.MIN_ACK_DEADLINE_SECONDS) {\n      sec = Subscriber.MIN_ACK_DEADLINE_SECONDS;\n    } else if (sec > Subscriber.MAX_ACK_DEADLINE_SECONDS) {\n      sec = Subscriber.MAX_ACK_DEADLINE_SECONDS;\n    }\n    return sec;\n  }"}, {"instruction": "Maintains backwards compatibility. Invoked by XStream when this object is de-serialized.", "input": "Java", "output": "@SuppressWarnings({\"unused\"})\n    private Object readResolve() {\n        if (jdks == null) {\n            jdks = new ArrayList<>();\n        }\n        if (SLAVE_AGENT_PORT_ENFORCE) {\n            slaveAgentPort = getSlaveAgentPortInitialValue(slaveAgentPort);\n        }\n        if (disabledAgentProtocols == null && _disabledAgentProtocols != null) {\n            disabledAgentProtocols = Arrays.asList(_disabledAgentProtocols);\n            _disabledAgentProtocols = null;\n        }\n        if (enabledAgentProtocols == null && _enabledAgentProtocols != null) {\n            enabledAgentProtocols = Arrays.asList(_enabledAgentProtocols);\n            _enabledAgentProtocols = null;\n        }\n        // Invalidate the protocols cache after the reload\n        agentProtocols = null;\n        return this;\n    }"}, {"instruction": "\u8bc6\u522bJDBC\u9a71\u52a8\u540d\n\n@param ds \u6570\u636e\u6e90\n@return \u9a71\u52a8", "input": "Java", "output": "public static String identifyDriver(DataSource ds) {\r\n\t\tif(ds instanceof DataSourceWrapper) {\r\n\t\t\tfinal String driver = ((DataSourceWrapper)ds).getDriver();\r\n\t\t\tif(StrUtil.isNotBlank(driver)) {\r\n\t\t\t\treturn driver;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tConnection conn = null;\r\n\t\tString driver = null;\r\n\t\ttry {\r\n\t\t\ttry {\r\n\t\t\t\tconn = ds.getConnection();\r\n\t\t\t} catch (SQLException e) {\r\n\t\t\t\tthrow new DbRuntimeException(\"Get Connection error !\", e);\r\n\t\t\t} catch (NullPointerException e) {\r\n\t\t\t\tthrow new DbRuntimeException(\"Unexpected NullPointException, maybe [jdbcUrl] or [url] is empty!\", e);\r\n\t\t\t}\r\n\t\t\tdriver = identifyDriver(conn);\r\n\t\t} finally {\r\n\t\t\tDbUtil.close(conn);\r\n\t\t}\r\n\r\n\t\treturn driver;\r\n\t}"}, {"instruction": "Gets the action (first instance to be found) of a specified type that contributed to this build.\n\n@param type\n@return The action or <code>null</code> if no such actions exist.\n@see #getActions(Class)", "input": "Java", "output": "public <T extends Action> T getAction(Class<T> type) {\n        // Shortcut: if the persisted list has one, return it.\n        for (Action a : getActions()) {\n            if (type.isInstance(a)) {\n                return type.cast(a);\n            }\n        }\n        // Otherwise check transient factories.\n        for (TransientActionFactory<?> taf : TransientActionFactory.factoriesFor(getClass(), type)) {\n            for (Action a : createFor(taf)) {\n                if (type.isInstance(a)) {\n                    return type.cast(a);\n                }\n            }\n        }\n        return null;\n    }"}, {"instruction": "MD5\u52a0\u5bc6\u6587\u4ef6\n\n@param file \u6587\u4ef6\n@return \u6587\u4ef6\u7684MD5\u6821\u9a8c\u7801", "input": "Java", "output": "public static byte[] md5FileToByte(File file) {\n        if (file == null) return null;\n        FileInputStream   fis               = null;\n        DigestInputStream digestInputStream = null;\n        try {\n            fis = new FileInputStream(file);\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            digestInputStream = new DigestInputStream(fis, md);\n            byte[] buffer = new byte[256 * 1024];\n            while (digestInputStream.read(buffer) > 0) ;\n            md = digestInputStream.getMessageDigest();\n            return md.digest();\n        } catch (NoSuchAlgorithmException | IOException e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            IOKit.closeQuietly(fis);\n            IOKit.closeQuietly(digestInputStream);\n        }\n    }"}, {"instruction": "This method returns 2D array, where each row represents corresponding label\n\n@param labels\n@return", "input": "Java", "output": "@Override\n    public INDArray getWordVectors(@NonNull Collection<String> labels) {\n        int indexes[] = new int[labels.size()];\n        int cnt = 0;\n        boolean useIndexUnknown = useUnknown && vocab.containsWord(getUNK());\n\n        for (String label : labels) {\n            if (vocab.containsWord(label)) {\n                indexes[cnt] = vocab.indexOf(label);\n            } else\n                indexes[cnt] = useIndexUnknown ? vocab.indexOf(getUNK()) : -1;\n            cnt++;\n        }\n\n        while (ArrayUtils.contains(indexes, -1)) {\n            indexes = ArrayUtils.removeElement(indexes, -1);\n        }\n        if (indexes.length == 0) {\n                return Nd4j.empty(((InMemoryLookupTable)lookupTable).getSyn0().dataType());\n        }\n\n        INDArray result = Nd4j.pullRows(lookupTable.getWeights(), 1, indexes);\n        return result;\n    }"}, {"instruction": "This method updates VocabCache and all it's elements with Huffman indexes\nPlease note: it should be the same VocabCache as was used for Huffman tree initialization\n\n@param cache VocabCache to be updated.", "input": "Java", "output": "public void applyIndexes(VocabCache<? extends SequenceElement> cache) {\n        if (!buildTrigger)\n            build();\n\n        for (int a = 0; a < words.size(); a++) {\n            if (words.get(a).getLabel() != null) {\n                cache.addWordToIndex(a, words.get(a).getLabel());\n            } else {\n                cache.addWordToIndex(a, words.get(a).getStorageId());\n            }\n\n            words.get(a).setIndex(a);\n        }\n    }"}, {"instruction": "This should be overriden for any custom columns", "input": "Java", "output": "@Override\n\tpublic Object getValueAt(int row, int col) {\n\t\t// Get the href and the required field\n\t\tHistoryReference href = hrefList.get(row);\n\t\ttry {\n\t\t\tswitch (this.columns[col]) {\n\t\t\tcase HREF_ID:\t\treturn href.getHistoryId();\n\t\t\tcase TYPE_FLAG:\t\treturn this.getHrefTypeIcon(href);\n\t\t\tcase METHOD:\t\treturn href.getMethod();\n\t\t\tcase URL:\t\t\treturn href.getURI().toString();\n\t\t\tcase CODE:\t\t\treturn href.getStatusCode();\n\t\t\tcase REASON:\t\treturn href.getReason();\n\t\t\tcase RTT:\t\t\treturn href.getRtt();\n\t\t\tcase SIZE:\t\t\treturn href.getResponseBodyLength();\n\t\t\tcase SESSION_ID:\treturn href.getSessionId();\n\t\t\tcase ALERT_FLAG:\treturn this.getHrefAlertIcon(href);\n\t\t\tcase TAGS:\t\t\treturn listToCsv(href.getTags());\n\t\t\tdefault:\t\t\treturn null;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(e.getMessage(), e);\n\t\t\treturn null;\n\t\t}\n\t}"}, {"instruction": "\u6784\u5efa\u67e5\u8be2\u8ba2\u5355\u53c2\u6570\n\n@return <Map<String, String>>", "input": "Java", "output": "public Map<String, String> orderQueryBuild() {\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tif (getPayModel().equals(PayModel.SERVICEMODE)) {\n\t\t\tmap.put(\"sub_mch_id\", getSubMchId());\n\t\t\tmap.put(\"sub_appid\", getSubAppId());\n\t\t}\n\n\t\tmap.put(\"appid\", getAppId());\n\t\tmap.put(\"mch_id\", getMchId());\n\n\t\tif (StrKit.notBlank(getTransactionId())) {\n\t\t\tmap.put(\"transaction_id\", getTransactionId());\n\t\t} else {\n\t\t\tif (StrKit.isBlank(getOutTradeNo())) {\n\t\t\t\tthrow new IllegalArgumentException(\"out_trade_no,transaction_id \u4e0d\u80fd\u540c\u65f6\u4e3a\u7a7a\");\n\t\t\t}\n\t\t\tmap.put(\"out_trade_no\", getOutTradeNo());\n\t\t}\n\t\tmap.put(\"nonce_str\", String.valueOf(System.currentTimeMillis()));\n\t\tmap.put(\"sign\", PaymentKit.createSign(map, getPaternerKey()));\n\t\treturn map;\n\t}"}, {"instruction": "Method that assigns a unique {@link Long} value to all elements in the input data set as described below.\n<ul>\n<li> a map function is applied to the input data set\n<li> each map task holds a counter c which is increased for each record\n<li> c is shifted by n bits where n = log2(number of parallel tasks)\n<li> to create a unique ID among all tasks, the task id is added to the counter\n<li> for each record, the resulting counter is collected\n</ul>\n\n@param input the input data set\n@return a data set of tuple 2 consisting of ids and initial values.", "input": "Java", "output": "public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {\n\n\t\treturn input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {\n\n\t\t\tlong maxBitSize = getBitSize(Long.MAX_VALUE);\n\t\t\tlong shifter = 0;\n\t\t\tlong start = 0;\n\t\t\tlong taskId = 0;\n\t\t\tlong label = 0;\n\n\t\t\t@Override\n\t\t\tpublic void open(Configuration parameters) throws Exception {\n\t\t\t\tsuper.open(parameters);\n\t\t\t\tshifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1);\n\t\t\t\ttaskId = getRuntimeContext().getIndexOfThisSubtask();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {\n\t\t\t\tfor (T value : values) {\n\t\t\t\t\tlabel = (start << shifter) + taskId;\n\n\t\t\t\t\tif (getBitSize(start) + shifter < maxBitSize) {\n\t\t\t\t\t\tout.collect(new Tuple2<>(label, value));\n\t\t\t\t\t\tstart++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Exception(\"Exceeded Long value range while generating labels\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}"}, {"instruction": "Notify all {@link ChannelFuture}s that were registered with {@link #add(ChannelPromise, int)} and\ntheir pendingDatasize isis smaller then the current writeCounter returned by {@link #writeCounter()}.\n\nAfter a {@link ChannelFuture} was notified it will be removed from this {@link ChannelFlushPromiseNotifier} and\nso not receive anymore notification.\n\nThe rest of the remaining {@link ChannelFuture}s will be failed with the given {@link Throwable}.\n\nSo after this operation this {@link ChannelFutureListener} is empty.", "input": "Java", "output": "public ChannelFlushPromiseNotifier notifyPromises(Throwable cause) {\n        notifyPromises();\n        for (;;) {\n            FlushCheckpoint cp = flushCheckpoints.poll();\n            if (cp == null) {\n                break;\n            }\n            if (tryNotify) {\n                cp.promise().tryFailure(cause);\n            } else {\n                cp.promise().setFailure(cause);\n            }\n        }\n        return this;\n    }"}, {"instruction": "Log {@link CasServiceTicketValidatedEvent} at debug level.\n\n@param e the event", "input": "Java", "output": "@EventListener\n    public void logServiceTicketValidatedEvent(final CasServiceTicketValidatedEvent e) {\n        val principal = e.getServiceTicket().getTicketGrantingTicket().getAuthentication().getPrincipal();\n        LOGGER.debug(VALIDATED_ST_MSG,\n                e.getServiceTicket().getCreationTime(),\n                e.getServiceTicket().getId(),\n                e.getServiceTicket().getService().getId(),\n                principal.getId(),\n                principal.getAttributes());\n    }"}, {"instruction": "Creates a new config option, using this option's key and default value, and\nadding the given deprecated keys.\n\n<p>When obtaining a value from the configuration via {@link Configuration#getValue(ConfigOption)},\nthe deprecated keys will be checked in the order provided to this method. The first key for which\na value is found will be used - that value will be returned.\n\n@param deprecatedKeys The deprecated keys, in the order in which they should be checked.\n@return A new config options, with the given deprecated keys.", "input": "Java", "output": "public ConfigOption<T> withDeprecatedKeys(String... deprecatedKeys) {\n\t\tfinal Stream<FallbackKey> newDeprecatedKeys = Arrays.stream(deprecatedKeys).map(FallbackKey::createDeprecatedKey);\n\t\tfinal Stream<FallbackKey> currentAlternativeKeys = Arrays.stream(this.fallbackKeys);\n\n\t\t// put deprecated keys last so that they are de-prioritized\n\t\tfinal FallbackKey[] mergedAlternativeKeys = Stream.concat(currentAlternativeKeys, newDeprecatedKeys)\n\t\t\t.toArray(FallbackKey[]::new);\n\t\treturn new ConfigOption<>(key, description, defaultValue, mergedAlternativeKeys);\n\t}"}, {"instruction": "<pre>\nUses YarnClient to kill the job on HDFS.\nUsing JobClient only works partially:\nIf yarn container has started but spark job haven't, it will kill\nIf spark job has started, the cancel will hang until the spark job is complete\nIf the spark job is complete, it will return immediately, with a job not found on job tracker\n</pre>", "input": "Java", "output": "public static void killJobOnCluster(String applicationId, Logger log) throws YarnException,\n      IOException {\n\n    YarnConfiguration yarnConf = new YarnConfiguration();\n    YarnClient yarnClient = YarnClient.createYarnClient();\n    yarnClient.init(yarnConf);\n    yarnClient.start();\n\n    String[] split = applicationId.split(\"_\");\n    ApplicationId aid = ApplicationId.newInstance(Long.parseLong(split[1]),\n        Integer.parseInt(split[2]));\n\n    log.info(\"start klling application: \" + aid);\n    yarnClient.killApplication(aid);\n    log.info(\"successfully killed application: \" + aid);\n  }"}, {"instruction": "Direct method for a complete ContentMatcher instance creation.\n@param xmlInputStream the stream of the XML file that need to be used for initialization\n@return a ContentMatcher instance", "input": "Java", "output": "public static ContentMatcher getInstance(InputStream xmlInputStream) {\r\n        ContentMatcher cm = new ContentMatcher();\r\n\r\n        // Load the pattern definitions from an XML file\r\n        try {\r\n            cm.loadXMLPatternDefinitions(xmlInputStream);\r\n            \r\n        } catch (JDOMException | IOException ex) {\r\n            throw new IllegalArgumentException(\"Failed to initialize the ContentMatcher object using that stream\", ex);\r\n        }\r\n        \r\n        return cm;\r\n    }"}, {"instruction": "Lists all shared VPC host projects visible to the user in an organization.\n\n<p>Sample code:\n\n<pre><code>\ntry (ProjectClient projectClient = ProjectClient.create()) {\nProjectName project = ProjectName.of(\"[PROJECT]\");\nProjectsListXpnHostsRequest projectsListXpnHostsRequestResource = ProjectsListXpnHostsRequest.newBuilder().build();\nfor (Project element : projectClient.listXpnHostsProjects(project, projectsListXpnHostsRequestResource).iterateAll()) {\n// doThingsWith(element);\n}\n}\n</code></pre>\n\n@param project Project ID for this request.\n@param projectsListXpnHostsRequestResource\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final ListXpnHostsProjectsPagedResponse listXpnHostsProjects(\n      ProjectName project, ProjectsListXpnHostsRequest projectsListXpnHostsRequestResource) {\n    ListXpnHostsProjectsHttpRequest request =\n        ListXpnHostsProjectsHttpRequest.newBuilder()\n            .setProject(project == null ? null : project.toString())\n            .setProjectsListXpnHostsRequestResource(projectsListXpnHostsRequestResource)\n            .build();\n    return listXpnHostsProjects(request);\n  }"}, {"instruction": "Execute the specified TransformProcess with the given <i>sequence</i> input data<br>\nNote: this method can only be used if the TransformProcess starts with sequence data, but returns <i>non-sequential</i>\ndata (after reducing or converting sequential data to individual examples)\n\n@param inputSequence    Input sequence data to process\n@param transformProcess TransformProcess to execute\n@return Processed (non-sequential) data", "input": "Java", "output": "public static List<List<Writable>> executeSequenceToSeparate(List<List<List<Writable>>> inputSequence,\n                                                                 TransformProcess transformProcess) {\n        if (transformProcess.getFinalSchema() instanceof SequenceSchema) {\n            throw new IllegalStateException(\"Cannot return sequence data with this method\");\n        }\n\n        return execute(null, inputSequence, transformProcess).getFirst();\n    }"}, {"instruction": "Create a new SAML object.\n\n@param <T>        the generic type\n@param objectType the object type\n@return the t", "input": "Java", "output": "@SneakyThrows\n    public <T extends SAMLObject> T newSamlObject(final Class<T> objectType) {\n        val qName = getSamlObjectQName(objectType);\n        val builder = (SAMLObjectBuilder<T>)\n            XMLObjectProviderRegistrySupport.getBuilderFactory().getBuilder(qName);\n        if (builder == null) {\n            throw new IllegalStateException(\"No SAML object builder is registered for class \" + objectType.getName());\n        }\n        return objectType.cast(builder.buildObject(qName));\n    }"}, {"instruction": "add additional config entries from the Flink config to the Hadoop config", "input": "Java", "output": "private org.apache.hadoop.conf.Configuration loadHadoopConfigFromFlink() {\n\t\torg.apache.hadoop.conf.Configuration hadoopConfig = new org.apache.hadoop.conf.Configuration();\n\t\tfor (String key : flinkConfig.keySet()) {\n\t\t\tfor (String prefix : flinkConfigPrefixes) {\n\t\t\t\tif (key.startsWith(prefix)) {\n\t\t\t\t\tString newKey = hadoopConfigPrefix + key.substring(prefix.length());\n\t\t\t\t\tString newValue = fixHadoopConfig(key, flinkConfig.getString(key, null));\n\t\t\t\t\thadoopConfig.set(newKey, newValue);\n\n\t\t\t\t\tLOG.debug(\"Adding Flink config entry for {} as {} to Hadoop config\", key, newKey);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hadoopConfig;\n\t}"}, {"instruction": "Invokes a nullary static factory method using reflection to stay backwards-compatible with older JDKs.\n\n@param fqcn The fully qualified class name of the type to be produced.\n@param methodName The name of the factory method.\n@return the object produced.", "input": "Java", "output": "private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {\n        try {\n            final Class<?> type = Class.forName(fqcn);\n            final Method method = type.getMethod(methodName);\n\n            return method.invoke(null);\n            // any exception is really unexpected since the type name has\n            // already been verified\n        } catch (final Exception e) {\n            throw new InstantiationException(\n                    String.format(\"Could not create %s#%s(): %s\", fqcn, methodName, e), e);\n        }\n    }"}, {"instruction": "***********************************************************************", "input": "Java", "output": "private Class<?> attemptFromContextLoader(final String driverClassName) {\n      final ClassLoader threadContextClassLoader = Thread.currentThread().getContextClassLoader();\n      if (threadContextClassLoader != null) {\n         try {\n            final Class<?> driverClass = threadContextClassLoader.loadClass(driverClassName);\n            LOGGER.debug(\"Driver class {} found in Thread context class loader {}\", driverClassName, threadContextClassLoader);\n            return driverClass;\n         } catch (ClassNotFoundException e) {\n            LOGGER.debug(\"Driver class {} not found in Thread context class loader {}, trying classloader {}\",\n               driverClassName, threadContextClassLoader, this.getClass().getClassLoader());\n         }\n      }\n\n      return null;\n   }"}, {"instruction": "\u5c06\u952e\u503c\u5bf9\u52a0\u5165\u5230\u5bf9\u5e94\u5206\u7ec4\u4e2d\n\n@param group \u5206\u7ec4\n@param key \u952e\n@param value \u503c\n@return \u6b64key\u4e4b\u524d\u5b58\u5728\u7684\u503c\uff0c\u5982\u679c\u6ca1\u6709\u8fd4\u56denull", "input": "Java", "output": "public String put(String group, String key, String value) {\r\n\t\tgroup = StrUtil.nullToEmpty(group).trim();\r\n\t\twriteLock.lock();\r\n\t\ttry {\r\n\t\t\tLinkedHashMap<String, String> valueMap = this.get(group);\r\n\t\t\tif (null == valueMap) {\r\n\t\t\t\tvalueMap = new LinkedHashMap<>();\r\n\t\t\t\tthis.put(group, valueMap);\r\n\t\t\t}\r\n\t\t\tthis.size = -1;\r\n\t\t\treturn valueMap.put(key, value);\r\n\t\t} finally {\r\n\t\t\twriteLock.unlock();\r\n\t\t}\r\n\t}"}, {"instruction": "Extracts the Win32 error message from {@link Throwable} if possible.\n\n@return\nnull if there seems to be no error code or if the platform is not Win32.", "input": "Java", "output": "@CheckForNull\n    public static String getWin32ErrorMessage(Throwable e) {\n        String msg = e.getMessage();\n        if(msg!=null) {\n            Matcher m = errorCodeParser.matcher(msg);\n            if(m.matches()) {\n                try {\n                    ResourceBundle rb = ResourceBundle.getBundle(\"/hudson/win32errors\");\n                    return rb.getString(\"error\"+m.group(1));\n                } catch (Exception ignored) {\n                    // silently recover from resource related failures\n                }\n            }\n        }\n\n        if(e.getCause()!=null)\n            return getWin32ErrorMessage(e.getCause());\n        return null; // no message\n    }"}, {"instruction": "Specifies a writer instance that caches should notify each time an entry is explicitly created\nor modified, or removed for any {@linkplain RemovalCause reason}. The writer is not notified\nwhen an entry is loaded or computed. Each cache created by this builder will invoke this writer\nas part of the atomic operation that modifies the cache.\n<p>\n<b>Warning:</b> after invoking this method, do not continue to use <i>this</i> cache builder\nreference; instead use the reference this method <i>returns</i>. At runtime, these point to the\nsame instance, but only the returned reference has the correct generic type information so as\nto ensure type safety. For best results, use the standard method-chaining idiom illustrated in\nthe class documentation above, configuring a builder and building your cache in a single\nstatement. Failure to heed this advice can result in a {@link ClassCastException} being thrown\nby a cache operation at some <i>undefined</i> point in the future.\n<p>\n<b>Warning:</b> any exception thrown by {@code writer} will be propagated to the {@code Cache}\nuser.\n<p>\nThis feature cannot be used in conjunction with {@link #weakKeys()} or {@link #buildAsync}.\n\n@param writer a writer instance that caches should notify each time an entry is explicitly\ncreated or modified, or removed for any reason\n@param <K1> the key type of the writer\n@param <V1> the value type of the writer\n@return the cache builder reference that should be used instead of {@code this} for any\nremaining configuration and cache building\n@throws IllegalStateException if a writer was already set or if the key strength is weak\n@throws NullPointerException if the specified writer is null", "input": "Java", "output": "@NonNull\n  public <K1 extends K, V1 extends V> Caffeine<K1, V1> writer(\n      @NonNull CacheWriter<? super K1, ? super V1> writer) {\n    requireState(this.writer == null, \"Writer was already set to %s\", this.writer);\n    requireState(keyStrength == null, \"Weak keys may not be used with CacheWriter\");\n\n    @SuppressWarnings(\"unchecked\")\n    Caffeine<K1, V1> self = (Caffeine<K1, V1>) this;\n    self.writer = requireNonNull(writer);\n    return self;\n  }"}, {"instruction": "Gets response mode type.\n\n@param context the context\n@return the response type", "input": "Java", "output": "public static OAuth20ResponseModeTypes getResponseModeType(final J2EContext context) {\n        val responseType = context.getRequestParameter(OAuth20Constants.RESPONSE_MODE);\n        val type = Arrays.stream(OAuth20ResponseModeTypes.values())\n            .filter(t -> t.getType().equalsIgnoreCase(responseType))\n            .findFirst()\n            .orElse(OAuth20ResponseModeTypes.NONE);\n        LOGGER.debug(\"OAuth response type is [{}]\", type);\n        return type;\n    }"}, {"instruction": "gets quoted attribute value: QUOTATION *( quotechar / pair ) QUOTATION", "input": "Java", "output": "private String quotedAV() {\n    pos++;\n    beg = pos;\n    end = beg;\n    while (true) {\n\n      if (pos == length) {\n        throw new IllegalStateException(\"Unexpected end of DN: \" + dn);\n      }\n\n      if (chars[pos] == '\"') {\n        // enclosing quotation was found\n        pos++;\n        break;\n      } else if (chars[pos] == '\\\\') {\n        chars[end] = getEscaped();\n      } else {\n        // shift char: required for string with escaped chars\n        chars[end] = chars[pos];\n      }\n      pos++;\n      end++;\n    }\n\n    // skip trailing space chars before comma or semicolon.\n    // (compatibility with RFC 1779)\n    for (; pos < length && chars[pos] == ' '; pos++) {\n    }\n\n    return new String(chars, beg, end - beg);\n  }"}, {"instruction": "\u6839\u636e\u540d\u5b57\u5728manager\u914d\u7f6e\u7684\u6620\u5c04\u5173\u7cfb\uff0c\u8f6c\u5316\u4e3a\u76ee\u6807\u7684\u5b57\u6bb5\u540d\u5b57", "input": "Java", "output": "private String translateColumnName(String srcColumnName, DataMediaPair dataMediaPair,\n                                       Multimap<String, String> translateDict) {\n        if (dataMediaPair.getColumnPairMode().isExclude() || CollectionUtils.isEmpty(dataMediaPair.getColumnPairs())) {\n            return srcColumnName; // \u9ed8\u8ba4\u540c\u540d\n        }\n\n        Collection<String> tColumnNames = translateDict.get(srcColumnName);\n        if (CollectionUtils.isEmpty(tColumnNames)) {\n            throw new TransformException(srcColumnName + \" is not found in column pairs: \" + translateDict.toString());\n        }\n        String columnName = tColumnNames.iterator().next();\n\n        return columnName;\n    }"}, {"instruction": "------------------------------------------------------------------------", "input": "Java", "output": "private static String getAndCheckOption(Configuration config, ConfigOption<String> primaryOption, ConfigOption<String> fallbackOption) {\n\t\tString value = config.getString(primaryOption, config.getString(fallbackOption));\n\t\tif (value != null) {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalConfigurationException(\"The config option \" + primaryOption.key() +\n\t\t\t\t\t\" or \" + fallbackOption.key() + \" is missing.\");\n\t\t}\n\t}"}, {"instruction": "Get parameter sets.\n\n@param statement statement\n@return parameter sets", "input": "Java", "output": "public List<List<Object>> getParameterSet(final Statement statement) {\n        List<List<Object>> result = new LinkedList<>();\n        for (ShardingExecuteGroup<StatementExecuteUnit> each : getExecuteGroups()) {\n            Optional<StatementExecuteUnit> target = getStatementExecuteUnit(statement, each);\n            if (target.isPresent()) {\n                result = getParameterSets(target.get());\n                break;\n            }\n        }\n        return result;\n    }"}, {"instruction": "returns the version of the backed up plugin,\nor null if there's no back up.", "input": "Java", "output": "@Exported\n    public String getBackupVersion() {\n        File backup = getBackupFile();\n        if (backup.exists()) {\n            try {\n                try (JarFile backupPlugin = new JarFile(backup)) {\n                    return backupPlugin.getManifest().getMainAttributes().getValue(\"Plugin-Version\");\n                }\n            } catch (IOException e) {\n                LOGGER.log(WARNING, \"Failed to get backup version from \" + backup, e);\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }"}, {"instruction": "Returns the class name for the given logical name and trailing name. For example \"person\" and \"Controller\" would evaluate to \"PersonController\".\n\n@param logicalName  The logical name\n@param trailingName The trailing name\n@return The class name", "input": "Java", "output": "public static String getClassName(String logicalName, String trailingName) {\n        if (isBlank(logicalName)) {\n            throw new IllegalArgumentException(\"Argument [logicalName] cannot be null or blank\");\n        }\n\n        String className = logicalName.substring(0, 1).toUpperCase(Locale.ENGLISH) + logicalName.substring(1);\n        if (trailingName != null) {\n            className = className + trailingName;\n        }\n        return className;\n    }"}, {"instruction": "This method is handling the IllegalAccess exceptions of Field.get()", "input": "Java", "output": "public final Object accessField(Field field, Object object) {\n\t\ttry {\n\t\t\tobject = field.get(object);\n\t\t} catch (NullPointerException npex) {\n\t\t\tthrow new NullKeyFieldException(\"Unable to access field \"+field+\" on object \"+object);\n\t\t} catch (IllegalAccessException iaex) {\n\t\t\tthrow new RuntimeException(\"This should not happen since we call setAccesssible(true) in PojoTypeInfo.\"\n\t\t\t+ \" fields: \" + field + \" obj: \" + object);\n\t\t}\n\t\treturn object;\n\t}"}, {"instruction": "\u904d\u5386\u67d0\u4e2a\u76ee\u5f55\u4e0b\u6240\u6709\u6587\u4ef6\u6216\u76ee\u5f55\uff0c\u4e0d\u4f1a\u9012\u5f52\u904d\u5386\n\n@param path \u904d\u5386\u67d0\u4e2a\u76ee\u5f55\u4e0b\u6240\u6709\u6587\u4ef6\u6216\u76ee\u5f55\n@param filter \u6587\u4ef6\u6216\u76ee\u5f55\u8fc7\u6ee4\u5668\uff0c\u53ef\u4ee5\u5b9e\u73b0\u8fc7\u6ee4\u5668\u8fd4\u56de\u81ea\u5df1\u9700\u8981\u7684\u6587\u4ef6\u6216\u76ee\u5f55\u540d\u5217\u8868\n@return \u76ee\u5f55\u6216\u6587\u4ef6\u540d\u5217\u8868\n@since 4.0.5", "input": "Java", "output": "public List<String> ls(String path, final Filter<LsEntry> filter) {\r\n\t\tfinal List<String> fileNames = new ArrayList<>();\r\n\t\ttry {\r\n\t\t\tchannel.ls(path, new LsEntrySelector() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic int select(LsEntry entry) {\r\n\t\t\t\t\tString fileName = entry.getFilename();\r\n\t\t\t\t\tif (false == StrUtil.equals(\".\", fileName) && false == StrUtil.equals(\"..\", fileName)) {\r\n\t\t\t\t\t\tif (null == filter || filter.accept(entry)) {\r\n\t\t\t\t\t\t\tfileNames.add(entry.getFilename());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn CONTINUE;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} catch (SftpException e) {\r\n\t\t\tthrow new JschRuntimeException(e);\r\n\t\t}\r\n\t\treturn fileNames;\r\n\t}"}, {"instruction": "\u5ba2\u6237\u7aef\u5df2\u7ecf\u8d85\u65f6\u4e86\uff08\u4f8b\u5982\u5728\u4e1a\u52a1\u6267\u884c\u65f6\u95f4\u592a\u957f\uff09\uff0c\u4e22\u5f03\u8fd9\u4e2a\u8fd4\u56de\u503c\n\n@param appName       \u5e94\u7528\n@param serviceName   \u670d\u52a1\n@param remoteAddress \u8fdc\u7a0b\u5730\u5740\n@return \u4e22\u5f03\u7684\u5f02\u5e38", "input": "Java", "output": "private SofaRpcException clientTimeoutWhenSendResponse(String appName, String serviceName, String remoteAddress) {\n        String errorMsg = LogCodes.getLog(\n            LogCodes.ERROR_DISCARD_TIMEOUT_RESPONSE, serviceName, remoteAddress);\n        if (LOGGER.isWarnEnabled(appName)) {\n            LOGGER.warnWithApp(appName, errorMsg);\n        }\n        return new SofaRpcException(RpcErrorType.SERVER_UNDECLARED_ERROR, errorMsg);\n    }"}, {"instruction": "Returns an unmodifiable snapshot map ordered by the provided iterator. Beware that obtaining\nthe mappings is <em>NOT</em> a constant-time operation.\n\n@param iteratorSupplier the iterator\n@param limit the maximum number of entries\n@param transformer a function that unwraps the value\n@return an unmodifiable snapshot in the iterator's order", "input": "Java", "output": "Map<K, V> fixedSnapshot(Supplier<Iterator<Node<K, V>>> iteratorSupplier,\n      int limit, Function<V, V> transformer) {\n    requireArgument(limit >= 0);\n    evictionLock.lock();\n    try {\n      maintenance(/* ignored */ null);\n\n      int initialCapacity = Math.min(limit, size());\n      Iterator<Node<K, V>> iterator = iteratorSupplier.get();\n      Map<K, V> map = new LinkedHashMap<>(initialCapacity);\n      while ((map.size() < limit) && iterator.hasNext()) {\n        Node<K, V> node = iterator.next();\n        K key = node.getKey();\n        V value = transformer.apply(node.getValue());\n        if ((key != null) && (value != null) && node.isAlive()) {\n          map.put(key, value);\n        }\n      }\n      return Collections.unmodifiableMap(map);\n    } finally {\n      evictionLock.unlock();\n    }\n  }"}, {"instruction": "Create a DataBuffer for indices of given arrays of indices.\n@param indices\n@param shape\n@return", "input": "Java", "output": "protected static DataBuffer createIndiceBuffer(long[][] indices, long[] shape){\n        checkNotNull(indices);\n        checkNotNull(shape);\n        if(indices.length == 0){\n            return Nd4j.getDataBufferFactory().createLong(shape.length);\n        }\n\n        if (indices.length == shape.length) {\n            return Nd4j.createBuffer(ArrayUtil.flattenF(indices));\n        }\n\n        return Nd4j.createBuffer(ArrayUtil.flatten(indices));\n    }"}, {"instruction": "Start the monitoring process.", "input": "Java", "output": "@Override\n    public synchronized void start() {\n        if (monitorActive) {\n            return;\n        }\n        lastTime.set(milliSecondFromNano());\n        long localCheckInterval = checkInterval.get();\n        if (localCheckInterval > 0) {\n            monitorActive = true;\n            monitor = new MixedTrafficMonitoringTask((GlobalChannelTrafficShapingHandler) trafficShapingHandler, this);\n            scheduledFuture =\n                executor.schedule(monitor, localCheckInterval, TimeUnit.MILLISECONDS);\n        }\n    }"}, {"instruction": "Check if job is paused.\n\n@return true if job is paused, false otherwise.", "input": "Java", "output": "public synchronized boolean isJobPaused(final String jobName, final String groupName)\n      throws SchedulerException {\n    if (!ifJobExist(jobName, groupName)) {\n      throw new SchedulerException(String.format(\"Job (job name %s, group name %s) doesn't \"\n          + \"exist'\", jobName, groupName));\n    }\n    final JobKey jobKey = new JobKey(jobName, groupName);\n    final JobDetail jobDetail = this.scheduler.getJobDetail(jobKey);\n    final List<? extends Trigger> triggers = this.scheduler.getTriggersOfJob(jobDetail.getKey());\n    for (final Trigger trigger : triggers) {\n      final TriggerState triggerState = this.scheduler.getTriggerState(trigger.getKey());\n      if (TriggerState.PAUSED.equals(triggerState)) {\n        return true;\n      }\n    }\n    return false;\n  }"}, {"instruction": "Returns the cache as a {@link Maybe}.\n\n@param name The name of the cache to retrieve\n@return The cache as a {@link Single}", "input": "Java", "output": "@Read\n    public Maybe<Map<String, Object>> getCache(@NotBlank @Selector String name) {\n        try {\n            final Cache<Object> cache = cacheManager.getCache(name);\n            return Flowable.fromPublisher(cache.getCacheInfo())\n                           .map(CacheInfo::get)\n                           .singleElement();\n        } catch (ConfigurationException e) {\n            // no cache exists\n            return Maybe.empty();\n        }\n    }"}, {"instruction": "Text coming from an input stream considered as one document\n\n@param is    the input stream to read from\n@param label the label to assign\n@return a dataset with a applyTransformToDestination of weights(relative to impl; could be word counts or tfidf scores)", "input": "Java", "output": "@Override\n    public DataSet vectorize(InputStream is, String label) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n            String line = \"\";\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            return vectorize(builder.toString(), label);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }"}, {"instruction": "\u63d0\u4f9b\u7cbe\u786e\u7684\u51cf\u6cd5\u8fd0\u7b97<br>\n\u5982\u679c\u4f20\u5165\u591a\u4e2a\u503c\u4e3anull\u6216\u8005\u7a7a\uff0c\u5219\u8fd4\u56de0\n\n@param values \u591a\u4e2a\u88ab\u51cf\u503c\n@return \u5dee\n@since 4.0.0", "input": "Java", "output": "public static BigDecimal sub(Number... values) {\r\n\t\tif (ArrayUtil.isEmpty(values)) {\r\n\t\t\treturn BigDecimal.ZERO;\r\n\t\t}\r\n\r\n\t\tNumber value = values[0];\r\n\t\tBigDecimal result = new BigDecimal(null == value ? \"0\" : value.toString());\r\n\t\tfor (int i = 1; i < values.length; i++) {\r\n\t\t\tvalue = values[i];\r\n\t\t\tif (null != value) {\r\n\t\t\t\tresult = result.subtract(new BigDecimal(value.toString()));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}"}, {"instruction": "When a ephemeral worker node disappears from ZK, incomplete running tasks will be retried by\nthe logic in the status listener. We still have to make sure there are no tasks assigned\nto the worker but not yet running.\n\n@param worker - the removed worker", "input": "Java", "output": "private void removeWorker(final Worker worker)\n  {\n    log.info(\"Kaboom! Worker[%s] removed!\", worker.getHost());\n\n    final ZkWorker zkWorker = zkWorkers.get(worker.getHost());\n    if (zkWorker != null) {\n      try {\n        scheduleTasksCleanupForWorker(worker.getHost(), getAssignedTasks(worker));\n      }\n      catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n      finally {\n        try {\n          zkWorker.close();\n        }\n        catch (Exception e) {\n          log.error(e, \"Exception closing worker[%s]!\", worker.getHost());\n        }\n        zkWorkers.remove(worker.getHost());\n        checkBlackListedNodes();\n      }\n    }\n    lazyWorkers.remove(worker.getHost());\n  }"}, {"instruction": "Opens the interactive CLI shell.", "input": "Java", "output": "public void open() {\n\t\tisRunning = true;\n\n\t\t// print welcome\n\t\tterminal.writer().append(CliStrings.MESSAGE_WELCOME);\n\n\t\t// begin reading loop\n\t\twhile (isRunning) {\n\t\t\t// make some space to previous command\n\t\t\tterminal.writer().append(\"\\n\");\n\t\t\tterminal.flush();\n\n\t\t\tfinal String line;\n\t\t\ttry {\n\t\t\t\tline = lineReader.readLine(prompt, null, (MaskingCallback) null, null);\n\t\t\t} catch (UserInterruptException e) {\n\t\t\t\t// user cancelled line with Ctrl+C\n\t\t\t\tcontinue;\n\t\t\t} catch (EndOfFileException | IOError e) {\n\t\t\t\t// user cancelled application with Ctrl+D or kill\n\t\t\t\tbreak;\n\t\t\t} catch (Throwable t) {\n\t\t\t\tthrow new SqlClientException(\"Could not read from command line.\", t);\n\t\t\t}\n\t\t\tif (line == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfinal Optional<SqlCommandCall> cmdCall = parseCommand(line);\n\t\t\tcmdCall.ifPresent(this::callCommand);\n\t\t}\n\t}"}, {"instruction": "Handles expected Attribute-related exceptions. Since the attribute index is a separate segment from the main one,\nit is highly likely that it may get temporarily out of sync with the main one, thus causing spurious StreamSegmentSealedExceptions\nor StreamSegmentNotExistsExceptions. If we get either of those, and they are consistent with our current state, the\nwe can safely ignore them; otherwise we should be rethrowing them.", "input": "Java", "output": "private CompletableFuture<Void> handleAttributeException(CompletableFuture<Void> future) {\n        return Futures.exceptionallyExpecting(\n                future,\n                ex -> (ex instanceof StreamSegmentSealedException && this.metadata.isSealedInStorage())\n                        || ((ex instanceof StreamSegmentNotExistsException || ex instanceof StreamSegmentMergedException)\n                        && (this.metadata.isMerged() || this.metadata.isDeleted())),\n                null);\n    }"}, {"instruction": "Returns the caches as a {@link Single}.\n\n@return The caches as a {@link Single}", "input": "Java", "output": "@Read\n    public Single<Map<String, Object>> getCaches() {\n        return Flowable.fromIterable(cacheManager.getCacheNames())\n                       .flatMapMaybe(n -> Flowable.fromPublisher(cacheManager.getCache(n).getCacheInfo()).firstElement())\n                       .reduce(new HashMap<>(), (seed, info) -> {\n                           seed.put(info.getName(), info.get());\n                           return seed;\n                       }).map(objectObjectHashMap -> Collections.singletonMap(\n                           NAME, objectObjectHashMap\n                       ));\n    }"}, {"instruction": "Try to instantiate the given class.\n\n@param name        The class name\n@param classLoader The class loader to use\n@return The instantiated instance or {@link Optional#empty()}", "input": "Java", "output": "public static Optional<?> tryInstantiate(String name, ClassLoader classLoader) {\n        try {\n            return ClassUtils.forName(name, classLoader)\n                .flatMap(InstantiationUtils::tryInstantiate);\n        } catch (Throwable e) {\n            Logger log = LoggerFactory.getLogger(InstantiationUtils.class);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Tried, but could not instantiate type: \" + name, e);\n            }\n            return Optional.empty();\n        }\n    }"}, {"instruction": "Gets the zone to pick up for this instance.", "input": "Java", "output": "private static int getZoneOffset(String myZone, boolean preferSameZone, String[] availZones) {\n        for (int i = 0; i < availZones.length; i++) {\n            if (myZone != null && (availZones[i].equalsIgnoreCase(myZone.trim()) == preferSameZone)) {\n                return i;\n            }\n        }\n        logger.warn(\"DISCOVERY: Could not pick a zone based on preferred zone settings. My zone - {},\" +\n                \" preferSameZone - {}. Defaulting to {}\", myZone, preferSameZone, availZones[0]);\n\n        return 0;\n    }"}, {"instruction": "In addition to the expiration requested by the super class, we also check the expiration is not too far in the future.\nEspecially to detect maliciously crafted cookie.", "input": "Java", "output": "@Override\n    protected boolean isTokenExpired(long tokenExpiryTimeMs) {\n        long nowMs = System.currentTimeMillis();\n        long maxExpirationMs = TimeUnit.SECONDS.toMillis(tokenValiditySeconds) + nowMs;\n        if(!SKIP_TOO_FAR_EXPIRATION_DATE_CHECK && tokenExpiryTimeMs > maxExpirationMs){\n            // attempt to use a cookie that has more than the maximum allowed expiration duration\n            // was either created before a change of configuration or maliciously crafted\n            long diffMs = tokenExpiryTimeMs - maxExpirationMs;\n            LOGGER.log(Level.WARNING, \"Attempt to use a cookie with an expiration duration larger than the one configured (delta of: {0} ms)\", diffMs);\n            return true;\n        }\n        // Check it has not expired\n        if (tokenExpiryTimeMs < nowMs) {\n            return true;\n        }\n        return false;\n    }"}, {"instruction": "\u5224\u65ad\u81ea\u52a8!=null\u7684\u6761\u4ef6\u7ed3\u6784\n\n@param entityName\n@param column\n@param contents\n@param empty\n@return", "input": "Java", "output": "public static String getIfNotNull(String entityName, EntityColumn column, String contents, boolean empty) {\n        StringBuilder sql = new StringBuilder();\n        sql.append(\"<if test=\\\"\");\n        if (StringUtil.isNotEmpty(entityName)) {\n            sql.append(entityName).append(\".\");\n        }\n        sql.append(column.getProperty()).append(\" != null\");\n        if (empty && column.getJavaType().equals(String.class)) {\n            sql.append(\" and \");\n            if (StringUtil.isNotEmpty(entityName)) {\n                sql.append(entityName).append(\".\");\n            }\n            sql.append(column.getProperty()).append(\" != '' \");\n        }\n        sql.append(\"\\\">\");\n        sql.append(contents);\n        sql.append(\"</if>\");\n        return sql.toString();\n    }"}, {"instruction": "[TARGET listMetricsAsync(ListOption...)]", "input": "Java", "output": "public Page<Metric> listMetricsAsync() throws ExecutionException, InterruptedException {\n    // [START listMetricsAsync]\n    Future<AsyncPage<Metric>> future = logging.listMetricsAsync(ListOption.pageSize(100));\n    // ...\n    AsyncPage<Metric> metrics = future.get();\n    for (Metric metric : metrics.iterateAll()) {\n      // do something with the metric\n    }\n    // [END listMetricsAsync]\n    return metrics;\n  }"}, {"instruction": "Find a resource for class name.\n\n@param className The class name\n@return The resource if found, {@code null} otherwise", "input": "Java", "output": "public Resource findResourceForClassName(String className) {\n\n        if (className.contains(CLOSURE_MARKER)) {\n            className = className.substring(0, className.indexOf(CLOSURE_MARKER));\n        }\n        Resource resource = classNameToResourceCache.get(className);\n        if (resource == null) {\n            String classNameWithPathSeparator = className.replace(\".\", FILE_SEPARATOR);\n            for (String pathPattern : getSearchPatternForExtension(classNameWithPathSeparator, \".groovy\", \".java\", \".kt\")) {\n                resource = resolveExceptionSafe(pathPattern);\n                if (resource != null && resource.exists()) {\n                    classNameToResourceCache.put(className, resource);\n                    break;\n                }\n            }\n        }\n        return resource != null && resource.exists() ? resource : null;\n    }"}, {"instruction": "Value for absent column, i. e. {@link NilColumnValueSelector}, should be equivalent to [null] during index merging.\n\nDuring index merging, if one of the merged indexes has absent columns, {@link StringDimensionMergerV9} ensures\nthat null value is present, and it has index = 0 after sorting, because sorting puts null first. See {@link\nStringDimensionMergerV9#hasNull} and the place where it is assigned.", "input": "Java", "output": "private static IndexedInts getRow(ColumnValueSelector s)\n  {\n    if (s instanceof DimensionSelector) {\n      return ((DimensionSelector) s).getRow();\n    } else if (s instanceof NilColumnValueSelector) {\n      return ZeroIndexedInts.instance();\n    } else {\n      throw new ISE(\n          \"ColumnValueSelector[%s], only DimensionSelector or NilColumnValueSelector is supported\",\n          s.getClass()\n      );\n    }\n  }"}, {"instruction": "\u9012\u5f52\u538b\u7f29\u6587\u4ef6\u5939<br>\nsrcRootDir\u51b3\u5b9a\u4e86\u8def\u5f84\u622a\u53d6\u7684\u4f4d\u7f6e\uff0c\u4f8b\u5982\uff1a<br>\nfile\u7684\u8def\u5f84\u4e3ad:/a/b/c/d.txt\uff0csrcRootDir\u4e3ad:/a/b\uff0c\u5219\u538b\u7f29\u540e\u7684\u6587\u4ef6\u4e0e\u76ee\u5f55\u4e3a\u7ed3\u6784\u4e3ac/d.txt\n\n@param out \u538b\u7f29\u6587\u4ef6\u5b58\u50a8\u5bf9\u8c61\n@param srcRootDir \u88ab\u538b\u7f29\u7684\u6587\u4ef6\u5939\u6839\u76ee\u5f55\n@param file \u5f53\u524d\u9012\u5f52\u538b\u7f29\u7684\u6587\u4ef6\u6216\u76ee\u5f55\u5bf9\u8c61\n@throws UtilException IO\u5f02\u5e38", "input": "Java", "output": "private static void zip(File file, String srcRootDir, ZipOutputStream out) throws UtilException {\r\n\t\tif (file == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfinal String subPath = FileUtil.subPath(srcRootDir, file); // \u83b7\u53d6\u6587\u4ef6\u76f8\u5bf9\u4e8e\u538b\u7f29\u6587\u4ef6\u5939\u6839\u76ee\u5f55\u7684\u5b50\u8def\u5f84\r\n\t\tif (file.isDirectory()) {// \u5982\u679c\u662f\u76ee\u5f55\uff0c\u5219\u538b\u7f29\u538b\u7f29\u76ee\u5f55\u4e2d\u7684\u6587\u4ef6\u6216\u5b50\u76ee\u5f55\r\n\t\t\tfinal File[] files = file.listFiles();\r\n\t\t\tif (ArrayUtil.isEmpty(files) && StrUtil.isNotEmpty(subPath)) {\r\n\t\t\t\t// \u52a0\u5165\u76ee\u5f55\uff0c\u53ea\u6709\u7a7a\u76ee\u5f55\u65f6\u624d\u52a0\u5165\u76ee\u5f55\uff0c\u975e\u7a7a\u65f6\u4f1a\u5728\u521b\u5efa\u6587\u4ef6\u65f6\u81ea\u52a8\u6dfb\u52a0\u7236\u7ea7\u76ee\u5f55\r\n\t\t\t\taddDir(subPath, out);\r\n\t\t\t}\r\n\t\t\t// \u538b\u7f29\u76ee\u5f55\u4e0b\u7684\u5b50\u6587\u4ef6\u6216\u76ee\u5f55\r\n\t\t\tfor (File childFile : files) {\r\n\t\t\t\tzip(childFile, srcRootDir, out);\r\n\t\t\t}\r\n\t\t} else {// \u5982\u679c\u662f\u6587\u4ef6\u6216\u5176\u5b83\u7b26\u53f7\uff0c\u5219\u76f4\u63a5\u538b\u7f29\u8be5\u6587\u4ef6\r\n\t\t\taddFile(file, subPath, out);\r\n\t\t}\r\n\t}"}, {"instruction": "Gets declared method from specified type by mame and parameters types.\n\n@param type           the type\n@param methodName     the name of the method\n@param parameterTypes the parameter array\n@return a {@link Method} object or null if method doesn't exist", "input": "Java", "output": "public static Method getDeclaredMethod(Class<?> type, String methodName, Class<?>... parameterTypes) {\n        Method method = null;\n        try {\n            method = type.getDeclaredMethod(methodName, parameterTypes);\n            if(method.isBridge()){\n                method = MethodProvider.getInstance().unbride(method, type);\n            }\n        } catch (NoSuchMethodException e) {\n            Class<?> superclass = type.getSuperclass();\n            if (superclass != null) {\n                method = getDeclaredMethod(superclass, methodName, parameterTypes);\n            }\n        } catch (ClassNotFoundException e) {\n            Throwables.propagate(e);\n        } catch (IOException e) {\n            Throwables.propagate(e);\n        }\n        return method;\n    }"}, {"instruction": "Get BatchNormalization epsilon parameter from Keras layer configuration.\n\n@param layerConfig dictionary containing Keras layer configuration\n@return epsilon\n@throws InvalidKerasConfigurationException Invalid Keras config", "input": "Java", "output": "private double getEpsFromConfig(Map<String, Object> layerConfig) throws InvalidKerasConfigurationException {\n        Map<String, Object> innerConfig = KerasLayerUtils.getInnerLayerConfigFromConfig(layerConfig, conf);\n        if (!innerConfig.containsKey(LAYER_FIELD_EPSILON))\n            throw new InvalidKerasConfigurationException(\n                    \"Keras BatchNorm layer config missing \" + LAYER_FIELD_EPSILON + \" field\");\n        return (double) innerConfig.get(LAYER_FIELD_EPSILON);\n    }"}, {"instruction": "Update the given picker to the helper if it's different from the current one.", "input": "Java", "output": "private void maybeUpdatePicker(ConnectivityState state, RoundRobinPicker picker) {\n    // Discard the new picker if we are sure it won't make any difference, in order to save\n    // re-processing pending streams, and avoid unnecessary resetting of the pointer in\n    // RoundRobinPicker.\n    if (picker.dropList.equals(currentPicker.dropList)\n        && picker.pickList.equals(currentPicker.pickList)) {\n      return;\n    }\n    currentPicker = picker;\n    logger.log(\n        ChannelLogLevel.INFO, \"{0}: picks={1}, drops={2}\", state, picker.pickList, picker.dropList);\n    helper.updateBalancingState(state, picker);\n  }"}, {"instruction": "Is this computer reachable via the given address?\n\n@param ia      The address to check.\n@param timeout Timeout in seconds.", "input": "Java", "output": "public static boolean checkIsReachable(InetAddress ia, int timeout) throws IOException {\n        for (ComputerPinger pinger : ComputerPinger.all()) {\n            try {\n                if (pinger.isReachable(ia, timeout)) {\n                    return true;\n                }\n            } catch (IOException e) {\n                LOGGER.fine(\"Error checking reachability with \" + pinger + \": \" + e.getMessage());\n            }\n        }\n\n        return false;\n    }"}, {"instruction": "Saves the client cert settings if the flag is set explicitly.\nOnly works for the CLI currently.", "input": "Java", "output": "private void saveClientCertSettings(){\r\n\r\n        if (getBoolean(PERSIST_CLIENT_CERT, false)){\r\n            logger.warn(\"Saving Client Certificate settings: password will be found in config\");\r\n            setUseClientCert(getBoolean(USE_CLIENT_CERT, false));\r\n            setClientCertLocation(getString(CLIENT_CERT_LOCATION, \"\"));\r\n            setClientCertPassword(getString(CLIENT_CERT_PASSWORD, \"\"));\r\n            setClientCertIndex(getInt(CLIENT_CERT_INDEX, 0));\r\n\r\n        } else {\r\n            // Default to clear settings\r\n            setUseClientCert(false);\r\n            setClientCertLocation(\"\");\r\n            setClientCertPassword(\"\");\r\n            setClientCertIndex(0);\r\n        }\r\n    }"}, {"instruction": "Private helper that fetches the Instances for each application.\n@param serviceId of the service that the instance list should be returned for\n@return List of instances for a given service id\n@throws Exception - retrieving and marshalling service instances may result in an\nException", "input": "Java", "output": "@Override\n\tprotected List<Instance> getInstancesForApp(String serviceId) throws Exception {\n\t\tList<Instance> instances = new ArrayList<>();\n\t\tlog.info(\"Fetching instances for app: \" + serviceId);\n\t\tApplication app = eurekaClient.getApplication(serviceId);\n\t\tif (app == null) {\n\t\t\tlog.warn(\"Eureka returned null for app: \" + serviceId);\n\t\t\treturn instances;\n\t\t}\n\t\ttry {\n\t\t\tList<InstanceInfo> instancesForApp = app.getInstances();\n\t\t\tif (instancesForApp != null) {\n\t\t\t\tlog.info(\"Received instance list for app: \" + serviceId + \", size=\"\n\t\t\t\t\t\t+ instancesForApp.size());\n\t\t\t\tfor (InstanceInfo iInfo : instancesForApp) {\n\t\t\t\t\tInstance instance = marshall(iInfo);\n\t\t\t\t\tif (instance != null) {\n\t\t\t\t\t\tinstances.add(instance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.warn(\"Failed to retrieve instances from Eureka\", e);\n\t\t}\n\t\treturn instances;\n\t}"}, {"instruction": "Validates all panels, throwing an exception if there's any validation error.\n<p>\nThe message of the exception can be shown in GUI components (for example, an error dialogue) callers can expect an\ninternationalised message.\n\n@throws Exception if there's any validation error.\n@see #initParam(Object)\n@see #saveParam()", "input": "Java", "output": "public void validateParam() throws Exception {\r\n        Enumeration<AbstractParamPanel> en = tablePanel.elements();\r\n        AbstractParamPanel panel = null;\r\n        while (en.hasMoreElements()) {\r\n            panel = en.nextElement();\r\n            try {\r\n                panel.validateParam(paramObject);\r\n            } catch (Exception e) {\r\n                showParamPanel(panel, panel.getName());\r\n                throw e;\r\n            }\r\n        }\r\n    }"}, {"instruction": "Programmatically registers the auto-configuration package names. Subsequent\ninvocations will add the given package names to those that have already been\nregistered. You can use this method to manually define the base packages that will\nbe used for a given {@link BeanDefinitionRegistry}. Generally it's recommended that\nyou don't call this method directly, but instead rely on the default convention\nwhere the package name is set from your {@code @EnableAutoConfiguration}\nconfiguration class or classes.\n@param registry the bean definition registry\n@param packageNames the package names to set", "input": "Java", "output": "public static void register(BeanDefinitionRegistry registry, String... packageNames) {\n\t\tif (registry.containsBeanDefinition(BEAN)) {\n\t\t\tBeanDefinition beanDefinition = registry.getBeanDefinition(BEAN);\n\t\t\tConstructorArgumentValues constructorArguments = beanDefinition\n\t\t\t\t\t.getConstructorArgumentValues();\n\t\t\tconstructorArguments.addIndexedArgumentValue(0,\n\t\t\t\t\taddBasePackages(constructorArguments, packageNames));\n\t\t}\n\t\telse {\n\t\t\tGenericBeanDefinition beanDefinition = new GenericBeanDefinition();\n\t\t\tbeanDefinition.setBeanClass(BasePackages.class);\n\t\t\tbeanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0,\n\t\t\t\t\tpackageNames);\n\t\t\tbeanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tregistry.registerBeanDefinition(BEAN, beanDefinition);\n\t\t}\n\t}"}, {"instruction": "Convenience function equivalent to calling\n{@link #createColumnSelectorPluses(ColumnSelectorStrategyFactory, List, ColumnSelectorFactory)} with a singleton\nlist of dimensionSpecs and then retrieving the only element in the returned array.\n\n@param <ColumnSelectorStrategyClass> The strategy type created by the provided strategy factory.\n@param strategyFactory               A factory provided by query engines that generates type-handling strategies\n@param dimensionSpec                 column to generate a ColumnSelectorPlus object for\n@param cursor                        Used to create value selectors for columns.\n\n@return A ColumnSelectorPlus object", "input": "Java", "output": "public static <ColumnSelectorStrategyClass extends ColumnSelectorStrategy> ColumnSelectorPlus<ColumnSelectorStrategyClass> createColumnSelectorPlus(\n      ColumnSelectorStrategyFactory<ColumnSelectorStrategyClass> strategyFactory,\n      DimensionSpec dimensionSpec,\n      ColumnSelectorFactory cursor\n  )\n  {\n    return createColumnSelectorPluses(strategyFactory, ImmutableList.of(dimensionSpec), cursor)[0];\n  }"}, {"instruction": "Retrieve authn request authn request.\n\n@param request the request\n@return the authn request\n@throws Exception the exception", "input": "Java", "output": "protected AuthnRequest retrieveSamlAuthenticationRequestFromHttpRequest(final HttpServletRequest request) throws Exception {\n        LOGGER.debug(\"Retrieving authentication request from scope\");\n        val requestValue = request.getParameter(SamlProtocolConstants.PARAMETER_SAML_REQUEST);\n        if (StringUtils.isBlank(requestValue)) {\n            throw new IllegalArgumentException(\"SAML request could not be determined from the authentication request\");\n        }\n        val encodedRequest = EncodingUtils.decodeBase64(requestValue.getBytes(StandardCharsets.UTF_8));\n        return (AuthnRequest) XMLObjectSupport.unmarshallFromInputStream(samlProfileHandlerConfigurationContext.getOpenSamlConfigBean().getParserPool(),\n            new ByteArrayInputStream(encodedRequest));\n    }"}, {"instruction": "\u540c\u65f6\u8fd4\u56de\u65e0\u5e8f\u96c6\u5408\u4e2d\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\uff0c\u4f7f\u7528\u5143\u7d20\u9ed8\u8ba4\u6392\u5e8f\n\n\u5728\u8fd4\u56de\u7684Pair\u4e2d\uff0c\u7b2c\u4e00\u4e2a\u4e3a\u6700\u5c0f\u503c\uff0c\u7b2c\u4e8c\u4e2a\u4e3a\u6700\u5927\u503c", "input": "Java", "output": "public static <T extends Object & Comparable<? super T>> Pair<T, T> minAndMax(Collection<? extends T> coll) {\n\t\tIterator<? extends T> i = coll.iterator();\n\t\tT minCandidate = i.next();\n\t\tT maxCandidate = minCandidate;\n\n\t\twhile (i.hasNext()) {\n\t\t\tT next = i.next();\n\t\t\tif (next.compareTo(minCandidate) < 0) {\n\t\t\t\tminCandidate = next;\n\t\t\t} else if (next.compareTo(maxCandidate) > 0) {\n\t\t\t\tmaxCandidate = next;\n\t\t\t}\n\t\t}\n\t\treturn Pair.of(minCandidate, maxCandidate);\n\t}"}, {"instruction": "Token count for a user.\n\n@param userId user to count tokens for\n@return count of the user's tokens", "input": "Java", "output": "@View(name = \"count_by_userId\", map = \"function(doc) { if(doc.token && doc.userId) { emit(doc.userId, doc) } }\", reduce = \"_count\")\n    public long countByUserId(final String userId) {\n        val view = createQuery(\"count_by_userId\").key(userId);\n        val rows = db.queryView(view).getRows();\n        if (rows.isEmpty()) {\n            return 0;\n        }\n        return rows.get(0).getValueAsInt();\n    }"}, {"instruction": "Turns a String text into a sequence of tokens.\n\n@param text                 input text\n@param filters              characters to filter\n@param lower                whether to lowercase input or not\n@param split                by which string to split words (usually single space)\n@return Sequence of tokens as String array", "input": "Java", "output": "public static String[] textToWordSequence(String text, String filters, boolean lower, String split) {\n        if (lower)\n            text = text.toLowerCase();\n\n        for (String filter: filters.split(\"\")) {\n            text = text.replace(filter, split);\n        }\n        String[] sequences = text.split(split);\n        List<String> seqList = new ArrayList(Arrays.asList(sequences));\n        seqList.removeAll(Arrays.asList(\"\", null));\n\n        return seqList.toArray(new String[seqList.size()]);\n    }"}, {"instruction": "Starts an Actor System at a specific port.\n@param configuration The Flink configuration.\n@param listeningAddress The address to listen at.\n@param listeningPort The port to listen at.\n@param logger the logger to output log information.\n@param actorSystemExecutorConfiguration configuration for the ActorSystem's underlying executor\n@return The ActorSystem which has been started.\n@throws Exception", "input": "Java", "output": "public static ActorSystem startActorSystem(\n\t\t\t\tConfiguration configuration,\n\t\t\t\tString listeningAddress,\n\t\t\t\tint listeningPort,\n\t\t\t\tLogger logger,\n\t\t\t\tActorSystemExecutorConfiguration actorSystemExecutorConfiguration) throws Exception {\n\t\treturn startActorSystem(\n\t\t\tconfiguration,\n\t\t\tAkkaUtils.getFlinkActorSystemName(),\n\t\t\tlisteningAddress,\n\t\t\tlisteningPort,\n\t\t\tlogger,\n\t\t\tactorSystemExecutorConfiguration);\n\t}"}, {"instruction": "For the given input shape/type for the network, return a list of activation sizes for each layer in the network.<br>\ni.e., list.get(i) is the output activation sizes for layer i\n\n@param inputType Input type for the network\n@return A lits of activation types for the network, indexed by layer number", "input": "Java", "output": "public List<InputType> getLayerActivationTypes(@NonNull InputType inputType) {\n        List<InputType> out = new ArrayList<>();\n        int nLayers = confs.size();\n        for (int i = 0; i < nLayers; i++) {\n            InputPreProcessor preproc = getInputPreProcess(i);\n            if (preproc != null) {\n                inputType = preproc.getOutputType(inputType);\n            }\n\n            inputType = confs.get(i).getLayer().getOutputType(i, inputType);\n            out.add(inputType);\n        }\n        return out;\n    }"}, {"instruction": "This method builds\n@param op", "input": "Java", "output": "public void processStackCall(Op op, long timeStart) {\n        //StackTraceElement stack[] = Thread.currentThread().getStackTrace();\n\n        long timeSpent = (System.nanoTime() - timeStart) / 1000;\n\n        /*\n           basically we want to unroll stack trace for few levels ABOVE nd4j classes\n           and update invocations list for last few levels, to keep that stat on few levels\n         */\n\n        methodsAggregator.incrementCount(timeSpent);\n    }"}, {"instruction": "Used to produce an index for particular annotation type. Method referenced by generated byte code and\nnot for public consumption. Should be called after {@link #addProperty(BeanProperty)} if required.\n\n@param annotationType The annotation type\n@param propertyName The property name", "input": "Java", "output": "@SuppressWarnings(\"unused\")\n    @Internal\n    @UsedByGeneratedCode\n    protected final void indexProperty(@Nonnull Class<? extends Annotation> annotationType, @Nonnull String propertyName) {\n        ArgumentUtils.requireNonNull(\"annotationType\", annotationType);\n        if (StringUtils.isNotEmpty(propertyName)) {\n            final BeanProperty<T, Object> property = beanProperties.get(propertyName);\n            if (property == null) {\n                throw new IllegalStateException(\"Invalid byte code generated during bean introspection. Call addProperty first!\");\n            }\n            if (indexed == null) {\n                indexed = new HashMap<>(2);\n            }\n            final List<BeanProperty<T, Object>> indexed = this.indexed.computeIfAbsent(annotationType, aClass -> new ArrayList<>(2));\n\n            indexed.add(property);\n        }\n    }"}, {"instruction": "\u7528\u4e8eModel\u5bf9\u8c61\u8f6c\u5316\u4e3aDO\u5bf9\u8c61\n\n@param canal\n@return CanalDO", "input": "Java", "output": "private CanalDO modelToDo(Canal canal) {\n        CanalDO canalDo = new CanalDO();\n        try {\n            canalDo.setId(canal.getId());\n            canalDo.setName(canal.getName());\n            canalDo.setStatus(canal.getStatus());\n            canalDo.setDescription(canal.getDesc());\n            canalDo.setParameters(canal.getCanalParameter());\n            canalDo.setGmtCreate(canal.getGmtCreate());\n            canalDo.setGmtModified(canal.getGmtModified());\n        } catch (Exception e) {\n            logger.error(\"ERROR ## change the canal Model to Do has an exception\");\n            throw new ManagerException(e);\n        }\n        return canalDo;\n    }"}, {"instruction": "Returns the indices of non-zero element of the vector\n\n@return indices in Databuffer", "input": "Java", "output": "@Override\n    public DataBuffer getVectorCoordinates() {\n        int idx;\n        if (isRowVector()) {\n            idx = 1;\n        } else if (isColumnVector()) {\n            idx = 0;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n\n        // FIXME: int cast\n        int[] temp = new int[(int) length()];\n        for (int i = 0; i < length(); i++) {\n            temp[i] = getUnderlyingIndicesOf(i).getInt(idx);\n        }\n        return Nd4j.createBuffer(temp);\n    }"}, {"instruction": "Gets encrypter.\n\n@param samlObject    the saml object\n@param service       the service\n@param adaptor       the adaptor\n@param keyEncParams  the key enc params\n@param dataEncParams the data enc params\n@return the encrypter", "input": "Java", "output": "protected Encrypter getEncrypter(final Object samlObject,\n                                     final SamlRegisteredService service,\n                                     final SamlRegisteredServiceServiceProviderMetadataFacade adaptor,\n                                     final KeyEncryptionParameters keyEncParams,\n                                     final DataEncryptionParameters dataEncParams) {\n        val encrypter = new Encrypter(dataEncParams, keyEncParams);\n        encrypter.setKeyPlacement(Encrypter.KeyPlacement.PEER);\n        return encrypter;\n    }"}, {"instruction": "Gets resource from a String location.\n\n@param location the metadata location\n@return the resource from\n@throws IOException the exception", "input": "Java", "output": "public static AbstractResource getRawResourceFrom(final String location) throws IOException {\n        if (StringUtils.isBlank(location)) {\n            throw new IllegalArgumentException(\"Provided location does not exist and is empty\");\n        }\n        if (location.toLowerCase().startsWith(HTTP_URL_PREFIX)) {\n            return new UrlResource(location);\n        }\n        if (location.toLowerCase().startsWith(CLASSPATH_URL_PREFIX)) {\n            return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()));\n        }\n        return new FileSystemResource(StringUtils.remove(location, FILE_URL_PREFIX));\n    }"}, {"instruction": "Checks and installs all the add-ons whose installation status is {@code NOT_INSTALLED} that have (now) all required\ndependencies fulfilled.\n<p>\nShould be called after an installation of an add-on.\n\n@see #addAddOnImpl(AddOn)\n@see AddOn.InstallationStatus#NOT_INSTALLED\n@since 2.4.0", "input": "Java", "output": "private void checkAndInstallAddOnsNotInstalled() {\r\n        List<AddOn> runnableAddOns = new ArrayList<>();\r\n        for (AddOn addOn : aoc.getAddOns()) {\r\n            if (AddOn.InstallationStatus.NOT_INSTALLED == addOn.getInstallationStatus() && addOnLoaders.get(addOn.getId()) == null) {\r\n                AddOnRunRequirements reqs = addOn.calculateRunRequirements(aoc.getInstalledAddOns());\r\n                if (reqs.isRunnable()) {\r\n                    runnableAddOns.add(addOn);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (AddOn addOn : runnableAddOns) {\r\n            addAddOnImpl(addOn);\r\n        }\r\n    }"}, {"instruction": "Apply L1 and L2 regularization, if necessary. Note that L1/L2 may differ for different layers in the same block\n\n@param layer        The layer to apply L1/L2 to\n@param paramName    Parameter name in the given layer\n@param gradientView Gradient view array for the layer + param\n@param paramsView   Parameter view array for the layer + param", "input": "Java", "output": "protected void applyRegularization(Regularization.ApplyStep step, Trainable layer, String paramName, INDArray gradientView, INDArray paramsView, int iter, int epoch, double lr) {\n        //TODO: do this for multiple contiguous params/layers (fewer, larger ops)\n\n        List<Regularization> l = layer.getConfig().getRegularizationByParam(paramName);\n        if(l != null && !l.isEmpty()){\n            for(Regularization r : l){\n                if(r.applyStep() == step){\n                    r.apply(paramsView, gradientView, lr, iter, epoch);\n                }\n            }\n        }\n    }"}, {"instruction": "Given a {@link ROC} instance, render the ROC chart and precision vs. recall charts to a stand-alone HTML file (returned as a String)\n@param roc  ROC to render", "input": "Java", "output": "public static String rocChartToHtml(ROC roc) {\n        RocCurve rocCurve = roc.getRocCurve();\n\n        Component c = getRocFromPoints(ROC_TITLE, rocCurve, roc.getCountActualPositive(), roc.getCountActualNegative(),\n                        roc.calculateAUC(), roc.calculateAUCPR());\n        Component c2 = getPRCharts(PR_TITLE, PR_THRESHOLD_TITLE, roc.getPrecisionRecallCurve());\n\n        return StaticPageUtil.renderHTML(c, c2);\n    }"}, {"instruction": "Tries to write&flush unannounced credits for the next input channel in queue.\n\n<p>This method may be called by the first input channel enqueuing, or the complete\nfuture's callback in previous input channel, or the channel writability changed event.", "input": "Java", "output": "private void writeAndFlushNextMessageIfPossible(Channel channel) {\n\t\tif (channelError.get() != null || !channel.isWritable()) {\n\t\t\treturn;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tRemoteInputChannel inputChannel = inputChannelsWithCredit.poll();\n\n\t\t\t// The input channel may be null because of the write callbacks\n\t\t\t// that are executed after each write.\n\t\t\tif (inputChannel == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//It is no need to notify credit for the released channel.\n\t\t\tif (!inputChannel.isReleased()) {\n\t\t\t\tAddCredit msg = new AddCredit(\n\t\t\t\t\tinputChannel.getPartitionId(),\n\t\t\t\t\tinputChannel.getAndResetUnannouncedCredit(),\n\t\t\t\t\tinputChannel.getInputChannelId());\n\n\t\t\t\t// Write and flush and wait until this is done before\n\t\t\t\t// trying to continue with the next input channel.\n\t\t\t\tchannel.writeAndFlush(msg).addListener(writeListener);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}"}, {"instruction": "\u8fdb\u884c\u9012\u5f52\u89e3\u6790\u6ce8\u89e3\uff0c\u76f4\u5230\u5168\u90e8\u90fd\u662f\u5143\u6ce8\u89e3\u4e3a\u6b62\n\n@param annotations Class, Method, Field\u7b49", "input": "Java", "output": "private void parseDeclared(Annotation[] annotations) {\r\n\t\tClass<? extends Annotation> annotationType;\r\n\t\t// \u76f4\u63a5\u6ce8\u89e3\r\n\t\tfor (Annotation annotation : annotations) {\r\n\t\t\tannotationType = annotation.annotationType();\r\n\t\t\tif (false == META_ANNOTATIONS.contains(annotationType)) {\r\n\t\t\t\tdeclaredAnnotationMap.put(annotationType, annotation);\r\n\t\t\t\tparseDeclared(annotationType.getDeclaredAnnotations());\r\n\t\t\t}\r\n\t\t}\r\n\t}"}, {"instruction": "Locates the index for the given key. This method probes using double hashing.\n\n@param key the key for an entry in the map.\n@return the index where the key was found, or {@code -1} if no entry is found for that key.", "input": "Java", "output": "private int indexOf(int key) {\n\t\tint startIndex = hashIndex(key);\n\t\tint index = startIndex;\n\n\t\tfor (;;) {\n\t\t\tif (values[index] == null) {\n\t\t\t\t// It's available, so no chance that this value exists anywhere in the map.\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (key == keys[index]) {\n\t\t\t\treturn index;\n\t\t\t}\n\n\t\t\t// Conflict, keep probing ...\n\t\t\tif ((index = probeNext(index)) == startIndex) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}"}, {"instruction": "Returns whether the supplied cache loader has bulk load functionality.", "input": "Java", "output": "private static boolean canBulkLoad(AsyncCacheLoader<?, ?> loader) {\n    try {\n      Class<?> defaultLoaderClass = AsyncCacheLoader.class;\n      if (loader instanceof CacheLoader<?, ?>) {\n        defaultLoaderClass = CacheLoader.class;\n\n        Method classLoadAll = loader.getClass().getMethod(\"loadAll\", Iterable.class);\n        Method defaultLoadAll = CacheLoader.class.getMethod(\"loadAll\", Iterable.class);\n        if (!classLoadAll.equals(defaultLoadAll)) {\n          return true;\n        }\n      }\n\n      Method classAsyncLoadAll = loader.getClass().getMethod(\n          \"asyncLoadAll\", Iterable.class, Executor.class);\n      Method defaultAsyncLoadAll = defaultLoaderClass.getMethod(\n          \"asyncLoadAll\", Iterable.class, Executor.class);\n      return !classAsyncLoadAll.equals(defaultAsyncLoadAll);\n    } catch (NoSuchMethodException | SecurityException e) {\n      logger.log(Level.WARNING, \"Cannot determine if CacheLoader can bulk load\", e);\n      return false;\n    }\n  }"}, {"instruction": "Check if a {@link ByteBuffer} contains a file identifier.\n\n@param bb A {@code ByteBuffer} to check if it contains the identifier\n`ident`.\n@param ident A `String` identifier of the FlatBuffer file.\n@return True if the buffer contains the file identifier", "input": "Java", "output": "protected static boolean __has_identifier(ByteBuffer bb, String ident) {\n    if (ident.length() != FILE_IDENTIFIER_LENGTH)\n        throw new AssertionError(\"FlatBuffers: file identifier must be length \" +\n                                 FILE_IDENTIFIER_LENGTH);\n    for (int i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n      if (ident.charAt(i) != (char)bb.get(bb.position() + SIZEOF_INT + i)) return false;\n    }\n    return true;\n  }"}, {"instruction": "\u6839\u636e\u6a21\u578b\u540d\u79f0\u83b7\u53d6crf\u6a21\u578b\n\n@param modelName\n@return", "input": "Java", "output": "public static StopRecognition get(String key) {\n        KV<String, StopRecognition> kv = STOP.get(key);\n\n        if (kv == null) {\n            if (MyStaticValue.ENV.containsKey(key)) {\n                putIfAbsent(key, MyStaticValue.ENV.get(key));\n                return get(key);\n            }\n            LOG.warn(\"STOP \" + key + \" not found in config \");\n            return null;\n        }\n        StopRecognition stopRecognition = kv.getV();\n        if (stopRecognition == null) {\n            stopRecognition = init(key, kv, false);\n        }\n        return stopRecognition;\n\n    }"}, {"instruction": "Returns the details for the specified interconnect location. Gets a list of available\ninterconnect locations by making a list() request.\n\n<p>Sample code:\n\n<pre><code>\ntry (InterconnectLocationClient interconnectLocationClient = InterconnectLocationClient.create()) {\nProjectGlobalInterconnectLocationName interconnectLocation = ProjectGlobalInterconnectLocationName.of(\"[PROJECT]\", \"[INTERCONNECT_LOCATION]\");\nInterconnectLocation response = interconnectLocationClient.getInterconnectLocation(interconnectLocation);\n}\n</code></pre>\n\n@param interconnectLocation Name of the interconnect location to return.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final InterconnectLocation getInterconnectLocation(\n      ProjectGlobalInterconnectLocationName interconnectLocation) {\n\n    GetInterconnectLocationHttpRequest request =\n        GetInterconnectLocationHttpRequest.newBuilder()\n            .setInterconnectLocation(\n                interconnectLocation == null ? null : interconnectLocation.toString())\n            .build();\n    return getInterconnectLocation(request);\n  }"}, {"instruction": "\u589e\u52a0\u4e00\u4e2a\u6bb5\u843d\n\n@param align \u6bb5\u843d\u5bf9\u9f50\u65b9\u5f0f{@link ParagraphAlignment}\n@param font \u5b57\u4f53\u4fe1\u606f{@link Font}\n@param texts \u6bb5\u843d\u4e2d\u7684\u6587\u672c\uff0c\u652f\u6301\u591a\u4e2a\u6587\u672c\u4f5c\u4e3a\u4e00\u4e2a\u6bb5\u843d\n@return this", "input": "Java", "output": "public Word07Writer addText(ParagraphAlignment align, Font font, String... texts) {\r\n\t\tfinal XWPFParagraph p = this.doc.createParagraph();\r\n\t\tif (null != align) {\r\n\t\t\tp.setAlignment(align);\r\n\t\t}\r\n\t\tif (ArrayUtil.isNotEmpty(texts)) {\r\n\t\t\tXWPFRun run;\r\n\t\t\tfor (String text : texts) {\r\n\t\t\t\trun = p.createRun();\r\n\t\t\t\trun.setText(text);\r\n\t\t\t\tif (null != font) {\r\n\t\t\t\t\trun.setFontFamily(font.getFamily());\r\n\t\t\t\t\trun.setFontSize(font.getSize());\r\n\t\t\t\t\trun.setBold(font.isBold());\r\n\t\t\t\t\trun.setItalic(font.isItalic());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}"}, {"instruction": "Create registered service public key defined.\n\n@param registeredService the registered service\n@return the public key", "input": "Java", "output": "private static PublicKey createRegisteredServicePublicKey(final RegisteredService registeredService) {\n        if (registeredService.getPublicKey() == null) {\n            LOGGER.debug(\"No public key is defined for service [{}]. No encoding will take place.\", registeredService);\n            return null;\n        }\n        val publicKey = registeredService.getPublicKey().createInstance();\n        if (publicKey == null) {\n            LOGGER.debug(\"No public key instance created for service [{}]. No encoding will take place.\", registeredService);\n            return null;\n        }\n        return publicKey;\n    }"}, {"instruction": "Decodes the specified region of the buffer into an unadjusted frame length.  The default implementation is\ncapable of decoding the specified region into an unsigned 8/16/24/32/64 bit integer.  Override this method to\ndecode the length field encoded differently.  Note that this method must not modify the state of the specified\nbuffer (e.g. {@code readerIndex}, {@code writerIndex}, and the content of the buffer.)\n\n@throws DecoderException if failed to decode the specified region", "input": "Java", "output": "protected long getUnadjustedFrameLength(ByteBuf buf, int offset, int length, ByteOrder order) {\n        buf = buf.order(order);\n        long frameLength;\n        switch (length) {\n        case 1:\n            frameLength = buf.getUnsignedByte(offset);\n            break;\n        case 2:\n            frameLength = buf.getUnsignedShort(offset);\n            break;\n        case 3:\n            frameLength = buf.getUnsignedMedium(offset);\n            break;\n        case 4:\n            frameLength = buf.getUnsignedInt(offset);\n            break;\n        case 8:\n            frameLength = buf.getLong(offset);\n            break;\n        default:\n            throw new DecoderException(\n                    \"unsupported lengthFieldLength: \" + lengthFieldLength + \" (expected: 1, 2, 3, 4, or 8)\");\n        }\n        return frameLength;\n    }"}, {"instruction": "Build saml assertion assertion.\n\n@param authnRequest   the authn request\n@param request        the request\n@param response       the response\n@param casAssertion   the cas assertion\n@param service        the service\n@param adaptor        the adaptor\n@param binding        the binding\n@param messageContext the message context\n@return the assertion", "input": "Java", "output": "protected Assertion buildSamlAssertion(final RequestAbstractType authnRequest,\n                                           final HttpServletRequest request,\n                                           final HttpServletResponse response,\n                                           final Object casAssertion,\n                                           final SamlRegisteredService service,\n                                           final SamlRegisteredServiceServiceProviderMetadataFacade adaptor,\n                                           final String binding,\n                                           final MessageContext messageContext) {\n        return samlResponseBuilderConfigurationContext.getSamlProfileSamlAssertionBuilder()\n            .build(authnRequest, request, response, casAssertion, service, adaptor, binding, messageContext);\n    }"}, {"instruction": "A convenience method that performs click-and-hold at the location of the source element,\nmoves by a given offset, then releases the mouse.\n\n@param source element to emulate button down at.\n@param xOffset horizontal move offset.\n@param yOffset vertical move offset.\n@return A self reference.", "input": "Java", "output": "public Actions dragAndDropBy(WebElement source, int xOffset, int yOffset) {\n    if (isBuildingActions()) {\n      action.addAction(new ClickAndHoldAction(jsonMouse, (Locatable) source));\n      action.addAction(new MoveToOffsetAction(jsonMouse, null, xOffset, yOffset));\n      action.addAction(new ButtonReleaseAction(jsonMouse, null));\n    }\n\n    return moveInTicks(source, 0, 0)\n        .tick(defaultMouse.createPointerDown(LEFT.asArg()))\n        .tick(defaultMouse.createPointerMove(Duration.ofMillis(250), Origin.pointer(), xOffset, yOffset))\n        .tick(defaultMouse.createPointerUp(LEFT.asArg()));\n  }"}, {"instruction": "Overrides unsupported type conversions/mappings specified by the user.\n@param vec byte vec holding bin\\ary parquet data\n@param requestedTypes user-specified target types\n@return corrected types", "input": "Java", "output": "public static byte[] correctTypeConversions(ByteVec vec, byte[] requestedTypes) {\n    byte[] metadataBytes = VecParquetReader.readFooterAsBytes(vec);\n    ParquetMetadata metadata = VecParquetReader.readFooter(metadataBytes, ParquetMetadataConverter.NO_FILTER);\n    byte[] roughTypes = roughGuessTypes(metadata.getFileMetaData().getSchema());\n    return correctTypeConversions(roughTypes, requestedTypes);\n  }"}, {"instruction": "Set the {@link TaskExecutorCustomizer TaskExecutorCustomizers} that should be\napplied to the {@link ThreadPoolTaskExecutor}. Customizers are applied in the order\nthat they were added after builder configuration has been applied. Setting this\nvalue will replace any previously configured customizers.\n@param customizers the customizers to set\n@return a new builder instance\n@see #additionalCustomizers(TaskExecutorCustomizer...)", "input": "Java", "output": "public TaskExecutorBuilder customizers(Iterable<TaskExecutorCustomizer> customizers) {\n\t\tAssert.notNull(customizers, \"Customizers must not be null\");\n\t\treturn new TaskExecutorBuilder(this.queueCapacity, this.corePoolSize,\n\t\t\t\tthis.maxPoolSize, this.allowCoreThreadTimeOut, this.keepAlive,\n\t\t\t\tthis.awaitTermination, this.awaitTerminationPeriod, this.threadNamePrefix,\n\t\t\t\tthis.taskDecorator, append(null, customizers));\n\t}"}, {"instruction": "Sort the given range of items using quick sort. {@inheritDoc} If the recursion depth falls below\n{@link #getMaxDepth}, then switch to {@link HeapSort}.", "input": "Java", "output": "public void sort(final IndexedSortable s, int p, int r) {\n\t\tint recordsPerSegment = s.recordsPerSegment();\n\t\tint recordSize = s.recordSize();\n\t\tint maxOffset = recordSize * (recordsPerSegment - 1);\n\n\t\tint pN = p / recordsPerSegment;\n\t\tint pO = (p % recordsPerSegment) * recordSize;\n\n\t\tint rN = r / recordsPerSegment;\n\t\tint rO = (r % recordsPerSegment) * recordSize;\n\n\t\tsortInternal(s, recordsPerSegment, recordSize, maxOffset, p, pN, pO, r, rN, rO, getMaxDepth(r - p));\n\t}"}, {"instruction": "Sets the named ports for the specified instance group.\n\n<p>Sample code:\n\n<pre><code>\ntry (InstanceGroupClient instanceGroupClient = InstanceGroupClient.create()) {\nProjectZoneInstanceGroupName instanceGroup = ProjectZoneInstanceGroupName.of(\"[PROJECT]\", \"[ZONE]\", \"[INSTANCE_GROUP]\");\nInstanceGroupsSetNamedPortsRequest instanceGroupsSetNamedPortsRequestResource = InstanceGroupsSetNamedPortsRequest.newBuilder().build();\nOperation response = instanceGroupClient.setNamedPortsInstanceGroup(instanceGroup, instanceGroupsSetNamedPortsRequestResource);\n}\n</code></pre>\n\n@param instanceGroup The name of the instance group where the named ports are updated.\n@param instanceGroupsSetNamedPortsRequestResource\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation setNamedPortsInstanceGroup(\n      ProjectZoneInstanceGroupName instanceGroup,\n      InstanceGroupsSetNamedPortsRequest instanceGroupsSetNamedPortsRequestResource) {\n\n    SetNamedPortsInstanceGroupHttpRequest request =\n        SetNamedPortsInstanceGroupHttpRequest.newBuilder()\n            .setInstanceGroup(instanceGroup == null ? null : instanceGroup.toString())\n            .setInstanceGroupsSetNamedPortsRequestResource(\n                instanceGroupsSetNamedPortsRequestResource)\n            .build();\n    return setNamedPortsInstanceGroup(request);\n  }"}, {"instruction": "This method returns intersection point of shape border and line.\n@param shape\n@param line\n@return Point", "input": "Java", "output": "private static Point getIntersection(Shape shape,\n                                         Line2D.Double line) {\n        if (shape instanceof Ellipse2D) {\n            return getEllipseIntersection(shape,\n                                          line);\n        } else if (shape instanceof Rectangle2D || shape instanceof Path2D) {\n            return getShapeIntersection(shape,\n                                        line);\n        } else {\n            // something strange\n            return null;\n        }\n    }"}, {"instruction": "Adds a reference to a section of the http data. Should only\nbe called after data has been added to the underlying http data.\n\n@param onError A consumer to call if an IOException occurs\n@return The newly added component, or null if an error occurred", "input": "Java", "output": "Component addComponent(Consumer<IOException> onError) {\n        Component component;\n        try {\n            long readable = readableBytes(data);\n            long offset = position.getAndUpdate(p -> readable);\n            int length = new Long(readable - offset).intValue();\n            component = new Component(length, offset);\n            components.add(component);\n        } catch (IOException e) {\n            onError.accept(e);\n            return null;\n        }\n\n        if (!data.isInMemory()) {\n            fileAccess.getAndUpdate(channel -> {\n                if (channel == null) {\n                    try {\n                        return new RandomAccessFile(data.getFile(), \"r\");\n                    } catch (IOException e) {\n                        onError.accept(e);\n                    }\n                }\n                return channel;\n            });\n        }\n\n        return component;\n    }"}, {"instruction": "bits\u8f6cbytes\n\n@param bits \u4e8c\u8fdb\u5236\n@return bytes", "input": "Java", "output": "public static byte[] bits2Bytes(String bits) {\n        int lenMod  = bits.length() % 8;\n        int byteLen = bits.length() / 8;\n        // \u4e0d\u662f8\u7684\u500d\u6570\u524d\u9762\u88650\n        if (lenMod != 0) {\n            for (int i = lenMod; i < 8; i++) {\n                bits = \"0\" + bits;\n            }\n            byteLen++;\n        }\n        byte[] bytes = new byte[byteLen];\n        for (int i = 0; i < byteLen; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                bytes[i] <<= 1;\n                bytes[i] |= bits.charAt(i * 8 + j) - '0';\n            }\n        }\n        return bytes;\n    }"}, {"instruction": "Copy the values of an {@link Iterator} to the target {@link CallStreamObserver} while properly\naccounting for outbound flow-control.  After calling this method, {@code target} should no\nlonger be used.\n\n<p>For clients this method is safe to call inside {@link ClientResponseObserver#beforeStart},\non servers it is safe to call inside the service method implementation.\n</p>\n\n@param source of values expressed as an {@link Iterator}.\n@param target {@link CallStreamObserver} which accepts values from the source.", "input": "Java", "output": "public static <V> void copyWithFlowControl(final Iterator<V> source,\n      final CallStreamObserver<V> target) {\n    Preconditions.checkNotNull(source, \"source\");\n    Preconditions.checkNotNull(target, \"target\");\n\n    final class FlowControllingOnReadyHandler implements Runnable {\n      private boolean completed;\n\n      @Override\n      public void run() {\n        if (completed) {\n          return;\n        }\n\n        while (target.isReady() && source.hasNext()) {\n          target.onNext(source.next());\n        }\n\n        if (!source.hasNext()) {\n          completed = true;\n          target.onCompleted();\n        }\n      }\n    }\n\n    target.setOnReadyHandler(new FlowControllingOnReadyHandler());\n  }"}, {"instruction": "Notify all the handshake futures about the successfully handshake", "input": "Java", "output": "private void setHandshakeSuccess() {\n        handshakePromise.trySuccess(ctx.channel());\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"{} HANDSHAKEN: {}\", ctx.channel(), engine.getSession().getCipherSuite());\n        }\n        ctx.fireUserEventTriggered(SslHandshakeCompletionEvent.SUCCESS);\n\n        if (readDuringHandshake && !ctx.channel().config().isAutoRead()) {\n            readDuringHandshake = false;\n            ctx.read();\n        }\n    }"}, {"instruction": "necessary different) mode, and then a code.", "input": "Java", "output": "State latchAndAppend(int mode, int value) {\n    //assert binaryShiftByteCount == 0;\n    int bitCount = this.bitCount;\n    Token token = this.token;\n    if (mode != this.mode) {\n      int latch = HighLevelEncoder.LATCH_TABLE[this.mode][mode];\n      token = token.add(latch & 0xFFFF, latch >> 16);\n      bitCount += latch >> 16;\n    }\n    int latchModeBitCount = mode == HighLevelEncoder.MODE_DIGIT ? 4 : 5;\n    token = token.add(value, latchModeBitCount);\n    return new State(token, mode, 0, bitCount + latchModeBitCount);\n  }"}, {"instruction": "Creates a sorted set with all the parameters from the given {@code query}, ordered lexicographically by name and value.\n\n@param queryString the query string\n@return a sorted set with all parameters, or {@code null} if the query string is {@code null} or empty.", "input": "Java", "output": "private static SortedSet<QueryParameter> createSortedParameters(final String queryString) {\n\t\tif (queryString == null || queryString.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal String[] pairs = queryString.split(\"&\");\n\t\tfinal SortedSet<QueryParameter> params = new TreeSet<>();\n\n\t\tfor (final String pair : pairs) {\n\t\t\tif (pair.length() == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString[] tokens = pair.split(\"=\", 2);\n\t\t\tswitch (tokens.length) {\n\t\t\tcase 1:\n\t\t\t\tif (pair.charAt(0) == '=') {\n\t\t\t\t\tparams.add(new QueryParameter(\"\", tokens[0]));\n\t\t\t\t} else {\n\t\t\t\t\tparams.add(new QueryParameter(tokens[0], \"\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tparams.add(new QueryParameter(tokens[0], tokens[1]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn params;\n\t}"}, {"instruction": "Encode a Uri Chunk, ensuring that all reserved characters are also encoded.\n\n@param value to encode.\n@param type identifying which uri fragment rules to apply.\n@param charset to use.\n@return an encoded uri chunk.", "input": "Java", "output": "private static String encodeChunk(String value, FragmentType type, Charset charset) {\n    byte[] data = value.getBytes(charset);\n    ByteArrayOutputStream encoded = new ByteArrayOutputStream();\n\n    for (byte b : data) {\n      if (type.isAllowed(b)) {\n        encoded.write(b);\n      } else {\n        /* percent encode the byte */\n        pctEncode(b, encoded);\n      }\n    }\n    return new String(encoded.toByteArray());\n  }"}, {"instruction": "Reads the given file line-by-line and creates a data stream that contains a string with the\ncontents of each such line. The {@link java.nio.charset.Charset} with the given name will be\nused to read the files.\n\n<p><b>NOTES ON CHECKPOINTING: </b> The source monitors the path, creates the\n{@link org.apache.flink.core.fs.FileInputSplit FileInputSplits} to be processed,\nforwards them to the downstream {@link ContinuousFileReaderOperator readers} to read the actual data,\nand exits, without waiting for the readers to finish reading. This implies that no more checkpoint\nbarriers are going to be forwarded after the source exits, thus having no checkpoints after that point.\n\n@param filePath\nThe path of the file, as a URI (e.g., \"file:///some/local/file\" or \"hdfs://host:port/file/path\")\n@param charsetName\nThe name of the character set used to read the file\n@return The data stream that represents the data read from the given file as text lines", "input": "Java", "output": "public DataStreamSource<String> readTextFile(String filePath, String charsetName) {\n\t\tPreconditions.checkArgument(!StringUtils.isNullOrWhitespaceOnly(filePath), \"The file path must not be null or blank.\");\n\n\t\tTextInputFormat format = new TextInputFormat(new Path(filePath));\n\t\tformat.setFilesFilter(FilePathFilter.createDefaultFilter());\n\t\tTypeInformation<String> typeInfo = BasicTypeInfo.STRING_TYPE_INFO;\n\t\tformat.setCharsetName(charsetName);\n\n\t\treturn readFile(format, filePath, FileProcessingMode.PROCESS_ONCE, -1, typeInfo);\n\t}"}, {"instruction": "Overwrites the document referred to by this DocumentReference. If the document doesn't exist\nyet, it will be created. If you pass {@link SetOptions}, the provided data can be merged into\nan existing document.\n\n@param documentReference The DocumentReference to overwrite.\n@param pojo The POJO that will be used to populate the document contents.\n@param options An object to configure the set behavior.\n@return The instance for chaining.", "input": "Java", "output": "@Nonnull\n  public T set(\n      @Nonnull DocumentReference documentReference,\n      @Nonnull Object pojo,\n      @Nonnull SetOptions options) {\n    Object data = CustomClassMapper.convertToPlainJavaTypes(pojo);\n    if (!(data instanceof Map)) {\n      throw new IllegalArgumentException(\"Can't set a document's data to an array or primitive\");\n    }\n    return performSet(documentReference, (Map<String, Object>) data, options);\n  }"}, {"instruction": "Deletes this recorder, then go back to the parent.", "input": "Java", "output": "@RequirePOST\n    public synchronized void doDoDelete(StaplerResponse rsp) throws IOException, ServletException {\n        getConfigFile().delete();\n        getParent().logRecorders.remove(name);\n        // Disable logging for all our targets,\n        // then reenable all other loggers in case any also log the same targets\n        for (Target t : targets)\n            t.disable();\n        for (LogRecorder log : getParent().logRecorders.values())\n            for (Target t : log.targets)\n                t.enable();\n        rsp.sendRedirect2(\"..\");\n    }"}, {"instruction": "Sends the registration information of {@link InstanceInfo} receiving by\nthis node to the peer node represented by this class.\n\n@param info\nthe instance information {@link InstanceInfo} of any instance\nthat is send to this instance.\n@throws Exception", "input": "Java", "output": "public void register(final InstanceInfo info) throws Exception {\n        long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);\n        batchingDispatcher.process(\n                taskId(\"register\", info),\n                new InstanceReplicationTask(targetHost, Action.Register, info, null, true) {\n                    public EurekaHttpResponse<Void> execute() {\n                        return replicationClient.register(info);\n                    }\n                },\n                expiryTime\n        );\n    }"}, {"instruction": "Called when a checkpoint barrier arrives. It closes any open streams to the backend\nand marks them as pending for committing to the external, third-party storage system.\n\n@param checkpointId the id of the latest received checkpoint.\n@throws IOException in case something went wrong when handling the stream to the backend.", "input": "Java", "output": "private void saveHandleInState(final long checkpointId, final long timestamp) throws Exception {\n\n\t\t//only add handle if a new OperatorState was created since the last snapshot\n\t\tif (out != null) {\n\t\t\tint subtaskIdx = getRuntimeContext().getIndexOfThisSubtask();\n\t\t\tStreamStateHandle handle = out.closeAndGetHandle();\n\n\t\t\tPendingCheckpoint pendingCheckpoint = new PendingCheckpoint(\n\t\t\t\tcheckpointId, subtaskIdx, timestamp, handle);\n\n\t\t\tif (pendingCheckpoints.contains(pendingCheckpoint)) {\n\t\t\t\t//we already have a checkpoint stored for that ID that may have been partially written,\n\t\t\t\t//so we discard this \"alternate version\" and use the stored checkpoint\n\t\t\t\thandle.discardState();\n\t\t\t} else {\n\t\t\t\tpendingCheckpoints.add(pendingCheckpoint);\n\t\t\t}\n\t\t\tout = null;\n\t\t}\n\t}"}, {"instruction": "Build output frame from the multi-column results", "input": "Java", "output": "public static Frame buildOutput(int[] gbCols, int noutCols, Frame fr, String[] fcnames, int ngrps, MRTask mrfill) {\n\n    // Build the output!\n    // the names of columns\n    final int nCols = gbCols.length + noutCols;\n    String[] names = new String[nCols];\n    String[][] domains = new String[nCols][];\n    byte[] types = new byte[nCols];\n    for (int i = 0; i < gbCols.length; i++) {\n      names[i] = fr.name(gbCols[i]);\n      domains[i] = fr.domains()[gbCols[i]];\n      types[i] = fr.vec(names[i]).get_type();\n    }\n    for (int i = 0; i < fcnames.length; i++) {\n      names[i + gbCols.length] = fcnames[i];\n      types[i + gbCols.length] = Vec.T_NUM;\n    }\n    Vec v = Vec.makeZero(ngrps); // dummy layout vec\n    // Convert the output arrays into a Frame, also doing the post-pass work\n    Frame f =  mrfill.doAll(types, new Frame(v)).outputFrame(names, domains);\n    v.remove();\n    return f;\n  }"}, {"instruction": "Determines the number of consecutive characters that are encodable using text compaction.\n\n@param msg      the message\n@param startpos the start position within the message\n@return the requested character count", "input": "Java", "output": "private static int determineConsecutiveTextCount(CharSequence msg, int startpos) {\n    int len = msg.length();\n    int idx = startpos;\n    while (idx < len) {\n      char ch = msg.charAt(idx);\n      int numericCount = 0;\n      while (numericCount < 13 && isDigit(ch) && idx < len) {\n        numericCount++;\n        idx++;\n        if (idx < len) {\n          ch = msg.charAt(idx);\n        }\n      }\n      if (numericCount >= 13) {\n        return idx - startpos - numericCount;\n      }\n      if (numericCount > 0) {\n        //Heuristic: All text-encodable chars or digits are binary encodable\n        continue;\n      }\n      ch = msg.charAt(idx);\n\n      //Check if character is encodable\n      if (!isText(ch)) {\n        break;\n      }\n      idx++;\n    }\n    return idx - startpos;\n  }"}, {"instruction": "Method used to setup the toolbar elements. Should not usually be overriden. Instead, use the\n{@link #addToolBarElements(JToolBar, short, int)} method to add elements at various points.\n@param toolbar the tool bar of the status panel", "input": "Java", "output": "protected void setupToolbarElements(JToolBar toolbar) {\n\t\tint x = 0;\n\t\tInsets insets = new Insets(0, 4, 0, 2);\n\n\t\tx = this.addToolBarElements(toolbar, TOOLBAR_LOCATION_START, x);\n\n\t\ttoolbar.add(new JLabel(Constant.messages.getString(panelPrefix + \".toolbar.context.label\")),\n\t\t\t\tLayoutHelper.getGBC(x++, 0, 1, 0, insets));\n\t\ttoolbar.add(getContextSelectComboBox(), LayoutHelper.getGBC(x++, 0, 1, 0, insets));\n\n\t\tx = this.addToolBarElements(toolbar, TOOLBAR_LOCATION_AFTER_CONTEXTS_SELECT, x);\n\n\t\ttoolbar.add(new JLabel(), LayoutHelper.getGBC(x++, 0, 1, 1.0)); // Spacer\n\t\tif (hasOptions()) {\n\t\t\ttoolbar.add(getOptionsButton(), LayoutHelper.getGBC(x++, 0, 1, 0, insets));\n\t\t}\n\n\t\tthis.addToolBarElements(toolbar, TOOLBAR_LOCATION_END, x);\n\t}"}, {"instruction": "Creates a new {@link NameResolver}. Override this method to create an alternative {@link NameResolver}\nimplementation or override the default configuration.", "input": "Java", "output": "protected NameResolver<InetAddress> newNameResolver(EventLoop eventLoop,\n                                                        ChannelFactory<? extends DatagramChannel> channelFactory,\n                                                        DnsServerAddressStreamProvider nameServerProvider)\n            throws Exception {\n        // once again, channelFactory and nameServerProvider are most probably set in builder already,\n        // but I do reassign them again to avoid corner cases with override methods\n        return dnsResolverBuilder.eventLoop(eventLoop)\n                .channelFactory(channelFactory)\n                .nameServerProvider(nameServerProvider)\n                .build();\n    }"}, {"instruction": "Returns the name(s) of the outputs for the given function\n\n@param function the function to get the outputs for\n@return the outputs ids for a given function", "input": "Java", "output": "public String[] getOutputsForFunction(DifferentialFunction function) {\n        if (!ops.containsKey(function.getOwnName()))\n            throw new ND4JIllegalStateException(\"Illegal function instance id found \" + function.getOwnName());\n        List<String> outputs = ops.get(function.getOwnName()).getOutputsOfOp();\n        return outputs == null ? null : outputs.toArray(new String[outputs.size()]);\n    }"}, {"instruction": "Example of running a query with the cache disabled.", "input": "Java", "output": "public void runUncachedQuery() throws TimeoutException, InterruptedException {\n    // [START bigquery_query_no_cache]\n    // BigQuery bigquery = BigQueryOptions.getDefaultInstance().getService();\n    String query = \"SELECT corpus FROM `bigquery-public-data.samples.shakespeare` GROUP BY corpus;\";\n    QueryJobConfiguration queryConfig =\n        QueryJobConfiguration.newBuilder(query)\n            // Disable the query cache to force live query evaluation.\n            .setUseQueryCache(false)\n            .build();\n\n    // Print the results.\n    for (FieldValueList row : bigquery.query(queryConfig).iterateAll()) {\n      for (FieldValue val : row) {\n        System.out.printf(\"%s,\", val.toString());\n      }\n      System.out.printf(\"\\n\");\n    }\n    // [END bigquery_query_no_cache]\n  }"}, {"instruction": "Changes the icon size by changing the cookie", "input": "Java", "output": "public void doIconSize( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        String qs = req.getQueryString();\n        if(qs==null)\n            throw new ServletException();\n        Cookie cookie = new Cookie(\"iconSize\", Functions.validateIconSize(qs));\n        cookie.setMaxAge(/* ~4 mo. */9999999); // #762\n        rsp.addCookie(cookie);\n        String ref = req.getHeader(\"Referer\");\n        if(ref==null)   ref=\".\";\n        rsp.sendRedirect2(ref);\n    }"}, {"instruction": "TODO hongjun: find table from parent select statement, should find table in subquery level only", "input": "Java", "output": "public static Optional<String> findTableName(final PredicateSegment predicateSegment, final SQLStatement sqlStatement, final ShardingTableMetaData shardingTableMetaData) {\n        if (!(sqlStatement instanceof SelectStatement)) {\n            return Optional.of(sqlStatement.getTables().getSingleTableName());\n        }\n        SelectStatement currentSelectStatement = (SelectStatement) sqlStatement;\n        while (null != currentSelectStatement.getParentStatement()) {\n            currentSelectStatement = currentSelectStatement.getParentStatement();\n            Optional<String> tableName = findTableName(predicateSegment, currentSelectStatement.getTables(), shardingTableMetaData);\n            if (tableName.isPresent()) {\n                return tableName;\n            }\n        }\n        return findTableName(predicateSegment, currentSelectStatement.getTables(), shardingTableMetaData);\n    }"}, {"instruction": "Print the job properties except property key contains \"pass\" and \"word\".", "input": "Java", "output": "@VisibleForTesting\n  Map<String, String> printableJobProperties(Props jobProps) {\n    Predicate<String> keyPredicate = new Predicate<String>() {\n\n      @Override\n      public boolean apply(String key) {\n        if (StringUtils.isEmpty(key)) {\n          return true;\n        }\n        key = key.toLowerCase();\n        return !(key.contains(\"pass\") && key.contains(\"word\"));\n      }\n\n    };\n    return Maps.filterKeys(jobProps.getFlattened(), keyPredicate);\n  }"}, {"instruction": "A final allocation pass with no code length limit.\n@param array The code length array", "input": "Java", "output": "private static void allocateNodeLengths(final int[] array) {\n        int firstNode = array.length - 2;\n        int nextNode = array.length - 1;\n\n        for (int currentDepth = 1, availableNodes = 2; availableNodes > 0; currentDepth++) {\n            final int lastNode = firstNode;\n            firstNode = first(array, lastNode - 1, 0);\n\n            for (int i = availableNodes - (lastNode - firstNode); i > 0; i--) {\n                array[nextNode--] = currentDepth;\n            }\n\n            availableNodes = (lastNode - firstNode) << 1;\n        }\n    }"}, {"instruction": "\u4ece\u5b57\u8282\u6570\u7ec4\u52a0\u8f7d\uff08\u53d1\u73b0\u5728MacOS\u4e0a\uff0c\u6b64\u65b9\u6cd5\u6bd4ByteArray\u66f4\u5feb\uff09\n@param bytes\n@param offset\n@param value\n@return", "input": "Java", "output": "public boolean load(byte[] bytes, int offset, V[] value)\n    {\n        if (bytes == null) return false;\n        size = ByteUtil.bytesHighFirstToInt(bytes, offset);\n        offset += 4;\n        base = new int[size + 65535];   // \u591a\u7559\u4e00\u4e9b\uff0c\u9632\u6b62\u8d8a\u754c\n        check = new int[size + 65535];\n        for (int i = 0; i < size; i++)\n        {\n            base[i] = ByteUtil.bytesHighFirstToInt(bytes, offset);\n            offset += 4;\n            check[i] = ByteUtil.bytesHighFirstToInt(bytes, offset);\n            offset += 4;\n        }\n        v = value;\n        return true;\n    }"}, {"instruction": "\u521b\u5efa\u7528\u4e8e\u67e5\u8be2\u8bed\u53e5\u7684{@link URLEncoder}<br>\n\u7f16\u7801\u5668\u9488\u5bf9URI\u8def\u5f84\u7f16\u7801\uff0c\u5b9a\u4e49\u5982\u4e0b\uff1a\n\n<pre>\n0x20 ' ' =\u300b '+'\n0x2A, 0x2D, 0x2E, 0x30 to 0x39, 0x41 to 0x5A, 0x5F, 0x61 to 0x7A as-is\n'*', '-', '.', '0' to '9', 'A' to 'Z', '_', 'a' to 'z' Also '=' and '&' \u4e0d\u7f16\u7801\n\u5176\u5b83\u7f16\u7801\u4e3a %nn \u5f62\u5f0f\n</pre>\n\n\u8be6\u7ec6\u89c1\uff1ahttps://www.w3.org/TR/html5/forms.html#application/x-www-form-urlencoded-encoding-algorithm\n\n@return {@link URLEncoder}", "input": "Java", "output": "public static URLEncoder createQuery() {\r\n\t\tfinal URLEncoder encoder = new URLEncoder();\r\n\t\t// Special encoding for space\r\n\t\tencoder.setEncodeSpaceAsPlus(true);\r\n\t\t// Alpha and digit are safe by default\r\n\t\t// Add the other permitted characters\r\n\t\tencoder.addSafeCharacter('*');\r\n\t\tencoder.addSafeCharacter('-');\r\n\t\tencoder.addSafeCharacter('.');\r\n\t\tencoder.addSafeCharacter('_');\r\n\t\tencoder.addSafeCharacter('=');\r\n\t\tencoder.addSafeCharacter('&');\r\n\r\n\t\treturn encoder;\r\n\t}"}, {"instruction": "------------------------------------------------------------------------", "input": "Java", "output": "@Override\n\tpublic Long getValue() {\n\t\tfinal JobStatus status = eg.getState();\n\n\t\tif (status == JobStatus.RUNNING) {\n\t\t\t// running right now - report the uptime\n\t\t\tfinal long runningTimestamp = eg.getStatusTimestamp(JobStatus.RUNNING);\n\t\t\t// we use 'Math.max' here to avoid negative timestamps when clocks change\n\t\t\treturn Math.max(System.currentTimeMillis() - runningTimestamp, 0);\n\t\t}\n\t\telse if (status.isTerminalState()) {\n\t\t\t// not running any more -> finished or not on leader\n\t\t\treturn NO_LONGER_RUNNING;\n\t\t}\n\t\telse {\n\t\t\t// not yet running or not up at the moment\n\t\t\treturn 0L;\n\t\t}\n\t}"}, {"instruction": "Instantiates a template and begins execution.\n\n<p>This method is equivalent to executing the sequence\n[CreateWorkflowTemplate][google.cloud.dataproc.v1beta2.WorkflowTemplateService.CreateWorkflowTemplate],\n[InstantiateWorkflowTemplate][google.cloud.dataproc.v1beta2.WorkflowTemplateService.InstantiateWorkflowTemplate],\n[DeleteWorkflowTemplate][google.cloud.dataproc.v1beta2.WorkflowTemplateService.DeleteWorkflowTemplate].\n\n<p>The returned Operation can be used to track execution of workflow by polling\n[operations.get][google.longrunning.Operations.GetOperation]. The Operation will complete when\nentire workflow is finished.\n\n<p>The running workflow can be aborted via\n[operations.cancel][google.longrunning.Operations.CancelOperation]. This will cause any\ninflight jobs to be cancelled and workflow-owned clusters to be deleted.\n\n<p>The [Operation.metadata][google.longrunning.Operation.metadata] will be\n[WorkflowMetadata][google.cloud.dataproc.v1beta2.WorkflowMetadata].\n\n<p>On successful completion, [Operation.response][google.longrunning.Operation.response] will\nbe [Empty][google.protobuf.Empty].\n\n<p>Sample code:\n\n<pre><code>\ntry (WorkflowTemplateServiceClient workflowTemplateServiceClient = WorkflowTemplateServiceClient.create()) {\nString formattedParent = RegionName.format(\"[PROJECT]\", \"[REGION]\");\nWorkflowTemplate template = WorkflowTemplate.newBuilder().build();\nworkflowTemplateServiceClient.instantiateInlineWorkflowTemplateAsync(formattedParent, template).get();\n}\n</code></pre>\n\n@param parent Required. The \"resource name\" of the workflow template region, as described in\nhttps://cloud.google.com/apis/design/resource_names of the form\n`projects/{project_id}/regions/{region}`\n@param template Required. The workflow template to instantiate.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi(\n      \"The surface for long-running operations is not stable yet and may change in the future.\")\n  public final OperationFuture<Empty, WorkflowMetadata> instantiateInlineWorkflowTemplateAsync(\n      String parent, WorkflowTemplate template) {\n\n    InstantiateInlineWorkflowTemplateRequest request =\n        InstantiateInlineWorkflowTemplateRequest.newBuilder()\n            .setParent(parent)\n            .setTemplate(template)\n            .build();\n    return instantiateInlineWorkflowTemplateAsync(request);\n  }"}, {"instruction": "return current date time by specified hour:minute\n\n@param plan format: hh:mm", "input": "Java", "output": "public static Date getCurrentDateByPlan(String plan, String pattern) {\n\t\ttry {\n\t\t\tFastDateFormat format = FastDateFormat.getInstance(pattern);\n\t\t\tDate end = format.parse(plan);\n\t\t\tCalendar today = Calendar.getInstance();\n\t\t\tend = DateUtils.setYears(end, (today.get(Calendar.YEAR)));\n\t\t\tend = DateUtils.setMonths(end, today.get(Calendar.MONTH));\n\t\t\tend = DateUtils.setDays(end, today.get(Calendar.DAY_OF_MONTH));\n\t\t\treturn end;\n\t\t} catch (Exception e) {\n\t\t\tthrow ExceptionUtil.unchecked(e);\n\t\t}\n\t}"}, {"instruction": "Returns the number of selected messages of the given message container.\n<p>\nBy default it returns the number of selected messages from {@code SelectableHttpMessagesContainer}s and for\n{@code SingleHttpMessageContainer}s returns 1 if it contains a message, 0 otherwise.\n</p>\n<p>\nNormally overridden if other implementations of {@code HttpMessageContainer} are supported. Default are\n{@code SingleHttpMessageContainer} and {@code SelectableHttpMessagesContainer}.\n</p>\n\n@param httpMessageContainer the container that will be evaluated\n@return the number of selected messages in the message container\n@see SingleHttpMessageContainer\n@see SelectableHttpMessagesContainer", "input": "Java", "output": "protected int getNumberOfSelectedMessages(HttpMessageContainer httpMessageContainer) {\n        if (httpMessageContainer instanceof SelectableHttpMessagesContainer) {\n            return ((SelectableHttpMessagesContainer) httpMessageContainer).getNumberOfSelectedMessages();\n        } else if (httpMessageContainer instanceof SingleHttpMessageContainer) {\n            return ((SingleHttpMessageContainer) httpMessageContainer).isEmpty() ? 0 : 1;\n        }\n\n        return 0;\n    }"}, {"instruction": "Calculate the output shape for this op\n\n@return", "input": "Java", "output": "public List<LongShapeDescriptor> calculateOutputShape() {\n        if(x == null || y == null)\n            return Collections.emptyList();\n\n        long[] shapeX = x.shape();\n        long[] shapeY = y.shape();\n\n        return Collections.singletonList(LongShapeDescriptor.fromShape(Shape.broadcastOutputShape(shapeX, shapeY),\n                Shape.pickPairwiseDataType(x.dataType(), y.dataType())));\n    }"}, {"instruction": "------------------------------------------------------------------------", "input": "Java", "output": "@Override\n\tpublic void report() {\n\t\t// instead of locking here, we tolerate exceptions\n\t\t// we do this to prevent holding the lock for very long and blocking\n\t\t// operator creation and shutdown\n\t\ttry {\n\t\t\tfor (Map.Entry<Gauge<?>, String> entry : gauges.entrySet()) {\n\t\t\t\tif (closed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treportGauge(entry.getValue(), entry.getKey());\n\t\t\t}\n\n\t\t\tfor (Map.Entry<Counter, String> entry : counters.entrySet()) {\n\t\t\t\tif (closed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treportCounter(entry.getValue(), entry.getKey());\n\t\t\t}\n\n\t\t\tfor (Map.Entry<Histogram, String> entry : histograms.entrySet()) {\n\t\t\t\treportHistogram(entry.getValue(), entry.getKey());\n\t\t\t}\n\n\t\t\tfor (Map.Entry<Meter, String> entry : meters.entrySet()) {\n\t\t\t\treportMeter(entry.getValue(), entry.getKey());\n\t\t\t}\n\t\t}\n\t\tcatch (ConcurrentModificationException | NoSuchElementException e) {\n\t\t\t// ignore - may happen when metrics are concurrently added or removed\n\t\t\t// report next time\n\t\t}\n\t}"}, {"instruction": "Tries to load the record #N.\n\n@return null if the data failed to load.", "input": "Java", "output": "private R load(int n, Index editInPlace) {\n        assert Thread.holdsLock(this);\n        assert dir != null;\n        R v = load(new File(dir, String.valueOf(n)), editInPlace);\n        if (v==null && editInPlace!=null) {\n            // remember the failure.\n            // if editInPlace==null, we can create a new copy for this, but not sure if it's worth doing,\n            // TODO should we also update numberOnDisk?\n            editInPlace.byNumber.put(n, null);\n        }\n        return v;\n    }"}, {"instruction": "Checks if the constant pool contains a reference to a given method, with any signature (return type and parameter types).\n\n@param className must be provided JVM-style, such as {@code java/lang/String}", "input": "Java", "output": "public boolean usesMethod(String className, String methodName) {\n\t\tint classIndex = findClass(className);\n\t\tif (classIndex == NOT_FOUND) return false;\n\t\tint methodNameIndex = findUtf8(methodName);\n\t\tif (methodNameIndex == NOT_FOUND) return false;\n\t\t\n\t\tfor (int i = 1; i < maxPoolSize; i++) {\n\t\t\tif (isMethod(i) && readValue(offsets[i]) == classIndex) {\n\t\t\t\tint nameAndTypeIndex = readValue(offsets[i] + 2);\n\t\t\t\tif (readValue(offsets[nameAndTypeIndex]) == methodNameIndex) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"}, {"instruction": "\u5339\u914d\u6bcd\u6587\u672c\n\n@param text \u4e00\u4e9b\u6587\u672c\n@return \u4e00\u4e2apair\u5217\u8868", "input": "Java", "output": "public List<Hit<V>> parseText(String text)\n    {\n        int position = 1;\n        int currentState = 0;\n        List<Hit<V>> collectedEmits = new LinkedList<Hit<V>>();\n        for (int i = 0; i < text.length(); ++i)\n        {\n            currentState = getState(currentState, text.charAt(i));\n            storeEmits(position, currentState, collectedEmits);\n            ++position;\n        }\n\n        return collectedEmits;\n    }"}, {"instruction": "Subscribe provider list from direct url\n\n@param directUrl direct url of consume config\n@return Provider group list", "input": "Java", "output": "protected List<ProviderGroup> subscribeFromDirectUrl(String directUrl) {\n        List<ProviderGroup> result = new ArrayList<ProviderGroup>();\n        List<ProviderInfo> tmpProviderInfoList = new ArrayList<ProviderInfo>();\n        String[] providerStrs = StringUtils.splitWithCommaOrSemicolon(directUrl);\n        for (String providerStr : providerStrs) {\n            ProviderInfo providerInfo = convertToProviderInfo(providerStr);\n            if (providerInfo.getStaticAttr(ProviderInfoAttrs.ATTR_SOURCE) == null) {\n                providerInfo.setStaticAttr(ProviderInfoAttrs.ATTR_SOURCE, \"direct\");\n            }\n            tmpProviderInfoList.add(providerInfo);\n        }\n\n        result.add(new ProviderGroup(RpcConstants.ADDRESS_DIRECT_GROUP, tmpProviderInfoList));\n        return result;\n    }"}, {"instruction": "Raw digest byte [ ].\n\n@param alg  the alg\n@param salt the salt\n@param data the data\n@return the byte [ ]", "input": "Java", "output": "public static byte[] rawDigest(final String alg, final String salt, final String... data) {\n        try {\n            val digest = getMessageDigestInstance(alg);\n            Arrays.stream(data).forEach(d -> digest.update(d.getBytes(StandardCharsets.UTF_8)));\n            return digest.digest(salt.getBytes(StandardCharsets.UTF_8));\n        } catch (final Exception cause) {\n            throw new SecurityException(cause);\n        }\n    }"}, {"instruction": "Delete TGT's service tickets.\n\n@param ticket the ticket\n@return the count of tickets that were removed including child tickets and zero if the ticket was not deleted", "input": "Java", "output": "protected int deleteChildren(final TicketGrantingTicket ticket) {\n        val count = new AtomicInteger(0);\n        val services = ticket.getServices();\n        if (services != null && !services.isEmpty()) {\n            services.keySet().forEach(ticketId -> {\n                if (deleteSingleTicket(ticketId)) {\n                    LOGGER.debug(\"Removed ticket [{}]\", ticketId);\n                    count.incrementAndGet();\n                } else {\n                    LOGGER.debug(\"Unable to remove ticket [{}]\", ticketId);\n                }\n            });\n        }\n        return count.intValue();\n    }"}, {"instruction": "Resolve the JVM arguments to use.\n@return a {@link RunArguments} defining the JVM arguments", "input": "Java", "output": "protected RunArguments resolveJvmArguments() {\n\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\tif (this.systemPropertyVariables != null) {\n\t\t\tstringBuilder.append(this.systemPropertyVariables.entrySet().stream()\n\t\t\t\t\t.map((e) -> SystemPropertyFormatter.format(e.getKey(), e.getValue()))\n\t\t\t\t\t.collect(Collectors.joining(\" \")));\n\t\t}\n\t\tif (this.jvmArguments != null) {\n\t\t\tstringBuilder.append(\" \").append(this.jvmArguments);\n\t\t}\n\t\treturn new RunArguments(stringBuilder.toString());\n\t}"}, {"instruction": "Convert a string time series to\nthe proper writable set based on the schema.\nNote that this does not use arrow.\nThis just uses normal writable objects.\n\n@param stringInput the string input\n@param schema the schema to use\n@return the converted records", "input": "Java", "output": "public static List<List<String>> convertWritableInputToString(List<List<Writable>> stringInput,Schema schema) {\n        List<List<String>> ret = new ArrayList<>();\n        List<List<String>> timeStepAdd = new ArrayList<>();\n        for(int j = 0; j < stringInput.size(); j++) {\n            List<Writable> record = stringInput.get(j);\n            List<String> recordAdd = new ArrayList<>();\n            for(int k = 0; k < record.size(); k++) {\n                recordAdd.add(record.get(k).toString());\n            }\n\n            timeStepAdd.add(recordAdd);\n        }\n\n\n        return ret;\n    }"}, {"instruction": "Class[]\u8f6cString[] <br>\n\u6ce8\u610f\uff0c\u5f97\u5230\u7684String\u53ef\u80fd\u4e0d\u80fd\u76f4\u63a5\u7528\u4e8eClass.forName\uff0c\u8bf7\u4f7f\u7528getClasses(String[])\u53cd\u5411\u83b7\u53d6\n\n@param types Class[]\n@param javaStyle JDK\u81ea\u5e26\u683c\u5f0f\uff0c\u4f8b\u5982 int[], true\u7684\u8bdd\u8fd4\u56de [I; false\u7684\u8bdd\u8fd4\u56deint[]\n@return \u5bf9\u8c61\u63cf\u8ff0\n@see #getClasses(String[])", "input": "Java", "output": "public static String[] getTypeStrs(Class[] types, boolean javaStyle) {\n        if (CommonUtils.isEmpty(types)) {\n            return StringUtils.EMPTY_STRING_ARRAY;\n        } else {\n            String[] strings = new String[types.length];\n            for (int i = 0; i < types.length; i++) {\n                strings[i] = javaStyle ? types[i].getName() : getTypeStr(types[i]);\n            }\n            return strings;\n        }\n    }"}, {"instruction": "Specifies the types for the CSV fields. This method parses the CSV data to a 2-tuple\nwhich has fields of the specified types.\nThis method is overloaded for each possible length of the tuples to support type safe\ncreation of data sets through CSV parsing.\n\n@param type0 The type of CSV field 0 and the type of field 0 in the returned tuple type.\n@param type1 The type of CSV field 1 and the type of field 1 in the returned tuple type.\n@return The {@link org.apache.flink.api.java.DataSet} representing the parsed CSV data.", "input": "Java", "output": "public <T0, T1> DataSource<Tuple2<T0, T1>> types(Class<T0> type0, Class<T1> type1) {\n\t\tTupleTypeInfo<Tuple2<T0, T1>> types = TupleTypeInfo.getBasicAndBasicValueTupleTypeInfo(type0, type1);\n\t\tCsvInputFormat<Tuple2<T0, T1>> inputFormat = new TupleCsvInputFormat<Tuple2<T0, T1>>(path, types, this.includedMask);\n\t\tconfigureInputFormat(inputFormat);\n\t\treturn new DataSource<Tuple2<T0, T1>>(executionContext, inputFormat, types, Utils.getCallLocationName());\n\t}"}, {"instruction": "Shuts down a reader, releasing all of its segments. The reader should cease all operations.\n@param lastPosition The last position the reader successfully read from.", "input": "Java", "output": "static void readerShutdown(String readerId, Position lastPosition, StateSynchronizer<ReaderGroupState> sync) {\n        sync.updateState((state, updates) -> {\n            Set<Segment> segments = state.getSegments(readerId);\n            if (segments == null) {\n                return;\n            }\n            log.debug(\"Removing reader {} from reader grop. CurrentState is: {}\", readerId, state);\n            updates.add(new RemoveReader(readerId, lastPosition == null ? Collections.emptyMap()\n                    : lastPosition.asImpl().getOwnedSegmentsWithOffsets()));\n        });\n    }"}, {"instruction": "Transform an object\nin to another object\n\n@param input the record to transform\n@return the transformed writable", "input": "Java", "output": "@Override\n    public Object map(Object input) {\n        List<Long> list = (List<Long>) input;\n        switch (mathOp) {\n            case Add:\n                long sum = 0;\n                for (Long w : list)\n                    sum += w;\n                return new LongWritable(sum);\n            case Subtract:\n                return list.get(0) - list.get(1);\n            case Multiply:\n                long product = 1;\n                for (Long w : list)\n                    product *= w;\n                return product;\n            case Divide:\n                return list.get(0) / list.get(1);\n            case Modulus:\n                return list.get(0) % list.get(1);\n            case ReverseSubtract:\n            case ReverseDivide:\n            case ScalarMin:\n            case ScalarMax:\n            default:\n                throw new RuntimeException(\"Invalid mathOp: \" + mathOp); //Should never happen\n        }\n    }"}, {"instruction": "Returns the type of column for given column index.\nThis should be overriden for any custom columns\n\n@param columnIndex the column index\n@return the column class", "input": "Java", "output": "@Override\n\tpublic Class<?> getColumnClass(int columnIndex) {\n\t\tswitch (this.columns[columnIndex]) {\n\t\tcase HREF_ID:\t\treturn Integer.class;\n\t\tcase TYPE_FLAG:\t\treturn ImageIcon.class;\n\t\tcase METHOD:\t\treturn String.class;\n\t\tcase URL:\t\t\treturn String.class;\n\t\tcase CODE:\t\t\treturn Integer.class;\n\t\tcase REASON:\t\treturn String.class;\n\t\tcase RTT:\t\t\treturn Integer.class;\n\t\tcase SIZE:\t\t\treturn Integer.class;\n\t\tcase SESSION_ID:\treturn Long.class;\n\t\tcase ALERT_FLAG:\treturn ImageIcon.class;\n\t\tcase TAGS:\t\t\treturn String.class;\n\t\tdefault:\t\t\treturn null;\n\t\t}\n\t}"}, {"instruction": "Initialize Settings for child components in build widget\n1. Build Status criteria settings\n2. Build Duration criteria settings\n\n@param buildScoreSettings", "input": "Java", "output": "private void initBuildScoreChildrenSettings(BuildScoreSettings buildScoreSettings) {\n    ScoreComponentSettings buildStatusSettings = Utils.getInstanceIfNull(\n      buildScoreSettings.getStatus(),\n      ScoreComponentSettings.class\n    );\n    buildStatusSettings.setCriteria(\n      Utils.mergeCriteria(buildScoreSettings.getCriteria(), buildStatusSettings.getCriteria())\n    );\n    buildScoreSettings.setStatus(buildStatusSettings);\n\n    BuildScoreSettings.BuildDurationScoreSettings buildDurationSettings = Utils.getInstanceIfNull(\n      buildScoreSettings.getDuration(),\n      BuildScoreSettings.BuildDurationScoreSettings.class\n    );\n\n    buildDurationSettings.setCriteria(\n      Utils.mergeCriteria(buildScoreSettings.getCriteria(), buildDurationSettings.getCriteria())\n    );\n    buildScoreSettings.setDuration(buildDurationSettings);\n  }"}, {"instruction": "\u6784\u5efa\u961f\u5217\n\n@param size       \u961f\u5217\u5927\u5c0f\n@param isPriority \u662f\u5426\u4f18\u5148\u7ea7\u961f\u5217\n@return \u961f\u5217", "input": "Java", "output": "public static BlockingQueue<Runnable> buildQueue(int size, boolean isPriority) {\n        BlockingQueue<Runnable> queue;\n        if (size == 0) { // \u9ed8\u8ba4\u65e0\u961f\u5217\n            queue = new SynchronousQueue<Runnable>();\n        } else { // \u6709\u9650\u961f\u5217\u6216\u65e0\u9650\u961f\u5217\n            if (isPriority) {\n                queue = size < 0 ? new PriorityBlockingQueue<Runnable>()\n                    : new PriorityBlockingQueue<Runnable>(size);\n            } else {\n                queue = size < 0 ? new LinkedBlockingQueue<Runnable>()\n                    : new LinkedBlockingQueue<Runnable>(size);\n            }\n        }\n        return queue;\n    }"}, {"instruction": "Produce ticket.\n\n@param <T>                 the type parameter\n@param proxyGrantingTicket the proxy granting ticket\n@param service             the service\n@param ticketId            the ticket id\n@param clazz               the clazz\n@return the ticket", "input": "Java", "output": "protected <T extends Ticket> T produceTicket(final ProxyGrantingTicket proxyGrantingTicket,\n                                                 final Service service, final String ticketId,\n                                                 final Class<T> clazz) {\n        val expirationPolicyToUse = determineExpirationPolicyForService(service);\n        val result = proxyGrantingTicket.grantProxyTicket(\n            ticketId,\n            service,\n            expirationPolicyToUse,\n            this.onlyTrackMostRecentSession);\n\n        if (!clazz.isAssignableFrom(result.getClass())) {\n            throw new ClassCastException(\"Result [\" + result\n                + \" is of type \" + result.getClass()\n                + \" when we were expecting \" + clazz);\n        }\n        return (T) result;\n    }"}, {"instruction": "Processing of queries with BitmapOffsets, whose Bitmaps has different factorized fullness (bucket), reported from\nthis method, uses different copies of the same code, so JIT compiler analyzes and compiles the code for different\nfactorized fullness separately. The goal is to capture frequency of abstraction usage in compressed bitmap\nalgorithms, i. e.\n- \"Zero sequence\" vs. \"Literal\" vs. \"One sequence\" in {@link org.apache.druid.extendedset.intset.ImmutableConciseSet}\n- {@link org.roaringbitmap.ArrayContainer} vs {@link org.roaringbitmap.BitmapContainer} in Roaring\nand then https://shipilev.net/blog/2015/black-magic-method-dispatch/ comes into play. The secondary goal is to\ncapture HotSpot's thresholds, which it uses to compile conditional blocks differently inside bitmap impls. See\nhttps://bugs.openjdk.java.net/browse/JDK-6743900. The default BlockLayoutMinDiamondPercentage=20, i. e. if\nprobability of taking some branch is less than 20%, it is moved out of the hot path (to save some icache?).\n\nOn the other hand, we don't want to factor fullness into too small pieces, because\n- too little queries may fall into those small buckets, and they are not compiled with Hotspot's C2 compiler\n- if there are a lot of queries for each small factorized fullness and their copies of the code is compiled by\nC2, this pollutes code cache and takes time to perform too many compilations, while some of them likely produce\nidentical code.\n\nIdeally there should be as much buckets as possible as long as Hotspot's C2 output for each bucket is different.", "input": "Java", "output": "private static String factorizeFullness(long bitmapCardinality, long numRows)\n  {\n    if (bitmapCardinality == 0) {\n      return \"0\";\n    } else if (bitmapCardinality == numRows) {\n      return \"1\";\n    } else {\n      double fullness = bitmapCardinality / (double) numRows;\n      int index = Arrays.binarySearch(BITMAP_FULLNESS_FACTORIZATION_STOPS, fullness);\n      if (index < 0) {\n        index = ~index;\n      }\n      return FACTORIZED_FULLNESS[index];\n    }\n  }"}, {"instruction": "!!! Only supports MySQL", "input": "Java", "output": "public static List<String> findSchemas(JdbcTemplate jdbcTemplate, final String schemaPattern,\n                                           final DdlSchemaFilter ddlSchemaFilter) {\n        List<String> schemas = findSchemas(jdbcTemplate, schemaPattern);\n        if (ddlSchemaFilter == null) {\n            return schemas;\n        }\n        List<String> filterSchemas = new ArrayList<String>();\n        for (String schema : schemas) {\n            if (ddlSchemaFilter.accept(schema)) {\n                filterSchemas.add(schema);\n            }\n        }\n        return filterSchemas;\n    }"}, {"instruction": "Return the appropriate {@link AnnotationAttributes} from the\n{@link AnnotationMetadata}. By default this method will return attributes for\n{@link #getAnnotationClass()}.\n@param metadata the annotation metadata\n@return annotation attributes", "input": "Java", "output": "protected AnnotationAttributes getAttributes(AnnotationMetadata metadata) {\n\t\tString name = getAnnotationClass().getName();\n\t\tAnnotationAttributes attributes = AnnotationAttributes\n\t\t\t\t.fromMap(metadata.getAnnotationAttributes(name, true));\n\t\tAssert.notNull(attributes,\n\t\t\t\t() -> \"No auto-configuration attributes found. Is \"\n\t\t\t\t\t\t+ metadata.getClassName() + \" annotated with \"\n\t\t\t\t\t\t+ ClassUtils.getShortName(name) + \"?\");\n\t\treturn attributes;\n\t}"}, {"instruction": "Remove a value from the bag.  This method should only be called\nwith objects obtained by <code>borrow(long, TimeUnit)</code> or <code>reserve(T)</code>\n\n@param bagEntry the value to remove\n@return true if the entry was removed, false otherwise\n@throws IllegalStateException if an attempt is made to remove an object\nfrom the bag that was not borrowed or reserved first", "input": "Java", "output": "public boolean remove(final T bagEntry)\n   {\n      if (!bagEntry.compareAndSet(STATE_IN_USE, STATE_REMOVED) && !bagEntry.compareAndSet(STATE_RESERVED, STATE_REMOVED) && !closed) {\n         LOGGER.warn(\"Attempt to remove an object from the bag that was not borrowed or reserved: {}\", bagEntry);\n         return false;\n      }\n\n      final boolean removed = sharedList.remove(bagEntry);\n      if (!removed && !closed) {\n         LOGGER.warn(\"Attempt to remove an object from the bag that does not exist: {}\", bagEntry);\n      }\n\n      return removed;\n   }"}, {"instruction": "Takes and rotates the it 90 degrees", "input": "Java", "output": "private static byte[][] rotateArray(byte[][] bitarray) {\n    byte[][] temp = new byte[bitarray[0].length][bitarray.length];\n    for (int ii = 0; ii < bitarray.length; ii++) {\n      // This makes the direction consistent on screen when rotating the\n      // screen;\n      int inverseii = bitarray.length - ii - 1;\n      for (int jj = 0; jj < bitarray[0].length; jj++) {\n        temp[jj][inverseii] = bitarray[ii][jj];\n      }\n    }\n    return temp;\n  }"}, {"instruction": "If the session has a delegation token obtained from the metastore, then cancel it", "input": "Java", "output": "private void cancelDelegationToken() throws HiveSQLException {\n    if (delegationTokenStr != null) {\n      try {\n        Hive.get(getHiveConf()).cancelDelegationToken(delegationTokenStr);\n      } catch (HiveException e) {\n        throw new HiveSQLException(\"Couldn't cancel delegation token\", e);\n      }\n      // close the metastore connection created with this delegation token\n      Hive.closeCurrent();\n    }\n  }"}, {"instruction": "\u6241\u5e73\u5316\u590d\u5236\n@param prefix \u524d\u7f00\n@param sourceMap \u539f\u59cbmap\n@param dstMap \u76ee\u6807map", "input": "Java", "output": "public static void flatCopyTo(String prefix, Map<String, Object> sourceMap,\n                                  Map<String, String> dstMap) {\n        for (Map.Entry<String, Object> entry : sourceMap.entrySet()) {\n            String key = prefix + entry.getKey();\n            Object value = entry.getValue();\n            if (value instanceof String) {\n                dstMap.put(key, (String) value);\n            } else if (value instanceof Number) {\n                dstMap.put(key, value.toString());\n            } else if (value instanceof Map) {\n                flatCopyTo(key + \".\", (Map<String, Object>) value, dstMap);\n            }\n        }\n    }"}, {"instruction": "Create merge engine instance.\n\n@param databaseType database type\n@param shardingRule sharding rule\n@param routeResult SQL route result\n@param shardingTableMetaData sharding table meta Data\n@param queryResults query results\n@return merge engine instance\n@throws SQLException SQL exception", "input": "Java", "output": "public static MergeEngine newInstance(final DatabaseType databaseType, final ShardingRule shardingRule,\n                                          final SQLRouteResult routeResult, final ShardingTableMetaData shardingTableMetaData, final List<QueryResult> queryResults) throws SQLException {\n        if (routeResult.getSqlStatement() instanceof SelectStatement) {\n            return new DQLMergeEngine(databaseType, routeResult, queryResults);\n        } \n        if (routeResult.getSqlStatement() instanceof DALStatement) {\n            return new DALMergeEngine(shardingRule, queryResults, (DALStatement) routeResult.getSqlStatement(), shardingTableMetaData);\n        }\n        throw new UnsupportedOperationException(String.format(\"Cannot support type '%s'\", routeResult.getSqlStatement().getType()));\n    }"}, {"instruction": "Configure ldap authentication provider.\n\n@param auth the auth\n@param ldap the ldap", "input": "Java", "output": "protected void configureLdapAuthenticationProvider(final AuthenticationManagerBuilder auth, final MonitorProperties.Endpoints.LdapSecurity ldap) {\n        if (isLdapAuthorizationActive()) {\n            val p = new MonitorEndpointLdapAuthenticationProvider(ldap, securityProperties);\n            auth.authenticationProvider(p);\n        } else {\n            LOGGER.trace(\"LDAP authorization is undefined, given no LDAP url, base-dn, search filter or role/group filter is configured\");\n        }\n    }"}, {"instruction": "Use ZipOutputStream to zip text to byte array, then convert\nbyte array to base64 string, so it can be transferred via http request.\n\n@param srcTxt the src txt\n@return the string in UTF-8 format and base64'ed, or null.", "input": "Java", "output": "@SneakyThrows\n    public static String compress(final String srcTxt) {\n        try (val rstBao = new ByteArrayOutputStream(); val zos = new GZIPOutputStream(rstBao)) {\n            zos.write(srcTxt.getBytes(StandardCharsets.UTF_8));\n            zos.flush();\n            zos.finish();\n            val bytes = rstBao.toByteArray();\n            val base64 = StringUtils.remove(EncodingUtils.encodeBase64(bytes), '\\0');\n            return new String(StandardCharsets.UTF_8.encode(base64).array(), StandardCharsets.UTF_8);\n        }\n    }"}, {"instruction": "Encode ticket id into a SHA-512.\n\n@param ticketId the ticket id\n@return the ticket", "input": "Java", "output": "protected String encodeTicketId(final String ticketId) {\n        if (!isCipherExecutorEnabled()) {\n            LOGGER.trace(MESSAGE);\n            return ticketId;\n        }\n        if (StringUtils.isBlank(ticketId)) {\n            return ticketId;\n        }\n        val encodedId = DigestUtils.sha512(ticketId);\n        LOGGER.debug(\"Encoded original ticket id [{}] to [{}]\", ticketId, encodedId);\n        return encodedId;\n    }"}, {"instruction": "Generate a project based on the specified {@link ProjectGenerationRequest}.\n@param request the generation request\n@return an entity defining the project\n@throws IOException if generation fails", "input": "Java", "output": "public ProjectGenerationResponse generate(ProjectGenerationRequest request)\n\t\t\tthrows IOException {\n\t\tLog.info(\"Using service at \" + request.getServiceUrl());\n\t\tInitializrServiceMetadata metadata = loadMetadata(request.getServiceUrl());\n\t\tURI url = request.generateUrl(metadata);\n\t\tCloseableHttpResponse httpResponse = executeProjectGenerationRequest(url);\n\t\tHttpEntity httpEntity = httpResponse.getEntity();\n\t\tvalidateResponse(httpResponse, request.getServiceUrl());\n\t\treturn createResponse(httpResponse, httpEntity);\n\t}"}, {"instruction": "Put.\n\n@param service the service", "input": "Java", "output": "public void put(final RegisteredService service) {\n        val values = buildTableAttributeValuesMapFromService(service);\n        val putItemRequest = new PutItemRequest(dynamoDbProperties.getTableName(), values);\n        LOGGER.debug(\"Submitting put request [{}] for service id [{}]\", putItemRequest, service.getServiceId());\n        val putItemResult = amazonDynamoDBClient.putItem(putItemRequest);\n        LOGGER.debug(\"Service added with result [{}]\", putItemResult);\n    }"}, {"instruction": "Set the list of search domains of the resolver.\n\n@param searchDomains the search domains\n@return {@code this}", "input": "Java", "output": "public DnsNameResolverBuilder searchDomains(Iterable<String> searchDomains) {\n        checkNotNull(searchDomains, \"searchDomains\");\n\n        final List<String> list = new ArrayList<String>(4);\n\n        for (String f : searchDomains) {\n            if (f == null) {\n                break;\n            }\n\n            // Avoid duplicate entries.\n            if (list.contains(f)) {\n                continue;\n            }\n\n            list.add(f);\n        }\n\n        this.searchDomains = list.toArray(new String[0]);\n        return this;\n    }"}, {"instruction": "This private field in the superclass needs to be reset so that we can continue reporting leaks even\nif they're duplicates. This is ugly but ideally should not be called frequently (or at all).", "input": "Java", "output": "private void resetReportedLeaks() {\n        try {\n            Field reportedLeaks = ResourceLeakDetector.class.getDeclaredField(\"reportedLeaks\");\n            reportedLeaks.setAccessible(true);\n            Object f = reportedLeaks.get(this);\n            if (f instanceof Map) {\n                ((Map) f).clear();\n            }\n        }\n        catch (Throwable t) {\n            // do nothing\n        }\n    }"}, {"instruction": "Update references to a renamed job in the fingerprint", "input": "Java", "output": "public synchronized void rename(String oldName, String newName) throws IOException {\n        boolean touched = false;\n        if (original != null) {\n            if (original.getName().equals(oldName)) {\n                original.setName(newName);\n                touched = true;\n            }\n        }\n        \n        if (usages != null) {\n            RangeSet r = usages.get(oldName);\n            if (r != null) {\n                usages.put(newName, r);\n                usages.remove(oldName);\n                touched = true;\n            }\n        }\n        \n        if (touched) {\n            save();\n        }\n    }"}, {"instruction": "Converts a map of class elements to type arguments.\n@param typeArguments The type arguments\n@return The type arguments", "input": "Java", "output": "@NotNull\n    protected Map<String, Object> toTypeArguments(@NotNull Map<String, ClassElement> typeArguments) {\n        final LinkedHashMap<String, Object> map = new LinkedHashMap<>(typeArguments.size());\n        for (Map.Entry<String, ClassElement> entry : typeArguments.entrySet()) {\n            final ClassElement ce = entry.getValue();\n            final Map<String, ClassElement> subArgs = ce.getTypeArguments();\n            if (CollectionUtils.isNotEmpty(subArgs)) {\n                map.put(entry.getKey(), toTypeArguments(subArgs));\n            } else {\n                final Type typeReference = getTypeForElement(ce);\n                map.put(entry.getKey(), typeReference);\n            }\n        }\n\n        return map;\n    }"}, {"instruction": "Called from RequestVariable.shutdown() to unschedule the task.", "input": "Java", "output": "public void shutdown() {\n        RequestBatch<BatchReturnType, ResponseType, RequestArgumentType> currentBatch = batch.getAndSet(null);\n        if (currentBatch != null) {\n            currentBatch.shutdown();\n        }\n\n        if (timerListenerReference.get() != null) {\n            // if the timer was started we'll clear it so it stops ticking\n            timerListenerReference.get().clear();\n        }\n    }"}, {"instruction": "Executes one instance of the task, or queues it up at most once should the task be currently running.", "input": "Java", "output": "void runAsync() {\n        // Determine if a task is running. If so, record the fact we want to have it run again, otherwise reserve our spot.\n        synchronized (this) {\n            Exceptions.checkNotClosed(this.closed, this);\n            if (this.running) {\n                this.runAgain = true;\n                return;\n            }\n\n            this.running = true;\n        }\n\n        // Execute the task.\n        runInternal();\n    }"}, {"instruction": "Add the given stream element queue entry to the operator's stream element queue. This\noperation blocks until the element has been added.\n\n<p>For that it tries to put the element into the queue and if not successful then it waits on\nthe checkpointing lock. The checkpointing lock is also used by the {@link Emitter} to output\nelements. The emitter is also responsible for notifying this method if the queue has capacity\nleft again, by calling notifyAll on the checkpointing lock.\n\n@param streamElementQueueEntry to add to the operator's queue\n@param <T> Type of the stream element queue entry's result\n@throws InterruptedException if the current thread has been interrupted", "input": "Java", "output": "private <T> void addAsyncBufferEntry(StreamElementQueueEntry<T> streamElementQueueEntry) throws InterruptedException {\n\t\tassert(Thread.holdsLock(checkpointingLock));\n\n\t\tpendingStreamElementQueueEntry = streamElementQueueEntry;\n\n\t\twhile (!queue.tryPut(streamElementQueueEntry)) {\n\t\t\t// we wait for the emitter to notify us if the queue has space left again\n\t\t\tcheckpointingLock.wait();\n\t\t}\n\n\t\tpendingStreamElementQueueEntry = null;\n\t}"}, {"instruction": "Gets attribute merger.\n\n@param mergingPolicy the merging policy\n@return the attribute merger", "input": "Java", "output": "public static IAttributeMerger getAttributeMerger(final String mergingPolicy) {\n        switch (mergingPolicy.toLowerCase()) {\n            case \"multivalued\":\n            case \"multi_valued\":\n            case \"combine\":\n                return new MultivaluedAttributeMerger();\n            case \"add\":\n                return new NoncollidingAttributeAdder();\n            case \"replace\":\n            case \"overwrite\":\n            case \"override\":\n                return new ReplacingAttributeAdder();\n            default:\n                return new BaseAdditiveAttributeMerger() {\n                    @Override\n                    protected Map<String, List<Object>> mergePersonAttributes(final Map<String, List<Object>> toModify,\n                                                                              final Map<String, List<Object>> toConsider) {\n                        return new LinkedHashMap<>(toModify);\n                    }\n                };\n        }\n    }"}, {"instruction": "-------------------------------------------------------------------------------", "input": "Java", "output": "public static <K, N> InternalTimersSnapshotReader<K, N> getReaderForVersion(\n\t\tint version, ClassLoader userCodeClassLoader) {\n\n\t\tswitch (version) {\n\t\t\tcase NO_VERSION:\n\t\t\t\treturn new InternalTimersSnapshotReaderPreVersioned<>(userCodeClassLoader);\n\n\t\t\tcase 1:\n\t\t\t\treturn new InternalTimersSnapshotReaderV1<>(userCodeClassLoader);\n\n\t\t\tcase InternalTimerServiceSerializationProxy.VERSION:\n\t\t\t\treturn new InternalTimersSnapshotReaderV2<>(userCodeClassLoader);\n\n\t\t\tdefault:\n\t\t\t\t// guard for future\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Unrecognized internal timers snapshot writer version: \" + version);\n\t\t}\n\t}"}, {"instruction": "Extract the OAuth bearer token from a header.\n\n@param request The request.\n@return The token, or null if no OAuth authorization header was supplied.", "input": "Java", "output": "protected String extractHeaderToken(HttpServletRequest request) {\n\t\tEnumeration<String> headers = request.getHeaders(\"Authorization\");\n\t\twhile (headers.hasMoreElements()) { // typically there is only one (most servers enforce that)\n\t\t\tString value = headers.nextElement();\n\t\t\tif ((value.toLowerCase().startsWith(OAuth2AccessToken.BEARER_TYPE.toLowerCase()))) {\n\t\t\t\tString authHeaderValue = value.substring(OAuth2AccessToken.BEARER_TYPE.length()).trim();\n\t\t\t\t// Add this here for the auth details later. Would be better to change the signature of this method.\n\t\t\t\trequest.setAttribute(OAuth2AuthenticationDetails.ACCESS_TOKEN_TYPE,\n\t\t\t\t\t\tvalue.substring(0, OAuth2AccessToken.BEARER_TYPE.length()).trim());\n\t\t\t\tint commaIndex = authHeaderValue.indexOf(',');\n\t\t\t\tif (commaIndex > 0) {\n\t\t\t\t\tauthHeaderValue = authHeaderValue.substring(0, commaIndex);\n\t\t\t\t}\n\t\t\t\treturn authHeaderValue;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"}, {"instruction": "Translates to an \"expression\" type leaf filter. Used as a fallback if we can't use a simple leaf filter.", "input": "Java", "output": "@Nullable\n  private static DimFilter toExpressionLeafFilter(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final RexNode rexNode\n  )\n  {\n    final DruidExpression druidExpression = toDruidExpression(plannerContext, rowSignature, rexNode);\n    return druidExpression != null\n           ? new ExpressionDimFilter(druidExpression.getExpression(), plannerContext.getExprMacroTable())\n           : null;\n  }"}, {"instruction": "\u63d2\u5165\u6570\u636e<br>\n\u6b64\u65b9\u6cd5\u4e0d\u4f1a\u5173\u95edConnection\n@param conn \u6570\u636e\u5e93\u8fde\u63a5\n@param record \u8bb0\u5f55\n@return \u4e3b\u952e\u5217\u8868\n@throws SQLException SQL\u6267\u884c\u5f02\u5e38", "input": "Java", "output": "public List<Object> insertForGeneratedKeys(Connection conn, Entity record) throws SQLException {\r\n\t\tcheckConn(conn);\r\n\t\tif(CollectionUtil.isEmpty(record)){\r\n\t\t\tthrow new SQLException(\"Empty entity provided!\");\r\n\t\t}\r\n\t\t\r\n\t\tPreparedStatement ps = null;\r\n\t\ttry {\r\n\t\t\tps = dialect.psForInsert(conn, record);\r\n\t\t\tps.executeUpdate();\r\n\t\t\treturn StatementUtil.getGeneratedKeys(ps);\r\n\t\t} catch (SQLException e) {\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\tDbUtil.close(ps);\r\n\t\t}\r\n\t}"}, {"instruction": "Create a node.\n\n@param path\n@param data\n@param mode\n@return create node's path\n@throws ZkInterruptedException if operation was interrupted, or a required reconnection got interrupted\n@throws IllegalArgumentException if called from anything except the ZooKeeper event thread\n@throws ZkException if any ZooKeeper exception occurred\n@throws RuntimeException if any other exception occurs", "input": "Java", "output": "public String create(final String path, Object data, final CreateMode mode) throws ZkInterruptedException,\n                                                                               IllegalArgumentException, ZkException,\n                                                                               RuntimeException {\n        if (path == null) {\n            throw new NullPointerException(\"path must not be null.\");\n        }\n        final byte[] bytes = data == null ? null : serialize(data);\n\n        return retryUntilConnected(new Callable<String>() {\n\n            @Override\n            public String call() throws Exception {\n                return _connection.create(path, bytes, mode);\n            }\n        });\n    }"}, {"instruction": "This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.", "input": "Java", "output": "private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(\n\t\tList<StateMetaInfoSnapshot> stateMetaInfoSnapshots,\n\t\tboolean registerTtlCompactFilter) {\n\n\t\tList<ColumnFamilyDescriptor> columnFamilyDescriptors =\n\t\t\tnew ArrayList<>(stateMetaInfoSnapshots.size());\n\n\t\tfor (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {\n\t\t\tRegisteredStateMetaInfoBase metaInfoBase =\n\t\t\t\tRegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot);\n\t\t\tColumnFamilyDescriptor columnFamilyDescriptor = RocksDBOperationUtils.createColumnFamilyDescriptor(\n\t\t\t\tmetaInfoBase, columnFamilyOptionsFactory, registerTtlCompactFilter ? ttlCompactFiltersManager : null);\n\t\t\tcolumnFamilyDescriptors.add(columnFamilyDescriptor);\n\t\t}\n\t\treturn columnFamilyDescriptors;\n\t}"}, {"instruction": "Static factory method: to be used when a new execution is created for the very first time/\nCalling this will make sure no extra db fetches are needed later on, as all collections\nwill be populated with empty collections. If they would be null, it would trigger\na database fetch for those relationship entities.", "input": "Java", "output": "public static ExecutionEntityImpl createWithEmptyRelationshipCollections() {\n    ExecutionEntityImpl execution = new ExecutionEntityImpl();\n    execution.executions = new ArrayList<ExecutionEntityImpl>(1);\n    execution.tasks = new ArrayList<TaskEntity>(1);\n    execution.variableInstances = new HashMap<String, VariableInstanceEntity>(1);\n    execution.jobs = new ArrayList<JobEntity>(1);\n    execution.timerJobs = new ArrayList<TimerJobEntity>(1);\n    execution.eventSubscriptions = new ArrayList<EventSubscriptionEntity>(1);\n    execution.identityLinks = new ArrayList<IdentityLinkEntity>(1);\n    return execution;\n  }"}, {"instruction": "true if {@link AbstractBuild#hasParticipant} or {@link hudson.model.Cause.UserIdCause}", "input": "Java", "output": "private boolean relatedTo(@Nonnull AbstractBuild<?, ?> b) {\n        if (b.hasParticipant(this)) {\n            return true;\n        }\n        for (Cause cause : b.getCauses()) {\n            if (cause instanceof Cause.UserIdCause) {\n                String userId = ((Cause.UserIdCause) cause).getUserId();\n                if (userId != null && idStrategy().equals(userId, getId())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }"}, {"instruction": "Sets the access control policy on the specified resource. Replaces any existing policy.\n\n<p>Sample code:\n\n<pre><code>\ntry (InstanceTemplateClient instanceTemplateClient = InstanceTemplateClient.create()) {\nProjectGlobalInstanceTemplateResourceName resource = ProjectGlobalInstanceTemplateResourceName.of(\"[PROJECT]\", \"[RESOURCE]\");\nGlobalSetPolicyRequest globalSetPolicyRequestResource = GlobalSetPolicyRequest.newBuilder().build();\nPolicy response = instanceTemplateClient.setIamPolicyInstanceTemplate(resource, globalSetPolicyRequestResource);\n}\n</code></pre>\n\n@param resource Name or id of the resource for this request.\n@param globalSetPolicyRequestResource\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Policy setIamPolicyInstanceTemplate(\n      ProjectGlobalInstanceTemplateResourceName resource,\n      GlobalSetPolicyRequest globalSetPolicyRequestResource) {\n\n    SetIamPolicyInstanceTemplateHttpRequest request =\n        SetIamPolicyInstanceTemplateHttpRequest.newBuilder()\n            .setResource(resource == null ? null : resource.toString())\n            .setGlobalSetPolicyRequestResource(globalSetPolicyRequestResource)\n            .build();\n    return setIamPolicyInstanceTemplate(request);\n  }"}, {"instruction": "Recursively retrieve files that match the given pattern,\nadding them to the given result list.\n\n@param fullPattern the pattern to match against,\nwith prepended root directory path\n@param dir         the current directory\n@param result      the Set of matching File instances to add to\n@throws IOException if directory contents could not be retrieved", "input": "Java", "output": "protected void doRetrieveMatchingFiles(String fullPattern, File dir, Set<File> result) throws IOException {\n        File[] dirContents = dir.listFiles();\n        if (dirContents == null) {\n            return;\n        }\n        for (File content : dirContents) {\n            String currPath = content.getAbsolutePath().replace(File.separator, \"/\");\n            if (content.isDirectory() && getPathMatcher().matchStart(fullPattern, currPath + \"/\")) {\n                if (content.canRead()) {\n                    doRetrieveMatchingFiles(fullPattern, content, result);\n                }\n            }\n            if (getPathMatcher().match(fullPattern, currPath)) {\n                result.add(content);\n            }\n        }\n    }"}, {"instruction": "Checks whether the given directory exists and is writable. If it doesn't exist, this method\nwill attempt to create it.\n\n@param uploadDir directory to check\n@param log logger used for logging output\n@throws IOException if the directory does not exist and cannot be created, or if the\ndirectory isn't writable", "input": "Java", "output": "private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {\n\t\tif (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {\n\t\t\tlog.info(\"Using directory {} for file uploads.\", uploadDir);\n\t\t} else if (Files.isWritable(Files.createDirectories(uploadDir))) {\n\t\t\tlog.info(\"Created directory {} for file uploads.\", uploadDir);\n\t\t} else {\n\t\t\tlog.warn(\"Upload directory {} cannot be created or is not writable.\", uploadDir);\n\t\t\tthrow new IOException(\n\t\t\t\tString.format(\"Upload directory %s cannot be created or is not writable.\",\n\t\t\t\t\tuploadDir));\n\t\t}\n\t}"}, {"instruction": "Reads from a data input view a {@link TypeSerializerSnapshot} that was previously\nwritten using {@link TypeSerializerSnapshotSerializationUtil#writeSerializerSnapshot(DataOutputView, TypeSerializerSnapshot, TypeSerializer)}.\n\n@param in the data input view\n@param userCodeClassLoader the user code class loader to use\n@param existingPriorSerializer the prior serializer. This would only be non-null if we are\nrestoring from a snapshot taken with Flink version <= 1.6.\n\n@return the read serializer configuration snapshot", "input": "Java", "output": "public static <T> TypeSerializerSnapshot<T> readSerializerSnapshot(\n\t\t\tDataInputView in,\n\t\t\tClassLoader userCodeClassLoader,\n\t\t\t@Nullable TypeSerializer<T> existingPriorSerializer) throws IOException {\n\n\t\tfinal TypeSerializerSnapshotSerializationProxy<T> proxy =\n\t\t\tnew TypeSerializerSnapshotSerializationProxy<>(userCodeClassLoader, existingPriorSerializer);\n\t\tproxy.read(in);\n\n\t\treturn proxy.getSerializerSnapshot();\n\t}"}, {"instruction": "This method tracks op calls\n\n@param op", "input": "Java", "output": "public void processOpCall(CustomOp op) {\n        // total number of invocations\n        invocationsCount.incrementAndGet();\n\n        // number of invocations for this specific op\n        opCounter.incrementCount(op.opName());\n\n        // number of invocations for specific class\n        String opClass = getOpClass(op);\n        classCounter.incrementCount(opClass);\n\n\n        lastZ = 0;\n        prevOpMatching = opClass;\n        prevOpMatchingDetailed = opClass + \" \" + op.opName();\n        prevOpMatchingInverted = opClass + \" \" + op.opName();\n\n        updatePairs(op.opName(), opClass);\n\n        // TODO: to be implemented\n        //for (OpProfilerListener listener : listeners) {\n        //  listener.invoke(op);\n        //}\n    }"}, {"instruction": "Picks up a {@link RepositoryBrowser} that matches the\ngiven {@link SCM} from existing other jobs.\n\n@return\nnull if no applicable configuration was found.", "input": "Java", "output": "private RepositoryBrowser infer() {\n        for( AbstractProject p : Jenkins.getInstance().allItems(AbstractProject.class) ) {\n            SCM scm = p.getScm();\n            if (scm!=null && scm.getClass()==owner.getClass() && scm.getBrowser()!=null &&\n                    ((SCMDescriptor)scm.getDescriptor()).isBrowserReusable(scm,owner)) {\n                return scm.getBrowser();\n            }\n        }\n        return null;\n    }"}, {"instruction": "Handle asynchronous {@link Runnable}. This method simply executes the given {@link Runnable}\nin the context of the actor thread.\n\n@param runAsync Run async message", "input": "Java", "output": "private void handleRunAsync(RunAsync runAsync) {\n\t\tfinal long timeToRun = runAsync.getTimeNanos();\n\t\tfinal long delayNanos;\n\n\t\tif (timeToRun == 0 || (delayNanos = timeToRun - System.nanoTime()) <= 0) {\n\t\t\t// run immediately\n\t\t\ttry {\n\t\t\t\trunAsync.getRunnable().run();\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlog.error(\"Caught exception while executing runnable in main thread.\", t);\n\t\t\t\tExceptionUtils.rethrowIfFatalErrorOrOOM(t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// schedule for later. send a new message after the delay, which will then be immediately executed\n\t\t\tFiniteDuration delay = new FiniteDuration(delayNanos, TimeUnit.NANOSECONDS);\n\t\t\tRunAsync message = new RunAsync(runAsync.getRunnable(), timeToRun);\n\n\t\t\tfinal Object envelopedSelfMessage = envelopeSelfMessage(message);\n\n\t\t\tgetContext().system().scheduler().scheduleOnce(delay, getSelf(), envelopedSelfMessage,\n\t\t\t\t\tgetContext().dispatcher(), ActorRef.noSender());\n\t\t}\n\t}"}, {"instruction": "calc the gradient based on the n-step rewards", "input": "Java", "output": "public Gradient[] calcGradient(IDQN current, Stack<MiniTrans<Integer>> rewards) {\n\n        MiniTrans<Integer> minTrans = rewards.pop();\n\n        int size = rewards.size();\n\n        int[] shape = getHistoryProcessor() == null ? mdp.getObservationSpace().getShape()\n                        : getHistoryProcessor().getConf().getShape();\n        int[] nshape = Learning.makeShape(size, shape);\n        INDArray input = Nd4j.create(nshape);\n        INDArray targets = Nd4j.create(size, mdp.getActionSpace().getSize());\n\n        double r = minTrans.getReward();\n        for (int i = size - 1; i >= 0; i--) {\n            minTrans = rewards.pop();\n\n            r = minTrans.getReward() + conf.getGamma() * r;\n            input.putRow(i, minTrans.getObs());\n            INDArray row = minTrans.getOutput()[0];\n            row = row.putScalar(minTrans.getAction(), r);\n            targets.putRow(i, row);\n        }\n\n        return current.gradient(input, targets);\n    }"}, {"instruction": "Updates the task execution state for a given task.\n\n@param taskExecutionState New task execution state for a given task\n@return Acknowledge the task execution state update", "input": "Java", "output": "@Override\n\tpublic CompletableFuture<Acknowledge> updateTaskExecutionState(\n\t\t\tfinal TaskExecutionState taskExecutionState) {\n\t\tcheckNotNull(taskExecutionState, \"taskExecutionState\");\n\n\t\tif (executionGraph.updateState(taskExecutionState)) {\n\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n\t\t} else {\n\t\t\treturn FutureUtils.completedExceptionally(\n\t\t\t\tnew ExecutionGraphException(\"The execution attempt \" +\n\t\t\t\t\ttaskExecutionState.getID() + \" was not found.\"));\n\t\t}\n\t}"}, {"instruction": "Save this samediff instance as a zip file\nwith the training configuration\n@param trainingConfig the training configuration to save\n@param outputStream the output stream to write to\n@throws IOException", "input": "Java", "output": "public void saveWithTrainingConfig(TrainingConfig trainingConfig,OutputStream outputStream) throws  IOException {\n        ObjectMapper objectMapper = ObjectMapperHolder.getJsonMapper();\n        String configJson = objectMapper.writeValueAsString(trainingConfig);\n        ZipOutputStream zipfile = new ZipOutputStream(new CloseShieldOutputStream(outputStream));\n        ZipEntry config = new ZipEntry(TRAINING_CONFIG_JSON_ZIP_ENTRY_NAME);\n        zipfile.putNextEntry(config);\n        zipfile.write(configJson.getBytes());\n\n        ZipEntry sameDiff = new ZipEntry(SAMEDIFF_FILE_ENTRY_NAME);\n        zipfile.putNextEntry(sameDiff);\n\n        val fb = asFlatBuffers();\n        val offset = fb.position();\n\n        val array = fb.array();\n\n        try (BufferedOutputStream zipFileOutputStream = new BufferedOutputStream(zipfile);\n             val dos = new DataOutputStream(zipFileOutputStream)) {\n            dos.write(array, offset, array.length - offset);\n        }\n    }"}, {"instruction": "Executes the webflow action.\n\n@param context the context\n@return the event", "input": "Java", "output": "@Override\n    protected Event doExecute(final RequestContext context) {\n        try {\n            val request = WebUtils.getHttpServletRequestFromExternalWebflowContext(context);\n            val wa = request.getParameter(WA);\n            if (StringUtils.isNotBlank(wa) && wa.equalsIgnoreCase(WSIGNIN)) {\n                wsFederationResponseValidator.validateWsFederationAuthenticationRequest(context);\n                return super.doExecute(context);\n            }\n            return wsFederationRequestBuilder.buildAuthenticationRequestEvent(context);\n        } catch (final Exception ex) {\n            LOGGER.error(ex.getMessage(), ex);\n            throw new UnauthorizedServiceException(UnauthorizedServiceException.CODE_UNAUTHZ_SERVICE, ex.getMessage());\n        }\n    }"}, {"instruction": "Validate.\n\n@param profile the profile", "input": "Java", "output": "@JsonIgnore\n    public void validate(final CommonProfile profile) {\n        if (StringUtils.isBlank(getClientId())) {\n            throw new InvalidResourceSetException(HttpStatus.BAD_REQUEST.value(), \"Authentication request does contain a client id\");\n        }\n\n        if (getScopes().isEmpty()) {\n            throw new InvalidResourceSetException(HttpStatus.BAD_REQUEST.value(), \"Resource set registration is missing scopes\");\n        }\n\n        if (!getOwner().equals(profile.getId())) {\n            throw new InvalidResourceSetException(HttpStatus.FORBIDDEN.value(), \"Resource-set owner does not match the authenticated profile\");\n        }\n    }"}, {"instruction": "Locate the vertices and the codewords area of a black blob using the Start\nand Stop patterns as locators.\n\n@param matrix the scanned barcode image.\n@return an array containing the vertices:\nvertices[0] x, y top left barcode\nvertices[1] x, y bottom left barcode\nvertices[2] x, y top right barcode\nvertices[3] x, y bottom right barcode\nvertices[4] x, y top left codeword area\nvertices[5] x, y bottom left codeword area\nvertices[6] x, y top right codeword area\nvertices[7] x, y bottom right codeword area", "input": "Java", "output": "private static ResultPoint[] findVertices(BitMatrix matrix, int startRow, int startColumn) {\n    int height = matrix.getHeight();\n    int width = matrix.getWidth();\n\n    ResultPoint[] result = new ResultPoint[8];\n    copyToResult(result, findRowsWithPattern(matrix, height, width, startRow, startColumn, START_PATTERN),\n        INDEXES_START_PATTERN);\n\n    if (result[4] != null) {\n      startColumn = (int) result[4].getX();\n      startRow = (int) result[4].getY();\n    }\n    copyToResult(result, findRowsWithPattern(matrix, height, width, startRow, startColumn, STOP_PATTERN),\n        INDEXES_STOP_PATTERN);\n    return result;\n  }"}, {"instruction": "Cancel Hadoop Tokens\n\n@param logger logger handler", "input": "Java", "output": "public void cancelHadoopTokens(final Logger logger) {\n    if (tokenFile == null) {\n      return;\n    }\n    try {\n      hadoopSecurityManager.cancelTokens(tokenFile, userToProxy, logger);\n    } catch (HadoopSecurityManagerException e) {\n      logger.error(e.getCause() + e.getMessage());\n    } catch (Exception e) {\n      logger.error(e.getCause() + e.getMessage());\n    }\n    if (tokenFile.exists()) {\n      tokenFile.delete();\n    }\n  }"}, {"instruction": "/* Helper method to fetch flow priority from flow props", "input": "Java", "output": "private int getPriority(final ExecutableFlow exflow) {\n    final ExecutionOptions options = exflow.getExecutionOptions();\n    int priority = ExecutionOptions.DEFAULT_FLOW_PRIORITY;\n    if (options != null\n        && options.getFlowParameters() != null\n        && options.getFlowParameters()\n        .containsKey(ExecutionOptions.FLOW_PRIORITY)) {\n      try {\n        priority =\n            Integer.valueOf(options.getFlowParameters().get(\n                ExecutionOptions.FLOW_PRIORITY));\n      } catch (final NumberFormatException ex) {\n        priority = ExecutionOptions.DEFAULT_FLOW_PRIORITY;\n        logger.error(\n            \"Failed to parse flow priority for exec_id = \"\n                + exflow.getExecutionId(), ex);\n      }\n    }\n    return priority;\n  }"}, {"instruction": "\u662f\u5426\u4e3a\u65e5\u671f\u683c\u5f0f<br>\n\u5224\u65ad\u65b9\u5f0f\uff1a\n\n<pre>\n1\u3001\u6307\u5b9a\u5e8f\u53f7\n2\u3001org.apache.poi.ss.usermodel.DateUtil.isADateFormat\u65b9\u6cd5\u5224\u5b9a\n</pre>\n\n@param cell \u5355\u5143\u683c\n@param formatIndex \u683c\u5f0f\u5e8f\u53f7\n@return \u662f\u5426\u4e3a\u65e5\u671f\u683c\u5f0f", "input": "Java", "output": "private static boolean isDateType(Cell cell, int formatIndex) {\r\n\t\t// yyyy-MM-dd----- 14\r\n\t\t// yyyy\u5e74m\u6708d\u65e5---- 31\r\n\t\t// yyyy\u5e74m\u6708------- 57\r\n\t\t// m\u6708d\u65e5 ---------- 58\r\n\t\t// HH:mm----------- 20\r\n\t\t// h\u65f6mm\u5206 -------- 32\r\n\t\tif (formatIndex == 14 || formatIndex == 31 || formatIndex == 57 || formatIndex == 58 || formatIndex == 20 || formatIndex == 32) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (org.apache.poi.ss.usermodel.DateUtil.isCellDateFormatted(cell)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}"}, {"instruction": "\u83b7\u5f97\u7ed3\u679c\u96c6\u7684\u6240\u6709\u5217\u540d\n\n@param rs \u7ed3\u679c\u96c6\n@return \u5217\u540d\u6570\u7ec4\n@throws DbRuntimeException SQL\u6267\u884c\u5f02\u5e38", "input": "Java", "output": "public static String[] getColumnNames(ResultSet rs) throws DbRuntimeException {\r\n\t\ttry {\r\n\t\t\tResultSetMetaData rsmd = rs.getMetaData();\r\n\t\t\tint columnCount = rsmd.getColumnCount();\r\n\t\t\tString[] labelNames = new String[columnCount];\r\n\t\t\tfor (int i = 0; i < labelNames.length; i++) {\r\n\t\t\t\tlabelNames[i] = rsmd.getColumnLabel(i + 1);\r\n\t\t\t}\r\n\t\t\treturn labelNames;\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new DbRuntimeException(\"Get colunms error!\", e);\r\n\t\t}\r\n\t}"}, {"instruction": "Create Unicode code points from a String.\n\n@param s\na String to convert to an Unicode code point array\n\n@return the corresponding array of integers representing Unicode code\npoints", "input": "Java", "output": "public static int[] stringToCodePoints(final String s) {\n        final int m = s.codePointCount(0, s.length());\n        final int[] codePoints = new int[m];\n        int j = 0;\n        for (int offset = 0; offset < s.length();) {\n            final int codepoint = s.codePointAt(offset);\n            codePoints[j++] = codepoint;\n            offset += Character.charCount(codepoint);\n        }\n        return codePoints;\n    }"}, {"instruction": "\u83b7\u53d6\u96c6\u5408\u4e2d\u6307\u5b9a\u591a\u4e2a\u4e0b\u6807\u7684\u5143\u7d20\u503c\uff0c\u4e0b\u6807\u53ef\u4ee5\u4e3a\u8d1f\u6570\uff0c\u4f8b\u5982-1\u8868\u793a\u6700\u540e\u4e00\u4e2a\u5143\u7d20\n\n@param <T> \u5143\u7d20\u7c7b\u578b\n@param collection \u96c6\u5408\n@param indexes \u4e0b\u6807\uff0c\u652f\u6301\u8d1f\u6570\n@return \u5143\u7d20\u503c\u5217\u8868\n@since 4.0.6", "input": "Java", "output": "@SuppressWarnings(\"unchecked\")\r\n\tpublic static <T> List<T> getAny(Collection<T> collection, int... indexes) {\r\n\t\tfinal int size = collection.size();\r\n\t\tfinal ArrayList<T> result = new ArrayList<>();\r\n\t\tif (collection instanceof List) {\r\n\t\t\tfinal List<T> list = ((List<T>) collection);\r\n\t\t\tfor (int index : indexes) {\r\n\t\t\t\tif (index < 0) {\r\n\t\t\t\t\tindex += size;\r\n\t\t\t\t}\r\n\t\t\t\tresult.add(list.get(index));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tObject[] array = ((Collection<T>) collection).toArray();\r\n\t\t\tfor (int index : indexes) {\r\n\t\t\t\tif (index < 0) {\r\n\t\t\t\t\tindex += size;\r\n\t\t\t\t}\r\n\t\t\t\tresult.add((T) array[index]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}"}, {"instruction": "fill the result set with the remaining flow capacity .\n\n@param stats reference to the result container which contains all the results, this specific\nmethod will only work on the property \"remainingFlowCapacity\".", "input": "Java", "output": "protected void fillRemainingFlowCapacityAndLastDispatchedTime(final ExecutorInfo stats) {\n\n    final AzkabanExecutorServer server = AzkabanExecutorServer.getApp();\n    if (server != null) {\n      final FlowRunnerManager runnerMgr = AzkabanExecutorServer.getApp().getFlowRunnerManager();\n      final int assignedFlows = runnerMgr.getNumRunningFlows() + runnerMgr.getNumQueuedFlows();\n      stats.setRemainingFlowCapacity(runnerMgr.getMaxNumRunningFlows() - assignedFlows);\n      stats.setNumberOfAssignedFlows(assignedFlows);\n      stats.setLastDispatchedTime(runnerMgr.getLastFlowSubmittedTime());\n    } else {\n      logger.error(\"failed to get data for remaining flow capacity or LastDispatchedTime\"\n          + \" as the AzkabanExecutorServer has yet been initialized.\");\n    }\n  }"}, {"instruction": "Create a RPC service for the task manager.\n\n@param configuration The configuration for the TaskManager.\n@param haServices to use for the task manager hostname retrieval", "input": "Java", "output": "public static RpcService createRpcService(\n\t\t\tfinal Configuration configuration,\n\t\t\tfinal HighAvailabilityServices haServices) throws Exception {\n\n\t\tcheckNotNull(configuration);\n\t\tcheckNotNull(haServices);\n\n\t\tfinal String taskManagerAddress = determineTaskManagerBindAddress(configuration, haServices);\n\t\tfinal String portRangeDefinition = configuration.getString(TaskManagerOptions.RPC_PORT);\n\n\t\treturn AkkaRpcServiceUtils.createRpcService(taskManagerAddress, portRangeDefinition, configuration);\n\t}"}, {"instruction": "Gets authenticated profile.\n\n@param request            the request\n@param response           the response\n@param requiredPermission the required permission\n@return the authenticated profile", "input": "Java", "output": "protected CommonProfile getAuthenticatedProfile(final HttpServletRequest request,\n                                                    final HttpServletResponse response,\n                                                    final String requiredPermission) {\n        val context = new J2EContext(request, response, getUmaConfigurationContext().getSessionStore());\n        val manager = new ProfileManager<>(context, context.getSessionStore());\n        val profile = manager.get(true).orElse(null);\n        if (profile == null) {\n            throw new AuthenticationException(\"Unable to locate authenticated profile\");\n        }\n        if (!profile.getPermissions().contains(requiredPermission)) {\n            throw new AuthenticationException(\"Authenticated profile does not carry the UMA protection scope\");\n        }\n        return profile;\n    }"}, {"instruction": "Return next fix length string from buffer.", "input": "Java", "output": "public final String getFixString(final int len, String charsetName) {\r\n        if (position + len > origin + limit) throw new IllegalArgumentException(\"limit excceed: \"\r\n                                                                                + (position + len - origin));\r\n\r\n        final int from = position;\r\n        final int end = from + len;\r\n        byte[] buf = buffer;\r\n        int found = from;\r\n        for (; (found < end) && buf[found] != '\\0'; found++)\r\n            /* empty loop */;\r\n\r\n        try {\r\n            String string = new String(buf, from, found - from, charsetName);\r\n            position += len;\r\n            return string;\r\n        } catch (UnsupportedEncodingException e) {\r\n            throw new IllegalArgumentException(\"Unsupported encoding: \" + charsetName, e);\r\n        }\r\n    }"}, {"instruction": "Identifying certificate for this host. {@code keyCertChainInputStream} and {@code keyInputStream} may\nbe {@code null} for client contexts, which disables mutual authentication.\n\n@param keyCertChainInputStream an input stream for an X.509 certificate chain in PEM format\n@param keyInputStream an input stream for a PKCS#8 private key in PEM format\n@param keyPassword the password of the {@code keyInputStream}, or {@code null} if it's not\npassword-protected", "input": "Java", "output": "public SslContextBuilder keyManager(InputStream keyCertChainInputStream, InputStream keyInputStream,\n            String keyPassword) {\n        X509Certificate[] keyCertChain;\n        PrivateKey key;\n        try {\n            keyCertChain = SslContext.toX509Certificates(keyCertChainInputStream);\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Input stream not contain valid certificates.\", e);\n        }\n        try {\n            key = SslContext.toPrivateKey(keyInputStream, keyPassword);\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Input stream does not contain valid private key.\", e);\n        }\n        return keyManager(key, keyPassword, keyCertChain);\n    }"}, {"instruction": "Returns the number of registers that are no longer zero after the value was added\n\n@param position   The position into the byte buffer, this position represents two \"registers\"\n@param offsetDiff The difference in offset between the byteToAdd and the current HyperLogLogCollector\n@param byteToAdd  The byte to merge into the current HyperLogLogCollector", "input": "Java", "output": "private static short mergeAndStoreByteRegister(\n      final ByteBuffer storageBuffer,\n      final int position,\n      final int offsetDiff,\n      final byte byteToAdd\n  )\n  {\n    if (byteToAdd == 0) {\n      return 0;\n    }\n\n    final byte currVal = storageBuffer.get(position);\n\n    final int upperNibble = currVal & 0xf0;\n    final int lowerNibble = currVal & 0x0f;\n\n    // subtract the differences so that the nibbles align\n    final int otherUpper = (byteToAdd & 0xf0) - (offsetDiff << bitsPerBucket);\n    final int otherLower = (byteToAdd & 0x0f) - offsetDiff;\n\n    final int newUpper = Math.max(upperNibble, otherUpper);\n    final int newLower = Math.max(lowerNibble, otherLower);\n\n    storageBuffer.put(position, (byte) ((newUpper | newLower) & 0xff));\n\n    short numNoLongerZero = 0;\n    if (upperNibble == 0 && newUpper > 0) {\n      ++numNoLongerZero;\n    }\n    if (lowerNibble == 0 && newLower > 0) {\n      ++numNoLongerZero;\n    }\n\n    return numNoLongerZero;\n  }"}, {"instruction": "Return an array of the underlying storage from {@code buf} into a byte array.\nThe copy will start at {@code start} and copy {@code length} bytes.\nIf {@code copy} is true a copy will be made of the memory.\nIf {@code copy} is false the underlying storage will be shared, if possible.", "input": "Java", "output": "public static byte[] getBytes(ByteBuf buf, int start, int length, boolean copy) {\n        int capacity = buf.capacity();\n        if (isOutOfBounds(start, length, capacity)) {\n            throw new IndexOutOfBoundsException(\"expected: \" + \"0 <= start(\" + start + \") <= start + length(\" + length\n                    + \") <= \" + \"buf.capacity(\" + capacity + ')');\n        }\n\n        if (buf.hasArray()) {\n            if (copy || start != 0 || length != capacity) {\n                int baseOffset = buf.arrayOffset() + start;\n                return Arrays.copyOfRange(buf.array(), baseOffset, baseOffset + length);\n            } else {\n                return buf.array();\n            }\n        }\n\n        byte[] v = PlatformDependent.allocateUninitializedArray(length);\n        buf.getBytes(start, v);\n        return v;\n    }"}, {"instruction": "\u6839\u636e\u7279\u5f81\u51fd\u6570\u8ba1\u7b97\u8f93\u51fa\n\n@param table\n@param current\n@return", "input": "Java", "output": "protected LinkedList<double[]> computeScoreList(Table table, int current)\n    {\n        LinkedList<double[]> scoreList = new LinkedList<double[]>();\n        for (FeatureTemplate featureTemplate : featureTemplateList)\n        {\n            char[] o = featureTemplate.generateParameter(table, current);\n            FeatureFunction featureFunction = featureFunctionTrie.get(o);\n            if (featureFunction == null) continue;\n            scoreList.add(featureFunction.w);\n        }\n\n        return scoreList;\n    }"}, {"instruction": "\u67e5\u627e\u7c7b\u4e2d\u7684\u6307\u5b9a\u53c2\u6570\u7684\u6784\u9020\u65b9\u6cd5\uff0c\u5982\u679c\u627e\u5230\u6784\u9020\u65b9\u6cd5\uff0c\u4f1a\u81ea\u52a8\u8bbe\u7f6e\u53ef\u8bbf\u95ee\u4e3atrue\n\n@param <T> \u5bf9\u8c61\u7c7b\u578b\n@param clazz \u7c7b\n@param parameterTypes \u53c2\u6570\u7c7b\u578b\uff0c\u53ea\u8981\u4efb\u4f55\u4e00\u4e2a\u53c2\u6570\u662f\u6307\u5b9a\u53c2\u6570\u7684\u7236\u7c7b\u6216\u63a5\u53e3\u6216\u76f8\u7b49\u5373\u53ef\uff0c\u6b64\u53c2\u6570\u53ef\u4ee5\u4e0d\u4f20\n@return \u6784\u9020\u65b9\u6cd5\uff0c\u5982\u679c\u672a\u627e\u5230\u8fd4\u56denull", "input": "Java", "output": "@SuppressWarnings(\"unchecked\")\r\n\tpublic static <T> Constructor<T> getConstructor(Class<T> clazz, Class<?>... parameterTypes) {\r\n\t\tif (null == clazz) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tfinal Constructor<?>[] constructors = getConstructors(clazz);\r\n\t\tClass<?>[] pts;\r\n\t\tfor (Constructor<?> constructor : constructors) {\r\n\t\t\tpts = constructor.getParameterTypes();\r\n\t\t\tif (ClassUtil.isAllAssignableFrom(pts, parameterTypes)) {\r\n\t\t\t\t// \u6784\u9020\u53ef\u8bbf\u95ee\r\n\t\t\t\tconstructor.setAccessible(true);\r\n\t\t\t\treturn (Constructor<T>) constructor;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}"}, {"instruction": "Creates a uima sentence iterator with the given path\n@param path the path to the root directory or file to read from\n@return the uima sentence iterator for the given root dir or file\n@throws Exception", "input": "Java", "output": "public static SentenceIterator createWithPath(String path) throws Exception {\n        return new UimaSentenceIterator(path,\n                        new UimaResource(AnalysisEngineFactory.createEngine(AnalysisEngineFactory\n                                        .createEngineDescription(TokenizerAnnotator.getDescription(),\n                                                        SentenceAnnotator.getDescription()))));\n    }"}, {"instruction": "Creates a ZFS file system to migrate the data to.\n\n<p>\nThis has to be done while we still have an interactive access with the user, since it involves the password.\n\n<p>\nAn exception will be thrown if the operation fails. A normal completion means a success.\n\n@return\nThe ZFS dataset name to migrate the data to.", "input": "Java", "output": "private String createZfsFileSystem(final TaskListener listener, String rootUsername, String rootPassword) throws IOException, InterruptedException, ZFSException {\n        // capture the UID that Hudson runs under\n        // so that we can allow this user to do everything on this new partition\n        final int uid = LIBC.geteuid();\n        final int gid = LIBC.getegid();\n        passwd pwd = LIBC.getpwuid(uid);\n        if(pwd==null)\n            throw new IOException(\"Failed to obtain the current user information for \"+uid);\n        final String userName = pwd.pw_name;\n\n        final File home = Jenkins.getInstance().getRootDir();\n\n        // this is the actual creation of the file system.\n        // return true indicating a success\n        return SU.execute(listener, rootUsername, rootPassword, new Create(listener, home, uid, gid, userName));\n    }"}, {"instruction": "[VARIABLE 42]", "input": "Java", "output": "public boolean deleteBlobFromStringsWithGeneration(\n      String bucketName, String blobName, long blobGeneration) {\n    // [START deleteBlobFromStringsWithGeneration]\n    boolean deleted =\n        storage.delete(bucketName, blobName, BlobSourceOption.generationMatch(blobGeneration));\n    if (deleted) {\n      // the blob was deleted\n    } else {\n      // the blob was not found\n    }\n    // [END deleteBlobFromStringsWithGeneration]\n    return deleted;\n  }"}, {"instruction": "Collects a record and emits it to all writers.", "input": "Java", "output": "@Override\n\tpublic void collect(T record)  {\n\t\tif (record != null) {\n\t\t\tthis.delegate.setInstance(record);\n\t\t\ttry {\n\t\t\t\tfor (RecordWriter<SerializationDelegate<T>> writer : writers) {\n\t\t\t\t\twriter.emit(this.delegate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"Emitting the record caused an I/O exception: \" + e.getMessage(), e);\n\t\t\t}\n\t\t\tcatch (InterruptedException e) {\n\t\t\t\tthrow new RuntimeException(\"Emitting the record was interrupted: \" + e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new NullPointerException(\"The system does not support records that are null.\"\n\t\t\t\t\t\t\t\t+ \"Null values are only supported as fields inside other objects.\");\n\t\t}\n\t}"}, {"instruction": "To use this method, {@link #objectMapper} should be a smileMapper.", "input": "Java", "output": "protected FullResponseHolder submitSmileRequest(\n      String taskId,\n      HttpMethod method,\n      String encodedPathSuffix,\n      @Nullable String encodedQueryString,\n      byte[] content,\n      boolean retry\n  ) throws IOException, ChannelException, NoTaskLocationException\n  {\n    return submitRequest(\n        taskId,\n        SmileMediaTypes.APPLICATION_JACKSON_SMILE,\n        method,\n        encodedPathSuffix,\n        encodedQueryString,\n        content,\n        retry\n    );\n  }"}, {"instruction": "Converts the given objects into a map of interned strings. See {@link String#intern()}.\n\n@param values The objects\n@return An unmodifiable set of strings\n@see CollectionUtils#mapOf(Object...)", "input": "Java", "output": "@SuppressWarnings(\"unused\")\n    public static Map<String, Object> internMapOf(Object... values) {\n        if (values == null) {\n            return Collections.emptyMap();\n        }\n        int len = values.length;\n        if (len % 2 != 0) {\n            throw new IllegalArgumentException(\"Number of arguments should be an even number representing the keys and values\");\n        }\n\n        Map<String, Object> answer = new HashMap<>((int) (len / 2 / 0.75));\n        int i = 0;\n        while (i < values.length - 1) {\n            String key = values[i++].toString().intern();\n            Object val = values[i++];\n            answer.put(key, val);\n        }\n        return answer;\n    }"}, {"instruction": "Replace deprecated configuration properties for {@link FlinkKinesisProducer}.\nThis should be remove along with deprecated keys", "input": "Java", "output": "public static Properties replaceDeprecatedProducerKeys(Properties configProps) {\n\t\t// Replace deprecated key\n\t\tif (configProps.containsKey(ProducerConfigConstants.COLLECTION_MAX_COUNT)) {\n\t\t\tconfigProps.setProperty(COLLECTION_MAX_COUNT,\n\t\t\t\t\tconfigProps.getProperty(ProducerConfigConstants.COLLECTION_MAX_COUNT));\n\t\t\tconfigProps.remove(ProducerConfigConstants.COLLECTION_MAX_COUNT);\n\t\t}\n\t\t// Replace deprecated key\n\t\tif (configProps.containsKey(ProducerConfigConstants.AGGREGATION_MAX_COUNT)) {\n\t\t\tconfigProps.setProperty(AGGREGATION_MAX_COUNT,\n\t\t\t\t\tconfigProps.getProperty(ProducerConfigConstants.AGGREGATION_MAX_COUNT));\n\t\t\tconfigProps.remove(ProducerConfigConstants.AGGREGATION_MAX_COUNT);\n\t\t}\n\t\treturn configProps;\n\t}"}, {"instruction": "\u589e\u52a0\u4e00\u4e2a\u8bcd\u5178\n\n@param key\n@param path\n@param value", "input": "Java", "output": "public static void putLibrary(String key, String path, Object value) {\n        if (key.startsWith(DicLibrary.DEFAULT)) {\n            DicLibrary.put(key, path, (Forest) value);\n        } else if (key.startsWith(StopLibrary.DEFAULT)) {\n            StopLibrary.put(key, path, (StopRecognition) value);\n        } else if (key.startsWith(SynonymsLibrary.DEFAULT)) {\n            SynonymsLibrary.put(key, path, (SmartForest) value);\n        } else if (key.startsWith(AmbiguityLibrary.DEFAULT)) {\n            AmbiguityLibrary.put(key, path, (Forest) value);\n        } else if (key.startsWith(CrfLibrary.DEFAULT)) {\n            CrfLibrary.put(key, path, (SplitWord) value);\n        } else {\n            throw new LibraryException(key + \" type err must start with dic,stop,ambiguity,synonyms\");\n        }\n        ENV.put(key, path);\n    }"}, {"instruction": "Reads a number of items starting with the first one that has a Sequence Number higher than the given one.\n\n@param afterSequenceNumber The sequence to search from.\n@param count               The maximum number of items to read.\n@return An Iterator with the resulting items. If no results are available for the given parameters, an empty iterator is returned.", "input": "Java", "output": "public Iterator<T> read(long afterSequenceNumber, int count) {\n        ListNode<T> firstNode;\n        synchronized (this.lock) {\n            firstNode = this.head;\n        }\n\n        // Find the first node that has a Sequence Number after the given one, but make sure we release and reacquire\n        // the lock with every iteration. This will prevent long-list scans from blocking adds.\n        while (firstNode != null && firstNode.item.getSequenceNumber() <= afterSequenceNumber) {\n            synchronized (this.lock) {\n                firstNode = firstNode.next;\n            }\n        }\n\n        return new NodeIterator<>(firstNode, count, this.lock);\n    }"}, {"instruction": "Deletes all alerts of this node and all child nodes recursively.", "input": "Java", "output": "public void deleteAllAlerts() {\r\n        for(int i = 0; i < getChildCount(); i++) {\r\n            ((SiteNode) getChildAt(i)).deleteAllAlerts();\r\n        }\r\n\r\n        if (!alerts.isEmpty()) {\r\n            alerts.clear();\r\n            highestAlert = null;\r\n            calculateHighestAlert = false;\r\n        \tif (this.siteMap != null) {\r\n        \t\t// Deleting alert might affect the nodes visibility in a filtered tree\r\n        \t\tsiteMap.applyFilter(this);\r\n        \t}\r\n            nodeChanged();\r\n        }\r\n    }"}, {"instruction": "Merge the absolute paths of source paths into the list of destination paths\n\n@param destinationPaths the path list which the source paths will be merged into\n@param sourcePaths source paths\n@param rootPath defined root path for source paths when they are not absolute path", "input": "Java", "output": "public static void mergeTypeClassPaths(\n      List<String> destinationPaths, final List<String> sourcePaths, final String rootPath) {\n    if (sourcePaths != null) {\n      for (String jar : sourcePaths) {\n        File file = new File(jar);\n        if (!file.isAbsolute()) {\n          file = new File(rootPath + File.separatorChar + jar);\n        }\n\n        String path = file.getAbsolutePath();\n        if (!destinationPaths.contains(path)) {\n          destinationPaths.add(path);\n        }\n      }\n    }\n  }"}, {"instruction": "Deregister the given epoll from this {@link EventLoop}.", "input": "Java", "output": "void remove(AbstractEpollChannel ch) throws IOException {\n        assert inEventLoop();\n\n        if (ch.isOpen()) {\n            int fd = ch.socket.intValue();\n            if (channels.remove(fd) != null) {\n                // Remove the epoll. This is only needed if it's still open as otherwise it will be automatically\n                // removed once the file-descriptor is closed.\n                Native.epollCtlDel(epollFd.intValue(), ch.fd().intValue());\n            }\n        }\n    }"}, {"instruction": "\u5bfb\u627e\u91cd\u53e0\n@param interval \u4e00\u4e2a\u533a\u95f4\uff0c\u4e0e\u8be5\u533a\u95f4\u91cd\u53e0\n@param direction \u65b9\u5411\uff0c\u8868\u660e\u91cd\u53e0\u533a\u95f4\u5728interval\u7684\u5de6\u8fb9\u8fd8\u662f\u53f3\u8fb9\n@return", "input": "Java", "output": "protected List<Intervalable> checkForOverlaps(Intervalable interval, Direction direction)\n    {\n\n        List<Intervalable> overlaps = new ArrayList<Intervalable>();\n        for (Intervalable currentInterval : this.intervals)\n        {\n            switch (direction)\n            {\n                case LEFT:\n                    if (currentInterval.getStart() <= interval.getEnd())\n                    {\n                        overlaps.add(currentInterval);\n                    }\n                    break;\n                case RIGHT:\n                    if (currentInterval.getEnd() >= interval.getStart())\n                    {\n                        overlaps.add(currentInterval);\n                    }\n                    break;\n            }\n        }\n        return overlaps;\n    }"}, {"instruction": "\u7ed9\u5b9a\u8303\u56f4\u5185\u7684\u6574\u6570\u5217\u8868\n\n@param start \u5f00\u59cb\uff08\u5305\u542b\uff09\n@param stop \u7ed3\u675f\uff08\u5305\u542b\uff09\n@param step \u6b65\u8fdb\n@return \u6574\u6570\u5217\u8868", "input": "Java", "output": "public static int[] range(int start, int stop, int step) {\r\n\t\tif (start < stop) {\r\n\t\t\tstep = Math.abs(step);\r\n\t\t} else if (start > stop) {\r\n\t\t\tstep = -Math.abs(step);\r\n\t\t} else {// start == end\r\n\t\t\treturn new int[] { start };\r\n\t\t}\r\n\r\n\t\tint size = Math.abs((stop - start) / step) + 1;\r\n\t\tint[] values = new int[size];\r\n\t\tint index = 0;\r\n\t\tfor (int i = start; (step > 0) ? i <= stop : i >= stop; i += step) {\r\n\t\t\tvalues[index] = i;\r\n\t\t\tindex++;\r\n\t\t}\r\n\t\treturn values;\r\n\t}"}, {"instruction": "Configure Azkaban metrics tracking for a new flowRunner instance", "input": "Java", "output": "private void configureFlowLevelMetrics(final FlowRunner flowRunner) {\n    logger.info(\"Configuring Azkaban metrics tracking for flow runner object\");\n\n    if (MetricReportManager.isAvailable()) {\n      final MetricReportManager metricManager = MetricReportManager.getInstance();\n      // Adding NumFailedFlow Metric listener\n      flowRunner.addListener((NumFailedFlowMetric) metricManager\n          .getMetricFromName(NumFailedFlowMetric.NUM_FAILED_FLOW_METRIC_NAME));\n    }\n\n  }"}, {"instruction": "Takes an image and executes a pipeline of combined transforms.\n\n@param image to transform, null == end of stream\n@param random object to use (or null for deterministic)\n@return transformed image", "input": "Java", "output": "@Override\n    protected ImageWritable doTransform(ImageWritable image, Random random) {\n        if (shuffle) {\n            Collections.shuffle(imageTransforms);\n        }\n\n        currentTransforms.clear();\n\n        // execute each item in the pipeline\n        for (Pair<ImageTransform, Double> tuple : imageTransforms) {\n            if (tuple.getSecond() == 1.0 || rng.nextDouble() < tuple.getSecond()) { // probability of execution\n                currentTransforms.add(tuple.getFirst());\n                image = random != null ? tuple.getFirst().transform(image, random)\n                        : tuple.getFirst().transform(image);\n            }\n        }\n\n        return image;\n    }"}, {"instruction": "/* (non-Javadoc)\n@see org.parosproxy.paros.db.paros.TableContext#getDataForContext(int)", "input": "Java", "output": "@Override\r\n\tpublic synchronized List<RecordContext> getDataForContext (int contextId) throws DatabaseException {\r\n    \ttry {\r\n\t\t\tList<RecordContext> result = new ArrayList<>();\r\n\t\t\tpsGetAllDataForContext.setInt(1, contextId);\r\n\t\t\ttry (ResultSet rs = psGetAllDataForContext.executeQuery()) {\r\n\t\t\t\twhile (rs.next()) {\r\n\t\t\t\t\tresult.add(new RecordContext(rs.getLong(DATAID), rs.getInt(CONTEXTID), rs.getInt(TYPE), rs.getString(DATA)));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t} catch (SQLException e) {\r\n\t\t\tthrow new DatabaseException(e);\r\n\t\t}\r\n    }"}, {"instruction": "Calculate the inner product value between vectors.", "input": "Java", "output": "static double inner_product(SparseVector vec1, SparseVector vec2)\n    {\n        Iterator<Map.Entry<Integer, Double>> it;\n        SparseVector other;\n        if (vec1.size() < vec2.size())\n        {\n            it = vec1.entrySet().iterator();\n            other = vec2;\n        }\n        else\n        {\n            it = vec2.entrySet().iterator();\n            other = vec1;\n        }\n        double prod = 0;\n        while (it.hasNext())\n        {\n            Map.Entry<Integer, Double> entry = it.next();\n            prod += entry.getValue() * other.get(entry.getKey());\n        }\n        return prod;\n    }"}, {"instruction": "Called by {@link Executor} to kill excessive executors from this computer.", "input": "Java", "output": "protected void removeExecutor(final Executor e) {\n        final Runnable task = new Runnable() {\n            @Override\n            public void run() {\n                synchronized (Computer.this) {\n                    executors.remove(e);\n                    addNewExecutorIfNecessary();\n                    if (!isAlive()) {\n                        AbstractCIBase ciBase = Jenkins.getInstanceOrNull();\n                        if (ciBase != null) { // TODO confirm safe to assume non-null and use getInstance()\n                            ciBase.removeComputer(Computer.this);\n                        }\n                    }\n                }\n            }\n        };\n        if (!Queue.tryWithLock(task)) {\n            // JENKINS-28840 if we couldn't get the lock push the operation to a separate thread to avoid deadlocks\n            threadPoolForRemoting.submit(Queue.wrapWithLock(task));\n        }\n    }"}, {"instruction": "This should only be called as last operation from a method as this may adjust the underlying\narray of components and so affect the index etc.", "input": "Java", "output": "private void consolidateIfNeeded() {\n        // Consolidate if the number of components will exceed the allowed maximum by the current\n        // operation.\n        int size = componentCount;\n        if (size > maxNumComponents) {\n            final int capacity = components[size - 1].endOffset;\n\n            ByteBuf consolidated = allocBuffer(capacity);\n            lastAccessed = null;\n\n            // We're not using foreach to avoid creating an iterator.\n            for (int i = 0; i < size; i ++) {\n                components[i].transferTo(consolidated);\n            }\n\n            components[0] = new Component(consolidated, 0, 0, capacity, consolidated);\n            removeCompRange(1, size);\n        }\n    }"}, {"instruction": "\u8c03\u7528\u8f6c\u53d1\uff0c\u5982\u679c\u9700\u8981\u8f6c\u53d1\u8fd4\u56de\u8f6c\u53d1\u7ed3\u679c\uff0c\u5426\u5219\u8fd4\u56de<code>null</code>\n\n@return {@link HttpResponse}\uff0c\u65e0\u8f6c\u53d1\u8fd4\u56de <code>null</code>", "input": "Java", "output": "private HttpResponse sendRedirectIfPosible() {\r\n\t\tif (this.maxRedirectCount < 1) {\r\n\t\t\t// \u4e0d\u91cd\u5b9a\u5411\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// \u624b\u52a8\u5b9e\u73b0\u91cd\u5b9a\u5411\r\n\t\tif (this.httpConnection.getHttpURLConnection().getInstanceFollowRedirects()) {\r\n\t\t\tint responseCode;\r\n\t\t\ttry {\r\n\t\t\t\tresponseCode = httpConnection.responseCode();\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\tthrow new HttpException(e);\r\n\t\t\t}\r\n\t\t\tif (responseCode != HttpURLConnection.HTTP_OK) {\r\n\t\t\t\tif (responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_SEE_OTHER) {\r\n\t\t\t\t\tthis.url = httpConnection.header(Header.LOCATION);\r\n\t\t\t\t\tif (redirectCount < this.maxRedirectCount) {\r\n\t\t\t\t\t\tredirectCount++;\r\n\t\t\t\t\t\treturn execute();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tStaticLog.warn(\"URL [{}] redirect count more than two !\", this.url);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}"}, {"instruction": "Sets the number of fields in the record. If the new number of fields is longer than the current number of\nfields, then null fields are appended. If the new number of fields is smaller than the current number of\nfields, then the last fields are truncated.\n\n@param numFields The new number of fields.", "input": "Java", "output": "public void setNumFields(final int numFields) {\n\t\tfinal int oldNumFields = this.numFields;\n\t\t// check whether we increase or decrease the fields \n\t\tif (numFields > oldNumFields) {\n\t\t\tmakeSpace(numFields);\n\t\t\tfor (int i = oldNumFields; i < numFields; i++) {\n\t\t\t\tthis.offsets[i] = NULL_INDICATOR_OFFSET;\n\t\t\t}\n\t\t\tmarkModified(oldNumFields);\n\t\t}\n\t\telse {\n\t\t\t// decrease the number of fields\n\t\t\t// we do not remove the values from the cache, as the objects (if they are there) will most likely\n\t\t\t// be reused when the record is re-filled\n\t\t\tmarkModified(numFields);\n\t\t}\n\t\tthis.numFields = numFields;\n\t}"}, {"instruction": "\u5bf9\u6bd4\u4e24\u4e2aReader\u7684\u5185\u5bb9\u662f\u5426\u4e00\u81f4<br>\n\u5185\u90e8\u4f1a\u8f6c\u6362\u6d41\u4e3a {@link BufferedInputStream}\n\n@param input1 \u7b2c\u4e00\u4e2areader\n@param input2 \u7b2c\u4e8c\u4e2areader\n@return \u4e24\u4e2a\u6d41\u7684\u5185\u5bb9\u4e00\u81f4\u8fd4\u56detrue\uff0c\u5426\u5219false\n@throws IORuntimeException IO\u5f02\u5e38\n@since 4.0.6", "input": "Java", "output": "public static boolean contentEquals(Reader input1, Reader input2) throws IORuntimeException {\r\n\t\tinput1 = getReader(input1);\r\n\t\tinput2 = getReader(input2);\r\n\r\n\t\ttry {\r\n\t\t\tint ch = input1.read();\r\n\t\t\twhile (EOF != ch) {\r\n\t\t\t\tint ch2 = input2.read();\r\n\t\t\t\tif (ch != ch2) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tch = input1.read();\r\n\t\t\t}\r\n\r\n\t\t\tint ch2 = input2.read();\r\n\t\t\treturn ch2 == EOF;\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new IORuntimeException(e);\r\n\t\t}\r\n\t}"}, {"instruction": "todo dmgcodevil: it would be better to reuse the code from build() method", "input": "Java", "output": "public HystrixObservableCommand.Setter buildObservableCommandSetter() {\n        HystrixObservableCommand.Setter setter = HystrixObservableCommand.Setter\n                .withGroupKey(HystrixCommandGroupKey.Factory.asKey(groupKey))\n                .andCommandKey(HystrixCommandKey.Factory.asKey(commandKey));\n        try {\n            setter.andCommandPropertiesDefaults(HystrixPropertiesManager.initializeCommandProperties(commandProperties));\n        } catch (IllegalArgumentException e) {\n            throw new HystrixPropertyException(\"Failed to set Command properties. \" + getInfo(), e);\n        }\n        return setter;\n    }"}, {"instruction": "\u5206\u8bcd\n@param text \u6587\u672c\n@return \u5206\u8bcd\u7ed3\u679c", "input": "Java", "output": "public static List<Term> segment(String text)\n    {\n        List<Term> termList = new LinkedList<Term>();\n        Matcher matcher = WEB_URL.matcher(text);\n        int begin = 0;\n        int end;\n        while (matcher.find())\n        {\n            end = matcher.start();\n            termList.addAll(SEGMENT.seg(text.substring(begin, end)));\n            termList.add(new Term(matcher.group(), Nature.xu));\n            begin = matcher.end();\n        }\n        if (begin < text.length()) termList.addAll(SEGMENT.seg(text.substring(begin)));\n\n        return termList;\n    }"}, {"instruction": "ZapTocMerger#mergeNodes(TreeNode, TreeNode) instead of UniteAppendMerge#mergeNodes(TreeNode, TreeNode).", "input": "Java", "output": "@Override\n    public TreeNode processMerge(TreeNode node) {\n\n        DefaultMutableTreeNode masterNode = (DefaultMutableTreeNode) node;\n\n        // if master and slave are the same object return the\n        // masterNode\n        if (masterNode.equals(slaveTopNode)) {\n            return masterNode;\n        }\n\n        // If there are not children in slaveTopNode return the\n        // masterNode\n        if (slaveTopNode.getChildCount() == 0) {\n            return masterNode;\n        }\n\n        mergeNodes(masterNode, slaveTopNode);\n        return masterNode;\n    }"}, {"instruction": "Build a new set of genes. Has two distinct modes of operation\n<ul>\n<li>Before the population has reached the culled size: will return a random set of genes.</li>\n<li>After: Parents will be selected among the population, a crossover will be applied followed by a mutation.</li>\n</ul>\n@return Returns the generated set of genes\n@throws GeneticGenerationException If buildNextGenes() can't generate a set that has not already been tried,\nor if the crossover and the mutation operators can't generate a set,\nthis exception is thrown.", "input": "Java", "output": "@Override\n    public double[] buildNextGenes() {\n        double[] result;\n\n        boolean hasAlreadyBeenTried;\n        int attemptsRemaining = MAX_NUM_GENERATION_ATTEMPTS;\n        do {\n            if (populationModel.isReadyToBreed()) {\n                result = buildOffspring();\n            } else {\n                result = buildRandomGenes();\n            }\n\n            hasAlreadyBeenTried = hasAlreadyBeenTried(result);\n            if (hasAlreadyBeenTried && --attemptsRemaining == 0) {\n                throw new GeneticGenerationException(\"Failed to generate a set of genes not already tried.\");\n            }\n        } while (hasAlreadyBeenTried);\n\n        previousGenes[previousGenesIdx] = result;\n        previousGenesIdx = ++previousGenesIdx % previousGenes.length;\n\n        return result;\n    }"}, {"instruction": "Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies\na user-defined transformation on the values of the matched records.\nThe vertex ID and the first field of the Tuple2 DataSet are used as the join keys.\n\n@param inputDataSet the Tuple2 DataSet to join with.\nThe first field of the Tuple2 is used as the join key and the second field is passed\nas a parameter to the transformation function.\n@param vertexJoinFunction the transformation function to apply.\nThe first parameter is the current vertex value and the second parameter is the value\nof the matched Tuple2 from the input DataSet.\n@return a new Graph, where the vertex values have been updated according to the\nresult of the vertexJoinFunction.\n\n@param <T> the type of the second field of the input Tuple2 DataSet.", "input": "Java", "output": "public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,\n\t\t\tfinal VertexJoinFunction<VV, T> vertexJoinFunction) {\n\n\t\tDataSet<Vertex<K, VV>> resultedVertices = this.getVertices()\n\t\t\t\t.coGroup(inputDataSet).where(0).equalTo(0)\n\t\t\t\t.with(new ApplyCoGroupToVertexValues<>(vertexJoinFunction))\n\t\t\t\t\t.name(\"Join with vertices\");\n\t\treturn new Graph<>(resultedVertices, this.edges, this.context);\n\t}"}, {"instruction": "\u8ba1\u7b97\u5bf9\u8c61\u957f\u5ea6\uff0c\u5982\u679c\u662f\u5b57\u7b26\u4e32\u8c03\u7528\u5176length\u51fd\u6570\uff0c\u96c6\u5408\u7c7b\u8c03\u7528\u5176size\u51fd\u6570\uff0c\u6570\u7ec4\u8c03\u7528\u5176length\u5c5e\u6027\uff0c\u5176\u4ed6\u53ef\u904d\u5386\u5bf9\u8c61\u904d\u5386\u8ba1\u7b97\u957f\u5ea6<br>\n\u652f\u6301\u7684\u7c7b\u578b\u5305\u62ec\uff1a\n<ul>\n<li>CharSequence</li>\n<li>Map</li>\n<li>Iterator</li>\n<li>Enumeration</li>\n<li>Array</li>\n</ul>\n\n@param obj \u88ab\u8ba1\u7b97\u957f\u5ea6\u7684\u5bf9\u8c61\n@return \u957f\u5ea6", "input": "Java", "output": "public static int length(Object obj) {\r\n\t\tif (obj == null) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (obj instanceof CharSequence) {\r\n\t\t\treturn ((CharSequence) obj).length();\r\n\t\t}\r\n\t\tif (obj instanceof Collection) {\r\n\t\t\treturn ((Collection<?>) obj).size();\r\n\t\t}\r\n\t\tif (obj instanceof Map) {\r\n\t\t\treturn ((Map<?, ?>) obj).size();\r\n\t\t}\r\n\r\n\t\tint count;\r\n\t\tif (obj instanceof Iterator) {\r\n\t\t\tIterator<?> iter = (Iterator<?>) obj;\r\n\t\t\tcount = 0;\r\n\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\tcount++;\r\n\t\t\t\titer.next();\r\n\t\t\t}\r\n\t\t\treturn count;\r\n\t\t}\r\n\t\tif (obj instanceof Enumeration) {\r\n\t\t\tEnumeration<?> enumeration = (Enumeration<?>) obj;\r\n\t\t\tcount = 0;\r\n\t\t\twhile (enumeration.hasMoreElements()) {\r\n\t\t\t\tcount++;\r\n\t\t\t\tenumeration.nextElement();\r\n\t\t\t}\r\n\t\t\treturn count;\r\n\t\t}\r\n\t\tif (obj.getClass().isArray() == true) {\r\n\t\t\treturn Array.getLength(obj);\r\n\t\t}\r\n\t\treturn -1;\r\n\t}"}, {"instruction": "Process a resource, searching for links (uris) to other resources.\n\n@param message the HTTP Message", "input": "Java", "output": "private void processResource(HttpMessage message) {\n\t\tList<SpiderParser> parsers = parent.getController().getParsers();\n\n\t\t// Prepare the Jericho source\n\t\tSource source = new Source(message.getResponseBody().toString());\n\t\t\n\t\t// Get the full path of the file\n\t\tString path = null;\n\t\ttry {\n\t\t\tpath = message.getRequestHeader().getURI().getPath();\n\t\t} catch (URIException e) {\n\t\t} finally {\n\t\t\t// Handle null paths.\n\t\t\tif (path == null)\n\t\t\t\tpath = \"\";\n\t\t}\n\t\t\n\t\t// Parse the resource\n\t\tboolean alreadyConsumed = false;\n\t\tfor (SpiderParser parser : parsers) {\t\t\t\n\t\t\tif (parser.canParseResource(message, path, alreadyConsumed)) {\n\t\t\t\tif (log.isDebugEnabled()) log.debug(\"Parser \"+ parser +\" can parse resource '\"+ path + \"'\");\n\t\t\t\tif (parser.parseResource(message, source, depth))\n\t\t\t\t\talreadyConsumed = true;\n\t\t\t} else {\n\t\t\t\tif (log.isDebugEnabled()) log.debug(\"Parser \"+ parser +\" cannot parse resource '\"+ path + \"'\");\n\t\t\t}\n\t\t}\n\t}"}, {"instruction": "\u83b7\u53d6\u6307\u5b9a\u7c7b\u578b\u5206\u7684\u9ed8\u8ba4\u503c<br>\n\u9ed8\u8ba4\u503c\u89c4\u5219\u4e3a\uff1a\n\n<pre>\n1\u3001\u5982\u679c\u4e3a\u539f\u59cb\u7c7b\u578b\uff0c\u8fd4\u56de0\n2\u3001\u975e\u539f\u59cb\u7c7b\u578b\u8fd4\u56de{@code null}\n</pre>\n\n@param clazz \u7c7b\n@return \u9ed8\u8ba4\u503c\n@since 3.0.8", "input": "Java", "output": "public static Object getDefaultValue(Class<?> clazz) {\r\n\t\tif (clazz.isPrimitive()) {\r\n\t\t\tif (long.class == clazz) {\r\n\t\t\t\treturn 0L;\r\n\t\t\t} else if (int.class == clazz) {\r\n\t\t\t\treturn 0;\r\n\t\t\t} else if (short.class == clazz) {\r\n\t\t\t\treturn (short) 0;\r\n\t\t\t} else if (char.class == clazz) {\r\n\t\t\t\treturn (char) 0;\r\n\t\t\t} else if (byte.class == clazz) {\r\n\t\t\t\treturn (byte) 0;\r\n\t\t\t} else if (double.class == clazz) {\r\n\t\t\t\treturn 0D;\r\n\t\t\t} else if (float.class == clazz) {\r\n\t\t\t\treturn 0f;\r\n\t\t\t} else if (boolean.class == clazz) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}"}, {"instruction": "Build a MultiLayerNetwork from this Keras Sequential model configuration and import weights.\n\n@return MultiLayerNetwork", "input": "Java", "output": "public MultiLayerNetwork getMultiLayerNetwork(boolean importWeights)\n            throws InvalidKerasConfigurationException, UnsupportedKerasConfigurationException {\n        MultiLayerNetwork model = new MultiLayerNetwork(getMultiLayerConfiguration());\n        model.init();\n        if (importWeights)\n            model = (MultiLayerNetwork) KerasModelUtils.copyWeightsToModel(model, this.layers);\n        return model;\n    }"}, {"instruction": "\u5224\u65ad\u6307\u5b9a\u7684\u5355\u5143\u683c\u662f\u5426\u662f\u5408\u5e76\u5355\u5143\u683c\n\n@param sheet {@link Sheet}\n@param row \u884c\u53f7\n@param column \u5217\u53f7\n@return \u662f\u5426\u662f\u5408\u5e76\u5355\u5143\u683c", "input": "Java", "output": "public static boolean isMergedRegion(Sheet sheet, int row, int column) {\r\n\t\tfinal int sheetMergeCount = sheet.getNumMergedRegions();\r\n\t\tCellRangeAddress ca;\r\n\t\tfor (int i = 0; i < sheetMergeCount; i++) {\r\n\t\t\tca = sheet.getMergedRegion(i);\r\n\t\t\tif (row >= ca.getFirstRow() && row <= ca.getLastRow() && column >= ca.getFirstColumn() && column <= ca.getLastColumn()) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}"}, {"instruction": "}", "input": "Java", "output": "@Bean\n\t@ConditionalOnBean(AutoServiceRegistrationProperties.class)\n\t@ConditionalOnProperty(value = \"spring.cloud.service-registry.auto-registration.enabled\", matchIfMissing = true)\n\tpublic EurekaAutoServiceRegistration eurekaAutoServiceRegistration(\n\t\t\tApplicationContext context, EurekaServiceRegistry registry,\n\t\t\tEurekaRegistration registration) {\n\t\treturn new EurekaAutoServiceRegistration(context, registry, registration);\n\t}"}, {"instruction": "Get all dashboards filtered by title and Pageable ( default page size = 10)\n\n@param title, pageable\n@return Page<Dashboard>", "input": "Java", "output": "@Override\n    public Page<Dashboard> getDashboardByTitleWithFilter(String title, String type, Pageable pageable) {\n        Page<Dashboard> dashboardItems = null;\n        if ((type != null) && (!type.isEmpty()) && (!UNDEFINED.equalsIgnoreCase(type))) {\n            dashboardItems = dashboardRepository.findAllByTypeContainingIgnoreCaseAndTitleContainingIgnoreCase(type, title, pageable);\n        } else {\n            dashboardItems = dashboardRepository.findAllByTitleContainingIgnoreCase(title, pageable);\n        }\n\n        return dashboardItems;\n    }"}, {"instruction": "\u6267\u884cWebservice\u8bf7\u6c42\uff0c\u65e2\u53d1\u9001SOAP\u5185\u5bb9\n\n@return \u8fd4\u56de\u7ed3\u679c", "input": "Java", "output": "public SOAPMessage sendForMessage() {\r\n\t\tfinal HttpResponse res = sendForResponse();\r\n\t\tfinal MimeHeaders headers = new MimeHeaders();\r\n\t\tfor (Entry<String, List<String>> entry : res.headers().entrySet()) {\r\n\t\t\tif(StrUtil.isNotEmpty(entry.getKey())) {\r\n\t\t\t\theaders.setHeader(entry.getKey(), CollUtil.get(entry.getValue(), 0));\r\n\t\t\t}\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn this.factory.createMessage(headers, res.bodyStream());\r\n\t\t} catch (IOException | SOAPException e) {\r\n\t\t\tthrow new SoapRuntimeException(e);\r\n\t\t}\r\n\t}"}, {"instruction": "\u68c0\u67e5\u8bc1\u4e66\u94fe\n\n@param rootCerts\n\u6839\u8bc1\u4e66\n@param cert\n\u5f85\u9a8c\u8bc1\u7684\u8bc1\u4e66\n@return", "input": "Java", "output": "public static boolean verifyCertificate(X509Certificate cert) {\n\t\t\n\t\tif ( null == cert) {\n\t\t\tLogUtil.writeErrorLog(\"cert must Not null\");\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tcert.checkValidity();//\u9a8c\u8bc1\u6709\u6548\u671f\n//\t\t\tcert.verify(middleCert.getPublicKey());\n\t\t\tif(!verifyCertificateChain(cert)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLogUtil.writeErrorLog(\"verifyCertificate fail\", e);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(SDKConfig.getConfig().isIfValidateCNName()){\n\t\t\t// \u9a8c\u8bc1\u516c\u94a5\u662f\u5426\u5c5e\u4e8e\u94f6\u8054\n\t\t\tif(!UNIONPAY_CNNAME.equals(CertUtil.getIdentitiesFromCertficate(cert))) {\n\t\t\t\tLogUtil.writeErrorLog(\"cer owner is not CUP:\" + CertUtil.getIdentitiesFromCertficate(cert));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\t// \u9a8c\u8bc1\u516c\u94a5\u662f\u5426\u5c5e\u4e8e\u94f6\u8054\n\t\t\tif(!UNIONPAY_CNNAME.equals(CertUtil.getIdentitiesFromCertficate(cert)) \n\t\t\t\t\t&& !\"00040000:SIGN\".equals(CertUtil.getIdentitiesFromCertficate(cert))) {\n\t\t\t\tLogUtil.writeErrorLog(\"cer owner is not CUP:\" + CertUtil.getIdentitiesFromCertficate(cert));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\t\t\n\t}"}, {"instruction": "\u5c1d\u8bd5\u904d\u5386\u5e76\u8c03\u7528\u6b64\u7c7b\u7684\u6240\u6709\u6784\u9020\u65b9\u6cd5\uff0c\u76f4\u5230\u6784\u9020\u6210\u529f\u5e76\u8fd4\u56de\n\n@param <T> \u5bf9\u8c61\u7c7b\u578b\n@param beanClass \u88ab\u6784\u9020\u7684\u7c7b\n@return \u6784\u9020\u540e\u7684\u5bf9\u8c61", "input": "Java", "output": "public static <T> T newInstanceIfPossible(Class<T> beanClass) {\r\n\t\tAssert.notNull(beanClass);\r\n\t\ttry {\r\n\t\t\treturn newInstance(beanClass);\r\n\t\t} catch (Exception e) {\r\n\t\t\t// ignore\r\n\t\t\t// \u9ed8\u8ba4\u6784\u9020\u4e0d\u5b58\u5728\u7684\u60c5\u51b5\u4e0b\u67e5\u627e\u5176\u5b83\u6784\u9020\r\n\t\t}\r\n\t\t\r\n\t\tfinal Constructor<T>[] constructors = getConstructors(beanClass);\r\n\t\tClass<?>[] parameterTypes;\r\n\t\tfor (Constructor<T> constructor : constructors) {\r\n\t\t\tparameterTypes = constructor.getParameterTypes();\r\n\t\t\tif (0 == parameterTypes.length) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconstructor.setAccessible(true);\r\n\t\t\ttry {\r\n\t\t\t\treturn constructor.newInstance(ClassUtil.getDefaultValues(parameterTypes));\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\t// \u6784\u9020\u51fa\u9519\u65f6\u7ee7\u7eed\u5c1d\u8bd5\u4e0b\u4e00\u79cd\u6784\u9020\u65b9\u5f0f\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}"}, {"instruction": "Writes the given {@link AccessExecutionGraph} to the {@link FileSystem} pointed to by\n{@link JobManagerOptions#ARCHIVE_DIR}.\n\n@param rootPath directory to which the archive should be written to\n@param jobId  job id\n@param jsonToArchive collection of json-path pairs to that should be archived\n@return path to where the archive was written, or null if no archive was created\n@throws IOException", "input": "Java", "output": "public static Path archiveJob(Path rootPath, JobID jobId, Collection<ArchivedJson> jsonToArchive) throws IOException {\n\t\ttry {\n\t\t\tFileSystem fs = rootPath.getFileSystem();\n\t\t\tPath path = new Path(rootPath, jobId.toString());\n\t\t\tOutputStream out = fs.create(path, FileSystem.WriteMode.NO_OVERWRITE);\n\n\t\t\ttry (JsonGenerator gen = jacksonFactory.createGenerator(out, JsonEncoding.UTF8)) {\n\t\t\t\tgen.writeStartObject();\n\t\t\t\tgen.writeArrayFieldStart(ARCHIVE);\n\t\t\t\tfor (ArchivedJson archive : jsonToArchive) {\n\t\t\t\t\tgen.writeStartObject();\n\t\t\t\t\tgen.writeStringField(PATH, archive.getPath());\n\t\t\t\t\tgen.writeStringField(JSON, archive.getJson());\n\t\t\t\t\tgen.writeEndObject();\n\t\t\t\t}\n\t\t\t\tgen.writeEndArray();\n\t\t\t\tgen.writeEndObject();\n\t\t\t} catch (Exception e) {\n\t\t\t\tfs.delete(path, false);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tLOG.info(\"Job {} has been archived at {}.\", jobId, path);\n\t\t\treturn path;\n\t\t} catch (IOException e) {\n\t\t\tLOG.error(\"Failed to archive job.\", e);\n\t\t\tthrow e;\n\t\t}\n\t}"}, {"instruction": "Returns the next items from the queue. If the queue is empty, it blocks the call until at least one item is added.\n\n@param maxCount The maximum number of items to return. This argument will be ignored if the queue is currently empty,\nbut in that case the result will always be completed with exactly one element.\n@return A CompletableFuture that, when completed, will contain the requested result. If the queue is not currently\nempty, this Future will already be completed, otherwise it will be completed the next time the add() method is called.\nIf the queue is closed and this Future is not yet completed, it will be cancelled.\n@throws ObjectClosedException If the Queue is closed.\n@throws IllegalStateException If another call to take() is in progress.", "input": "Java", "output": "public CompletableFuture<Queue<T>> take(int maxCount) {\n        synchronized (this.contents) {\n            Exceptions.checkNotClosed(this.closed, this);\n            Preconditions.checkState(this.pendingTake == null, \"Cannot have more than one concurrent pending take() request.\");\n            Queue<T> result = fetch(maxCount);\n            if (result.size() > 0) {\n                return CompletableFuture.completedFuture(result);\n            } else {\n                this.pendingTake = new CompletableFuture<>();\n                return this.pendingTake;\n            }\n        }\n    }"}, {"instruction": "[VARIABLE \"bucket_\"]", "input": "Java", "output": "public Page<Bucket> listBucketsWithSizeAndPrefix(String prefix) {\n    // [START listBucketsWithSizeAndPrefix]\n    // Include a prefix of bucket-name to reduce search space.\n    // For more information read https://cloud.google.com/storage/docs/json_api/v1/buckets/list\n    Page<Bucket> buckets =\n        storage.list(BucketListOption.pageSize(100), BucketListOption.prefix(prefix));\n    for (Bucket bucket : buckets.iterateAll()) {\n      // do something with the bucket\n    }\n    // [END listBucketsWithSizeAndPrefix]\n    return buckets;\n  }"}, {"instruction": "Ipv4 String \u8f6c\u6362\u5230byte[]", "input": "Java", "output": "private static byte[] ip4StringToBytes(String ipv4Str) {\n\t\tif (ipv4Str == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tList<String> it = MoreStringUtil.split(ipv4Str, '.', 4);\n\t\tif (it.size() != 4) {\n\t\t\treturn null;\n\t\t}\n\n\t\tbyte[] byteAddress = new byte[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint tempInt = Integer.parseInt(it.get(i));\n\t\t\tif (tempInt > 255) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbyteAddress[i] = (byte) tempInt;\n\t\t}\n\t\treturn byteAddress;\n\t}"}, {"instruction": "Executes one iteration of the MetadataCleaner. This ensures that there cannot be more than one concurrent executions of\nsuch an iteration (whether it's from this direct call or from the regular MetadataCleaner invocation). If concurrent\ninvocations are made, then subsequent calls will be tied to the execution of the first, and will all complete at\nthe same time (even though there's only one executing).\n\n@return A CompletableFuture that, when completed, indicates that the operation completed (successfully or not).", "input": "Java", "output": "CompletableFuture<Void> runOnce() {\n        CompletableFuture<Void> result;\n        synchronized (this.singleRunLock) {\n            if (this.currentIteration != null) {\n                // Some other iteration is in progress. Piggyback on that one and return when it is done.\n                return this.currentIteration;\n            } else {\n                // No other iteration is running.\n                this.currentIteration = new CompletableFuture<>();\n                this.currentIteration.whenComplete((r, ex) -> {\n                    // Unregister the current iteration when done.\n                    synchronized (this.singleRunLock) {\n                        this.currentIteration = null;\n                    }\n                });\n                result = this.currentIteration;\n            }\n        }\n\n        Futures.completeAfter(this::runOnceInternal, result);\n        return result;\n    }"}, {"instruction": "/*\nReturns the JVM-specific size of a primitive type.", "input": "Java", "output": "private static int sizeofPrimitiveType(final Class type) {\n        if (type == int.class) {\n            return INT_FIELD_SIZE;\n        } else if (type == long.class) {\n            return LONG_FIELD_SIZE;\n        } else if (type == short.class) {\n            return SHORT_FIELD_SIZE;\n        } else if (type == byte.class) {\n            return BYTE_FIELD_SIZE;\n        } else if (type == boolean.class) {\n            return BOOLEAN_FIELD_SIZE;\n        } else if (type == char.class) {\n            return CHAR_FIELD_SIZE;\n        } else if (type == double.class) {\n            return DOUBLE_FIELD_SIZE;\n        } else if (type == float.class) {\n            return FLOAT_FIELD_SIZE;\n        } else {\n            throw new IllegalArgumentException(\"not primitive: \" + type);\n        }\n    }"}, {"instruction": "BC\u7684SM3withSM2\u7b7e\u540d\u5f97\u5230\u7684\u7ed3\u679c\u7684rs\u662fasn1\u683c\u5f0f\u7684\uff0c\u8fd9\u4e2a\u65b9\u6cd5\u8f6c\u5316\u6210\u76f4\u63a5\u62fc\u63a5r||s<br>\n\u6765\u81ea\uff1ahttps://blog.csdn.net/pridas/article/details/86118774\n\n@param rsDer rs in asn1 format\n@return sign result in plain byte array\n@since 4.5.0", "input": "Java", "output": "public static byte[] rsAsn1ToPlain(byte[] rsDer) {\r\n\t\tASN1Sequence seq = ASN1Sequence.getInstance(rsDer);\r\n\t\tbyte[] r = bigIntToFixexLengthBytes(ASN1Integer.getInstance(seq.getObjectAt(0)).getValue());\r\n\t\tbyte[] s = bigIntToFixexLengthBytes(ASN1Integer.getInstance(seq.getObjectAt(1)).getValue());\r\n\t\tbyte[] result = new byte[RS_LEN * 2];\r\n\t\tSystem.arraycopy(r, 0, result, 0, r.length);\r\n\t\tSystem.arraycopy(s, 0, result, RS_LEN, s.length);\r\n\t\treturn result;\r\n\t}"}, {"instruction": "Deflate the given string via a {@link java.util.zip.Deflater}.\n\n@param data the data\n@return base64 encoded string", "input": "Java", "output": "public static String deflate(final String data) {\n        val deflater = new Deflater();\n        deflater.setInput(data.getBytes(StandardCharsets.UTF_8));\n        deflater.finish();\n        val buffer = new byte[data.length()];\n        val resultSize = deflater.deflate(buffer);\n        val output = new byte[resultSize];\n        System.arraycopy(buffer, 0, output, 0, resultSize);\n        return EncodingUtils.encodeBase64(output);\n    }"}, {"instruction": "Return a view macro that may or may not be defined in a certain schema. If it's not defined, returns null.\n\n@param schemaPlus   schema\n@param functionName function name\n\n@return view, or null", "input": "Java", "output": "@Nullable\n  private static TableMacro getView(final SchemaPlus schemaPlus, final String functionName)\n  {\n    // Look for a zero-arg function that is also a TableMacro. The returned value\n    // is never null so we don't need to check for that.\n    final Collection<org.apache.calcite.schema.Function> functions =\n        schemaPlus.getFunctions(functionName);\n\n    for (org.apache.calcite.schema.Function function : functions) {\n      if (function.getParameters().isEmpty() && function instanceof TableMacro) {\n        return (TableMacro) function;\n      }\n    }\n\n    return null;\n  }"}, {"instruction": "\u83b7\u53d6\u6c49\u5b57\u5bf9\u5e94\u7684ascii\u7801\n@param chs \u6c49\u5b57\n@return ascii\u7801", "input": "Java", "output": "private static int getChsAscii(String chs) {\r\n\t\tint asc = 0;\r\n\t\tbyte[] bytes = chs.getBytes(CharsetUtil.CHARSET_GBK);\r\n\t\tswitch (bytes.length) {\r\n\t\tcase 1:\r\n\t\t\t// \u82f1\u6587\u5b57\u7b26\r\n\t\t\tasc = bytes[0];\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\t// \u4e2d\u6587\u5b57\u7b26\r\n\t\t\tint hightByte = 256 + bytes[0];\r\n\t\t\tint lowByte = 256 + bytes[1];\r\n\t\t\tasc = (256 * hightByte + lowByte) - 256 * 256;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow new UtilException(\"Illegal resource string\");\r\n\t\t}\r\n\t\treturn asc;\r\n\t}"}, {"instruction": "Parse and return a user defined function of the form \"{arg1 arg2 . (expr)}\"", "input": "Java", "output": "private AstFunction parseFunctionDefinition() {\n    eatChar('{');\n\n    // Parse the list of ids\n    ArrayList<String> ids = new ArrayList<>();\n    ids.add(\"\");  // 1-based ID list\n    while (skipWS() != '.') {\n      String id = token();\n      if (!Character.isJavaIdentifierStart(id.charAt(0)))\n        throw new IllegalASTException(\"variable must be a valid Java identifier: \" + id);\n      for (char c : id.toCharArray())\n        if (!Character.isJavaIdentifierPart(c))\n          throw new IllegalASTException(\"variable must be a valid Java identifier: \" + id);\n      ids.add(id);\n    }\n\n    // Single dot separates the list of ids from the body of the function\n    eatChar('.');\n\n    // Parse the body\n    AstRoot body = parseNext();\n    if (skipWS() != '}')\n      throw new IllegalASTException(\"Expected the end of the function, but found '\" + peek(0) + \"'\");\n    eatChar('}');\n\n    return new AstFunction(ids, body);\n  }"}, {"instruction": "Takes the serialized accumulator results and tries to deserialize them using the provided\nclass loader.\n@param serializedAccumulators The serialized accumulator results.\n@param loader The class loader to use.\n@return The deserialized accumulator results.\n@throws IOException\n@throws ClassNotFoundException", "input": "Java", "output": "public static Map<String, OptionalFailure<Object>> deserializeAccumulators(\n\t\t\tMap<String, SerializedValue<OptionalFailure<Object>>> serializedAccumulators,\n\t\t\tClassLoader loader) throws IOException, ClassNotFoundException {\n\n\t\tif (serializedAccumulators == null || serializedAccumulators.isEmpty()) {\n\t\t\treturn Collections.emptyMap();\n\t\t}\n\n\t\tMap<String, OptionalFailure<Object>> accumulators = new HashMap<>(serializedAccumulators.size());\n\n\t\tfor (Map.Entry<String, SerializedValue<OptionalFailure<Object>>> entry : serializedAccumulators.entrySet()) {\n\n\t\t\tOptionalFailure<Object> value = null;\n\t\t\tif (entry.getValue() != null) {\n\t\t\t\tvalue = entry.getValue().deserializeValue(loader);\n\t\t\t}\n\n\t\t\taccumulators.put(entry.getKey(), value);\n\t\t}\n\n\t\treturn accumulators;\n\t}"}, {"instruction": "Loads the data from the user folder into the new object.\n<p>\nIf the folder does not exist yet, a fresh new instance is created.", "input": "Java", "output": "public static @Nonnull ApiTokenStats load(@Nonnull User user) {\n        // even if we are not using statistics, we load the existing one in case the configuration\n        // is enabled afterwards to avoid erasing data\n        \n        ApiTokenStats apiTokenStats = null;\n        \n        File userFolder = user.getUserFolder();\n        if (userFolder != null) {\n            apiTokenStats = internalLoad(userFolder);\n        }\n        \n        if (apiTokenStats == null) {\n            apiTokenStats = new ApiTokenStats();\n        }\n        \n        apiTokenStats.user = user;\n        \n        return apiTokenStats;\n    }"}, {"instruction": "Computes the build cause, using RemoteCause or UserCause as appropriate.", "input": "Java", "output": "@Restricted(NoExternalUse.class)\n    public static CauseAction getBuildCause(ParameterizedJob job, StaplerRequest req) {\n        Cause cause;\n        @SuppressWarnings(\"deprecation\")\n        hudson.model.BuildAuthorizationToken authToken = job.getAuthToken();\n        if (authToken != null && authToken.getToken() != null && req.getParameter(\"token\") != null) {\n            // Optional additional cause text when starting via token\n            String causeText = req.getParameter(\"cause\");\n            cause = new Cause.RemoteCause(req.getRemoteAddr(), causeText);\n        } else {\n            cause = new Cause.UserIdCause();\n        }\n        return new CauseAction(cause);\n    }"}, {"instruction": "Gets the serializer that recognizes the previous serialization schema of the state.\nThis is the serializer that should be used for restoring the state, i.e. when the state\nis still in the previous serialization schema.\n\n<p>This method only returns a serializer if this provider has the previous serializer's\nsnapshot. Otherwise, trying to access the previous schema serializer will fail\nwith an exception.\n\n@return a serializer that reads and writes in the previous schema of the state.", "input": "Java", "output": "@Nonnull\n\tpublic final TypeSerializer<T> previousSchemaSerializer() {\n\t\tif (cachedRestoredSerializer != null) {\n\t\t\treturn cachedRestoredSerializer;\n\t\t}\n\n\t\tif (previousSerializerSnapshot == null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"This provider does not contain the state's previous serializer's snapshot. Cannot provider a serializer for previous schema.\");\n\t\t}\n\n\t\tthis.cachedRestoredSerializer = previousSerializerSnapshot.restoreSerializer();\n\t\treturn cachedRestoredSerializer;\n\t}"}, {"instruction": "Copy the contents of the given Reader to the given Writer.\nCloses both when done.\n\n@param in  the Reader to copy from\n@param out the Writer to copy to\n@return the number of characters copied\n@throws IOException in case of I/O errors", "input": "Java", "output": "public static int copy(Reader in, Writer out) throws IOException {\n        assert in != null : \"No input Reader specified\";\n        assert out != null : \"No output Writer specified\";\n\n        try {\n            int byteCount = 0;\n            char[] buffer = new char[BUFFER_SIZE];\n            int bytesRead = -1;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n                byteCount += bytesRead;\n            }\n            out.flush();\n            return byteCount;\n        } finally {\n            try {\n                in.close();\n            } catch (IOException ex) {\n            }\n            try {\n                out.close();\n            } catch (IOException ex) {\n            }\n        }\n    }"}, {"instruction": "\u89e3\u538b\u7f29", "input": "Java", "output": "public void unSimplify()\n    {\n        if (sourceNode == null)\n        {\n            sourceNode = new MDAGNode(false);\n            equivalenceClassMDAGNodeHashMap = new HashMap<MDAGNode, MDAGNode>();\n            MDAGNode[] toNodeArray = new MDAGNode[mdagDataArray.length];\n            createMDAGNode(simplifiedSourceNode, -1, toNodeArray, new MDAGNode[mdagDataArray.length]);\n            // \u6784\u5efa\u6ce8\u518c\u8868\n            for (MDAGNode mdagNode : toNodeArray)\n            {\n                equivalenceClassMDAGNodeHashMap.put(mdagNode, mdagNode);\n            }\n            // \u6254\u6389\u5783\u573e\n            simplifiedSourceNode = null;\n        }\n    }"}, {"instruction": "\u8c03\u6574\u4e00\u4e0b\u7ebf\u7a0b\u6c60", "input": "Java", "output": "private void adjustPoolSize(DbLoadContext context) {\n        Pipeline pipeline = context.getPipeline();\n        int newPoolSize = pipeline.getParameters().getLoadPoolSize();\n        if (newPoolSize != poolSize) {\n            poolSize = newPoolSize;\n            if (executor instanceof ThreadPoolExecutor) {\n                ThreadPoolExecutor pool = (ThreadPoolExecutor) executor;\n                pool.setCorePoolSize(newPoolSize);\n                pool.setMaximumPoolSize(newPoolSize);\n            }\n        }\n    }"}, {"instruction": "Create a proxy for the specified {@link Connection} instance.\n@param poolEntry the PoolEntry holding pool state\n@param connection the raw database Connection\n@param openStatements a reusable list to track open Statement instances\n@param leakTask the ProxyLeakTask for this connection\n@param now the current timestamp\n@param isReadOnly the default readOnly state of the connection\n@param isAutoCommit the default autoCommit state of the connection\n@return a proxy that wraps the specified {@link Connection}", "input": "Java", "output": "static ProxyConnection getProxyConnection(final PoolEntry poolEntry, final Connection connection, final FastList<Statement> openStatements, final ProxyLeakTask leakTask, final long now, final boolean isReadOnly, final boolean isAutoCommit)\n   {\n      // Body is replaced (injected) by JavassistProxyFactory\n      throw new IllegalStateException(\"You need to run the CLI build and you need target/classes in your classpath to run.\");\n   }"}, {"instruction": "Convert a class name with underscores to the corresponding column name using \"_\". A name like \"CustomerNumber\"\nclass name would match a \"CUSTOMER_NUMBER\".\n\n@param name the class name to be converted\n@return the name using \"_\"", "input": "Java", "output": "public static String convertClassNameToUnderscoreName(String name) {\n        StringBuilder result = new StringBuilder();\n\n        if (name != null) {\n            int len = name.length();\n\n            if (len > 0) {\n                result.append(name.charAt(0));\n\n                for (int i = 1; i < len; i++) {\n                    if (true == Character.isUpperCase(name.charAt(i))) {\n                        result.append('_');\n                    }\n\n                    result.append(name.charAt(i));\n                }\n            }\n        }\n\n        return result.toString().toUpperCase();\n    }"}, {"instruction": "This method will either generate a new random sessionId or will retrieve the value stored\nin the \"io\" cookie.  Failures to parse will cause a logging warning to be generated and a\nrandom uuid to be generated instead (same as not passing a cookie in the first place).", "input": "Java", "output": "private UUID generateOrGetSessionIdFromRequest(HttpHeaders headers) {\n        List<String> values = headers.getAll(\"io\");\n        if (values.size() == 1) {\n            try {\n                return UUID.fromString(values.get(0));\n            } catch (IllegalArgumentException iaex) {\n                log.warn(\"Malformed UUID received for session! io=\" + values.get(0));\n            }\n        }\n\n        for (String cookieHeader : headers.getAll(HttpHeaderNames.COOKIE)) {\n            Set<Cookie> cookies = ServerCookieDecoder.LAX.decode(cookieHeader);\n\n            for (Cookie cookie : cookies) {\n                if (cookie.name().equals(\"io\")) {\n                    try {\n                        return UUID.fromString(cookie.value());\n                    } catch (IllegalArgumentException iaex) {\n                        log.warn(\"Malformed UUID received for session! io=\" + cookie.value());\n                    }\n                }\n            }\n        }\n\n        return UUID.randomUUID();\n    }"}, {"instruction": "\u8ba1\u7b97\u6587\u4ef6\u6821\u9a8c\u7801\n\n@param file \u6587\u4ef6\uff0c\u4e0d\u80fd\u4e3a\u76ee\u5f55\n@param checksum {@link Checksum}\n@return Checksum\n@throws IORuntimeException IO\u5f02\u5e38\n@since 4.0.6", "input": "Java", "output": "public static Checksum checksum(File file, Checksum checksum) throws IORuntimeException {\r\n\t\tAssert.notNull(file, \"File is null !\");\r\n\t\tif (file.isDirectory()) {\r\n\t\t\tthrow new IllegalArgumentException(\"Checksums can't be computed on directories\");\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn IoUtil.checksum(new FileInputStream(file), checksum);\r\n\t\t} catch (FileNotFoundException e) {\r\n\t\t\tthrow new IORuntimeException(e);\r\n\t\t}\r\n\t}"}, {"instruction": "\u521d\u59cb\u5316<br>\n\u8bbe\u5b9a\u6587\u4ef6\u4e2d\u7684host\u548c\u7aef\u53e3\u6709\u4e09\u79cd\u5f62\u5f0f\uff1a\n\n<pre>\nhost = host:port\n</pre>\n\n<pre>\nhost = host\nport = port\n</pre>\n\n<pre>\nhost = host\n</pre>", "input": "Java", "output": "synchronized public void initSingle() {\r\n\t\tif (setting == null) {\r\n\t\t\ttry {\r\n\t\t\t\tsetting = new Setting(MONGO_CONFIG_PATH, true);\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\t// \u5728single\u6a21\u5f0f\u4e0b\uff0c\u53ef\u4ee5\u6ca1\u6709\u914d\u7f6e\u6587\u4ef6\u3002\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tString group = StrUtil.EMPTY;\r\n\t\tif (null == this.serverAddress) {\r\n\t\t\t//\u5b58\u5728\u552f\u4e00\u5206\u7ec4\r\n\t\t\tif (groups != null && groups.length == 1) {\r\n\t\t\t\tgroup = groups[0];\r\n\t\t\t}\r\n\t\t\tserverAddress = createServerAddress(group);\r\n\t\t}\r\n\r\n\t\tfinal MongoCredential credentail = createCredentail(group);\r\n\t\ttry {\r\n\t\t\tif (null == credentail) {\r\n\t\t\t\tmongo = new MongoClient(serverAddress, buildMongoClientOptions(group));\r\n\t\t\t} else {\r\n\t\t\t\tmongo = new MongoClient(serverAddress, credentail, buildMongoClientOptions(group));\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new DbRuntimeException(StrUtil.format(\"Init MongoDB pool with connection to [{}] error!\", serverAddress), e);\r\n\t\t}\r\n\r\n\t\tlog.info(\"Init MongoDB pool with connection to [{}]\", serverAddress);\r\n\t}"}, {"instruction": "This method initializes btnCancel\n\n@return javax.swing.JButton", "input": "Java", "output": "private JButton getBtnCancel() {\r\n\t\tif (btnCancel == null) {\r\n\t\t\tbtnCancel = new JButton();\r\n\t\t\tbtnCancel.setText(Constant.messages.getString(\"edit.find.button.cancel\"));\r\n\t\t\tbtnCancel.addActionListener(new java.awt.event.ActionListener() { \r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void actionPerformed(java.awt.event.ActionEvent e) {\r\n\r\n\t\t\t\t\tFindDialog.this.discard();\r\n\t\t\t\t\tFindDialog.this.dispatchEvent(new WindowEvent(FindDialog.this, WindowEvent.WINDOW_CLOSING));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\treturn btnCancel;\r\n\t}"}, {"instruction": "Find by principal name.\n@param principal name to search for\n@return records for given principal", "input": "Java", "output": "@View(name = \"by_principal\",\n        map = \"function(doc) { if (doc.principal && doc.deviceFingerprint && doc.recordDate) { emit(doc.principal, doc) } }\")\n    public List<CouchDbMultifactorAuthenticationTrustRecord> findByPrincipal(final String principal) {\n        val view = createQuery(\"by_principal\").key(principal);\n        return db.queryView(view, CouchDbMultifactorAuthenticationTrustRecord.class);\n    }"}, {"instruction": "------------------------------------------------------------------------", "input": "Java", "output": "@Override\n\tpublic void onTaskFailure(Execution taskExecution, Throwable cause) {\n\t\tfinal ExecutionVertex ev = taskExecution.getVertex();\n\t\tfinal FailoverRegion failoverRegion = vertexToRegion.get(ev);\n\n\t\tif (failoverRegion == null) {\n\t\t\texecutionGraph.failGlobal(new FlinkException(\n\t\t\t\t\t\"Can not find a failover region for the execution \" + ev.getTaskNameWithSubtaskIndex(), cause));\n\t\t}\n\t\telse {\n\t\t\tLOG.info(\"Recovering task failure for {} #{} ({}) via restart of failover region\",\n\t\t\t\t\ttaskExecution.getVertex().getTaskNameWithSubtaskIndex(),\n\t\t\t\t\ttaskExecution.getAttemptNumber(),\n\t\t\t\t\ttaskExecution.getAttemptId());\n\n\t\t\tfailoverRegion.onExecutionFail(taskExecution, cause);\n\t\t}\n\t}"}, {"instruction": "Get metric snapshots for a metric and date specification", "input": "Java", "output": "private void handleGetMetricHistory(final int executorId, final HttpServletRequest req,\n      final HashMap<String, Object> ret, final User user) throws IOException,\n      ServletException {\n    try {\n      final Map<String, Object> result =\n          this.execManagerAdapter.callExecutorStats(executorId,\n              ConnectorParams.STATS_GET_METRICHISTORY, getAllParams(req));\n      if (result.containsKey(ConnectorParams.RESPONSE_ERROR)) {\n        ret.put(ConnectorParams.RESPONSE_ERROR,\n            result.get(ConnectorParams.RESPONSE_ERROR).toString());\n      } else {\n        ret.put(\"data\", result.get(\"data\"));\n      }\n    } catch (final ExecutorManagerException ex) {\n      logger.error(ex.getMessage(), ex);\n      ret.put(\"error\", \"Failed to fetch metric history\");\n    }\n  }"}, {"instruction": "Uploads and registers a single resource and adds it to <tt>localResources</tt>.\n\n@param key\nthe key to add the resource under\n@param fs\nthe remote file system to upload to\n@param appId\napplication ID\n@param localSrcPath\nlocal path to the file\n@param localResources\nmap of resources\n\n@return the remote path to the uploaded resource", "input": "Java", "output": "private static Path setupSingleLocalResource(\n\t\t\tString key,\n\t\t\tFileSystem fs,\n\t\t\tApplicationId appId,\n\t\t\tPath localSrcPath,\n\t\t\tMap<String, LocalResource> localResources,\n\t\t\tPath targetHomeDir,\n\t\t\tString relativeTargetPath) throws IOException, URISyntaxException {\n\n\t\tTuple2<Path, LocalResource> resource = Utils.setupLocalResource(\n\t\t\tfs,\n\t\t\tappId.toString(),\n\t\t\tlocalSrcPath,\n\t\t\ttargetHomeDir,\n\t\t\trelativeTargetPath);\n\n\t\tlocalResources.put(key, resource.f1);\n\n\t\treturn resource.f0;\n\t}"}, {"instruction": "Lists time series that match a filter. This method does not require a Stackdriver account.\n\n<p>Sample code:\n\n<pre><code>\ntry (MetricServiceClient metricServiceClient = MetricServiceClient.create()) {\nProjectName name = ProjectName.of(\"[PROJECT]\");\nString filter = \"\";\nTimeInterval interval = TimeInterval.newBuilder().build();\nListTimeSeriesRequest.TimeSeriesView view = ListTimeSeriesRequest.TimeSeriesView.FULL;\nfor (TimeSeries element : metricServiceClient.listTimeSeries(name, filter, interval, view).iterateAll()) {\n// doThingsWith(element);\n}\n}\n</code></pre>\n\n@param name The project on which to execute the request. The format is\n\"projects/{project_id_or_number}\".\n@param filter A [monitoring filter](/monitoring/api/v3/filters) that specifies which time\nseries should be returned. The filter must specify a single metric type, and can\nadditionally specify metric labels and other information. For example:\n<p>metric.type = \"compute.googleapis.com/instance/cpu/usage_time\" AND\nmetric.label.instance_name = \"my-instance-name\"\n@param interval The time interval for which results should be returned. Only time series that\ncontain data points in the specified interval are included in the response.\n@param view Specifies which information is returned about the time series.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "public final ListTimeSeriesPagedResponse listTimeSeries(\n      ProjectName name,\n      String filter,\n      TimeInterval interval,\n      ListTimeSeriesRequest.TimeSeriesView view) {\n    ListTimeSeriesRequest request =\n        ListTimeSeriesRequest.newBuilder()\n            .setName(name == null ? null : name.toString())\n            .setFilter(filter)\n            .setInterval(interval)\n            .setView(view)\n            .build();\n    return listTimeSeries(request);\n  }"}, {"instruction": "This method initializes logPanel\n\n@return org.parosproxy.paros.extension.history.LogPanel", "input": "Java", "output": "private LogPanel getLogPanel() {\r\n\t\tif (logPanel == null) {\r\n\t\t\tlogPanel = new LogPanel(getView());\r\n\t\t\tlogPanel.setName(Constant.messages.getString(\"history.panel.title\"));\t// ZAP: i18n\r\n\t\t\t// ZAP: Added History (calendar) icon\r\n\t\t\tlogPanel.setIcon(new ImageIcon(ExtensionHistory.class.getResource(\"/resource/icon/16/025.png\")));\t// 'calendar' icon\r\n\t\t\t// Dont allow this tab to be hidden\r\n\t\t\tlogPanel.setHideable(false);\r\n\r\n            logPanel.setExtension(this);\r\n            logPanel.setModel(historyTableModel);\r\n\t\t}\r\n\t\treturn logPanel;\r\n\t}"}, {"instruction": "Create a composition with {@link LottieCompositionFactory}\n\n@return True if the composition is different from the previously set composition, false otherwise.", "input": "Java", "output": "public boolean setComposition(LottieComposition composition) {\n    if (this.composition == composition) {\n      return false;\n    }\n\n    isDirty = false;\n    clearComposition();\n    this.composition = composition;\n    buildCompositionLayer();\n    animator.setComposition(composition);\n    setProgress(animator.getAnimatedFraction());\n    setScale(scale);\n    updateBounds();\n\n    // We copy the tasks to a new ArrayList so that if this method is called from multiple threads,\n    // then there won't be two iterators iterating and removing at the same time.\n    Iterator<LazyCompositionTask> it = new ArrayList<>(lazyCompositionTasks).iterator();\n    while (it.hasNext()) {\n      LazyCompositionTask t = it.next();\n      t.run(composition);\n      it.remove();\n    }\n    lazyCompositionTasks.clear();\n\n    composition.setPerformanceTrackingEnabled(performanceTrackingEnabled);\n\n    return true;\n  }"}, {"instruction": "\u5faa\u73af\u5411\u4e0a\u8f6c\u578b, \u83b7\u53d6\u5bf9\u8c61\u7684DeclaredField, \u5e76\u5f3a\u5236\u8bbe\u7f6e\u4e3a\u53ef\u8bbf\u95ee.\n\n\u5982\u5411\u4e0a\u8f6c\u578b\u5230Object\u4ecd\u65e0\u6cd5\u627e\u5230, \u8fd4\u56denull.\n\n\u56e0\u4e3agetFiled()\u4e0d\u80fd\u83b7\u53d6\u7236\u7c7b\u7684private\u5c5e\u6027, \u56e0\u6b64\u91c7\u7528\u5faa\u73af\u5411\u4e0a\u7684getDeclaredField();", "input": "Java", "output": "public static Field getField(final Class clazz, final String fieldName) {\n\t\tValidate.notNull(clazz, \"clazz can't be null\");\n\t\tValidate.notEmpty(fieldName, \"fieldName can't be blank\");\n\t\tfor (Class<?> superClass = clazz; superClass != Object.class; superClass = superClass.getSuperclass()) {\n\t\t\ttry {\n\t\t\t\tField field = superClass.getDeclaredField(fieldName);\n\t\t\t\tmakeAccessible(field);\n\t\t\t\treturn field;\n\t\t\t} catch (NoSuchFieldException e) {// NOSONAR\n\t\t\t\t// Field\u4e0d\u5728\u5f53\u524d\u7c7b\u5b9a\u4e49,\u7ee7\u7eed\u5411\u4e0a\u8f6c\u578b\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"}, {"instruction": "Save a {@code JavaRDD<List<List<Writable>>>} to a Hadoop {@link org.apache.hadoop.io.SequenceFile}. Each record\nis given a unique (but noncontiguous) {@link LongWritable} key, and values are stored as {@link SequenceRecordWritable} instances.\n<p>\nUse {@link #restoreSequenceFileSequences(String, JavaSparkContext)} to restore values saved with this method.\n\n@param path           Path to save the sequence file\n@param rdd            RDD to save\n@param maxOutputFiles Nullable. If non-null: first coalesce the RDD to the specified size (number of partitions)\nto limit the maximum number of output sequence files\n@see #saveSequenceFile(String, JavaRDD)\n@see #saveMapFileSequences(String, JavaRDD)", "input": "Java", "output": "public static void saveSequenceFileSequences(String path, JavaRDD<List<List<Writable>>> rdd,\n                     Integer maxOutputFiles) {\n        path = FilenameUtils.normalize(path, true);\n        if (maxOutputFiles != null) {\n            rdd = rdd.coalesce(maxOutputFiles);\n        }\n        JavaPairRDD<List<List<Writable>>, Long> dataIndexPairs = rdd.zipWithUniqueId(); //Note: Long values are unique + NOT contiguous; more efficient than zipWithIndex\n        JavaPairRDD<LongWritable, SequenceRecordWritable> keyedByIndex =\n                        dataIndexPairs.mapToPair(new SequenceRecordSavePrepPairFunction());\n\n        keyedByIndex.saveAsNewAPIHadoopFile(path, LongWritable.class, SequenceRecordWritable.class,\n                        SequenceFileOutputFormat.class);\n    }"}, {"instruction": "Initializes the process that periodically fetches CRL data.", "input": "Java", "output": "@SneakyThrows\n    @SuppressWarnings(\"FutureReturnValueIgnored\")\n    public void init() {\n        if (!validateConfiguration()) {\n            return;\n        }\n\n        val results = this.fetcher.fetch(getResources());\n        ResourceCRLRevocationChecker.this.addCrls(results);\n\n        final Runnable scheduledFetcher = () -> {\n            try {\n                val fetchedResults = getFetcher().fetch(getResources());\n                ResourceCRLRevocationChecker.this.addCrls(fetchedResults);\n            } catch (final Exception e) {\n                LOGGER.debug(e.getMessage(), e);\n            }\n        };\n\n        this.scheduler.scheduleAtFixedRate(\n            scheduledFetcher,\n            this.refreshInterval,\n            this.refreshInterval,\n            TimeUnit.SECONDS);\n\n    }"}, {"instruction": "This shuts down the flow runner. The call is blocking and awaits execution of all jobs.", "input": "Java", "output": "public void shutdown() {\n    logger.warn(\"Shutting down FlowRunnerManager...\");\n    if (this.azkabanProps.getBoolean(ConfigurationKeys.AZKABAN_POLL_MODEL, false)) {\n      this.pollingService.shutdown();\n    }\n    this.executorService.shutdown();\n    boolean result = false;\n    while (!result) {\n      logger.info(\"Awaiting Shutdown. # of executing flows: \" + getNumRunningFlows());\n      try {\n        result = this.executorService.awaitTermination(1, TimeUnit.MINUTES);\n      } catch (final InterruptedException e) {\n        logger.error(e);\n      }\n    }\n    logger.warn(\"Shutdown FlowRunnerManager complete.\");\n  }"}, {"instruction": "\u8fde\u63a5\u8f6c\u5b57\u7b26\u4e32\n\n@param local1  \u672c\u5730\u5730\u5740\n@param remote1 \u8fdc\u7a0b\u5730\u5740\n@return \u5730\u5740\u4fe1\u606f\u5b57\u7b26\u4e32", "input": "Java", "output": "public static String channelToString(SocketAddress local1, SocketAddress remote1) {\n        try {\n            InetSocketAddress local = (InetSocketAddress) local1;\n            InetSocketAddress remote = (InetSocketAddress) remote1;\n            return toAddressString(local) + \" -> \" + toAddressString(remote);\n        } catch (Exception e) {\n            return local1 + \"->\" + remote1;\n        }\n    }"}, {"instruction": "Updates all the process definition entities to have the correct diagram resource name.  Must\nbe called after createAndPersistNewDiagramsAsNeeded to ensure that any newly-created diagrams\nalready have their resources attached to the deployment.", "input": "Java", "output": "protected void setProcessDefinitionDiagramNames(ParsedDeployment parsedDeployment) {\n        Map<String, ResourceEntity> resources = parsedDeployment.getDeployment().getResources();\n\n        for (ProcessDefinitionEntity processDefinition : parsedDeployment.getAllProcessDefinitions()) {\n            String diagramResourceName = ResourceNameUtil.getProcessDiagramResourceNameFromDeployment(processDefinition,\n                                                                                                      resources);\n            processDefinition.setDiagramResourceName(diagramResourceName);\n        }\n    }"}, {"instruction": "Reads the contents of the user-specified {@code filePath} based on the given {@link FileInputFormat}.\nDepending on the provided {@link FileProcessingMode}, the source may periodically monitor (every {@code interval} ms)\nthe path for new data ({@link FileProcessingMode#PROCESS_CONTINUOUSLY}), or process once the data currently in the\npath and exit ({@link FileProcessingMode#PROCESS_ONCE}). In addition, if the path contains files not to be processed,\nthe user can specify a custom {@link FilePathFilter}. As a default implementation you can use\n{@link FilePathFilter#createDefaultFilter()}.\n\n<p><b>NOTES ON CHECKPOINTING: </b> If the {@code watchType} is set to {@link FileProcessingMode#PROCESS_ONCE},\nthe source monitors the path <b>once</b>, creates the {@link org.apache.flink.core.fs.FileInputSplit FileInputSplits}\nto be processed, forwards them to the downstream {@link ContinuousFileReaderOperator readers} to read the actual data,\nand exits, without waiting for the readers to finish reading. This implies that no more checkpoint barriers\nare going to be forwarded after the source exits, thus having no checkpoints after that point.\n\n@param inputFormat\nThe input format used to create the data stream\n@param filePath\nThe path of the file, as a URI (e.g., \"file:///some/local/file\" or \"hdfs://host:port/file/path\")\n@param watchType\nThe mode in which the source should operate, i.e. monitor path and react to new data, or process once and exit\n@param typeInformation\nInformation on the type of the elements in the output stream\n@param interval\nIn the case of periodic path monitoring, this specifies the interval (in millis) between consecutive path scans\n@param <OUT>\nThe type of the returned data stream\n@return The data stream that represents the data read from the given file", "input": "Java", "output": "@PublicEvolving\n\tpublic <OUT> DataStreamSource<OUT> readFile(FileInputFormat<OUT> inputFormat,\n\t\t\t\t\t\t\t\t\t\t\t\tString filePath,\n\t\t\t\t\t\t\t\t\t\t\t\tFileProcessingMode watchType,\n\t\t\t\t\t\t\t\t\t\t\t\tlong interval,\n\t\t\t\t\t\t\t\t\t\t\t\tTypeInformation<OUT> typeInformation) {\n\n\t\tPreconditions.checkNotNull(inputFormat, \"InputFormat must not be null.\");\n\t\tPreconditions.checkArgument(!StringUtils.isNullOrWhitespaceOnly(filePath), \"The file path must not be null or blank.\");\n\n\t\tinputFormat.setFilePath(filePath);\n\t\treturn createFileInput(inputFormat, typeInformation, \"Custom File Source\", watchType, interval);\n\t}"}, {"instruction": "Returns a new initialized {@link OpenSslX509KeyManagerFactory} which will provide its private key by using the\n{@link OpenSslPrivateKeyMethod}.", "input": "Java", "output": "public static OpenSslX509KeyManagerFactory newKeyless(X509Certificate... certificateChain)\n            throws CertificateException, IOException,\n            KeyStoreException, NoSuchAlgorithmException, UnrecoverableKeyException {\n        KeyStore store = new OpenSslKeyStore(certificateChain.clone(), true);\n        store.load(null, null);\n        OpenSslX509KeyManagerFactory factory = new OpenSslX509KeyManagerFactory();\n        factory.init(store, null);\n        return factory;\n    }"}, {"instruction": "\u7528\u4e8eModel\u5bf9\u8c61\u8f6c\u5316\u4e3aDO\u5bf9\u8c61", "input": "Java", "output": "private DataMatrixDO modelToDo(DataMatrix matrix) {\n        DataMatrixDO matrixDo = new DataMatrixDO();\n        try {\n            matrixDo.setId(matrix.getId());\n            matrixDo.setGroupKey(matrix.getGroupKey());\n            matrixDo.setDescription(matrix.getDescription());\n            matrixDo.setMaster(matrix.getMaster());\n            matrixDo.setSlave(matrix.getSlave());\n            matrixDo.setGmtCreate(matrix.getGmtCreate());\n            matrixDo.setGmtModified(matrix.getGmtModified());\n        } catch (Exception e) {\n            logger.error(\"ERROR ## change the matrix Model to Do has an exception\");\n            throw new ManagerException(e);\n        }\n        return matrixDo;\n    }"}, {"instruction": "Installs (and sets into the add-on) the resource bundle declared by the given add-on, if any.\n\n@param addOnClassLoader the ClassLoader of the add-on.\n@param addOn the add-on.\n@since TODO add version\n@see AddOn#getBundleData()", "input": "Java", "output": "static void installResourceBundle(AddOnClassLoader addOnClassLoader, AddOn addOn) {\n        AddOn.BundleData bundleData = addOn.getBundleData();\n        if (bundleData.isEmpty()) {\n            return;\n        }\n\n        try {\n            ResourceBundle resourceBundle = ResourceBundle.getBundle(\n                    bundleData.getBaseName(),\n                    Constant.getLocale(),\n                    addOnClassLoader,\n                    new ZapResourceBundleControl());\n            addOn.setResourceBundle(resourceBundle);\n            String bundlePrefix = bundleData.getPrefix();\n            if (!bundlePrefix.isEmpty()) {\n                Constant.messages.addMessageBundle(bundlePrefix, resourceBundle);\n            }\n        } catch (MissingResourceException e) {\n            logger.error(\"Declared bundle not found in \" + addOn.getId() + \" add-on:\", e);\n        }\n    }"}, {"instruction": "If this specified class represents a primitive type (int, float, etc.)\nthen it is translated into its wrapper type (Integer, Float, etc.). If\nthe passed class is not a primitive then it is just returned.\n\n@param primitive class\n@return class", "input": "Java", "output": "private static Class<?> translateFromPrimitive(Class<?> primitive) {\n        if (!primitive.isPrimitive()) {\n            return primitive;\n        }\n\n        if (Boolean.TYPE.equals(primitive)) {\n            return Boolean.class;\n        }\n        if (Character.TYPE.equals(primitive)) {\n            return Character.class;\n        }\n        if (Byte.TYPE.equals(primitive)) {\n            return Byte.class;\n        }\n        if (Short.TYPE.equals(primitive)) {\n            return Short.class;\n        }\n        if (Integer.TYPE.equals(primitive)) {\n            return Integer.class;\n        }\n        if (Long.TYPE.equals(primitive)) {\n            return Long.class;\n        }\n        if (Float.TYPE.equals(primitive)) {\n            return Float.class;\n        }\n        if (Double.TYPE.equals(primitive)) {\n            return Double.class;\n        }\n\n        throw new RuntimeException(\"Error translating type:\" + primitive);\n    }"}, {"instruction": "This method initializes this", "input": "Java", "output": "private void initialize() {\r\n        this.setName(Constant.messages.getString(\"pscan.options.name\"));\r\n        this.setLayout(new GridBagLayout());\r\n\r\n        GridBagConstraints gbc = new GridBagConstraints();\r\n        gbc.gridx = 0;\r\n        gbc.weightx = 1.0;\r\n        gbc.anchor = GridBagConstraints.LINE_START;\r\n        gbc.fill = GridBagConstraints.BOTH;\r\n        \r\n        this.add(new JLabel(Constant.messages.getString(\"pscan.options.header\")), gbc);\r\n\r\n        scannersOptionsPanel = new ScannersMultipleOptionsPanel(getTableModel());\r\n        \r\n        gbc.weighty = 1.0;\r\n        this.add(scannersOptionsPanel, gbc);\r\n        \r\n        //gbc.weighty = 0.0;\r\n\t}"}, {"instruction": "Prints out the command line to the listener with some portions masked to prevent sensitive information from being\nrecorded on the listener.\n\n@param cmd     The commands\n@param mask    An array of booleans which control whether a cmd element should be masked (<code>true</code>) or\nremain unmasked (<code>false</code>).\n@param workDir The work dir.", "input": "Java", "output": "protected final void maskedPrintCommandLine(@Nonnull List<String> cmd, @CheckForNull boolean[] mask, @CheckForNull FilePath workDir) {\n        if(mask==null) {\n            printCommandLine(cmd.toArray(new String[0]),workDir);\n            return;\n        }\n        \n        assert mask.length == cmd.size();\n        final String[] masked = new String[cmd.size()];\n        for (int i = 0; i < cmd.size(); i++) {\n            if (mask[i]) {\n                masked[i] = \"********\";\n            } else {\n                masked[i] = cmd.get(i);\n            }\n        }\n        printCommandLine(masked, workDir);\n    }"}, {"instruction": "Enough attributes available to process? Check collection sizes and determine\nif we have enough data to move on.\n\n@param principal           the principal\n@param principalAttributes the principal attributes\n@return true /false", "input": "Java", "output": "protected boolean enoughAttributesAvailableToProcess(final String principal, final Map<String, Object> principalAttributes) {\n        if (!enoughRequiredAttributesAvailableToProcess(principalAttributes, this.requiredAttributes)) {\n            return false;\n        }\n        if (principalAttributes.size() < this.rejectedAttributes.size()) {\n            LOGGER.debug(\"The size of the principal attributes that are [{}] does not match defined rejected attributes, \"\n                + \"which means the principal is not carrying enough data to grant authorization\", principalAttributes);\n            return false;\n        }\n        return true;\n    }"}, {"instruction": "\u7528\u4e8eModel\u5bf9\u8c61\u8f6c\u5316\u4e3aDO\u5bf9\u8c61\n\n@param tableStat\n@return TableStatDO", "input": "Java", "output": "private TableStatDO tableStatModelToDo(TableStat tableStat) {\n        TableStatDO tableStatDO = new TableStatDO();\n        tableStatDO.setId(tableStat.getId());\n        tableStatDO.setPipelineId(tableStat.getPipelineId());\n        tableStatDO.setDataMediaPairId(tableStat.getDataMediaPairId());\n        tableStatDO.setFileSize(tableStat.getFileSize());\n        tableStatDO.setFileCount(tableStat.getFileCount());\n        tableStatDO.setDeleteCount(tableStat.getDeleteCount());\n        tableStatDO.setInsertCount(tableStat.getInsertCount());\n        tableStatDO.setUpdateCount(tableStat.getUpdateCount());\n        tableStatDO.setGmtCreate(tableStat.getGmtCreate());\n        tableStatDO.setGmtModified(tableStat.getGmtModified());\n        return tableStatDO;\n\n    }"}, {"instruction": "Create the dimensions for the flatbuffer builder\n@param bufferBuilder the buffer builder to use\n@param arr the input array\n@return", "input": "Java", "output": "public static int createDims(FlatBufferBuilder bufferBuilder,INDArray arr) {\n        int[] tensorDimOffsets = new int[arr.rank()];\n        int[] nameOffset = new int[arr.rank()];\n        for(int i = 0; i < tensorDimOffsets.length; i++) {\n            nameOffset[i] = bufferBuilder.createString(\"\");\n            tensorDimOffsets[i] = TensorDim.createTensorDim(bufferBuilder,arr.size(i),nameOffset[i]);\n        }\n\n        return Tensor.createShapeVector(bufferBuilder,tensorDimOffsets);\n    }"}, {"instruction": "Patches the specified SSL policy with the data included in the request.\n\n<p>Sample code:\n\n<pre><code>\ntry (SslPolicyClient sslPolicyClient = SslPolicyClient.create()) {\nProjectGlobalSslPolicyName sslPolicy = ProjectGlobalSslPolicyName.of(\"[PROJECT]\", \"[SSL_POLICY]\");\nSslPolicy sslPolicyResource = SslPolicy.newBuilder().build();\nList&lt;String&gt; fieldMask = new ArrayList&lt;&gt;();\nOperation response = sslPolicyClient.patchSslPolicy(sslPolicy, sslPolicyResource, fieldMask);\n}\n</code></pre>\n\n@param sslPolicy Name of the SSL policy to update. The name must be 1-63 characters long, and\ncomply with RFC1035.\n@param sslPolicyResource A SSL policy specifies the server-side support for SSL features. This\ncan be attached to a TargetHttpsProxy or a TargetSslProxy. This affects connections between\nclients and the HTTPS or SSL proxy load balancer. They do not affect the connection between\nthe load balancers and the backends.\n@param fieldMask The fields that should be serialized (even if they have empty values). If the\ncontaining message object has a non-null fieldmask, then all the fields in the field mask\n(and only those fields in the field mask) will be serialized. If the containing object does\nnot have a fieldmask, then only non-empty fields will be serialized.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation patchSslPolicy(\n      ProjectGlobalSslPolicyName sslPolicy, SslPolicy sslPolicyResource, List<String> fieldMask) {\n\n    PatchSslPolicyHttpRequest request =\n        PatchSslPolicyHttpRequest.newBuilder()\n            .setSslPolicy(sslPolicy == null ? null : sslPolicy.toString())\n            .setSslPolicyResource(sslPolicyResource)\n            .addAllFieldMask(fieldMask)\n            .build();\n    return patchSslPolicy(request);\n  }"}, {"instruction": "Sends a {@code RST_STREAM} frame even if we don't know about the stream. This error condition is most likely\ntriggered by the first frame of a stream being invalid. That is, there was an error reading the frame before\nwe could create a new stream.", "input": "Java", "output": "private ChannelFuture resetUnknownStream(final ChannelHandlerContext ctx, int streamId, long errorCode,\n                                             ChannelPromise promise) {\n        ChannelFuture future = frameWriter().writeRstStream(ctx, streamId, errorCode, promise);\n        if (future.isDone()) {\n            closeConnectionOnError(ctx, future);\n        } else {\n            future.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    closeConnectionOnError(ctx, future);\n                }\n            });\n        }\n        return future;\n    }"}, {"instruction": "Given all of the thread pool configuration, what is the actual maximumSize applied to the thread pool\nvia {@link ThreadPoolExecutor#setMaximumPoolSize(int)}\n\nCases:\n1) allowMaximumSizeToDivergeFromCoreSize == false: maximumSize is set to coreSize\n2) allowMaximumSizeToDivergeFromCoreSize == true, maximumSize >= coreSize: thread pool has different core/max sizes, so return the configured max\n3) allowMaximumSizeToDivergeFromCoreSize == true, maximumSize < coreSize: threadpool incorrectly configured, use coreSize for max size\n@return actually configured maximum size of threadpool", "input": "Java", "output": "public Integer actualMaximumSize() {\n        final int coreSize = coreSize().get();\n        final int maximumSize = maximumSize().get();\n        if (getAllowMaximumSizeToDivergeFromCoreSize().get()) {\n            if (coreSize > maximumSize) {\n                return coreSize;\n            } else {\n                return maximumSize;\n            }\n        } else {\n            return coreSize;\n        }\n    }"}, {"instruction": "Convert the \"messy\" min/max values on a dataset to something clean. For example, 0.895732 becomes 1.0\n\n@param max   Maximum data point value\n@param min   Minimum data point value\n@param nTick Number of tick marks desired on chart (good setting: 5)\n@return double[] of length 2 - with new minimum and maximum", "input": "Java", "output": "public static double[] graphNiceRange(double max, double min, int nTick){\n        if(max == min || !Double.isFinite(max)){\n            if(max == 0.0 || !Double.isFinite(max)){\n                return new double[]{0.0, 1.0};\n            }\n\n            return graphNiceRange(1.5 * max, 0.5 * max, nTick);\n        }\n\n        double range = niceNum(max-min, false);\n        double d = niceNum(range / (nTick-1), true );\n        double graphMin = Math.floor(min/d)*d;\n        double graphMax = Math.ceil(max/d)*d;\n\n\n        return new double[]{graphMin, graphMax};\n    }"}, {"instruction": "Creates a new data stream that contains the given elements. The elements must all be of the\nsame type, for example, all of the {@link String} or {@link Integer}.\n\n<p>The framework will try and determine the exact type from the elements. In case of generic\nelements, it may be necessary to manually supply the type information via\n{@link #fromCollection(java.util.Collection, org.apache.flink.api.common.typeinfo.TypeInformation)}.\n\n<p>Note that this operation will result in a non-parallel data stream source, i.e. a data\nstream source with a degree of parallelism one.\n\n@param data\nThe array of elements to create the data stream from.\n@param <OUT>\nThe type of the returned data stream\n@return The data stream representing the given array of elements", "input": "Java", "output": "@SafeVarargs\n\tpublic final <OUT> DataStreamSource<OUT> fromElements(OUT... data) {\n\t\tif (data.length == 0) {\n\t\t\tthrow new IllegalArgumentException(\"fromElements needs at least one element as argument\");\n\t\t}\n\n\t\tTypeInformation<OUT> typeInfo;\n\t\ttry {\n\t\t\ttypeInfo = TypeExtractor.getForObject(data[0]);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new RuntimeException(\"Could not create TypeInformation for type \" + data[0].getClass().getName()\n\t\t\t\t\t+ \"; please specify the TypeInformation manually via \"\n\t\t\t\t\t+ \"StreamExecutionEnvironment#fromElements(Collection, TypeInformation)\", e);\n\t\t}\n\t\treturn fromCollection(Arrays.asList(data), typeInfo);\n\t}"}, {"instruction": "Returns a {@link Set} view of the mappings contained in this map.  The\nset is backed by the map, so changes to the map are reflected in the\nset, and vice-versa.  The set supports element removal, which removes\nthe corresponding mapping from the map, via the\n<tt>Iterator.remove</tt>, <tt>Set.remove</tt>, <tt>removeAll</tt>,\n<tt>retainAll</tt>, and <tt>clear</tt> operations.  It does not support\nthe <tt>add</tt> or <tt>addAll</tt> operations.\n\n<p>The view's <tt>iterator</tt> is a \"weakly consistent\" iterator\nthat will never throw {@link ConcurrentModificationException},\nand guarantees to traverse elements as they existed upon\nconstruction of the iterator, and may (but is not guaranteed to)\nreflect any modifications subsequent to construction.\n\n<p><strong>Warning:</strong> the iterator associated with this Set\nrequires the creation of {@link java.util.Map.Entry} objects with each\niteration.  The org.cliffc.high_scale_lib.NonBlockingHashMap\ndoes not normally create or using {@link java.util.Map.Entry} objects so\nthey will be created soley to support this iteration.  Iterating using\n{@link #keySet} or {@link #values} will be more efficient.  In addition,\nthis version requires <strong>auto-boxing</strong> the keys.", "input": "Java", "output": "public Set<Map.Entry<Long,TypeV>> entrySet() {\n    return new AbstractSet<Map.Entry<Long,TypeV>>() {\n      public void    clear   (          ) {        NonBlockingHashMapLong.this.clear( ); }\n      public int     size    (          ) { return NonBlockingHashMapLong.this.size ( ); }\n      public boolean remove( final Object o ) {\n        if (!(o instanceof Map.Entry)) return false;\n        final Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n        return NonBlockingHashMapLong.this.remove(e.getKey(), e.getValue());\n      }\n      public boolean contains(final Object o) {\n        if (!(o instanceof Map.Entry)) return false;\n        final Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n        TypeV v = get(e.getKey());\n        return v.equals(e.getValue());\n      }\n      public Iterator<Map.Entry<Long,TypeV>> iterator() { return new SnapshotE(); }\n    };\n  }"}, {"instruction": "Normalize the URL for use in the signature. The OAuth spec says the URL protocol and host are to be lower-case,\nand the query and fragments are to be stripped.\n\n@param url The URL.\n@return The URL normalized for use in the signature.", "input": "Java", "output": "protected String normalizeUrl(String url) {\n    try {\n      URL requestURL = new URL(url);\n      StringBuilder normalized = new StringBuilder(requestURL.getProtocol().toLowerCase()).append(\"://\").append(requestURL.getHost().toLowerCase());\n      if ((requestURL.getPort() >= 0) && (requestURL.getPort() != requestURL.getDefaultPort())) {\n        normalized.append(\":\").append(requestURL.getPort());\n      }\n      normalized.append(requestURL.getPath());\n      return normalized.toString();\n    }\n    catch (MalformedURLException e) {\n      throw new IllegalStateException(\"Illegal URL for calculating the OAuth signature.\", e);\n    }\n  }"}, {"instruction": "\u65b9\u6cd5\u662f\u5426\u4e3aGetter\u65b9\u6cd5<br>\n\u5339\u914d\u89c4\u5219\u5982\u4e0b\uff08\u5ffd\u7565\u5927\u5c0f\u5199\uff09\uff1a\n\n<pre>\n\u5b57\u6bb5\u540d    -\u300b \u65b9\u6cd5\u540d\nisName  -\u300b isName\nisName  -\u300b isIsName\nisName  -\u300b getIsName\nname     -\u300b isName\nname     -\u300b getName\n</pre>\n\n@param methodName \u65b9\u6cd5\u540d\n@param fieldName \u5b57\u6bb5\u540d\n@param isBooeanField \u662f\u5426\u4e3aBoolean\u7c7b\u578b\u5b57\u6bb5\n@return \u662f\u5426\u5339\u914d", "input": "Java", "output": "private boolean isMatchGetter(String methodName, String fieldName, boolean isBooeanField) {\r\n\t\t// \u5168\u90e8\u8f6c\u4e3a\u5c0f\u5199\uff0c\u5ffd\u7565\u5927\u5c0f\u5199\u6bd4\u8f83\r\n\t\tmethodName = methodName.toLowerCase();\r\n\t\tfieldName = fieldName.toLowerCase();\r\n\r\n\t\tif (false == methodName.startsWith(\"get\") && false == methodName.startsWith(\"is\")) {\r\n\t\t\t// \u975e\u6807\u51c6Getter\u65b9\u6cd5\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif(\"getclass\".equals(methodName)) {\r\n\t\t\t//\u8df3\u8fc7getClass\u65b9\u6cd5\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// \u9488\u5bf9Boolean\u7c7b\u578b\u7279\u6b8a\u68c0\u67e5\r\n\t\tif (isBooeanField) {\r\n\t\t\tif (fieldName.startsWith(\"is\")) {\r\n\t\t\t\t// \u5b57\u6bb5\u5df2\u7ecf\u662fis\u5f00\u5934\r\n\t\t\t\tif (methodName.equals(fieldName) // isName -\u300b isName\r\n\t\t\t\t\t\t|| methodName.equals(\"get\" + fieldName)// isName -\u300b getIsName\r\n\t\t\t\t\t\t|| methodName.equals(\"is\" + fieldName)// isName -\u300b isIsName\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t} else if (methodName.equals(\"is\" + fieldName)) {\r\n\t\t\t\t// \u5b57\u6bb5\u975eis\u5f00\u5934\uff0c name -\u300b isName\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// \u5305\u62ecboolean\u7684\u4efb\u4f55\u7c7b\u578b\u53ea\u6709\u4e00\u79cd\u5339\u914d\u60c5\u51b5\uff1aname -\u300b getName\r\n\t\treturn methodName.equals(\"get\" + fieldName);\r\n\t}"}, {"instruction": "VJ: \u52a0\u4e0asymbolType instanceof JavaType\u7684\u5224\u65ad\uff0c\u9632\u6b62\u6570\u7ec4\u8f6c\u6362\u51fa\u9519", "input": "Java", "output": "private static boolean isConstantType(Type symbolType) {\n\t\treturn symbolType.isPrimitive() || symbolType.is(\"java.lang.String\") ||  symbolType.is(\"java.lang.Byte\") ||\n\t\t\t\tsymbolType.is(\"java.lang.Character\") ||\n\t\t\t\tsymbolType.is(\"java.lang.Short\") ||\n\t\t\t\tsymbolType.is(\"java.lang.Integer\") ||\n\t\t\t\tsymbolType.is(\"java.lang.Long\") ||\n\t\t\t\tsymbolType.is(\"java.lang.Float\") ||\n\t\t\t\tsymbolType.is(\"java.lang.Double\") ||\n\t\t\t\tsymbolType.is(\"java.lang.Boolean\");\n\t}"}, {"instruction": "Writes the request headers to the given {@link HttpConnection connection}.\n\n<p>\nThis implementation invokes {@link #addRequestHeaders(HttpState,HttpConnection)},\nand then writes each header to the request stream.\n</p>\n\n<p>\nSubclasses may want to override this method to to customize the\nprocessing.\n</p>\n\n@param state the {@link HttpState state} information associated with this method\n@param conn the {@link HttpConnection connection} used to execute\nthis HTTP method\n\n@throws IOException if an I/O (transport) error occurs. Some transport exceptions\ncan be recovered from.\n@throws HttpException  if a protocol exception occurs. Usually protocol exceptions\ncannot be recovered from.\n\n@see #addRequestHeaders\n@see #getRequestHeaders", "input": "Java", "output": "protected void writeRequestHeaders(HttpState state, HttpConnection conn)\n    throws IOException, HttpException {\n        LOG.trace(\"enter HttpMethodBase.writeRequestHeaders(HttpState,\"\n            + \"HttpConnection)\");\n        addRequestHeaders(state, conn);\n\n        String charset = getParams().getHttpElementCharset();\n        \n        Header[] headers = getRequestHeaders();\n        for (int i = 0; i < headers.length; i++) {\n            String s = headers[i].toExternalForm();\n            if (Wire.HEADER_WIRE.enabled()) {\n                Wire.HEADER_WIRE.output(s);\n            }\n            conn.print(s, charset);\n        }\n    }"}, {"instruction": "Sets the position of the response panel. Should be considered a hint, not all workbench layouts might use this setting.\n<p>\nIf the position is already set no further action is taken, otherwise updates the main tool bar buttons, the workbench\npanel and the configurations file.\n\n@param position the new position of the response panel\n@throws IllegalArgumentException if the given parameter is {@code null}.\n@since 2.5.0\n@see #getResponsePanelPosition()\n@see #setWorkbenchLayout(org.parosproxy.paros.view.WorkbenchPanel.Layout)", "input": "Java", "output": "public void setResponsePanelPosition(WorkbenchPanel.ResponsePanelPosition position) {\r\n\t\tif (position == null) {\r\n\t\t\tthrow new IllegalArgumentException(\"Parameter position must not be null.\");\r\n\t\t}\r\n\r\n\t\tif (responsePanelPosition == position) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tresponsePanelPosition = position;\r\n\r\n\t\tswitch (position) {\r\n\t\tcase PANEL_ABOVE:\r\n\t\t\taboveResponsePanelPositionButton.setSelected(true);\r\n\t\t\tbreak;\r\n\t\tcase PANELS_SIDE_BY_SIDE:\r\n\t\t\tpanelsResponsePanelPositionButton.setSelected(true);\r\n\t\t\tbreak;\r\n\t\tcase TAB_SIDE_BY_SIDE:\r\n\t\t\ttabSideBySideResponsePanelPositionButton.setSelected(true);\r\n\t\t\tbreak;\r\n\t\tcase TABS_SIDE_BY_SIDE:\r\n\t\tdefault:\r\n\t\t\ttabsResponsePanelPositionButton.setSelected(true);\r\n\t\t}\r\n\r\n\t\tgetWorkbench().setResponsePanelPosition(responsePanelPosition);\r\n\t\toptions.getViewParam().setResponsePanelPosition(responsePanelPosition.toString());\r\n\t}"}, {"instruction": "*************************************************************************\n* Setters / Getters * *\n************************************************************************", "input": "Java", "output": "public void setControl(Node control) {\n        if (control != null) {\n            this.control = control;\n            this.badge = new Group();\n            this.getChildren().add(control);\n            this.getChildren().add(badge);\n\n            // if the control got resized the badge must be rest\n            if (control instanceof Region) {\n                ((Region) control).widthProperty().addListener((o, oldVal, newVal) -> refreshBadge());\n                ((Region) control).heightProperty().addListener((o, oldVal, newVal) -> refreshBadge());\n            }\n            text.addListener((o, oldVal, newVal) -> refreshBadge());\n        }\n    }"}, {"instruction": "Evaluation for multiple-output networks.<br>\nSee {@link #evaluate(MultiDataSetIterator, Map, Map)}", "input": "Java", "output": "public void evaluate(DataSetIterator iterator, Map<String,IEvaluation> variableEvals){\n        Map<String,Integer> map = new HashMap<>();\n        Map<String,List<IEvaluation>> variableEvalsList = new HashMap<>();\n        for(String s : variableEvals.keySet()){\n            map.put(s, 0);  //Only 1 possible output here with DataSetIterator\n            variableEvalsList.put(s, Collections.singletonList(variableEvals.get(s)));\n        }\n        evaluate(new MultiDataSetIteratorAdapter(iterator), variableEvalsList, map);\n    }"}, {"instruction": "Parse the from clause\nzhongshu-comment \u53ea\u89e3\u6790\u4e86\u4e00\u822c\u67e5\u8be2\u548cjoin\u67e5\u8be2\uff0c\u6ca1\u6709\u89e3\u6790\u5b50\u67e5\u8be2\n@param from the from clause.\n@return list of From objects represents all the sources.", "input": "Java", "output": "private List<From> findFrom(SQLTableSource from) {\n        //zhongshu-comment class1.isAssignableFrom(class2) class2\u662f\u4e0d\u662fclass1\u7684\u5b50\u7c7b\u6216\u8005\u5b50\u63a5\u53e3\n        //\u6539\u6210\u7528instanceof \u5e94\u8be5\u4e5f\u884c\u5427\uff1afrom instanceof SQLExprTableSource\n        boolean isSqlExprTable = from.getClass().isAssignableFrom(SQLExprTableSource.class);\n\n        if (isSqlExprTable) {\n            SQLExprTableSource fromExpr = (SQLExprTableSource) from;\n            String[] split = fromExpr.getExpr().toString().split(\",\");\n\n            ArrayList<From> fromList = new ArrayList<>();\n            for (String source : split) {\n                fromList.add(new From(source.trim(), fromExpr.getAlias()));\n            }\n            return fromList;\n        }\n\n        SQLJoinTableSource joinTableSource = ((SQLJoinTableSource) from);\n        List<From> fromList = new ArrayList<>();\n        fromList.addAll(findFrom(joinTableSource.getLeft()));\n        fromList.addAll(findFrom(joinTableSource.getRight()));\n        return fromList;\n    }"}, {"instruction": "This method converts existing X509TrustManagers to ClientX509ExtendedTrustManagers.\n\n@param trustManagers\n@param tlsConfig\n@return", "input": "Java", "output": "public static TrustManager[] decorate(TrustManager[] trustManagers, TLSConfig tlsConfig) {\n\t\tif (null!=trustManagers && trustManagers.length>0) {\n\t\t\tTrustManager[] decoratedTrustManagers = new TrustManager[trustManagers.length];\n\t\t\t\n\t\t\tfor (int i=0; i<trustManagers.length; ++i) {\n\t\t\t\tTrustManager trustManager = trustManagers[i];\n\t\t\t\t\n\t\t\t\tif (trustManager instanceof X509TrustManager){\n\t\t\t\t\tdecoratedTrustManagers[i] = new ClientX509ExtendedTrustManager((X509TrustManager)trustManager, tlsConfig);\n\t\t\t\t}else {\n\t\t\t\t\tdecoratedTrustManagers[i] = trustManager;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn decoratedTrustManagers;\n\t\t}\n\t\t\n\t\treturn trustManagers;\n\t}"}, {"instruction": "Convert a SQL search pattern into an equivalent Java Regex.\n\n@param pattern input which may contain '%' or '_' wildcard characters, or\nthese characters escaped using {@code getSearchStringEscape()}.\n@return replace %/_ with regex search characters, also handle escaped\ncharacters.", "input": "Java", "output": "public static String patternToRegex(String pattern) {\n    if (pattern == null) {\n      return \".*\";\n    } else {\n      StringBuilder result = new StringBuilder(pattern.length());\n\n      boolean escaped = false;\n      for (int i = 0, len = pattern.length(); i < len; i++) {\n        char c = pattern.charAt(i);\n        if (escaped) {\n          if (c != SEARCH_STRING_ESCAPE) {\n            escaped = false;\n          }\n          result.append(c);\n        } else {\n          if (c == SEARCH_STRING_ESCAPE) {\n            escaped = true;\n            continue;\n          } else if (c == '%') {\n            result.append(\".*\");\n          } else if (c == '_') {\n            result.append('.');\n          } else {\n            result.append(Character.toLowerCase(c));\n          }\n        }\n      }\n      return result.toString();\n    }\n  }"}, {"instruction": "Exclusive buffer is recycled to this input channel directly and it may trigger return extra\nfloating buffer and notify increased credit to the producer.\n\n@param segment The exclusive segment of this channel.", "input": "Java", "output": "@Override\n\tpublic void recycle(MemorySegment segment) {\n\t\tint numAddedBuffers;\n\n\t\tsynchronized (bufferQueue) {\n\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n\t\t\t// after releaseAllResources() released all buffers (see below for details).\n\t\t\tif (isReleased.get()) {\n\t\t\t\ttry {\n\t\t\t\t\tinputGate.returnExclusiveSegments(Collections.singletonList(segment));\n\t\t\t\t\treturn;\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tExceptionUtils.rethrow(t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n\t\t}\n\n\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n\t\t\tnotifyCreditAvailable();\n\t\t}\n\t}"}, {"instruction": "\u6bd4\u8f83\u4e24\u4e2a\u6587\u4ef6\u5185\u5bb9\u662f\u5426\u76f8\u540c<br>\n\u9996\u5148\u6bd4\u8f83\u957f\u5ea6\uff0c\u957f\u5ea6\u4e00\u81f4\u518d\u6bd4\u8f83\u5185\u5bb9\uff0c\u6bd4\u8f83\u5185\u5bb9\u91c7\u7528\u6309\u884c\u8bfb\u53d6\uff0c\u6bcf\u884c\u6bd4\u8f83<br>\n\u6b64\u65b9\u6cd5\u6765\u81eaApache Commons io\n\n@param file1 \u6587\u4ef61\n@param file2 \u6587\u4ef62\n@param charset \u7f16\u7801\uff0cnull\u8868\u793a\u4f7f\u7528\u5e73\u53f0\u9ed8\u8ba4\u7f16\u7801 \u4e24\u4e2a\u6587\u4ef6\u5185\u5bb9\u4e00\u81f4\u8fd4\u56detrue\uff0c\u5426\u5219false\n@throws IORuntimeException IO\u5f02\u5e38\n@since 4.0.6", "input": "Java", "output": "public static boolean contentEqualsIgnoreEOL(File file1, File file2, Charset charset) throws IORuntimeException {\r\n\t\tboolean file1Exists = file1.exists();\r\n\t\tif (file1Exists != file2.exists()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (!file1Exists) {\r\n\t\t\t// \u4e24\u4e2a\u6587\u4ef6\u90fd\u4e0d\u5b58\u5728\uff0c\u8fd4\u56detrue\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (file1.isDirectory() || file2.isDirectory()) {\r\n\t\t\t// \u4e0d\u6bd4\u8f83\u76ee\u5f55\r\n\t\t\tthrow new IORuntimeException(\"Can't compare directories, only files\");\r\n\t\t}\r\n\r\n\t\tif (equals(file1, file2)) {\r\n\t\t\t// \u540c\u4e00\u4e2a\u6587\u4ef6\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tReader input1 = null;\r\n\t\tReader input2 = null;\r\n\t\ttry {\r\n\t\t\tinput1 = getReader(file1, charset);\r\n\t\t\tinput2 = getReader(file2, charset);\r\n\t\t\treturn IoUtil.contentEqualsIgnoreEOL(input1, input2);\r\n\t\t} finally {\r\n\t\t\tIoUtil.close(input1);\r\n\t\t\tIoUtil.close(input2);\r\n\t\t}\r\n\t}"}, {"instruction": "region AbstractService Implementation", "input": "Java", "output": "@Override\n    protected void doStart() {\n        log.info(\"{}: Starting.\", this.traceObjectId);\n\n        Services.startAsync(this.durableLog, this.executor)\n                .thenComposeAsync(v -> startWhenDurableLogOnline(), this.executor)\n                .whenComplete((v, ex) -> {\n                    if (ex == null) {\n                        // We are started and ready to accept requests when DurableLog starts. All other (secondary) services\n                        // are not required for accepting new operations and can still start in the background.\n                        notifyStarted();\n                    } else {\n                        doStop(ex);\n                    }\n                });\n    }"}, {"instruction": "Create generate service ticket action.\n\n@param flow the flow", "input": "Java", "output": "protected void createGenerateServiceTicketAction(final Flow flow) {\n        val handler = createActionState(flow,\n            CasWebflowConstants.STATE_ID_GENERATE_SERVICE_TICKET,\n            createEvaluateAction(CasWebflowConstants.ACTION_ID_GENERATE_SERVICE_TICKET));\n        createTransitionForState(handler, CasWebflowConstants.TRANSITION_ID_SUCCESS, CasWebflowConstants.STATE_ID_REDIRECT);\n        createTransitionForState(handler, CasWebflowConstants.TRANSITION_ID_WARN, CasWebflowConstants.STATE_ID_WARN);\n        createTransitionForState(handler, CasWebflowConstants.TRANSITION_ID_AUTHENTICATION_FAILURE, CasWebflowConstants.STATE_ID_HANDLE_AUTHN_FAILURE);\n        createTransitionForState(handler, CasWebflowConstants.TRANSITION_ID_ERROR, CasWebflowConstants.STATE_ID_INIT_LOGIN_FORM);\n        createTransitionForState(handler, CasWebflowConstants.TRANSITION_ID_GATEWAY, CasWebflowConstants.STATE_ID_GATEWAY_SERVICES_MGMT_CHECK);\n    }"}, {"instruction": "Internal method that sets a variable without validating the script name.\n\n@param scriptName the name of the script.\n@param key the key of the variable.\n@param value the value of the variable.", "input": "Java", "output": "private static void setScriptVarImpl(String scriptName, String key, String value) {\t\n\t\tvalidateKey(key);\n\t\t\n\t\tMap<String, String> scVars = scriptVars\n\t\t\t\t.computeIfAbsent(scriptName, k -> Collections.synchronizedMap(new HashMap<String, String>()));\n\t\t\n\t\tif (value == null) {\n\t\t\tscVars.remove(key);\n\t\t} else {\n\t\t\tvalidateValueLength(value);\n\t\t\tif (scVars.size() > MAX_SCRIPT_VARS) {\n\t\t\t\tthrow new IllegalArgumentException(\"Maximum number of script variables reached: \" + MAX_SCRIPT_VARS);\n\t\t\t}\n\t\t\tscVars.put(key, value);\n\t\t}\n\t}"}, {"instruction": "{@inheritDoc}", "input": "Java", "output": "@Override\n    public double f1Score(INDArray examples, INDArray labels) {\n        if (examples.rank() == 3)\n            examples = TimeSeriesUtils.reshape3dTo2d(examples, LayerWorkspaceMgr.noWorkspaces(), ArrayType.ACTIVATIONS);\n        if (labels.rank() == 3)\n            labels = TimeSeriesUtils.reshape3dTo2d(labels, LayerWorkspaceMgr.noWorkspaces(), ArrayType.ACTIVATIONS);\n        return super.f1Score(examples, labels);\n    }"}, {"instruction": "Process one training row at a time (online learning)\n@param seed Seed is only used if reproducible mode is enabled\n@param r Row (must be dense for now)\n@param mb mini-batch internal index", "input": "Java", "output": "@Override public final void processRow(long seed, DataInfo.Row r, int mb) {\n    if (_localmodel.get_params()._reproducible) {\n      seed += _localmodel.get_processed_global(); //avoid periodicity\n    } else {\n      seed = _dropout_rng.nextLong(); // non-reproducible case - make a fast & good random number\n    }\n    _localmodel.checkMissingCats(r.binIds);\n    ((Neurons.Input) _neurons[0]).setInput(seed, r.isSparse() ? r.numIds : null, r.numVals, r.nBins, r.binIds, mb);\n  }"}, {"instruction": "Instrumentation for RxJava 1 using function with {@link io.micronaut.tracing.instrument.util.TracingRunnable}..\n\n@param instrumenter A function that instruments an existing Runnable with {@link io.micronaut.tracing.instrument.util.TracingRunnable}.", "input": "Java", "output": "@PostConstruct\n    void init(TracingRunnableInstrumenter instrumenter) {\n        if (instrumenter != null) {\n            Func1<Action0, Action0> existing = RxJavaHooks.getOnScheduleAction();\n            if (existing != null && !(existing instanceof InstrumentScheduleAction)) {\n                RxJavaHooks.setOnScheduleAction(action0 ->\n                        new InstrumentScheduleAction(instrumenter).call(existing.call(action0))\n                );\n            } else {\n                RxJavaHooks.setOnScheduleAction(new InstrumentScheduleAction(instrumenter));\n            }\n        }\n    }"}, {"instruction": "Register an instance.\n\n@param registration registration info\n@param builder      UriComponentsBuilder\n@return The registered instance id;", "input": "Java", "output": "@PostMapping(path = \"/instances\", consumes = MediaType.APPLICATION_JSON_VALUE)\n    public Mono<ResponseEntity<Map<String, InstanceId>>> register(@RequestBody Registration registration,\n                                                                  UriComponentsBuilder builder) {\n        Registration withSource = Registration.copyOf(registration).source(\"http-api\").build();\n        LOGGER.debug(\"Register instance {}\", withSource);\n        return registry.register(withSource).map(id -> {\n            URI location = builder.replacePath(\"/instances/{id}\").buildAndExpand(id).toUri();\n            return ResponseEntity.created(location).body(Collections.singletonMap(\"id\", id));\n        });\n    }"}, {"instruction": "\u63d0\u4ea4\u6279\u6b21", "input": "Java", "output": "public void commit() {\n        if (getBulk().numberOfActions() > 0) {\n            BulkResponse response = getBulk().execute().actionGet();\n            if (response.hasFailures()) {\n                for (BulkItemResponse itemResponse : response.getItems()) {\n                    if (!itemResponse.isFailed()) {\n                        continue;\n                    }\n\n                    if (itemResponse.getFailure().getStatus() == RestStatus.NOT_FOUND) {\n                        logger.error(itemResponse.getFailureMessage());\n                    } else {\n                        throw new RuntimeException(\"ES sync commit error\" + itemResponse.getFailureMessage());\n                    }\n                }\n            }\n        }\n    }"}, {"instruction": "Visits a pre-destroy method injection point.\n\n@param declaringType The declaring type of the method. Either a Class or a string representing the name of the type\n@param returnType    The return type of the method\n@param methodName    The method name", "input": "Java", "output": "public void visitPreDestroyMethod(Object declaringType,\n                                      Object returnType,\n                                      String methodName) {\n        visitPreDestroyMethodDefinition();\n        final MethodVisitData methodVisitData = new MethodVisitData(\n                declaringType,\n                false,\n                returnType,\n                methodName,\n                Collections.emptyMap(),\n                Collections.emptyMap(),\n                Collections.emptyMap(),\n                AnnotationMetadata.EMPTY_METADATA);\n        preDestroyMethodVisits.add(methodVisitData);\n        visitMethodInjectionPointInternal(methodVisitData,\n                constructorVisitor,\n                preDestroyMethodVisitor,\n                preDestroyInstanceIndex,\n                ADD_PRE_DESTROY_METHOD);\n    }"}, {"instruction": "default value is used for backwards compatibility", "input": "Java", "output": "@POST\n  @Path(\"/worker\")\n  @Consumes(MediaType.APPLICATION_JSON)\n  @ResourceFilters(ConfigResourceFilter.class)\n  public Response setWorkerConfig(\n      final WorkerBehaviorConfig workerBehaviorConfig,\n      @HeaderParam(AuditManager.X_DRUID_AUTHOR) @DefaultValue(\"\") final String author,\n      @HeaderParam(AuditManager.X_DRUID_COMMENT) @DefaultValue(\"\") final String comment,\n      @Context final HttpServletRequest req\n  )\n  {\n    final SetResult setResult = configManager.set(\n        WorkerBehaviorConfig.CONFIG_KEY,\n        workerBehaviorConfig,\n        new AuditInfo(author, comment, req.getRemoteAddr())\n    );\n    if (setResult.isOk()) {\n      log.info(\"Updating Worker configs: %s\", workerBehaviorConfig);\n\n      return Response.ok().build();\n    } else {\n      return Response.status(Response.Status.BAD_REQUEST).build();\n    }\n  }"}, {"instruction": "\u8bbe\u7f6e\u54cd\u5e94\u7684Header\n\n@param response \u54cd\u5e94\u5bf9\u8c61{@link HttpServletResponse}\n@param name \u540d\n@param value \u503c\uff0c\u53ef\u4ee5\u662fString\uff0cDate\uff0c int", "input": "Java", "output": "public static void setHeader(HttpServletResponse response, String name, Object value) {\r\n\t\tif (value instanceof String) {\r\n\t\t\tresponse.setHeader(name, (String) value);\r\n\t\t} else if (Date.class.isAssignableFrom(value.getClass())) {\r\n\t\t\tresponse.setDateHeader(name, ((Date) value).getTime());\r\n\t\t} else if (value instanceof Integer || \"int\".equals(value.getClass().getSimpleName().toLowerCase())) {\r\n\t\t\tresponse.setIntHeader(name, (Integer) value);\r\n\t\t} else {\r\n\t\t\tresponse.setHeader(name, value.toString());\r\n\t\t}\r\n\t}"}, {"instruction": "Called when a stream is closed, we do things like:\n<ul>\n<li>Removing the stream from the map.\n<li>Optionally reporting the status.\n<li>Starting pending streams if we can.\n<li>Stopping the transport if this is the last live stream under a go-away status.\n</ul>\n\n@param streamId the Id of the stream.\n@param status the final status of this stream, null means no need to report.\n@param stopDelivery interrupt queued messages in the deframer\n@param errorCode reset the stream with this ErrorCode if not null.\n@param trailers the trailers received if not null", "input": "Java", "output": "void finishStream(\n      int streamId,\n      @Nullable Status status,\n      RpcProgress rpcProgress,\n      boolean stopDelivery,\n      @Nullable ErrorCode errorCode,\n      @Nullable Metadata trailers) {\n    synchronized (lock) {\n      OkHttpClientStream stream = streams.remove(streamId);\n      if (stream != null) {\n        if (errorCode != null) {\n          frameWriter.rstStream(streamId, ErrorCode.CANCEL);\n        }\n        if (status != null) {\n          stream\n              .transportState()\n              .transportReportStatus(\n                  status,\n                  rpcProgress,\n                  stopDelivery,\n                  trailers != null ? trailers : new Metadata());\n        }\n        if (!startPendingStreams()) {\n          stopIfNecessary();\n          maybeClearInUse(stream);\n        }\n      }\n    }\n  }"}, {"instruction": "arg.toByte", "input": "Java", "output": "public static java.lang.Byte toByte(Object arg) throws NoSuchMethodException {\n        if (arg instanceof java.lang.Integer) return boxToByte((byte)unboxToInt(arg));\n        if (arg instanceof java.lang.Character) return boxToByte((byte)unboxToChar(arg));\n        if (arg instanceof java.lang.Byte) return (java.lang.Byte)arg;\n        if (arg instanceof java.lang.Long) return boxToByte((byte)unboxToLong(arg));\n        if (arg instanceof java.lang.Short) return boxToByte((byte)unboxToShort(arg));\n        if (arg instanceof java.lang.Float) return boxToByte((byte)unboxToFloat(arg));\n        if (arg instanceof java.lang.Double) return boxToByte((byte)unboxToDouble(arg));\n        throw new NoSuchMethodException();\n    }"}, {"instruction": "Returns the Value Proto at 'fieldPath'. Returns null if the field was not found.", "input": "Java", "output": "@Nullable\n  Value extractField(@Nonnull FieldPath fieldPath) {\n    Value value = null;\n\n    if (fields != null) {\n      Iterator<String> components = fieldPath.getSegments().iterator();\n      value = fields.get(components.next());\n\n      while (value != null && components.hasNext()) {\n        if (value.getValueTypeCase() != Value.ValueTypeCase.MAP_VALUE) {\n          return null;\n        }\n        value = value.getMapValue().getFieldsOrDefault(components.next(), null);\n      }\n    }\n\n    return value;\n  }"}, {"instruction": "Like the standard next method but allows a\ncustomizable number of examples returned\n\n@param num the number of examples\n@return the next data applyTransformToDestination", "input": "Java", "output": "@Override\n    public DataSet next(int num) {\n        if (num <= cachedWindow.size())\n            return fromCached(num);\n        //no more sentences, return the left over\n        else if (num >= cachedWindow.size() && !iter.hasNext())\n            return fromCached(cachedWindow.size());\n\n        //need the next sentence\n        else {\n            while (cachedWindow.size() < num && iter.hasNext()) {\n                String sentence = iter.nextSentence();\n                if (sentence.isEmpty())\n                    continue;\n                List<Window> windows = Windows.windows(sentence, vec.getTokenizerFactory(), vec.getWindow(), vec);\n                if (windows.isEmpty() && !sentence.isEmpty())\n                    throw new IllegalStateException(\"Empty window on sentence\");\n                for (Window w : windows)\n                    w.setLabel(iter.currentLabel());\n                cachedWindow.addAll(windows);\n            }\n\n            return fromCached(num);\n        }\n\n    }"}, {"instruction": "This method initializes chkProxyChainAuth\n\n@return javax.swing.JCheckBox", "input": "Java", "output": "private JCheckBox getChkProxyChainAuth() {\r\n\t\tif (chkProxyChainAuth == null) {\r\n\t\t\tchkProxyChainAuth = new JCheckBox();\r\n\t\t\tchkProxyChainAuth.setText(Constant.messages.getString(\"conn.options.proxy.auth.required\"));\r\n\t\t\tchkProxyChainAuth.addActionListener(new java.awt.event.ActionListener() { \r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void actionPerformed(java.awt.event.ActionEvent e) {    \r\n\r\n\t\t\t\t\tsetProxyChainAuthEnabled(chkProxyChainAuth.isSelected());\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\treturn chkProxyChainAuth;\r\n\t}"}, {"instruction": "Populates the task input from external payload storage if the external storage path is specified.\n\n@param task the task for which the input is to be populated.", "input": "Java", "output": "private void populateTaskInput(Task task) {\n        if (StringUtils.isNotBlank(task.getExternalInputPayloadStoragePath())) {\n            WorkflowTaskMetrics.incrementExternalPayloadUsedCount(task.getTaskDefName(), ExternalPayloadStorage.Operation.READ.name(), ExternalPayloadStorage.PayloadType.TASK_INPUT.name());\n            task.setInputData(downloadFromExternalStorage(ExternalPayloadStorage.PayloadType.TASK_INPUT, task.getExternalInputPayloadStoragePath()));\n            task.setExternalInputPayloadStoragePath(null);\n        }\n    }"}, {"instruction": "Example of how to enable default event-based hold for a bucket", "input": "Java", "output": "public Bucket enableDefaultEventBasedHold(String bucketName) throws StorageException {\n    // [START storage_enable_default_event_based_hold]\n    // Instantiate a Google Cloud Storage client\n    Storage storage = StorageOptions.getDefaultInstance().getService();\n\n    // The name of a bucket, e.g. \"my-bucket\"\n    // String bucketName = \"my-bucket\";\n\n    Bucket bucket =\n        storage.update(BucketInfo.newBuilder(bucketName).setDefaultEventBasedHold(true).build());\n\n    System.out.println(\"Default event-based hold was enabled for \" + bucketName);\n    // [END storage_enable_default_event_based_hold]\n    return bucket;\n  }"}, {"instruction": "\u751f\u6210\u4e0d\u91cd\u590d\u968f\u673a\u6570 \u6839\u636e\u7ed9\u5b9a\u7684\u6700\u5c0f\u6570\u5b57\u548c\u6700\u5927\u6570\u5b57\uff0c\u4ee5\u53ca\u968f\u673a\u6570\u7684\u4e2a\u6570\uff0c\u4ea7\u751f\u6307\u5b9a\u7684\u4e0d\u91cd\u590d\u7684\u6570\u7ec4\n\n@param begin \u6700\u5c0f\u6570\u5b57\uff08\u5305\u542b\u8be5\u6570\uff09\n@param end \u6700\u5927\u6570\u5b57\uff08\u4e0d\u5305\u542b\u8be5\u6570\uff09\n@param size \u6307\u5b9a\u4ea7\u751f\u968f\u673a\u6570\u7684\u4e2a\u6570\n@return \u968f\u673aint\u6570\u7ec4", "input": "Java", "output": "public static int[] generateRandomNumber(int begin, int end, int size) {\r\n\t\tif (begin > end) {\r\n\t\t\tint temp = begin;\r\n\t\t\tbegin = end;\r\n\t\t\tend = temp;\r\n\t\t}\r\n\t\t// \u52a0\u5165\u903b\u8f91\u5224\u65ad\uff0c\u786e\u4fddbegin<end\u5e76\u4e14size\u4e0d\u80fd\u5927\u4e8e\u8be5\u8868\u793a\u8303\u56f4\r\n\t\tif ((end - begin) < size) {\r\n\t\t\tthrow new UtilException(\"Size is larger than range between begin and end!\");\r\n\t\t}\r\n\t\t// \u79cd\u5b50\u4f60\u53ef\u4ee5\u968f\u610f\u751f\u6210\uff0c\u4f46\u4e0d\u80fd\u91cd\u590d\r\n\t\tint[] seed = new int[end - begin];\r\n\r\n\t\tfor (int i = begin; i < end; i++) {\r\n\t\t\tseed[i - begin] = i;\r\n\t\t}\r\n\t\tint[] ranArr = new int[size];\r\n\t\tRandom ran = new Random();\r\n\t\t// \u6570\u91cf\u4f60\u53ef\u4ee5\u81ea\u5df1\u5b9a\u4e49\u3002\r\n\t\tfor (int i = 0; i < size; i++) {\r\n\t\t\t// \u5f97\u5230\u4e00\u4e2a\u4f4d\u7f6e\r\n\t\t\tint j = ran.nextInt(seed.length - i);\r\n\t\t\t// \u5f97\u5230\u90a3\u4e2a\u4f4d\u7f6e\u7684\u6570\u503c\r\n\t\t\tranArr[i] = seed[j];\r\n\t\t\t// \u5c06\u6700\u540e\u4e00\u4e2a\u672a\u7528\u7684\u6570\u5b57\u653e\u5230\u8fd9\u91cc\r\n\t\t\tseed[j] = seed[seed.length - 1 - i];\r\n\t\t}\r\n\t\treturn ranArr;\r\n\t}"}, {"instruction": "Gets a list of the http cookies from this request Header.\n\n@return the http cookies\n@throws IllegalArgumentException if a problem is encountered while\nprocessing the \"Cookie: \" header line.", "input": "Java", "output": "public List<HttpCookie> getHttpCookies() {\r\n        List<HttpCookie> cookies = new LinkedList<>();\r\n        // Use getCookieParams to reduce the places we parse cookies\r\n        TreeSet<HtmlParameter> ts = getCookieParams();\r\n        Iterator<HtmlParameter> it = ts.iterator();\r\n        while (it.hasNext()) {\r\n            HtmlParameter htmlParameter = it.next();\r\n            if (!htmlParameter.getName().isEmpty()) {\r\n                try {\r\n                    cookies.add(new HttpCookie(htmlParameter.getName(), htmlParameter.getValue()));\r\n                \r\n                } catch (IllegalArgumentException e) {\r\n                    // Occurs while scanning ;)\r\n                    log.debug(e.getMessage() + \" \" + htmlParameter.getName());\r\n                }\r\n            }\r\n        }\r\n        \r\n        return cookies;\r\n    }"}, {"instruction": "Processes the GRPC compression header which is composed of the compression flag and the outer\nframe length.", "input": "Java", "output": "private void processHeader() {\n    int type = nextFrame.readUnsignedByte();\n    if ((type & RESERVED_MASK) != 0) {\n      throw Status.INTERNAL.withDescription(\n          \"gRPC frame header malformed: reserved bits not zero\")\n          .asRuntimeException();\n    }\n    compressedFlag = (type & COMPRESSED_FLAG_MASK) != 0;\n\n    // Update the required length to include the length of the frame.\n    requiredLength = nextFrame.readInt();\n    if (requiredLength < 0 || requiredLength > maxInboundMessageSize) {\n      throw Status.RESOURCE_EXHAUSTED.withDescription(\n          String.format(\"gRPC message exceeds maximum size %d: %d\",\n              maxInboundMessageSize, requiredLength))\n          .asRuntimeException();\n    }\n\n    currentMessageSeqNo++;\n    statsTraceCtx.inboundMessage(currentMessageSeqNo);\n    transportTracer.reportMessageReceived();\n    // Continue reading the frame body.\n    state = State.BODY;\n  }"}, {"instruction": "An expectation for checking if the given text is present in the specified elements value\nattribute.\n\n@param locator used to find the element\n@param text    to be present in the value attribute of the element found by the locator\n@return true once the value attribute of the first element located by locator contains the\ngiven text", "input": "Java", "output": "public static ExpectedCondition<Boolean> textToBePresentInElementValue(final By locator,\n                                                                         final String text) {\n\n    return new ExpectedCondition<Boolean>() {\n      @Override\n      public Boolean apply(WebDriver driver) {\n        try {\n          String elementText = driver.findElement(locator).getAttribute(\"value\");\n          if (elementText != null) {\n            return elementText.contains(text);\n          }\n          return false;\n        } catch (StaleElementReferenceException e) {\n          return null;\n        }\n      }\n\n      @Override\n      public String toString() {\n        return String.format(\"text ('%s') to be the value of element located by %s\",\n                             text, locator);\n      }\n    };\n  }"}, {"instruction": "\u5220\u9664\u64cd\u4f5c\n\n@param config\n@param dml", "input": "Java", "output": "private void delete(BatchExecutor batchExecutor, MappingConfig config, SingleDml dml) throws SQLException {\n        Map<String, Object> data = dml.getData();\n        if (data == null || data.isEmpty()) {\n            return;\n        }\n\n        DbMapping dbMapping = config.getDbMapping();\n\n        Map<String, Integer> ctype = getTargetColumnType(batchExecutor.getConn(), config);\n\n        StringBuilder sql = new StringBuilder();\n        sql.append(\"DELETE FROM \").append(SyncUtil.getDbTableName(dbMapping)).append(\" WHERE \");\n\n        List<Map<String, ?>> values = new ArrayList<>();\n        // \u62fc\u63a5\u4e3b\u952e\n        appendCondition(dbMapping, sql, ctype, values, data);\n        batchExecutor.execute(sql.toString(), values);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Delete from target table, sql: {}\", sql);\n        }\n    }"}, {"instruction": "This method defines TokenizerFactory instance to be using during model building\n\n@param tokenizerFactory TokenizerFactory instance", "input": "Java", "output": "public void setTokenizerFactory(@NonNull TokenizerFactory tokenizerFactory) {\n        this.tokenizerFactory = tokenizerFactory;\n\n        if (sentenceIter != null) {\n            SentenceTransformer transformer = new SentenceTransformer.Builder().iterator(sentenceIter)\n                            .tokenizerFactory(this.tokenizerFactory).build();\n            this.iterator = new AbstractSequenceIterator.Builder<>(transformer).build();\n        }\n    }"}, {"instruction": "Sends a SavepointTriggerMessage to the job manager.", "input": "Java", "output": "private String triggerSavepoint(ClusterClient<?> clusterClient, JobID jobId, String savepointDirectory) throws FlinkException {\n\t\tlogAndSysout(\"Triggering savepoint for job \" + jobId + '.');\n\t\tCompletableFuture<String> savepointPathFuture = clusterClient.triggerSavepoint(jobId, savepointDirectory);\n\n\t\tlogAndSysout(\"Waiting for response...\");\n\n\t\tfinal String savepointPath;\n\n\t\ttry {\n\t\t\tsavepointPath = savepointPathFuture.get();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tThrowable cause = ExceptionUtils.stripExecutionException(e);\n\t\t\tthrow new FlinkException(\"Triggering a savepoint for the job \" + jobId + \" failed.\", cause);\n\t\t}\n\n\t\tlogAndSysout(\"Savepoint completed. Path: \" + savepointPath);\n\t\tlogAndSysout(\"You can resume your program from this savepoint with the run command.\");\n\n\t\treturn savepointPath;\n\t}"}, {"instruction": "Authenticate ecp request.\n\n@param credential   the credential\n@param authnRequest the authn request\n@return the authentication", "input": "Java", "output": "protected Authentication authenticateEcpRequest(final Credential credential,\n                                                    final Pair<AuthnRequest, MessageContext> authnRequest) {\n        val issuer = SamlIdPUtils.getIssuerFromSamlObject(authnRequest.getKey());\n        LOGGER.debug(\"Located issuer [{}] from request prior to authenticating [{}]\", issuer, credential.getId());\n\n        val service = getSamlProfileHandlerConfigurationContext().getWebApplicationServiceFactory().createService(issuer);\n        LOGGER.debug(\"Executing authentication request for service [{}] on behalf of credential id [{}]\", service, credential.getId());\n        val authenticationResult = getSamlProfileHandlerConfigurationContext()\n            .getAuthenticationSystemSupport().handleAndFinalizeSingleAuthenticationTransaction(service, credential);\n        return authenticationResult.getAuthentication();\n    }"}, {"instruction": "Get the cacheKeys of all the ASG to which query AWS for.\n\n<p>\nThe names are obtained from the {@link com.netflix.eureka.registry.InstanceRegistry} which is then\nused for querying the AWS.\n</p>\n\n@return the set of ASG cacheKeys (asgName + accountId).", "input": "Java", "output": "private Set<CacheKey> getCacheKeys() {\n        Set<CacheKey> cacheKeys = new HashSet<CacheKey>();\n        Applications apps = registry.getApplicationsFromLocalRegionOnly();\n        for (Application app : apps.getRegisteredApplications()) {\n            for (InstanceInfo instanceInfo : app.getInstances()) {\n                String localAccountId = getAccountId(instanceInfo, accountId);\n                String asgName = instanceInfo.getASGName();\n                if (asgName != null) {\n                    CacheKey key = new CacheKey(localAccountId, asgName);\n                    cacheKeys.add(key);\n                }\n            }\n        }\n\n        return cacheKeys;\n    }"}, {"instruction": "\u8fc7\u6ee4<br>\n\u8fc7\u6ee4\u8fc7\u7a0b\u901a\u8fc7\u4f20\u5165\u7684Filter\u5b9e\u73b0\u6765\u8fc7\u6ee4\u8fd4\u56de\u9700\u8981\u7684\u5143\u7d20\u5185\u5bb9\uff0c\u8fd9\u4e2aFilter\u5b9e\u73b0\u53ef\u4ee5\u5b9e\u73b0\u4ee5\u4e0b\u529f\u80fd\uff1a\n\n<pre>\n1\u3001\u8fc7\u6ee4\u51fa\u9700\u8981\u7684\u5bf9\u8c61\uff0c{@link Filter#accept(Object)}\u65b9\u6cd5\u8fd4\u56detrue\u7684\u5bf9\u8c61\u5c06\u88ab\u52a0\u5165\u7ed3\u679c\u96c6\u5408\u4e2d\n</pre>\n\n@param <T> \u96c6\u5408\u5143\u7d20\u7c7b\u578b\n@param collection \u96c6\u5408\n@param filter \u8fc7\u6ee4\u5668\n@return \u8fc7\u6ee4\u540e\u7684\u6570\u7ec4\n@since 3.1.0", "input": "Java", "output": "public static <T> Collection<T> filter(Collection<T> collection, Filter<T> filter) {\r\n\t\tif (null == collection || null == filter) {\r\n\t\t\treturn collection;\r\n\t\t}\r\n\r\n\t\tCollection<T> collection2 = ObjectUtil.clone(collection);\r\n\t\ttry {\r\n\t\t\tcollection2.clear();\r\n\t\t} catch (UnsupportedOperationException e) {\r\n\t\t\t// \u514b\u9686\u540e\u7684\u5bf9\u8c61\u4e0d\u652f\u6301\u6e05\u7a7a\uff0c\u8bf4\u660e\u4e3a\u4e0d\u53ef\u53d8\u96c6\u5408\u5bf9\u8c61\uff0c\u4f7f\u7528\u9ed8\u8ba4\u7684ArrayList\u4fdd\u5b58\u7ed3\u679c\r\n\t\t\tcollection2 = new ArrayList<>();\r\n\t\t}\r\n\r\n\t\tfor (T t : collection) {\r\n\t\t\tif (filter.accept(t)) {\r\n\t\t\t\tcollection2.add(t);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn collection2;\r\n\t}"}, {"instruction": "Create a new event handler group that combines the consumers in this group with <code>otherHandlerGroup</code>.\n\n@param otherHandlerGroup the event handler group to combine.\n@return a new EventHandlerGroup combining the existing and new consumers into a single dependency group.", "input": "Java", "output": "public EventHandlerGroup<T> and(final EventHandlerGroup<T> otherHandlerGroup)\n    {\n        final Sequence[] combinedSequences = new Sequence[this.sequences.length + otherHandlerGroup.sequences.length];\n        System.arraycopy(this.sequences, 0, combinedSequences, 0, this.sequences.length);\n        System.arraycopy(\n            otherHandlerGroup.sequences, 0,\n            combinedSequences, this.sequences.length, otherHandlerGroup.sequences.length);\n        return new EventHandlerGroup<>(disruptor, consumerRepository, combinedSequences);\n    }"}, {"instruction": "Returns the textual representations of the running issues (Java version and dependency) of the extensions of hte add-on,\nif any.\n<p>\nThe messages are internationalised thus suitable for UI components.\n\n@param requirements the run requirements of the add-on, whose extensions' run requirements will be used\n@param addOnSearcher the class responsible for searching add-ons with a given id, used to search for add-ons that are\nmissing for the add-on\n@return a {@code List} containing all the running issues of the add-on, empty if none\n@see #getRunningIssues(AddOn.BaseRunRequirements)\n@see #getUiExtensionsRunningIssues(AddOn.AddOnRunRequirements, AddOnSearcher)", "input": "Java", "output": "public static List<String> getUiExtensionsRunningIssues(AddOn.AddOnRunRequirements requirements, AddOnSearcher addOnSearcher) {\n        if (!requirements.hasExtensionsWithRunningIssues()) {\n            return new ArrayList<>(0);\n        }\n\n        List<String> issues = new ArrayList<>(10);\n        for (AddOn.ExtensionRunRequirements extReqs : requirements.getExtensionRequirements()) {\n            issues.addAll(getUiRunningIssues(extReqs, addOnSearcher));\n        }\n        return issues;\n    }"}, {"instruction": "\u89e3\u5bc6\n\n@param data SM2\u5bc6\u6587\uff0c\u5b9e\u9645\u5305\u542b\u4e09\u90e8\u5206\uff1aECC\u516c\u94a5\u3001\u771f\u6b63\u7684\u5bc6\u6587\u3001\u516c\u94a5\u548c\u539f\u6587\u7684SM3-HASH\u503c\n@param keyType \u79c1\u94a5\u6216\u516c\u94a5 {@link KeyType}\n@return \u52a0\u5bc6\u540e\u7684bytes\n@throws CryptoException \u5305\u62ecInvalidKeyException\u548cInvalidCipherTextException\u7684\u5305\u88c5\u5f02\u5e38", "input": "Java", "output": "@Override\r\n\tpublic byte[] decrypt(byte[] data, KeyType keyType) throws CryptoException {\r\n\t\tif (KeyType.PrivateKey != keyType) {\r\n\t\t\tthrow new IllegalArgumentException(\"Decrypt is only support by private key\");\r\n\t\t}\r\n\t\tckeckKey(keyType);\r\n\r\n\t\tlock.lock();\r\n\t\tfinal SM2Engine engine = getEngine();\r\n\t\ttry {\r\n\t\t\tengine.init(false, getCipherParameters(keyType));\r\n\t\t\treturn engine.processBlock(data, 0, data.length);\r\n\t\t} finally {\r\n\t\t\tlock.unlock();\r\n\t\t}\r\n\t}"}, {"instruction": "/*\n(non-Javadoc)\n@see java.util.Map#containsValue(java.lang.Object)", "input": "Java", "output": "@Override\n    public boolean containsValue(Object value) {\n        if (value == null) {\n            throw new NullPointerException();\n        }\n\n        for (Map.Entry<K, CachedValue<K, V>> entry : map.entrySet()) {\n            CachedValue<K, V> cachedValue = entry.getValue();\n            if (cachedValue.getValue().equals(value)) {\n                if (isValueExpired(cachedValue)) {\n                    if (map.remove(cachedValue.getKey(), cachedValue)) {\n                        onValueRemove(cachedValue);\n                    }\n                } else {\n                    readValue(cachedValue);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }"}, {"instruction": "Removes the field at the given position.\n<p>\nThis method should be used carefully. Be aware that as the field is actually removed from the record, the\ntotal number of fields is modified, and all fields to the right of the field removed shift one position to\nthe left.\n\n@param fieldNum The position of the field to be removed, starting at zero.\n@throws IndexOutOfBoundsException Thrown, when the position is not between 0 (inclusive) and the\nnumber of fields (exclusive).", "input": "Java", "output": "public void removeField(int fieldNum)\n\t{\n\t\t// range check\n\t\tif (fieldNum < 0 || fieldNum >= this.numFields) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tint lastIndex = this.numFields - 1;\t\t\n\n\t\tif (fieldNum < lastIndex) {\n\t\t\tint len = lastIndex - fieldNum;\n\t\t\tSystem.arraycopy(this.offsets, fieldNum + 1, this.offsets, fieldNum, len);\n\t\t\tSystem.arraycopy(this.lengths, fieldNum + 1, this.lengths, fieldNum, len);\n\t\t\tSystem.arraycopy(this.readFields, fieldNum + 1, this.readFields, fieldNum, len);\n\t\t\tSystem.arraycopy(this.writeFields, fieldNum + 1, this.writeFields, fieldNum, len);\n\t\t\tmarkModified(fieldNum);\n\t\t}\n\t\tthis.offsets[lastIndex] = NULL_INDICATOR_OFFSET;\n\t\tthis.lengths[lastIndex] = 0;\n\t\tthis.writeFields[lastIndex] = null;\n\n\t\tsetNumFields(lastIndex);\n\t}"}, {"instruction": "Gets all.\n\n@return the all", "input": "Java", "output": "public List<RegisteredService> getAll() {\n        val scan = new ScanRequest(dynamoDbProperties.getTableName());\n        LOGGER.debug(\"Scanning table with request [{}]\", scan);\n        val result = this.amazonDynamoDBClient.scan(scan);\n        LOGGER.debug(\"Scanned table with result [{}]\", scan);\n        return result.getItems()\n            .stream()\n            .map(this::deserializeServiceFromBinaryBlob)\n            .filter(Objects::nonNull)\n            .sorted(Comparator.comparingInt(RegisteredService::getEvaluationOrder))\n            .collect(Collectors.toList());\n    }"}, {"instruction": "Gets the new session button.\n\n@return the new session button", "input": "Java", "output": "private JButton getNewSessionButton() {\r\n\t\tif (newSessionButton == null) {\r\n\t\t\tnewSessionButton = new JButton();\r\n\t\t\tnewSessionButton.setText(Constant.messages.getString(\"httpsessions.toolbar.newsession.label\"));\r\n\t\t\tnewSessionButton.setIcon(DisplayUtils.getScaledIcon(new ImageIcon(HttpSessionsPanel.class.getResource(\"/resource/icon/16/103.png\"))));\r\n\t\t\tnewSessionButton.setToolTipText(Constant.messages.getString(\"httpsessions.toolbar.newsession.tooltip\"));\r\n\r\n\t\t\tnewSessionButton.addActionListener(new ActionListener() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\r\n\t\t\t\t\tHttpSessionsSite site = getCurrentHttpSessionSite();\r\n\t\t\t\t\tif (site != null) {\r\n\t\t\t\t\t\tsite.createEmptySession();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\treturn newSessionButton;\r\n\t}"}, {"instruction": "Make a TypeVariableName for the given TypeMirror. This form is used internally to avoid\ninfinite recursion in cases like {@code Enum<E extends Enum<E>>}. When we encounter such a\nthing, we will make a TypeVariableName without bounds and add that to the {@code typeVariables}\nmap before looking up the bounds. Then if we encounter this TypeVariable again while\nconstructing the bounds, we can just return it from the map. And, the code that put the entry\nin {@code variables} will make sure that the bounds are filled in before returning.", "input": "Java", "output": "static TypeVariableName get(\n      TypeVariable mirror, Map<TypeParameterElement, TypeVariableName> typeVariables) {\n    TypeParameterElement element = (TypeParameterElement) mirror.asElement();\n    TypeVariableName typeVariableName = typeVariables.get(element);\n    if (typeVariableName == null) {\n      // Since the bounds field is public, we need to make it an unmodifiableList. But we control\n      // the List that that wraps, which means we can change it before returning.\n      List<TypeName> bounds = new ArrayList<>();\n      List<TypeName> visibleBounds = Collections.unmodifiableList(bounds);\n      typeVariableName = new TypeVariableName(element.getSimpleName().toString(), visibleBounds);\n      typeVariables.put(element, typeVariableName);\n      for (TypeMirror typeMirror : element.getBounds()) {\n        bounds.add(TypeName.get(typeMirror, typeVariables));\n      }\n      bounds.remove(OBJECT);\n    }\n    return typeVariableName;\n  }"}, {"instruction": "Finds an available TCP port.\n\n@param minPortRange The minimum port range\n@param maxPortRange The maximum port range\n@return The available port", "input": "Java", "output": "public static int findAvailableTcpPort(int minPortRange, int maxPortRange) {\n        ArgumentUtils.check(() -> minPortRange > MIN_PORT_RANGE)\n            .orElseFail(\"Port minimum value must be greater than \" + MIN_PORT_RANGE);\n        ArgumentUtils.check(() -> maxPortRange >= minPortRange)\n            .orElseFail(\"Max port range must be greater than minimum port range\");\n        ArgumentUtils.check(() -> maxPortRange <= MAX_PORT_RANGE)\n            .orElseFail(\"Port maximum value must be less than \" + MAX_PORT_RANGE);\n\n        int currentPort = nextPort(minPortRange, maxPortRange);\n        while (!isTcpPortAvailable(currentPort)) {\n            currentPort = nextPort(minPortRange, maxPortRange);\n        }\n        return currentPort;\n    }"}, {"instruction": "Is usage policy accepted by user?\nLooks into the attributes collected by the principal to find {@link #aupAttributeName}.\nIf the attribute contains {@code true}, then the policy is determined as accepted.\n\n@param principal the principal\n@return true if accepted, false otherwise.", "input": "Java", "output": "protected boolean isUsagePolicyAcceptedBy(final Principal principal) {\n        val attributes = principal.getAttributes();\n        LOGGER.debug(\"Principal attributes found for [{}] are [{}]\", principal.getId(), attributes);\n\n        if (attributes != null && attributes.containsKey(this.aupAttributeName)) {\n            val value = CollectionUtils.toCollection(attributes.get(this.aupAttributeName));\n            LOGGER.debug(\"Evaluating attribute value [{}] found for [{}]\", value, this.aupAttributeName);\n            return value.stream().anyMatch(v -> v.toString().equalsIgnoreCase(Boolean.TRUE.toString()));\n        }\n        return false;\n    }"}, {"instruction": "TODO: make protected on a minor release", "input": "Java", "output": "byte[] writeAndClose(byte[] payload, StreamWrapper wrapper) throws IOException {\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream(512);\n        OutputStream compressionStream = wrapper.wrap(outputStream);\n        try {\n            compressionStream.write(payload);\n            compressionStream.flush();\n        } finally {\n            Objects.nullSafeClose(compressionStream);\n        }\n        return outputStream.toByteArray();\n    }"}, {"instruction": "Register spider for monitor.\n\n@param spiders spiders\n@return this\n@throws JMException JMException", "input": "Java", "output": "public synchronized SpiderMonitor register(Spider... spiders) throws JMException {\n        for (Spider spider : spiders) {\n            MonitorSpiderListener monitorSpiderListener = new MonitorSpiderListener();\n            if (spider.getSpiderListeners() == null) {\n                List<SpiderListener> spiderListeners = new ArrayList<SpiderListener>();\n                spiderListeners.add(monitorSpiderListener);\n                spider.setSpiderListeners(spiderListeners);\n            } else {\n                spider.getSpiderListeners().add(monitorSpiderListener);\n            }\n            SpiderStatusMXBean spiderStatusMBean = getSpiderStatusMBean(spider, monitorSpiderListener);\n            registerMBean(spiderStatusMBean);\n            spiderStatuses.add(spiderStatusMBean);\n        }\n        return this;\n    }"}, {"instruction": "Get the bean-style property names for the specified object.\n\n@param targetClass the target object\n@return a set of property names", "input": "Java", "output": "public static Set<String> getPropertyNames(final Class<?> targetClass)\n   {\n      HashSet<String> set = new HashSet<>();\n      Matcher matcher = GETTER_PATTERN.matcher(\"\");\n      for (Method method : targetClass.getMethods()) {\n         String name = method.getName();\n         if (method.getParameterTypes().length == 0 && matcher.reset(name).matches()) {\n            name = name.replaceFirst(\"(get|is)\", \"\");\n            try {\n               if (targetClass.getMethod(\"set\" + name, method.getReturnType()) != null) {\n                  name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\n                  set.add(name);\n               }\n            }\n            catch (Exception e) {\n               // fall thru (continue)\n            }\n         }\n      }\n\n      return set;\n   }"}, {"instruction": "Create a {@link ConfigurationPropertyName} by adapting the given source. The name\nis split into elements around the given {@code separator}. This method is more\nlenient than {@link #of} in that it allows mixed case names and '{@code _}'\ncharacters. Other invalid characters are stripped out during parsing.\n<p>\nThe {@code elementValueProcessor} function may be used if additional processing is\nrequired on the extracted element values.\n@param name the name to parse\n@param separator the separator used to split the name\n@param elementValueProcessor a function to process element values\n@return a {@link ConfigurationPropertyName}", "input": "Java", "output": "static ConfigurationPropertyName adapt(CharSequence name, char separator,\n\t\t\tFunction<CharSequence, CharSequence> elementValueProcessor) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tif (name.length() == 0) {\n\t\t\treturn EMPTY;\n\t\t}\n\t\tElements elements = new ElementsParser(name, separator)\n\t\t\t\t.parse(elementValueProcessor);\n\t\tif (elements.getSize() == 0) {\n\t\t\treturn EMPTY;\n\t\t}\n\t\treturn new ConfigurationPropertyName(elements);\n\t}"}, {"instruction": "Returns whether the system needs a restart, and if it is supported\ne.g. { restartRequired: true, restartSupported: false }", "input": "Java", "output": "@Restricted(DoNotUse.class) // WebOnly\n    public HttpResponse doRestartStatus() throws IOException {\n        JSONObject response = new JSONObject();\n        Jenkins jenkins = Jenkins.get();\n        response.put(\"restartRequired\", jenkins.getUpdateCenter().isRestartRequiredForCompletion());\n        response.put(\"restartSupported\", jenkins.getLifecycle().canRestart());\n        return HttpResponses.okJSON(response);\n    }"}, {"instruction": "Mask the input string with a list of patterns indexed by key in string section in mask.json\nThis is usually used to mask header values, query parameters and uri parameters\n\n@param input String The source of the string that needs to be masked\n@param key   String The key that maps to a list of patterns for masking in config file\n@return Masked result", "input": "Java", "output": "public static String maskString(String input, String key) {\n        String output = input;\n        Map<String, Object> stringConfig = (Map<String, Object>) config.get(MASK_TYPE_STRING);\n        if (stringConfig != null) {\n            Map<String, Object> keyConfig = (Map<String, Object>) stringConfig.get(key);\n            if (keyConfig != null) {\n                Set<String> patterns = keyConfig.keySet();\n                for (String pattern : patterns) {\n                    output = output.replaceAll(pattern, (String) keyConfig.get(pattern));\n                }\n            }\n        }\n        return output;\n    }"}, {"instruction": "This method uses locks because it can be used during indexing,\nand Druid can call aggregate() and get() concurrently\nhttps://github.com/apache/incubator-druid/pull/3956", "input": "Java", "output": "@Override\n  public void aggregate(final ByteBuffer buf, final int position)\n  {\n    final ArrayOfDoublesSketch update = selector.getObject();\n    if (update == null) {\n      return;\n    }\n    // Wrapping memory and ArrayOfDoublesUnion is inexpensive compared to union operations.\n    // Maintaining a cache of wrapped objects per buffer position like in Theta sketch aggregator\n    // might might be considered, but it would increase complexity including relocate() support.\n    final WritableMemory mem = WritableMemory.wrap(buf, ByteOrder.LITTLE_ENDIAN);\n    final WritableMemory region = mem.writableRegion(position, maxIntermediateSize);\n    final Lock lock = stripedLock.getAt(ArrayOfDoublesSketchBuildBufferAggregator.lockIndex(position)).writeLock();\n    lock.lock();\n    try {\n      final ArrayOfDoublesUnion union = ArrayOfDoublesSketches.wrapUnion(region);\n      union.update(update);\n    }\n    finally {\n      lock.unlock();\n    }\n  }"}, {"instruction": "\u8f6c\u6362\u4e3a\u5206\u9875\u8bed\u53e5\n\n@param sql\n@param offset\n@param limit\n@return", "input": "Java", "output": "public String convertToPageSql(String sql, Integer offset, Integer limit) {\n        //\u89e3\u6790SQL\n        Statement stmt;\n        try {\n            stmt = CCJSqlParserUtil.parse(sql);\n        } catch (Throwable e) {\n            throw new PageException(\"\u4e0d\u652f\u6301\u8be5SQL\u8f6c\u6362\u4e3a\u5206\u9875\u67e5\u8be2!\", e);\n        }\n        if (!(stmt instanceof Select)) {\n            throw new PageException(\"\u5206\u9875\u8bed\u53e5\u5fc5\u987b\u662fSelect\u67e5\u8be2!\");\n        }\n        //\u83b7\u53d6\u5206\u9875\u67e5\u8be2\u7684select\n        Select pageSelect = getPageSelect((Select) stmt);\n        String pageSql = pageSelect.toString();\n        //\u7f13\u5b58\u79fb\u5230\u5916\u9762\u4e86\uff0c\u6240\u4ee5\u4e0d\u66ff\u6362\u53c2\u6570\n        if (offset != null) {\n            pageSql = pageSql.replace(START_ROW, String.valueOf(offset));\n        }\n        if (limit != null) {\n            pageSql = pageSql.replace(PAGE_SIZE, String.valueOf(limit));\n        }\n        return pageSql;\n    }"}, {"instruction": "sm3\u8ba1\u7b97\u540e\u8fdb\u884c16\u8fdb\u5236\u8f6c\u6362\n\n@param data\n\u5f85\u8ba1\u7b97\u7684\u6570\u636e\n@param encoding\n\u7f16\u7801\n@return \u8ba1\u7b97\u7ed3\u679c", "input": "Java", "output": "public static String sm3X16Str(String data, String encoding) {\n\t\tbyte[] bytes = sm3(data, encoding);\n\t\tStringBuilder sm3StrBuff = new StringBuilder();\n\t\tfor (int i = 0; i < bytes.length; i++) {\n\t\t\tif (Integer.toHexString(0xFF & bytes[i]).length() == 1) {\n\t\t\t\tsm3StrBuff.append(\"0\").append(\n\t\t\t\t\t\tInteger.toHexString(0xFF & bytes[i]));\n\t\t\t} else {\n\t\t\t\tsm3StrBuff.append(Integer.toHexString(0xFF & bytes[i]));\n\t\t\t}\n\t\t}\n\t\treturn sm3StrBuff.toString();\n\t}"}, {"instruction": "\u521b\u5efa\u5f15\u64ce\n\n@param config \u6a21\u677f\u914d\u7f6e\n@return {@link org.rythmengine.RythmEngine}", "input": "Java", "output": "private static org.rythmengine.RythmEngine createEngine(TemplateConfig config) {\r\n\t\tif (null == config) {\r\n\t\t\tconfig = new TemplateConfig();\r\n\t\t}\r\n\t\t\r\n\t\tfinal Properties props = new Properties();\r\n\t\tfinal String path = config.getPath();\r\n\t\tif (null != path) {\r\n\t\t\tprops.put(\"home.template\", path);\r\n\t\t}\r\n\r\n\t\tfinal org.rythmengine.RythmEngine engine = new org.rythmengine.RythmEngine(props);\r\n\t\treturn engine;\r\n\t}"}, {"instruction": "Get current thread context ClassLoader\n\n@return return ClassLoader", "input": "Java", "output": "public static ClassLoader getDefault() {\n        ClassLoader loader = null;\n        try {\n            loader = Thread.currentThread().getContextClassLoader();\n        } catch (Exception ignored) {\n        }\n        if (loader == null) {\n            loader = Environment.class.getClassLoader();\n            if (loader == null) {\n                try {\n                    // getClassLoader() returning null indicates the bootstrap ClassLoader\n                    loader = ClassLoader.getSystemClassLoader();\n                } catch (Exception e) {\n                    // Cannot access system ClassLoader - oh well, maybe the caller can live with null...\n                }\n            }\n        }\n        return loader;\n    }"}, {"instruction": "Return a {@link RelaxedNames} for the given source camelCase source name.\n\n@param name the source name in camelCase\n@return the relaxed names", "input": "Java", "output": "public static RelaxedNames forCamelCase(String name) {\n        StringBuilder result = new StringBuilder();\n        for (char c : name.toCharArray()) {\n            result.append(Character.isUpperCase(c) && result.length() > 0\n                          && result.charAt(result.length() - 1) != '-' ? \"-\" + Character.toLowerCase(c) : c);\n        }\n        return new RelaxedNames(result.toString());\n    }"}, {"instruction": "Removes the mapping from the cache without store-by-value copying nor waiting for synchronous\nlisteners to complete.\n\n@param key key whose mapping is to be removed from the cache\n@return the old value", "input": "Java", "output": "private V removeNoCopyOrAwait(K key) {\n    @SuppressWarnings(\"unchecked\")\n    V[] removed = (V[]) new Object[1];\n    cache.asMap().computeIfPresent(key, (k, expirable) -> {\n      if (!expirable.isEternal() && expirable.hasExpired(currentTimeMillis())) {\n        dispatcher.publishExpired(this, key, expirable.get());\n        statistics.recordEvictions(1L);\n        return null;\n      }\n\n      dispatcher.publishRemoved(this, key, expirable.get());\n      removed[0] = expirable.get();\n      return null;\n    });\n    return removed[0];\n  }"}, {"instruction": "\u5e8f\u5217\u5316\u540e\u62f7\u8d1d\u6d41\u7684\u65b9\u5f0f\u514b\u9686<br>\n\u5bf9\u8c61\u5fc5\u987b\u5b9e\u73b0Serializable\u63a5\u53e3\n\n@param <T> \u5bf9\u8c61\u7c7b\u578b\n@param obj \u88ab\u514b\u9686\u5bf9\u8c61\n@return \u514b\u9686\u540e\u7684\u5bf9\u8c61\n@throws UtilException IO\u5f02\u5e38\u548cClassNotFoundException\u5c01\u88c5", "input": "Java", "output": "@SuppressWarnings(\"unchecked\")\r\n\tpublic static <T> T cloneByStream(T obj) {\r\n\t\tif (null == obj || false == (obj instanceof Serializable)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tfinal FastByteArrayOutputStream byteOut = new FastByteArrayOutputStream();\r\n\t\tObjectOutputStream out = null;\r\n\t\ttry {\r\n\t\t\tout = new ObjectOutputStream(byteOut);\r\n\t\t\tout.writeObject(obj);\r\n\t\t\tout.flush();\r\n\t\t\tfinal ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(byteOut.toByteArray()));\r\n\t\t\treturn (T) in.readObject();\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new UtilException(e);\r\n\t\t} finally {\r\n\t\t\tIoUtil.close(out);\r\n\t\t}\r\n\t}"}, {"instruction": "Parse RFC 7235 challenges. This is awkward because we need to look ahead to know how to\ninterpret a token.\n\n<p>For example, the first line has a parameter name/value pair and the second line has a single\ntoken68:\n\n<pre>   {@code\n\nWWW-Authenticate: Digest foo=bar\nWWW-Authenticate: Digest foo=\n}</pre>\n\n<p>Similarly, the first line has one challenge and the second line has two challenges:\n\n<pre>   {@code\n\nWWW-Authenticate: Digest ,foo=bar\nWWW-Authenticate: Digest ,foo\n}</pre>", "input": "Java", "output": "public static List<Challenge> parseChallenges(Headers responseHeaders, String headerName) {\n    List<Challenge> result = new ArrayList<>();\n    for (int h = 0; h < responseHeaders.size(); h++) {\n      if (headerName.equalsIgnoreCase(responseHeaders.name(h))) {\n        Buffer header = new Buffer().writeUtf8(responseHeaders.value(h));\n        try {\n          parseChallengeHeader(result, header);\n        } catch (EOFException e) {\n          Platform.get().log(Platform.WARN, \"Unable to parse challenge\", e);\n        }\n      }\n    }\n    return result;\n  }"}, {"instruction": "Applies Givens rotation to sparse vectors one of which is in compressed form.\n\n@param N The number of elements in vectors X and Y\n@param X a sparse vector\n@param Y a full-storage vector\n@param c a scalar\n@param s a scalar", "input": "Java", "output": "@Override\n    public void rot(long N, INDArray X, INDArray Y, double c, double s) {\n\n\n        if (X instanceof BaseSparseNDArray) {\n            BaseSparseNDArray sparseX = (BaseSparseNDArray) X;\n\n            switch (X.data().dataType()) {\n                case DOUBLE:\n                    droti(N, X, sparseX.getVectorCoordinates(), Y, c, s);\n                    break;\n                case FLOAT:\n                    sroti(N, X, sparseX.getVectorCoordinates(), Y, c, s);\n                    break;\n                case HALF:\n                    hroti(N, X, sparseX.getVectorCoordinates(), Y, c, s);\n                    break;\n                default:\n                    throw new UnsupportedOperationException();\n            }\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }"}, {"instruction": "\u4ece\u767b\u8bb0\u7c3f\u4e2d\u79fb\u9664\u8def\u5f84\u5bf9\u5e94\u7684\u72b6\u6001\u4eec<br>\nRemoves from equivalenceClassMDAGNodeHashmap the entries of all the nodes in a _transition path.\n\n@param str a String corresponding to a _transition path from sourceNode", "input": "Java", "output": "private void removeTransitionPathRegisterEntries(String str)\n    {\n        MDAGNode currentNode = sourceNode;\n\n        int charCount = str.length();\n\n        for (int i = 0; i < charCount; i++)\n        {\n            currentNode = currentNode.transition(str.charAt(i));\n            if (equivalenceClassMDAGNodeHashMap.get(currentNode) == currentNode)\n                equivalenceClassMDAGNodeHashMap.remove(currentNode);\n\n            //The hashCode of an MDAGNode is cached the first time a hash is performed without a cache value present.\n            //Since we just hashed currentNode, we must clear this regardless of its presence in equivalenceClassMDAGNodeHashMap\n            //since we're not actually declaring equivalence class representatives here.\n            if (currentNode != null) currentNode.clearStoredHashCode();\n        }\n    }"}, {"instruction": "/* package", "input": "Java", "output": "void addExecutedCommand(HystrixInvokableInfo<?> command) {\n        if (!allExecutedCommands.offer(command)) {\n            // see RequestLog: Reduce Chance of Memory Leak https://github.com/Netflix/Hystrix/issues/53\n            logger.warn(\"RequestLog ignoring command after reaching limit of \" + MAX_STORAGE + \". See https://github.com/Netflix/Hystrix/issues/53 for more information.\");\n        }\n\n        // TODO remove this when deprecation completed\n        if (command instanceof HystrixCommand) {\n            @SuppressWarnings(\"rawtypes\")\n            HystrixCommand<?> _c = (HystrixCommand) command;\n            if (!executedCommands.offer(_c)) {\n                // see RequestLog: Reduce Chance of Memory Leak https://github.com/Netflix/Hystrix/issues/53\n                logger.warn(\"RequestLog ignoring command after reaching limit of \" + MAX_STORAGE + \". See https://github.com/Netflix/Hystrix/issues/53 for more information.\");\n            }\n        }\n    }"}, {"instruction": "${expectedBulkLength}\\r\\n <here> {data...}\\r\\n", "input": "Java", "output": "private boolean decodeBulkStringContent(ByteBuf in, List<Object> out) throws Exception {\n        final int readableBytes = in.readableBytes();\n        if (readableBytes == 0 || remainingBulkLength == 0 && readableBytes < RedisConstants.EOL_LENGTH) {\n            return false;\n        }\n\n        // if this is last frame.\n        if (readableBytes >= remainingBulkLength + RedisConstants.EOL_LENGTH) {\n            ByteBuf content = in.readSlice(remainingBulkLength);\n            readEndOfLine(in);\n            // Only call retain after readEndOfLine(...) as the method may throw an exception.\n            out.add(new DefaultLastBulkStringRedisContent(content.retain()));\n            resetDecoder();\n            return true;\n        }\n\n        // chunked write.\n        int toRead = Math.min(remainingBulkLength, readableBytes);\n        remainingBulkLength -= toRead;\n        out.add(new DefaultBulkStringRedisContent(in.readSlice(toRead).retain()));\n        return true;\n    }"}, {"instruction": "The lookup handler method, maps the SEOMapper method to the request URL.\n<p>If no mapping is found, or if the URL is disabled, it will simply drop through\nto the standard 404 handling.</p>\n\n@param urlPath the path to match.\n@param request the http servlet request.\n@return The HandlerMethod if one was found.", "input": "Java", "output": "@Override\n  protected HandlerMethod lookupHandlerMethod(String urlPath, HttpServletRequest request) {\n    logger.debug(\"looking up handler for path: \" + urlPath);\n    HandlerMethod handlerMethod = handlerMethods.get(urlPath);\n    if (handlerMethod != null) {\n      return handlerMethod;\n    }\n    for (String path : handlerMethods.keySet()) {\n      UriTemplate template = new UriTemplate(path);\n      if (template.matches(urlPath)) {\n        request.setAttribute(\n            HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE,\n            template.match(urlPath));\n        return handlerMethods.get(path);\n      }\n    }\n    return null;\n  }"}, {"instruction": "Returns staged predictions of tree algorithms (prediction probabilities of trees per iteration).\nThe output structure is for tree Tt and class Cc:\nBinomial models: [probability T1.C1, probability T2.C1, ..., Tt.C1] where Tt.C1 correspond to the the probability p0\nMultinomial models: [probability T1.C1, probability T1.C2, ..., Tt.Cc]\n@param row Input row.\n@param predsLength Length of prediction result.\n@return array of staged prediction probabilities", "input": "Java", "output": "public double[] scoreStagedPredictions(double[] row, int predsLength) {\n        int contribOffset = nclasses() == 1 ? 0 : 1;\n        double[] trees_result = new double[_ntree_groups * _ntrees_per_group];\n\n        for (int groupIndex = 0; groupIndex < _ntree_groups; groupIndex++) {\n            double[] tmpPreds = new double[predsLength];\n            scoreTreeRange(row, 0, groupIndex+1, tmpPreds);\n            unifyPreds(row, 0, tmpPreds);\n            for (int classIndex = 0; classIndex < _ntrees_per_group; classIndex++) {\n                int tree_index = groupIndex * _ntrees_per_group + classIndex;\n                trees_result[tree_index] = tmpPreds[contribOffset+classIndex];\n            }\n        }\n        return trees_result;\n    }"}, {"instruction": "Return 16-bit unsigned int from buffer. (little-endian)\n\n@see mysql-5.1.60/include/my_global.h - uint2korr", "input": "Java", "output": "public final int getUint16(final int pos) {\r\n        final int position = origin + pos;\r\n\r\n        if (pos + 1 >= limit || pos < 0) throw new IllegalArgumentException(\"limit excceed: \"\r\n                                                                            + (pos < 0 ? pos : (pos + 1)));\r\n\r\n        byte[] buf = buffer;\r\n        return (0xff & buf[position]) | ((0xff & buf[position + 1]) << 8);\r\n    }"}, {"instruction": "Called once the user logs in. Just forward to the top page.\nUsed only by {@link LegacySecurityRealm}.", "input": "Java", "output": "public void doLoginEntry( StaplerRequest req, StaplerResponse rsp ) throws IOException {\n        if(req.getUserPrincipal()==null) {\n            rsp.sendRedirect2(\"noPrincipal\");\n            return;\n        }\n\n        // TODO fire something in SecurityListener?\n\n        String from = req.getParameter(\"from\");\n        if(from!=null && from.startsWith(\"/\") && !from.equals(\"/loginError\")) {\n            rsp.sendRedirect2(from);    // I'm bit uncomfortable letting users redirected to other sites, make sure the URL falls into this domain\n            return;\n        }\n\n        String url = AbstractProcessingFilter.obtainFullRequestUrl(req);\n        if(url!=null) {\n            // if the login redirect is initiated by Acegi\n            // this should send the user back to where s/he was from.\n            rsp.sendRedirect2(url);\n            return;\n        }\n\n        rsp.sendRedirect2(\".\");\n    }"}, {"instruction": "This method initializes this", "input": "Java", "output": "private void initialize() {\r\n        this.setCursor(new java.awt.Cursor(java.awt.Cursor.WAIT_CURSOR));\r\n        this.setContentPane(getJPanel());\r\n        if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {\r\n        \tthis.setSize(282, 118);\r\n        }\r\n        this.setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);\r\n        this.setResizable(false);\r\n\t\t\t\r\n\t}"}, {"instruction": "Update account info from account object.\n@param account to be updated\n@return this", "input": "Java", "output": "public CouchDbGoogleAuthenticatorAccount update(final OneTimeTokenAccount account) {\n        setId(account.getId());\n        setUsername(account.getUsername());\n        setSecretKey(account.getSecretKey());\n        setValidationCode(account.getValidationCode());\n        setScratchCodes(account.getScratchCodes());\n        setRegistrationDate(account.getRegistrationDate());\n        return this;\n    }"}, {"instruction": "Eagerly reads {@code byteCount} bytes from the source before launching a background task to\nprocess the data.  This avoids corrupting the stream.", "input": "Java", "output": "void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,\n      final boolean inFinished) throws IOException {\n    final Buffer buffer = new Buffer();\n    source.require(byteCount); // Eagerly read the frame before firing client thread.\n    source.read(buffer, byteCount);\n    if (buffer.size() != byteCount) throw new IOException(buffer.size() + \" != \" + byteCount);\n    pushExecutorExecute(new NamedRunnable(\"OkHttp %s Push Data[%s]\", connectionName, streamId) {\n      @Override public void execute() {\n        try {\n          boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);\n          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);\n          if (cancel || inFinished) {\n            synchronized (Http2Connection.this) {\n              currentPushRequests.remove(streamId);\n            }\n          }\n        } catch (IOException ignored) {\n        }\n      }\n    });\n  }"}, {"instruction": "Trim the wave data\n\n@param leftTrimSecond\nSeconds trimmed from beginning\n@param rightTrimSecond\nSeconds trimmed from ending", "input": "Java", "output": "public void trim(double leftTrimSecond, double rightTrimSecond) {\n\n        int sampleRate = waveHeader.getSampleRate();\n        int bitsPerSample = waveHeader.getBitsPerSample();\n        int channels = waveHeader.getChannels();\n\n        int leftTrimNumberOfSample = (int) (sampleRate * bitsPerSample / 8 * channels * leftTrimSecond);\n        int rightTrimNumberOfSample = (int) (sampleRate * bitsPerSample / 8 * channels * rightTrimSecond);\n\n        trim(leftTrimNumberOfSample, rightTrimNumberOfSample);\n    }"}, {"instruction": "Make a prediction on a new data point using a Dimension Reduction model (PCA, GLRM)\n@param data A new data point.\n@return The prediction.\n@throws PredictException", "input": "Java", "output": "public DimReductionModelPrediction predictDimReduction(RowData data) throws PredictException {\n    double[] preds = preamble(ModelCategory.DimReduction, data);  // preds contains the x factor\n\n    DimReductionModelPrediction p = new DimReductionModelPrediction();\n    p.dimensions = preds;\n    if (m instanceof GlrmMojoModel && ((GlrmMojoModel) m)._archetypes_raw != null && this.enableGLRMReconstruct)  // only for verion 1.10 or higher\n      p.reconstructed = ((GlrmMojoModel) m).impute_data(preds, new double[m.nfeatures()], ((GlrmMojoModel) m)._nnums,\n              ((GlrmMojoModel) m)._ncats, ((GlrmMojoModel) m)._permutation, ((GlrmMojoModel) m)._reverse_transform,\n              ((GlrmMojoModel) m)._normMul, ((GlrmMojoModel) m)._normSub, ((GlrmMojoModel) m)._losses,\n              ((GlrmMojoModel) m)._transposed, ((GlrmMojoModel) m)._archetypes_raw, ((GlrmMojoModel) m)._catOffsets,\n              ((GlrmMojoModel) m)._numLevels);\n    return p;\n  }"}, {"instruction": "Put cas response attributes into model.\n\n@param model              the model\n@param attributes         the attributes\n@param registeredService  the registered service\n@param attributesRenderer the attributes renderer", "input": "Java", "output": "protected void putCasResponseAttributesIntoModel(final Map<String, Object> model,\n                                                     final Map<String, Object> attributes,\n                                                     final RegisteredService registeredService,\n                                                     final CasProtocolAttributesRenderer attributesRenderer) {\n\n        LOGGER.trace(\"Beginning to encode attributes for the response\");\n        val encodedAttributes = this.protocolAttributeEncoder.encodeAttributes(attributes, registeredService);\n\n        LOGGER.debug(\"Encoded attributes for the response are [{}]\", encodedAttributes);\n        putIntoModel(model, CasProtocolConstants.VALIDATION_CAS_MODEL_ATTRIBUTE_NAME_ATTRIBUTES, encodedAttributes);\n\n        val formattedAttributes = attributesRenderer.render(encodedAttributes);\n        putIntoModel(model, CasProtocolConstants.VALIDATION_CAS_MODEL_ATTRIBUTE_NAME_FORMATTED_ATTRIBUTES, formattedAttributes);\n    }"}, {"instruction": "\u8fd4\u56de\u5305\u542b\u5b57\u4e32\u7684key<br>\nRetrieves all the Strings in the MDAG that contain a given String.\n\n@param str a String that is contained in all the desired Strings\n@return a HashSet containing all the Strings present in the MDAG that begin with {@code prefixString}", "input": "Java", "output": "public HashSet<String> getStringsWithSubstring(String str)\n    {\n        HashSet<String> strHashSet = new HashSet<String>();\n\n        if (sourceNode != null)      //if the MDAG hasn't been simplified\n            getStrings(strHashSet, SearchCondition.SUBSTRING_SEARCH_CONDITION, str, \"\", sourceNode.getOutgoingTransitions());\n        else\n            getStrings(strHashSet, SearchCondition.SUBSTRING_SEARCH_CONDITION, str, \"\", simplifiedSourceNode);\n\n        return strHashSet;\n    }"}, {"instruction": "Creates a CompletableFuture that will do nothing and complete after a specified delay, without using a thread during\nthe delay.\n\n@param delay           The duration of the delay (how much to wait until completing the Future).\n@param executorService An ExecutorService that will be used to complete the Future on.\n@return A CompletableFuture that will complete after the specified delay.", "input": "Java", "output": "public static CompletableFuture<Void> delayedFuture(Duration delay, ScheduledExecutorService executorService) {\n        CompletableFuture<Void> result = new CompletableFuture<>();\n        if (delay.toMillis() == 0) {\n            // Zero delay; no need to bother with scheduling a task in the future.\n            result.complete(null);\n        } else {\n            ScheduledFuture<Boolean> sf = executorService.schedule(() -> result.complete(null), delay.toMillis(), TimeUnit.MILLISECONDS);\n            result.whenComplete((r, ex) -> sf.cancel(true));\n        }\n\n        return result;\n    }"}, {"instruction": "The Jaeger Tracer builder bean.\n\n@param configuration The configuration\n@return The builder", "input": "Java", "output": "@Singleton\n    @Primary\n    @Requires(classes = JaegerTracer.Builder.class)\n    JaegerTracer.Builder jaegerTracerBuilder(Configuration configuration) {\n        JaegerTracer.Builder tracerBuilder = resolveBuilder(configuration);\n        if (this.configuration.isExpandExceptionLogs()) {\n            tracerBuilder.withExpandExceptionLogs();\n        }\n        if (this.configuration.isZipkinSharedRpcSpan()) {\n            tracerBuilder.withZipkinSharedRpcSpan();\n        }\n        if (reporter != null) {\n            tracerBuilder.withReporter(reporter);\n        }\n        if (sampler != null) {\n            tracerBuilder.withSampler(sampler);\n        }\n        return tracerBuilder;\n    }"}, {"instruction": "word pos\n\n@return", "input": "Java", "output": "public String[][] toWordTagArray()\n    {\n        List<Word> wordList = toSimpleWordList();\n        String[][] pair = new String[2][wordList.size()];\n        Iterator<Word> iterator = wordList.iterator();\n        for (int i = 0; i < pair[0].length; i++)\n        {\n            Word word = iterator.next();\n            pair[0][i] = word.value;\n            pair[1][i] = word.label;\n        }\n        return pair;\n    }"}, {"instruction": "\u6253\u5f00SSH\u4f1a\u8bdd\uff0c\u5e76\u7ed1\u5b9a\u8fdc\u7a0b\u7aef\u53e3\u5230\u672c\u5730\u7684\u4e00\u4e2a\u968f\u673a\u7aef\u53e3\n\n@param sshConn SSH\u8fde\u63a5\u4fe1\u606f\u5bf9\u8c61\n@param remoteHost \u8fdc\u7a0b\u4e3b\u673a\n@param remotePort \u8fdc\u7a0b\u7aef\u53e3\n@return \u6620\u5c04\u540e\u7684\u672c\u5730\u7aef\u53e3\n@throws JschRuntimeException \u8fde\u63a5\u5f02\u5e38", "input": "Java", "output": "public static int openAndBindPortToLocal(Connector sshConn, String remoteHost, int remotePort) throws JschRuntimeException {\r\n\t\tfinal Session session = openSession(sshConn.getHost(), sshConn.getPort(), sshConn.getUser(), sshConn.getPassword());\r\n\t\tif (session == null) {\r\n\t\t\tthrow new JschRuntimeException(\"Error to create SSH Session\uff01\");\r\n\t\t}\r\n\t\tfinal int localPort = generateLocalPort();\r\n\t\tbindPort(session, remoteHost, remotePort, localPort);\r\n\t\treturn localPort;\r\n\t}"}, {"instruction": "Helper to convert retention policy from RPC call to internal representation.\n\n@param policy The retention policy from RPC interface.\n@return New instance of RetentionPolicy.", "input": "Java", "output": "public static final RetentionPolicy encode(final Controller.RetentionPolicy policy) {\n        // Using default enum type of UNKNOWN(0) to detect if retention policy has been set or not.\n        // This is required since proto3 does not have any other way to detect if a field has been set or not.\n        if (policy != null && policy.getRetentionType() != Controller.RetentionPolicy.RetentionPolicyType.UNKNOWN) {\n            return RetentionPolicy.builder()\n                    .retentionType(RetentionPolicy.RetentionType.valueOf(policy.getRetentionType().name()))\n                    .retentionParam(policy.getRetentionParam())\n                    .build();\n        } else {\n            return null;\n        }\n    }"}, {"instruction": "Conditionally schedules the asynchronous maintenance task after a write operation. If the\ntask status was IDLE or REQUIRED then the maintenance task is scheduled immediately. If it\nis already processing then it is set to transition to REQUIRED upon completion so that a new\nexecution is triggered by the next operation.", "input": "Java", "output": "void scheduleAfterWrite() {\n    for (;;) {\n      switch (drainStatus()) {\n        case IDLE:\n          casDrainStatus(IDLE, REQUIRED);\n          scheduleDrainBuffers();\n          return;\n        case REQUIRED:\n          scheduleDrainBuffers();\n          return;\n        case PROCESSING_TO_IDLE:\n          if (casDrainStatus(PROCESSING_TO_IDLE, PROCESSING_TO_REQUIRED)) {\n            return;\n          }\n          continue;\n        case PROCESSING_TO_REQUIRED:\n          return;\n        default:\n          throw new IllegalStateException();\n      }\n    }\n  }"}, {"instruction": "\u83b7\u5f97\u5b57\u7b26\u4e32\u503c<br>\n\u652f\u6301Clob\u3001Blob\u3001RowId\n\n@param field \u5b57\u6bb5\u540d\n@param charset \u7f16\u7801\n@return \u5b57\u6bb5\u5bf9\u5e94\u503c\n@since 3.0.6", "input": "Java", "output": "public String getStr(String field, Charset charset) {\r\n\t\tfinal Object obj = get(field);\r\n\t\tif (obj instanceof Clob) {\r\n\t\t\treturn SqlUtil.clobToStr((Clob) obj);\r\n\t\t} else if (obj instanceof Blob) {\r\n\t\t\treturn SqlUtil.blobToStr((Blob) obj, charset);\r\n\t\t} else if (obj instanceof RowId) {\r\n\t\t\tfinal RowId rowId = (RowId) obj;\r\n\t\t\treturn StrUtil.str(rowId.getBytes(), charset);\r\n\t\t}\r\n\t\treturn super.getStr(field);\r\n\t}"}, {"instruction": "Convenience method to perform a reverse DNS lookup. Threads the request\nthrough a custom Runnable class in order to prevent inordinately long\nuser waits while performing reverse lookup.\n\n@param remoteIp the remote ip\n@return the remote host name", "input": "Java", "output": "protected String getRemoteHostName(final String remoteIp) {\n        val revDNS = new ReverseDNSRunnable(remoteIp);\n        val t = new Thread(revDNS);\n        t.start();\n        try {\n            t.join(this.timeout);\n        } catch (final InterruptedException e) {\n            LOGGER.debug(\"Threaded lookup failed.  Defaulting to IP [{}].\", remoteIp, e);\n        }\n        val remoteHostName = revDNS.getHostName();\n        LOGGER.debug(\"Found remote host name [{}].\", remoteHostName);\n        return StringUtils.isNotBlank(remoteHostName) ? remoteHostName : remoteIp;\n    }"}, {"instruction": "Return true if blocking is unnecessary.\nAlas, used in TWO places and the blocking API forces them to share here.", "input": "Java", "output": "@Override public boolean isReleasable() {\n    int r = _rwlock.get();\n    if( _key.home() ) {         // Called from lock_and_invalidate\n      // Home-key blocking: wait for active-GET count to fall to zero, or blocking on deleted object\n      return r <= 0;\n    } else {                    // Called from start_put\n      // Remote-key blocking: wait for active-PUT lock to hit -1\n      assert r == 2 || r == -1; // Either waiting (2) or done (-1) but not started(1)\n      return r == -1;           // done!\n    }\n  }"}, {"instruction": "Due to the return type change in {@link Executable} in 1.377, the caller needs a special precaution now.\n@param e Executable\n@return Discovered subtask", "input": "Java", "output": "public static @Nonnull SubTask getParentOf(@Nonnull Executable e) \n            throws Error, RuntimeException {\n        try {\n            return e.getParent();\n        } catch (AbstractMethodError ignored) { // will fallback to a private implementation\n            try {\n                Method m = e.getClass().getMethod(\"getParent\");\n                m.setAccessible(true);\n                return (SubTask) m.invoke(e);\n            } catch (IllegalAccessException x) {\n                throw (Error)new IllegalAccessError().initCause(x);\n            } catch (NoSuchMethodException x) {\n                throw (Error)new NoSuchMethodError().initCause(x);\n            } catch (InvocationTargetException x) {\n                Throwable y = x.getTargetException();\n                if (y instanceof Error)     throw (Error)y;\n                if (y instanceof RuntimeException)     throw (RuntimeException)y;\n                throw new Error(x);\n            }\n        }\n    }"}, {"instruction": "Awaits the phase of this phaser to advance from the given phase\nvalue, throwing {@code InterruptedException} if interrupted\nwhile waiting, or returning immediately if the current phase is\nnot equal to the given phase value or this phaser is\nterminated.\n\n@param phase an arrival phase number, or negative value if\nterminated; this argument is normally the value returned by a\nprevious call to {@code arrive} or {@code arriveAndDeregister}.\n@return the next arrival phase number, or the argument if it is\nnegative, or the (negative) {@linkplain #getPhase() current phase}\nif terminated\n@throws InterruptedException if thread interrupted while waiting", "input": "Java", "output": "public int awaitAdvanceInterruptibly(int phase)\n        throws InterruptedException {\n        final Phaser root = this.root;\n        long s = (root == this) ? state : reconcileState();\n        int p = (int)(s >>> PHASE_SHIFT);\n        if (phase < 0)\n            return phase;\n        if (p == phase) {\n            QNode node = new QNode(this, phase, true, false, 0L);\n            p = root.internalAwaitAdvance(phase, node);\n            if (node.wasInterrupted)\n                throw new InterruptedException();\n        }\n        return p;\n    }"}, {"instruction": "\u6784\u5efa\u7533\u8bf7\u6263\u6b3e\u7684Map\n\n@return \u7533\u8bf7\u6263\u6b3e\u7684Map", "input": "Java", "output": "public Map<String, String> pappayapplyBuild() {\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tmap.put(\"appid\", getAppId());\n\t\tmap.put(\"mch_id\", getMchId());\n\t\tmap.put(\"nonce_str\", getNonceStr());\n\t\tmap.put(\"body\", getBody());\n\t\tmap.put(\"attach\", getAttach());\n\t\tmap.put(\"out_trade_no\", getOutTradeNo());\n\t\tmap.put(\"total_fee\", getTotalFee());\n\t\tmap.put(\"spbill_create_ip\", getSpbillCreateIp());\n\t\tmap.put(\"notify_url\", getNotifyUrl());\n\t\tmap.put(\"trade_type\", getTradeType().name());\n\t\tmap.put(\"contract_id\", getContractId());\n\t\tmap.put(\"sign\", PaymentKit.createSign(map, getPaternerKey()));\n\t\treturn map;\n\t}"}, {"instruction": "Return next n bytes in this buffer.", "input": "Java", "output": "public final LogBuffer duplicate(final int len) {\r\n        if (position + len > origin + limit) throw new IllegalArgumentException(\"limit excceed: \"\r\n                                                                                + (position + len - origin));\r\n\r\n        // XXX: Do momery copy avoid buffer modified.\r\n        final int end = position + len;\r\n        byte[] buf = Arrays.copyOfRange(buffer, position, end);\r\n        LogBuffer dupBuffer = new LogBuffer(buf, 0, len);\r\n        position = end;\r\n        return dupBuffer;\r\n    }"}, {"instruction": "Bind indexed elements to the supplied collection.\n@param name the name of the property to bind\n@param target the target bindable\n@param elementBinder the binder to use for elements\n@param aggregateType the aggregate type, may be a collection or an array\n@param elementType the element type\n@param result the destination for results", "input": "Java", "output": "protected final void bindIndexed(ConfigurationPropertyName name, Bindable<?> target,\n\t\t\tAggregateElementBinder elementBinder, ResolvableType aggregateType,\n\t\t\tResolvableType elementType, IndexedCollectionSupplier result) {\n\t\tfor (ConfigurationPropertySource source : getContext().getSources()) {\n\t\t\tbindIndexed(source, name, target, elementBinder, result, aggregateType,\n\t\t\t\t\telementType);\n\t\t\tif (result.wasSupplied() && result.get() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}"}, {"instruction": "[TARGET waitFor(RetryOption...)]", "input": "Java", "output": "public boolean waitForWithOptions() throws InterruptedException {\n    try {\n      // [START ]\n      Job completedJob =\n          job.waitFor(\n              RetryOption.initialRetryDelay(Duration.ofSeconds(1)),\n              RetryOption.totalTimeout(Duration.ofMinutes(1)));\n      if (completedJob == null) {\n        // job no longer exists\n      } else if (completedJob.getStatus().getError() != null) {\n        // job failed, handle error\n      } else {\n        // job completed successfully\n      }\n      // [END ]\n    } catch (BigQueryException e) {\n      if (e.getCause() instanceof PollException) {\n        return false;\n      }\n      throw e;\n    }\n    return true;\n  }"}, {"instruction": "Gets the most recent health check results for each IP for the instance that is referenced by\nthe given target pool.\n\n<p>Sample code:\n\n<pre><code>\ntry (TargetPoolClient targetPoolClient = TargetPoolClient.create()) {\nProjectRegionTargetPoolName targetPool = ProjectRegionTargetPoolName.of(\"[PROJECT]\", \"[REGION]\", \"[TARGET_POOL]\");\nInstanceReference instanceReferenceResource = InstanceReference.newBuilder().build();\nTargetPoolInstanceHealth response = targetPoolClient.getHealthTargetPool(targetPool, instanceReferenceResource);\n}\n</code></pre>\n\n@param targetPool Name of the TargetPool resource to which the queried instance belongs.\n@param instanceReferenceResource\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final TargetPoolInstanceHealth getHealthTargetPool(\n      ProjectRegionTargetPoolName targetPool, InstanceReference instanceReferenceResource) {\n\n    GetHealthTargetPoolHttpRequest request =\n        GetHealthTargetPoolHttpRequest.newBuilder()\n            .setTargetPool(targetPool == null ? null : targetPool.toString())\n            .setInstanceReferenceResource(instanceReferenceResource)\n            .build();\n    return getHealthTargetPool(request);\n  }"}, {"instruction": "Create an n dimensional index\nbased on the given interval indices.\nStart and end represent the begin and\nend of each interval\n@param start the start indexes\n@param end the end indexes\n@return the interval index relative to the given\nstart and end indices", "input": "Java", "output": "public static INDArrayIndex[] createFromStartAndEnd(INDArray start, INDArray end) {\n        if (start.length() != end.length())\n            throw new IllegalArgumentException(\"Start length must be equal to end length\");\n        else {\n            if (start.length() > Integer.MAX_VALUE)\n                throw new ND4JIllegalStateException(\"Can't proceed with INDArray with length > Integer.MAX_VALUE\");\n\n            INDArrayIndex[] indexes = new INDArrayIndex[(int) start.length()];\n            for (int i = 0; i < indexes.length; i++) {\n                indexes[i] = NDArrayIndex.interval(start.getInt(i), end.getInt(i));\n            }\n            return indexes;\n        }\n    }"}, {"instruction": "This code is more complicated than you would think because we might require multiple\ntransferTo invocations in order to transfer a single MessageWithHeader to avoid busy waiting.\n\nThe contract is that the caller will ensure position is properly set to the total number\nof bytes transferred so far (i.e. value returned by transferred()).", "input": "Java", "output": "@Override\n  public long transferTo(final WritableByteChannel target, final long position) throws IOException {\n    Preconditions.checkArgument(position == totalBytesTransferred, \"Invalid position.\");\n    // Bytes written for header in this call.\n    long writtenHeader = 0;\n    if (header.readableBytes() > 0) {\n      writtenHeader = copyByteBuf(header, target);\n      totalBytesTransferred += writtenHeader;\n      if (header.readableBytes() > 0) {\n        return writtenHeader;\n      }\n    }\n\n    // Bytes written for body in this call.\n    long writtenBody = 0;\n    if (body instanceof FileRegion) {\n      writtenBody = ((FileRegion) body).transferTo(target, totalBytesTransferred - headerLength);\n    } else if (body instanceof ByteBuf) {\n      writtenBody = copyByteBuf((ByteBuf) body, target);\n    }\n    totalBytesTransferred += writtenBody;\n\n    return writtenHeader + writtenBody;\n  }"}, {"instruction": "Set current key context of this window set.\n\n<p>Notes: {@code initializeCache(Object)} must be called before\n{@link #addWindow(Window, MergeFunction)} and {@link #retireWindow(Window)}\n\n@param key the current access key", "input": "Java", "output": "public void initializeCache(Object key) throws Exception {\n\t\tthis.sortedWindows = cachedSortedWindows.get(key);\n\t\tif (sortedWindows == null) {\n\t\t\tthis.sortedWindows = new TreeSet<>();\n\t\t\tIterator<Map.Entry<W, W>> keyValues = mapping.iterator();\n\t\t\tif (keyValues != null) {\n\t\t\t\twhile (keyValues.hasNext()) {\n\t\t\t\t\tMap.Entry<W, W> keyValue = keyValues.next();\n\t\t\t\t\tthis.sortedWindows.add(keyValue.getKey());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcachedSortedWindows.put(key, sortedWindows);\n\t\t}\n\t}"}, {"instruction": "Indicates progress by number.\n\n@param number The number", "input": "Java", "output": "@Override\n    public void indicateProgress(int number) {\n        verifySystemOut();\n        progressIndicatorActive = true;\n        String currMsg = lastMessage;\n        try {\n            if (isAnsiEnabled()) {\n                updateStatus(currMsg + ' ' + number);\n            } else {\n                out.print(\"..\");\n                out.print(number);\n            }\n        } finally {\n            lastMessage = currMsg;\n        }\n    }"}, {"instruction": "\u6267\u884cShell\u547d\u4ee4\n\n@param session Session\u4f1a\u8bdd\n@param cmd \u547d\u4ee4\n@param charset \u53d1\u9001\u548c\u8bfb\u53d6\u5185\u5bb9\u7684\u7f16\u7801\n@param errStream \u9519\u8bef\u4fe1\u606f\u8f93\u51fa\u5230\u7684\u4f4d\u7f6e\n@return {@link ChannelExec}\n@since 4.3.1", "input": "Java", "output": "public static String exec(Session session, String cmd, Charset charset, OutputStream errStream) {\r\n\t\tif (null == charset) {\r\n\t\t\tcharset = CharsetUtil.CHARSET_UTF_8;\r\n\t\t}\r\n\t\tChannelExec channel = (ChannelExec) openChannel(session, ChannelType.EXEC);\r\n\t\tchannel.setCommand(StrUtil.bytes(cmd, charset));\r\n\t\tchannel.setInputStream(null);\r\n\t\tchannel.setErrStream(errStream);\r\n\t\tInputStream in = null;\r\n\t\ttry {\r\n\t\t\tin = channel.getInputStream();\r\n\t\t\treturn IoUtil.read(in, CharsetUtil.CHARSET_UTF_8);\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new IORuntimeException(e);\r\n\t\t} finally {\r\n\t\t\tIoUtil.close(in);\r\n\t\t\tclose(channel);\r\n\t\t}\r\n\t}"}, {"instruction": "\u901a\u8fc7DS\u6267\u884csql", "input": "Java", "output": "public static Object sqlRS(DataSource ds, String sql, Function<ResultSet, Object> fun) {\n        try (Connection conn = ds.getConnection();\n                Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {\n            stmt.setFetchSize(Integer.MIN_VALUE);\n            try (ResultSet rs = stmt.executeQuery(sql)) {\n                return fun.apply(rs);\n            }\n        } catch (Exception e) {\n            logger.error(\"sqlRs has error, sql: {} \", sql);\n            throw new RuntimeException(e);\n        }\n    }"}, {"instruction": "Attaches an existing Disk resource to an instance. You must first create the disk before you\ncan attach it. It is not possible to create and attach a disk at the same time. For more\ninformation, read Adding a persistent disk to your instance.\n\n<p>Sample code:\n\n<pre><code>\ntry (InstanceClient instanceClient = InstanceClient.create()) {\nProjectZoneInstanceName instance = ProjectZoneInstanceName.of(\"[PROJECT]\", \"[ZONE]\", \"[INSTANCE]\");\nBoolean forceAttach = false;\nAttachedDisk attachedDiskResource = AttachedDisk.newBuilder().build();\nOperation response = instanceClient.attachDiskInstance(instance, forceAttach, attachedDiskResource);\n}\n</code></pre>\n\n@param instance The instance name for this request.\n@param forceAttach Whether to force attach the disk even if it's currently attached to another\ninstance.\n@param attachedDiskResource An instance-attached disk resource.\n@throws com.google.api.gax.rpc.ApiException if the remote call fails", "input": "Java", "output": "@BetaApi\n  public final Operation attachDiskInstance(\n      ProjectZoneInstanceName instance, Boolean forceAttach, AttachedDisk attachedDiskResource) {\n\n    AttachDiskInstanceHttpRequest request =\n        AttachDiskInstanceHttpRequest.newBuilder()\n            .setInstance(instance == null ? null : instance.toString())\n            .setForceAttach(forceAttach)\n            .setAttachedDiskResource(attachedDiskResource)\n            .build();\n    return attachDiskInstance(request);\n  }"}, {"instruction": "Append a log event at the appropriate JUL level, depending on the log4j level.", "input": "Java", "output": "@Override\n    protected void append(LoggingEvent loggingEvent)\n    {\n        java.util.logging.Logger logger = java.util.logging.Logger.getLogger(loggingEvent.getLoggerName());\n        if (logger == null) {\n            LogLog.warn(format(\"Cannot obtain JUL %s. Verify that this appender is used while an appropriate LogManager is active.\", loggingEvent.getLoggerName()));\n            return;\n        }\n\n        Level level = loggingEvent.getLevel();\n        java.util.logging.Level julLevel = convertLog4jLevel(level);\n\n        LogRecord record = new LogRecord(julLevel, loggingEvent.getRenderedMessage());\n        record.setMillis(loggingEvent.getTimeStamp());\n        LocationInfo location = loggingEvent.getLocationInformation();\n        if (location != null) {\n            record.setSourceClassName(location.getClassName());\n            record.setSourceMethodName(location.getMethodName());\n        }\n\n        logger.log(record);\n    }"}, {"instruction": "---------------------------------------------------------------------", "input": "Java", "output": "public SlotReport createSlotReport(ResourceID resourceId) {\n\t\tfinal int numberSlots = taskSlots.size();\n\n\t\tList<SlotStatus> slotStatuses = Arrays.asList(new SlotStatus[numberSlots]);\n\n\t\tfor (int i = 0; i < numberSlots; i++) {\n\t\t\tTaskSlot taskSlot = taskSlots.get(i);\n\t\t\tSlotID slotId = new SlotID(resourceId, taskSlot.getIndex());\n\n\t\t\tSlotStatus slotStatus = new SlotStatus(\n\t\t\t\tslotId,\n\t\t\t\ttaskSlot.getResourceProfile(),\n\t\t\t\ttaskSlot.getJobId(),\n\t\t\t\ttaskSlot.getAllocationId());\n\n\t\t\tslotStatuses.set(i, slotStatus);\n\t\t}\n\n\t\tfinal SlotReport slotReport = new SlotReport(slotStatuses);\n\n\t\treturn slotReport;\n\t}"}, {"instruction": "Triggers the schedule update now.\n\nTODO: ajax on the client side to wait until the update completion might be nice.", "input": "Java", "output": "@RequirePOST\n    public void doUpdateNow( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n        \n        for (NodeMonitor nodeMonitor : NodeMonitor.getAll()) {\n            Thread t = nodeMonitor.triggerUpdate();\n            String columnCaption = nodeMonitor.getColumnCaption();\n            if (columnCaption != null) {\n                t.setName(columnCaption);\n            }\n        }\n        rsp.forwardToPreviousPage(req);\n    }"}, {"instruction": "arg.toFloat", "input": "Java", "output": "public static java.lang.Float toFloat(Object arg) throws NoSuchMethodException {\n        if (arg instanceof java.lang.Integer) return boxToFloat((float)unboxToInt(arg));\n        if (arg instanceof java.lang.Long) return boxToFloat((float)unboxToLong(arg));\n        if (arg instanceof java.lang.Float) return (java.lang.Float)arg;\n        if (arg instanceof java.lang.Double) return boxToFloat((float)unboxToDouble(arg));\n        if (arg instanceof java.lang.Character) return boxToFloat((float)unboxToChar(arg));\n        if (arg instanceof java.lang.Byte) return boxToFloat((float)unboxToByte(arg));\n        if (arg instanceof java.lang.Short) return boxToFloat((float)unboxToShort(arg));\n        throw new NoSuchMethodException();\n    }"}, {"instruction": "US-ASCII characters excluding CTLs, whitespace, DQUOTE, comma, semicolon, and backslash", "input": "Java", "output": "private static BitSet validCookieValueOctets() {\n        BitSet bits = new BitSet(8);\n        for (int i = 35; i < 127; i++) {\n            // US-ASCII characters excluding CTLs (%x00-1F / %x7F)\n            bits.set(i);\n        }\n        bits.set('\"', false);  // exclude DQUOTE = %x22\n        bits.set(',', false);  // exclude comma = %x2C\n        bits.set(';', false);  // exclude semicolon = %x3B\n        bits.set('\\\\', false); // exclude backslash = %x5C\n        return bits;\n    }"}, {"instruction": "Optimize a Filtration for querying, possibly pulling out intervals and simplifying the dimFilter in the process.\n\n@return equivalent Filtration", "input": "Java", "output": "public Filtration optimize(final DruidQuerySignature querySignature)\n  {\n    return transform(\n        this,\n        ImmutableList.of(\n            CombineAndSimplifyBounds.instance(),\n            MoveTimeFiltersToIntervals.instance(),\n            ConvertBoundsToSelectors.create(querySignature),\n            ConvertSelectorsToIns.create(querySignature.getRowSignature()),\n            MoveMarkerFiltersToIntervals.instance(),\n            ValidateNoMarkerFiltersRemain.instance()\n        )\n    );\n  }"}, {"instruction": "\u83b7\u53d6{@link KeyGenerator}\n\n@param algorithm \u5bf9\u79f0\u52a0\u5bc6\u7b97\u6cd5\n@return {@link KeyGenerator}\n@since 4.5.2", "input": "Java", "output": "public static KeyGenerator getKeyGenerator(String algorithm) {\r\n\t\tfinal Provider provider = GlobalBouncyCastleProvider.INSTANCE.getProvider();\r\n\r\n\t\tKeyGenerator generator;\r\n\t\ttry {\r\n\t\t\tgenerator = (null == provider) //\r\n\t\t\t\t\t? KeyGenerator.getInstance(getMainAlgorithm(algorithm)) //\r\n\t\t\t\t\t: KeyGenerator.getInstance(getMainAlgorithm(algorithm), provider);\r\n\t\t} catch (NoSuchAlgorithmException e) {\r\n\t\t\tthrow new CryptoException(e);\r\n\t\t}\r\n\t\treturn generator;\r\n\t}"}, {"instruction": "\u5904\u7406\u5b57\u6bb5\u6620\u5c04", "input": "Java", "output": "private List<EventColumn> translateColumns(EventData data, List<EventColumn> columns, DataMediaPair dataMediaPair,\n                                               Multimap<String, String> translateColumnNames,\n                                               TableInfoHolder tableHolder) {\n        List<EventColumn> tcolumns = new ArrayList<EventColumn>();\n        for (EventColumn scolumn : columns) {\n            EventColumn tcolumn = translateColumn(data, scolumn, tableHolder, dataMediaPair, translateColumnNames);\n            if (tcolumn != null) {\n                tcolumns.add(tcolumn);\n            }\n        }\n        return tcolumns;\n    }"}, {"instruction": "\u8f6c\u6362\u6beb\u79d2\u4e3a\u5e26\u65f6\u95f4\u5355\u4f4d\u7684\u5b57\u7b26\u4e32\uff0c\u4f1a\u540c\u65f6\u5e26\u4e0b\u4e00\u7ea7\u7684\u5355\u4f4d\uff0c\u56db\u820d\u4e94\u5165", "input": "Java", "output": "public static String toTimeWithMinorUnit(long millis) {\n\t\tif (millis < MILLIS_PER_SECOND) {\n\t\t\treturn String.format(\"%4dms\", millis);\n\t\t}\n\n\t\tif (millis < MILLIS_PER_MINUTE) {\n\t\t\treturn String.format(\"%02ds\", millis / MILLIS_PER_SECOND);\n\t\t}\n\n\t\tif (millis < MILLIS_PER_HOUR) {\n\t\t\treturn String.format(\"%02dm%02ds\", millis / MILLIS_PER_MINUTE, (millis / MILLIS_PER_SECOND) % 60);\n\t\t}\n\n\t\tif (millis < MILLIS_PER_DAY) {\n\t\t\treturn String.format(\"%02dh%02dm\", millis / MILLIS_PER_HOUR, (millis / MILLIS_PER_MINUTE) % 60);\n\t\t}\n\n\t\treturn String.format(\"%dd%02dh\", millis / MILLIS_PER_DAY, (millis / MILLIS_PER_HOUR) % 24);\n\t}"}, {"instruction": "For the garbage collector in Java, it's better to keep new objects short-living, but once they are old enough\n(i. e. promoted to old generation), try to keep them alive. In {@link #poll()}, we fetch and deserialize all\nexisting segments each time, and then replace them in {@link #dataSources}. This method allows to use already\nexisting (old) segments when possible, effectively interning them a-la {@link String#intern} or {@link\ncom.google.common.collect.Interner}, aiming to make the majority of {@link DataSegment} objects garbage soon after\nthey are deserialized and to die in young generation. It allows to avoid fragmentation of the old generation and\nfull GCs.", "input": "Java", "output": "private DataSegment replaceWithExistingSegmentIfPresent(DataSegment segment)\n  {\n    DruidDataSource dataSource = Optional.ofNullable(dataSources).map(m -> m.get(segment.getDataSource())).orElse(null);\n    if (dataSource == null) {\n      return segment;\n    }\n    DataSegment alreadyExistingSegment = dataSource.getSegment(segment.getId());\n    return alreadyExistingSegment != null ? alreadyExistingSegment : segment;\n  }"}, {"instruction": "Gets a single {@link S3ObjectSummary} from s3. Since this method might return a wrong object if there are multiple\nobjects that match the given key, this method should be used only when it's guaranteed that the given key is unique\nin the given bucket.\n\n@param s3Client s3 client\n@param bucket   s3 bucket\n@param key      unique key for the object to be retrieved", "input": "Java", "output": "public static S3ObjectSummary getSingleObjectSummary(ServerSideEncryptingAmazonS3 s3Client, String bucket, String key)\n  {\n    final ListObjectsV2Request request = new ListObjectsV2Request()\n        .withBucketName(bucket)\n        .withPrefix(key)\n        .withMaxKeys(1);\n    final ListObjectsV2Result result = s3Client.listObjectsV2(request);\n\n    // Using getObjectSummaries().size() instead of getKeyCount as, in some cases\n    // it is observed that even though the getObjectSummaries returns some data\n    // keyCount is still zero.\n    if (result.getObjectSummaries().size() == 0) {\n      throw new ISE(\"Cannot find object for bucket[%s] and key[%s]\", bucket, key);\n    }\n    final S3ObjectSummary objectSummary = result.getObjectSummaries().get(0);\n    if (!objectSummary.getBucketName().equals(bucket) || !objectSummary.getKey().equals(key)) {\n      throw new ISE(\"Wrong object[%s] for bucket[%s] and key[%s]\", objectSummary, bucket, key);\n    }\n\n    return objectSummary;\n  }"}, {"instruction": "Returns type variable equivalent to {@code element}.", "input": "Java", "output": "public static TypeVariableName get(TypeParameterElement element) {\n    String name = element.getSimpleName().toString();\n    List<? extends TypeMirror> boundsMirrors = element.getBounds();\n\n    List<TypeName> boundsTypeNames = new ArrayList<>();\n    for (TypeMirror typeMirror : boundsMirrors) {\n      boundsTypeNames.add(TypeName.get(typeMirror));\n    }\n\n    return TypeVariableName.of(name, boundsTypeNames);\n  }"}, {"instruction": "Returns the boolean value to which the specified key is mapped,\nor defaultValue if there is no mapping for the key. The key match is case-insensitive.", "input": "Java", "output": "public boolean getBoolean(String key, boolean defaultValue) {\n    String value = get(key);\n    // We can't use `Boolean.parseBoolean` here, as it returns false for invalid strings.\n    if (value == null) {\n      return defaultValue;\n    } else if (value.equalsIgnoreCase(\"true\")) {\n      return true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      return false;\n    } else {\n      throw new IllegalArgumentException(value + \" is not a boolean string.\");\n    }\n  }"}, {"instruction": "TODO: remove @NonNull check here", "input": "Java", "output": "protected void handleMessage(@NonNull VoidMessage message) {\n        if (message == null) {\n            //            log.info(\"sI_{} got null message\", getShardIndex());\n            return;\n        }\n\n        if (message.getTargetId() >= 0 && message.getTargetId() != shardIndex) {\n            log.warn(\"sI_{}: Skipping message: [{}]; TargetIdx: [{}]\", shardIndex, message.getClass().getSimpleName(),\n                            message.getTargetId());\n            return;\n        }\n\n        //      log.info(\"sI_{}: Processing message: [{}]\", shardIndex, message.getClass().getSimpleName());\n\n        message.attachContext(voidConfiguration, trainer, clipboard, transport, storage, nodeRole, shardIndex);\n        message.processMessage();\n    }"}, {"instruction": "Resolves a single generic type argument for the given field.\n\n@param field The field\n@return The type argument or {@link Optional#empty()}", "input": "Java", "output": "public static Optional<Class> resolveGenericTypeArgument(Field field) {\n        Type genericType = field != null ? field.getGenericType() : null;\n        if (genericType instanceof ParameterizedType) {\n            Type[] typeArguments = ((ParameterizedType) genericType).getActualTypeArguments();\n            if (typeArguments.length > 0) {\n                Type typeArg = typeArguments[0];\n                return resolveParameterizedTypeArgument(typeArg);\n            }\n        }\n        return Optional.empty();\n    }"}, {"instruction": "Creates a new buffer whose content is a copy of the specified\n{@code buffer}'s current slice.  The new buffer's {@code readerIndex}\nand {@code writerIndex} are {@code 0} and {@code buffer.remaining}\nrespectively.", "input": "Java", "output": "public static ByteBuf copiedBuffer(ByteBuffer buffer) {\n        int length = buffer.remaining();\n        if (length == 0) {\n            return EMPTY_BUFFER;\n        }\n        byte[] copy = PlatformDependent.allocateUninitializedArray(length);\n        // Duplicate the buffer so we not adjust the position during our get operation.\n        // See https://github.com/netty/netty/issues/3896\n        ByteBuffer duplicate = buffer.duplicate();\n        duplicate.get(copy);\n        return wrappedBuffer(copy).order(duplicate.order());\n    }"}, {"instruction": "Initializes the type system.", "input": "Java", "output": "@Override\n    public void typeSystemInit(TypeSystem typeSystem) throws AnalysisEngineProcessException {\n\n        // sentence type\n        this.sentenceType = AnnotatorUtil.getRequiredTypeParameter(this.context, typeSystem,\n                        UimaUtil.SENTENCE_TYPE_PARAMETER);\n\n        // token type\n        this.tokenType = AnnotatorUtil.getRequiredTypeParameter(this.context, typeSystem,\n                        UimaUtil.TOKEN_TYPE_PARAMETER);\n\n        // pos feature\n        this.posFeature = AnnotatorUtil.getRequiredFeatureParameter(this.context, this.tokenType,\n                        UimaUtil.POS_FEATURE_PARAMETER, CAS.TYPE_NAME_STRING);\n\n        this.probabilityFeature = AnnotatorUtil.getOptionalFeatureParameter(this.context, this.tokenType,\n                        UimaUtil.PROBABILITY_FEATURE_PARAMETER, CAS.TYPE_NAME_DOUBLE);\n    }"}, {"instruction": "Export the scores in delimited (one per line) UTF-8 format with the specified delimiter\n\n@param outputStream Stream to write to\n@param delimiter    Delimiter to use", "input": "Java", "output": "public void exportScores(OutputStream outputStream, String delimiter) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Iteration\").append(delimiter).append(\"Score\");\n        for (Pair<Integer, Double> p : scoreVsIter) {\n            sb.append(\"\\n\").append(p.getFirst()).append(delimiter).append(p.getSecond());\n        }\n        outputStream.write(sb.toString().getBytes(\"UTF-8\"));\n    }"}, {"instruction": "Parse the supplied XML file data to a {@link Document}.\n@param file The file to parse.\n@param encoding The encoding of the XML in the file.\n@return The parsed document.\n@throws SAXException Error parsing the XML file data e.g. badly formed XML.\n@throws IOException Error reading from the file.\n@since 2.0", "input": "Java", "output": "public static @Nonnull Document parse(@Nonnull File file, @Nonnull String encoding) throws SAXException, IOException {\n        if (!file.exists() || !file.isFile()) {\n            throw new IllegalArgumentException(String.format(\"File %s does not exist or is not a 'normal' file.\", file.getAbsolutePath()));\n        }\n\n        try (InputStream fileInputStream = Files.newInputStream(file.toPath());\n            InputStreamReader fileReader = new InputStreamReader(fileInputStream, encoding)) {\n            return parse(fileReader);\n        } catch (InvalidPathException e) {\n            throw new IOException(e);\n        }\n    }"}, {"instruction": "Gets a command line string, which can be passed to agent start command.\n\n@param computer Computer, for which the arguments need to be constructed.\n@return Command line arguments.\nIt may be empty if the working directory is disabled or\nif the Computer type is not {@link SlaveComputer}.", "input": "Java", "output": "@Nonnull\n    @Restricted(NoExternalUse.class)\n    public String toCommandLineString(@Nonnull SlaveComputer computer) {\n        if(disabled) {\n            return \"\";\n        }\n        \n        StringBuilder bldr = new StringBuilder();\n        bldr.append(\"-workDir \\\"\");\n        if (workDirPath == null) {\n            Slave node = computer.getNode();\n            if (node == null) {\n                // It is not possible to launch this node anyway.\n                return \"\";\n            }\n            bldr.append(node.getRemoteFS());\n        } else {\n            bldr.append(workDirPath);\n        }\n        bldr.append(\"\\\"\");\n        \n        if (!DEFAULT_INTERNAL_DIR.equals(internalDir)) {\n            bldr.append(\" -internalDir \\\"\");\n            bldr.append(internalDir);\n            bldr.append(\"\\\"\");\n        }\n        \n        if (failIfWorkDirIsMissing) {\n            bldr.append(\" -failIfWorkDirIsMissing\"); \n        }\n                \n        return bldr.toString();\n    }"}, {"instruction": "\u8bbe\u7f6e\u901a\u7528Mapper\u914d\u7f6e\n\n@param config", "input": "Java", "output": "public void setConfig(Config config) {\n        this.config = config;\n        if(config.getResolveClass() != null){\n            try {\n                EntityHelper.setResolve(config.getResolveClass().newInstance());\n            } catch (Exception e) {\n                throw new MapperException(\"\u521b\u5efa \" + config.getResolveClass().getCanonicalName()\n                        + \" \u5b9e\u4f8b\u5931\u8d25\uff0c\u8bf7\u4fdd\u8bc1\u8be5\u7c7b\u6709\u9ed8\u8ba4\u7684\u6784\u9020\u65b9\u6cd5!\", e);\n            }\n        }\n        if(config.getMappers() != null && config.getMappers().size() > 0){\n            for (Class mapperClass : config.getMappers()) {\n                registerMapper(mapperClass);\n            }\n        }\n    }"}, {"instruction": "Equivalent of \"main\", but non-static.", "input": "Java", "output": "public void run(String[] args) throws Exception {\n    ServerConfiguration.Builder configBuilder = ServerConfiguration.newBuilder();\n    ServerConfiguration config;\n    try {\n      config = configBuilder.build(args);\n    } catch (Exception e) {\n      System.out.println(e.getMessage());\n      configBuilder.printUsage();\n      return;\n    }\n\n    final Server server = newServer(config);\n    server.start();\n\n    System.out.println(\"QPS Server started on \" + config.address);\n\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      @SuppressWarnings(\"CatchAndPrintStackTrace\")\n      public void run() {\n        try {\n          System.out.println(\"QPS Server shutting down\");\n          server.shutdown();\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    });\n    server.awaitTermination();\n  }"}, {"instruction": "\u6784\u5efaIN\u8bed\u53e5\u4e2d\u7684\u503c\u90e8\u5206<br>\n\u5f00\u5934\u5fc5\u987b\u52a0\u7a7a\u683c\uff0c\u7c7b\u4f3c\uff1a\" (?,?,?)\" \u6216\u8005 \" (1,2,3,4)\"\n\n@param conditionStrBuilder \u6761\u4ef6\u8bed\u53e5\u6784\u5efa\u5668\n@param paramValues \u53c2\u6570\u96c6\u5408\uff0c\u7528\u4e8e\u53c2\u6570\u5360\u4f4d\u7b26\u5bf9\u5e94\u53c2\u6570\u56de\u586b", "input": "Java", "output": "private void buildValuePartForIN(StringBuilder conditionStrBuilder, List<Object> paramValues) {\r\n\t\tconditionStrBuilder.append(\" (\");\r\n\t\tfinal Object value = this.value;\r\n\t\tif (isPlaceHolder()) {\r\n\t\t\tList<?> valuesForIn;\r\n\t\t\t// \u5360\u4f4d\u7b26\u5bf9\u5e94\u503c\u5217\u8868\r\n\t\t\tif (value instanceof CharSequence) {\r\n\t\t\t\tvaluesForIn = StrUtil.split((CharSequence) value, ',');\r\n\t\t\t} else {\r\n\t\t\t\tvaluesForIn = Arrays.asList(Convert.convert(String[].class, value));\r\n\t\t\t\tif (null == valuesForIn) {\r\n\t\t\t\t\tvaluesForIn = CollUtil.newArrayList(Convert.toStr(value));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tconditionStrBuilder.append(StrUtil.repeatAndJoin(\"?\", valuesForIn.size(), \",\"));\r\n\t\t\tif(null != paramValues) {\r\n\t\t\t\tparamValues.addAll(valuesForIn);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tconditionStrBuilder.append(StrUtil.join(\",\", value));\r\n\t\t}\r\n\t\tconditionStrBuilder.append(')');\r\n\t}"}, {"instruction": "Returns the trailers. It is only safe to call this once the source stream has been completely\nexhausted.", "input": "Java", "output": "public synchronized Headers trailers() throws IOException {\n    if (errorCode != null) {\n      throw errorException != null ? errorException : new StreamResetException(errorCode);\n    }\n    if (!source.finished || !source.receiveBuffer.exhausted() || !source.readBuffer.exhausted()) {\n      throw new IllegalStateException(\"too early; can't read the trailers yet\");\n    }\n    return source.trailers != null ? source.trailers : Util.EMPTY_HEADERS;\n  }"}, {"instruction": "Returns the HBase identifiers of all registered column qualifiers for a specific column family.\n\n@param family The name of the column family for which the column qualifier identifiers are returned.\n@return The HBase identifiers of all registered column qualifiers for a specific column family.", "input": "Java", "output": "byte[][] getQualifierKeys(String family) {\n\t\tMap<String, TypeInformation<?>> qualifierMap = familyMap.get(family);\n\n\t\tif (qualifierMap == null) {\n\t\t\tthrow new IllegalArgumentException(\"Family \" + family + \" does not exist in schema.\");\n\t\t}\n\t\tCharset c = Charset.forName(charset);\n\n\t\tbyte[][] qualifierKeys = new byte[qualifierMap.size()][];\n\t\tint i = 0;\n\t\tfor (String name : qualifierMap.keySet()) {\n\t\t\tqualifierKeys[i++] = name.getBytes(c);\n\t\t}\n\t\treturn qualifierKeys;\n\t}"}, {"instruction": "Determines if the candidate should be accepted into the main space, as determined by its\nfrequency relative to the victim. A small amount of randomness is used to protect against hash\ncollision attacks, where the victim's frequency is artificially raised so that no new entries\nare admitted.\n\n@param candidateKey the key for the entry being proposed for long term retention\n@param victimKey the key for the entry chosen by the eviction policy for replacement\n@return if the candidate should be admitted and the victim ejected", "input": "Java", "output": "@GuardedBy(\"evictionLock\")\n  boolean admit(K candidateKey, K victimKey) {\n    int victimFreq = frequencySketch().frequency(victimKey);\n    int candidateFreq = frequencySketch().frequency(candidateKey);\n    if (candidateFreq > victimFreq) {\n      return true;\n    } else if (candidateFreq <= 5) {\n      // The maximum frequency is 15 and halved to 7 after a reset to age the history. An attack\n      // exploits that a hot candidate is rejected in favor of a hot victim. The threshold of a warm\n      // candidate reduces the number of random acceptances to minimize the impact on the hit rate.\n      return false;\n    }\n    int random = ThreadLocalRandom.current().nextInt();\n    return ((random & 127) == 0);\n  }"}, {"instruction": "Wait for a message to arrive for this mailbox.\n\n@param timeout\nthe time, in milliseconds, to wait for a message before\nreturning null.\n\n@return an {@link OtpErlangObject OtpErlangObject} representing the body\nof the next message waiting in this mailbox.\n\n@exception OtpErlangDecodeException\nif the message cannot be decoded.\n\n@exception OtpErlangExit\nif a linked {@link OtpErlangPid pid} has exited or has\nsent an exit signal to this mailbox.", "input": "Java", "output": "public OtpErlangObject receive(final long timeout) throws OtpErlangExit,\n            OtpErlangDecodeException {\n        try {\n            final OtpMsg m = receiveMsg(timeout);\n            if (m != null) {\n                return m.getMsg();\n            }\n        } catch (final OtpErlangExit e) {\n            throw e;\n        } catch (final OtpErlangDecodeException f) {\n            throw f;\n        } catch (final InterruptedException g) {\n        }\n        return null;\n    }"}, {"instruction": "Is cas authentication available?\n\n@param context the context\n@return the optional authn", "input": "Java", "output": "public Optional<Authentication> isCasAuthenticationAvailable(final WebContext context) {\n        val j2EContext = (J2EContext) context;\n        if (j2EContext != null) {\n            val tgtId = ticketGrantingTicketCookieGenerator.retrieveCookieValue(j2EContext.getRequest());\n\n            if (StringUtils.isNotBlank(tgtId)) {\n                val authentication = ticketRegistrySupport.getAuthenticationFrom(tgtId);\n                if (authentication != null) {\n                    return Optional.of(authentication);\n                }\n            }\n        }\n        return Optional.empty();\n    }"}, {"instruction": "Reverses the migration, in case you want to revert to the older format.\n@param args one parameter, {@code $JENKINS_HOME}", "input": "Java", "output": "public static void main(String... args) throws Exception {\n        if (args.length != 1) {\n            throw new Exception(\"pass one parameter, $JENKINS_HOME\");\n        }\n        File root = new File(args[0]);\n        File jobs = new File(root, \"jobs\");\n        if (!jobs.isDirectory()) {\n            throw new FileNotFoundException(\"no such $JENKINS_HOME \" + root);\n        }\n        new RunIdMigrator().unmigrateJobsDir(jobs);\n    }"}, {"instruction": "Rebalances the min-heap by pushing values from the top down and simultaneously updating the reverse index\n\n@param heap         min-heap stored as indices into the array of values\n@param reverseIndex reverse index from the array of values into the heap\n@param start        index to start re-balancing from\n@param end          index to stop re-balancing at\n@param values       values stored in the heap", "input": "Java", "output": "private static void siftDown(int[] heap, int[] reverseIndex, int start, int end, float[] values)\n  {\n    int root = start;\n    while (root * 2 + 1 <= end) {\n      int child = root * 2 + 1;\n      int swap = root;\n      if (values[heap[swap]] > values[heap[child]]) {\n        swap = child;\n      }\n      if (child + 1 <= end && values[heap[swap]] > values[heap[child + 1]]) {\n        swap = child + 1;\n      }\n      if (swap != root) {\n        // swap\n        int tmp = heap[swap];\n        heap[swap] = heap[root];\n        heap[root] = tmp;\n\n        // heap index from delta index\n        reverseIndex[heap[swap]] = swap;\n        reverseIndex[heap[root]] = root;\n\n        root = swap;\n      } else {\n        return;\n      }\n    }\n  }"}, {"instruction": "\u6784\u9020Cluster\u5bf9\u8c61\n\n@param consumerBootstrap \u5ba2\u6237\u7aef\u914d\u7f6e\n@return Cluster\u5bf9\u8c61", "input": "Java", "output": "public static Cluster getCluster(ConsumerBootstrap consumerBootstrap) {\n        try {\n            ConsumerConfig consumerConfig = consumerBootstrap.getConsumerConfig();\n            ExtensionClass<Cluster> ext = ExtensionLoaderFactory.getExtensionLoader(Cluster.class)\n                .getExtensionClass(consumerConfig.getCluster());\n            if (ext == null) {\n                throw ExceptionUtils.buildRuntime(\"consumer.cluster\",\n                    consumerConfig.getCluster(), \"Unsupported cluster of client!\");\n            }\n            return ext.getExtInstance(new Class[] { ConsumerBootstrap.class },\n                new Object[] { consumerBootstrap });\n        } catch (SofaRpcRuntimeException e) {\n            throw e;\n        } catch (Throwable e) {\n            throw new SofaRpcRuntimeException(e.getMessage(), e);\n        }\n    }"}, {"instruction": "\u901a\u8fc7\u54cd\u5e94\u900f\u4f20\u6570\u636e\n\n@param context  RpcInvokeContext\n@param response \u54cd\u5e94", "input": "Java", "output": "public static void carryWithResponse(RpcInvokeContext context, SofaResponse response) {\n        if (context != null) {\n            Map<String, String> responseBaggage = context.getAllResponseBaggage();\n            if (CommonUtils.isNotEmpty(responseBaggage)) {\n                String prefix = RemotingConstants.RPC_RESPONSE_BAGGAGE + \".\";\n                for (Map.Entry<String, String> entry : responseBaggage.entrySet()) {\n                    response.addResponseProp(prefix + entry.getKey(), entry.getValue());\n                }\n            }\n        }\n    }"}, {"instruction": "Convert a orc struct field of the \"root\" {@link OrcStruct} that represents the \"row\". This method has a cache of\nfield names to field index that is ONLY valid for this {@link OrcStruct}, and should not be used for\nnested {@link OrcStruct} fields of the row. Looks up field index by field name, and delegates to\n{@link OrcStructConverter#convertField(OrcStruct, int)}.", "input": "Java", "output": "@Nullable\n  Object convertRootField(OrcStruct struct, String fieldName)\n  {\n    // this cache is only valid for the root level, to skip the indexOf on fieldNames to get the fieldIndex.\n    TypeDescription schema = struct.getSchema();\n    final List<String> fields = schema.getFieldNames();\n    if (fieldIndexCache == null) {\n      fieldIndexCache = new Object2IntOpenHashMap<>(fields.size());\n      for (int i = 0; i < fields.size(); i++) {\n        fieldIndexCache.put(fields.get(i), i);\n      }\n    }\n    WritableComparable wc = struct.getFieldValue(fieldName);\n\n    int fieldIndex = fieldIndexCache.getOrDefault(fieldName, -1);\n\n    return convertField(struct, fieldIndex);\n  }"}, {"instruction": "This method initializes popupMenuFind\n\n@return org.parosproxy.paros.extension.ExtensionPopupMenu", "input": "Java", "output": "private PopupFindMenu getPopupMenuFind() {\r\n        if (popupFindMenu== null) {\r\n            popupFindMenu = new PopupFindMenu();\r\n            popupFindMenu.setText(Constant.messages.getString(\"edit.find.popup\"));\t// ZAP: i18n\r\n            popupFindMenu.addActionListener(new java.awt.event.ActionListener() {\r\n                @Override\r\n                public void actionPerformed(java.awt.event.ActionEvent e) {\r\n                    JTextComponent component = popupFindMenu.getLastInvoker();\r\n                    Window window = getWindowAncestor(component);\r\n                    if (window != null) {\r\n                        showFindDialog(window, component);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        return popupFindMenu;\r\n    }"}, {"instruction": "This method is for compatibilty so that newer version of KafkaIndexTaskIOConfig can be read by\nold version of Druid. Note that this method returns end sequence numbers instead of start. This is because\n{@link SeekableStreamStartSequenceNumbers} didn't exist before.", "input": "Java", "output": "@JsonProperty\n  @Deprecated\n  public SeekableStreamEndSequenceNumbers<Integer, Long> getStartPartitions()\n  {\n    // Converting to start sequence numbers. This is allowed for Kafka because the start offset is always inclusive.\n    final SeekableStreamStartSequenceNumbers<Integer, Long> startSequenceNumbers = getStartSequenceNumbers();\n    return new SeekableStreamEndSequenceNumbers<>(\n        startSequenceNumbers.getStream(),\n        startSequenceNumbers.getPartitionSequenceNumberMap()\n    );\n  }"}, {"instruction": "Sets the order of keys for range partitioning.\nNOTE: Only valid for {@link PartitionMethod#RANGE}.\n\n@param orders array of orders for each specified partition key\n@return The partitioneOperator with properly set orders for given keys", "input": "Java", "output": "@PublicEvolving\n\tpublic PartitionOperator<T> withOrders(Order... orders) {\n\t\tPreconditions.checkState(pMethod == PartitionMethod.RANGE, \"Orders cannot be applied for %s partition \" +\n\t\t\t\t\"method\", pMethod);\n\t\tPreconditions.checkArgument(pKeys.getOriginalKeyFieldTypes().length == orders.length, \"The number of key \" +\n\t\t\t\t\"fields and orders should be the same.\");\n\t\tthis.orders = orders;\n\n\t\treturn this;\n\t}"}, {"instruction": "\u83b7\u5f97 Sofa Runtime \u7684\u65e5\u5fd7\u5bf9\u8c61\uff0c\u6253\u5370\u51fa\u83b7\u5f97\u914d\u7f6e\u4e2d\u5fc3\u5730\u5740", "input": "Java", "output": "private void printUserData(String dataId, UserData userData) {\n        StringBuilder sb = new StringBuilder();\n        int count = 0;\n        if (userData != null && userData.getZoneData() != null) {\n            Map<String, List<String>> oneUserData = userData.getZoneData();\n            for (Map.Entry<String, List<String>> entry : oneUserData.entrySet()) {\n                sb.append(\"  --- \").append(entry.getKey()).append(\"\\n\");\n                for (String provider : entry.getValue()) {\n                    sb.append(\"   >>> \").append((String) provider).append(\"\\n\");\n                    ++count;\n                }\n            }\n        }\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(LogCodes.getLog(LogCodes.INFO_ROUTE_REGISTRY_URLS_HANDLE,\n                dataId, count, sb.toString()));\n        }\n    }"}, {"instruction": "Add a weight parameter to the layer, with the specified shape. For example, a standard fully connected layer\ncould have weight parameters with shape [numInputs, layerSize]\n\n@param paramKey   The parameter key (name) for the weight parameter\n@param paramShape Shape of the weight parameter array", "input": "Java", "output": "public void addWeightParam(@NonNull String paramKey, @NonNull long... paramShape) {\n        Preconditions.checkArgument(paramShape.length > 0, \"Provided weight parameter shape is\"\n                        + \" invalid: length 0 provided for shape. Parameter: \" + paramKey);\n        weightParams.put(paramKey, paramShape);\n        paramsList = null;\n        weightParamsList = null;\n        biasParamsList = null;\n    }"}, {"instruction": "Gets the top nodes from the site tree which contain nodes that are \"In Scope\".\nSearches recursively starting from the root node.\nShould be used with care, as it is time-consuming, querying the database for\nevery node in the Site Tree.\n\n@return the nodes in scope from site tree", "input": "Java", "output": "public List<SiteNode> getTopNodesInScopeFromSiteTree() {\r\n\t\tList<SiteNode> nodes = new LinkedList<>();\r\n\t\tSiteNode rootNode = getSiteTree().getRoot();\r\n\t\t@SuppressWarnings(\"unchecked\")\r\n\t\tEnumeration<TreeNode> en = rootNode.children();\r\n\t\twhile (en.hasMoreElements()) {\r\n\t\t\tSiteNode sn = (SiteNode) en.nextElement();\r\n\t\t\tif (isContainsNodesInScope(sn)) {\r\n\t\t\t\tnodes.add(sn);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn nodes;\r\n\t}"}, {"instruction": "Returns the default project ID, or {@code null} if no default project ID could be found. This\nmethod returns the first available project ID among the following sources:\n\n<ol>\n<li>The project ID specified by the GOOGLE_CLOUD_PROJECT environment variable\n<li>The App Engine project ID\n<li>The project ID specified in the JSON credentials file pointed by the {@code\nGOOGLE_APPLICATION_CREDENTIALS} environment variable\n<li>The Google Cloud SDK project ID\n<li>The Compute Engine project ID\n</ol>", "input": "Java", "output": "public static String getDefaultProjectId() {\n    String projectId = System.getProperty(PROJECT_ENV_NAME, System.getenv(PROJECT_ENV_NAME));\n    if (projectId == null) {\n      projectId =\n          System.getProperty(LEGACY_PROJECT_ENV_NAME, System.getenv(LEGACY_PROJECT_ENV_NAME));\n    }\n    if (projectId == null) {\n      projectId = getAppEngineProjectId();\n    }\n    if (projectId == null) {\n      projectId = getServiceAccountProjectId();\n    }\n    return projectId != null ? projectId : getGoogleCloudProjectId();\n  }"}, {"instruction": "partition a[left] to a[right], assumes left < right", "input": "Java", "output": "private int partition(double[] a, int[] indexes, int left, int right) {\n        int i = left - 1;\n        int j = right;\n        while (true) {\n            while (a[indexes[++i]] < a[indexes[right]]); // find item on left to swap, a[right] acts as sentinel\n            while (a[indexes[right]] < a[indexes[--j]]) { // find item on right to swap\n                if (j == left)\n                    break; // don't go out-of-bounds\n            }\n            if (i >= j)\n                break; // check if pointers cross\n            swap(a, indexes, i, j); // swap two elements into place\n        }\n        swap(a, indexes, i, right); // swap with partition element\n        return i;\n    }"}, {"instruction": "\u4e8c\u5206\u641c\u7d22\n@param mdagDataArray\n@param node\n@return", "input": "Java", "output": "private int binarySearch(SimpleMDAGNode[] mdagDataArray, char node)\n    {\n        if (transitionSetSize < 1)\n        {\n            return -1;\n        }\n        int high = transitionSetBeginIndex + transitionSetSize - 1;\n        int low = transitionSetBeginIndex;\n        while (low <= high)\n        {\n            int mid = ((low + high) >>> 1);\n            int cmp = mdagDataArray[mid].getLetter() - node;\n\n            if (cmp < 0)\n                low = mid + 1;\n            else if (cmp > 0)\n                high = mid - 1;\n            else\n                return mid;\n        }\n        return -1;\n    }"}, {"instruction": "Deletes the path if it is empty. A path can only be empty if it is a directory which does\nnot contain any other directories/files.\n\n@param fileSystem to use\n@param path to be deleted if empty\n@return true if the path could be deleted; otherwise false\n@throws IOException if the delete operation fails", "input": "Java", "output": "public static boolean deletePathIfEmpty(FileSystem fileSystem, Path path) throws IOException {\n\t\tfinal FileStatus[] fileStatuses;\n\n\t\ttry {\n\t\t\tfileStatuses = fileSystem.listStatus(path);\n\t\t}\n\t\tcatch (FileNotFoundException e) {\n\t\t\t// path already deleted\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t// could not access directory, cannot delete\n\t\t\treturn false;\n\t\t}\n\n\t\t// if there are no more files or if we couldn't list the file status try to delete the path\n\t\tif (fileStatuses == null) {\n\t\t\t// another indicator of \"file not found\"\n\t\t\treturn true;\n\t\t}\n\t\telse if (fileStatuses.length == 0) {\n\t\t\t// attempt to delete the path (will fail and be ignored if the path now contains\n\t\t\t// some files (possibly added concurrently))\n\t\t\treturn fileSystem.delete(path, false);\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"}, {"instruction": "Invalidates a Hadoop authentication token file", "input": "Java", "output": "public static void cancelHadoopTokens(HadoopSecurityManager hadoopSecurityManager,\n      String userToProxy, File tokenFile, Logger log) {\n    if (tokenFile == null) {\n      return;\n    }\n    try {\n      hadoopSecurityManager.cancelTokens(tokenFile, userToProxy, log);\n    } catch (HadoopSecurityManagerException e) {\n      log.error(e.getCause() + e.getMessage());\n    } catch (Exception e) {\n      log.error(e.getCause() + e.getMessage());\n    }\n    if (tokenFile.exists()) {\n      tokenFile.delete();\n    }\n  }"}, {"instruction": "List of the files in the given directory (path), as a {@code JavaRDD<String>}\n\n@param sc                Spark context\n@param path              Path to list files in\n@param recursive         Whether to walk the directory tree recursively (i.e., include subdirectories)\n@param allowedExtensions If null: all files will be accepted. If non-null: only files with the specified extension will be allowed.\nExclude the extension separator - i.e., use \"txt\" not \".txt\" here.\n@param config            Hadoop configuration to use. Must not be null.\n@return Paths in the directory\n@throws IOException If error occurs getting directory contents", "input": "Java", "output": "public static JavaRDD<String> listPaths(@NonNull JavaSparkContext sc, String path, boolean recursive,\n                                            Set<String> allowedExtensions, @NonNull Configuration config) throws IOException {\n        List<String> paths = new ArrayList<>();\n        FileSystem hdfs = FileSystem.get(URI.create(path), config);\n        RemoteIterator<LocatedFileStatus> fileIter = hdfs.listFiles(new org.apache.hadoop.fs.Path(path), recursive);\n\n        while (fileIter.hasNext()) {\n            String filePath = fileIter.next().getPath().toString();\n            if(allowedExtensions == null){\n                paths.add(filePath);\n            } else {\n                String ext = FilenameUtils.getExtension(path);\n                if(allowedExtensions.contains(ext)){\n                    paths.add(filePath);\n                }\n            }\n        }\n        return sc.parallelize(paths);\n    }"}, {"instruction": "Wraps a callable chain in a user presentable callable that will inject the default call context\nand trace the call.", "input": "Java", "output": "private <RequestT, ResponseT> UnaryCallable<RequestT, ResponseT> createUserFacingUnaryCallable(\n      String methodName, UnaryCallable<RequestT, ResponseT> inner) {\n\n    UnaryCallable<RequestT, ResponseT> traced =\n        new TracedUnaryCallable<>(\n            inner,\n            clientContext.getTracerFactory(),\n            SpanName.of(TRACING_OUTER_CLIENT_NAME, methodName));\n\n    return traced.withDefaultCallContext(clientContext.getDefaultCallContext());\n  }"}, {"instruction": "Cancels those Operations in the given list that have not yet completed with the given exception.", "input": "Java", "output": "private void cancelIncompleteOperations(Iterable<CompletableOperation> operations, Throwable failException) {\n        assert failException != null : \"no exception to set\";\n        int cancelCount = 0;\n        for (CompletableOperation o : operations) {\n            if (!o.isDone()) {\n                this.state.failOperation(o, failException);\n                cancelCount++;\n            }\n        }\n\n        log.warn(\"{}: Cancelling {} operations with exception: {}.\", this.traceObjectId, cancelCount, failException.toString());\n    }"}, {"instruction": "Get all the bytes of a given chunk.\nUseful for previewing sections of files.\n\n@param chkIdx index of desired chunk\n@return array of initial bytes", "input": "Java", "output": "public byte[] getPreviewChunkBytes(int chkIdx) {\n    if (chkIdx >= nChunks())\n      throw new H2OIllegalArgumentException(\"Asked for chunk index beyond the number of chunks.\");\n    if (chkIdx == 0)\n      return chunkForChunkIdx(chkIdx)._mem;\n    else { //must eat partial lines\n      // FIXME: a hack to consume partial lines since each preview chunk is seen as cidx=0\n      byte[] mem = chunkForChunkIdx(chkIdx)._mem;\n      int i = 0, j = mem.length-1;\n      while (i < mem.length && mem[i] != CHAR_CR && mem[i] != CHAR_LF) i++;\n      while (j > i && mem[j] != CHAR_CR && mem[j] != CHAR_LF) j--;\n      if (j-i > 1) return Arrays.copyOfRange(mem,i,j);\n      else return null;\n    }\n  }"}, {"instruction": "\u901a\u8fc7certId\u83b7\u53d6\u9a8c\u7b7e\u8bc1\u4e66Map\u4e2d\u5bf9\u5e94\u8bc1\u4e66PublicKey\n\n@param certId \u8bc1\u4e66\u7269\u7406\u5e8f\u53f7\n@return \u901a\u8fc7\u8bc1\u4e66\u7f16\u53f7\u83b7\u53d6\u5230\u7684\u516c\u94a5", "input": "Java", "output": "public static PublicKey getValidatePublicKey(String certId) {\n\t\tX509Certificate cf = null;\n\t\tif (certMap.containsKey(certId)) {\n\t\t\t// \u5b58\u5728certId\u5bf9\u5e94\u7684\u8bc1\u4e66\u5bf9\u8c61\n\t\t\tcf = certMap.get(certId);\n\t\t\treturn cf.getPublicKey();\n\t\t} else {\n\t\t\t// \u4e0d\u5b58\u5728\u5219\u91cd\u65b0Load\u8bc1\u4e66\u6587\u4ef6\u76ee\u5f55\n\t\t\tinitValidateCertFromDir();\n\t\t\tif (certMap.containsKey(certId)) {\n\t\t\t\t// \u5b58\u5728certId\u5bf9\u5e94\u7684\u8bc1\u4e66\u5bf9\u8c61\n\t\t\t\tcf = certMap.get(certId);\n\t\t\t\treturn cf.getPublicKey();\n\t\t\t} else {\n\t\t\t\tLogUtil.writeErrorLog(\"\u7f3a\u5c11certId=[\" + certId + \"]\u5bf9\u5e94\u7684\u9a8c\u7b7e\u8bc1\u4e66.\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}"}, {"instruction": "\u901a\u8fc7\u8fde\u63a5\u8fdc\u7a0b\u5730\u5740\u5f97\u5230\u672c\u673a\u5185\u7f51\u5730\u5740\n\n@param remoteAddress \u8fdc\u7a0b\u5730\u5740\n@return \u672c\u673a\u5185\u7f51\u5730\u5740", "input": "Java", "output": "private static InetAddress getLocalHostBySocket(InetSocketAddress remoteAddress) {\n        InetAddress host = null;\n        try {\n            // \u53bb\u8fde\u4e00\u4e0b\u8fdc\u7a0b\u5730\u5740\n            Socket socket = new Socket();\n            try {\n                socket.connect(remoteAddress, 1000);\n                // \u5f97\u5230\u672c\u5730\u5730\u5740\n                host = socket.getLocalAddress();\n            } finally {\n                IOUtils.closeQuietly(socket);\n            }\n        } catch (Exception e) {\n            LOGGER.warn(\"Can not connect to host {}, cause by :{}\",\n                remoteAddress.toString(), e.getMessage());\n        }\n        return host;\n    }"}, {"instruction": "\u5c06\u6574\u4e2a\u6587\u4ef6\u8bfb\u53d6\u4e3a\u5b57\u8282\u6570\u7ec4\n\n@param path\n@return", "input": "Java", "output": "public static byte[] readBytes(String path)\n    {\n        try\n        {\n            if (IOAdapter == null) return readBytesFromFileInputStream(new FileInputStream(path));\n\n            InputStream is = IOAdapter.open(path);\n            if (is instanceof FileInputStream)\n                return readBytesFromFileInputStream((FileInputStream) is);\n            else\n                return readBytesFromOtherInputStream(is);\n        }\n        catch (Exception e)\n        {\n            logger.warning(\"\u8bfb\u53d6\" + path + \"\u65f6\u53d1\u751f\u5f02\u5e38\" + e);\n        }\n\n        return null;\n    }"}, {"instruction": "\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\n\n@param file \u6587\u4ef6\n@return \u6587\u4ef6\u5185\u5bb9\n@throws IOException \u53d1\u9001IO\u5f02\u5e38", "input": "Java", "output": "public static String file2String(File file) throws IOException {\n        if (file == null || !file.exists() || !file.isFile() || !file.canRead()) {\n            return null;\n        }\n        FileReader reader = null;\n        StringWriter writer = null;\n        try {\n            reader = new FileReader(file);\n            writer = new StringWriter();\n            char[] cbuf = new char[1024];\n            int len = 0;\n            while ((len = reader.read(cbuf)) != -1) {\n                writer.write(cbuf, 0, len);\n            }\n            return writer.toString();\n        } finally {\n            IOUtils.closeQuietly(reader);\n            IOUtils.closeQuietly(writer);\n        }\n    }"}, {"instruction": "Handle SSO HEAD profile redirect request (not allowed).\n\n@param response the response\n@param request  the request", "input": "Java", "output": "@RequestMapping(path = SamlIdPConstants.ENDPOINT_SAML2_SSO_PROFILE_REDIRECT, method = {RequestMethod.HEAD})\n    public void handleSaml2ProfileSsoRedirectHeadRequest(final HttpServletResponse response,\n                                                         final HttpServletRequest request) {\n        LOGGER.info(\"Endpoint [{}] called with HTTP HEAD returning 400 Bad Request\", SamlIdPConstants.ENDPOINT_SAML2_SSO_PROFILE_REDIRECT);\n        response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n    }"}, {"instruction": "Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise", "input": "Java", "output": "public boolean isSet(_Fields field) {\n    if (field == null) {\n      throw new IllegalArgumentException();\n    }\n\n    switch (field) {\n    case SESSION_HANDLE:\n      return isSetSessionHandle();\n    case CATALOG_NAME:\n      return isSetCatalogName();\n    case SCHEMA_NAME:\n      return isSetSchemaName();\n    case TABLE_NAME:\n      return isSetTableName();\n    case TABLE_TYPES:\n      return isSetTableTypes();\n    }\n    throw new IllegalStateException();\n  }"}, {"instruction": "TODO: return VecDomainV4", "input": "Java", "output": "@SuppressWarnings(\"unused\") // called through reflection by RequestServer\n  public FramesV3 columnDomain(int version, FramesV3 s) {\n    Frame frame = getFromDKV(\"key\", s.frame_id.key());\n    Vec vec = frame.vec(s.column);\n    if (vec == null)\n      throw new H2OColumnNotFoundArgumentException(\"column\", s.frame_id.toString(), s.column);\n    s.domain = new String[1][];\n    s.domain[0] = vec.domain();\n    return s;\n  }"}, {"instruction": "Returns the host via {@link InetSocketAddress#getHostString} if it is possible,\ni.e. in jdk >= 7.\nOtherwise, return it via {@link InetSocketAddress#getHostName} which may incur a DNS lookup.", "input": "Java", "output": "public static String getHost(InetSocketAddress addr) {\n    try {\n      Method getHostStringMethod = InetSocketAddress.class.getMethod(\"getHostString\");\n      return (String) getHostStringMethod.invoke(addr);\n    } catch (NoSuchMethodException e) {\n      // noop\n    } catch (IllegalAccessException e) {\n      // noop\n    } catch (InvocationTargetException e) {\n      // noop\n    }\n    return addr.getHostName();\n  }"}, {"instruction": "\u5339\u914d\u6587\u672c\n\n@param text      \u6587\u672c\n@param processor \u5904\u7406\u5668", "input": "Java", "output": "public void parseText(String text, AhoCorasickDoubleArrayTrie.IHit<V> processor)\n    {\n        int length = text.length();\n        int begin = 0;\n        BaseNode<V> state = this;\n\n        for (int i = begin; i < length; ++i)\n        {\n            state = state.transition(text.charAt(i));\n            if (state != null)\n            {\n                V value = state.getValue();\n                if (value != null)\n                {\n                    processor.hit(begin, i + 1, value);\n                }\n            }\n            else\n            {\n                i = begin;\n                ++begin;\n                state = this;\n            }\n        }\n    }"}, {"instruction": "Increases the current backoff and returns whether the operation was successful.\n\n@return <code>true</code>, iff the operation was successful. Otherwise, <code>false</code>.", "input": "Java", "output": "protected boolean increaseBackoff() {\n\t\t// Backoff is disabled\n\t\tif (currentBackoff < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// This is the first time backing off\n\t\tif (currentBackoff == 0) {\n\t\t\tcurrentBackoff = initialBackoff;\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Continue backing off\n\t\telse if (currentBackoff < maxBackoff) {\n\t\t\tcurrentBackoff = Math.min(currentBackoff * 2, maxBackoff);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Reached maximum backoff\n\t\treturn false;\n\t}"}, {"instruction": "Add converters useful for most Spring Boot applications.\n@param registry the registry of converters to add to (must also be castable to\nConversionService, e.g. being a {@link ConfigurableConversionService})\n@throws ClassCastException if the given ConverterRegistry could not be cast to a\nConversionService", "input": "Java", "output": "public static void addApplicationConverters(ConverterRegistry registry) {\n\t\taddDelimitedStringConverters(registry);\n\t\tregistry.addConverter(new StringToDurationConverter());\n\t\tregistry.addConverter(new DurationToStringConverter());\n\t\tregistry.addConverter(new NumberToDurationConverter());\n\t\tregistry.addConverter(new DurationToNumberConverter());\n\t\tregistry.addConverter(new StringToDataSizeConverter());\n\t\tregistry.addConverter(new NumberToDataSizeConverter());\n\t\tregistry.addConverterFactory(new StringToEnumIgnoringCaseConverterFactory());\n\t}"}, {"instruction": "Register SQL.\n\n@param sql SQL\n@param parametersCount parameters count\n@return statement ID", "input": "Java", "output": "public synchronized int register(final String sql, final int parametersCount) {\n        Integer result = statementIdAssigner.get(sql);\n        if (null != result) {\n            return result;\n        }\n        result = sequence.incrementAndGet();\n        statementIdAssigner.putIfAbsent(sql, result);\n        binaryStatements.putIfAbsent(result, new MySQLBinaryStatement(sql, parametersCount));\n        return result;\n    }"}, {"instruction": "Calculate percentage of instances online\n\n@param collectorItemId Collector Item Id of deploy\n@return percentage of instances online", "input": "Java", "output": "private Double fetchInstancesOnlineRatio(ObjectId collectorItemId) {\n    int totalInstances = 0, totalInstancesOnline = 0;\n    Double instancesOnlineScore = null;\n\n    List<EnvironmentStatus> statuses = environmentStatusRepository\n      .findByCollectorItemId(collectorItemId);\n\n    if (null == statuses || statuses.isEmpty()) {\n      return null;\n    }\n\n    for (EnvironmentStatus environmentStatus : statuses) {\n      totalInstances++;\n      if (environmentStatus.isOnline()) {\n        totalInstancesOnline++;\n      }\n    }\n    instancesOnlineScore = ((totalInstancesOnline * 100) / (double) totalInstances);\n    LOGGER.info(\"totalInstances \" + totalInstances + \" totalInstancesOnline \" + totalInstancesOnline + \" instancesOnlineScore \" + instancesOnlineScore);\n\n    return instancesOnlineScore;\n  }"}, {"instruction": "Returns null if fails to decrypt properly.", "input": "Java", "output": "public static String unprotect(String data) {\n        if(data==null)      return null;\n        try {\n            Cipher cipher = Secret.getCipher(ALGORITHM);\n            cipher.init(Cipher.DECRYPT_MODE, DES_KEY);\n            String plainText = new String(cipher.doFinal(Base64.getDecoder().decode(data.getBytes(StandardCharsets.UTF_8))), StandardCharsets.UTF_8);\n            if(plainText.endsWith(MAGIC))\n                return plainText.substring(0,plainText.length()-3);\n            return null;\n        } catch (GeneralSecurityException | IllegalArgumentException e) {\n            return null;\n        }\n    }"}, {"instruction": "Create a {@link LinkedHashMap} from an array of values.\n\n@param values The values\n@return The created map", "input": "Java", "output": "@UsedByGeneratedCode\n    public static Map mapOf(Object... values) {\n        int len = values.length;\n        if (len % 2 != 0) {\n            throw new IllegalArgumentException(\"Number of arguments should be an even number representing the keys and values\");\n        }\n\n        Map answer = new LinkedHashMap(len / 2);\n        int i = 0;\n        while (i < values.length - 1) {\n            answer.put(values[i++], values[i++]);\n        }\n        return answer;\n    }"}, {"instruction": "Reads until {@code in} is exhausted or the deadline has been reached. This is careful to not\nextend the deadline if one exists already.", "input": "Java", "output": "public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) throws IOException {\n    long now = System.nanoTime();\n    long originalDuration = source.timeout().hasDeadline()\n        ? source.timeout().deadlineNanoTime() - now\n        : Long.MAX_VALUE;\n    source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));\n    try {\n      Buffer skipBuffer = new Buffer();\n      while (source.read(skipBuffer, 8192) != -1) {\n        skipBuffer.clear();\n      }\n      return true; // Success! The source has been exhausted.\n    } catch (InterruptedIOException e) {\n      return false; // We ran out of time before exhausting the source.\n    } finally {\n      if (originalDuration == Long.MAX_VALUE) {\n        source.timeout().clearDeadline();\n      } else {\n        source.timeout().deadlineNanoTime(now + originalDuration);\n      }\n    }\n  }"}, {"instruction": "*************************************************************************", "input": "Java", "output": "private static DataSet<Centroid> getCentroidDataSet(ParameterTool params, ExecutionEnvironment env) {\n\t\tDataSet<Centroid> centroids;\n\t\tif (params.has(\"centroids\")) {\n\t\t\tcentroids = env.readCsvFile(params.get(\"centroids\"))\n\t\t\t\t.fieldDelimiter(\" \")\n\t\t\t\t.pojoType(Centroid.class, \"id\", \"x\", \"y\");\n\t\t} else {\n\t\t\tSystem.out.println(\"Executing K-Means example with default centroid data set.\");\n\t\t\tSystem.out.println(\"Use --centroids to specify file input.\");\n\t\t\tcentroids = KMeansData.getDefaultCentroidDataSet(env);\n\t\t}\n\t\treturn centroids;\n\t}"}, {"instruction": "This method reconnects given node to another node", "input": "Java", "output": "public synchronized void remapNode(@NonNull Node node) {\n        version++;\n\n        if (buildMode == MeshBuildMode.MESH) {\n            node.getUpstreamNode().removeFromDownstreams(node);\n\n            boolean m = false;\n            for (val n : sortedNodes) {\n                // we dont want to remap node to itself\n                if (!Objects.equals(n, node) && n.status().equals(NodeStatus.ONLINE)) {\n                    n.addDownstreamNode(node);\n                    m = true;\n                    break;\n                }\n            }\n\n            // if we were unable to find good enough node - we'll map this node to the rootNode\n            if (!m) {\n                rootNode.addDownstreamNode(node);\n            }\n\n            // i hope we won't deadlock here? :)\n            synchronized (this) {\n                Collections.sort(sortedNodes);\n            }\n        } else if (buildMode == MeshBuildMode.PLAIN) {\n            // nothing to do here\n        }\n    }"}, {"instruction": "Get Metadata.\n\n@param request  the request\n@param response the response\n@throws Exception the exception", "input": "Java", "output": "@GetMapping(path = WSFederationConstants.ENDPOINT_FEDERATION_METADATA)\n    public void doGet(final HttpServletRequest request, final HttpServletResponse response) throws Exception {\n        try {\n            response.setContentType(MediaType.TEXT_HTML_VALUE);\n            val out = response.getWriter();\n            val metadata = WSFederationMetadataWriter.produceMetadataDocument(casProperties);\n            out.write(DOM2Writer.nodeToString(metadata));\n        } catch (final Exception ex) {\n            LOGGER.error(\"Failed to get metadata document\", ex);\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        }\n    }"}, {"instruction": "A small colored rectangle with rounded corners.", "input": "JavaScript", "output": "function Badge({ className, children, color = \"primary\" }: Props): React.Node {\n  const classes = cn(\n    {\n      badge: true,\n      [`badge-${color}`]: color,\n    },\n    className\n  );\n  return <span className={classes}>{children}</span>;\n}"}, {"instruction": "Returns unique values from an array.\n\nNote: ugly code is ugly, but efficient: http://jsperf.com/array-unique2/8\n\n@param  Array  array\n@return Array", "input": "JavaScript", "output": "function unique(array) {\n    \"use strict\";\n    var o = {},\n        r = [];\n    for (var i = 0, len = array.length; i !== len; i++) {\n        var d = array[i];\n        if (typeof o[d] === \"undefined\") {\n            o[d] = 1;\n            r[r.length] = d;\n        }\n    }\n    return r;\n}"}, {"instruction": "Annoying method to copy nodes to an array, thanks to IE", "input": "JavaScript", "output": "function(nodes) {\n      nodes = nodes || [];\n\n      var results = [];\n      for (var i = 0; i < nodes.length; ++i) {\n        results.push(nodes.item(i));\n      }\n      return results;\n    }"}, {"instruction": "find the leftmost node of a polygon ring", "input": "JavaScript", "output": "function getLeftmost(start) {\n        var p = start, leftmost = start;\n        do {\n            if (p.x < leftmost.x)\n                leftmost = p;\n            p = p.next;\n        } while (p !== start);\n        return leftmost;\n    }"}, {"instruction": "Return a page by its path\n@param {String} filePath\n@return {Object|undefined}", "input": "JavaScript", "output": "function getPageByPath(filePath) {\n        var page = output.getPage(filePath);\n        if (!page) return undefined;\n\n        return JSONUtils.encodePage(page, summary);\n    }"}, {"instruction": "Delete a given Queue", "input": "JavaScript", "output": "async function deleteQueue(\n  project = 'my-project-id', // Your GCP Project id\n  queue = 'my-appengine-queue', // Name of the Queue to delete\n  location = 'us-central1' // The GCP region in which to delete the queue\n) {\n  // Imports the Google Cloud Tasks library.\n  const cloudTasks = require('@google-cloud/tasks');\n\n  // Instantiates a client.\n  const client = new cloudTasks.CloudTasksClient();\n\n  // Get the fully qualified path to the queue\n  const name = client.queuePath(project, location, queue);\n\n  // Send delete queue request.\n  await client.deleteQueue({name});\n  console.log(`Deleted queue '${queue}'.`);\n}"}, {"instruction": "Update the site\n\n@param {string} siteId\n@param {Object} manifest", "input": "JavaScript", "output": "async function _updateSite(siteId, tree, manifest, content) {\n  const endpoint = url.resolve(apiURL, `/sites/${siteId}`);\n  const body = { tree, content, manifest };\n  const response = await got.post(endpoint, { body, json: true, headers: _bearer() });\n  return response.body.site;\n}"}, {"instruction": "Converts the current instance to a Javascript date\n@return {Date}", "input": "JavaScript", "output": "function toJSDate() {\n      if (this.zone == ICAL.Timezone.localTimezone) {\n        if (this.isDate) {\n          return new Date(this.year, this.month - 1, this.day);\n        } else {\n          return new Date(this.year, this.month - 1, this.day,\n                          this.hour, this.minute, this.second, 0);\n        }\n      } else {\n        return new Date(this.toUnixTime() * 1000);\n      }\n    }"}, {"instruction": "The name has been updated if the user presses enter.", "input": "JavaScript", "output": "function registerInputEnterKeyHandler(inputEl, fileId) {\n        inheritedInternalApi.getDisposeSupport().attach(inputEl, \"keyup\", function(event) {\n\n            var code = event.keyCode || event.which;\n\n            if (code === 13) {\n                handleNameUpdate(inputEl, fileId);\n            }\n        });\n    }"}, {"instruction": "turns off the scroll shadow on view containers so they don't interfere with dragging\n@private\n@param {Boolean} disable - true to disable, false to enable", "input": "JavaScript", "output": "function _suppressScrollShadowsOnAllViews(disable) {\n        _.forEach(_views, function (view) {\n            if (disable) {\n                ViewUtils.removeScrollerShadow(view.$openFilesContainer[0], null);\n            } else if (view.$openFilesContainer[0].scrollHeight > view.$openFilesContainer[0].clientHeight) {\n                ViewUtils.addScrollerShadow(view.$openFilesContainer[0], null, true);\n            }\n        });\n    }"}, {"instruction": "Properties of a FieldOptions.\n@memberof google.protobuf\n@interface IFieldOptions\n@property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype\n@property {boolean|null} [packed] FieldOptions packed\n@property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype\n@property {boolean|null} [lazy] FieldOptions lazy\n@property {boolean|null} [deprecated] FieldOptions deprecated\n@property {boolean|null} [weak] FieldOptions weak\n@property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption\n \nConstructs a new FieldOptions.\n@memberof google.protobuf\n@classdesc Represents a FieldOptions.\n@implements IFieldOptions\n@constructor\n@param {google.protobuf.IFieldOptions=} [properties] Properties to set", "input": "JavaScript", "output": "function FieldOptions(properties) {\n                this.uninterpretedOption = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }"}, {"instruction": "Function: getStylename\n\nReturns the stylename in a style of the form [(stylename|key=value);] or\nan empty string if the given style does not contain a stylename.\n\nParameters:\n\nstyle - String of the form [(stylename|key=value);].", "input": "JavaScript", "output": "function(style)\n\t{\n\t\tif (style != null)\n\t\t{\n\t\t\tvar pairs = style.split(';');\n\t\t\tvar stylename = pairs[0];\n\t\t\t\n\t\t\tif (stylename.indexOf('=') < 0)\n\t\t\t{\n\t\t\t\treturn stylename;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\treturn '';\n\t}"}, {"instruction": "async strategy ensures processing order by chaining the callbacks", "input": "JavaScript", "output": "function asyncStrategy(node, oAggregation, mAggregations) {\n\t\t\tvar childNode,\n\t\t\t\tpChain = Promise.resolve(),\n\t\t\t\taChildPromises = [];\n\n\t\t\tfor (childNode = node.firstChild; childNode; childNode = childNode.nextSibling) {\n\t\t\t\tpChain = pChain.then(fnCallback.bind(null, node, oAggregation, mAggregations, childNode));\n\t\t\t\taChildPromises.push(pChain);\n\t\t\t}\n\t\t\treturn Promise.all(aChildPromises);\n\t\t}"}, {"instruction": "adds a class on NewComponent events", "input": "JavaScript", "output": "function() {\n        var comp,\n            c = this.__c,\n            str = \"\";\n        for (comp in c) {\n            str += \" \" + comp;\n        }\n        str = str.substr(1);\n        this._element.className = str;\n    }"}, {"instruction": "Sets version in 'package.json' in http://semver.org friendly mode\n\n@param {String} type   Could be 'major', 'minor' or 'patch'\n@param {String} suffix Suffic string, example: 'alpha', 'pre-alpha', 'beta'", "input": "JavaScript", "output": "function setVersion(type, suffix) {\n        var file = 'package.json',\n            VERSION_REGEX = /([\\'|\\\"]version[\\'|\\\"][ ]*:[ ]*[\\'|\\\"])([\\d|.]*)(-\\w+)*([\\'|\\\"])/,\n            contents = grunt.file.read(file),\n            version;\n        contents = contents.replace(VERSION_REGEX, function(match, left, center) {\n            version = center;\n            if (type) {\n                version = require('semver').inc(version, type);\n            }\n            //semver.inc strips our suffix if it existed\n            if (suffix) {\n                version += '-' + suffix;\n            }\n            return left + version + '\"';\n        });\n        grunt.log.ok('Version set to ' + version.cyan);\n        grunt.file.write(file, contents);\n        return version;\n    }"}, {"instruction": "Given a string and an index, look backwards to find the string of whitespace following the next previous line break.", "input": "JavaScript", "output": "function getIndentation(str, index) {\n  let indentStart = index;\n  let indentEnd = index;\n  while (indentStart) {\n    const c = str.charCodeAt(indentStart - 1);\n    // line break\n    if (c === 10 || c === 13 || c === 0x2028 || c === 0x2029) {\n      break;\n    }\n    indentStart--;\n    // not white space\n    if (c !== 9 && c !== 11 && c !== 12 && c !== 32 && c !== 160) {\n      indentEnd = indentStart;\n    }\n  }\n  return str.substring(indentStart, indentEnd);\n}"}, {"instruction": "/* BIFF2_??? where ??? is the name from [XLS]", "input": "JavaScript", "output": "function parse_BIFF2STR(blob, length, opts) {\n\tvar cell = parse_XLSCell(blob, 6);\n\t++blob.l;\n\tvar str = parse_XLUnicodeString2(blob, length-7, opts);\n\tcell.t = 'str';\n\tcell.val = str;\n\treturn cell;\n}"}, {"instruction": "The keys in this object are timezones that we know may be ambiguous after\na preliminary scan through the olson_tz object.\n\nThe array of timezones to compare must be in the order that daylight savings\nstarts for the regions.", "input": "JavaScript", "output": "function () {\r\n              var ambiguity_list = AMBIGUITIES[timezone_name],\r\n                  length = ambiguity_list.length,\r\n                  i = 0,\r\n                  tz = ambiguity_list[0];\r\n\r\n              for (; i < length; i += 1) {\r\n                  tz = ambiguity_list[i];\r\n\r\n                  if (jstz.date_is_dst(jstz.dst_start_for(tz))) {\r\n                      timezone_name = tz;\r\n                      return;\r\n                  }\r\n              }\r\n          }"}, {"instruction": "/*!\nThe following functions are taken from jQuery UI 1.8.17 but modified\n\nCopyright 2011, AUTHORS.txt (http://jqueryui.com/about)\nDual licensed under the MIT or GPL Version 2 licenses.\nhttp://jquery.org/license\n\nhttp://docs.jquery.com/UI", "input": "JavaScript", "output": "function visible( element ) {\n\t\t// check if one of the parents (until it's position parent) is invisible\n\t\t// prevent that elements in static area are always checked as invisible\n\n\t\t// list all items until the offsetParent item (with jQuery >1.6 you can use parentsUntil)\n\t\tvar oOffsetParent = jQuery(element).offsetParent();\n\t\tvar bOffsetParentFound = false;\n\t\tvar $refs = jQuery(element).parents().filter(function() {\n\t\t\tif (this === oOffsetParent) {\n\t\t\t\tbOffsetParentFound = true;\n\t\t\t}\n\t\t\treturn bOffsetParentFound;\n\t\t});\n\n\t\t// check for at least one item to be visible\n\t\treturn !jQuery(element).add($refs).filter(function() {\n\t\t\treturn jQuery.css( this, \"visibility\" ) === \"hidden\" || jQuery.expr.filters.hidden( this );\n\t\t}).length;\n\t}"}, {"instruction": "Initialize the point\n@param {Object} series The series object containing this point\n@param {Object} options The data in either number, array or object format", "input": "JavaScript", "output": "function (series, options) {\r\n\t\tvar point = this,\r\n\t\t\tcounters = series.chart.counters,\r\n\t\t\tdefaultColors;\r\n\t\tpoint.series = series;\r\n\t\tpoint.applyOptions(options);\r\n\t\tpoint.pointAttr = {};\r\n\r\n\t\tif (series.options.colorByPoint) {\r\n\t\t\tdefaultColors = series.chart.options.colors;\r\n\t\t\tif (!point.options) {\r\n\t\t\t\tpoint.options = {};\r\n\t\t\t}\r\n\t\t\tpoint.color = point.options.color = point.color || defaultColors[counters.color++];\r\n\r\n\t\t\t// loop back to zero\r\n\t\t\tcounters.wrapColor(defaultColors.length);\r\n\t\t}\r\n\r\n\t\tseries.chart.pointCount++;\r\n\t\treturn point;\r\n\t}"}, {"instruction": "object draw<br>\nnot to be called by the end user<br>\ncalled by the game manager on each game loop\n@name draw\n@memberOf me.Entity\n@function\n@protected\n@param {me.CanvasRenderer|me.WebGLRenderer} renderer a renderer object\n@param {me.Rect} region to draw", "input": "JavaScript", "output": "function (renderer, rect) {\n            var renderable = this.renderable;\n            if (renderable instanceof me.Renderable) {\n                // predraw (apply transforms)\n                renderable.preDraw(renderer);\n\n                // draw the object\n                renderable.draw(renderer, rect);\n\n                // postdraw (clean-up);\n                renderable.postDraw(renderer);\n            }\n        }"}, {"instruction": "Checks if a value is a valid locator.\n@param {!(By|Function|ByHash)} locator The value to check.\n@return {!(By|Function)} The valid locator.\n@throws {TypeError} If the given value does not define a valid locator\nstrategy.", "input": "JavaScript", "output": "function check(locator) {\n  if (locator instanceof By || typeof locator === 'function') {\n    return locator;\n  }\n\n  if (locator\n      && typeof locator === 'object'\n      && typeof locator.using === 'string'\n      && typeof locator.value === 'string') {\n    return new By(locator.using, locator.value);\n  }\n\n  for (let key in locator) {\n    if (locator.hasOwnProperty(key) && By.hasOwnProperty(key)) {\n      return By[key](locator[key]);\n    }\n  }\n  throw new TypeError('Invalid locator');\n}"}, {"instruction": "Prints CasperJS help.", "input": "JavaScript", "output": "function printHelp() {\n        /* global slimer */\n        var engine = phantom.casperEngine === 'slimerjs' ? slimer : phantom;\n        var version = [engine.version.major, engine.version.minor, engine.version.patch].join('.');\n        return __terminate([\n            'CasperJS version ' + phantom.casperVersion.toString() +\n            ' at ' + phantom.casperPath + ', using ' + phantom.casperEngine + ' version ' + version,\n            fs.read(fs.pathJoin(phantom.casperPath, 'bin', 'usage.txt'))\n        ].join('\\n'));\n    }"}, {"instruction": "Returns a list of elements that have had polymer-elements created but\nare not yet ready to register. The list is an array of element definitions.", "input": "JavaScript", "output": "function() {\n      var e$ = [];\n      for (var i=0, l=elements.length, e; (i<l) && \n          (e=elements[i]); i++) {\n        if (e.__queue && !e.__queue.flushable) {\n          e$.push(e);\n        }\n      }\n      return e$;\n    }"}, {"instruction": "mouse event management (mousewheel)\nXXX: mousewheel is deprecated\n@ignore", "input": "JavaScript", "output": "function onMouseWheel(e) {\n       /* jshint expr:true */\n       if (e.target === me.video.renderer.getScreenCanvas()) {\n         // create a (fake) normalized event object\n         e.type = \"wheel\"; // dispatch mouse event to registered object\n\n         return dispatchEvent(normalizeEvent(e));\n       }\n\n       return true;\n     }"}, {"instruction": "Changes the user's password.", "input": "JavaScript", "output": "function onChangePassword() {\n  var password = $('#changed-password').val();\n  activeUser().updatePassword(password).then(function() {\n    refreshUserData();\n    alertSuccess('Password changed!');\n  }, onAuthError);\n}"}, {"instruction": "Function: getName\n\nReturns the name for the given value.", "input": "JavaScript", "output": "function(value)\n\t{\n\t\tfor (var key in mxStyleRegistry.values)\n\t\t{\n\t\t\tif (mxStyleRegistry.values[key] == value)\n\t\t\t{\n\t\t\t\treturn key;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}"}, {"instruction": "/* eslint-enable \nLoader used to create Skeleton objects", "input": "JavaScript", "output": "function Skeleton({ width, height, dark, ...other }) {\n  return (\n    <StyledSkeleton dark={dark} customWidth={width} customHeight={height} {...other}>\n      &nbsp;\n    </StyledSkeleton>\n  );\n}"}, {"instruction": "Creates an error object to be thrown when an exception was caught, but the `Error` is falsy or undefined.\n\n@public\n@param {string} message - Error message to be displayed.\n@returns {Error} instance detailing the error condition", "input": "JavaScript", "output": "function createInvalidExceptionError(message, value) {\n  var err = new Error(message);\n  err.code = 'ERR_MOCHA_INVALID_EXCEPTION';\n  err.valueType = typeof value;\n  err.value = value;\n  return err;\n}"}, {"instruction": "Exports JDL a application to a JDL file in the current directory.\n@param application, the JDL application to export.\n@return the exported application in its final form.", "input": "JavaScript", "output": "function exportApplication(application) {\n  checkForErrors(application);\n  const formattedApplication = setUpApplicationStructure(application);\n  writeConfigFile(formattedApplication);\n  return formattedApplication;\n}"}, {"instruction": "Mimic Array.forEach() API, but with an async callback function. Execute each callback on each array item serially. Useful when using WebDriverIO API.  Added due because of problem with chrome driver when too many requests are made simultaneously. https://bugs.chromium.org/p/chromedriver/issues/detail?id=2152#c9  @param {object[]} array Input array items to iterate over @param {function} callback Async function to excute on each array item @param {object} option Additional options. 'extractValue' will extract the .value object from a WebdriverIO", "input": "JavaScript", "output": "async function forEachAsync(array, callback, option = {}) {\n  const {\n    extractValue = true,\n    unify: unifyResults = true,\n    expandArrayResults = true,\n  } = option;\n  const inputArray = Array.isArray(array) ? array : [array];\n  const values = [];\n  for (let index = 0; index < inputArray.length; index++) {\n    let res;\n    try {\n      res = await callback(inputArray[index], index, inputArray);\n      if (Array.isArray(res) && expandArrayResults) {\n        res.forEach(val => values.push(val));\n      } else if (res) {\n        values.push(res);\n      }\n    } catch (err) {\n      throw err;\n    }\n  }\n  if (unifyResults) {\n    return unify(values, { extractValue: true });\n  }\n  return values;\n}"}, {"instruction": "url:        null, type:       'GET',", "input": "JavaScript", "output": "function( mockHandler, requestSettings ) {\n\t\t\tif ( mockHandler.logging === false ||\n\t\t\t\t ( typeof mockHandler.logging === 'undefined' && $.mockjaxSettings.logging === false ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( window.console && console.log ) {\n\t\t\t\tvar message = 'MOCK ' + requestSettings.type.toUpperCase() + ': ' + requestSettings.url;\n\t\t\t\tvar request = $.extend({}, requestSettings);\n\n\t\t\t\tif (typeof console.log === 'function') {\n\t\t\t\t\tconsole.log(message, request);\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconsole.log( message + ' ' + JSON.stringify(request) );\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.log(message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"}, {"instruction": "Checks whether this user is the current user and has been authenticated.\n@deprecated \u5982\u679c\u8981\u5224\u65ad\u5f53\u524d\u7528\u6237\u7684\u767b\u5f55\u72b6\u6001\u662f\u5426\u6709\u6548\uff0c\u8bf7\u4f7f\u7528 currentUser.isAuthenticated().then()\uff0c\n\u5982\u679c\u8981\u5224\u65ad\u8be5\u7528\u6237\u662f\u5426\u662f\u5f53\u524d\u767b\u5f55\u7528\u6237\uff0c\u8bf7\u4f7f\u7528 user.id === currentUser.id\n@return (Boolean) whether this user is the current user and is logged in.", "input": "JavaScript", "output": "function() {\n        console.warn(\n          'DEPRECATED: \u5982\u679c\u8981\u5224\u65ad\u5f53\u524d\u7528\u6237\u7684\u767b\u5f55\u72b6\u6001\u662f\u5426\u6709\u6548\uff0c\u8bf7\u4f7f\u7528 currentUser.isAuthenticated().then()\uff0c\u5982\u679c\u8981\u5224\u65ad\u8be5\u7528\u6237\u662f\u5426\u662f\u5f53\u524d\u767b\u5f55\u7528\u6237\uff0c\u8bf7\u4f7f\u7528 user.id === currentUser.id\u3002'\n        );\n        return (\n          !!this._sessionToken &&\n          (!AV._config.disableCurrentUser &&\n            AV.User.current() &&\n            AV.User.current().id === this.id)\n        );\n      }"}, {"instruction": "<include src=\"assert.js\"> \nAlias for document.getElementById. Found elements must be HTMLElements.\n@param {string} id The ID of the element to find.\n@return {HTMLElement} The found element or null if not found.", "input": "JavaScript", "output": "function $(id) {\n  var el = document.getElementById(id);\n  return el ? assertInstanceof(el, HTMLElement) : null;\n}"}, {"instruction": "File loading ------------------------------------------------", "input": "JavaScript", "output": "function(plugins) {\n    _.each(\n      plugins,\n      _.bind(function(plugin) {\n        if (!this.plugins[plugin]) {\n          this.plugins[plugin] = this.requirePlugin(plugin);\n        }\n      }, this)\n    );\n  }"}, {"instruction": "Begins polling to determine when the specified stylesheet has finished loading\nin Gecko. Polling stops when all pending stylesheets have loaded or after 10\nseconds (to prevent stalls).\n\nThanks to Zach Leatherman for calling my attention to the @import-based\ncross-domain technique used here, and to Oleg Slobodskoi for an earlier\nsame-domain implementation. See Zach's blog for more details:\nhttp://www.zachleat.com/web/2010/07/29/load-css-dynamically/\n\n@method pollGecko\n@param {HTMLElement} node Style node to poll.\n@private", "input": "JavaScript", "output": "function pollGecko(node) {\n    var hasRules;\n\n    try {\n      // We don't really need to store this value or ever refer to it again, but\n      // if we don't store it, Closure Compiler assumes the code is useless and\n      // removes it.\n      hasRules = !!node.sheet.cssRules;\n    } catch (ex) {\n      // An exception means the stylesheet is still loading.\n      pollCount += 1;\n\n      if (pollCount < 200) {\n        setTimeout(function () { pollGecko(node); }, 50);\n      } else {\n        // We've been polling for 10 seconds and nothing's happened. Stop\n        // polling and finish the pending requests to avoid blocking further\n        // requests.\n        hasRules && finish('css');\n      }\n\n      return;\n    }\n\n    // If we get here, the stylesheet has loaded.\n    finish('css');\n  }"}, {"instruction": "Tells if an object is a primitive type or a \"real\" object\nArrays are considered primitive", "input": "JavaScript", "output": "function isPrimitiveType (obj) {\n  return ( typeof obj === 'boolean' ||\n       typeof obj === 'number' ||\n       typeof obj === 'string' ||\n       obj === null ||\n       util.isDate(obj) ||\n       util.isArray(obj));\n}"}, {"instruction": "DomRenderer#attach( data ) -> this\n- data (HTMLElement|Object): DOM node or event data (`data.body`)\n\nEvent callback to attach a node to the viewport", "input": "JavaScript", "output": "function( data ){\n\n            // interpred data as either dom node or event data\n            var el = (data.nodeType && data) || (data.body && data.body.view)\n                ;\n\n            if ( el ){\n                // attach to viewport\n                this.el.appendChild( el );\n            }\n\n            return this;\n        }"}, {"instruction": "Exports a [SurfacePolyline]{@link SurfacePolyline} in WKT format of type LineString.\n@param {SurfacePolyline} renderable The SurfacePolyline object.\n@throws {ArgumentError} If the specified argument is null or undefined.\n@returns {String} WKT format.", "input": "JavaScript", "output": "function (renderable) {\n                if (!(renderable instanceof WorldWind.SurfacePolyline)) {\n                    throw new ArgumentError(\n                        Logger.logMessage(Logger.LEVEL_SEVERE, \"WktExporter\", \"exportSurfacePolyline\",\n                            \"invalidTypeOfRenderable\"));\n                }\n\n                var sb = WktType.SupportedGeometries.LINE_STRING + '(';\n                for (var i = 0; i < renderable.boundaries.length; i++) {\n                    sb = sb + renderable.boundaries[i].longitude + ' ' +\n                        renderable.boundaries[i].latitude;\n                    sb = sb + ', ';\n                }\n                sb = sb.substring(0, sb.length - 2);\n                sb = sb + ')';\n                return sb;\n            }"}, {"instruction": "$NON-NLS-0$", "input": "JavaScript", "output": "function(){\n\t\t\tvar compareParams = PageUtil.matchResourceParameters();\n\t\t\tvar compareTreeExplorer = new mCompareTreeExplorer.CompareTreeExplorer(serviceRegistry, \"compare-tree-results\", commandRegistry, fileClient); //$NON-NLS-0$\n\t\t\tcompareTreeExplorer.startup(compareParams);\n\t\t\tmGlobalCommands.setPageTarget({\n\t\t\t\ttask: messages.compareTreeTitle\n\t\t\t});\n\t\t}"}, {"instruction": "Show value inside the debug console", "input": "JavaScript", "output": "function WidgetSliderGUI() {\n        this.addOutput(\"\", \"number\");\n        this.properties = {\n            value: 0.5,\n            min: 0,\n            max: 1,\n            text: \"V\"\n        };\n        var that = this;\n        this.size = [140, 40];\n        this.slider = this.addWidget(\n            \"slider\",\n            \"V\",\n            this.properties.value,\n            function(v) {\n                that.properties.value = v;\n            },\n            this.properties\n        );\n        this.widgets_up = true;\n    }"}, {"instruction": "Parse CSS", "input": "JavaScript", "output": "function parseCSS(content) {\r\n    var _return = {},\r\n      parts = content.split(\"\\n\"),\r\n      keys = [\r\n        \"name\",\r\n        \"description\",\r\n        \"type\"\r\n      ];\r\n\r\n    for (var pi in parts) {\r\n      var p = parts[pi];\r\n\r\n      for (var ki in keys) {\r\n        var key = keys[ki];\r\n\r\n        if (p.indexOf(\"@\"+key) > -1) {\r\n          var pset = p.split(\"@\"+key),\r\n          part = pset[ pset.length - 1 ].trim();\r\n\r\n          _return[key] = part;\r\n        }\r\n      }\r\n    }\r\n    return _return;\r\n  }"}, {"instruction": "Wrapper for defined play method.\nPlay component by adding tick behavior and calling user's play method.\n\n@param playMethod {function}", "input": "JavaScript", "output": "function wrapPlay (playMethod) {\n  return function play () {\n    var sceneEl = this.el.sceneEl;\n    var shouldPlay = this.el.isPlaying && !this.isPlaying;\n    if (!this.initialized || !shouldPlay) { return; }\n    playMethod.call(this);\n    this.isPlaying = true;\n    this.eventsAttach();\n    // Add tick behavior.\n    if (!hasBehavior(this)) { return; }\n    sceneEl.addBehavior(this);\n  };\n}"}, {"instruction": "Set the resource path to be considered for the OData request URI of this\nquery request object. This method provides an alternative way to assign a\npath comprising a parameterization. If a path is provided, it overwrites\nany parameterization object that might have been specified separately.\n\n@param {string} sResourcePath\nResource path pointing to the entity set of the query result.\nMust include a valid parameterization if query contains\nparameters.\n@public\n@function\n@name sap.ui.model.analytics.odata4analytics.QueryResultRequest#setResourcePath", "input": "JavaScript", "output": "function(sResourcePath) {\n\t\t\tthis._sResourcePath = sResourcePath;\n\t\t\tif (this._sResourcePath.indexOf(\"/\") != 0) {\n\t\t\t\tthrow \"Missing leading / (slash) for resource path\";\n\t\t\t}\n\t\t\tif (this._oQueryResult.getParameterization()) {\n\t\t\t\tvar iLastPathSep = sResourcePath.lastIndexOf(\"/\");\n\t\t\t\tif (iLastPathSep == -1) {\n\t\t\t\t\tthrow \"Missing navigation from parameter entity set to query result in resource path\";\n\t\t\t\t}\n\t\t\t\tvar sNavPropName = sResourcePath.substring(iLastPathSep + 1);\n\t\t\t\tif (sNavPropName != this._oQueryResult.getParameterization().getNavigationPropertyToQueryResult()) {\n\t\t\t\t\tthrow \"Invalid navigation property from parameter entity set to query result in resource path\";\n\t\t\t\t}\n\t\t\t}\n\t\t}"}, {"instruction": "/* return a promise and a function. When the function is called,\nthe promise will be resolved.", "input": "JavaScript", "output": "function awaitFunctionCall() {\n                let func;\n                const promise = new Promise((resolve, reject) => {\n                    func = function(...args) {\n                        resolve(args);\n                        return new Promise((resolve, reject) => {\n                            // give us some time to process the result before\n                            // continuing\n                            global.setTimeout(resolve, 1);\n                        });\n                    };\n                });\n                return {func, promise};\n            }"}, {"instruction": "Drag Handlers", "input": "JavaScript", "output": "function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var label = { position: this.getLabelPosition(x, y, data.positionArgs) };\n        this.model.label(data.labelIdx, label);\n    }"}, {"instruction": "Initialize the grid navigation holder to null.\n@param {Object} modelItem The model item object that represent a row.", "input": "JavaScript", "output": "function(modelItem) {\n\t\t\tif(!modelItem){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar modelId = this._model.getId(modelItem);\n\t\t\tif(this._dict[modelId]){\n\t\t\t\tthis._dict[modelId].gridChildren = null;\n\t\t\t}\n\t\t}"}, {"instruction": "/* eslint-disable", "input": "JavaScript", "output": "function requestUrl(url, callback) {\n  var req = new XMLHttpRequest();\n  req.addEventListener(\"load\", function () {\n    callback(req.responseText);\n  });\n  req.open(\"GET\", url);\n  req.send();\n}"}, {"instruction": "/* template", "input": "JavaScript", "output": "function() {\n      var _vm = this;\n      var _h = _vm.$createElement;\n      var _c = _vm._self._c || _h;\n      return _c(\n        _vm.tag,\n        {\n          tag: \"component\",\n          class: [!_vm.fluid ? \"container\" : \"container-fluid\"]\n        },\n        [_vm._t(\"default\")],\n        2\n      )\n    }"}, {"instruction": "Build CSS", "input": "JavaScript", "output": "function() {\n    return gulp\n      .src(item.dest + item.name + '.css')\n      .pipe(rename(item.name + '.min.css'))\n      .pipe(cleanCSS())\n      .pipe(gulp.dest(item.dest));\n  }"}, {"instruction": "/* [MS-XLSB] 2.5.166", "input": "JavaScript", "output": "function parse_XLNullableWideString(data) {\n\tvar cchCharacters = data.read_shift(4);\n\treturn cchCharacters === 0 || cchCharacters === 0xFFFFFFFF ? \"\" : data.read_shift(cchCharacters, 'dbcs');\n}"}, {"instruction": "Called by native code when returning error result from an action.", "input": "JavaScript", "output": "function (callbackId, args) {\n        // TODO: Deprecate callbackSuccess and callbackError in favour of callbackFromNative.\n        // Derive success from status.\n        cordova.callbackFromNative(callbackId, false, args.status, [args.message], args.keepCallback);\n    }"}, {"instruction": "/* global dom", "input": "JavaScript", "output": "function noParentScrolled(element, offset) {\n\telement = dom.getComposedParent(element);\n\twhile (element && element.nodeName.toLowerCase() !== 'html') {\n\t\tif (element.scrollTop) {\n\t\t\toffset += element.scrollTop;\n\t\t\tif (offset >= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telement = dom.getComposedParent(element);\n\t}\n\treturn true;\n}"}, {"instruction": "Binds a framebuffer\n\nThis function pretty much soley exists because I spent hours\ntrying to figure out why something I wrote wasn't working only\nto realize I forget to set the viewport dimensions.\nMy hope is this function will fix that.\n\nIt is effectively the same as\n\ngl.bindFramebuffer(gl.FRAMEBUFFER, someFramebufferInfo.framebuffer);\ngl.viewport(0, 0, someFramebufferInfo.width, someFramebufferInfo.height);\n\n@param {WebGLRenderingContext} gl the WebGLRenderingContext\n@param {module:twgl.FramebufferInfo} [framebufferInfo] a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.\nIf not passed will bind the canvas.\n@param {number} [target] The target. If not passed `gl.FRAMEBUFFER` will be used.\n@memberOf module:twgl/framebuffers", "input": "JavaScript", "output": "function bindFramebufferInfo(gl, framebufferInfo, target) {\n  target = target || gl.FRAMEBUFFER;\n  if (framebufferInfo) {\n    gl.bindFramebuffer(target, framebufferInfo.framebuffer);\n    gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);\n  } else {\n    gl.bindFramebuffer(target, null);\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n  }\n}"}, {"instruction": "ANIMATION:", "input": "JavaScript", "output": "function(props, duration, easing, complete) {\n                    return this.each(function() { animate(this, props, duration, easing, complete); });\n                }"}, {"instruction": "remember the state of the bound property and copy it to both accus", "input": "JavaScript", "output": "function() {\n\n\t\tvar binding = this.binding;\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * 3;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\tthis.cumulativeWeight = 0;\n\n\t}"}, {"instruction": "primary ('.' id)+ '='?\n| primary", "input": "JavaScript", "output": "function() {\n    var node = this.primary();\n    if (node) {\n      while (this.accept('.')) {\n        var id = new nodes.Ident(this.expect('ident').val.string);\n        node = new nodes.Member(node, id);\n      }\n      this.skipSpaces();\n      if (this.accept('=')) {\n        node.val = this.list();\n        // @block support\n        if (node.val.isEmpty) this.assignAtblock(node.val);\n      }\n    }\n    return node;\n  }"}, {"instruction": "Sets the value for multiple styles on a node.  If a value is specified as\n'' (empty string), the corresponding style property will be unset.\n\n@param {DOMElement} node\n@param {object} styles", "input": "JavaScript", "output": "function setValueForStyles(node, styles, getStack) {\n  const style = node.style;\n  for (let styleName in styles) {\n    if (!styles.hasOwnProperty(styleName)) {\n      continue;\n    }\n    const isCustomProperty = styleName.indexOf('--') === 0;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!isCustomProperty) {\n        warnValidStyle(styleName, styles[styleName], getStack);\n      }\n    }\n    const styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n    if (styleName === 'float') {\n      styleName = 'cssFloat';\n    }\n    if (isCustomProperty) {\n      const name = isCustomProperty ? styleName : hyphenateStyleName(styleName);\n      style.setProperty(name, styleValue);\n    } else {\n      style[styleName] = styleValue;\n    }\n  }\n}"}, {"instruction": "has length 2", "input": "JavaScript", "output": "function(module, shim) {\n\t\t\tif ( Array.isArray(shim) ) {\n\t\t\t\tshim = { deps : shim };\n\t\t\t}\n\t\t\tmShims[module + '.js'] = shim;\n\t\t}"}, {"instruction": "Convert CH y/x to WGS lat", "input": "JavaScript", "output": "function CHtoWGSlat(y, x) {\n\n  // Converts militar to civil and  to unit = 1000km\n  // Axiliary values (% Bern)\n  const y_aux = (y - 600000) / 1000000;\n  const x_aux = (x - 200000) / 1000000;\n\n  // Process lat\n  let lat = 16.9023892 +\n      3.238272 * x_aux -\n      0.270978 * Math.pow(y_aux, 2) -\n      0.002528 * Math.pow(x_aux, 2) -\n      0.0447 * Math.pow(y_aux, 2) * x_aux -\n      0.0140 * Math.pow(x_aux, 3);\n\n  // Unit 10000\" to 1 \" and converts seconds to degrees (dec)\n  lat = lat * 100 / 36;\n\n  return lat;\n\n}"}, {"instruction": "Load the resource at the given path.\n@name orion.explorer.FileExplorer#loadResourceList\n@function\n@param {String|Object} path The path of the resource to load, or an object with a ChildrenLocation or ContentLocation field giving the path.\n@param {Boolean} [force] If true, force reload even if the path is unchanged. Useful\nwhen the client knows the resource underlying the current path has changed.\n@param {Function} postLoad a function to call after loading the resource. <b>Deprecated</b>: use the returned promise instead.\n@returns {orion.Promise}", "input": "JavaScript", "output": "function(path, force, postLoad) {\n\t\t\tif (path && typeof path === \"object\") {\n\t\t\t\tpath = path.ChildrenLocation || path.ContentLocation;\n\t\t\t}\n\t\t\tpath = mFileUtils.makeRelative(path);\n\t\t\tvar self = this;\n\t\t\tif (force || path !== this.treeRoot.Path || path !== this._lastPath) {\n\t\t\t\tthis._lastPath = path;\n\t\t\t\treturn this.load(this.fileClient.read(path, true), i18nUtil.formatMessage(messages[\"Loading ${0}\"], path), postLoad).then(function() {\n\t\t\t\t\tself.treeRoot.Path = path;\n\t\t\t\t\treturn self.treeRoot;\n\t\t\t\t}, function(err) {\n\t\t\t\t\tself.treeRoot.Path = null;\n\t\t\t\t\treturn new Deferred().reject(err);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn new Deferred().resolve(self.treeRoot);\n\t\t}"}, {"instruction": "Compile and link the given template and store values for element, scope, and controller.\n@param {string} template\n@returns {angular.JQLite} The root compiled element.", "input": "JavaScript", "output": "function createDatepickerInstance(template) {\n    var outputElement = $compile(template)(pageScope);\n    pageScope.$apply();\n\n    ngElement = outputElement[0].tagName == 'MD-DATEPICKER' ?\n        outputElement : outputElement.find('md-datepicker');\n    element = ngElement[0];\n    scope = ngElement.isolateScope();\n    controller = ngElement.controller('mdDatepicker');\n\n    return outputElement;\n  }"}, {"instruction": "Build the legacy pyramid URLs (one tile per level)\n@function\n@param {object} options - infoJson\n@throws {Error}", "input": "JavaScript", "output": "function constructLevels(options) {\n        var levels = [];\n        for(var i = 0; i < options.sizes.length; i++) {\n            levels.push({\n                url: options['@id'] + '/full/' + options.sizes[i].width + ',/0/default.' + options.tileFormat,\n                width: options.sizes[i].width,\n                height: options.sizes[i].height\n            });\n        }\n        return levels.sort(function(a, b) {\n            return a.width - b.width;\n        });\n    }"}, {"instruction": "Opens the panel. If a config value is passed, creates a new panelRef\nusing $mdPanel.open(config); Otherwise, called open on the panelRef,\nassuming one has already been created.\n@param {!Object=} opt_config", "input": "JavaScript", "output": "function openPanel(preset, opt_config) {\n    // TODO(ErinCoughlan): Investigate why panelRef.open() doesn't return\n    // panelRef.\n    var openPromise;\n\n    if (panelRef) {\n      openPromise = panelRef.open();\n    } else {\n      openPromise = $mdPanel.open(preset, opt_config);\n    }\n\n    openPromise.then(function(createdPanelRef) {\n      panelRef = createdPanelRef;\n      return panelRef;\n    });\n\n    flushPanel();\n  }"}, {"instruction": "Clones a given metadata instance\n@param source the instance to clone\n@returns {*} cloned metadata", "input": "JavaScript", "output": "function cloneMetadata(source) {\n\t\t\tvar backupMetadata = initMetadata(source.__ui5version);\n\t\t\tfor (var index in source.__byIndex__) {\n\t\t\t\tbackupMetadata.__byIndex__[index] = source.__byIndex__[index];\n\t\t\t}\n\t\t\tfor (var key in source.__byKey__) {\n\t\t\t\tbackupMetadata.__byKey__[key] = source.__byKey__[key];\n\t\t\t}\n\t\t\treturn backupMetadata;\n\t\t}"}, {"instruction": "Retrieve the computed style from a specified element.\n\n@param el\n@param styleProperty\n@return The computed style value.\n@type String", "input": "JavaScript", "output": "function(el, styleProperty){\n            if(el.currentStyle){\n                return el.currentStyle[styleProperty];\n            }else if(window.getComputedStyle){\n                var cssProperty = styleProperty.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n                var computedStyle = window.getComputedStyle(el, \"\");\n                return computedStyle.getPropertyValue(cssProperty);\n            }else{\n                return \"\";\n            }\n        }"}, {"instruction": "Fires the XHR request -- may be invoked immediately or on a gradually expanding retry window for reconnects", "input": "JavaScript", "output": "function () {\r\n                req.date = new Date();\r\n                if (self._conn.options.customHeaders){\r\n                    var headers = self._conn.options.customHeaders;\r\n                    for (var header in headers) {\r\n                        if (headers.hasOwnProperty(header)) {\r\n                            req.xhr.setRequestHeader(header, headers[header]);\r\n                        }\r\n                    }\r\n                }\r\n                req.xhr.send(req.data);\r\n            }"}, {"instruction": "Gets an actual movement value corrected by offset.\n\n@return {Number}", "input": "JavaScript", "output": "function get() {\n      var offset = this.offset;\n      var translate = this.translate;\n\n      if (Components.Direction.is('rtl')) {\n        return translate + offset;\n      }\n\n      return translate - offset;\n    }"}, {"instruction": "Override the broken getFunctionName() method from JsUnit\nThis file must be loaded _after_ the jsunitCore.js", "input": "JavaScript", "output": "function getFunctionName(aFunction) {\n    var regexpResult = aFunction.toString().match(/function (\\w*)/);\n    if (regexpResult && regexpResult[1]) {\n        return regexpResult[1];\n    }\n    return 'anonymous';\n}"}, {"instruction": "Called when the result stream reads a new chunk.\n\n@param {Chunk} chunk", "input": "JavaScript", "output": "function onResultStreamData(chunk)\n  {\n    // unsubscribe from the result stream's 'data' and 'close' events\n    resultStream.removeListener('data', onResultStreamData);\n    resultStream.removeListener('close', onResultStreamClose);\n\n    // get all the rows in the chunk that overlap with the requested window,\n    // and use the resulting array as the new row buffer\n    var chunkStart = chunk.getStartIndex();\n    var chunkEnd = chunk.getEndIndex();\n    rowBuffer = chunk.getRows().slice(\n        Math.max(chunkStart, start) - chunkStart,\n        Math.min(chunkEnd, end) + 1 - chunkStart);\n\n    // reset the row index\n    rowIndex = 0;\n\n    // process the row buffer\n    processRowBuffer();\n  }"}, {"instruction": "\"Natural\" union type.\n\nThis representation doesn't require a wrapping object and is therefore\nsimpler and generally closer to what users expect. However it cannot be used\nto represent all Avro unions since some lead to ambiguities (e.g. if two\nnumber types are in the union).\n\nCurrently, this union supports at most one type in each of the categories\nbelow:\n\n+ `null`\n+ `boolean`\n+ `int`, `long`, `float`, `double`\n+ `string`, `enum`\n+ `bytes`, `fixed`\n+ `array`\n+ `map`, `record`", "input": "JavaScript", "output": "function UnwrappedUnionType(schema, opts) {\n  UnionType.call(this, schema, opts);\n\n  this._dynamicBranches = null;\n  this._bucketIndices = {};\n  this.types.forEach(function (type, index) {\n    if (Type.isType(type, 'abstract', 'logical')) {\n      if (!this._dynamicBranches) {\n        this._dynamicBranches = [];\n      }\n      this._dynamicBranches.push({index: index, type: type});\n    } else {\n      var bucket = getTypeBucket(type);\n      if (this._bucketIndices[bucket] !== undefined) {\n        throw new Error(f('ambiguous unwrapped union: %j', this));\n      }\n      this._bucketIndices[bucket] = index;\n    }\n  }, this);\n\n  Object.freeze(this);\n}"}, {"instruction": "We are using a 2x2 rotation matrix.", "input": "JavaScript", "output": "function applyRotationMatrix(touch, axis) {\n  const rotationMatrix = axisProperties.rotationMatrix[axis];\n\n  return {\n    pageX: rotationMatrix.x[0] * touch.pageX + rotationMatrix.x[1] * touch.pageY,\n    pageY: rotationMatrix.y[0] * touch.pageX + rotationMatrix.y[1] * touch.pageY,\n  };\n}"}, {"instruction": "hook for the deprecated property viewId on the route, will not prefix the id with the component\n\n@name sap.ui.core.routing.TargetCache#_getViewWithGlobalId\n@returns {*}\n@private\n \n@param {string} sName logs an error if it is empty or undefined\n@param {string} sType whether it's a 'View' or 'Component'\n@private", "input": "JavaScript", "output": "function (sName, sType) {\n\n\t\t\t\tif (!sName) {\n\t\t\t\t\tvar sMessage = \"A name for the \" + sType.toLowerCase() + \" has to be defined\";\n\t\t\t\t\tLog.error(sMessage, this);\n\t\t\t\t\tthrow Error(sMessage);\n\t\t\t\t}\n\n\t\t\t}"}, {"instruction": "Builds a function call graph for the current contracts.\nExample Contract call graph:\n\n{\n\"KingOfTheEtherThrone\": {\n\"contracts\": {...},                                        // Contract node as defined in abstractAstView.js\n\"functions\": {\n\"KingOfTheEtherThrone.claimThrone(string memory)\": {    // function in KingOfEtherThrone\n\"node\": {...},                                        // function node as defined in abstractAstView.js\n\"calls\": {                                            // list of full qualified function names which are called form this function\n}\n}\n}\n},\n\"foo\": {\n\"contract\": {...},           // Contract node as definded in abstractAstView.js\n\"functions\": {}             // map from full qualified function name to func node\n}\n}\n\n@contracts {list contracts} Expects as input the contract structure defined in abstractAstView.js\n@return {map (string -> Contract Call Graph)} returns map from contract name to contract call graph", "input": "JavaScript", "output": "function buildGlobalFuncCallGraph (contracts) {\n  var callGraph = {}\n  contracts.forEach((contract) => {\n    var filterNodes = (node) => { return common.isLocalCallGraphRelevantNode(node) || common.isExternalDirectCall(node) }\n    var getNodeIdent = (node) => { return common.getFullQualifiedFunctionCallIdent(contract.node, node) }\n    var getFunDefIdent = (funcDef) => { return common.getFullQuallyfiedFuncDefinitionIdent(contract.node, funcDef.node, funcDef.parameters) }\n\n    callGraph[common.getContractName(contract.node)] = { contract: contract, functions: buildLocalFuncCallGraphInternal(contract.functions, filterNodes, getNodeIdent, getFunDefIdent) }\n  })\n\n  return callGraph\n}"}, {"instruction": "Limit the resultset to `n` records\n@class Model\n@method limit\n@param {integer} limit - The limit as a number.\n@param {integer} offset - Optional offset.\n\n@see Model.exec\n\n@return {Model}", "input": "JavaScript", "output": "function(limit, offset) {\n    const self = this.chain()._unresolve() // if the collection is already resolved, return a unresolved and empty copy!\n\n    offset = offset || self.getInternal('offset') || 0\n\n    if (typeof limit === 'string') limit = parseInt(limit)\n    if (typeof offset === 'string') offset = parseInt(offset)\n\n    if (!isNaN(limit)) {\n      self.setInternal('limit', limit)\n      self.setInternal('no_relation_cache', true)\n    }\n    if (!isNaN(offset)) {\n      self.setInternal('offset', offset)\n      self.setInternal('no_relation_cache', true)\n    }\n\n    if (!limit) {\n      self.clearInternal('offset', offset)\n      self.clearInternal('limit', limit)\n    }\n\n    return self\n  }"}, {"instruction": "Case-insensitive scan of current elements only (do not descend).", "input": "JavaScript", "output": "function scanLevel(element) {\n        if (element) {\n          for (var i = 0, len = element.length; i < len; i++) {\n            if (element[i].nodeName.toLowerCase() === nodeName) {\n              return element[i];\n            }\n          }\n        }\n        return null;\n      }"}, {"instruction": "Join lists with \"i\" and \"i+1\"", "input": "JavaScript", "output": "function addToList(i, L, R) {\n    R[L[i + 1]] = R[i];\n    L[R[i]] = L[i + 1];\n    R[i] = i + 1;\n    L[i + 1] = i;\n}"}, {"instruction": "gets an iframes document in a cross browser compatible manner", "input": "JavaScript", "output": "function getiframeDocument($iframe) {\n            var iframeDoc = $iframe[0].contentWindow || $iframe[0].contentDocument;\n            if (iframeDoc.document) {\n                iframeDoc = iframeDoc.document;\n            }\n            return iframeDoc;\n        }"}, {"instruction": "Convert object to meta by value.", "input": "JavaScript", "output": "function (obj) {\n  return Object.getOwnPropertyNames(obj).map(function (name) {\n    return {\n      name: name,\n      value: obj[name]\n    }\n  })\n}"}, {"instruction": "Left/right translate effect", "input": "JavaScript", "output": "function scrollInterpolator3 (index, carouselProps) {\n    const range = [2, 1, 0, -1];\n    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);\n    const outputRange = range;\n\n    return { inputRange, outputRange };\n}"}, {"instruction": "SAP MODIFICATION Because touchcancel is used together with touchend, jQuery.fn.bind is used to replace jQuery.fn.one due to the fact that jQuery.fn.one doesn't work for multiple events.", "input": "JavaScript", "output": "function stopHandler( event ) {\n\t\t\t\t\t$this.unbind( touchMoveEvent, moveHandler )\n\t\t\t\t\t\t.unbind( touchStopEvent, stopHandler );\n\n\t\t\t\t\tif ( start && stop ) {\n\t\t\t\t\t\t$.event.special.swipe.handleSwipe( start, stop );\n\t\t\t\t\t}\n\t\t\t\t\tstart = stop = undefined;\n\t\t\t\t}"}, {"instruction": "Update mark when resizing", "input": "JavaScript", "output": "function updateMarkWhenResizing() {\n    const helper = getHelper();\n\n    ml.getAll().forEach(marker => {\n      helper.updateMarkerWithExtraInfo(marker);\n    });\n\n    editor.eventManager.emit('markerUpdated', ml.getAll());\n  }"}, {"instruction": "Copyright (c) 2006-2017, JGraph Ltd\nCopyright (c) 2006-2017, Gaudenz Alder\n \nClass: mxPrintPreview\n\nImplements printing of a diagram across multiple pages. The following opens\na print preview for an existing graph:\n\n(code)\nvar preview = new mxPrintPreview(graph);\npreview.open();\n(end)\n\nUse <mxUtils.getScaleForPageCount> as follows in order to print the graph\nacross a given number of pages:\n\n(code)\nvar pageCount = mxUtils.prompt('Enter page count', '1');\n\nif (pageCount != null)\n{\nvar scale = mxUtils.getScaleForPageCount(pageCount, graph);\nvar preview = new mxPrintPreview(graph, scale);\npreview.open();\n}\n(end)\n\nAdditional pages:\n\nTo add additional pages before and after the output, <getCoverPages> and\n<getAppendices> can be used, respectively.\n\n(code)\nvar preview = new mxPrintPreview(graph, 1);\n\npreview.getCoverPages = function(w, h)\n{\nreturn [this.renderPage(w, h, 0, 0, mxUtils.bind(this, function(div)\n{\ndiv.innerHTML = '<div style=\"position:relative;margin:4px;\">Cover Page</p>'\n}))];\n};\n\npreview.getAppendices = function(w, h)\n{\nreturn [this.renderPage(w, h, 0, 0, mxUtils.bind(this, function(div)\n{\ndiv.innerHTML = '<div style=\"position:relative;margin:4px;\">Appendix</p>'\n}))];\n};\n\npreview.open();\n(end)\n\nCSS:\n\nThe CSS from the original page is not carried over to the print preview.\nTo add CSS to the page, use the css argument in the <open> function or\noverride <writeHead> to add the respective link tags as follows:\n\n(code)\nvar writeHead = preview.writeHead;\npreview.writeHead = function(doc, css)\n{\nwriteHead.apply(this, arguments);\ndoc.writeln('<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">');\n};\n(end)\n\nPadding:\n\nTo add a padding to the page in the preview (but not the print output), use\nthe following code:\n\n(code)\npreview.writeHead = function(doc)\n{\nwriteHead.apply(this, arguments);\n\ndoc.writeln('<style type=\"text/css\">');\ndoc.writeln('@media screen {');\ndoc.writeln('  body > div { padding-top:30px;padding-left:40px;box-sizing:content-box; }');\ndoc.writeln('}');\ndoc.writeln('</style>');\n};\n(end)\n\nHeaders:\n\nApart from setting the title argument in the mxPrintPreview constructor you\ncan override <renderPage> as follows to add a header to any page:\n\n(code)\nvar oldRenderPage = mxPrintPreview.prototype.renderPage;\nmxPrintPreview.prototype.renderPage = function(w, h, x, y, content, pageNumber)\n{\nvar div = oldRenderPage.apply(this, arguments);\n\nvar header = document.createElement('div');\nheader.style.position = 'absolute';\nheader.style.top = '0px';\nheader.style.width = '100%';\nheader.style.textAlign = 'right';\nmxUtils.write(header, 'Your header here');\ndiv.firstChild.appendChild(header);\n\nreturn div;\n};\n(end)\n\nThe pageNumber argument contains the number of the current page, starting at\n1. To display a header on the first page only, check pageNumber and add a\nvertical offset in the constructor call for the height of the header.\n\nPage Format:\n\nFor landscape printing, use <mxConstants.PAGE_FORMAT_A4_LANDSCAPE> as\nthe pageFormat in <mxUtils.getScaleForPageCount> and <mxPrintPreview>.\nKeep in mind that one can not set the defaults for the print dialog\nof the operating system from JavaScript so the user must manually choose\na page format that matches this setting.\n\nYou can try passing the following CSS directive to <open> to set the\npage format in the print dialog to landscape. However, this CSS\ndirective seems to be ignored in most major browsers, including IE.\n\n(code)\n@page {\nsize: landscape;\n}\n(end)\n\nNote that the print preview behaves differently in IE when used from the\nfilesystem or via HTTP so printing should always be tested via HTTP.\n\nIf you are using a DOCTYPE in the source page you can override <getDoctype>\nand provide the same DOCTYPE for the print preview if required. Here is\nan example for IE8 standards mode.\n\n(code)\nvar preview = new mxPrintPreview(graph);\npreview.getDoctype = function()\n{\nreturn '<!--[if IE]><meta http-equiv=\"X-UA-Compatible\" content=\"IE=5,IE=8\" ><![endif]-->';\n};\npreview.open();\n(end)\n\nConstructor: mxPrintPreview\n\nConstructs a new print preview for the given parameters.\n\nParameters:\n\ngraph - <mxGraph> to be previewed.\nscale - Optional scale of the output. Default is 1 / <mxGraph.pageScale>.\nborder - Border in pixels along each side of every page. Note that the\nactual print function in the browser will add another border for\nprinting.\npageFormat - <mxRectangle> that specifies the page format (in pixels).\nThis should match the page format of the printer. Default uses the\n<mxGraph.pageFormat> of the given graph.\nx0 - Optional left offset of the output. Default is 0.\ny0 - Optional top offset of the output. Default is 0.\nborderColor - Optional color of the page border. Default is no border.\nNote that a border is sometimes useful to highlight the printed page\nborder in the print preview of the browser.\ntitle - Optional string that is used for the window title. Default\nis 'Printer-friendly version'.\npageSelector - Optional boolean that specifies if the page selector\nshould appear in the window with the print preview. Default is true.", "input": "JavaScript", "output": "function mxPrintPreview(graph, scale, pageFormat, border, x0, y0, borderColor, title, pageSelector)\n{\n\tthis.graph = graph;\n\tthis.scale = (scale != null) ? scale : 1 / graph.pageScale;\n\tthis.border = (border != null) ? border : 0;\n\tthis.pageFormat = mxRectangle.fromRectangle((pageFormat != null) ? pageFormat : graph.pageFormat);\n\tthis.title = (title != null) ? title : 'Printer-friendly version';\n\tthis.x0 = (x0 != null) ? x0 : 0;\n\tthis.y0 = (y0 != null) ? y0 : 0;\n\tthis.borderColor = borderColor;\n\tthis.pageSelector = (pageSelector != null) ? pageSelector : true;\n}"}, {"instruction": "traverse icons in a row of icon atlas extend each icon with left-top coordinates", "input": "JavaScript", "output": "function buildRowMapping(mapping, columns, yOffset) {\n  for (let i = 0; i < columns.length; i++) {\n    const {icon, xOffset} = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = Object.assign({}, icon, {\n      x: xOffset,\n      y: yOffset\n    });\n  }\n}"}, {"instruction": "It will remove resize/scroll events and won't recalculate popper position\nwhen they are triggered. It also won't trigger onUpdate callback anymore,\nunless you call `update` method manually.\n@method\n@memberof Popper", "input": "JavaScript", "output": "function disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    if (window.cancelAnimationFrame) {\n      cancelAnimationFrame(this.scheduleUpdate);\n    }\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}"}, {"instruction": "/* jshint ignore:start \nInitialize the BulkExports version of Preview\n\n@constructor Twilio.Preview.BulkExports\n\n@property {Twilio.Preview.BulkExports.ExportList} exports - exports resource\n@property {Twilio.Preview.BulkExports.ExportConfigurationList} exportConfiguration -\nexportConfiguration resource\n\n@param {Twilio.Preview} domain - The twilio domain\n /* jshint ignore:end", "input": "JavaScript", "output": "function BulkExports(domain) {\n  Version.prototype.constructor.call(this, domain, 'BulkExports');\n\n  // Resources\n  this._exports = undefined;\n  this._exportConfiguration = undefined;\n}"}, {"instruction": "Helper method for unwrapping jQuery/DOM/string elements\n@param callback", "input": "JavaScript", "output": "function(a) {\n            if ( !a ) {\n                return null;\n            } else if ( a instanceof jQuery ) {\n                return a[0];\n            } else if ( a instanceof Object ) {\n                return a;\n            }\n            return $('#'+a)[0];\n        }"}, {"instruction": "Mimic Array.filter() API, but with an async callback function. Execute each callback on each array item serially. Useful when using WebDriverIO API. Added due because of problem with chrome driver when too many requests are made simultaneously. https://bugs.chromium.org/p/chromedriver/issues/detail?id=2152#c9 @param {object[]} array Input array items to iterate over @param {function} callback Async function to excute on each array item @param {object} option Additional options. 'extractValue' will extract the .value object from a WebdriverIO", "input": "JavaScript", "output": "async function filterAsync(array, callback, option = {}) {\n  const {\n    extractValue = true,\n  } = option;\n  const inputArray = Array.isArray(array) ? array : [array];\n  const values = [];\n  for (let index = 0; index < inputArray.length; index++) {\n    try {\n      const res = unify(await callback(inputArray[index], index, inputArray), { extractValue });\n      const value = Array.isArray(res) ? res[0] : res;\n\n      if (value) {\n        values.push(inputArray[index]);\n      }\n    } catch (err) {\n      throw err;\n    }\n  }\n  return values;\n}"}, {"instruction": "Likewise, we want to know if a profile is specified early, in particular to save the window state data.", "input": "JavaScript", "output": "function profileFromArgs(args) {\n\tif (!args) return null;\n\tconst profileIndex = args.indexOf('--profile');\n\tif (profileIndex <= 0 || profileIndex >= args.length - 1) return null;\n\tconst profileValue = args[profileIndex + 1];\n\treturn profileValue ? profileValue : null;\n}"}, {"instruction": "Unescapes a double quoted string.\n\n@param string value A double quoted string.\n\n@return string The unescaped string.", "input": "JavaScript", "output": "function(value)\n\t{\n\t\tvar callback = function(m) {\n\t\t\treturn new YamlUnescaper().unescapeCharacter(m);\n\t\t};\n\n\t\t// evaluate the string\n\t\treturn value.replace(new RegExp(YamlUnescaper.REGEX_ESCAPED_CHARACTER, 'g'), callback);\n\t}"}, {"instruction": "@private\n\nInjects LiveReload script into HTML\n\n@param {Object} ctx\n@param {number} port - server port number", "input": "JavaScript", "output": "function _injectLiveReload(ctx, port) {\n  const { hostname } = ctx.request;\n  const wsPort = _websocketPort(ctx, port);\n  const script = `<script src=\"/dashboard/javascripts/livereload.js?snipver=1&port=${wsPort}&host=${hostname}\"></script>`;\n\n  ctx.body = ctx.body.replace(/(<\\/body>(?![\\s\\S]*<\\/body>[\\s\\S]*$))/i, `${script}\\n$1`);\n}"}, {"instruction": "Parse nodes in FBXTree.Objects.Material", "input": "JavaScript", "output": "function ( textureMap ) {\n\n\t\t\tvar materialMap = new Map();\n\n\t\t\tif ( 'Material' in fbxTree.Objects ) {\n\n\t\t\t\tvar materialNodes = fbxTree.Objects.Material;\n\n\t\t\t\tfor ( var nodeID in materialNodes ) {\n\n\t\t\t\t\tvar material = this.parseMaterial( materialNodes[ nodeID ], textureMap );\n\n\t\t\t\t\tif ( material !== null ) materialMap.set( parseInt( nodeID ), material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materialMap;\n\n\t\t}"}, {"instruction": "Wrapper to allow the use of object methods as static methods of Immutable.", "input": "JavaScript", "output": "function toStatic(fn) {\n    function staticWrapper() {\n      var args = [].slice.call(arguments);\n      var self = args.shift();\n      return fn.apply(self, args);\n    }\n\n    return staticWrapper;\n  }"}, {"instruction": "Style strike.\n@param {object} sq - squire editor instance", "input": "JavaScript", "output": "function styleStrike(sq) {\n  if (sq.hasFormat('S')) {\n    sq.changeFormat(null, {tag: 'S'});\n  } else if (!sq.hasFormat('a') && !sq.hasFormat('PRE')) {\n    if (sq.hasFormat('code')) {\n      sq.changeFormat(null, {tag: 'code'});\n    }\n    sq.strikethrough();\n  }\n}"}, {"instruction": "\u5c06\u4e24\u4e2a\u70b9\u5747\u5206\u6210count\u4e2a\u70b9", "input": "JavaScript", "output": "function _splitPoints(points, former, count) {\n  var result = [].concat(points);\n  var index = void 0;\n  var t = 1 / (count + 1);\n  var formerEnd = _getSegmentPoints(former)[0];\n  for (var i = 1; i <= count; i++) {\n    t *= i;\n    index = Math.floor(points.length * t);\n    if (index === 0) {\n      result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);\n    } else {\n      result.splice(index, 0, [formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);\n    }\n  }\n  return result;\n}"}, {"instruction": "The default function used to format a Date to String, passed to the `format`\nprop.\n@param {Date} d\n@return {String}", "input": "JavaScript", "output": "function defaultFormat(d) {\n  if ((0, _DateUtils.isDate)(d)) {\n    var year = d.getFullYear();\n    var month = '' + (d.getMonth() + 1);\n    var day = '' + d.getDate();\n    return year + '-' + month + '-' + day;\n  }\n  return '';\n}"}, {"instruction": "\u64ad\u653e\u504f\u79fb\u91cf the offset of current playing audio \n@language=en\n@private Initialize.", "input": "JavaScript", "output": "function(){\n        this._context = context;\n        this._gainNode = context.createGain ? context.createGain() : context.createGainNode();\n        this._gainNode.connect(context.destination);\n\n        this._onAudioEvent = this._onAudioEvent.bind(this);\n        this._onDecodeComplete = this._onDecodeComplete.bind(this);\n        this._onDecodeError = this._onDecodeError.bind(this);\n    }"}, {"instruction": "Checks whether a node has the '_super' property.\n@param {Node[]} nodes An array of nodes.\n@returns {Boolean}", "input": "JavaScript", "output": "function checkForSuper(nodes) {\n  if (nodes.length === 0) return false;\n\n  return nodes.some((n) => {\n    if (utils.isCallExpression(n.expression)) {\n      const fnCallee = n.expression.callee;\n      return utils.isMemberExpression(fnCallee) &&\n        utils.isThisExpression(fnCallee.object) &&\n        utils.isIdentifier(fnCallee.property) &&\n        fnCallee.property.name === '_super';\n    } else if (utils.isReturnStatement(n)) {\n      if (!n.argument || !utils.isCallExpression(n.argument)) return false;\n\n      const fnCallee = n.argument.callee;\n      return fnCallee.property.name === '_super';\n    }\n\n    return false;\n  });\n}"}, {"instruction": "/*\nGeoJSON MultiLineString Class\nnew MultiLineString();\nnew MultiLineString([ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ]);\nnew MultiLineString({\ntype: \"MultiLineString\",\ncoordinates: [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ]\n});", "input": "JavaScript", "output": "function MultiLineString(input){\n    if(input && input.type === \"MultiLineString\" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiLineString\";\n    }\n\n    this.type = \"MultiLineString\";\n  }"}, {"instruction": "Adds null elements of the given ArrayExpression or ArrayPattern node to the ignore list.\n@param {ASTNode} node An ArrayExpression or ArrayPattern node.\n@returns {void}", "input": "JavaScript", "output": "function addNullElementsToIgnoreList(node) {\n            let previousToken = sourceCode.getFirstToken(node);\n\n            node.elements.forEach(element => {\n                let token;\n\n                if (element === null) {\n                    token = sourceCode.getTokenAfter(previousToken);\n\n                    if (astUtils.isCommaToken(token)) {\n                        commaTokensToIgnore.push(token);\n                    }\n                } else {\n                    token = sourceCode.getTokenAfter(element);\n                }\n\n                previousToken = token;\n            });\n        }"}, {"instruction": "Convert string to printable,replace all control chars and unicode to hex escape", "input": "JavaScript", "output": "function toPrint(s,isRaw) {\n  var ctrl=/[\\x00-\\x1F\\x7F-\\x9F]/,unicode=/[\\u009F-\\uFFFF]/;\n  s=s.split('').map(function (c) {\n    if (!isRaw && printEscapeMap.hasOwnProperty(c)) return printEscapeMap[c];\n    else if (unicode.test(c)) return '\\\\u'+('00'+ord(c).toString(16).toUpperCase()).slice(-4);\n    else if (ctrl.test(c)) return '\\\\x'+(\"0\"+ord(c).toString(16).toUpperCase()).slice(-2);\n    return c;\n  }).join('');\n  return s;\n}"}, {"instruction": "Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.", "input": "JavaScript", "output": "function hideTooltipOnMouseMove(e) {\r\n\t\t\tvar pageX = defined(e.pageX) ? e.pageX : e.page.x, // In mootools the event is wrapped and the page x/y position is named e.page.x\r\n\t\t\t\tpageY = defined(e.pageX) ? e.pageY : e.page.y; // Ref: http://mootools.net/docs/core/Types/DOMEvent\r\n\r\n\t\t\tif (chartPosition &&\r\n\t\t\t\t\t!isInsidePlot(pageX - chartPosition.left - plotLeft,\r\n\t\t\t\t\t\tpageY - chartPosition.top - plotTop)) {\r\n\t\t\t\tresetTracker();\r\n\t\t\t}\r\n\t\t}"}, {"instruction": "/*\tPrivate Methods\n==================================================", "input": "JavaScript", "output": "function () {\n\t\t\n\t\t// Create Layout\n\t\tthis._el.message_container = TL.Dom.create(\"div\", \"tl-message-container\", this._el.container);\n\t\tthis._el.loading_icon = TL.Dom.create(\"div\", this.options.message_icon_class, this._el.message_container);\n\t\tthis._el.message = TL.Dom.create(\"div\", \"tl-message-content\", this._el.message_container);\n\t\t\n\t\tthis._updateMessage();\n\t\t\n\t}"}, {"instruction": "return the custom message for the given element name and validation method", "input": "JavaScript", "output": "function( name, method ) {\n\t\t\tvar m = this.settings.messages[name];\n\t\t\treturn m && (m.constructor === String ? m : m[method]);\n\t\t}"}, {"instruction": "\u6dfb\u52a0\u5e74\u6708\u65e5\u7b49\u6587\u672c\n@param { array } arr\n@param {string } text\n@param { object } props", "input": "JavaScript", "output": "function formatText(arr, text, props) {\n  const formatArray = [];\n  const localeCode = props.locale;\n  for (let i = 0; i < arr.length; i += 1) {\n    const el = arr[i];\n    formatArray.push(isArray(el) ?\n      formatText(el, locale[localeCode].surfix[colFlags[i]], props) :\n      {\n        text: addZero(el.text) +\n              (isUndefined(text) ? locale[localeCode].surfix[colFlags[i]] : text),\n        value: el.value,\n      });\n  }\n  return formatArray;\n}"}, {"instruction": "Skip transition and create new iframe\n\n@param {Object} shell shell instance\n@param {Object} options\n@param {string} options.targetPageId targetPageId\n@param {Object} options.targetPageMeta pageMeta of target page\n@param {string} options.sourcePageId sourcePageId\n@param {Object} options.sourcePageMeta pageMeta of source page\n@param {boolean} options.newPage whether a new iframe should be created (false)\n@param {boolean} options.isForward whether transition direction is forward (true)\n@param {Function} options.onComplete complete callback", "input": "JavaScript", "output": "function skipTransitionAndCreate (shell, options) {\n  let {sourcePageId, targetPageId, onComplete} = options\n\n  hideAllIFrames()\n  fixRootPageScroll(shell, {sourcePageId, targetPageId})\n  onComplete && onComplete()\n\n  let iframe = getIFrame(targetPageId)\n  css(iframe, 'z-index', activeZIndex++)\n\n  shell.afterSwitchPage(options)\n}"}, {"instruction": "Validates any given collection.\nBasically you can validate Audiences, Categories, Severity etc - everything that meets the criteria\n\nPositive cases :\n- \"Capitalcase\"\n\n@private\n@param {array} aEnum Enum to be validated.\n@param {array} oEnumComparison Enum comparison.\n@returns {boolean} Boolean response if the provided collection is valid.", "input": "JavaScript", "output": "function(aEnum, oEnumComparison) {\n\n\t\tif (aEnum && Array.isArray(aEnum) && aEnum.length) {\n\n\t\t\tfor (var i = 0; i < aEnum.length; i++) {\n\n\t\t\t\tif (oEnumComparison.hasOwnProperty(aEnum[i])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}"}, {"instruction": "/*\\\nRaphael\n[ method ]\n*\nCreates a canvas object on which to draw.\nYou must do this first, as all future calls to drawing methods\nfrom this instance will be bound to this canvas.\n> Parameters\n*\n- container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface\n- width (number)\n- height (number)\n- callback (function) #optional callback function which is going to be executed in the context of newly created paper\nor\n- x (number)\n- y (number)\n- width (number)\n- height (number)\n- callback (function) #optional callback function which is going to be executed in the context of newly created paper\nor\n- all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.\n- callback (function) #optional callback function which is going to be executed in the context of newly created paper\nor\n- onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve\u2019s \u201cDOMLoad\u201d event. In this case method returns `undefined`.\n= (object) @Paper\n> Usage\n| // Each of the following examples create a canvas\n| // that is 320px wide by 200px high.\n| // Canvas is created at the viewport\u2019s 10,50 coordinate.\n| var paper = Raphael(10, 50, 320, 200);\n| // Canvas is created at the top left corner of the #notepad element\n| // (or its top right corner in dir=\"rtl\" elements)\n| var paper = Raphael(document.getElementById(\"notepad\"), 320, 200);\n| // Same as above\n| var paper = Raphael(\"notepad\", 320, 200);\n| // Image dump\n| var set = Raphael([\"notepad\", 320, 200, {\n|     type: \"rect\",\n|     x: 10,\n|     y: 10,\n|     width: 25,\n|     height: 25,\n|     stroke: \"#f00\"\n| }, {\n|     type: \"text\",\n|     x: 30,\n|     y: 40,\n|     text: \"Dump\"\n| }]);\n\\", "input": "JavaScript", "output": "function R(first) {\n        if (R.is(first, \"function\")) {\n            return loaded ? first() : eve.on(\"raphael.DOMload\", first);\n        } else if (R.is(first, array)) {\n            return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);\n        } else {\n            var args = Array.prototype.slice.call(arguments, 0);\n            if (R.is(args[args.length - 1], \"function\")) {\n                var f = args.pop();\n                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on(\"raphael.DOMload\", function () {\n                    f.call(R._engine.create[apply](R, args));\n                });\n            } else {\n                return R._engine.create[apply](R, arguments);\n            }\n        }\n    }"}, {"instruction": "tutorials can have only one parent so there is no risk for loops", "input": "JavaScript", "output": "function saveChildren(node) {\n        node.children.forEach(function(child) {\n            var originalFileName = child.name;\n            var isHtmlTutorial = child.type === tutorial.TYPES.HTML;\n            var title = 'Tutorial: ' + child.title;\n            var fileName = helper.tutorialToUrl(child.name);\n\n            generateTutorial(title, child, fileName, originalFileName, isHtmlTutorial);\n            saveChildren(child);\n        });\n    }"}, {"instruction": "Poll for stats every `ms`.\n\n@param {Number} ms", "input": "JavaScript", "output": "function pollStats(ms) {\n    request('./stats', function (data) {\n        o('li.inactive .count').text(data.inactiveCount);\n        o('li.active .count').text(data.activeCount);\n        o('li.complete .count').text(data.completeCount);\n        o('li.failed .count').text(data.failedCount);\n        o('li.delayed .count').text(data.delayedCount);\n        setTimeout(function () {\n            pollStats(ms);\n        }, ms);\n    });\n}"}, {"instruction": "Creates an array with the control properties that are inherited.\n@param {Object} control - UI5 control.\n@returns {Array}\n@private", "input": "JavaScript", "output": "function (control) {\n\t\t\t\tvar result = [];\n\t\t\t\tvar inheritedMetadata = control.getMetadata().getParent();\n\n\t\t\t\twhile (inheritedMetadata instanceof ElementMetadata) {\n\t\t\t\t\tresult.push(this._copyInheritedProperties(control, inheritedMetadata));\n\t\t\t\t\tinheritedMetadata = inheritedMetadata.getParent();\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}"}, {"instruction": "True if is interaction with external contract (change in context, no delegate calls) (send, call of other contracts)\n@node {ASTNode} some AstNode\n@return {bool}", "input": "JavaScript", "output": "function isInteraction (node) {\n  return isLLCall(node) || isLLSend(node) || isExternalDirectCall(node) || isTransfer(node) || isLLCall050(node) || isLLSend050(node)\n}"}, {"instruction": "Calls the provided function only after all of the channels specified\nhave been fired. All channels must be sticky channels.", "input": "JavaScript", "output": "function (h, c) {\n        var len = c.length;\n        var i = len;\n        var f = function () {\n            if (!(--i)) h();\n        };\n        for (var j = 0; j < len; j++) {\n            if (c[j].state === 0) {\n                throw Error('Can only use join with sticky channels.');\n            }\n            c[j].subscribe(f);\n        }\n        if (!len) h();\n    }"}, {"instruction": "This is an internal class and is intentionally not documented.", "input": "JavaScript", "output": "function (sector, tileMatrix, row, column, imagePath) {\n            this.sector = sector;\n            this.tileMatrix = tileMatrix;\n            this.row = row;\n            this.column = column;\n            this.imagePath = imagePath;\n\n            this.texelSize = (sector.deltaLatitude() * Angle.DEGREES_TO_RADIANS) / tileMatrix.tileHeight;\n\n            this.tileKey = tileMatrix.levelNumber.toString() + \".\" + row.toString() + \".\" + column.toString();\n\n            this.gpuCacheKey = imagePath;\n        }"}, {"instruction": "Action creator for document change event. Used to create action objects\nto be passed to dispatch.\n@param  {Object} change - Document change object from Firebase callback\n@param  {Object} [originalMeta={}] - Original meta data of action\n@return {Object}                   [description]", "input": "JavaScript", "output": "function docChangeEvent(change, originalMeta = {}) {\n  const meta = { ...cloneDeep(originalMeta), path: change.doc.ref.path };\n  if (originalMeta.subcollections && !originalMeta.storeAs) {\n    meta.subcollections[0] = { ...meta.subcollections[0], doc: change.doc.id };\n  } else {\n    meta.doc = change.doc.id;\n  }\n  return {\n    type: changeTypeToEventType[change.type] || actionTypes.DOCUMENT_MODIFIED,\n    meta,\n    payload: {\n      data: change.doc.data(),\n      ordered: { oldIndex: change.oldIndex, newIndex: change.newIndex },\n    },\n  };\n}"}, {"instruction": "Computes the maximum sum of values for any date\n\n@return {Number} Max value", "input": "JavaScript", "output": "function getMaxValueByDate() {\n            let keys = uniq(data.map(o => o.name));\n            let maxValueByDate = d3Array.max(dataByDateFormatted, function(d){\n                let vals = keys.map((key) => d[key]);\n\n                return d3Array.sum(vals);\n            });\n\n            return maxValueByDate;\n        }"}, {"instruction": "/*\nrecursive function to get a dependencie Set which is ordered so that no depencies exist to a later on entry\n@return Set with all the dependencies.", "input": "JavaScript", "output": "function getAllDependencies(allVariables, currentKey, dependencies = new Set()) {\n\n    if (!allVariables[currentKey].dependencies.length) {\n\n        dependencies.add(`${currentKey}: ${allVariables[currentKey].value}`);\n        return Array.from(dependencies);\n    } else {\n\n        allVariables[currentKey].dependencies.forEach(dependecy => {\n            getAllDependencies(allVariables, dependecy, dependencies).forEach(newDependency => dependencies.add(newDependency));\n        });\n\n        dependencies.add(`${currentKey}: ${allVariables[currentKey].value}`);\n        return Array.from(dependencies);\n    }\n}"}, {"instruction": "Inlines CSS into HTML, adds media query CSS into the <style> tag of the email, and compresses the HTML", "input": "JavaScript", "output": "function inliner(css) {\n  var css = fs.readFileSync(css).toString();\n  var mqCss = siphon(css);\n\n  var pipe = lazypipe()\n    .pipe($.inlineCss, {\n      applyStyleTags: false,\n      removeStyleTags: true,\n      preserveMediaQueries: true,\n      removeLinkTags: false\n    })\n    .pipe($.replace, '<!-- <style> -->', `<style>${mqCss}</style>`)\n    .pipe($.replace, '<link rel=\"stylesheet\" type=\"text/css\" href=\"css/app.css\">', '')\n    .pipe($.htmlmin, {\n      collapseWhitespace: true,\n      minifyCSS: true\n    });\n\n  return pipe();\n}"}, {"instruction": "Emulates python's range() built-in. Returns an array of integers, counting\nup (or down) from start to end. Note that the range returned is up to, but\nNOT INCLUDING, end.\n.\n@param start  integer from which to start counting. If the end parameter is\nnot provided, this value is considered the end and start will\nbe zero.\n@param end    integer to which to count. If omitted, the function will count\nup from zero to the value of the start parameter. Note that\nthe array returned will count up to but will not include this\nvalue.\n@return       an array of consecutive integers.", "input": "JavaScript", "output": "function range(start, end)\n{\n    if (arguments.length == 1) {\n        var end = start;\n        start = 0;\n    }\n\n    var r = [];\n    if (start < end) {\n        while (start != end)\n            r.push(start++);\n    }\n    else {\n        while (start != end)\n            r.push(start--);\n    }\n    return r;\n}"}, {"instruction": "Obtains the children of a remote resource\n@param location The location of the item to obtain children for\n@return A deferred that will provide the array of child objects when complete", "input": "JavaScript", "output": "function(location) {\n\t\t\tif (!location) {\n\t\t\t\tlocation = this._rootLocation;\n\t\t\t}\n\t\t\treturn _call(\"PROPFIND\", location, {depth:1}).then(function(response) {\n\t\t\t\tif (response.status !== 207) {\n\t\t\t\t\tthrow \"Error \" + response.status;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar multistatus = parseDAV_multistatus(response.responseText);\n\t\t\t\tvar childrenResponses = multistatus.response.slice(1);\n\t\t\t\t\n\t\t\t\tvar children = [];\n\t\t\t\twhile (childrenResponses.length !== 0) {\n\t\t\t\t\tchildren.push(createFile(childrenResponses.shift()));\n\t\t\t\t}\n\t\t\t\treturn children;\n\t\t\t});\n\t\t}"}, {"instruction": "Get linefeed\n\n@param {Object} options\n@api private", "input": "JavaScript", "output": "function getLinefeed(options) {\n  var feeds = {\n    cr: '\\r',\n    crlf: '\\r\\n',\n    lf: '\\n',\n    lfcr: '\\n\\r'\n  };\n\n  return feeds[options.linefeed] || '\\n';\n}"}, {"instruction": "extended", "input": "JavaScript", "output": "function( dir, result ){\n\n            result = result || new Physics.vector();\n\n            return result.clone( dir ).normalize().mult( this.radius );\n        }"}, {"instruction": "if (transform == null) { throw new Error(`No transform found for ${ccName}`); }", "input": "JavaScript", "output": "function statsMethod (query = {}) {\n    const reqParams = Object.assign({}, defaults, query);\n\n    debug(\"stats request\", endpoint.url, reqParams);\n    return transport(endpoint.url, reqParams).then(function (response) {\n      if (response == null) return;\n\n      // response is something like \"GameID is required\"\n      if (typeof response === \"string\") throw new Error(response);\n\n      return transform ? transform(response) : response;\n    });\n  }"}, {"instruction": "('data.a.b', 5) => opts.data.a.b = 5", "input": "JavaScript", "output": "function (path, value) {\n    if (typeof path == 'string') {\n      path = path.split('.');\n    } else if (!Array.isArray(path)) {\n      return;\n    }\n\n    var propName = path.shift();\n    var prop = Model.allProperties[propName] || opts.extra[propName];\n    var currKey, currObj;\n\n    if (!prop) {\n      return;\n    }\n    if (path.length == 0) {\n      instance[propName] = value;\n      return;\n    }\n    currObj = instance[propName];\n\n    while(currObj && path.length > 0 ) {\n      currKey = path.shift();\n\n      if (path.length > 0) {\n        currObj = currObj[currKey];\n      } else if (currObj[currKey] !== value) {\n        currObj[currKey] = value;\n        opts.changes.push(propName);\n      }\n    }\n  }"}, {"instruction": "Helper function to get the text of a given document and send it to tern.\nIf DocumentManager successfully gets the file's text then we'll send it to the tern node domain.\nThe Promise for getDocumentText() is returned so that custom fail functions can be used.\n\n@param {string} filePath - the path of the file to get the text of\n@return {jQuery.Promise} - the Promise returned from DocumentMangaer.getDocumentText()", "input": "JavaScript", "output": "function getDocText(filePath) {\n                if (!FileSystem.isAbsolutePath(filePath) || // don't handle URLs\n                        filePath.slice(0, 2) === \"//\") { // don't handle protocol-relative URLs like //example.com/main.js (see #10566)\n                    return (new $.Deferred()).reject().promise();\n                }\n\n                var file = FileSystem.getFileForPath(filePath),\n                    promise = DocumentManager.getDocumentText(file);\n\n                promise.done(function (docText) {\n                    resolvedFiles[name] = filePath;\n                    numResolvedFiles++;\n                    replyWith(name, filterText(docText));\n                });\n                return promise;\n            }"}, {"instruction": "\u5206\u6790\u6ce8\u91ca\u4e2d\u4f9d\u8d56\u7528\u6cd5\u3002\n@param {String} comment \u6ce8\u91ca\u5185\u5bb9\n@param {Callback} [callback] \u53ef\u4ee5\u901a\u8fc7\u6b64\u53c2\u6570\u6765\u66ff\u6362\u539f\u6709\u66ff\u6362\u56de\u8c03\u51fd\u6570\u3002\n@memberOf fis.compile", "input": "JavaScript", "output": "function analyseComment(comment, callback) {\n  var reg = /(@(require|async|require\\.async)\\s+)('[^']+'|\"[^\"]+\"|[^\\s;!@#%^&*()]+)/g;\n  callback = callback || function(m, prefix, type, value) {\n    type = type === 'require' ? type : 'async';\n\n    return prefix + map[type].wrap(value);\n  };\n\n  return comment.replace(reg, callback).replace(/(?:@|#)\\s+sourceMappingURL=([^\\s]+)/g, function(_, value) {\n    return '# sourceMappingURL=' + map.sourceMap.wrap(value);\n  });\n}"}, {"instruction": "Helper that creates a NDEF record containing an absolute URI.\n\nAn Absolute URI record means the URI describes the payload of the record.\n\nFor example a SOAP message could use \"http://schemas.xmlsoap.org/soap/envelope/\"\nas the type and XML content for the payload.\n\nAbsolute URI can also be used to write LaunchApp records for Windows.\n\nSee 2.4.2 Payload Type of the NDEF Specification\nhttp://www.nfc-forum.org/specs/spec_list#ndefts\n\nNote that by default, Android will open the URI defined in the type\nfield of an Absolute URI record (TNF=3) and ignore the payload.\nBlackBerry and Windows do not open the browser for TNF=3.\n\nTo write a URI as the payload use ndef.uriRecord(uri)\n\n@uri String\n@payload byte[] or String\n@id byte[] (optional)", "input": "JavaScript", "output": "function (uri, payload, id) {\n        if (!id) { id = []; }\n        if (!payload) { payload = []; }\n        return ndef.record(ndef.TNF_ABSOLUTE_URI, uri, id, payload);\n    }"}, {"instruction": "Keeps the selection state in sync", "input": "JavaScript", "output": "function(sender, evt)\n\t{\n\t\tvar changes = evt.getProperty('edit').changes;\n\t\tgraph.setSelectionCells(graph.getSelectionCellsForChanges(changes));\n\t}"}, {"instruction": "Validate regular expression literals\n@param {ASTNode} node node to validate\n@returns {void}\n@private", "input": "JavaScript", "output": "function checkLiteral(node) {\n            const token = sourceCode.getFirstToken(node),\n                nodeType = token.type,\n                nodeValue = token.value;\n\n            if (nodeType === \"RegularExpression\") {\n                checkRegex(node, nodeValue, token.range[0]);\n            }\n        }"}, {"instruction": "@private\nProcess and load the current theme into the editor\n\n@return {$.Promise} promise object resolved with the theme object and all\ncorresponding new css/less and scrollbar information", "input": "JavaScript", "output": "function loadCurrentTheme() {\n        var theme = getCurrentTheme();\n\n        var pending = theme && FileUtils.readAsText(theme.file)\n            .then(function (lessContent) {\n                return lessifyTheme(lessContent.replace(commentRegex, \"\"), theme);\n            })\n            .then(function (content) {\n                var result = extractScrollbars(content);\n                theme.scrollbar = result.scrollbar;\n                return result.content;\n            })\n            .then(function (cssContent) {\n                $(\"body\").toggleClass(\"dark\", theme.dark);\n                styleNode.text(cssContent);\n                return theme;\n            });\n\n        return $.when(pending);\n    }"}, {"instruction": "Return a string that shows the literal parent hierarchy of the selector\nin info.\n\n@param {!SelectorInfo} info\n@param {boolean=} useGroup true to append selectorGroup instead of selector\n@return {string} the literal parent hierarchy of the selector", "input": "JavaScript", "output": "function getCompleteSelectors(info, useGroup) {\n        if (info.parentSelectors) {\n            // Show parents with / separators.\n            var completeSelectors = info.parentSelectors + \" / \";\n            if (useGroup && info.selectorGroup) {\n                completeSelectors += info.selectorGroup;\n            } else {\n                completeSelectors += info.selector;\n            }\n            return completeSelectors;\n        } else if (useGroup && info.selectorGroup) {\n            return info.selectorGroup;\n        }\n\n        return info.selector;\n    }"}, {"instruction": "/*", "input": "JavaScript", "output": "function preTransformVFor (el, options) {\n  var exp = getAndRemoveAttr(el, 'v-for');\n  if (!exp) {\n    return\n  }\n\n  var res = parseFor(exp);\n  if (!res) {\n    if (process.env.NODE_ENV !== 'production' && options.warn) {\n      options.warn((\"Invalid v-for expression: \" + exp));\n    }\n    return\n  }\n\n  var desc = {\n    '@expression': res.for,\n    '@alias': res.alias\n  };\n  if (res.iterator2) {\n    desc['@key'] = res.iterator1;\n    desc['@index'] = res.iterator2;\n  } else {\n    desc['@index'] = res.iterator1;\n  }\n\n  delete el.attrsMap['v-for'];\n  addRawAttr(el, '[[repeat]]', desc);\n}"}, {"instruction": "create an touch point\n@constructor\n@param target\n@param identifier\n@param pos\n@param deltaX\n@param deltaY\n@returns {Object} touchPoint", "input": "JavaScript", "output": "function Touch(target, identifier, pos, deltaX, deltaY) {\n        deltaX = deltaX || 0;\n        deltaY = deltaY || 0;\n\n        this.identifier = identifier;\n        this.target = target;\n        this.clientX = pos.clientX + deltaX;\n        this.clientY = pos.clientY + deltaY;\n        this.screenX = pos.screenX + deltaX;\n        this.screenY = pos.screenY + deltaY;\n        this.pageX = pos.pageX + deltaX;\n        this.pageY = pos.pageY + deltaY;\n    }"}, {"instruction": "process items to extract files to be uploaded\n@param  {File[]} items items to process\n@param  {Event} event event that led to upload", "input": "JavaScript", "output": "function loadFiles(items, event) {\n      if(!items.length){\n        return; // nothing to do\n      }\n      $.fire('beforeAdd');\n      var files = [];\n      processCallbacks(\n          Array.prototype.map.call(items, function(item){\n            // bind all properties except for callback\n            var entry = item;\n            if('function' === typeof item.webkitGetAsEntry){\n              entry = item.webkitGetAsEntry();\n            }\n            return processItem.bind(null, entry, \"\", files);\n          }),\n          function(){\n            if(files.length){\n              // at least one file found\n              appendFilesFromFileList(files, event);\n            }\n          }\n      );\n    }"}, {"instruction": "Displays the UI for a signed out user.", "input": "JavaScript", "output": "function() {\n  document.getElementById('user-signed-in').style.display = 'none';\n  document.getElementById('user-signed-out').style.display = 'block';\n  ui.start('#firebaseui-container', getUiConfig());\n}"}, {"instruction": "TODO(dbeam): DO NOT USE. THIS IS DEPRECATED. Use an action-link instead.\nCall this to stop clicks on <a href=\"#\"> links from scrolling to the top of\nthe page (and possibly showing a # in the link).", "input": "JavaScript", "output": "function preventDefaultOnPoundLinkClicks() {\n  document.addEventListener('click', function(e) {\n    var anchor = findAncestor(/** @type {Node} */(e.target), function(el) {\n      return el.tagName == 'A';\n    });\n    // Use getAttribute() to prevent URL normalization.\n    if (anchor && anchor.getAttribute('href') == '#')\n      e.preventDefault();\n  });\n}"}, {"instruction": "We want the smallest scaled file to be uploaded first", "input": "JavaScript", "output": "function(sizes) {\n        \"use strict\";\n\n        sizes = qq.extend([], sizes);\n\n        return sizes.sort(function(a, b) {\n            if (a.maxSize > b.maxSize) {\n                return 1;\n            }\n            if (a.maxSize < b.maxSize) {\n                return -1;\n            }\n            return 0;\n        });\n    }"}, {"instruction": "OAuth2 Username-Password Flow (Resource Owner Password Credentials)\n\n@param {String} username - Salesforce username\n@param {String} password - Salesforce password\n@param {Callback.<TokenResponse>} [callback] - Callback function\n@returns {Promise.<TokenResponse>}", "input": "JavaScript", "output": "function(username, password, callback) {\n    return this._postParams({\n      grant_type : \"password\",\n      username : username,\n      password : password,\n      client_id : this.clientId,\n      client_secret : this.clientSecret,\n      redirect_uri : this.redirectUri\n    }, callback);\n  }"}, {"instruction": "\u5728 trailing edge \u4e14\u65f6\u95f4\u7b26\u5408\u6761\u4ef6\u65f6\uff0c\u8c03\u7528 trailingEdge\u51fd\u6570\uff0c\u5426\u5219\u91cd\u542f\u5b9a\u65f6\u5668", "input": "JavaScript", "output": "function timerExpired() {\n    let time = new Date()\n      .getTime();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // \u91cd\u542f\u5b9a\u65f6\u5668\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }"}, {"instruction": "Converts an array of globs to full paths\n@function\n@param {array} globs - Array of globs and/or normal paths\n@return {array} Array of fully-qualified paths\n@requires glob", "input": "JavaScript", "output": "function convertGlobPaths(globs) {\n  return globs\n    .map(globString => glob.sync(globString))\n    .reduce((previous, current) => previous.concat(current), []);\n}"}, {"instruction": "Hooks and props are merged as arrays.", "input": "JavaScript", "output": "function mergeHook (\n  parentVal,\n  childVal\n) {\n  const res = childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal;\n  return res\n    ? dedupeHooks(res)\n    : res\n}"}, {"instruction": "lets you call a css selector with a guard", "input": "JavaScript", "output": "function (args, env) {\n        var lastSelector = this.selectors[this.selectors.length-1];\n        if (!lastSelector.evaldCondition) {\n            return false;\n        }\n        if (lastSelector.condition &&\n            !lastSelector.condition.eval(\n                new(tree.evalEnv)(env,\n                    env.frames))) {\n            return false;\n        }\n        return true;\n    }"}, {"instruction": "Used to assert that actual matches expected value, where expected may be a function or a string.", "input": "JavaScript", "output": "function assertMatch(actual, expected, message) {\n  if (isRegExp(expected))\n    assert(expected.test(actual), message || `Expected \"${actual}\" to match \"${expected}\"`);\n  else if (typeof expected === 'function')\n    assert(expected(actual), message);\n  else\n    assert.deepEqual(actual, expected, message);\n}"}, {"instruction": "Current position of an element relative to the document.", "input": "JavaScript", "output": "function offset ( elem, orientation ) {\n\n        var rect = elem.getBoundingClientRect(),\n            doc = elem.ownerDocument,\n            docElem = doc.documentElement,\n            pageOffset = getPageOffset();\n\n        // getBoundingClientRect contains left scroll in Chrome on Android.\n        // I haven't found a feature detection that proves this. Worst case\n        // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.\n        if ( /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) ) {\n            pageOffset.x = 0;\n        }\n\n        return orientation ? (rect.top + pageOffset.y - docElem.clientTop) : (rect.left + pageOffset.x - docElem.clientLeft);\n    }"}, {"instruction": "--- Compile Helpers ---", "input": "JavaScript", "output": "function getPackagePath(p) {\n      if (p.path) {\n        return p.path;\n      } else if (p.polyfill) {\n        return path.join('polyfills', p.namespace.toLowerCase(), p.name);\n      } else if (p.type === 'fix') {\n        return path.join(p.module.toLowerCase(), 'fixes', p.name);\n      } else if (p.type === 'locale') {\n        return path.join(p.module.toLowerCase(), p.code);\n      } else if (sourcePackageIsDependency(p)) {\n        return path.join(p.module.toLowerCase(), p.type, p.name);\n      } else {\n        return path.join(p.namespace.toLowerCase(), p.name);\n      }\n    }"}, {"instruction": "Calculates the height and width of text on the canvas Width is found by using the canvas measureText function Height is only estimated -- it calculates the font size in pixels, and sets the height to 110% of that.", "input": "JavaScript", "output": "function() {\n        var ctx = this._drawContext;\n        ctx.font = this._fontString();\n        this.w = ctx.measureText(this._text).width;\n\n        var size = this._textFont.size || this.defaultSize;\n        this.h = 1.1 * this._getFontHeight(size);\n\n        /* Offset the MBR for text alignment*/\n        if (this._textAlign === \"left\" || this._textAlign === \"start\") {\n            this.offsetBoundary(0, 0, 0, 0);\n        } else if (this._textAlign === \"center\") {\n            this.offsetBoundary(this.w / 2, 0, -this.w / 2, 0);\n        } else if (this._textAlign === \"end\" || this._textAlign === \"right\") {\n            this.offsetBoundary(this.w, 0, -this.w, 0);\n        }\n    }"}, {"instruction": "eslint-disable-next-line no-unused-vars", "input": "JavaScript", "output": "function toggleSlideShowMode() {\n  const streams = room.remoteStreams;\n  const cb = (evt) => {\n    console.log('SlideShowMode changed', evt);\n  };\n  slideShowMode = !slideShowMode;\n  streams.forEach((stream) => {\n    if (localStream.getID() !== stream.getID()) {\n      console.log('Updating config');\n      stream.updateConfiguration({ slideShowMode }, cb);\n    }\n  });\n}"}, {"instruction": "This function returns the route object matched by the identifier passed as parameter.\n@private", "input": "JavaScript", "output": "function findRouteByIdentifier(sIdf){\n\t\t\tvar i;\n\t\t\tfor (i = 0 ; i < routes.length ; i++) {\n\t\t\t\tif (routes[i].sIdentifier === sIdf) {\n\t\t\t\t\treturn routes[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}"}, {"instruction": "If there are promise handlers waiting for execution at the time the timeout fires, start another timeout to postpone timer execution after promise execution.", "input": "JavaScript", "output": "function wrapTimerHandler(vHandler) {\n\t\t\t\tvar fnWrappedHandler = function() {\n\t\t\t\t\tvar aArgs, fnHandler;\n\t\t\t\t\tif (bPromisesQueued) {\n\t\t\t\t\t\taArgs = [fnWrappedHandler, 0].concat(arguments);\n\t\t\t\t\t\t_timeout.apply(window, aArgs);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfnHandler = typeof vHandler !== \"function\" ? new Function(vHandler) : vHandler; // eslint-disable-line no-new-func\n\t\t\t\t\t\tfnHandler.apply(window, arguments);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\treturn fnWrappedHandler;\n\t\t\t}"}, {"instruction": "Gets whether two dates have the same month and year.\n@param {Date} d1\n@param {Date} d2\n@returns {boolean}", "input": "JavaScript", "output": "function isSameMonthAndYear(d1, d2) {\n      return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth();\n    }"}, {"instruction": "Get the parent ES6 component node from the current scope\n\n@returns {ASTNode} component node, null if we are not in a component", "input": "JavaScript", "output": "function () {\n      let scope = context.getScope();\n      while (scope && scope.type !== 'class') {\n        scope = scope.upper;\n      }\n      const node = scope && scope.block;\n      if (!node || !utils.isES6Component(node)) {\n        return null;\n      }\n      return node;\n    }"}, {"instruction": "Log when a file changes\n@param {BrowserSync} bs\n@param data", "input": "JavaScript", "output": "function(bs, data) {\n        if (canLogFileChange(bs, data)) {\n            if (data.path[0] === \"*\") {\n                return logger.info(\n                    \"{cyan:Reloading files that match: {magenta:%s\",\n                    data.path\n                );\n            }\n\n            logger.info(\n                \"{cyan:File event [\" + data.event + \"] : {magenta:%s\",\n                data.path\n            );\n        }\n    }"}, {"instruction": "extended", "input": "JavaScript", "output": "function( meta ){\n\n            this.els.fps.innerHTML = meta.fps.toFixed(2);\n            this.els.ipf.innerHTML = meta.ipf;\n        }"}, {"instruction": "runner", "input": "JavaScript", "output": "function traverseDirectory(pathname, callback) {\n\tpathname = pathname.replace(/\\\\/g, \"/\")\n\treturn new Promise(function(resolve, reject) {\n\t\tfs.lstat(pathname, function(err, stat) {\n\t\t\tif (err) reject(err)\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\tfs.readdir(pathname, function(err, pathnames) {\n\t\t\t\t\tif (err) reject(err)\n\t\t\t\t\tvar promises = []\n\t\t\t\t\tfor (var i = 0; i < pathnames.length; i++) {\n\t\t\t\t\t\tpathnames[i] = path.join(pathname, pathnames[i])\n\t\t\t\t\t\tpromises.push(traverseDirectory(pathnames[i], callback))\n\t\t\t\t\t}\n\t\t\t\t\tcallback(pathname, stat, pathnames)\n\t\t\t\t\tresolve(Promise.all(promises))\n\t\t\t\t})\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcallback(pathname, stat)\n\t\t\t\tresolve(pathname)\n\t\t\t}\n\t\t})\n\t})\n}"}, {"instruction": "listing descendant nodes\n\n@param {Node} node\n@param {Function} [pred] - predicate function", "input": "JavaScript", "output": "function listDescendant(node, pred) {\n  const descendants = [];\n  pred = pred || func.ok;\n\n  // start DFS(depth first search) with node\n  (function fnWalk(current) {\n    if (node !== current && pred(current)) {\n      descendants.push(current);\n    }\n    for (let idx = 0, len = current.childNodes.length; idx < len; idx++) {\n      fnWalk(current.childNodes[idx]);\n    }\n  })(node);\n\n  return descendants;\n}"}, {"instruction": "client.enableSessionPersistence\n\n@description Enable session persistence of the requested type\n\n@param {Object}          loadBalancer      the loadBalancer or loadBalancerId\n@param {String}          type              HTTP_COOKIE or SOURCE_IP\n@param {function}        callback", "input": "JavaScript", "output": "function (loadBalancer, type, callback) {\n    var self = this,\n        loadBalancerId =\n          loadBalancer instanceof lb.LoadBalancer ? loadBalancer.id : loadBalancer;\n\n    if (!type || (type !== 'HTTP_COOKIE' && type !== 'SOURCE_IP')) {\n      throw new Error('Please provide a valid session persistence type');\n    }\n\n    self._request({\n      path: urlJoin(_urlPrefix, loadBalancerId, 'sessionpersistence'),\n      method: 'PUT',\n      body: {\n        sessionPersistence: {\n          persistenceType: type\n        }\n      }\n    }, function (err) {\n      return callback(err);\n    });\n  }"}, {"instruction": "Resize method bound to the polar\n@param {module:echarts/coord/polar/PolarModel} polarModel\n@param {module:echarts/ExtensionAPI} api", "input": "JavaScript", "output": "function resizePolar(polar, polarModel, api) {\n    var center = polarModel.get('center');\n    var width = api.getWidth();\n    var height = api.getHeight();\n\n    polar.cx = parsePercent(center[0], width);\n    polar.cy = parsePercent(center[1], height);\n\n    var radiusAxis = polar.getRadiusAxis();\n    var size = Math.min(width, height) / 2;\n    var radius = parsePercent(polarModel.get('radius'), size);\n    radiusAxis.inverse\n        ? radiusAxis.setExtent(radius, 0)\n        : radiusAxis.setExtent(0, radius);\n}"}, {"instruction": "+'s are replaced with spaces when used in query params, this returns them to +'s, then removes remaining whitespace. https://github.com/badges/shields/pull/1546", "input": "JavaScript", "output": "function decodeDataUrlFromQueryParam(value) {\n  if (typeof value !== 'string') {\n    return undefined\n  }\n  const maybeDataUrl = prependPrefix(value, 'data:')\n    .replace(/ /g, '+')\n    .replace(/\\s/g, '')\n  return isDataUrl(maybeDataUrl) ? maybeDataUrl : undefined\n}"}, {"instruction": "* -1 if rtl scroll max is negative", "input": "JavaScript", "output": "function(base) {\n                        return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));\n                    }"}, {"instruction": "This next function modelled on Cesium.geoJsonDataSource's defaultDescribe.", "input": "JavaScript", "output": "function describeWithoutUnderscores(properties, nameProperty) {\n  var html = \"\";\n  for (var key in properties) {\n    if (properties.hasOwnProperty(key)) {\n      if (key === nameProperty || simpleStyleIdentifiers.indexOf(key) !== -1) {\n        continue;\n      }\n      var value = properties[key];\n      if (typeof value === \"object\") {\n        value = describeWithoutUnderscores(value);\n      } else {\n        value = formatPropertyValue(value);\n      }\n      key = key.replace(/_/g, \" \");\n      if (defined(value)) {\n        html += \"<tr><th>\" + key + \"</th><td>\" + value + \"</td></tr>\";\n      }\n    }\n  }\n  if (html.length > 0) {\n    html =\n      '<table class=\"cesium-infoBox-defaultTable\"><tbody>' +\n      html +\n      \"</tbody></table>\";\n  }\n  return html;\n}"}, {"instruction": "Reads files from .desktop and computes a version hash.\n\n@param {string} dir - path\n@returns {Promise<Object>}", "input": "JavaScript", "output": "function readFilesAndComputeDesktopHash(dir) {\n    const desktopHash = crypto.createHash('sha1');\n\n    return new Promise((resolve, reject) => {\n        getFileList(dir)\n            .catch(reject)\n            .then(readAndHashFiles)\n            .catch(reject)\n            .then((result) => {\n                const hash = result.files.reduce(\n                    (tmpHash, file) => {\n                        tmpHash += result.fileHashes[file];\n                        return tmpHash;\n                    }, ''\n                );\n                desktopHash.update(hash);\n                result.hash = desktopHash.digest('hex');\n                resolve(result);\n            });\n    });\n}"}, {"instruction": "Locates the instance of lm.controls.Splitter in the array of\nregistered splitters and returns a map containing the contentItem\nbefore and after the splitters, both of which are affected if the\nsplitter is moved\n\n@param   {lm.controls.Splitter} splitter\n\n@returns {Object} A map of contentItems that the splitter affects", "input": "JavaScript", "output": "function( splitter ) {\n\t\tvar index = lm.utils.indexOf( splitter, this._splitter );\n\t\t\n\t\treturn {\n\t\t\tbefore: this.contentItems[ index ],\n\t\t\tafter: this.contentItems[ index + 1 ]\n\t\t};\n\t}"}, {"instruction": "Find the deepest React component completely containing the root of the\npassed-in instance (for use when entire React trees are nested within each\nother). If React trees are not nested, returns null.", "input": "JavaScript", "output": "function findRootContainerNode(inst) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  if (typeof inst.tag === 'number') {\n    while (inst['return']) {\n      inst = inst['return'];\n    }\n    if (inst.tag !== HostRoot) {\n      // This can happen if we're in a detached tree.\n      return null;\n    }\n    return inst.stateNode.containerInfo;\n  } else {\n    while (inst._hostParent) {\n      inst = inst._hostParent;\n    }\n    var rootNode = ReactDOMComponentTree_1.getNodeFromInstance(inst);\n    return rootNode.parentNode;\n  }\n}"}, {"instruction": "Replace any characters that can't be sent on with an underscore", "input": "JavaScript", "output": "function sanitizeTags(value, telegraf) {\n  const blacklist = telegraf ? /:|\\|/g : /:|\\||@|,/g;\n  // Replace reserved chars with underscores.\n  return String(value).replace(blacklist, '_');\n}"}, {"instruction": "Initialize the generator\n\n@param {Output}\n@return {Output}", "input": "JavaScript", "output": "function onInit(output) {\n    return Promise(output)\n    .then(prepareI18n)\n    .then(prepareResources)\n    .then(copyPluginAssets);\n}"}, {"instruction": "Turns off the event handlers for a given event, optionally for a specific preference\nor a specific handler function.\n\n@param {string} event Name of the event for which to turn off listening\n@param {string|Function} preferenceID Name of a specific preference or the handler function\n@param {?Function} handler Specific handler which should stop being notified", "input": "JavaScript", "output": "function (event, preferenceID, handler) {\n            if (typeof preferenceID === \"function\") {\n                handler = preferenceID;\n                preferenceID = null;\n            }\n\n            if (preferenceID) {\n                var pref = this.getPreference(preferenceID);\n                pref.off(event, handler);\n            } else {\n                this._off_internal(event, handler);\n            }\n        }"}, {"instruction": "Validate a book configuration for plugins and\nreturns an update configuration with default values.\n\n@param {Book}\n@param {OrderedMap<String:Plugin>}\n@return {Promise<Book>}", "input": "JavaScript", "output": "function validateConfig(book, plugins) {\n    return Promise.reduce(plugins, function(newBook, plugin) {\n        return validatePluginConfig(newBook, plugin);\n    }, book);\n}"}, {"instruction": "Convert the JSON object to a padded buffer.\n\nPad the JSON with extra whitespace to fit the next 4-byte boundary. This ensures proper alignment\nfor the section that follows.\n\n@param {Object} [json] The JSON object.\n@returns {Buffer} The padded JSON buffer.\n\n@private", "input": "JavaScript", "output": "function getJsonBufferPadded(json) {\n    let string = JSON.stringify(json);\n\n    const boundary = 4;\n    const byteLength = Buffer.byteLength(string);\n    const remainder = byteLength % boundary;\n    const padding = (remainder === 0) ? 0 : boundary - remainder;\n    let whitespace = '';\n    for (let i = 0; i < padding; ++i) {\n        whitespace += ' ';\n    }\n    string += whitespace;\n\n    return Buffer.from(string);\n}"}, {"instruction": "---- Names and Paths ----------------------------------------------------------------------- \nName conversion function that converts a name in unified resource name syntax to a name in UI5 module name syntax.\nIf the name cannot be converted (e.g. doesn't end with '.js'), then <code>undefined</code> is returned.\n\n@param {string} sName Name in unified resource name syntax\n@returns {string|undefined} Name in UI5 (legacy) module name syntax (dot separated)\nor <code>undefined</code> when the name can't be converted\n@private", "input": "JavaScript", "output": "function urnToUI5(sName) {\n\t\t// UI5 module name syntax is only defined for JS resources\n\t\tif ( !/\\.js$/.test(sName) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tsName = sName.slice(0, -3);\n\t\tif ( /^jquery\\.sap\\./.test(sName) ) {\n\t\t\treturn sName; // do nothing\n\t\t}\n\t\treturn sName.replace(/\\//g, \".\");\n\t}"}, {"instruction": "/*eslint-enable no-loop-func", "input": "JavaScript", "output": "function getContextInfos(oContext, sModelName) {\n\t\t\t\tvar mContextInfos = {\n\t\t\t\t\tmodelName: (sModelName === 'undefined') ? 'none (default)' : sModelName,\n\t\t\t\t\tpath: oContext.getPath()\n\t\t\t\t};\n\n\t\t\t\tif (oContext.getModel().isA(\"sap.ui.model.odata.v4.ODataModel\")) { // ODataModel v4 throws an exception on getObject()\n\t\t\t\t\tmContextInfos.unverifiedPath = true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!oContext.getObject() == null) {\n\t\t\t\t\t\tmContextInfos.invalidPath = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn mContextInfos;\n\t\t\t}"}, {"instruction": "Write the API meta data used for the AutoComplete widget\n@method writeAPIMeta\n@param {Callback} cb The callback to execute when complete\n@async", "input": "JavaScript", "output": "function (cb) {\n            Y.log('Writing API Meta Data', 'info', 'builder');\n            var self = this;\n            this.renderAPIMeta(function (js) {\n                fs.writeFile(path.join(self.options.outdir, 'api.js'), js, Y.charset, cb);\n            });\n        }"}, {"instruction": "Returns a view limiter that prevents zooming in beyond the given\nresolution.\n@param {number} size The image width in pixels.\n@return {FlatViewLimiter}", "input": "JavaScript", "output": "function(size) {\n    return function limitResolution(params) {\n      if (params.width <= 0 || params.height <= 0) {\n        return params;\n      }\n      var width = params.width;\n      var minZoom = pixelRatio() * width / size;\n      params.zoom = clamp(params.zoom, minZoom, Infinity);\n      return params;\n    };\n  }"}, {"instruction": "Remove animator\n@param {clay.animate.Animator} animator", "input": "JavaScript", "output": "function (animator) {\n        var clips = animator.getClips();\n        for (var i = 0; i < clips.length; i++) {\n            this.removeClip(clips[i]);\n        }\n        animator.animation = null;\n    }"}, {"instruction": "Returns true if the source code is intended to run in strict mode. Does not detect\n\"use strict\" if it occurs in a nested function.\n\n@param {String} src\n@return {Boolean}", "input": "JavaScript", "output": "function detectStrictMode(src) {\r\n    var singleLine;\r\n    var multiLine;\r\n\r\n    while ((singleLine = singleLineComment.test(src)) || (multiLine = multiLineComment.test(src))) {\r\n        if (singleLine) {\r\n            src = src.replace(singleLineComment, \"\");\r\n        }\r\n        if (multiLine) {\r\n            src = src.replace(multiLineComment, \"\");\r\n        }\r\n    }\r\n\r\n    return strictMode.test(src);\r\n}"}, {"instruction": "/* TODO", "input": "JavaScript", "output": "function write_sty_xlml(wb, opts)/*:string*/ {\n\t/* Styles */\n\tvar styles/*:Array<string>*/ = ['<Style ss:ID=\"Default\" ss:Name=\"Normal\"><NumberFormat/></Style>'];\n\topts.cellXfs.forEach(function(xf, id) {\n\t\tvar payload/*:Array<string>*/ = [];\n\t\tpayload.push(writextag('NumberFormat', null, {\"ss:Format\": escapexml(SSF._table[xf.numFmtId])}));\n\t\tstyles.push(writextag('Style', payload.join(\"\"), {\"ss:ID\": \"s\" + (21+id)}));\n\t});\n\treturn writextag(\"Styles\", styles.join(\"\"));\n}"}, {"instruction": "column merge \uac00 \uc124\uc815\ub418\uc5b4 \uc788\uc744 \ub54c \ud5e4\ub354\uc758 \uacc4\uce35\uad6c\uc870 \ub9ac\uc2a4\ud2b8\ub97c \uac00\uc838\uc628\ub2e4.\n@returns {Array}  \uacc4\uce35\uad6c\uc870 \ub9ac\uc2a4\ud2b8\n@private", "input": "JavaScript", "output": "function() {\n        var columns = this._getColumnData().columns;\n        var hierarchyList;\n\n        hierarchyList = _.map(columns, function(column) {\n            return this._getColumnHierarchy(column).reverse();\n        }, this);\n\n        return hierarchyList;\n    }"}, {"instruction": "Determines whether a provided address matches the provided parent domain in order\nto avoid certain attack vectors.\n\n@param {String} srvAddress The address to check against a domain\n@param {String} parentDomain The domain to check the provided address against\n@return {Boolean} Whether the provided address matches the parent domain", "input": "JavaScript", "output": "function matchesParentDomain(srvAddress, parentDomain) {\n  const regex = /^.*?\\./;\n  const srv = `.${srvAddress.replace(regex, '')}`;\n  const parent = `.${parentDomain.replace(regex, '')}`;\n  return srv.endsWith(parent);\n}"}, {"instruction": "/*\nCreates new sap.ui.layout.ResponsiveFlowLayoutData with the given parameters\n@param {int} iWeight the weight for the layout data\n@param {boolean} bLinebreak Whether the layout data has a linebreak\n@param {boolean} bLinebreakable Whether the layout data is linebreakable\n@returns {sap.ui.layout.ResponsiveFlowLayoutData} The newly created ResponsiveFlowLayoutData\n@private", "input": "JavaScript", "output": "function _createRFLayoutData(iWeight, bLinebreak, bLinebreakable, iMinWidth) {\n\n\t\tvar oLayout = new ResponsiveFlowLayoutData({weight:iWeight,linebreak:bLinebreak === true,linebreakable: bLinebreakable === true});\n\t\tif (iMinWidth) {\n\t\t\toLayout.setMinWidth(iMinWidth);\n\t\t}\n\t\tthis._aLayouts.push(oLayout.getId());\n\t\treturn oLayout;\n\n\t}"}, {"instruction": "/*\n<functionName>: function() {}", "input": "JavaScript", "output": "function (node) {\n                if (node.body && node.body.type === \"FunctionDeclaration\") {\n                    if (node.label) {\n                        _addResult(node.label);\n                    }\n                }\n            }"}, {"instruction": "23.1.3.3 Map.prototype.delete(key) 23.2.3.4 Set.prototype.delete(value)", "input": "JavaScript", "output": "function (key) {\n        var that = this;\n        var state = getInternalState(that);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.next;\n          var prev = entry.previous;\n          delete state.index[entry.index];\n          entry.removed = true;\n          if (prev) prev.next = next;\n          if (next) next.previous = prev;\n          if (state.first == entry) state.first = next;\n          if (state.last == entry) state.last = prev;\n          if (DESCRIPTORS) state.size--;\n          else that.size--;\n        } return !!entry;\n      }"}, {"instruction": "Set a property on an object. Adds the new property and\ntriggers change notification if the property doesn't\nalready exist.", "input": "JavaScript", "output": "function set (target, key, val) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}"}, {"instruction": "Delimiter functions", "input": "JavaScript", "output": "function checkDelimiter(\n    delim: AnyParseNode,\n    context: FunctionContext,\n): SymbolParseNode {\n    const symDelim = checkSymbolNodeType(delim);\n    if (symDelim && utils.contains(delimiters, symDelim.text)) {\n        return symDelim;\n    } else {\n        throw new ParseError(\n            \"Invalid delimiter: '\" +\n            (symDelim ? symDelim.text : JSON.stringify(delim)) +\n            \"' after '\" + context.funcName + \"'\", delim);\n    }\n}"}, {"instruction": "PrivateFunction: _newXHR\n_Private_ helper function to create XMLHttpRequests.\n\nThis function creates XMLHttpRequests across all implementations.\n\nReturns:\nA new XMLHttpRequest.", "input": "JavaScript", "output": "function ()\r\n    {\r\n        var xhr = null;\r\n        if (window.XMLHttpRequest) {\r\n            xhr = new XMLHttpRequest();\r\n            if (xhr.overrideMimeType) {\r\n                xhr.overrideMimeType(\"text/xml; charset=utf-8\");\r\n            }\r\n        } else if (window.ActiveXObject) {\r\n            xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\r\n        }\r\n\r\n        // use Function.bind() to prepend ourselves as an argument\r\n        xhr.onreadystatechange = this.func.bind(null, this);\r\n\r\n        return xhr;\r\n    }"}, {"instruction": "get returns the value of the given key. If that value is undefined, it returns optionalDefaultValue instead.", "input": "JavaScript", "output": "function(key, optionalDefaultValue) {\n\t\tvar data = this.storage.read(this._namespacePrefix + key)\n\t\treturn this._deserialize(data, optionalDefaultValue)\n\t}"}, {"instruction": "COUNTUP AND CODE VISUALIZER", "input": "JavaScript", "output": "function createCountUp() {\n    establishOptionsFromInputs();\n    demo = new CountUp('myTargetElement', endVal, options);\n    if (!demo.error) {\n      errorSection.style.display = 'none';\n      if (input('useOnComplete').checked) {\n        demo.start(methodToCallOnComplete);\n      }\n      else {\n        demo.start();\n      }\n      updateCodeVisualizer();\n    }\n    else {\n      errorSection.style.display = 'block';\n      document.getElementById('error').innerHTML = demo.error;\n      console.error(demo.error);\n    }\n  }"}, {"instruction": "Remote Event: Go to the given source node", "input": "JavaScript", "output": "function _onRemoteEdit(event, res) {\n        // res = {nodeId, name, value}\n\n        // detach from DOM change events\n        if (res.value === \"0\") {\n            Inspector.DOM.off(\".EditAgent\");\n            return;\n        }\n\n        // find and store the edited node\n        var node = DOMAgent.nodeWithId(res.nodeId);\n        node = node.children[0];\n        if (!node.location) {\n            return;\n        }\n        _editedNode = node;\n\n        // attach to character data modified events\n        Inspector.DOM.on(\"characterDataModified.EditAgent\", _onCharacterDataModified);\n    }"}, {"instruction": "Test bind path to make sure it's working\n@param {string} bindPath\n@return {boolean}", "input": "JavaScript", "output": "function tryBindPath(serverless, bindPath, testFile) {\n  const options = [\n    'run',\n    '--rm',\n    '-v',\n    `${bindPath}:/test`,\n    'alpine',\n    'ls',\n    `/test/${testFile}`\n  ];\n  try {\n    const ps = dockerCommand(options);\n    if (process.env.SLS_DEBUG) {\n      serverless.cli.log(`Trying bindPath ${bindPath} (${options})`);\n      serverless.cli.log(ps.stdout.trim());\n    }\n    return ps.stdout.trim() === `/test/${testFile}`;\n  } catch (err) {\n    return false;\n  }\n}"}, {"instruction": "Default onTouchEnd handler.\n@param {jQuery.Event} oEvent  Event object", "input": "JavaScript", "output": "function (oEvent) {\n\t\t\tvar iPageY = oEvent.changedTouches && oEvent.changedTouches.length ? oEvent.changedTouches[0].pageY : oEvent.pageY;\n\n\t\t\tif (this._bIsDrag === false) {\n\t\t\t\tthis.fireTap(oEvent);\n\t\t\t\tthis._dragSession = null;\n\t\t\t}\n\n\t\t\tthis._bIsDrag = true;\n\n\t\t\tif (!this.getIsExpanded()) {\n\t\t\t\tthis._dragSession = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._endDrag(iPageY, oEvent.timeStamp);\n\n\t\t\tthis._mousedown = false;\n\t\t}"}, {"instruction": "---------------------------------------------------------------------------", "input": "JavaScript", "output": "function replaceInFile (filename, regex, replacement) {\n    let contents = fs.readFileSync (filename, 'utf8')\n    const parts = contents.split (regex)\n    const newContents = parts[0] + replacement + parts[1]\n    fs.truncateSync (filename)\n    fs.writeFileSync (filename, newContents)\n}"}, {"instruction": "Matches settings for currectly matching media breakpoint.\n\n@param {Object} points\n@returns {Object}", "input": "JavaScript", "output": "function match(points) {\n      if (typeof window.matchMedia !== 'undefined') {\n        for (var point in points) {\n          if (points.hasOwnProperty(point)) {\n            if (window.matchMedia('(max-width: ' + point + 'px)').matches) {\n              return points[point];\n            }\n          }\n        }\n      }\n\n      return defaults;\n    }"}, {"instruction": "measure the given text size in pixels\n@name measureText\n@memberOf me.BitmapText.prototype\n@function\n@param {String} [text]\n@param {me.Rect} [ret] a object in which to store the text metrics\n@returns {TextMetrics} a TextMetrics object with two properties: `width` and `height`, defining the output dimensions", "input": "JavaScript", "output": "function (text, ret) {\n            text = text || this._text;\n\n            var strings = (\"\" + text).split(\"\\n\");\n            var stringHeight = measureTextHeight(this);\n            var textMetrics  = ret || this.getBounds();\n\n            textMetrics.height = textMetrics.width = 0;\n\n            for (var i = 0; i < strings.length; i++) {\n                textMetrics.width = Math.max(measureTextWidth(this, strings[i]), textMetrics.width);\n                textMetrics.height += stringHeight;\n            }\n            return textMetrics;\n        }"}, {"instruction": "/* GLTFREGISTRY", "input": "JavaScript", "output": "function GLTFRegistry() {\n\n    var objects = {};\n\n    return    {\n\n        get: function ( key ) {\n\n            return objects[ key ];\n\n        },\n\n        add: function ( key, object ) {\n\n            objects[ key ] = object;\n\n        },\n\n        remove: function ( key ) {\n\n            delete objects[ key ];\n\n        },\n\n        removeAll: function () {\n\n            objects = {};\n\n        }\n\n    };\n\n}"}, {"instruction": "Handle when the DOM is ready", "input": "JavaScript", "output": "function() {\n\t\t// Make sure that the DOM is not already loaded\n\t\tif ( !jQuery.isReady ) {\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\n\t\t\t// If there are functions bound, to execute\n\t\t\tif ( jQuery.readyList ) {\n\t\t\t\t// Execute all of them\n\t\t\t\tjQuery.each( jQuery.readyList, function(){\n\t\t\t\t\tthis.call( document, jQuery );\n\t\t\t\t});\n\n\t\t\t\t// Reset the list of functions\n\t\t\t\tjQuery.readyList = null;\n\t\t\t}\n\n\t\t\t// Trigger any bound ready events\n\t\t\tjQuery(document).triggerHandler(\"ready\");\n\t\t}\n\t}"}, {"instruction": "/* extract the faces from an image for given face rectangles", "input": "JavaScript", "output": "function getFacesFromLocations(img, rects, faceSize = 150) {\n      const shapes = rects.map(rect => faceLandmarkPredictor.predict(img, rect))\n      return fr.extractImageChips(img, fr.getFaceChipDetails(shapes, faceSize))\n    }"}, {"instruction": "Undeclared grammar", "input": "JavaScript", "output": "function undeclaredGrammar(grammarName, namespace, interval) {\n  var message = namespace ?\n      'Grammar ' + grammarName + ' is not declared in namespace ' + Namespace.toString(namespace) :\n      'Undeclared grammar ' + grammarName;\n  return createError(message, interval);\n}"}, {"instruction": "This function is called in a $$postDigest to trigger all the onChanges hooks in a single digest", "input": "JavaScript", "output": "function flushOnChangesQueue() {\n      try {\n        if (!(--onChangesTtl)) {\n          // We have hit the TTL limit so reset everything\n          onChangesQueue = undefined;\n          throw $compileMinErr('infchng', '{0} $onChanges() iterations reached. Aborting!\\n', TTL);\n        }\n        // We must run this hook in an apply since the $$postDigest runs outside apply\n        $rootScope.$apply(function() {\n          for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) {\n            onChangesQueue[i]();\n          }\n          // Reset the queue to trigger a new schedule next time there is a change\n          onChangesQueue = undefined;\n        });\n      } finally {\n        onChangesTtl++;\n      }\n    }"}, {"instruction": "@description Formats API response into handlebars/theme format.\n\n@return {Object} containing page variables", "input": "JavaScript", "output": "function formatPageResponse(result) {\n    var response = {};\n\n    if (result.posts) {\n        response.posts = result.posts;\n    }\n\n    if (result.meta && result.meta.pagination) {\n        response.pagination = result.meta.pagination;\n    }\n\n    _.each(result.data, function (data, name) {\n        if (data.meta) {\n            // Move pagination to be a top level key\n            response[name] = data;\n            response[name].pagination = data.meta.pagination;\n            delete response[name].meta;\n        } else {\n            // This is a single object, don't wrap it in an array\n            response[name] = data[0];\n        }\n    });\n\n    return response;\n}"}, {"instruction": "{{{1 numeric encode", "input": "JavaScript", "output": "function encode_numeric(str) {\n    var len = str.length;\n    var bits = [];\n\n    for (var i = 0; i < len; i += 3) {\n        var s = str.substr(i, 3);\n        var b = Math.ceil(s.length * 10 / 3);\n        pushBits(bits, b, parseInt(s, 10));\n    }\n\n    var res = {};\n\n    var d = [0, 0, 0, 1];\n    pushBits(d, 14, len);\n    res.data27 = d.concat(bits);\n\n    if (len < 4096) {\n        var d = [0, 0, 0, 1];\n        pushBits(d, 12, len);\n        res.data10 = d.concat(bits);\n    }\n\n    if (len < 1024) {\n        var d = [0, 0, 0, 1];\n        pushBits(d, 10, len);\n        res.data1 = d.concat(bits);\n    }\n\n    return res;\n}"}, {"instruction": "Issues a request to cancel a statement.\n\n@param {Object} statementContext\n@param {Object} statement\n@param {Function} callback", "input": "JavaScript", "output": "function sendCancelStatement(statementContext, statement, callback)\n{\n  var url;\n  var json;\n\n  // use different rest endpoints based on whether the statement id is available\n  if (statementContext.statementId)\n  {\n    url = '/queries/' + statementContext.statementId + '/abort-request';\n  }\n  else\n  {\n    url  = '/queries/v1/abort-request';\n    json =\n    {\n      requestId: statementContext.requestId\n    };\n  }\n\n  // issue a request to cancel the statement\n  statementContext.services.sf.request(\n  {\n    method   : 'POST',\n    url      : url,\n    json     : json,\n    callback : function(err)\n    {\n      // if a callback was specified, invoke it\n      if (Util.isFunction(callback))\n      {\n        callback(Errors.externalize(err), statement);\n      }\n    }\n  });\n}"}, {"instruction": "Checks for an active Internet connection by doing a DNS lookup of Microsoft.com.\n\n@return {Promise.<boolean>} - True if lookup succeeded (or if we skip the test)", "input": "JavaScript", "output": "function checkInternetConnection () {\n  return new Promise((resolve) => {\n    require('dns').lookup('microsoft.com', (err) => {\n      if (err && err.code === 'ENOTFOUND') {\n        resolve(false)\n      } else {\n        resolve(true)\n      }\n    })\n  })\n}"}, {"instruction": "Search for abbreviation in editor from current caret position\n@param {IEmmetEditor} editor Editor instance\n@return {String}", "input": "JavaScript", "output": "function findAbbreviation(editor) {\n\t\tvar r = range(editor.getSelectionRange());\n\t\tvar content = String(editor.getContent());\n\t\tif (r.length()) {\n\t\t\t// abbreviation is selected by user\n\t\t\treturn r.substring(content);\n\t\t}\n\t\t\n\t\t// search for new abbreviation from current caret position\n\t\tvar curLine = editor.getCurrentLineRange();\n\t\treturn actionUtils.extractAbbreviation(content.substring(curLine.start, r.start));\n\t}"}, {"instruction": "Sum the width of all tabs.\n\n@param elements\n@returns {number}", "input": "JavaScript", "output": "function getTotalTabsWidth(elements) {\n    var sum = 0, i, tab;\n\n    for (i = 0; i < elements.tabs.length; i++) {\n      tab = elements.tabs[i];\n      sum += tab.offsetWidth;\n    }\n\n    return sum;\n  }"}, {"instruction": "PTR records with a TTL of 0 is considered a \"goodbye\" announcement. I.e. a DNS response broadcasted when a service shuts down in order to let the network know that the service is no longer going to be available.  For more info see: https://tools.ietf.org/html/rfc6762#section-8.4  This function returns an array of all resource records considered a goodbye record", "input": "JavaScript", "output": "function goodbyes (name, packet) {\n  return packet.answers.concat(packet.additionals)\n    .filter(function (rr) {\n      return rr.type === 'PTR' && rr.ttl === 0 && dnsEqual(rr.name, name)\n    })\n    .map(function (rr) {\n      return rr.data\n    })\n}"}, {"instruction": "Execute the down function of currently executed seeds.", "input": "JavaScript", "output": "function (specification, scope, callback) {\n    var executeUndoSeed = load('undo-seed');\n    if (arguments.length > 0) {\n      if (typeof specification === 'number') {\n        this.internals.argv.count = specification;\n\n        if (scope) {\n          this.internals.migrationMode = scope;\n          this.internals.matching = scope;\n        }\n      } else if (typeof specification === 'string') {\n        this.internals.migrationMode = scope;\n        this.internals.matching = scope;\n      }\n    }\n\n    return Promise.fromCallback(\n      function (callback) {\n        executeUndoSeed(this.internals, this.config, callback);\n      }.bind(this)\n    ).asCallback(callback);\n  }"}, {"instruction": "Get a call object built with the provided options.\n@param {grpc.Channel} channel\n@param {string} path\n@param {grpc.Client~CallOptions=} options Options object.", "input": "JavaScript", "output": "function getCall(channel, path, options) {\n  var deadline;\n  var host;\n  var parent;\n  var propagate_flags;\n  var credentials;\n  if (options) {\n    deadline = options.deadline;\n    host = options.host;\n    parent = options.parent ? options.parent.call : undefined;\n    propagate_flags = options.propagate_flags;\n    credentials = options.credentials;\n  }\n  if (deadline === undefined) {\n    deadline = Infinity;\n  }\n  var call = channel.createCall(path, deadline, host,\n                                parent, propagate_flags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}"}, {"instruction": "@class StaticAsset\n@implements Asset\n@classdesc\n\nAn immutable {@link Asset} compatible with {@link WebGlStage} and\n{@link CssStage}.\n\n@param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} element The\nunderlying pixel source.\n@throws If the pixel source is unsupported.", "input": "JavaScript", "output": "function StaticAsset(element) {\n  var supported = false;\n  for (var type in propertyMap) {\n    if (global[type] && element instanceof global[type]) {\n      supported = true;\n      this._widthProp = propertyMap[type][0];\n      this._heightProp = propertyMap[type][1];\n      break;\n    }\n  }\n  if (!supported) {\n    throw new Error('Unsupported pixel source');\n  }\n\n  this._element = element;\n}"}, {"instruction": "Sends a command to node to cause a restart.", "input": "JavaScript", "output": "function restartNode() {\n        try {\n            _nodeConnection.domains.base.restartNode();\n        } catch (e) {\n            window.alert(\"Failed trying to restart Node: \" + e.message);\n        }\n    }"}, {"instruction": "Creates a mongoDB object representation of this object.\n\n<pre><code>\n{\n'_id' : , // {number} id for this file\n'filename' : , // {string} name for this file\n'contentType' : , // {string} mime type for this file\n'length' : , // {number} size of this file?\n'chunksize' : , // {number} chunk size used by this file\n'uploadDate' : , // {Date}\n'aliases' : , // {array of string}\n'metadata' : , // {string}\n}\n</code></pre>\n\n@ignore", "input": "JavaScript", "output": "function(self, callback) {\n  // Calcuate the length\n  var mongoObject = {\n    _id: self.fileId,\n    filename: self.filename,\n    contentType: self.contentType,\n    length: self.position ? self.position : 0,\n    chunkSize: self.chunkSize,\n    uploadDate: self.uploadDate,\n    aliases: self.aliases,\n    metadata: self.metadata\n  };\n\n  var md5Command = { filemd5: self.fileId, root: self.root };\n  self.db.command(md5Command, function(err, results) {\n    if (err) return callback(err);\n\n    mongoObject.md5 = results.md5;\n    callback(null, mongoObject);\n  });\n}"}, {"instruction": "get a list of pointers\n@returns {Array}     touchlist", "input": "JavaScript", "output": "function() {\n      var self = this;\n      var touchlist = [];\n\n      // we can use forEach since pointerEvents only is in IE10\n      Object.keys(self.pointers).sort().forEach(function(id) {\n        touchlist.push(self.pointers[id]);\n      });\n      return touchlist;\n    }"}, {"instruction": "Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.", "input": "JavaScript", "output": "function GetSlope(aT, aA1, aA2) {\n\t\t\treturn 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n\t\t}"}, {"instruction": "Undo elements to its previous state\n@type {Function}", "input": "JavaScript", "output": "function () {\n      if (!els.length) return\n      els.map(function (el) {\n        el.parentElement.removeChild(el)\n      })\n      els = []\n    }"}, {"instruction": "Creates a type derived from {@link CatalogMember} based on a given URL.\n\n@param {String} url The derived type name.\n@param {Terria} terria The Terria instance.\n@param {Boolean} allowLoad Whether it's ok to attempt to load the URL and detect failures. We generally do this for WMS type services, but not for local files.\n@returns {CatalogMember} The constructed data item or promise, or undefined if the URL is not supported.", "input": "JavaScript", "output": "function(url, terria, allowLoad, index) {\n  index = index || 0;\n  if (index >= mapping.length) {\n    return undefined;\n  }\n  if (\n    (mapping[index].matcher && !mapping[index].matcher(url)) ||\n    (mapping[index].requiresLoad && !allowLoad)\n  ) {\n    return createCatalogItemFromUrl(url, terria, allowLoad, index + 1);\n  } else {\n    var item = new mapping[index].constructor(terria);\n    if (!allowLoad) {\n      return item;\n    }\n    item.url = url;\n    item.name = url;\n    return item\n      .load()\n      .yield(item)\n      .otherwise(function(e) {\n        console.log(e);\n        return createCatalogItemFromUrl(url, terria, allowLoad, index + 1);\n      });\n  }\n}"}, {"instruction": "terminate process, err (if defined) is from seneca.close", "input": "JavaScript", "output": "function(close_err) {\n            if (!undead) {\n              process.nextTick(function() {\n                if (close_err) {\n                  instance.log.fatal({\n                    kind: 'close',\n                    err: Util.inspect(close_err)\n                  })\n                }\n\n                if (test) {\n                  if (close_err) {\n                    Print.err(close_err)\n                  }\n\n                  Print.err(stderrmsg)\n                  Print.err(\n                    '\\nSENECA TERMINATED at ' +\n                      new Date().toISOString() +\n                      '. See above for error report.\\n'\n                  )\n                }\n\n                so.system.exit(1)\n              })\n            }\n          }"}, {"instruction": "Creates a local instance of an alert group.\n\n@param {Object} props The properties for the alert group.\n@return {splunkjs.Service.FiredAlertGroup} A new `splunkjs.Service.FiredAlertGroup` instance.\n\n@method splunkjs.Service.FiredAlertGroupCollection", "input": "JavaScript", "output": "function(props) {\n            var entityNamespace = utils.namespaceFromProperties(props);\n            return new root.FiredAlertGroup(this.service, props.name, entityNamespace);\n        }"}, {"instruction": "Track textures used by material components, so that they can be safely\ndisposed when no longer in use. Textures must be registered here, and not\nthrough registerMaterial(), because textures may not be attached at the\ntime the material is registered.\n\n@param {Event} e", "input": "JavaScript", "output": "function (e) {\n    if (!this.textureCounts[e.detail.texture.uuid]) {\n      this.textureCounts[e.detail.texture.uuid] = 0;\n    }\n    this.textureCounts[e.detail.texture.uuid]++;\n  }"}, {"instruction": "/* jshint ignore:start \nInitialize the V1 version of Pricing\n\n@constructor Twilio.Pricing.V1\n\n@property {Twilio.Pricing.V1.MessagingList} messaging - messaging resource\n@property {Twilio.Pricing.V1.PhoneNumberList} phoneNumbers -\nphoneNumbers resource\n@property {Twilio.Pricing.V1.VoiceList} voice - voice resource\n\n@param {Twilio.Pricing} domain - The twilio domain\n /* jshint ignore:end", "input": "JavaScript", "output": "function V1(domain) {\n  Version.prototype.constructor.call(this, domain, 'v1');\n\n  // Resources\n  this._messaging = undefined;\n  this._phoneNumbers = undefined;\n  this._voice = undefined;\n}"}, {"instruction": "We create a Comment node for CSS comments `/* */`, but keep the LeSS comments `//` silent, by just skipping over them.", "input": "JavaScript", "output": "function () {\n                var comment;\n\n                if (input.charAt(i) !== '/') { return; }\n\n                if (input.charAt(i + 1) === '/') {\n                    return new(tree.Comment)($re(/^\\/\\/.*/), true, i, env.currentFileInfo);\n                }\n                comment = $re(/^\\/\\*(?:[^*]|\\*+[^\\/*])*\\*+\\/\\n?/);\n                if (comment) {\n                    return new(tree.Comment)(comment, false, i, env.currentFileInfo);\n                }\n            }"}, {"instruction": "# prop :: String -> a -> b . . Takes a property name and an object with known properties and returns . the value of the specified property. If for some reason the object . lacks the specified property, a type error is thrown. . . For accessing properties of uncertain objects, use [`get`](#get) instead. . For accessing string map values by key, use [`value`](#value) instead. . . ```javascript . > S.prop ('a') ({a: 1, b: 2}) . 1 . ```", "input": "JavaScript", "output": "function prop(key) {\n    return function(x) {\n      var obj = toObject (x);\n      if (key in obj) return obj[key];\n      throw new TypeError ('\u2018prop\u2019 expected object to have a property named ' +\n                           '\u2018' + key + '\u2019; ' + show (x) + ' does not');\n    };\n  }"}, {"instruction": "Add a column split on a string or number valued field, producing a column for\neach distinct value of the field.\n\n@param {String} fieldName The name of field to split on.\n@return {splunkjs.Service.PivotSpecification} The updated pivot specification.\n\n@method splunkjs.Service.PivotSpecification", "input": "JavaScript", "output": "function(fieldName) {\n            if (!this.dataModelObject.hasField(fieldName)) {\n                throw new Error(\"Did not find field \" + fieldName);\n            }\n            var f = this.dataModelObject.fieldByName(fieldName);\n            if (!utils.contains([\"number\", \"string\"], f.type)) {\n                throw new Error(\"Field was of type \" + f.type + \", expected number or string.\");\n            }\n\n            var col = {\n                fieldName: fieldName,\n                owner: f.owner,\n                type: f.type\n            };\n\n            if (\"number\" === f.type) {\n                col.display = \"all\";\n            }\n\n            this.columns.push(col);\n\n            return this;\n        }"}, {"instruction": "Test screen rotation", "input": "JavaScript", "output": "function rotateScreen(r) {\n    lcd.setRotation(r);\n    lcd.fillRect(0, 0, 5, 5, ili9341.ILI9341_WHITE);\n    if (r < 4) {\n        r++;\n        setTimeout(function() { rotateScreen(r); }, 1000);\n    }\n}"}, {"instruction": "/* =========================================================== /* lifecycle methods /* =========================================================== \nCalled when the controller is instantiated.\n@public", "input": "JavaScript", "output": "function () {\n\t\t\tBaseController.prototype.onInit.call(this);\n\n\t\t\t// manually call the handler once at startup as device API won't do this for us\n\t\t\tthis._onOrientationChange({\n\t\t\t\tlandscape: Device.orientation.landscape\n\t\t\t});\n\n\t\t\tthis.getRouter().getRoute(\"tools\").attachPatternMatched(this._onMatched, this);\n\t\t}"}, {"instruction": "Adds an InfoWindow to the map\n@param infoWindowOptions:google.maps.InfoWindowOptions (optional)\n@param callback:function(InfoWindow:google.maps.InfoWindowOptions) (optional)\n@return $(google.maps.InfoWindowOptions)\n@see http://code.google.com/intl/sv-SE/apis/maps/documentation/javascript/reference.html#InfoWindowOptions", "input": "JavaScript", "output": "function(a, b) {\n            var c = new google.maps.InfoWindow(a);\n            this._call(b, c);\n            return $(c);\n        }"}, {"instruction": "Converts a SAT.Polygon into a SVG path string.", "input": "JavaScript", "output": "function poly2path(polygon) {\n  var pos = polygon.pos;\n  var points = polygon.calcPoints;\n  var result = 'M' + pos.x + ' ' + pos.y;\n  result += 'M' + (pos.x + points[0].x) + ' ' + (pos.y + points[0].y);\n  for (var i = 1; i < points.length; i++) {\n    var point = points[i];\n    result += 'L' + (pos.x + point.x) + ' ' + (pos.y + point.y);\n  }\n  result += 'Z';\n  return result;\n}"}, {"instruction": "Removes project from shared projects.\nAlso removes all references from the other table.", "input": "JavaScript", "output": "function removeProject(project) {\n\t\treturn sharedProject.findOne({'location': project}).exec()\n\t\t.then(function(doc) {\n\t\t\tif (doc.users.length > 0) {\n\t\t\t\treturn userProjectsCollection.removeProjectReferences(doc.users, project).exec();\n\t\t\t}\n\t\t})\n\t\t.then(function() {\n\t\t\treturn sharedProject.remove({location: project}).exec();\n\t\t});\n\t}"}, {"instruction": "Given a simple array of css color strings, eg. [\"red\", \"orange\", \"black\"],\nreturn an evenly spaced array suitable to instantiate a color map.\n@private\n@param  {String[]} simpleArray A simple array of css color strings, eg. [\"red\", \"orange\", \"black\"].\n@return {Object[]} An array of {color, offset} objects.", "input": "JavaScript", "output": "function simpleArrayToArray(simpleArray) {\n  return simpleArray\n    .map(function(el, index) {\n      return {\n        color: el,\n        offset: simpleArray.length === 1 ? 0 : index / (simpleArray.length - 1)\n      };\n    })\n    .filter(function(o) {\n      return o.color !== \"\";\n    });\n}"}, {"instruction": "Seeds either the static or version controlled seeders, controlled by\nthe passed mode.", "input": "JavaScript", "output": "function (mode, scope, callback) {\n    var executeSeed = load('seed');\n    if (scope) {\n      this.internals.migrationMode = scope;\n      this.internals.matching = scope;\n    }\n\n    this.internals.mode = mode || 'vc';\n    return Promise.fromCallback(\n      function (callback) {\n        executeSeed(this.internals, this.config, callback);\n      }.bind(this)\n    ).asCallback(callback);\n  }"}, {"instruction": "readable event readable - some data is now available event data - switch to flowing mode - feeds chunks to handler event end - no more data event close - optional, indicates upstream close event error - duh", "input": "JavaScript", "output": "function(size) {\n    var buffers;\n    // read min(buffer, size || infinity)\n    if (size) {\n      buffers = [];\n      while (size && this.buffers.length && !this.buffers[0].eod) {\n        var first = this.buffers[0];\n        var buffer = first.read(size);\n        size -= buffer.length;\n        buffers.push(buffer);\n        if (first.eod && first.full) {\n          this.buffers.shift();\n        }\n      }\n      return Buffer.concat(buffers);\n    }\n\n    buffers = this.buffers.map(buf => buf.toBuffer())\n      .filter(Boolean);\n    this.buffers = [];\n    return Buffer.concat(buffers);\n  }"}, {"instruction": "/*\tEvents\n==================================================", "input": "JavaScript", "output": "function(e) {\n\t\tthis.youtube_loaded = true;\n\t\tthis._el.content_item = document.getElementById(this._el.content_item.id);\n\t\tthis.onMediaLoaded();\n\n\t}"}, {"instruction": "Like _getNextNode, but for DOM implementations with no\nfirstElementChild/nextElementSibling functionality...", "input": "JavaScript", "output": "function(node, ignoreSelfAndKids) {\n    function nextSiblingEl(n) {\n      do {\n        n = n.nextSibling;\n      } while (n && n.nodeType !== n.ELEMENT_NODE);\n      return n;\n    }\n    // First check for kids if those aren't being ignored\n    if (!ignoreSelfAndKids && node.children[0]) {\n      return node.children[0];\n    }\n    // Then for siblings...\n    var next = nextSiblingEl(node);\n    if (next) {\n      return next;\n    }\n    // And finally, move up the parent chain *and* find a sibling\n    // (because this is depth-first traversal, we will have already\n    // seen the parent nodes themselves).\n    do {\n      node = node.parentNode;\n      if (node)\n        next = nextSiblingEl(node);\n    } while (node && !next);\n    return node && next;\n  }"}, {"instruction": "Fetch the model from the server. If the server's representation of the\nmodel differs from its current attributes, they will be overriden,\ntriggering a <code>\"change\"</code> event.\n@param {Object} fetchOptions Optional options to set 'keys',\n'include' and 'includeACL' option.\n@param {AuthOptions} options\n@return {Promise} A promise that is fulfilled when the fetch\ncompletes.", "input": "JavaScript", "output": "function(fetchOptions = {}, options) {\n        var self = this;\n        var request = _request(\n          'classes',\n          this.className,\n          this.id,\n          'GET',\n          transformFetchOptions(fetchOptions),\n          options\n        );\n        return request.then(function(response) {\n          const fetchedAttrs = self.parse(response);\n          if (!fetchOptions.keys) self._cleanupUnsetKeys(fetchedAttrs);\n          self._finishFetch(fetchedAttrs, true);\n          return self;\n        });\n      }"}, {"instruction": "A BufferGeometry where a 'prefab' geometry is repeated a number of times.\n\n@param {Geometry|BufferGeometry} prefab The Geometry instance to repeat.\n@param {Number} count The number of times to repeat the geometry.\n@constructor", "input": "JavaScript", "output": "function PrefabBufferGeometry(prefab, count) {\n  three.BufferGeometry.call(this);\n\n  /**\n   * A reference to the prefab geometry used to create this instance.\n   * @type {Geometry|BufferGeometry}\n   */\n  this.prefabGeometry = prefab;\n  this.isPrefabBufferGeometry = prefab.isBufferGeometry;\n\n  /**\n   * Number of prefabs.\n   * @type {Number}\n   */\n  this.prefabCount = count;\n\n  /**\n   * Number of vertices of the prefab.\n   * @type {Number}\n   */\n  if (this.isPrefabBufferGeometry) {\n    this.prefabVertexCount = prefab.attributes.position.count;\n  } else {\n    this.prefabVertexCount = prefab.vertices.length;\n  }\n\n  this.bufferIndices();\n  this.bufferPositions();\n}"}, {"instruction": "------------------------------ GOOGLE MAP /*\ncustom map with google api\ncheck out the link below for more information about api usage\nhttps://developers.google.com/maps/documentation/javascript/examples/marker-simple", "input": "JavaScript", "output": "function initializeMap() {\r\n\t\t\tif($('.map').length) {\r\n\t\t\t\tvar mapCanvas = $('#map-canvas');\r\n\t\t\t\tvar myLatlng = new google.maps.LatLng(mapCanvas.data(\"latitude\"),mapCanvas.data(\"longitude\"));\r\n\t\t\t\tvar mapOptions = {\r\n\t\t\t\t\tzoom: mapCanvas.data(\"zoom\"),\r\n\t\t\t\t\tcenter: myLatlng\r\n\t\t\t\t}\r\n\t\t\t\tvar map = new google.maps.Map(document.getElementById('map-canvas'), mapOptions);\r\n\t\t\t\t\r\n\t\t\t\tvar marker = new google.maps.Marker({\r\n\t\t\t\t  position: myLatlng,\r\n\t\t\t\t  map: map\r\n\t\t  \t});\r\n\t\t\t}\r\n\t\t  \r\n\t\t}"}, {"instruction": "ensure that control and library are loaded", "input": "JavaScript", "output": "function getObjectFallback(oClassObject) {\n\t\t\t\t// some modules might not return a class definition, so we fallback to the global\n\t\t\t\t// this is against the AMD definition, but is required for backward compatibility\n\t\t\t\tif (!oClassObject) {\n\t\t\t\t\tLog.error(\"Control '\" + sClassName + \"' did not return a class definition from sap.ui.define.\", \"\", \"XMLTemplateProcessor\");\n\t\t\t\t\toClassObject = ObjectPath.get(sClassName);\n\t\t\t\t}\n\t\t\t\tif (!oClassObject) {\n\t\t\t\t\tLog.error(\"Can't find object class '\" + sClassName + \"' for XML-view\", \"\", \"XMLTemplateProcessor\");\n\t\t\t\t}\n\t\t\t\treturn oClassObject;\n\t\t\t}"}, {"instruction": "Checks a given node against matching selectors and returns\nselector index (or 0 if none matched).\n\nThis function takes into account the ngProjectAs attribute: if present its value will be compared\nto the raw (un-parsed) CSS selector instead of using standard selector matching logic.", "input": "JavaScript", "output": "function matchingSelectorIndex(tNode, selectors, textSelectors) {\n    var ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n    for (var i = 0; i < selectors.length; i++) {\n        // if a node has the ngProjectAs attribute match it against unparsed selector\n        // match a node against a parsed selector only if ngProjectAs attribute is not present\n        if (ngProjectAsAttrVal === textSelectors[i] ||\n            ngProjectAsAttrVal === null && isNodeMatchingSelectorList(tNode, selectors[i])) {\n            return i + 1; // first matching selector \"captures\" a given node\n        }\n    }\n    return 0;\n}"}, {"instruction": "The base implementation of `assignValue` and `assignMergeValue` without\nvalue checks.\n\n@private\n@param {Object} object The object to modify.\n@param {string} key The key of the property to assign.\n@param {*} value The value to assign.", "input": "JavaScript", "output": "function baseAssignValue(object, key, value) {\n  if (key == '__proto__') {\n    Object.defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    })\n  } else {\n    object[key] = value\n  }\n}"}, {"instruction": "This method is like `_.set` except that accepts `updater` to produce the\nvalue to set. Use `_.updateWith` to customize `path` creation. The `updater`\nis invoked with one argument: (value).\n\n**Note:** This method mutates `object`.\n\n@static\n@memberOf _\n@since 4.6.0\n@category Object\n@param {Object} object The object to modify.\n@param {Array|string} path The path of the property to set.\n@param {Function} updater The function to produce the updated value.\n@returns {Object} Returns `object`.\n@example\n\nvar object = { 'a': [{ 'b': { 'c': 3 } }] };\n\n_.update(object, 'a[0].b.c', function(n) { return n * n; });\nconsole.log(object.a[0].b.c);\n// => 9\n\n_.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\nconsole.log(object.x[0].y.z);\n// => 0", "input": "JavaScript", "output": "function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }"}, {"instruction": "Gathers angular-wrapped versions of each element\n@param elements\n@returns {{}}", "input": "JavaScript", "output": "function getAngularElements (elements) {\n    var obj = {};\n    for (var key in elements) {\n      if (elements.hasOwnProperty(key)) obj[ key ] = angular.element(elements[ key ]);\n    }\n    return obj;\n  }"}, {"instruction": "When using multiple axes, adjust the number of ticks to match the highest\nnumber of ticks in that group", "input": "JavaScript", "output": "function adjustTickAmount() {\r\n\r\n\t\t\tif (maxTicks && !isDatetimeAxis && !categories && !isLinked) { // only apply to linear scale\r\n\t\t\t\tvar oldTickAmount = tickAmount,\r\n\t\t\t\t\tcalculatedTickAmount = tickPositions.length;\r\n\r\n\t\t\t\t// set the axis-level tickAmount to use below\r\n\t\t\t\ttickAmount = maxTicks[xOrY];\r\n\r\n\t\t\t\tif (calculatedTickAmount < tickAmount) {\r\n\t\t\t\t\twhile (tickPositions.length < tickAmount) {\r\n\t\t\t\t\t\ttickPositions.push(correctFloat(\r\n\t\t\t\t\t\t\ttickPositions[tickPositions.length - 1] + tickInterval\r\n\t\t\t\t\t\t));\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttransA *= (calculatedTickAmount - 1) / (tickAmount - 1);\r\n\t\t\t\t\tmax = tickPositions[tickPositions.length - 1];\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif (defined(oldTickAmount) && tickAmount !== oldTickAmount) {\r\n\t\t\t\t\taxis.isDirty = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}"}, {"instruction": "Convert real value to percent\n\n@param value {Number} X in real\n@param no_min {boolean=} don't use min value\n@returns {Number} X in percent", "input": "JavaScript", "output": "function (value, no_min) {\n            var diapason = this.options.max - this.options.min,\n                one_percent = diapason / 100,\n                val, percent;\n\n            if (!diapason) {\n                this.no_diapason = true;\n                return 0;\n            }\n\n            if (no_min) {\n                val = value;\n            } else {\n                val = value - this.options.min;\n            }\n\n            percent = val / one_percent;\n\n            return this.toFixed(percent);\n        }"}, {"instruction": "/*\nThis function calculates the absolute 'left' value for a html node", "input": "JavaScript", "output": "function calculateOffsetLeft(obj)\n{\n\tvar curleft = 0;\n\tif (obj.offsetParent) {\n\t\tcurleft = obj.offsetLeft\n\t\twhile (obj = obj.offsetParent) \n\t\t\tcurleft += obj.offsetLeft;\n\t} else if (obj.x)\n\t\tcurleft += obj.x;\n\treturn curleft;\n}"}, {"instruction": "Transforms the searchable templates by removing the `searchable` prefix.\n\nThis makes them usable in the `SearchBox` component.\n\n@param {object} templates The widget templates\n@returns {object} the formatted templates", "input": "JavaScript", "output": "function transformTemplates(templates) {\n  const allTemplates = {\n    ...templates,\n    submit: templates.searchableSubmit,\n    reset: templates.searchableReset,\n    loadingIndicator: templates.searchableLoadingIndicator,\n  };\n\n  const {\n    searchableReset,\n    searchableSubmit,\n    searchableLoadingIndicator,\n    ...transformedTemplates\n  } = allTemplates;\n\n  return transformedTemplates;\n}"}, {"instruction": "Mini-implementation of stream.PassThrough We are far from having need for the full implementation, and we can make assumptions like \"many writes, then only one final read\" and we can ignore encoding specifics", "input": "JavaScript", "output": "function PassThrough() {\n  return {\n    buf: '',\n\n    write: function(b) {\n      this.buf += b;\n    },\n\n    end: function(b) {\n      this.buf += b;\n    },\n\n    read: function() {\n      return this.buf;\n    }\n  };\n}"}, {"instruction": "Print the names and majors of students in a sample spreadsheet:\nhttps://docs.google.com/spreadsheets/d/1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms/edit", "input": "JavaScript", "output": "function listMajors(auth) {\n  const sheets = google.sheets('v4');\n  sheets.spreadsheets.values.get(\n    {\n      auth: auth,\n      spreadsheetId: '1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms',\n      range: 'Class Data!A2:E',\n    },\n    (err, res) => {\n      if (err) {\n        console.error('The API returned an error.');\n        throw err;\n      }\n      const rows = res.data.values;\n      if (rows.length === 0) {\n        console.log('No data found.');\n      } else {\n        console.log('Name, Major:');\n        for (const row of rows) {\n          // Print columns A and E, which correspond to indices 0 and 4.\n          console.log(`${row[0]}, ${row[4]}`);\n        }\n      }\n    }\n  );\n}"}, {"instruction": "The relative require() itself.", "input": "JavaScript", "output": "function localRequire(path) {\n    var resolved = localRequire.resolve(path);\n    return require(resolved, parent, path);\n  }"}, {"instruction": "-----------------------------------------------------------------------------", "input": "JavaScript", "output": "function getIdlType(type) {\n    var result\n\n\n    if (-1 == NativeTypes.indexOf(type.name)) {\n        result = \"<a href='javascript:showInterface(\\\"\" + type.name + \"\\\"); void(0);'>\" + type.name + \"</a>\"\n    }\n    else {\n        result = type.name\n    }\n\n    for (var i=0; i<type.rank; i++) {\n        result += \"[]\"\n    }\n\n    return \"<span class='type'>\" + result + \"</span>\"\n}"}, {"instruction": "convert a Backbone model to JSON", "input": "JavaScript", "output": "function serialize(model) {\n    var data = model.toJSON();\n    Object.keys(data).forEach(function serializeRecur(key) {\n        var value = data[key];\n        // if any value can be serialized toJSON() then do it\n        if (value && value.toJSON) {\n            data[key] = data[key].toJSON();\n        }\n    });\n    return data;\n}"}, {"instruction": "We set our dependencies as externals on our app bundler when developing (isDevelopment ? dependencies : []).forEach(function (dep) { appBundler.external(dep); }); The rebundle process", "input": "JavaScript", "output": "function () {\n\t\tvar start = Date.now();\n\t\tgutil.log('Building APP bundle');\n\t\tappBundler.bundle()\n\t\t\t.on('error', gutil.log)\n\t\t\t.pipe(source('main.js'))\n\t\t\t.pipe(gulpif(!isDevelopment, streamify(uglify())))\n\t\t\t.pipe(gulp.dest(configs.folders[options.environment]))\n\t\t\t.pipe(notify(function () {\n\t\t\t\tgutil.log('APP bundle built in ' + (Date.now() - start) + 'ms');\n\t\t\t}))\n\t\t\t.pipe(connect.reload());\n\t}"}, {"instruction": "Creates an object with the agregations bindings of a UI5 control.\n@param {Object} control\n@returns {Object}\n@private", "input": "JavaScript", "output": "function (control) {\n\t\t\t\tvar aggregations = control.getMetadata().getAllAggregations();\n\t\t\t\tvar aggregationsBindingData = Object.create(null);\n\n\t\t\t\tfor (var key in aggregations) {\n\t\t\t\t\tif (aggregations.hasOwnProperty(key) && control.getBinding(key)) {\n\t\t\t\t\t\taggregationsBindingData[key] = Object.create(null);\n\t\t\t\t\t\taggregationsBindingData[key].model = this._getModelFromContext(control, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn aggregationsBindingData;\n\t\t\t}"}, {"instruction": "`URLSearchParams.prototype.forEach` method", "input": "JavaScript", "output": "function forEach(callback /* , thisArg */) {\n    var entries = getInternalParamsState(this).entries;\n    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);\n    var i = 0;\n    var entry;\n    while (i < entries.length) {\n      entry = entries[i++];\n      boundFunction(entry.value, entry.key, this);\n    }\n  }"}, {"instruction": "Pick the object\n@param  {number} x Mouse position x\n@param  {number} y Mouse position y\n@return {clay.Node}", "input": "JavaScript", "output": "function(x, y) {\n        var renderer = this.renderer;\n\n        var ratio = this.downSampleRatio;\n        x = Math.ceil(ratio * x);\n        y = Math.ceil(ratio * (this.height - y));\n\n        this._frameBuffer.bind(renderer);\n        var pixel = new Uint8Array(4);\n        var _gl = renderer.gl;\n        // TODO out of bounds ?\n        // preserveDrawingBuffer ?\n        _gl.readPixels(x, y, 1, 1, _gl.RGBA, _gl.UNSIGNED_BYTE, pixel);\n        this._frameBuffer.unbind(renderer);\n        // Skip interpolated pixel because of anti alias\n        if (pixel[3] === 255) {\n            var id = unpackID(pixel[0], pixel[1], pixel[2]);\n            if (id) {\n                var el = this._lookupTable[id - this.lookupOffset];\n                return el;\n            }\n        }\n    }"}, {"instruction": "Extend properties to target if not exist.\n@param  {Object} target\n@param  {Object} source\n@return {Object}\n@memberOf clay.core.util", "input": "JavaScript", "output": "function (target, source) {\n        if (source) {\n            for (var propName in source) {\n                if (target[propName] === undefined) {\n                    target[propName] = source[propName];\n                }\n            }\n        }\n        return target;\n    }"}, {"instruction": "not save if out of bounds", "input": "JavaScript", "output": "function (start, end) {\n    var total = 0;\n\n    start = start || 0;\n    end = end || this.binCount;\n\n    for (var i = start; i < end; i++) {\n      total += this.frequencyByteData[i];\n    }\n\n    return total / (end - start);\n  }"}, {"instruction": "Get Custom Fingerprint.  Take a string of datapoints and eturn a 32-bit integer representing the browsers fingerprint.", "input": "JavaScript", "output": "function() {\n      var bar = '|';\n      var key = \"\";\n      for (var i = 0; i < arguments.length; i++) {\n        key += arguments[i] + bar;\n      }\n      return murmurhash3_32_gc(key, 256);\n    }"}, {"instruction": "Modified Richards and Whitby-Stevens precedence climbing method.", "input": "JavaScript", "output": "function makeTree(left, ops, rights, minPrecedence = 0) {\n  while (ops.length > 0 && precedence[ops[0]] >= minPrecedence) {\n    let op = ops.shift();\n    let right = rights.shift();\n    while (ops.length > 0 && (precedence[ops[0]] > precedence[op] ||\n        associativity[ops[0]] === 'R' && precedence[ops[0]] === precedence[op])) {\n      right = makeTree(right, ops, rights, precedence[ops[0]]);\n    }\n    left = new BinaryExpression(left, op, right);\n  }\n  return left;\n}"}, {"instruction": "Pick the next auth stage\n\n@private\n@return {string?} login type\n@throws {NoAuthFlowFoundError} If no suitable authentication flow can be found", "input": "JavaScript", "output": "function() {\n        const flow = this._chooseFlow();\n        console.log(\"Active flow => %s\", JSON.stringify(flow));\n        const nextStage = this._firstUncompletedStage(flow);\n        console.log(\"Next stage: %s\", nextStage);\n        return nextStage;\n    }"}, {"instruction": "/* Given a comma-separated string of layer names, returns the layer objects corresponding to them.", "input": "JavaScript", "output": "function findLayers(layers, names) {\n  if (!defined(names)) {\n    // If a list of layers is not specified, we're using all layers.\n    return layers;\n  }\n  return names.split(\",\").map(function(id) {\n    return findLayer(layers, id);\n  });\n}"}, {"instruction": "creates token objects and pushes them to a list", "input": "JavaScript", "output": "function tokener(value, type) {\n\t\tsession.tokens.push({\n\t\t\tvalue: value,\n\t\t\ttype:  type || value,\n\t\t\tstart: null,\n\t\t\tend:   null\n\t\t});\n\t}"}, {"instruction": "Set the position of the visual highlighter.\n@param {string} elementId - The id of the DOM element that need to be highlighted\n@returns {exports}", "input": "JavaScript", "output": "function (elementId) {\n\t\t\t\tvar highlighter;\n\t\t\t\tvar targetDomElement;\n\t\t\t\tvar targetRect;\n\n\t\t\t\tif (_highLighter === null && !document.getElementById(\"ui5-highlighter\")) {\n\t\t\t\t\t_createHighLighter();\n\t\t\t\t} else {\n\t\t\t\t\t_showHighLighter();\n\t\t\t\t}\n\n\t\t\t\thighlighter = _highLighter.firstElementChild;\n\t\t\t\ttargetDomElement = document.getElementById(elementId);\n\n\t\t\t\tif (targetDomElement) {\n\t\t\t\t\ttargetRect = targetDomElement.getBoundingClientRect();\n\n\t\t\t\t\thighlighter.style.top = targetRect.top + \"px\";\n\t\t\t\t\thighlighter.style.left = targetRect.left + \"px\";\n\t\t\t\t\thighlighter.style.height = targetRect.height + \"px\";\n\t\t\t\t\thighlighter.style.width = targetRect.width + \"px\";\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t}"}, {"instruction": "return a getUserMedia Constraints", "input": "JavaScript", "output": "function getConstraintObj(deviceId, facingMode, width, height){\n      var obj = { audio: false, video: {} };\n      obj.video.deviceId = {exact: deviceId};\n      if(facingMode) {\n        obj.video.facingMode = {exact: facingMode};\n      }\n      if(width) {\n        obj.video.width = {exact: width};\n      }\n      if(height) {\n        obj.video.height = {exact: height};\n      }\n      return obj;\n    }"}, {"instruction": "Updating the marks for editor content", "input": "JavaScript", "output": "function clearMarks(editor, arr, classes) {\n    for (var i = 0; i < arr.length; ++i) {\n      var mark = arr[i];\n      if (mark instanceof CodeMirror.TextMarker) {\n        mark.clear();\n      } else {\n        editor.removeLineClass(mark, \"background\", classes.chunk);\n        editor.removeLineClass(mark, \"background\", classes.start);\n        editor.removeLineClass(mark, \"background\", classes.end);\n      }\n    }\n    arr.length = 0;\n  }"}, {"instruction": "/* search in a sorted array.\n\nreturns the index of the last element for which func returns\ngreater than zero, or array.length if no such element exists.", "input": "JavaScript", "output": "function binarySearch(array, func) {\n    // min is inclusive, max exclusive.\n    let min = 0,\n        max = array.length;\n\n    while (min < max) {\n        const mid = (min + max) >> 1;\n        const res = func(array[mid]);\n        if (res > 0) {\n            // the element at 'mid' is too big; set it as the new max.\n            max = mid;\n        } else {\n            // the element at 'mid' is too small. 'min' is inclusive, so +1.\n            min = mid + 1;\n        }\n    }\n    // presumably, min==max now.\n    return min;\n}"}, {"instruction": "todos unmarked count", "input": "JavaScript", "output": "function setBadge(todos) {\n  if (chrome.browserAction) {\n    const count = todos.filter(todo => !todo.marked).length;\n    chrome.browserAction.setBadgeText({ text: count > 0 ? count.toString() : '' });\n  }\n}"}, {"instruction": "Creates a JavaScript UTC Date corresponding to the given JavaScript Date.\n@param {Date} oDate JavaScript date object. Time related information is cut.\n@returns {Date} JavaScript date created from the date object, but this time considered as UTC date information.", "input": "JavaScript", "output": "function createUTCDate(oDate) {\n\t\t\tvar oUTCDate = new Date(Date.UTC(0, 0, 1));\n\n\t\t\toUTCDate.setUTCFullYear(oDate.getFullYear(), oDate.getMonth(), oDate.getDate());\n\n\t\t\treturn oUTCDate;\n\t\t}"}, {"instruction": "Process File\nTakes a reference to a single file, sends it to the relevant handler to be loaded and returns an object in the\nimportData format: {data: {}, images: []}\nThe data key contains JSON representing any data that should be imported\nThe image key contains references to images that will be stored (and where they will be stored)\n@param {File} file\n@returns {Promise(ImportData)}", "input": "JavaScript", "output": "function (file, ext) {\n        var fileHandler = _.find(this.handlers, function (handler) {\n            return _.includes(handler.extensions, ext);\n        });\n\n        return fileHandler.loadFile([_.pick(file, 'name', 'path')]).then(function (loadedData) {\n            // normalize the returned data\n            var importData = {};\n            importData[fileHandler.type] = loadedData;\n            return importData;\n        });\n    }"}, {"instruction": "Create a new UndoManager with an optional maximum history size.", "input": "JavaScript", "output": "function UndoManager (maxItems) {\n    this.maxItems  = maxItems || 50;\n    this.state = NORMAL_STATE;\n    this.dontCompose = false;\n    this.undoStack = [];\n    this.redoStack = [];\n  }"}, {"instruction": "Register an alias name associated with a font-icon library style ;", "input": "JavaScript", "output": "function fontSet(alias, className) {\n    config.fontSets.push({\n      alias: alias,\n      fontSet: className || alias\n    });\n    return this;\n  }"}, {"instruction": "checks the given module's functions code for invalidContent returns an array which contains the functions with invalid content", "input": "JavaScript", "output": "function(oController, viewId, aInvalidContent, fnProcessInvalidFunction) {\n\t\t\t\tvar _aInvalidControllerFunctions = [];\n\t\t\t\tObject.keys(oController).forEach(function(sProtoKey) {\n\t\t\t\t\tvar sFnContent = oController[sProtoKey].toString().replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n\n\t\t\t\t\taInvalidContent.forEach(function(sInvalidContent) {\n\t\t\t\t\t\tif (sFnContent.indexOf(sInvalidContent) > 0) {\n\t\t\t\t\t\t\tfnProcessInvalidFunction(oController.getMetadata().getName(), sProtoKey, sInvalidContent, viewId);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\n\t\t\t\t});\n\t\t\t\treturn _aInvalidControllerFunctions;\n\t\t\t}"}, {"instruction": "Private: Format a date according to the `weekday`, `day`, `month`, and `year` attribute values.  This doesn't use Intl.DateTimeFormat to avoid creating text in the user's language when the majority of the surrounding text is in English. There's currently no way to separate the language from the format in Intl.  el - The local-time element to format.  Returns a date String or null if no date formats are provided.", "input": "JavaScript", "output": "function formatDate(el: Element, date: Date) {\n  // map attribute values to strftime\n  const props = {\n    weekday: {\n      short: '%a',\n      long: '%A'\n    },\n    day: {\n      numeric: '%e',\n      '2-digit': '%d'\n    },\n    month: {\n      short: '%b',\n      long: '%B'\n    },\n    year: {\n      numeric: '%Y',\n      '2-digit': '%y'\n    }\n  }\n\n  // build a strftime format string\n  let format = isDayFirst() ? 'weekday day month year' : 'weekday month day, year'\n  for (const prop in props) {\n    const value = props[prop][el.getAttribute(prop)]\n    format = format.replace(prop, value || '')\n  }\n\n  // clean up year separator comma\n  format = format.replace(/(\\s,)|(,\\s$)/, '')\n\n  // squeeze spaces from final string\n  return strftime(date, format)\n    .replace(/\\s+/, ' ')\n    .trim()\n}"}, {"instruction": "Stringify the given `arr`.\n\n@param {Array} arr\n@param {String} prefix\n@return {String}\n@api private", "input": "JavaScript", "output": "function stringifyArray(arr, prefix) {\n  var ret = [];\n  if (!prefix) throw new TypeError('stringify expects an object');\n  for (var i = 0; i < arr.length; i++) {\n    ret.push(stringify(arr[i], prefix + '[]'));\n  }\n  return ret.join('&');\n}"}, {"instruction": "Create an interpolation binding with 4 expressions.", "input": "JavaScript", "output": "function interpolation4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n    var different = bindingUpdated4(v0, v1, v2, v3);\n    return different ?\n        prefix + stringify$1(v0) + i0 + stringify$1(v1) + i1 + stringify$1(v2) + i2 + stringify$1(v3) +\n            suffix :\n        NO_CHANGE;\n}"}, {"instruction": "}}}", "input": "JavaScript", "output": "function parseKey(e) //{{{\n      {\n        if (e.ctrlKey || e.metaKey) {\n          return true;\n        }\n        shift_down = e.shiftKey ? true : false;\n        var nudge = shift_down ? 10 : 1;\n\n        switch (e.keyCode) {\n        case 37:\n          doNudge(e, -nudge, 0);\n          break;\n        case 39:\n          doNudge(e, nudge, 0);\n          break;\n        case 38:\n          doNudge(e, 0, -nudge);\n          break;\n        case 40:\n          doNudge(e, 0, nudge);\n          break;\n        case 27:\n          if (options.allowSelect) Selection.release();\n          break;\n        case 9:\n          return true;\n        }\n\n        return false;\n      }"}, {"instruction": "Running", "input": "JavaScript", "output": "function run() {\n\treturn Promise.resolve()\n\t\t.then(loadEnvFile)\n\t\t.then(loadConfigFile)\n\t\t.then(mergeOptions)\n\t\t.then(startBroker)\n\t\t.catch(err => {\n\t\t\tlogger.error(err);\n\t\t\tprocess.exit(1);\n\t\t});\n}"}, {"instruction": "Returns number representation of object's complexity\n@method complexity\n@return {Number} complexity", "input": "JavaScript", "output": "function() {\n      return this.paths.reduce(function(total, path) {\n        return total + ((path && path.complexity) ? path.complexity() : 0);\n      }, 0);\n    }"}, {"instruction": "destructive transform (faster)", "input": "JavaScript", "output": "function (point, scale) {\n\t\tscale = scale || 1;\n\t\tpoint.x = scale * (this._a * point.x + this._b);\n\t\tpoint.y = scale * (this._c * point.y + this._d);\n\t\treturn point;\n\t}"}, {"instruction": "`URLSearchParams.prototype.has` method https://url.spec.whatwg.org/#dom-urlsearchparams-has", "input": "JavaScript", "output": "function has(name) {\n    validateArgumentsLength(arguments.length, 1);\n    var entries = getInternalParamsState(this).entries;\n    var key = name + '';\n    var i = 0;\n    while (i < entries.length) if (entries[i++].key === key) return true;\n    return false;\n  }"}, {"instruction": "Returns the number of fixed columns depending on the parameter <code>bConsiderVisibility</code>.\n\n@param {sap.ui.table.Table} oTable Instance of the table.\n@param {boolean} bConsiderVisibility If <code>false</code> the result of the <code>getComputedFixedColumnCount</code> function of the\ntable is returned. If <code>true</code> the visibility is included into the determination of the\ncount.\n@returns {int} Returns the number of fixed columns depending on the parameter <code>bConsiderVisibility</code>.", "input": "JavaScript", "output": "function(oTable, bConsiderVisibility) {\n\t\t\tvar iFixed = oTable.getComputedFixedColumnCount();\n\n\t\t\tif (!bConsiderVisibility) {\n\t\t\t\treturn iFixed;\n\t\t\t}\n\n\t\t\tif (iFixed <= 0 || oTable._bIgnoreFixedColumnCount) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar aColumns = oTable.getColumns();\n\t\t\tvar iVisibleFixedColumnCount = 0;\n\t\t\tiFixed = Math.min(iFixed, aColumns.length);\n\n\t\t\tfor (var i = 0; i < iFixed; i++) {\n\t\t\t\tif (aColumns[i].shouldRender()) {\n\t\t\t\t\tiVisibleFixedColumnCount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn iVisibleFixedColumnCount;\n\t\t}"}, {"instruction": "Subtracts matrix b from matrix a\n\n@param {mat3} out the receiving matrix\n@param {mat3} a the first operand\n@param {mat3} b the second operand\n@returns {mat3} out", "input": "JavaScript", "output": "function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}"}, {"instruction": "handle debouncing a function for better performance on scroll", "input": "JavaScript", "output": "function debounce(fn, delay) {\n        return function () {\n          var self = this, args = arguments;\n          clearTimeout(timer);\n          console.log('debounce()');\n          timer = setTimeout(function () {\n            fn.apply(self, args);\n          }, delay);\n        };\n      }"}, {"instruction": "Main generate function", "input": "JavaScript", "output": "function ngSwaggerGen(options) {\n  if (typeof options.swagger != 'string') {\n    console.error(\"Swagger file not specified in the 'swagger' option\");\n    process.exit(1);\n  }\n\n  var globalTunnel = require('global-tunnel-ng');\n  globalTunnel.initialize();\n  \n  $RefParser.bundle(options.swagger, { dereference: { circular: false } }).then(\n    data => {\n      doGenerate(data, options);\n    },\n    err => {\n      console.error(\n        `Error reading swagger location ${options.swagger}: ${err}`\n      );\n    }\n  ).catch(function (error) {\n    console.error(`Error: ${error}`);\n  });\n}"}, {"instruction": "'{' '}'\n| '{' pair (ws pair)* '}'", "input": "JavaScript", "output": "function(){\n    var obj = new nodes.Object\n      , id, val, comma, hash;\n    this.expect('{');\n    this.skipWhitespace();\n\n    while (!this.accept('}')) {\n      if (this.accept('comment')\n        || this.accept('newline')) continue;\n\n      if (!comma) this.accept(',');\n      id = this.accept('ident') || this.accept('string');\n\n      if (!id) {\n        this.error('expected \"ident\" or \"string\", got {peek}');\n      }\n\n      hash = id.val.hash;\n\n      this.skipSpacesAndComments();\n      this.expect(':');\n\n      val = this.expression();\n\n      obj.setValue(hash, val);\n      obj.setKey(hash, id.val);\n\n      comma = this.accept(',');\n      this.skipWhitespace();\n    }\n\n    return obj;\n  }"}, {"instruction": "Returns whether or not comments are inside a node type or not.\n@param {ASTNode} parent The Comment parent node.\n@param {string} nodeType The parent type to check against.\n@returns {boolean} True if the comment is inside nodeType.", "input": "JavaScript", "output": "function isParentNodeType(parent, nodeType) {\n            return parent.type === nodeType ||\n                (parent.body && parent.body.type === nodeType) ||\n                (parent.consequent && parent.consequent.type === nodeType);\n        }"}, {"instruction": "Determine if a type is abstract (not concrete).\n\nNote: This is used in place of the `graphql` version of the function in order\nto not break `instanceof` checks with Jest. This version also unwraps\nnon-null/list wrapper types.", "input": "JavaScript", "output": "function isAbstractType(type: GraphQLType): boolean {\n  const rawType = getRawType(type);\n  return (\n    rawType instanceof GraphQLInterfaceType ||\n    rawType instanceof GraphQLUnionType\n  );\n}"}, {"instruction": "success handler", "input": "JavaScript", "output": "function() {\n          socket[options.decodedPropertyName] = decoded;\n          socket.emit('authenticated');\n          if (server.$emit) {\n            server.$emit('authenticated', socket);\n          } else {\n            //try getting the current namespace otherwise fallback to all sockets.\n            var namespace = (server.nsps && socket.nsp &&\n                             server.nsps[socket.nsp.name]) ||\n                            server.sockets;\n\n            // explicit namespace\n            namespace.emit('authenticated', socket);\n          }\n        }"}, {"instruction": "Remember\n\n@param {Object} options\n@return {Remember}\n@api public", "input": "JavaScript", "output": "function Remember(options) {\n  if(!(this instanceof Remember)) return new Remember(options);\n  options = options || {};\n  this.excepts = [];\n  this.ids = {};\n  var self = this;\n\n  // localstorage namespace\n  this.namespace = options.namespace || 'remember:';\n\n  // pull from storage\n  this.pull();\n\n  this.oninput = bind(this, this.input);\n  this.onselect = bind(this, this.select);\n\n  // bindings\n  delegate.bind(document, inputs, 'input', this.oninput);\n  delegate.bind(document, buttons, 'click', this.onselect);\n}"}, {"instruction": "/*\nAuthor: Zion Orent <zorent@ics.com>\nCopyright (c) 2015 Intel Corporation.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", "input": "JavaScript", "output": "function exit()\n{\n\tconsole.log(\"Exiting\");\n\n\tif (myLEDController_obj)\n\t{\n\t\t// clear the bits we set earlier\n\t\tmyLEDController_obj.ledFullOff(3, false);\n\t\tmyLEDController_obj.ledFullOn(4, false);\n\t}\n\tmyLEDController_obj = null;\n\tif (LEDController_lib)\n\t{\n\t\tLEDController_lib.cleanUp();\n\t\tLEDController_lib = null;\n\t}\n\tprocess.exit(0);\n}"}, {"instruction": "Create a function so we can use it inside of webpack's watch function.", "input": "JavaScript", "output": "function eslintFn() {\n  return gulp\n    .src([config.files.docs.srcJS])\n    .pipe(eslint())\n    .pipe(eslint.formatEach(\"stylish\", process.stderr));\n}"}, {"instruction": "Texture Blur *****************************************", "input": "JavaScript", "output": "function LGraphTextureBlur() {\n            this.addInput(\"Texture\", \"Texture\");\n            this.addInput(\"Iterations\", \"number\");\n            this.addInput(\"Intensity\", \"number\");\n            this.addOutput(\"Blurred\", \"Texture\");\n            this.properties = {\n                intensity: 1,\n                iterations: 1,\n                preserve_aspect: false,\n                scale: [1, 1],\n                precision: LGraphTexture.DEFAULT\n            };\n        }"}, {"instruction": "/*", "input": "JavaScript", "output": "function handleError (err, vm, info) {\n  if (vm) {\n    let cur = vm;\n    while ((cur = cur.$parent)) {\n      const hooks = cur.$options.errorCaptured;\n      if (hooks) {\n        for (let i = 0; i < hooks.length; i++) {\n          try {\n            const capture = hooks[i].call(cur, err, vm, info) === false;\n            if (capture) return\n          } catch (e) {\n            globalHandleError(e, cur, 'errorCaptured hook');\n          }\n        }\n      }\n    }\n  }\n  globalHandleError(err, vm, info);\n}"}, {"instruction": "Retrieve a property from an object\n@param {Object} object\n@param {Index} index\n@return {*} Returns the value of the property\n@private", "input": "JavaScript", "output": "function _getObjectProperty (object, index) {\n  if (index.size().length !== 1) {\n    throw new DimensionError(index.size(), 1)\n  }\n\n  const key = index.dimension(0)\n  if (typeof key !== 'string') {\n    throw new TypeError('String expected as index to retrieve an object property')\n  }\n\n  return getSafeProperty(object, key)\n}"}, {"instruction": "constructor", "input": "JavaScript", "output": "function init(cols, rows, tilewidth, tileheight) {\n         this._super(me.TMXRenderer, \"init\", [cols, rows, tilewidth, tileheight]);\n\n         this.hTilewidth = tilewidth / 2;\n         this.hTileheight = tileheight / 2;\n         this.originX = this.rows * this.hTilewidth;\n       }"}, {"instruction": "setup events to detect gestures on the document", "input": "JavaScript", "output": "function setup() {\n  if(Hammer.READY) {\n    return;\n  }\n\n  // find what eventtypes we add listeners to\n  Event.determineEventTypes();\n\n  // Register all gestures inside Hammer.gestures\n  Utils.each(Hammer.gestures, function(gesture){\n    Detection.register(gesture);\n  });\n\n  // Add touch events on the document\n  Event.onTouch(Hammer.DOCUMENT, EVENT_MOVE, Detection.detect);\n  Event.onTouch(Hammer.DOCUMENT, EVENT_END, Detection.detect);\n\n  // Hammer is ready...!\n  Hammer.READY = true;\n}"}, {"instruction": "the exporter is buggy eg VCGLab | MeshLab and does not specify input_set", "input": "JavaScript", "output": "function getLastNumber(str){\n\t\t\t\t\tvar retval=\"\";\n\t\t\t\t\tfor (var i=str.length-1;i>=0;--i)\n\t\t\t\t\t\tif (str[i]>=\"0\"&&str[i]<=\"9\")\n\t\t\t\t\t\t\tretval=str[i]+retval;\n\t\t\t\t\tif (retval.length==0) return \"0\";\n\t\t\t\t\treturn retval;\n\t\t\t\t}"}, {"instruction": "\u6dfb\u52a0change\u4e8b\u4ef6\n@method change\n@param {Function} fn \u56de\u8c03\u51fd\u6570\n@param {Boolean} after \u65f6\u5019\u7ed1\u5b9aafter\u4e8b\u4ef6\n@chainable", "input": "JavaScript", "output": "function (fn, after) {\n    if (typeof fn === FUNCTION) {\n      this._subs[after ? AFTER : ON].push(fn)\n    }\n\n    return this\n  }"}, {"instruction": "Creates a new search client.\n@param {Object} options The options object\n@param {orion.serviceregistry.ServiceRegistry} options.serviceRegistry The service registry\n@name orion.searchClient.Searcher\n@class Provides API for searching the workspace.", "input": "JavaScript", "output": "function Searcher(options) {\n\t\tthis._registry= options.serviceRegistry;\n\t\tthis._commandService = options.commandService;\n\t\tthis._fileClient = options.fileService;\n\t\t//TODO clean up the search client API. Make any helper private\n\t\tthis._registry.registerService(\"orion.core.search.client\", this); //$NON-NLS-1$\n\t}"}, {"instruction": "/*\nLints the directory passed in as a command line argument", "input": "JavaScript", "output": "function lintDirectory () {\n  var shouldFix = args.hasOwnProperty('fix');\n\n  cli = new eslint.CLIEngine({ configFile: configFilePath, fix: shouldFix });\n\n  report = cli.executeOnFiles(dir);\n\n  if (shouldFix) {\n    eslint.CLIEngine.outputFixes(report);\n  }\n\n  console.log(cli.getFormatter()(report.results)); // eslint-disable-line\n\n  // End with exit code 1 if there are errors\n  // Use process.exit instead of throwing to mimic the behaviour of eslints bin\n  // We don't want a stacktrace, it would just be confusing\n  if (report.errorCount) {\n      process.exit(1); // eslint-disable-line\n  }\n}"}, {"instruction": "extended", "input": "JavaScript", "output": "function( options ){\n\n            parent.init.call( this );\n            this.options.defaults({\n                channel: 'collisions:candidates' //default channel\n            });\n            this.options( options );\n\n            this.encounters = [];\n            this.candidates = [];\n\n            this.clear();\n        }"}, {"instruction": "show notification popup", "input": "JavaScript", "output": "function showNotification(msg, type, reloadPage){\n    // defaults to false\n    reloadPage = reloadPage || false;\n\n    $('#notify_message').removeClass();\n    $('#notify_message').addClass('alert-' + type);\n    $('#notify_message').html(msg);\n    $('#notify_message').slideDown(600).delay(2500).slideUp(600, function(){\n        if(reloadPage === true){\n            location.reload();\n        }\n    });\n}"}, {"instruction": "Checks whether or not there is a transition.\n\n@param styles The cached styles to use for the calculation. If null, getComputedStyle()\nwill be used.\n\n@returns {boolean} True if there is no transition/duration; false otherwise.", "input": "JavaScript", "output": "function noTransitionFound(styles) {\n          styles = styles || window.getComputedStyle(element[0]);\n\n          return styles.transitionDuration == '0s' || (!styles.transition && !styles.transitionProperty);\n        }"}, {"instruction": "Create a directory\n@param {String} dirPath The path to create\n@param {UserOptions=} options Options for the request\n@memberof ClientInterface\n@returns {Promise} A promise that resolves when the remote path has been created\n@example\nawait client.createDirectory(\"/my/directory\");", "input": "JavaScript", "output": "function createDirectory(dirPath, options) {\n            const createOptions = merge(baseOptions, options || {});\n            return createDir.createDirectory(dirPath, createOptions);\n        }"}, {"instruction": "Counts repeated characters in a string. When 50% or more characters are the same,\nwe return false and therefore invalidate the string.\n@param {String} stringToTest The password string to check.\n@return {Boolean}", "input": "JavaScript", "output": "function characterOccurance(stringToTest) {\n    var chars = {},\n        allowedOccurancy,\n        valid = true;\n\n    stringToTest = _.toString(stringToTest);\n    allowedOccurancy = stringToTest.length / 2;\n\n    // Loop through string and accumulate character counts\n    _.each(stringToTest, function (char) {\n        if (!chars[char]) {\n            chars[char] = 1;\n        } else {\n            chars[char] += 1;\n        }\n    });\n\n    // check if any of the accumulated chars exceed the allowed occurancy\n    // of 50% of the words' length.\n    _.forIn(chars, function (charCount) {\n        if (charCount >= allowedOccurancy) {\n            valid = false;\n        }\n    });\n\n    return valid;\n}"}, {"instruction": "@\n#Crafty.map.remove\n@comp Crafty.map\n@kind Method\n\n@sign public void Crafty.map.remove(Entry entry)\n@param entry - An entry to remove from the hashmap\n\nRemove an entry from the broad phase map.\n\n@example\n~~~\nCrafty.map.remove(e);\n~~~", "input": "JavaScript", "output": "function(entry) {\n        var keys = entry.keys;\n        var obj = entry.obj;\n        var i = 0,\n            j,\n            hash;\n\n        //search in all x buckets\n        for (i = keys.x1; i <= keys.x2; i++) {\n            //insert into all y buckets\n            for (j = keys.y1; j <= keys.y2; j++) {\n                hash = (i << 16) ^ j;\n\n                if (this.map[hash]) {\n                    var cell = this.map[hash],\n                        m,\n                        n = cell.length;\n                    //loop over objs in cell and delete\n                    for (m = 0; m < n; m++)\n                        if (cell[m] && cell[m][0] === obj[0]) cell.splice(m, 1);\n                }\n            }\n        }\n\n        //mark map boundaries as dirty\n        this.boundsDirty = true;\n    }"}, {"instruction": "Add cf routes command *", "input": "JavaScript", "output": "function describeRoute(route) {\n\t\tvar host = route.Host;\n\t\tvar domain = route.DomainName;\n\t\tvar apps = route.Apps;\n\t\tvar appsNum = route.Apps.length;\n\n\t\tvar strResult = \"\\n\" + host + \"\\t\" + domain;\n\n\t\tif(appsNum != 0){\n\t\t\tstrResult += \"\\t\" + route.Apps[0].Name;\n\t\t\tif(appsNum > 1){\n\t\t\t\tfor(var i = 1; i < appsNum; i++){\n\t\t\t\t\tstrResult += \", \" + route.Apps[i].Name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn strResult;\n\t}"}, {"instruction": "Create a new item in the current project.\n\n@param baseDir {string|Directory} Full path of the directory where the item should go.\nDefaults to the project root if the entry is not valid or not within the project.\n@param initialName {string} Initial name for the item\n@param skipRename {boolean} If true, don't allow the user to rename the item\n@param isFolder {boolean} If true, create a folder instead of a file\n@return {$.Promise} A promise object that will be resolved with the File\nof the created object, or rejected if the user cancelled or entered an illegal\nfilename.", "input": "JavaScript", "output": "function createNewItem(baseDir, initialName, skipRename, isFolder) {\n        baseDir = model.getDirectoryInProject(baseDir);\n\n        if (skipRename) {\n            if(isFolder) {\n                return model.createAtPath(baseDir + initialName + \"/\");\n            }\n            return model.createAtPath(baseDir + initialName);\n        }\n        return actionCreator.startCreating(baseDir, initialName, isFolder);\n    }"}, {"instruction": "Creates a splice record and sends an array splice notification for\nthe described mutation\n\nNote: this implementation only accepts normalized paths\n\n@param {!PropertyEffectsType} inst Instance to send notifications to\n@param {Array} array The array the mutations occurred on\n@param {string} path The path to the array that was mutated\n@param {number} index Index at which the array mutation occurred\n@param {number} addedCount Number of added items\n@param {Array} removed Array of removed items\n@return {void}\n@private", "input": "JavaScript", "output": "function notifySplice(inst, array, path, index, addedCount, removed) {\n  notifySplices(inst, array, path, [{\n    index: index,\n    addedCount: addedCount,\n    removed: removed,\n    object: array,\n    type: 'splice'\n  }]);\n}"}, {"instruction": "Copies properties of `source` to `object`.\n\n@private\n@param {Object} source The object to copy properties from.\n@param {Array} props The property identifiers to copy.\n@param {Object} [object={}] The object to copy properties to.\n@param {Function} [customizer] The function to customize copied values.\n@returns {Object} Returns `object`.", "input": "JavaScript", "output": "function copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      _baseAssignValue(object, key, newValue);\n    } else {\n      _assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}"}, {"instruction": "Removes value from an array.\nPresence of value (and its position in an array) is determined via `Array.prototype.indexOf`\n@static\n@memberOf fabric.util\n@method removeFromArray\n@param {Array} array\n@param {Any} value\n@return {Array} original array", "input": "JavaScript", "output": "function removeFromArray(array, value) {\n    var idx = array.indexOf(value);\n    if (idx !== -1) {\n      array.splice(idx, 1);\n    }\n    return array;\n  }"}, {"instruction": "Executes the provided `callback` once for each enumerable own property in the\nobject and constructs a new object from the results. The `callback` is\ninvoked with three arguments:\n\n- the property value\n- the property name\n- the object being traversed\n\nProperties that are added after the call to `mapObject` will not be visited\nby `callback`. If the values of existing properties are changed, the value\npassed to `callback` will be the value at the time `mapObject` visits them.\nProperties that are deleted before being visited are not visited.\n\n@grep function objectMap()\n@grep function objMap()\n\n@param {?object} object\n@param {function} callback\n@param {*} context\n@return {?object}", "input": "JavaScript", "output": "function mapObject(object, callback, context) {\n  if (!object) {\n    return null;\n  }\n  var result = {};\n  for (var name in object) {\n    if (hasOwnProperty.call(object, name)) {\n      result[name] = callback.call(context, object[name], name, object);\n    }\n  }\n  return result;\n}"}, {"instruction": "/*\noverwrite Labels isDisplayOnly function to use the editable property of the Form\nto determine the mode.\n\nIf DisplayOnly is set explicitly on the Label, this is used.", "input": "JavaScript", "output": "function _labelIsDisplayOnly(){\n\n\t\tif (this.getDisplayOnly) {\n\t\t\tif (!this.isPropertyInitial(\"displayOnly\")) {\n\t\t\t\treturn this.getDisplayOnly();\n\t\t\t}\n\n\t\t\tvar oFormElement = this.getParent();\n\t\t\tvar oFormContainer = oFormElement.getParent();\n\n\t\t\tif (oFormContainer) {\n\t\t\t\tvar oForm = oFormContainer.getParent();\n\n\t\t\t\tif (oForm) {\n\t\t\t\t\treturn !oForm.getEditable();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\n\t}"}, {"instruction": "Checks whether the property of 2 given member expression nodes are the same\nproperty or not.\n\n@param {ASTNode} left - A member expression node to check.\n@param {ASTNode} right - Another member expression node to check.\n@returns {boolean} `true` if the member expressions have the same property.", "input": "JavaScript", "output": "function isSameProperty(left, right) {\n    if (left.property.type === \"Identifier\" &&\n        left.property.type === right.property.type &&\n        left.property.name === right.property.name &&\n        left.computed === right.computed\n    ) {\n        return true;\n    }\n\n    const lname = astUtils.getStaticPropertyName(left);\n    const rname = astUtils.getStaticPropertyName(right);\n\n    return lname !== null && lname === rname;\n}"}, {"instruction": "Reset the tracking by hiding the tooltip, the hover series state and the hover point", "input": "JavaScript", "output": "function resetTracker() {\r\n\t\t\tvar hoverSeries = chart.hoverSeries,\r\n\t\t\t\thoverPoint = chart.hoverPoint;\r\n\r\n\t\t\tif (hoverPoint) {\r\n\t\t\t\thoverPoint.onMouseOut();\r\n\t\t\t}\r\n\r\n\t\t\tif (hoverSeries) {\r\n\t\t\t\thoverSeries.onMouseOut();\r\n\t\t\t}\r\n\r\n\t\t\tif (tooltip) {\r\n\t\t\t\ttooltip.hide();\r\n\t\t\t}\r\n\r\n\t\t\thoverX = null;\r\n\t\t}"}, {"instruction": "Get the constructor for a type\n\nIf the type is not registered, use generic {module:core/abstracts.MediaObject}\n\n@function module:kurentoClient~MediaObjectCreator~getConstructor\n\n@param {external:string} type\n@param {external:Boolean} strict\n\n@return {module:core/abstracts.MediaObject}", "input": "JavaScript", "output": "function getConstructor(type, strict) {\n  var result = register.classes[type.qualifiedType] || register.abstracts[type\n      .qualifiedType] ||\n    register.classes[type.type] || register.abstracts[type.type] ||\n    register.classes[type] || register.abstracts[type];\n  if (result) return result;\n\n  if (type.hierarchy != undefined) {\n    for (var i = 0; i <= type.hierarchy.length - 1; i++) {\n      var result = register.classes[type.hierarchy[i]] || register.abstracts[\n        type.hierarchy[i]];\n      if (result) return result;\n    };\n  }\n  if (strict) {\n    var error = new SyntaxError(\"Unknown type '\" + type + \"'\")\n    error.type = type\n\n    throw error\n  }\n\n  console.warn(\"Unknown type '\", type, \"', using MediaObject instead\");\n  return register.abstracts.MediaObject;\n}"}, {"instruction": "Initialize a new Record.\nYou could either use\n```js\nvar records = new Model();\n```\n@or\n```js\nvar records = Model.new();\n```\n\n@class Model\n@method new\n@param {object} attributes - Optional: The records attributes\n\n@return {Record}", "input": "JavaScript", "output": "function(data, castType) {\n    data = data || {}\n\n    // if it's already a record\n    if (data.definition && data._exists) {\n      if (this.add) this.add(data)\n      return data\n    }\n\n    if (this.chained) {\n      var record = this.model.new()\n      if (this.definition.temporary) {\n        record.definition = this.definition\n      }\n\n      record.__chainedModel = this\n      record.set(data, castType)\n\n      this.add(record)\n\n      return record\n    }\n\n    return new this(data, castType)\n  }"}, {"instruction": "Sends the \"Complete\" request and fulfills the returned promise when the success of this request is known.\n\n@param id ID associated with the file.\n@param uploadId AWS uploadId for this file\n@param etagEntries Array of objects containing `etag` values and their associated `part` numbers.\n@returns {qq.Promise}", "input": "JavaScript", "output": "function(id, uploadId, etagEntries) {\n            var promise = new qq.Promise(),\n                body = getCompleteRequestBody(etagEntries);\n\n            getHeaders(id, uploadId, body).then(function(headers, endOfUrl) {\n                options.log(\"Submitting S3 complete multipart upload request for \" + id);\n\n                pendingCompleteRequests[id] = promise;\n                delete headers[\"Content-Type\"];\n\n                requester.initTransport(id)\n                    .withPath(endOfUrl)\n                    .withHeaders(headers)\n                    .withPayload(body)\n                    .send();\n            }, promise.failure);\n\n            return promise;\n        }"}, {"instruction": "Parses a YAML string and returns the value.\n\n@param {string} text - The YAML string to be parsed\n@param {function} [reviver] - Not currently supported. Provided for consistency with {@link JSON.parse}\n@returns {*}", "input": "JavaScript", "output": "function yamlParse (text, reviver) {\n    try {\n      return yaml.safeLoad(text);\n    }\n    catch (e) {\n      if (e instanceof Error) {\n        throw e;\n      }\n      else {\n        // https://github.com/nodeca/js-yaml/issues/153\n        throw ono(e, e.message);\n      }\n    }\n  }"}, {"instruction": "@\n#.bind\n@comp Crafty Core\n@kind Method\n\n@sign public this .bind(String eventName, Function callback)\n@param eventName - Name of the event to bind to\n@param callback - Method to execute when the event is triggered\n\nAttach the current entity (or entities) to listen for an event.\n\nCallback will be invoked when an event with the event name passed\nis triggered. Depending on the event, some data may be passed\nvia an argument to the callback function.\n\nThe first argument is the event name (can be anything) whilst the\nsecond argument is the callback. If the event has data, the\ncallback should have an argument.\n\nEvents are arbitrary and provide communication between components.\nYou can trigger or bind an event even if it doesn't exist yet.\n\nUnlike DOM events, Crafty events are executed synchronously.\n\n@example\n~~~\nthis.attr(\"triggers\", 0); //set a trigger count\nthis.bind(\"myevent\", function() {\nthis.triggers++; //whenever myevent is triggered, increment\n});\nthis.bind(\"UpdateFrame\", function() {\nthis.trigger(\"myevent\"); //trigger myevent on every frame\n});\n~~~\n\n@see .trigger, .unbind", "input": "JavaScript", "output": "function(event, callback) {\n        //  To learn how the event system functions, see the comments for Crafty._callbackMethods\n        //optimization for 1 entity\n        if (this.length === 1) {\n            this._bindCallback(event, callback);\n        } else {\n            for (var i = 0; i < this.length; i++) {\n                var e = entities[this[i]];\n                if (e) {\n                    e._bindCallback(event, callback);\n                }\n            }\n        }\n        return this;\n    }"}, {"instruction": "save entitlements", "input": "JavaScript", "output": "function setEntitlements(file, entitlements) {\n    const plistContent = plist.build(entitlements);\n\n    mkpath.sync(path.dirname(file));\n\n    fs.writeFileSync(file, plistContent, \"utf8\");\n  }"}, {"instruction": "client.getNodeServiceEvents\n\n@description retrieve a list of events associated with the activity\nbetween the node and the load balancer\n\n@param {Object}          loadBalancer      the loadBalancer or loadBalancerId\n@param {function}        callback", "input": "JavaScript", "output": "function (loadBalancer, callback) {\n    var self = this,\n        loadBalancerId =\n          loadBalancer instanceof lb.LoadBalancer ? loadBalancer.id : loadBalancer;\n\n    self._request({\n      path: urlJoin(_urlPrefix, loadBalancerId, 'nodes', 'events')\n    }, function (err, body) {\n      return err\n        ? callback(err)\n        : callback(err, body.nodeServiceEvents);\n    });\n  }"}, {"instruction": "gets an legacy lambda name", "input": "JavaScript", "output": "function getLegacyName(tuple) {\n    if (Array.isArray(tuple)) {\n      var verb = tuple[0]\n      var path = getLegacyLambdaName(tuple[1])\n      return [`${app}-production-${verb}${path}`, `${app}-staging-${verb}${path}`]\n    }\n    else {\n      var path = getLegacyLambdaName(tuple)\n      return [`${app}-production-get${path}`, `${app}-staging-get${path}`]\n    }\n  }"}, {"instruction": "Create output directory", "input": "JavaScript", "output": "function createDirectory(filenames, next) {\n        fs.exists(config.folder, function(exists) {\n          if (!exists) {\n            fs.mkdir(config.folder, function(err) {\n              if (err) {\n                next(err);\n              } else {\n                next(null, filenames);\n              }\n            });\n          } else {\n            next(null, filenames);\n          }\n        });\n      }"}, {"instruction": "}}}", "input": "JavaScript", "output": "function createDragbars(li) //{{{\n      {\n        var i;\n        for (i = 0; i < li.length; i++) {\n          dragbar[li[i]] = insertDragbar(li[i]);\n        }\n      }"}, {"instruction": "removes array item by given index", "input": "JavaScript", "output": "function shift(arr, index) {\n    for (let i = index; i < arr.length; i++) {\n        arr[i] = arr[i + 1];\n    }\n    delete arr[arr.length - 1];\n    arr.length -= 1;\n}"}, {"instruction": "Remove an article from a level.\n\n@param {Summary} summary\n@param {String|SummaryArticle} level: level to remove\n@return {Summary}", "input": "JavaScript", "output": "function removeArticle(summary, level) {\n    // Coerce to level\n    level = is.string(level)? level : level.getLevel();\n\n    var parent = summary.getParent(level);\n\n    var articles = parent.getArticles();\n    // Find the index to remove\n    var index = articles.findIndex(function(art) {\n        return art.getLevel() === level;\n    });\n    if (index === -1) {\n        return summary;\n    }\n\n    // Remove from children\n    articles = articles.remove(index);\n    parent = parent.set('articles', articles);\n\n    // Reindex the level from here\n    parent = indexArticleLevels(parent);\n\n    return mergeAtLevel(summary, parent.getLevel(), parent);\n}"}, {"instruction": "Parse Style variables to object", "input": "JavaScript", "output": "function findVariables(string) {\n  // Do not parse empty files. Otherwise gonzales.parse will fail\n  if (!string) {\n    return [];\n  }\n\n  var out = [],\n      ast = gonzales.parse(string, {\n        syntax: 'less'\n      });\n\n  ast.traverseByType('value', function(subAst) {\n    subAst.traverseByType('variable', function(node) {\n      out.push(node.content.toString());\n    });\n  });\n\n  return out;\n}"}, {"instruction": "Prefill customer fields based on URL query string", "input": "JavaScript", "output": "function (suppliedConfig, urlParams) {\n    $.each(suppliedConfig.customer_fields, function (key) {\n      if (!urlParams['customer.' + key]) return\n      suppliedConfig.customer_fields[key].prefilled = urlParams['customer.' + key];\n    });\n    return suppliedConfig\n  }"}, {"instruction": "*\nGets the selection state for a package/module.\nPackage names must end with a slash, modules must not.\nIf an ancestor package of the package/module does not exists, undefined is returned.\n@param {object} oObject The resulting hierarchy object\n@param {string} sName The name to be set in the hierarchy\n@returns {boolean} the selected state of a name", "input": "JavaScript", "output": "function (oObject, sName) {\n\t\t\tsName = sName === '/' ? '' : sName;\n\t\t\tvar aNames = sName.split('/'),\n\t\t\t\tl = aNames.length, i;\n\n\t\t\tif (l > 0) {\n\t\t\t\tfor (i = 0; oObject && i < l - 1; i++) {\n\t\t\t\t\tif (!oObject[aNames[i]]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\toObject = oObject[aNames[i]];\n\t\t\t\t}\n\t\t\t\treturn oObject[aNames[l - 1]];\n\t\t\t}\n\t\t}"}, {"instruction": "Reorder tracks in a playlist.\n@param {string} playlistId The playlist's ID\n@param {int} rangeStart The position of the first track to be reordered.\n@param {int} insertBefore The position where the tracks should be inserted.\n@param {Object} options Optional parameters, i.e. range_length and snapshot_id.\n@param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n@returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\nit contains an error object. Not returned if a callback is given.", "input": "JavaScript", "output": "function(\n    playlistId,\n    rangeStart,\n    insertBefore,\n    options,\n    callback\n  ) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(\n        {\n          range_start: rangeStart,\n          insert_before: insertBefore\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.put, callback);\n  }"}, {"instruction": "Shows an error dialog indicating that the given file could not be opened due to the given error\n@param {!FileSystemError} name\n@return {!Dialog}", "input": "JavaScript", "output": "function showFileOpenError(name, path) {\n        return Dialogs.showModalDialog(\n            DefaultDialogs.DIALOG_ID_ERROR,\n            Strings.ERROR_OPENING_FILE_TITLE,\n            StringUtils.format(\n                Strings.ERROR_OPENING_FILE,\n                StringUtils.breakableUrl(path),\n                FileUtils.getFileErrorString(name)\n            )\n        );\n    }"}, {"instruction": "list-specific helper function to set nested children's `level` prop automatically", "input": "JavaScript", "output": "function addNestedLevelProps(childNode, level) {\n  let currentLevel = level;\n\n  if (childNode.tagName) {\n    childNode.level = currentLevel;\n  }\n\n  return currentLevel;\n}"}, {"instruction": "enqueue an element to the next spot in the queue.", "input": "JavaScript", "output": "function(element, check, go) {\n      var shouldAdd = element.__queue && !element.__queue.check;\n      if (shouldAdd) {\n        queueForElement(element).push(element);\n        element.__queue.check = check;\n        element.__queue.go = go;\n      }\n      return (this.indexOf(element) !== 0);\n    }"}, {"instruction": "strips trailing slashes and compares urls", "input": "JavaScript", "output": "function _isCurrentUrl(href, currentUrl) {\n        if (!currentUrl) {\n            return false;\n        }\n\n        var strippedHref = href.replace(/\\/+$/, ''),\n            strippedCurrentUrl = currentUrl.replace(/\\/+$/, '');\n        return strippedHref === strippedCurrentUrl;\n    }"}, {"instruction": "Returns the normalized resource name from the given full resource path.\n\n@param   {string}    path - The full resource path (e.g. \"/restaurants/washington/seattle/joes-diner\")\n@returns {string}         - The normalized resource name (e.g. \"/joes-diner\")", "input": "JavaScript", "output": "function getNameFromPath (path) {\n  path = _(path).toString();\n  let lastSlash = path.substring(0, path.length - 1).lastIndexOf(\"/\");\n  if (lastSlash === -1) {\n    return normalizeName(path);\n  }\n  else {\n    return normalizeName(path.substring(lastSlash));\n  }\n}"}, {"instruction": "Construct glide.\n\n@param  {String} selector\n@param  {Object} options", "input": "JavaScript", "output": "function Glide(selector) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, Glide);\n\n    this._c = {};\n    this._t = [];\n    this._e = new EventsBus();\n\n    this.disabled = false;\n    this.selector = selector;\n    this.settings = mergeOptions(defaults, options);\n    this.index = this.settings.startAt;\n  }"}, {"instruction": "Constructs a GeoJSON FeatureCollection object. Applications typically do not call this constructor.\nIt is called by {@link GeoJSON} as GeoJSON is read.\n@alias GeoJSONFeatureCollection\n@constructor\n@classdesc Contains the data associated with a GeoJSON Feature Collection Object.\nAn object of type \"FeatureCollection\" must have a member with the name \"features\".\nThe value corresponding to \"features\" is an array. Each element in the array is a feature object as\ndefined in {@link GeoJSONFeature}.\nTo include information on the coordinate range for feature collections, a GeoJSON object may have a member\nnamed \"bbox\".\n@param {Object} features An object containing the data associated with the GeoJSON FeatureCollection\nfeatures.\n@param {Object} bbox An object containing the value of GeoJSON FeatureCollection bbox member.\n@throws {ArgumentError} If the specified mandatory features parameter is null or undefined.", "input": "JavaScript", "output": "function (features,  bbox) {\n\n            if (!features) {\n                throw new ArgumentError(\n                    Logger.logMessage(Logger.LEVEL_SEVERE, \"GeoJSONFeatureCollection\", \"constructor\",\n                        \"missingFeatures\"));\n            }\n\n            if (Object.prototype.toString.call(features) !== '[object Array]') {\n                throw new ArgumentError(\n                    Logger.logMessage(Logger.LEVEL_SEVERE, \"GeoJSONFeatureCollection\", \"constructor\",\n                        \"invalidFeatures\"));\n            }\n\n            // Documented in defineProperties below.\n            this._features = features;\n\n            // Documented in defineProperties below.\n            this._bbox = bbox;\n        }"}, {"instruction": "**********", "input": "JavaScript", "output": "function module(name, section) {\n      var module = cache[name];\n      if (!module) {\n        module = cache[name] = {\n          name: name,\n          url: (NG_DOCS.html5Mode ? '' : '#/') + section + '/' + name,\n          globals: [],\n          controllers: [],\n          directives: [],\n          services: [],\n          others: [],\n          service: function(name) {\n            var service =  cache[this.name + ':' + name];\n            if (!service) {\n              service = {name: name};\n              cache[this.name + ':' + name] = service;\n              this.services.push(service);\n            }\n            return service;\n          },\n          types: [],\n          filters: []\n        };\n        modules.push(module);\n      }\n      return module;\n    }"}, {"instruction": "Transform start/end and route into series of lines\n@param {g.point} sourcePoint start point\n@param {g.point} targetPoint end point\n@param {g.point[]} route optional list of route\n@return {g.line[]} [description]", "input": "JavaScript", "output": "function createLines(sourcePoint, targetPoint, route) {\n        // make a flattened array of all points\n        var points = [].concat(sourcePoint, route, targetPoint);\n        return points.reduce(function(resultLines, point, idx) {\n            // if there is a next point, make a line with it\n            var nextPoint = points[idx + 1];\n            if (nextPoint != null) {\n                resultLines[idx] = g.line(point, nextPoint);\n            }\n            return resultLines;\n        }, []);\n    }"}, {"instruction": "Registration", "input": "JavaScript", "output": "function supportsObject(grip, noGrip = false) {\n  const type = getGripType(grip, noGrip);\n  if (noGrip === true || !isGrip(grip)) {\n    return type == \"function\";\n  }\n\n  return type == \"Function\";\n}"}, {"instruction": "$NON-NLS-0$", "input": "JavaScript", "output": "function(item, index, ar){\t\t\t\r\n\t\t\tvar option = document.createElement(\"option\"); //$NON-NLS-0$\r\n\t\t\toption.value = item.value;\r\n\t\t\toption.appendChild(document.createTextNode(typeof item.label === \"string\" ? item.label : item.value)); //$NON-NLS-0$\r\n\t\t\tif( item.selected  ){\r\n\t\t\t\toption.selected = 'selected'; //$NON-NLS-0$\r\n\t\t\t}\r\n\t\t\tthis.select.appendChild(option);\r\n\t\t}"}, {"instruction": "Get the actual indent of node\n@param {ASTNode|Token} node Node to examine\n@param {boolean} [byLastLine=false] get indent of node's last line\n@returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\ncontains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\n`badChar` is the amount of the other indentation character.", "input": "JavaScript", "output": "function getNodeIndent(node, byLastLine) {\n            const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n            const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n            const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n            const spaces = indentChars.filter(char => char === \" \").length;\n            const tabs = indentChars.filter(char => char === \"\\t\").length;\n\n            return {\n                space: spaces,\n                tab: tabs,\n                goodChar: indentType === \"space\" ? spaces : tabs,\n                badChar: indentType === \"space\" ? tabs : spaces\n            };\n        }"}, {"instruction": "/* At this point, any content is assumed to be an URL", "input": "JavaScript", "output": "function(url)  {\n\t\t\t\t\tvar self = this,\n\t\t\t\t\t\tdeferred = $.Deferred();\n\t\t\t\t\t/* we are using load so one can specify a target with: url.html #targetelement */\n\t\t\t\t\tvar $container = $('<div></div>').load(url, function(response, status){\n\t\t\t\t\t\tif ( status !== \"error\" ) {\n\t\t\t\t\t\t\tdeferred.resolve($container.contents());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdeferred.reject();\n\t\t\t\t\t});\n\t\t\t\t\treturn deferred.promise();\n\t\t\t\t}"}, {"instruction": "Event handler for 'native.keyboardshow' event, sets keyboard.height to the\nreported height and keyboard.isOpening to true. Then calls\nkeyboardWaitForResize with keyboardShow or keyboardUpdateViewportHeight as\nthe callback depending on whether the event was triggered by a focusin or\nan orientationchange.", "input": "JavaScript", "output": "function keyboardNativeShow(e) {\n  clearTimeout(keyboardFocusOutTimer);\n  //console.log(\"keyboardNativeShow fired at: \" + Date.now());\n  //console.log(\"keyboardNativeshow window.innerHeight: \" + window.innerHeight);\n\n  if (!ionic.keyboard.isOpen || ionic.keyboard.isClosing) {\n    ionic.keyboard.isOpening = true;\n    ionic.keyboard.isClosing = false;\n  }\n\n  ionic.keyboard.height = e.keyboardHeight;\n  //console.log('nativeshow keyboard height:' + e.keyboardHeight);\n\n  if (wasOrientationChange) {\n    keyboardWaitForResize(keyboardUpdateViewportHeight, true);\n  } else {\n    keyboardWaitForResize(keyboardShow, true);\n  }\n}"}, {"instruction": "Prefixes the given path with the API's basePath, if that option is enabled and the API has a basePath.\n\n@param   {string}    path\n@returns {string}", "input": "JavaScript", "output": "function getConfiguredPath (path) {\n    if (options.useBasePath && context.api && context.api.basePath) {\n      return context.api.basePath + path;\n    }\n    else {\n      return path;\n    }\n  }"}, {"instruction": "Calls a method recoursively downwards on the tree\n\n@param   {String} functionName      the name of the function to be called\n@param   {[Array]}functionArguments optional arguments that are passed to every function\n@param   {[bool]} bottomUp          Call methods from bottom to top, defaults to false\n@param   {[bool]} skipSelf          Don't invoke the method on the class that calls it, defaults to false\n\n@returns {void}", "input": "JavaScript", "output": "function( functionName, functionArguments, bottomUp, skipSelf ) {\n\t\tvar i;\n\n\t\tif( bottomUp !== true && skipSelf !== true ) {\n\t\t\tthis[ functionName ].apply( this, functionArguments || [] );\n\t\t}\n\t\tfor( i = 0; i < this.contentItems.length; i++ ) {\n\t\t\tthis.contentItems[ i ].callDownwards( functionName, functionArguments, bottomUp );\n\t\t}\n\t\tif( bottomUp === true && skipSelf !== true ) {\n\t\t\tthis[ functionName ].apply( this, functionArguments || [] );\n\t\t}\n\t}"}, {"instruction": "PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END", "input": "JavaScript", "output": "function (obj) {\n    return function (subscriber) {\n        var obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__[\"observable\"]]();\n        if (typeof obs.subscribe !== 'function') {\n            throw new TypeError('Provided object does not correctly implement Symbol.observable');\n        }\n        else {\n            return obs.subscribe(subscriber);\n        }\n    };\n}"}, {"instruction": "targeting snapsIE >= 0.2", "input": "JavaScript", "output": "function getFailureMessage(exceptionMessage) {\n            var msg = 'Snapsie failed: ';\n            if (exceptionMessage) {\n                if (exceptionMessage ==\n                    \"Automation server can't create object\") {\n                    msg += 'Is it installed? Does it have permission to run '\n                        + 'as an add-on? See http://snapsie.sourceforge.net/';\n                }\n                else {\n                    msg += exceptionMessage;\n                }\n            }\n            else {\n                msg += 'Undocumented error';\n            }\n            return msg;\n        }"}, {"instruction": "Returns the history into formatted output depending on the passed format.\n\n@public\n@method\n@param {string} sFormat The format into which the history object will be converted. Possible values are listed in sap.ui.support.HistoryFormats.\n@name sap.ui.support.History.getFormattedHistory\n@returns {*} All analysis history objects in the correct format.", "input": "JavaScript", "output": "function (sFormat) {\n\t\t\tvar oFormattedHistory,\n\t\t\t\taHistory = this.getHistory();\n\n\t\t\tswitch (sFormat) {\n\t\t\t\tcase library.HistoryFormats.Abap:\n\t\t\t\t\toFormattedHistory = AbapHistoryFormatter.format(aHistory);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault :\n\t\t\t\t\toFormattedHistory = StringHistoryFormatter.format(aHistory);\n\t\t\t}\n\n\t\t\treturn oFormattedHistory;\n\t\t}"}, {"instruction": "Locate last brace in `str` within the key.\n\n@param {String} str\n@return {Number}\n@api private", "input": "JavaScript", "output": "function lastBraceInKey(str) {\n  var len = str.length\n    , brace\n    , c;\n  for (var i = 0; i < len; ++i) {\n    c = str[i];\n    if (']' == c) brace = false;\n    if ('[' == c) brace = true;\n    if ('=' == c && !brace) return i;\n  }\n}"}, {"instruction": "ORIGINAL SOURCE: https://github.com/getsentry/raven-js/\nGiven a child DOM element, returns a query-selector statement describing that\nand its ancestors\ne.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\n@param elem\n@returns {string}", "input": "JavaScript", "output": "function htmlTreeAsString (elem) {\n  var MAX_TRAVERSE_HEIGHT = 5\n  var MAX_OUTPUT_LEN = 80\n  var out = []\n  var height = 0\n  var len = 0\n  var separator = ' > '\n  var sepLength = separator.length\n  var nextStr\n\n  while (elem && height++ < MAX_TRAVERSE_HEIGHT) {\n    nextStr = htmlElementAsString(elem)\n    // bail out if\n    // - nextStr is the 'html' element\n    // - the length of the string that would be created exceeds MAX_OUTPUT_LEN\n    //   (ignore this limit if we are on the first iteration)\n    if (\n      nextStr === 'html' ||\n      (height > 1 &&\n       len + (out.length * sepLength) + nextStr.length >= MAX_OUTPUT_LEN)\n    ) {\n      break\n    }\n\n    out.push(nextStr)\n\n    len += nextStr.length\n    elem = elem.parentNode\n  }\n\n  return out.reverse().join(separator)\n}"}, {"instruction": "Use mouse events for entropy, if we do not have enough entropy by the time we need it, entropy will be generated by Math.random.", "input": "JavaScript", "output": "function(ev) {\n    this.count = this.count || 0;\n    if (this.count >= 256 || rng_pptr >= rng_psize) {\n      if (window.removeEventListener)\n        window.removeEventListener(\"mousemove\", onMouseMoveListener, false);\n      else if (window.detachEvent)\n        window.detachEvent(\"onmousemove\", onMouseMoveListener);\n      return;\n    }\n    try {\n      var mouseCoordinates = ev.x + ev.y;\n      rng_pool[rng_pptr++] = mouseCoordinates & 255;\n      this.count += 1;\n    } catch (e) {\n      // Sometimes Firefox will deny permission to access event properties for some reason. Ignore.\n    }\n  }"}, {"instruction": "\u6dfb\u52a0\u78b0\u649e\u76d1\u542c\n@param {Number} typeA \u78b0\u649e\u7c7b\u578bA\n@param {Number} typeB \u78b0\u649e\u7c7b\u578bB\n@param {Object} listenerConfig \u56de\u8c03\u51fd\u6570\u914d\u7f6e\n@param {Physics~collisionCallback} listenerConfig.begin \u5f00\u59cb\u63a5\u89e6\u56de\u8c03\n@param {Physics~collisionCallback} listenerConfig.preSolve \u5904\u7406\u524d\u78b0\u649e\u56de\u8c03\n@param {Physics~collisionCallback} listenerConfig.postSolve \u5904\u7406\u540e\u78b0\u649e\u56de\u8c03\n@param {Physics~collisionCallback} listenerConfig.separate \u5206\u79bb\u56de\u8c03", "input": "JavaScript", "output": "function(typeA, typeB, listenerConfig){\n            var begin = listenerConfig.begin||function(arbiter){\n                return true;\n            };\n\n            var preSolve = listenerConfig.preSolve||function(arbiter){\n                return true;\n            };\n\n            var postSolve = listenerConfig.postSolve||function(arbiter){\n\n            };\n\n            var separate = listenerConfig.separate||function(arbiter){\n\n            };\n\n            this.space.addCollisionHandler(typeA, typeB, begin, preSolve, postSolve, separate);\n        }"}, {"instruction": "Creates and initializes specified collection of extensions.\nEach extension receives access to instance of glide and rest of components.\n\n@param {Object} glide\n@param {Object} extensions\n\n@returns {Object}", "input": "JavaScript", "output": "function mount(glide, extensions, events) {\n  var components = {};\n\n  for (var name in extensions) {\n    if (isFunction(extensions[name])) {\n      components[name] = extensions[name](glide, components, events);\n    } else {\n      warn('Extension must be a function');\n    }\n  }\n\n  for (var _name in components) {\n    if (isFunction(components[_name].mount)) {\n      components[_name].mount();\n    }\n  }\n\n  return components;\n}"}, {"instruction": "Documents are considered to be out-of-sync if they are dirty and\ndo not have \"update while editing\" support\n@param {Document} doc\n@return {boolean}", "input": "JavaScript", "output": "function _docIsOutOfSync(doc) {\n        var liveDoc = _server && _server.get(doc.file.fullPath),\n            isLiveEditingEnabled = liveDoc && liveDoc.isLiveEditingEnabled();\n\n        return doc.isDirty && !isLiveEditingEnabled;\n    }"}, {"instruction": "A node in the dynamic tree. The client does not interact with this directly.\n\n@prop {AABB} aabb Enlarged AABB\n@prop {integer} height 0: leaf, -1: free node", "input": "JavaScript", "output": "function TreeNode(id) {\n  this.id = id;\n  this.aabb = new AABB();\n  this.userData = null;\n  this.parent = null;\n  this.child1 = null;\n  this.child2 = null;\n  this.height = -1;\n\n  this.toString = function() {\n    return this.id + \": \" + this.userData;\n  }\n}"}, {"instruction": "And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js", "input": "JavaScript", "output": "function ExtensionAPI(chartInstance) {\n    zrUtil.each(echartsAPIList, function (name) {\n        this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n    }, this);\n}"}, {"instruction": "Returns the default number of simultaneous requests.\n@export @public @method\n@name getDefaultSimultaneousRequests\n\n@returns {number} The default number of simultaneous requests.", "input": "JavaScript", "output": "function getDefaultSimultaneousRequests() {\n  const infoString = getBrowserInfo();\n  const info = infoString.split(' ');\n  const browserName = info[0];\n  const browserVersion = info[1];\n  const browserData = maxSimultaneousRequests[browserName];\n\n  if (!browserData) {\n    return maxSimultaneousRequests.default;\n  }\n\n  if (!browserData[browserVersion]) {\n    return browserData.default;\n  }\n\n  return browserData[browserVersion];\n}"}, {"instruction": "Hooks into React's state management and applies the componentstate\nto GoldenLayout\n\n@private\n@returns {void}", "input": "JavaScript", "output": "function( nextProps, nextState ) {\n\t\tthis._container.setState( nextState );\n\t\tthis._originalComponentWillUpdate.call( this._reactComponent, nextProps, nextState );\n\t}"}, {"instruction": "////////////////", "input": "JavaScript", "output": "function initialise() {\n\n\t    DOMReady(function () {\n\n\t    \tfor (var i = 0; i < 10; i++) {\n\t\t\t\tcreateCommandHtml(true);\n\t    \t}\n\n\t\t\t// var rellax = new Rellax('.rellax');\n\n\t    });\n\n\t    document.addEventListener('webkitAnimationEnd', onAnimationEnded);\n\n\t}"}, {"instruction": "Return unique array.\n\n@param {Array} arr\n@return {Array}\n@api private", "input": "JavaScript", "output": "function unique(arr) {\n  var ret = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (~ret.indexOf(arr[i])) continue;\n    ret.push(arr[i]);\n  }\n\n  return ret;\n}"}, {"instruction": "Special case getDefaultProps which should move into statics but requires\nautomatic merging.", "input": "JavaScript", "output": "function(Constructor, getDefaultProps) {\n      if (Constructor.getDefaultProps) {\n        Constructor.getDefaultProps = createMergedResultFunction(\n          Constructor.getDefaultProps,\n          getDefaultProps\n        );\n      } else {\n        Constructor.getDefaultProps = getDefaultProps;\n      }\n    }"}, {"instruction": "SECTION: handle `change` event", "input": "JavaScript", "output": "function shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}"}, {"instruction": "Returns all Documents that are 'open' in the UI somewhere (for now, this means open in an\ninline editor and/or a full-size editor). Only these Documents can be modified, and only\nthese Documents are synced with external changes on disk.\n@return {Array.<Document>}", "input": "JavaScript", "output": "function getAllOpenDocuments() {\n        var result = [];\n        var id;\n        for (id in _openDocuments) {\n            if (_openDocuments.hasOwnProperty(id)) {\n                result.push(_openDocuments[id]);\n            }\n        }\n        return result;\n    }"}, {"instruction": "the function is used when no update function is given", "input": "JavaScript", "output": "function defaultUpdateFunction(instance, data) {\n    if (instance.isMatreshkaArray) {\n        instance.recreate(data);\n    } else if (instance.isMatreshkaObject) {\n        instance.setData(data, { replaceData: true });\n    } else {\n        // for other objects just extend them with given data\n        nofn.assign(instance, data);\n    }\n}"}, {"instruction": "Use timeInterval to set the period between notches, in seconds,\nadding notches as the number of pixels per second increases.\n\nNote that if you override the default function, you'll almost\ncertainly want to override formatTimeCallback, primaryLabelInterval\nand/or secondaryLabelInterval so they all work together.\n\n@param: pxPerSec", "input": "JavaScript", "output": "function timeInterval(pxPerSec) {\n    var retval = 1;\n    if (pxPerSec >= 25 * 100) {\n        retval = 0.01;\n    } else if (pxPerSec >= 25 * 40) {\n        retval = 0.025;\n    } else if (pxPerSec >= 25 * 10) {\n        retval = 0.1;\n    } else if (pxPerSec >= 25 * 4) {\n        retval = 0.25;\n    } else if (pxPerSec >= 25) {\n        retval = 1;\n    } else if (pxPerSec * 5 >= 25) {\n        retval = 5;\n    } else if (pxPerSec * 15 >= 25) {\n        retval = 15;\n    } else {\n        retval = Math.ceil(0.5 / pxPerSec) * 60;\n    }\n    return retval;\n}"}, {"instruction": "field can be: 1. function 2. regular property - ex: 'prop' 3. nested property path - ex: 'nested.prop'", "input": "JavaScript", "output": "function collect(obj, field) {\n      // utility function to get nested property\n      function dig(obj, selector) {\n        var result = obj;\n        var splitter = selector.split('.');\n\n        for (var i = 0; i < splitter.length; i++) {\n          if (typeof result === 'undefined' || result === null) {\n            return undefined;\n          }\n\n          result = result[splitter[i]];\n        }\n\n        return result;\n      }\n\n      if (typeof field === 'function') return field(obj);\n      if (typeof field === 'string') return dig(obj, field);\n      return undefined;\n    }"}, {"instruction": "actually log the message", "input": "JavaScript", "output": "function logMessage(message)\n    {\n        // post the message\n        var msg = WebInspector.ConsoleMessage.create(\n            WebInspector.ConsoleMessage.MessageSource.Other,\n            messageLevel || WebInspector.ConsoleMessage.MessageLevel.Debug,\n            message);\n\n        self.console.addMessage(msg);\n        if (showConsole)\n            WebInspector.showConsole();\n    }"}, {"instruction": "textutil -convert txt -stdout foo.doc", "input": "JavaScript", "output": "function extractText( filePath, options, cb ) {\n  var result = ''\n    , error = null\n    , textutil = spawn( 'textutil', ['-convert', 'txt', '-stdout', filePath] )\n    ;\n\n  textutil.stdout.on( 'data', function( buffer ) {\n    result += buffer.toString();\n  });\n\n  textutil.stderr.on( 'error', function( buffer ) {\n    if ( !error ) {\n      error = '';\n    }\n    error += buffer.toString();\n  });\n\n  textutil.on( 'close', function( /* code */ ) {\n    if ( error ) {\n      error = new Error( 'textutil read of file named [[ ' +\n        path.basename( filePath ) + ' ]] failed: ' + error );\n      cb( error, null );\n      return;\n    }\n    cb( null, result.trim() );\n  });\n}"}, {"instruction": "Strips the .ts or .tsx file extension from a path and returns the base filename.", "input": "JavaScript", "output": "function getBasename(relativePath) {\n    const mayBeSuffix = [\".ts\", \".tsx\", \".d.ts\"];\n    let mayBePath = relativePath;\n    mayBeSuffix.map(suffix => {\n        const tmpPath = path_1.default.basename(relativePath, suffix);\n        if (tmpPath.length < mayBePath.length) {\n            mayBePath = tmpPath;\n        }\n    });\n    // Return whichever path is shorter. If they're the same length then nothing was stripped.\n    return mayBePath;\n}"}, {"instruction": "Highlight the searching keywords", "input": "JavaScript", "output": "function highlightKeywords() {\n      var q = url('?q');\n      if (q !== null) {\n        var keywords = q.split(\"%20\");\n        keywords.forEach(function (keyword) {\n          if (keyword !== \"\") {\n            $('.data-searchable *').mark(keyword);\n            $('article *').mark(keyword);\n          }\n        });\n      }\n    }"}, {"instruction": "Invoked when a splitter's dragListener fires dragStart. Calculates the splitters\nmovement area once (so that it doesn't need calculating on every mousemove event)\n\n@param   {lm.controls.Splitter} splitter\n\n@returns {void}", "input": "JavaScript", "output": "function( splitter ) {\n\t\tvar items = this._getItemsForSplitter( splitter ),\n\t\t\tminSize = this.layoutManager.config.dimensions[ this._isColumn ? 'minItemHeight' : 'minItemWidth' ];\n\t\n\t\tthis._splitterPosition = 0;\n\t\tthis._splitterMinPosition = -1 * ( items.before.element[ this._dimension ]() - minSize );\n\t\tthis._splitterMaxPosition = items.after.element[ this._dimension ]() - minSize;\n\t}"}, {"instruction": "Transparently handle JSONP. Although this does require wrapping the Request#send() method which is a bit nasty. Other alternative is to always pass the response on and include this middleware after the routes.", "input": "JavaScript", "output": "function () {\n    return function (req, res, next) {\n      var _send = res.send;\n      res.send = function (body) {\n        var callback = req.params.callback,\n            isJSONP  = res.get('Content-Type') === 'application/json' && callback;\n\n        if (body && req.method !== 'HEAD' && isJSONP) {\n          res.contentType('js');\n          body = callback + '(' + body.toString().trim() + ');';\n        }\n        _send.call(this, body);\n      };\n      next();\n    };\n  }"}, {"instruction": "Checks if `value` is a number.\n\nNote: `NaN` is considered a number. See http://es5.github.io/#x8.5.\n\n@static\n@memberOf _\n@category Objects\n@param {*} value The value to check.\n@returns {boolean} Returns `true` if the `value` is a number, else `false`.\n@example\n\n_.isNumber(8.4 * 5);\n// => true", "input": "JavaScript", "output": "function isNumber(value) {\n    return typeof value == 'number' ||\n      value && typeof value == 'object' && toString.call(value) == numberClass || false;\n  }"}, {"instruction": "------------------------------------------------------------------------------ Helpers ------------------------------------------------------------------------------ \nGets all of the Use Strict Directives in the Directive Prologue of a group of\nstatements.\n@param {ASTNode[]} statements Statements in the program or function body.\n@returns {ASTNode[]} All of the Use Strict Directives.", "input": "JavaScript", "output": "function getUseStrictDirectives(statements) {\n    const directives = [];\n\n    for (let i = 0; i < statements.length; i++) {\n        const statement = statements[i];\n\n        if (\n            statement.type === \"ExpressionStatement\" &&\n            statement.expression.type === \"Literal\" &&\n            statement.expression.value === \"use strict\"\n        ) {\n            directives[i] = statement;\n        } else {\n            break;\n        }\n    }\n\n    return directives;\n}"}, {"instruction": "Loads configuration data from a JSON file into this config object.\n@note Loading configuration will reset all existing configuration\non the object.\n@!macro nobrowser\n@param path [String] the path relative to your process's current\nworking directory to load configuration from.\n@return [AWS.Config] the same configuration object", "input": "JavaScript", "output": "function loadFromPath(path) {\n    this.clear();\n\n    var options = JSON.parse(AWS.util.readFileSync(path));\n    var fileSystemCreds = new AWS.FileSystemCredentials(path);\n    var chain = new AWS.CredentialProviderChain();\n    chain.providers.unshift(fileSystemCreds);\n    chain.resolve(function (err, creds) {\n      if (err) throw err;\n      else options.credentials = creds;\n    });\n\n    this.constructor(options);\n\n    return this;\n  }"}, {"instruction": "Apply the operators that apply to the 'browser:reload' event\n@param {Rx.Observable} subject\n@param options\n@returns {Rx.Observable}", "input": "JavaScript", "output": "function applyReloadOperators(subject, options) {\n    var operators = [\n        {\n            option: \"reloadDebounce\",\n            fnName: \"debounce\"\n        },\n        {\n            option: \"reloadThrottle\",\n            fnName: \"throttle\"\n        },\n        {\n            option: \"reloadDelay\",\n            fnName: \"delay\"\n        }\n    ];\n\n    return applyOperators(\n        operators,\n        subject,\n        options,\n        options.getIn([\"debug\", \"scheduler\"])\n    );\n}"}, {"instruction": "Remove padding from a string.", "input": "JavaScript", "output": "function unpad(str) {\n  const lines = str.split(\"\\n\");\n  const m = lines[1] && lines[1].match(/^\\s+/);\n  if (!m) {\n    return str;\n  }\n  const spaces = m[0].length;\n  return lines\n    .map(line => line.slice(spaces))\n    .join(\"\\n\")\n    .trim();\n}"}, {"instruction": "Function to format an individual tick mark\n@private", "input": "JavaScript", "output": "function(time, index, ticks, format) {\n\t\tvar me = this;\n\t\tvar adapter = me._adapter;\n\t\tvar options = me.options;\n\t\tvar formats = options.time.displayFormats;\n\t\tvar minorFormat = formats[me._unit];\n\t\tvar majorUnit = me._majorUnit;\n\t\tvar majorFormat = formats[majorUnit];\n\t\tvar majorTime = +adapter.startOf(time, majorUnit);\n\t\tvar majorTickOpts = options.ticks.major;\n\t\tvar major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;\n\t\tvar label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);\n\t\tvar tickOpts = major ? majorTickOpts : options.ticks.minor;\n\t\tvar formatter = valueOrDefault$c(tickOpts.callback, tickOpts.userCallback);\n\n\t\treturn formatter ? formatter(label, index, ticks) : label;\n\t}"}, {"instruction": "Provides a cross-browser way to set a CSS value on a CSS declaration.\n@param {!CSSStyleDeclaration} cssStyle A CSS style object.\n@param {string} propName A property name.\n@param {string} sanitizedValue Sanitized value of the property to be set\non the CSS style object.\n@supported IE8 and newer.", "input": "JavaScript", "output": "function setCssProperty(cssStyle, propName, sanitizedValue) {\n  genericMethodCall(\n      Methods.SET_PROPERTY, cssStyle,\n      cssStyle.setProperty ? 'setProperty' : 'setAttribute',\n      [propName, sanitizedValue]);\n}"}, {"instruction": "overrides the lunr tokenizer in order to define custom token separators", "input": "JavaScript", "output": "function overrideLunrTokenizer() {\n\n\t\tvar origTokenizer = lunr.tokenizer;\n\t\tvar rSeparators = /[-./#_,;\\(\\)=><|]/g;\n\n\t\tlunr.tokenizer = function(str) {\n\t\t\treturn origTokenizer.call(lunr, str).reduce( function (result, token) {\n\t\t\t\tif ( rSeparators.test(token) ) {\n\t\t\t\t\ttoken = token.replace(rSeparators, \" \");\n\t\t\t\t\tresult.push.apply(result, token.toLowerCase().split(/ +/));\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(token.toLowerCase());\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}, []);\n\t\t};\n\t\tObject.keys(origTokenizer).forEach(function (key) {\n\t\t\tlunr.tokenizer[key] = origTokenizer[key];\n\t\t});\n\t}"}, {"instruction": "Dom ready.\n\n@param {Function} fn\n\n@link https://github.com/jed/alReady.js", "input": "JavaScript", "output": "function alReady ( fn ) {\n        var add = 'addEventListener';\n        var pre = document[ add ] ? '' : 'on';\n\n        ~document.readyState.indexOf( 'm' ) ? fn() :\n            'load DOMContentLoaded readystatechange'.replace( /\\w+/g, function( type, i ) {\n                ( i ? document : window )\n                    [ pre ? 'attachEvent' : add ]\n                (\n                    pre + type,\n                    function(){ if ( fn ) if ( i < 6 || ~document.readyState.indexOf( 'm' ) ) fn(), fn = 0 },\n                    !1\n                )\n            })\n    }"}, {"instruction": "Takes a model, and searches for a value by the property\n@param  {Object} model     The dictionary to search against\n@param  {String} property  A path within a dictionary (i.e. 'window.location.href')\n@param  {Object} data      Additional information from the get request that is\npassed to functions in the child model\n@return {Promise}", "input": "JavaScript", "output": "function resolveValue(model, property) {\n  var unwrappedContext = typeof model[property] === 'function' ? model[property]() : model[property];\n  return Postmate.Promise.resolve(unwrappedContext);\n}"}, {"instruction": "Creates an SVG Cursor for the target element\n\n@param {MouseCursor} svgCursor - The cursor.", "input": "JavaScript", "output": "function setToolCursor(element, svgCursor) {\n  if (!globalConfiguration.state.showSVGCursors) {\n    return;\n  }\n  // TODO: (state vs options) Exit if cursor wasn't updated\n  // TODO: Exit if invalid options to create cursor\n\n  // Note: Max size of an SVG cursor is 128x128, default is 32x32.\n  const cursorBlob = svgCursor.getIconWithPointerSVG();\n  const mousePoint = svgCursor.mousePoint;\n\n  const svgCursorUrl = window.URL.createObjectURL(cursorBlob);\n  element.style.cursor = `url('${svgCursorUrl}') ${mousePoint}, auto`;\n\n  state.svgCursorUrl = svgCursorUrl;\n}"}, {"instruction": "/* eslint-disable valid-typeof", "input": "JavaScript", "output": "function isBrowseStorage (storage) {\n  try {\n    var testKey = '__xe_t'\n    storage.setItem(testKey, 1)\n    storage.removeItem(testKey)\n    return true\n  } catch (e) {\n    return false\n  }\n}"}, {"instruction": "for output file output", "input": "JavaScript", "output": "function formatOutput(output) {\n    var indent = '  ';\n    var pad = '  ';\n    var results = [];\n    results.push('AppDir:' + output.appDir);\n    output.suites.forEach(function(suite) {\n      results.push(pad + 'Suite: ' + suite.description + ' -- ' + suite.status);\n      pad+=indent;\n      suite.specs.forEach(function(spec) {\n        results.push(pad + spec.status + ' - ' + spec.description);\n        if (spec.failedExpectations) {\n          pad+=indent;\n          spec.failedExpectations.forEach(function (fe) {\n            results.push(pad + 'message: ' + fe.message);\n          });\n          pad=pad.substr(2);\n        }\n      });\n      pad = pad.substr(2);\n      results.push('');\n    });\n    results.push('');\n    return results.join('\\n');\n  }"}, {"instruction": "Transform url-key names into something more presentable\n@param key\n@returns {string}", "input": "JavaScript", "output": "function getKeyName(key) {\n    if (key.indexOf(\"ui\") > -1) {\n        if (key === \"ui\") {\n            return \"UI\";\n        }\n        if (key === \"ui-external\") {\n            return \"UI External\";\n        }\n    }\n    return key.substr(0, 1).toUpperCase() + key.substring(1);\n}"}, {"instruction": "The same as <code>find()</code> method, but restricts matched result\nto <code>tag</code> type\n@param {String} text\n@param {Number} pos\n@returns {Object}", "input": "JavaScript", "output": "function(text, pos) {\n\t\t\tvar result = this.find(text, pos);\n\t\t\tif (result && result.type == 'tag') {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}"}, {"instruction": "/* jshint ignore:start \nInitialize the V1 version of FlexApi\n\n@constructor Twilio.FlexApi.V1\n\n@property {Twilio.FlexApi.V1.FlexFlowList} flexFlow - flexFlow resource\n@property {Twilio.FlexApi.V1.ConfigurationList} configuration -\nconfiguration resource\n\n@param {Twilio.FlexApi} domain - The twilio domain\n /* jshint ignore:end", "input": "JavaScript", "output": "function V1(domain) {\n  Version.prototype.constructor.call(this, domain, 'v1');\n\n  // Resources\n  this._flexFlow = undefined;\n  this._configuration = undefined;\n}"}, {"instruction": "internal helper to get nodes and edges as separate collections with single iteration over elements", "input": "JavaScript", "output": "function byGroup() {\n    var nodes = this.spawn();\n    var edges = this.spawn();\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n\n      if (ele.isNode()) {\n        nodes.merge(ele);\n      } else {\n        edges.merge(ele);\n      }\n    }\n\n    return {\n      nodes: nodes,\n      edges: edges\n    };\n  }"}, {"instruction": "Canacel a preapproval payment using the preapprovalModule\n@param id\n@param callback\n@returns {*}", "input": "JavaScript", "output": "function cancelPreapprovalPayment(id) {\n    var callback = preConditions.getCallback(arguments[arguments.length - 1]);\n\n    showWarning();\n\n    return preapprovalModule.update({\n      id: id,\n      status: 'cancelled'\n    }, callback);\n  }"}, {"instruction": "Creates a catalog item from the supplied resource and adds it to the supplied parent if necessary..\n@private\n@param resource The Ckan resource\n@param rootCkanGroup The root group of all items in this Ckan hierarchy\n@param itemData The data of the item to build the catalog item from\n@param extras\n@param parent The parent group to add the item to once it's constructed - set this to rootCkanGroup for flat hierarchies.\n@returns {CatalogItem} The catalog item added, or undefined if no catalog item was added.", "input": "JavaScript", "output": "function addItem(resource, rootCkanGroup, itemData, extras, parent) {\n  var item =\n    rootCkanGroup.terria.catalog.shareKeyIndex[\n      parent.uniqueId + \"/\" + resource.id\n    ];\n  var alreadyExists = defined(item);\n\n  if (!alreadyExists) {\n    item = createItemFromResource(\n      resource,\n      rootCkanGroup,\n      itemData,\n      extras,\n      parent\n    );\n\n    if (item) {\n      parent.add(item);\n    }\n  }\n\n  return item;\n}"}, {"instruction": "\u83b7\u53d6\u6587\u7ae0\u7684\u7b80\u4ecb\uff0c\u5373\u524d5\u884c\u5185\u5bb9\n@param  {String} post \u6587\u7ae0\u5185\u5bb9\n@param  {Number} line \u884c\u6570\uff0c\u9ed8\u8ba4\u4e3a10\u884c\n@return {String}      \u6587\u7ae0\u7b80\u4ecb", "input": "JavaScript", "output": "function getPostIntro(body) {\n  let isBlankReg = /^\\s+$/,\n    start = 0;\n  return body.split('\\n').filter((item) => {\n    if (start < 5 && !isBlankReg.test(item)) {\n      start++;\n      return true;\n    }\n  }).join('\\n')\n}"}, {"instruction": "Add additional information to the armor version of an OpenPGP binary\npacket block.\n@author  Alex\n@version 2011-12-16\n@param {String} customComment (optional) additional comment to add to the armored string\n@returns {String} The header information", "input": "JavaScript", "output": "function addheader(customComment) {\n  let result = \"\";\n  if (config.show_version) {\n    result += \"Version: \" + config.versionstring + '\\r\\n';\n  }\n  if (config.show_comment) {\n    result += \"Comment: \" + config.commentstring + '\\r\\n';\n  }\n  if (customComment) {\n    result += \"Comment: \" + customComment + '\\r\\n';\n  }\n  result += '\\r\\n';\n  return result;\n}"}, {"instruction": "Flatten an array\n@param {Array} array\n@param {Array} target\n@returns Array flattened array", "input": "JavaScript", "output": "function flatten(array, target) {\n\tconst result = target || [];\n\n\tfor (let i = 0; i < array.length; ++i) {\n\t\tif (Array.isArray(array[i])) {\n\t\t\tflatten(array[i], result);\n\t\t}\n\t\telse {\n\t\t\tresult.push(array[i]);\n\t\t}\n\t}\n\n\treturn result;\n}"}, {"instruction": "The loaded method is invoked after the initial batch of data arrives from the server.\nWhen this resolves, all data which existed prior to calling $asArray() is now cached\nlocally in the array.\n\nAs a shortcut is also possible to pass resolve/reject methods directly into this\nmethod just as they would be passed to .then()\n\n@param {Function} [resolve]\n@param {Function} [reject]\n@returns a promise", "input": "JavaScript", "output": "function(resolve, reject) {\n          var promise = this._sync.ready();\n          if( arguments.length ) {\n            // allow this method to be called just like .then\n            // by passing any arguments on to .then\n            promise = promise.then.call(promise, resolve, reject);\n          }\n          return promise;\n        }"}, {"instruction": "The margins push the \"home\" region in from the sides by the specified amounts.\n@function\n@param {Object} margins - Properties (Numbers, in screen coordinates): left, top, right, bottom.", "input": "JavaScript", "output": "function(margins) {\n        $.console.assert($.type(margins) === 'object', '[Viewport.setMargins] margins must be an object');\n\n        this._margins = $.extend({\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        }, margins);\n\n        this._updateContainerInnerSize();\n        if (this.viewer) {\n            this.viewer.forceRedraw();\n        }\n    }"}, {"instruction": "Build demo", "input": "JavaScript", "output": "function buildDemo(file) {\r\n    var doc = JSON.parse(fs.read(file));\r\n\r\n    if (doc.name) {\r\n      var destination = file.replace('docs/json', \"demo/_src/pages/components\").replace(\".json\", \".md\"),\r\n        template = {\r\n          template: \"component.html\",\r\n          title: doc.name,\r\n          demo: doc.demo,\r\n          asset_root: \"../\",\r\n          year: new Date().getFullYear()\r\n        },\r\n        header = \"\";\r\n\r\n      header += '\\n\\n #' + doc.name + ' Demo';\r\n      header += '\\n<p class=\"back_link\"><a href=\"https://formstone.it/components/' + doc.name.toLowerCase().replace(/ /g, \"\") + '\">View Documentation</a></p>';\r\n\r\n      fs.write(destination, JSON.stringify(template) + header);\r\n    }\r\n  }"}, {"instruction": "Define delegates for the given class for each property/method on the indicated prototype.", "input": "JavaScript", "output": "function defineDelegates(cls, prototype) {\n  const names = Object.getOwnPropertyNames(prototype);\n  names.forEach(name => {\n    const descriptor = Object.getOwnPropertyDescriptor(prototype, name);\n    if (!descriptor) {\n      return;\n    }\n    const delegate = createDelegate(name, descriptor);\n    if (delegate) {\n      Object.defineProperty(cls.prototype, name, delegate);\n    }\n  });\n}"}, {"instruction": "Utility function that creates new folders\nbased off dir argument", "input": "JavaScript", "output": "function createDirectory(dir) {\n    if (!fs.existsSync(dir)) {\n        dryRun ? console.log(`...CREATE the '${dir}' folder.`) : fs.mkdirSync(dir);\n    }\n}"}, {"instruction": "B.2.3.2.1 CreateHTML(string, tag, attribute, value)", "input": "JavaScript", "output": "function (string, tag, attribute, value) {\n  var S = String(defined(string));\n  var p1 = '<' + tag;\n  if (attribute !== '') p1 += ' ' + attribute + '=\"' + String(value).replace(quot, '&quot;') + '\"';\n  return p1 + '>' + S + '</' + tag + '>';\n}"}, {"instruction": "Fetches the published versions of npm from the npm registry\n@return {Promise.<versions[]>} - Array of the available versions", "input": "JavaScript", "output": "function getAvailableNPMVersions () {\n  return new Promise((resolve, reject) => {\n    exec('npm view npm versions --json', (err, stdout) => {\n      if (err) {\n        let error = 'We could not show latest available versions. Try running this script again '\n        error += 'with the version you want to install (npm-windows-upgrade --npm-version 3.0.0)'\n        return reject(error)\n      }\n\n      resolve(JSON.parse(stdout))\n    })\n  })\n}"}, {"instruction": "Map a function over a list", "input": "JavaScript", "output": "function map(fn, list) {\n\n   return list\n            ? cons(fn(head(list)), map(fn,tail(list)))\n            : emptyList\n            ;\n}"}, {"instruction": "Repeats a string n times with given separator\n@param str string to repeat\n@param n number of times\n@param sep separator\n@returns {*}", "input": "JavaScript", "output": "function strRepeat(str, n, sep) {\n  if(!n) {\n    return str;\n  }\n  return str + sep + strRepeat(str, --n, sep);\n}"}, {"instruction": "Private Static Methods", "input": "JavaScript", "output": "function(value)\n\t\t\t{\n\t\t\t\tswitch (typeof value)\n\t\t\t\t{\n\t\t\t\t\tcase \"number\":\n\t\t\t\t\tcase \"boolean\":\n\t\t\t\t\t\treturn value + \"\";\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\treturn \"\\\"\" + value + \"\\\"\";\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (value === undefined)\n\t\t\t\t\t\t\treturn \"undefined\";\n\t\t\t\t\t\tif (value === null)\n\t\t\t\t\t\t\treturn \"null\";\n\t\t\t\t\t\tvar hash = value[_HASH_KEY];\n\t\t\t\t\t\tif (!hash)\n\t\t\t\t\t\t\thash = value[_HASH_KEY] = \"#\" + (++_hashCount);\n\t\t\t\t\t\treturn hash;\n\t\t\t\t}\n\t\t\t}"}, {"instruction": "if the user specifies include_docs=true, then we don't want to block the main cursor while we're fetching the doc", "input": "JavaScript", "output": "function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result);\n      if (opts.conflicts) {\n        var conflicts = pouchdbMerge.collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }"}, {"instruction": "Get session from the store.\n@private", "input": "JavaScript", "output": "function getSession(sessions, sessionId) {\n  var sess = sessions[sessionId]\n\n  if (!sess) {\n    debug('no session in MemoryStore for %s',sessionId);\n    return;\n  }\n\n  // parse\n  sess = JSON.parse(sess)\n\n  var expires = typeof sess.cookie.expires === 'string' ?\n    new Date(sess.cookie.expires) :\n    sess.cookie.expires\n\n  // destroy expired session\n  if (expires && expires <= Date.now()) {\n    debug('Session %s is Expired in MemoryStore',sessionId);\n    delete sessions[sessionId];\n    return;\n  }\n\n  return sess\n}"}, {"instruction": "jshint ;_; /* AFFIX CLASS DEFINITION\n======================", "input": "JavaScript", "output": "function (element, options) {\n    this.options = $.extend({}, $.fn.affix.defaults, options)\n    this.$window = $(window).on('scroll.affix.data-api', $.proxy(this.checkPosition, this))\n    this.$element = $(element)\n    this.checkPosition()\n  }"}, {"instruction": "\u7f16\u8bd1\u666e\u901a\u8282\u70b9\n\n@param {ANode} aNode \u8282\u70b9\u5bf9\u8c61\n@param {CompileSourceBuffer} sourceBuffer \u7f16\u8bd1\u6e90\u7801\u7684\u4e2d\u95f4buffer\n@param {Component} owner \u6240\u5c5e\u7ec4\u4ef6\u5b9e\u4f8b\u73af\u5883\n@param {Object} extra \u7f16\u8bd1\u6240\u9700\u7684\u4e00\u4e9b\u989d\u5916\u4fe1\u606f", "input": "JavaScript", "output": "function (aNode, sourceBuffer, owner) {\n        elementSourceCompiler.tagStart(sourceBuffer, aNode);\n        elementSourceCompiler.inner(sourceBuffer, aNode, owner);\n        elementSourceCompiler.tagEnd(sourceBuffer, aNode);\n    }"}, {"instruction": "Add new layers to both existing maps\n@param {Object} splitMaps\n@param {Object|Array<Object>} layers\n@returns {Array<Object>} new splitMaps", "input": "JavaScript", "output": "function addNewLayersToSplitMap(splitMaps, layers) {\n  const newLayers = Array.isArray(layers) ? layers : [layers];\n\n  if (!splitMaps || !splitMaps.length || !newLayers.length) {\n    return splitMaps;\n  }\n\n  // add new layer to both maps,\n  //  don't override, if layer.id is already in splitMaps.settings.layers\n  return splitMaps.map(settings => ({\n    ...settings,\n    layers: {\n      ...settings.layers,\n      ...newLayers.reduce(\n        (accu, newLayer) =>\n          newLayer.config.isVisible\n            ? {\n                ...accu,\n                [newLayer.id]: settings.layers[newLayer.id]\n                  ? settings.layers[newLayer.id]\n                  : generateLayerMetaForSplitViews(newLayer)\n              }\n            : accu,\n        {}\n      )\n    }\n  }));\n}"}, {"instruction": "Loads the given name (or [name, options] pair) from the given table object\nholding the available presets or plugins.\n\nReturns undefined if the preset or plugin is not available; passes through\nname unmodified if it (or the first element of the pair) is not a string.", "input": "JavaScript", "output": "function loadBuiltin(builtinTable, name) {\n  if (isArray(name) && typeof name[0] === \"string\") {\n    if (builtinTable.hasOwnProperty(name[0])) {\n      return [builtinTable[name[0]]].concat(name.slice(1));\n    }\n    return;\n  } else if (typeof name === \"string\") {\n    return builtinTable[name];\n  }\n  // Could be an actual preset/plugin module\n  return name;\n}"}, {"instruction": "The following function does what document.importNode(node, true) would do for us here; however that method is broken in Safari/1.3, so we have to emulate it.", "input": "JavaScript", "output": "function xmlImportNode(doc, node) {\n  if (node.nodeType == DOM_TEXT_NODE) {\n    return domCreateTextNode(doc, node.nodeValue);\n\n  } else if (node.nodeType == DOM_CDATA_SECTION_NODE) {\n    return domCreateCDATASection(doc, node.nodeValue);\n\n  } else if (node.nodeType == DOM_ELEMENT_NODE) {\n    var newNode = domCreateElement(doc, node.nodeName);\n    for (var i = 0; i < node.attributes.length; ++i) {\n      var an = node.attributes[i];\n      var name = an.nodeName;\n      var value = an.nodeValue;\n      domSetAttribute(newNode, name, value);\n    }\n\n    for (var c = node.firstChild; c; c = c.nextSibling) {\n      var cn = arguments.callee(doc, c);\n      domAppendChild(newNode, cn);\n    }\n\n    return newNode;\n\n  } else {\n    return domCreateComment(doc, node.nodeName);\n  }\n}"}, {"instruction": "List of client ids the user has visited", "input": "JavaScript", "output": "function (done) {\n      var index = 'users:' + user._id + ':clients'\n      Client.__client.zrevrange(index, 0, -1, function (err, ids) {\n        if (err) { return done(err) }\n        done(null, ids)\n      })\n    }"}, {"instruction": "/* -----[ Tokenizer ]-----", "input": "JavaScript", "output": "function is_alphanumeric_char(ch) {\n        ch = ch.charCodeAt(0);\n        return (ch >= 48 && ch <= 57) ||\n                (ch >= 65 && ch <= 90) ||\n                (ch >= 97 && ch <= 122);\n}"}, {"instruction": "Sets up the binding index before executing any `pureFunctionX` instructions.\n\nThe index must be restored after the pure function is executed\n\n{@link reserveSlots}", "input": "JavaScript", "output": "function moveBindingIndexToReservedSlot(offset) {\n    var currentSlot = viewData[BINDING_INDEX];\n    viewData[BINDING_INDEX] = tView.bindingStartIndex - offset;\n    return currentSlot;\n}"}, {"instruction": "@classdesc\nWraps a jCal component, adding convenience methods to add, remove and\nupdate subcomponents and properties.\n\n@class\n@alias ICAL.Component\n@param {Array|String} jCal         Raw jCal component data OR name of new\ncomponent\n@param {ICAL.Component} parent     Parent component to associate", "input": "JavaScript", "output": "function Component(jCal, parent) {\n    if (typeof(jCal) === 'string') {\n      // jCal spec (name, properties, components)\n      jCal = [jCal, [], []];\n    }\n\n    // mostly for legacy reasons.\n    this.jCal = jCal;\n\n    this.parent = parent || null;\n  }"}, {"instruction": "\u89e3\u6790\u65e5\u671f\n@param { object | string | date | string | number } date\n@returns times", "input": "JavaScript", "output": "function parseDate(value) {\n  let date = value;\n  if (!value) {\n    return new Date().getTime();\n  }\n  if (isObject(date)) {\n    date = date.value || date;\n  }\n  // array\n  if (isArray(date)) {\n    date = new Date(...date).getTime();\n  } else {\n    // string number  null \u3001''\u3001undefined\n    date = new Date(date).getTime();\n  }\n  if (date) {\n    return date;\n  }\n  console.warn('Invalid Date ', value);\n  return new Date().getTime();\n}"}, {"instruction": "Convert a raw string to an array of big-endian words\nCharacters >255 have their high-byte silently ignored.", "input": "JavaScript", "output": "function rstr2binb(input) {\n    var i, l = input.length * 8,\n      output = Array(input.length >> 2),\n      lo = output.length;\n    for (i = 0; i < lo; i += 1) {\n      output[i] = 0;\n    }\n    for (i = 0; i < l; i += 8) {\n      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);\n    }\n    return output;\n  }"}, {"instruction": "Parses a JSON string into a Javascript object.\n@function\n@param {String} string\n@returns {Object}", "input": "JavaScript", "output": "function(string) {\n            if (window.JSON && window.JSON.parse) {\n                $.parseJSON = window.JSON.parse;\n            } else {\n                // Should only be used by IE8 in non standards mode\n                $.parseJSON = function(string) {\n                    /*jshint evil:true*/\n                    //eslint-disable-next-line no-eval\n                    return eval('(' + string + ')');\n                };\n            }\n            return $.parseJSON(string);\n        }"}, {"instruction": "Traverse an object or array, and return a clone with all ISO strings parsed\ninto Date objects.\n\n@param {Object} obj\n@return {Object}", "input": "JavaScript", "output": "function traverse (input, strict) {\n  if (strict === undefined) strict = true;\n\n  if (is.object(input)) return object(input, strict);\n  if (is.array(input)) return array(input, strict);\n  return input;\n}"}, {"instruction": "createDispatchers\n\nCreate action dispatcher wrappers with bound playerID and credentials", "input": "JavaScript", "output": "function createDispatchers(\n  storeActionType,\n  innerActionNames,\n  store,\n  playerID,\n  credentials,\n  multiplayer\n) {\n  return innerActionNames.reduce((dispatchers, name) => {\n    dispatchers[name] = function(...args) {\n      let assumedPlayerID = playerID;\n\n      // In singleplayer mode, if the client does not have a playerID\n      // associated with it, we attach the currentPlayer as playerID.\n      if (!multiplayer && (playerID === null || playerID === undefined)) {\n        const state = store.getState();\n        assumedPlayerID = state.ctx.currentPlayer;\n      }\n\n      store.dispatch(\n        ActionCreators[storeActionType](\n          name,\n          args,\n          assumedPlayerID,\n          credentials\n        )\n      );\n    };\n    return dispatchers;\n  }, {});\n}"}, {"instruction": "columns is a required parameter.", "input": "JavaScript", "output": "function getIdColumns(idColumnNames, columns) {\n  if (!defined(idColumnNames)) {\n    return [];\n  }\n  return idColumnNames.map(name => getColumnWithNameIdOrIndex(name, columns));\n}"}, {"instruction": "Main function to run the sandbox", "input": "JavaScript", "output": "function main() {\n    loadDependencies();\n    setInitialData();\n    domHelpers.initDomElements();\n\n    setDataInInputField();\n    setConfigInInputField();\n    setChartSelectorType();\n    setNewChart();\n    setHandlers();\n}"}, {"instruction": "----------------------------------------------------------------------------", "input": "JavaScript", "output": "function isSubquery(str, parenthesisLevel) {\n\treturn  parenthesisLevel - (str.replace(/\\(/g,'').length - str.replace(/\\)/g,'').length )\n}"}, {"instruction": "Logs a message at a given level.\n\n@param {String} levelTag the tag associated with the level at which to log\nthe message.\n@param {String} message the message to log.\n@param {Number} bufferMaxLength the maximum size to which the message\nbuffer can grow.", "input": "JavaScript", "output": "function(levelTag, message, bufferMaxLength)\n  {\n    // add the log level tag (e.g. info, warn, etc.) to the front of the message\n    message = Util.format('%s: %s', levelTag, message);\n\n    // if the buffer is full, evict old messages\n    while (buffer.length >= bufferMaxLength)\n    {\n      buffer.shift();\n    }\n\n    // add the new message to the buffer\n    buffer.push(message);\n  }"}, {"instruction": "Read all \"data-*\" attributes from a node", "input": "JavaScript", "output": "function attributeData(node) {\n    var store = {}\n    $.each(node.attributes || emptyArray, function(i, attr){\n      if (attr.name.indexOf('data-') == 0)\n        store[camelize(attr.name.replace('data-', ''))] =\n          $.zepto.deserializeValue(attr.value)\n    })\n    return store\n  }"}, {"instruction": "PURE_IMPORTS_START _map PURE_IMPORTS_END", "input": "JavaScript", "output": "function pluck() {\n    var properties = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        properties[_i] = arguments[_i];\n    }\n    var length = properties.length;\n    if (length === 0) {\n        throw new Error('list of properties cannot be empty.');\n    }\n    return function (source) { return Object(_map__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(plucker(properties, length))(source); };\n}"}, {"instruction": "return the distance between this vector and the passed one\n@name distance\n@memberOf me.Vector3d\n@function\n@param {me.Vector2d|me.Vector3d} v\n@return {Number}", "input": "JavaScript", "output": "function (v) {\n            var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - (v.z || 0);\n            return Math.sqrt(dx * dx + dy * dy + dz * dz);\n        }"}, {"instruction": "settings: { zoomOnMouseWheel moveOnMouseMove moveOnMouseWheel } The value can be: true / false / 'shift' / 'ctrl' / 'alt'.", "input": "JavaScript", "output": "function isAvailableBehavior(behaviorToCheck, e, settings) {\n    var setting = settings[behaviorToCheck];\n    return !behaviorToCheck || (\n        setting && (!zrUtil.isString(setting) || e.event[setting + 'Key'])\n    );\n}"}, {"instruction": "Find vertex by name", "input": "JavaScript", "output": "function findVertex(name) {\r\n\t\tvar objects = alasql.databases[alasql.useid].objects;\r\n\t\tfor (var k in objects) {\r\n\t\t\tif (objects[k].name === name) {\r\n\t\t\t\treturn objects[k];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn undefined;\r\n\t}"}, {"instruction": "Disables text selection and dragging, with optional whitelist callbacks.\n@param {function(Event):boolean=} opt_allowSelectStart Unless this function\nis defined and returns true, the onselectionstart event will be\nsurpressed.\n@param {function(Event):boolean=} opt_allowDragStart Unless this function\nis defined and returns true, the ondragstart event will be surpressed.", "input": "JavaScript", "output": "function disableTextSelectAndDrag(opt_allowSelectStart, opt_allowDragStart) {\n  // Disable text selection.\n  document.onselectstart = function(e) {\n    if (!(opt_allowSelectStart && opt_allowSelectStart.call(this, e)))\n      e.preventDefault();\n  };\n\n  // Disable dragging.\n  document.ondragstart = function(e) {\n    if (!(opt_allowDragStart && opt_allowDragStart.call(this, e)))\n      e.preventDefault();\n  };\n}"}, {"instruction": "TODO: not used here anymore and needs to be moved", "input": "JavaScript", "output": "function setProviderFromEndpoint (endpoint, context, cb) {\n    var oldProvider = web3.currentProvider\n\n    if (endpoint === 'ipc') {\n      web3.setProvider(new web3.providers.IpcProvider())\n    } else {\n      web3.setProvider(new web3.providers.HttpProvider(endpoint))\n    }\n    if (web3.isConnected()) {\n      executionContext = context\n      self._updateBlockGasLimit()\n      self.event.trigger('contextChanged', ['web3'])\n      self.event.trigger('web3EndpointChanged')\n      cb()\n    } else {\n      web3.setProvider(oldProvider)\n      var alertMsg = 'Not possible to connect to the Web3 provider. '\n      alertMsg += 'Make sure the provider is running and a connection is open (via IPC or RPC).'\n      cb(alertMsg)\n    }\n  }"}, {"instruction": "Return the cadence of notches that get labels in the primary color.\nEG, return 2 if every 2nd notch should be labeled,\nreturn 10 if every 10th notch should be labeled, etc.\n\nNote that if you override the default function, you'll almost\ncertainly want to override formatTimeCallback, primaryLabelInterval\nand/or secondaryLabelInterval so they all work together.\n\n@param pxPerSec", "input": "JavaScript", "output": "function primaryLabelInterval(pxPerSec) {\n    var retval = 1;\n    if (pxPerSec >= 25 * 100) {\n        retval = 10;\n    } else if (pxPerSec >= 25 * 40) {\n        retval = 4;\n    } else if (pxPerSec >= 25 * 10) {\n        retval = 10;\n    } else if (pxPerSec >= 25 * 4) {\n        retval = 4;\n    } else if (pxPerSec >= 25) {\n        retval = 1;\n    } else if (pxPerSec * 5 >= 25) {\n        retval = 5;\n    } else if (pxPerSec * 15 >= 25) {\n        retval = 15;\n    } else {\n        retval = Math.ceil(0.5 / pxPerSec) * 60;\n    }\n    return retval;\n}"}, {"instruction": "for comparing mods before unassignment", "input": "JavaScript", "output": "function compareArray(a1, a2) {\n    if (a1.length != a2.length) return false;\n    for (var i = 0; i < a1.length; i++) {\n        if (a1[i] !== a2[i]) return false;\n    }\n    return true;\n  }"}, {"instruction": "\u5faa\u73af\u904d\u5386\u6570\u7ec4\u96c6\u5408\n\n@inner\n@param {Array} source \u6570\u7ec4\u6e90\n@param {function(Array,Number):boolean} iterator \u904d\u5386\u51fd\u6570", "input": "JavaScript", "output": "function each(source, iterator) {\n        if (source instanceof Array) {\n            for (var i = 0, len = source.length; i < len; i++) {\n                if (iterator(source[i], i) === false) {\n                    break;\n                }\n            }\n        }\n    }"}, {"instruction": "Create conversion event params to be sent to the logging endpoint\n@param  {Object} options                           Object containing values needed to build conversion event\n@param  {Object} options.attributes                Object representing user attributes and values which need to be recorded\n@param  {string} options.clientEngine              The client we are using: node or javascript\n@param  {string} options.clientVersion             The version of the client\n@param  {Object} options.configObj                 Object representing project configuration, including datafile information and mappings for quick lookup\n@param  {string} options.eventKey                  Event key representing the event which needs to be recorded\n@param  {Object} options.eventTags                 Object with event-specific tags\n@param  {Object} options.logger                    Logger object\n@param  {string} options.userId                    ID for user\n@return {Object}                                   Params to be used in conversion event logging endpoint call", "input": "JavaScript", "output": "function(options) {\n    var conversionEvent = {\n      httpVerb: HTTP_VERB,\n    };\n\n    var commonParams = getCommonEventParams(options);\n    conversionEvent.url = ENDPOINT;\n\n    var snapshot = getVisitorSnapshot(options.configObj,\n                                            options.eventKey,\n                                            options.eventTags,\n                                            options.logger);\n\n    commonParams.visitors[0].snapshots = [snapshot];\n    conversionEvent.params = commonParams;\n\n    return conversionEvent;\n  }"}, {"instruction": "Functions from lodash 4.0.0-pre \nThe base implementation of `_.pick` without support for individual\nproperty names.\n\n@private\n@param {Object} object The source object.\n@param {string[]} props The property names to pick.\n@returns {Object} Returns the new object.", "input": "JavaScript", "output": "function basePick(object, props) {\n  object = Object(object);\n\n  const { length } = props;\n  const result = {};\n  let index = -1;\n\n  while (++index < length) {\n    const key = props[index];\n    if (key in object) {\n      result[key] = object[key];\n    }\n  }\n\n  return result;\n}"}, {"instruction": "Constructs a rotation gesture recognizer.\n@alias RotationRecognizer\n@constructor\n@augments GestureRecognizer\n@classdesc A concrete gesture recognizer subclass that looks for two finger rotation gestures.\n@param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.\n@param {Function} callback An optional function to call when this gesture is recognized. If non-null, the\nfunction is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,\ne.g., <code>gestureCallback(recognizer)</code>.\n@throws {ArgumentError} If the specified target is null or undefined.", "input": "JavaScript", "output": "function (target, callback) {\n            GestureRecognizer.call(this, target, callback);\n\n            // Intentionally not documented.\n            this._rotation = 0;\n\n            // Intentionally not documented.\n            this._offsetRotation = 0;\n\n            // Intentionally not documented.\n            this.referenceAngle = 0;\n\n            // Intentionally not documented.\n            this.interpretThreshold = 20;\n\n            // Intentionally not documented.\n            this.weight = 0.4;\n\n            // Intentionally not documented.\n            this.rotationTouches = [];\n        }"}, {"instruction": "/* Ensure a date is within any min/max bounds.", "input": "JavaScript", "output": "function(inst, date) {\n\t\tvar minDate = this._getMinMaxDate(inst, \"min\"),\n\t\t\tmaxDate = this._getMinMaxDate(inst, \"max\"),\n\t\t\tnewDate = (minDate && date < minDate ? minDate : date);\n\t\treturn (maxDate && newDate > maxDate ? maxDate : newDate);\n\t}"}, {"instruction": "Checks if there are internal rules files that has to be loaded\n@returns {Promise} The returned promise resolves with an argument showing\nwhether internal rules can be loaded or not", "input": "JavaScript", "output": "function () {\n\t\t\t\tvar that = this;\n\n\t\t\t\tvar oInternalRulesPromise = new Promise(function (resolve) {\n\n\t\t\t\t\tif (that.bCanLoadInternalRules !== null) {\n\t\t\t\t\t\tresolve(that.bCanLoadInternalRules);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\n\t\t\t\t\tjQuery.ajax({\n\t\t\t\t\t\ttype: \"HEAD\",\n\t\t\t\t\t\turl: sInternalPingFilePath,\n\t\t\t\t\t\tsuccess: function () {\n\t\t\t\t\t\t\tthat.bCanLoadInternalRules = true;\n\t\t\t\t\t\t\tresolve(that.bCanLoadInternalRules);\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: function() {\n\t\t\t\t\t\t\tthat.bCanLoadInternalRules = false;\n\t\t\t\t\t\t\tresolve(that.bCanLoadInternalRules);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\treturn oInternalRulesPromise;\n\t\t\t}"}, {"instruction": "Subclass of `glob.GlobSync`\n@param {string}     pattern      Pattern to be matched.\n@param {Object}     options      `options` for `glob`\n@param {function()} shouldIgnore Method to check whether a directory should be ignored.\n@constructor", "input": "JavaScript", "output": "function GlobSync(pattern, options, shouldIgnore) {\n\n    /**\n     * We don't put this thing to argument `options` to avoid\n     * further problems, such as `options` validation.\n     *\n     * Use `Symbol` as much as possible to avoid confliction.\n     */\n    this[IGNORE] = shouldIgnore;\n\n    Sync.call(this, pattern, options);\n}"}, {"instruction": "Serializes a capabilities object. This is defined as a standalone function\nso it may be type checked (where Capabilities[Symbols.serialize] has type\nchecking disabled since it is defined with [] access on a struct).\n\n@param {!Capabilities} caps The capabilities to serialize.\n@return {!Object<string, ?>} The JSON representation of this instance.\nNote, the returned object may contain nested promised values.", "input": "JavaScript", "output": "function serialize(caps) {\n  let ret = {};\n  for (let key of caps.keys()) {\n    let cap = caps.get(key);\n    if (cap !== undefined && cap !== null) {\n      ret[key] = cap;\n    }\n  }\n  return ret;\n}"}, {"instruction": "returns false, true, or the squash value to indicate the \"default parameter url squash policy\".", "input": "JavaScript", "output": "function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }"}, {"instruction": "Output all assets using a generator\n\n@param {Generator} generator\n@param {Output} output\n@return {Promise<Output>}", "input": "JavaScript", "output": "function generateAssets(generator, output) {\n    var assets = output.getAssets();\n    var logger = output.getLogger();\n\n    // Is generator ignoring assets?\n    if (!generator.onAsset) {\n        return Promise(output);\n    }\n\n    return Promise.reduce(assets, function(out, assetFile) {\n        logger.debug.ln('copy asset \"' + assetFile + '\"');\n\n        return generator.onAsset(out, assetFile);\n    }, output);\n}"}, {"instruction": "Change current page", "input": "JavaScript", "output": "function changePage(pageNumber) {\n      var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (pageNumber > 0 && this.total > this.currentPerPage * (pageNumber - 1)) {\n        this.prevPage = this.currentPage;\n        this.currentPage = pageNumber;\n        if (emit) this.pageChanged();\n      }\n    }"}, {"instruction": "Handler for `swipestart` event. Calculates entry points of the user's tap.\n\n@param {Object} event\n@return {Void}", "input": "JavaScript", "output": "function start(event) {\n      if (!disabled && !Glide.disabled) {\n        this.disable();\n\n        var swipe = this.touches(event);\n\n        swipeSin = null;\n        swipeStartX = toInt(swipe.pageX);\n        swipeStartY = toInt(swipe.pageY);\n\n        this.bindSwipeMove();\n        this.bindSwipeEnd();\n\n        Events.emit('swipe.start');\n      }\n    }"}, {"instruction": "@ngdoc method\n@name bundler.default:default#htmlTags\n@methodOf bundler.default:default\n@function\n@description\nFunction called by view.js to build the view HTML\n\n\n@param {String} type Either start/js/css\n@param {Boolean} pack Pack with resolveAssetLink ?\n@returns {[String]} List of script tag strings", "input": "JavaScript", "output": "function htmlTags(type,pack) {\n    var dests;\n\n    // jshint validthis:true\n    if (type === 'start') {\n      return ['<script>' + this.module('start').map(function(value) { return value.content; }).join('\\n') + '</script>'];\n    }\n\n    if (pack) {\n      dests = { urls: {} };\n      // jshint validthis:true\n      dests.urls[type] = resolveAssetLink(this.client, type);\n      return [ htmlTag[type](dests) ];\n    } else {\n      // jshint validthis:true\n      var entries = this.entries(type);\n      dests = this.dests;\n      return entries.map(function(entry) {\n        return htmlTag[type](dests,entry);\n      });\n    }\n  }"}, {"instruction": "rgb \u989c\u8272\u8f6c\u6362\u6210\u6570\u7ec4", "input": "JavaScript", "output": "function rgb2arr(str) {\n  var arr = [];\n  arr.push(parseInt(str.substr(1, 2), 16));\n  arr.push(parseInt(str.substr(3, 2), 16));\n  arr.push(parseInt(str.substr(5, 2), 16));\n  return arr;\n}"}, {"instruction": "setup events to detect gestures on the document\nthis function is called when creating an new instance\n@private", "input": "JavaScript", "output": "function setup(opts) {\n  if (GestureDetector.READY) {\n    return;\n  }\n\n  // find what eventtypes we add listeners to\n  Event.determineEventTypes();\n\n  // Register all gestures inside GestureDetector.gestures\n  Utils.each(GestureDetector.gestures, function(gesture) {\n    Detection.register(gesture);\n  });\n\n  // Add touch events on the document\n  Event.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect, opts);\n  Event.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect, opts);\n\n  // GestureDetector is ready...!\n  GestureDetector.READY = true;\n}"}, {"instruction": "A Value is a comma-delimited list of Expressions In a Rule, a Value represents everything after the `:`, and before the `;`.", "input": "JavaScript", "output": "function() {\n                var e, expressions = [];\n\n                e = $(this.expression);\n                while (e) {\n                    expressions.push(e);\n                    if (! $(',')) { break; }\n                    e = $(this.expression);\n                }\n\n                if (expressions.length > 1) {\n                    return new tree.Value(expressions.map(function(e) {\n                        return e.value[0];\n                    }));\n                } else if (expressions.length === 1) {\n                    return new tree.Value(expressions);\n                }\n            }"}, {"instruction": "Creates a new extension installer dialog.\n@constructor\n@param {{install: function(url), cancel: function()}} installer The installer backend to use.", "input": "JavaScript", "output": "function InstallExtensionDialog(installer, _isUpdate) {\n        this._installer = installer;\n        this._state = STATE_CLOSED;\n        this._installResult = null;\n        this._isUpdate = _isUpdate;\n\n        // Timeout before we allow user to leave STATE_INSTALL_CANCELING without waiting for a resolution\n        // (per-instance so we can poke it for unit testing)\n        this._cancelTimeout = 10 * 1000;\n    }"}, {"instruction": "PATHS", "input": "JavaScript", "output": "function (ps) {\n        var p = paths.ps = paths.ps || {};\n        if (p[ps]) {\n            p[ps].sleep = 100;\n        } else {\n            p[ps] = {\n                sleep: 100\n            };\n        }\n        setTimeout(function () {\n            for (var key in p) if (p[has](key) && key != ps) {\n                p[key].sleep--;\n                !p[key].sleep && delete p[key];\n            }\n        });\n        return p[ps];\n    }"}, {"instruction": "Reports an error with the given message and details and throws it.\n\n@param {sap.ui.model.odata.v4.ODataMetaModel} oMetaModel\nThe OData metadata model\n@param {string} sMessage\nError message\n@param {string} sDetails\nError details\n@throws {Error}", "input": "JavaScript", "output": "function reportAndThrowError(oMetaModel, sMessage, sDetails) {\n\t\tvar oError = new Error(sDetails + \": \" + sMessage);\n\n\t\toMetaModel.oModel.reportError(sMessage, sODataMetaModel, oError);\n\t\tthrow oError;\n\t}"}, {"instruction": "/* make sligthly rotated, scaled and mirrored variants of the input image /* can be useful to increase the training set in order to get better results /* but also training time increases with numJitters", "input": "JavaScript", "output": "function makeGetJitteredFaces(fr) {\n  return function(face, numJitters) {\n    if (numJitters && (face.rows !== face.cols)) {\n      throw new Error('jittering requires the face to have the same number of rows and cols')\n    }\n    return [face].concat(!numJitters ? [] : fr.jitterImage(face, numJitters))\n  }\n}"}, {"instruction": "Return true if `node` is wrapped any one of `types`.\n@param {TxtNode} node is target node\n@param {string[]} types are wrapped target node\n@returns {boolean}", "input": "JavaScript", "output": "function isNodeWrapped(node, types) {\n    var parents = getParents(node);\n    var parentsTypes = parents.map(function(parent) {\n        return parent.type;\n    });\n    return types.some(function(type) {\n        return parentsTypes.some(function(parentType) {\n            return parentType === type;\n        });\n    });\n}"}, {"instruction": "renders slider using CSS background ;)", "input": "JavaScript", "output": "function draw(attrsModified) {\n    calc();\n    if (isChanged && value != prevValue)\n      slider.dispatchEvent(onChange);\n    isChanged = false;\n    if (!attrsModified && value == prevValue)\n      return;\n    prevValue = value;\n    var position = range ? (value - min) / range * 100 : 0;\n    var bg = '-moz-element(#__sliderthumb__) ' + position + '% no-repeat, ';\n    style(slider, { background: bg + track });\n  }"}, {"instruction": "Properties of a Timestamp.\n@memberof google.protobuf\n@interface ITimestamp\n@property {number|null} [seconds] Timestamp seconds\n@property {number|null} [nanos] Timestamp nanos\n \nConstructs a new Timestamp.\n@memberof google.protobuf\n@classdesc Represents a Timestamp.\n@implements ITimestamp\n@constructor\n@param {google.protobuf.ITimestamp=} [properties] Properties to set", "input": "JavaScript", "output": "function Timestamp(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }"}, {"instruction": "PKCS#1 (OAEP) mask generation function", "input": "JavaScript", "output": "function oaep_mgf1_arr(seed, len, hash)\n{\n    var mask = '', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(String.fromCharCode.apply(String, seed.concat([\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff])));\n        i += 1;\n    }\n\n    return mask;\n}"}, {"instruction": "/* TODO: convert to BIFF8 font struct", "input": "JavaScript", "output": "function parse_BIFF2FONTXTRA(blob, length) {\n\tblob.l += 6; // unknown\n\tblob.l += 2; // font weight \"bls\"\n\tblob.l += 1; // charset\n\tblob.l += 3; // unknown\n\tblob.l += 1; // font family\n\tblob.l += length - 13;\n}"}, {"instruction": "/* eslint-disable prefer-object-spread/prefer-object-spread", "input": "JavaScript", "output": "function ReactResolver$$1(component) {\n  return isReactComponent(component) ? component : function (props) {\n    return React.createElement(VueContainer, _extends({}, props, { component: component }));\n  };\n}"}, {"instruction": "Recursively replace @imports with the text at that url", "input": "JavaScript", "output": "function(text, url, callback) {\n    var done = function(map) {\n      callback(this.flatten(text, url, map));\n    }.bind(this);\n    this.loader.process(text, url, done);\n  }"}, {"instruction": "Get the credentials from the ~/.aws/credentials file using the AWS_PROFILE env var to get the profile.\n\n@param profile The AWS profile to get the credentials from. Default to 'default'\n@returns {Promise} Will resolve with no parameters if it succeeds, rejects with the error if it fails (no credentials found for given profile.", "input": "JavaScript", "output": "function saveCredentialsInAWS(profile = 'default') {\n    credentials = new AWS.SharedIniFileCredentials({ profile });\n    return new Promise((resolve, reject) =>\n        credentials.refresh(err => {\n            if (err) {\n                reject(err);\n            }\n            AWS.config.credentials = credentials;\n            resolve();\n        })\n    );\n}"}, {"instruction": "template that produces error message", "input": "JavaScript", "output": "function(errors) {\n      var\n        html = '<ul class=\"list\">'\n      ;\n      $.each(errors, function(index, value) {\n        html += '<li>' + value + '</li>';\n      });\n      html += '</ul>';\n      return $(html);\n    }"}, {"instruction": "Move by key\n\n@param right {boolean} direction to move", "input": "JavaScript", "output": "function (right) {\n            var p = this.coords.p_pointer;\n            var p_step = (this.options.max - this.options.min) / 100;\n            p_step = this.options.step / p_step;\n\n            if (right) {\n                p += p_step;\n            } else {\n                p -= p_step;\n            }\n\n            this.coords.x_pointer = this.toFixed(this.coords.w_rs / 100 * p);\n            this.is_key = true;\n            this.calc();\n        }"}, {"instruction": "Pauses the Current User's Playback\n@param {Object} [options] Options, for now device_id,\n@param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n@example playbackPause().then(...)\n@returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\notherwise an error. Not returned if a callback is given.", "input": "JavaScript", "output": "function(options, callback) {\n    return (\n      WebApiRequest.builder(this.getAccessToken())\n        .withPath('/v1/me/player/pause')\n        /*jshint camelcase: false */\n        .withQueryParameters(\n          options && options.device_id ? { device_id: options.device_id } : null\n        )\n        .withHeaders({ 'Content-Type': 'application/json' })\n        .build()\n        .execute(HttpManager.put, callback)\n    );\n  }"}, {"instruction": "Iterates over the available log entries.\n\nBoth parameter functions gets a log entry object passed in with the following properties:\n<ul>\n<li>{jQuery.sap.log.Level} oLogEntry.level One of the log levels FATAL, ERROR, WARNING, INFO, DEBUG, TRACE</li>\n<li>{string} oLogEntry.message     The logged message</li>\n<li>{string} oLogEntry.details     The optional details for the message</li>\n<li>{string} oLogEntry.component   The optional log component under which the message was logged</li>\n<li>{float}  oLogEntry.timestamp   The timestamp when the log entry was written</li>\n<li>{object} oLogEntry.supportInfo The optional support info object</li>\n</ul>\n\n@param {function} fnFilter Filter function to filter out irrelevant log entries.\nIf the function returns <code>true</code> the log entry is kept, otherwise it's filtered out.\n@param {string} fnCheck Check function to check the remaining log entries.\nIf the function returns <code>true</code> the checking procedure is stopped,\notherwise the next entry is passed for checking.", "input": "JavaScript", "output": "function(fnFilter, fnCheck) {\n\t\t\tvar aLog = Log.getLogEntries(); //oScope.getLoggedObjects(); /*getLoggedObjects returns only log entries with supportinfo*/\n\t\t\tvar oLogEntry;\n\t\t\tfor (var i = 0; i < aLog.length; i++) {\n\t\t\t\toLogEntry = aLog[i];\n\t\t\t\tif (fnFilter(oLogEntry)) {\n\t\t\t\t\tif (fnCheck(oLogEntry)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"}]