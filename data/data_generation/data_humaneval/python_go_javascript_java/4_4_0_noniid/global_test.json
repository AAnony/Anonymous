[{"instruction": "def create_xml_path(path, **kwargs):\n    '''\n    Start a transient domain based on the XML-file path passed to the function\n\n    :param path: path to a file containing the libvirt XML definition of the domain\n    :param connection: libvirt connection URI, overriding defaults\n\n        .. versionadded:: 2019.2.0\n    :param username: username to connect with, overriding defaults\n\n        .. versionadded:: 2019.2.0\n    :param password: password to connect with, overriding defaults\n\n        .. versionadded:: 2019.2.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virt.create_xml_path <path to XML file on the node>\n    '''\n", "input": "", "output": "    try:\n        with salt.utils.files.fopen(path, 'r') as fp_:\n            return create_xml_str(\n                salt.utils.stringutils.to_unicode(fp_.read()),\n                **kwargs\n            )\n    except (OSError, IOError):\n        return False"}, {"instruction": "Computes how much of the queue can be filled by splits with the network topology distance to a node given by\nsplitAffinity. A split with zero affinity can only fill half the queue, whereas one that matches\nexactly can fill the entire queue.", "input": "Java", "output": "private int calculateMaxPendingSplits(int splitAffinity, int totalDepth)\n    {\n        if (totalDepth == 0) {\n            return maxPendingSplitsPerTask;\n        }\n        // Use half the queue for any split\n        // Reserve the other half for splits that have some amount of network affinity\n        double queueFraction = 0.5 * (1.0 + splitAffinity / (double) totalDepth);\n        return (int) Math.ceil(maxPendingSplitsPerTask * queueFraction);\n    }"}, {"instruction": "partial : ((* -> c), *) -> * -> c", "input": "JavaScript", "output": "function partial(...args) {\n  const fn = args[0]\n  const xs = args.slice(1)\n\n  if(!isFunction(fn)) {\n    throw new TypeError('partial: Function required for first argument')\n  }\n\n  return curry(\n    Function.bind.apply(fn, [ null ].concat(xs))\n  )\n}"}, {"instruction": "// Write creates a http or udp client and attempts to write BatchPoints.\n// If a \"database not found\" error is encountered, a CREATE DATABASE\n// query is attempted when using protocol http.", "input": "go language", "output": "func (w *influxDBWriter) Write(bp influxdb.BatchPoints) error {\n\tc, err := w.initWriteClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer c.Close()\n\n\tif writeErr := c.Write(bp); writeErr != nil {\n\t\tctx := log.With(context.Background(), log.Str(log.MetricsProviderName, \"influxdb\"))\n\t\tlog.FromContext(ctx).Errorf(\"Error while writing to InfluxDB: %s\", writeErr.Error())\n\n\t\tif handleErr := w.handleWriteError(ctx, c, writeErr); handleErr != nil {\n\t\t\treturn handleErr\n\t\t}\n\t\t// Retry write after successful handling of writeErr\n\t\treturn c.Write(bp)\n\t}\n\treturn nil\n}"}]